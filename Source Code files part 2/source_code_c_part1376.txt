RT(m_sorte[cur] != -1);

            // Check that the first edge looks reasonable
            DASSERT(m_sorte[cur] < m_edgecount);

            // So we need to add the new edges to our active list
            // by pointing the last element of the active list to
            // the first new edge
            
            // If we have no active edges; then just take the
            // the new list
            if (activeE == -1)
            {
                activeE = m_sorte[cur];
            }
            else
            {
                // If we have an active list; then we must have a last edge
                // in that list
                DASSERT(iLastActiveEdge >= 0);
            
                // It better be a 'last edge' i.e. have no next ptr.
                DASSERT(m_nexte[iLastActiveEdge] == -1);

                // For sanity checking; let's make sure that what we
                // think is our last active edge is actually the last
                // active edge
#ifdef DEBUG
                {
                    // Start at the beginning of the active list
                    LONG iLastTest = activeE;

                    DASSERT(iLastTest >= 0);

                    // Iterate through list until we hit at the end
                    while (m_nexte[iLastTest] >= 0)
                        iLastTest = m_nexte[iLastTest];

                    // Check that we have what we are supposed to have
                    DASSERT(iLastTest == iLastActiveEdge);
                }
#endif // DEBUG

                // Point our last active edge to our list of new edges that all start at
                // this scan-line
                m_nexte[iLastActiveEdge] = m_sorte[cur];
            }

            // Compute the minimum scan-line ahead of 
            // us where an edge starts.
            
            // We kept track of the last start during AddEdges;
            // so we use that information to reduce this run. The following
            // assert checks that something does start at LastStart
            DASSERT(m_sortc[m_yLastStart] == m_cursortcount);

            if (cur >= m_yLastStart)
            {
                nextystart = m_yend;
            }
            else
            {
                for (LONG i = cur + 1; i <= m_yLastStart; i++)	
                {
                    if (m_sortc[i] == m_cursortcount)
                    {
                        nextystart	= i;
                        break;
                    }
                }

                // We must have found it
                DASSERT(nextystart == i);
            }
            DASSERT(nextystart <= m_yend);
        }

        // Initialize nexty to indicate the Next
        // y value where an edge begins
        nexty = nextystart;
           
        // search active edges
        LONG prev = -1;
        for (LONG i = activeE; i >= 0; i = m_nexte[i])
        {
            // Assert that we don't have loops of one
            DASSERT(m_nexte[i] != i);
            // Assert that we don't have loops of two
            DASSERT(m_nexte[m_nexte[i]] != i);

            if (cur < m_ye[i])
            {
                // If this edge ends below this scan-line
                // then it intersects the scan-line; so add it
                // to the array of intersections.
                sects[cursects++] = i;
                DASSERT(cursects <= (ULONG)m_edgecount);

                // Update our nexty value to be the minimum
                // y value where an edge ends or begins
                if (nexty > m_ye[i])		
                    nexty = m_ye[i];

                // Remember previous element in our list to 
                // handle deletions
                prev = i;
            }
            else 
            {
                // Else this edge should no longer be active; so we
                // need to delete it from the active list.

                // If we have a previous, then point 
                // it to our next else our next is the new
                // active list.
                if (prev >= 0)
                    m_nexte[prev]	= m_nexte[i];
                else						
                    activeE		= m_nexte[i];

                // In this case, the 'previous' element
                // doesn't change because the current element
                // is deleted.
            }

            // Assert that we don't have loops of one
            DASSERT(m_nexte[i] != i);
            // Assert that we don't have loops of two
            DASSERT(m_nexte[m_nexte[i]] != i);
        }

        // The 'prev' element indicates the last edge of the active list (if
        // there is one).
#ifdef DEBUG
        DASSERT(i == -1);
        if (prev == -1)
        {
            // If we have no last element; then we must not 
            // have a list at all.
            DASSERT(activeE == -1);   
        }
        else
        {
            // Else check that it really is the end of some list.
            DASSERT(m_nexte[prev] == -1);
        }
#endif // DEBUG

        // Cache it away.
        iLastActiveEdge = prev;
        
        // =================================================================================================================
        // find pairs of intersections of edges with scan-lines
        DASSERT(cursects <= (ULONG)m_edgecount);
        if (cursects > 1)
        {
            // A "region" is a set of scan-lines where 
            // no edges start and end except at the top/bottom.
            int yBeginRegion = cur;

            do 
            {
                // Sort the intersections
                SortSects (sects, m_x, cursects - 1);					

                // Winding rules involve looking at the orientation
                // of the polygons which is captured by m_ef
                if (m_fWinding)
                {
                    ULONG i=0, e1, x1;
                    LONG winding = 0;
                    do
                    {
                        LONG e2 = sects[i++];
                        if (!winding)			
                        {
                            e1 = e2;	
                            winding = m_ef[e2];	
                            x1 = m_x[e2];
                        }
                        else
                        {
                            winding += m_ef[e2];
                            
                            if (!winding)
                            {
#define DO_RASTER 1
#if DO_RASTER
                                DrawScanLine (e1, e2, cur);
#endif
                            }
                            else 
                            {
                                m_x[e2] += m_xi[e2]; //increment edge we "skip"
                            }
                        }
                    }
                    while (i < cursects);
                }
                else
                {
                    // The default case is alternating i.e. if A, B, C, D, E, F are all
                    // intersections along a scan-line then draw a segment from A to B, 
                    // from C to D, and from E to F.

                    ULONG i=0;
                    do
                    {
                        // Take the current intersection
                        ULONG e1 = sects[i];

                        // And the next
                        i++;
                        ULONG e2 = sects[i];

                        // And then jump to the next intersection
                        i++;

#if DO_RASTER
                        DrawScanLine (e1, e2, cur);
#endif
                    }
                    while (i < cursects - 1); //-1 because we do two at a time
                }
                
                // =================================================================================================================
                // increment scanline
                cur++;

                // Check if we have finished a coverage buffer; see
                // the top of this function for an explanation of this 
                // magic value
                if ((cur & dwCoverageCompletionMask) == 0)
                {
                    DASSERT(m_proc);

                    // Count of number of identical scan-lines
                    ULONG cScan;

                    // Here we want to optimize for rectangular sections;
                    // So we say: if there are only k intersections; and
                    // they are vertical; and we have more than a full vertical
                    // sub-pixel left to draw vertically; and we've already
                    // filled an entire buffer during this region: Then
                    // we optimize it.
                    DASSERT(cursects >= 2);
                    if (m_xi[sects[0]] == 0 && 
                            m_xi[sects[1]] == 0 && 
                            (nexty - cur) >= m_subpixelscale && 
                            (cur - yBeginRegion) >= m_subpixelscale)
                    {
                        // Check the rest of the intersections to
                        // see if they are vertical:
                        for (ULONG i = 2; i < cursects; i++)
                        {
                            if (m_xi[sects[i]] != 0)
                                break;
                        }

                        // Check to see if we exited the above loop early i.e.
                        // one of the edges wasn't zero.
                        if (i == cursects)
                        {

                            DASSERT(m_subpixelscale > 1);
                            DASSERT(m_subpixelshift > 0);
                            // Count the number of complete scan-lines
                            // between cur and nexty. (We add one because
                            // we already have completed one scanline.)
                            //
                            // cScan = 1 + FLOOR((nexty - cur) / m_subscalescale);
                            // is the right equation; the following is
                            // an optimization.
                            cScan = 1 + ((nexty - cur) >> m_subpixelshift);

                            // Sanity check the logic
                            DASSERT(cScan == 1 + (ULONG)((nexty - cur) / m_subpixelscale));
                        }
                        else
                        {
                            // Not all of the edges were vertical; so
                            // we can't do multiple copies of the same
                            // scan
                            DASSERT(i < cursects);
                            DASSERT(m_xi[sects[i]] != 0);
                            cScan = 1;
                        }
                    }
                    else
                    {
                        cScan = 1;
                    }
        
                    m_proc ((cur-1)>>m_subpixelshift,	
                        m_coverage.MinPix(), 
                        m_coverage.MaxPix(), 
                        m_coverage.Buffer(), 
                        m_subpixelshift, 
                        cScan,
                        m_scanlineProcData);
                    m_coverage.ExtentsClearAndReset();

                    // Increment cur if we did a multi-line
                    DASSERT(cScan >= 1);
                    if (cScan > 1)
                    {   
                        // Cur should be incremented by the number
                        // of extra scan-lines times the vertical subsampling
                        // i.e. cur += (cScan - 1) * m_subpixelscale;                    }
                        DASSERT((cScan - 1) * m_subpixelscale == ((cScan - 1) << m_subpixelshift));
                        cur += (cScan - 1) << m_subpixelshift;
                    }
                }
            }
            while (cur < nexty);
        }
        else 
        {
            // =================================================================================================================
            // increment scanline anyway
            cur++;

            // Check if we have finished a coverage buffer; see
            // the top of this function for an explanation of this 
            // magic value
            if ((cur & dwCoverageCompletionMask) == 0)
            {
                DASSERT(m_proc);
                m_proc ((cur-1)>>m_subpixelshift,	
                    m_coverage.MinPix(), 
                    m_coverage.MaxPix(), 
                    m_coverage.Buffer(), 
                    m_subpixelshift, 
                    1 /* cScan */,
                    m_scanlineProcData);
                m_coverage.ExtentsClearAndReset();

                // We have flushed our buffer; and there are
                // only 0 or 1 edges active (which is why
                // there is nothing to draw)
                DASSERT(cursects <= 1);

                // So let's just skip our scan-line forward
                // until an edge is being added or deleted
                DASSERT(cur <= nexty + 1);
                if (cur < nexty)
                    cur = nexty;
            }
        }
    }
    while (cur < m_yend);

    // We must have processed at least one row
    DASSERT(cur > 0);

    // flush the Leftover in m_coverage buffer (unless we are already
    // at a line that causes a flush automatically in the main do...while loop.
    // (see the top of this function for an explanation of this magic value)
    if ((cur & dwCoverageCompletionMask) != 0)
    {
        DASSERT(m_proc);
        m_proc ((cur-1)>>m_subpixelshift,	
            m_coverage.MinPix(), 
            m_coverage.MaxPix(), 
            m_coverage.Buffer(), 
            m_subpixelshift, 
            1 /* cScan */,
            m_scanlineProcData);
        m_coverage.ExtentsClearAndReset();
    }
    
    return;
} // ScanEdges


//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\mscanner\mlinescan.cpp ===
//************************************************************
//
// FileName:	    mlinescan.cpp
//
// Created:	    1996
//
// Author:	    Sree Kotay
// 
// Abstract:	    Line drawing AA engine
//
// Change History:
// ??/??/97 sree kotay  Wrote AA line scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************


#include "precomp.h"
#include <stdlib.h>
#include <math.h>
#include "msupport.h"
#include "MLineScan.h"

//
//  Optimize for speed here
//
#ifndef _DEBUG
#pragma optimize("ax", on)
#endif

//
//  Optimize for speed, not size for this file.
//  

// Type-safe swap functions
template <class T> 
inline void SWAP(T& left, T& right)
{
    T tTemp = left;
    left = right;
    right = tTemp;
} // Swap<class T>

// Helper function to determine if a point is clipped
#ifdef DEBUG
bool IsPointClipped(const DXRASTERPOINTINFO &pointInfo, const RECT &rectClip)
{
    if (pointInfo.Pixel.p.x < rectClip.left)
        return true;
    if (pointInfo.Pixel.p.x >= rectClip.right)
        return true;
    if (pointInfo.Pixel.p.y < rectClip.top)
        return true;
    if (pointInfo.Pixel.p.y >= rectClip.bottom)
        return true;
    return false;
} // IsPointClipped
#endif // DEBUG

// -----------------------------------------------------------------------------------------------------------------
// CLineScanner
// -----------------------------------------------------------------------------------------------------------------
CLineScanner::CLineScanner(void) :
    m_fAntiAlias(true),
    m_dwLinePattern(0),
    m_pRasterizer(NULL),
    m_oldLength(0),
    m_fXInc(false)
{
    SetAlpha(256);
} // CLineScanner

// -----------------------------------------------------------------------------------------------------------------
// SetAlpha
// -----------------------------------------------------------------------------------------------------------------
void CLineScanner::SetAlpha (ULONG alpha)
{
    // Adjust the alpha passed in to a reasonable
    // range
    alpha = min (alpha, 255);

    // Update our lookup table for alpha values
    for (ULONG i = 1; i <= 256; i++)	
        m_rgAlphaTable[i] = (BYTE)((i*alpha)>>8);

    DASSERT(m_rgAlphaTable[256] == alpha);
    
    m_rgAlphaTable[0] = 0;
    m_dwAlpha = alpha;
} // SetAlpha

// -----------------------------------------------------------------------------------------------------------------
// ClipRealLine
// -----------------------------------------------------------------------------------------------------------------
bool CLineScanner::ClipRealLine(float &x1, float &y1, float &x2, float &y2)
{
    float clipMinX = (float)m_clipRect.left;
    float clipMinY = (float)m_clipRect.top;	

    // We want to clip based on "inclusive numbers". The normal
    // GDI clip rect is exclusive for right and bottom. So we
    // subtract a little to make it inclusive.
    float clipMaxX = (float)m_clipRect.right - 0.001f;
    float clipMaxY = (float)m_clipRect.bottom - 0.001f;

    // If we are anti-aliased; then there may be some spillover
    // from core pixels that are actually outside out true bbox.
    // The solution here is to artificially increase the size of our clipRect
    // and then explicitly perform clip-checks before we call SetPixel
    //
    // If we are not Anti-aliased, we do the same thing; because rounding
    // can cause pixels from outside the clipRect to be rounded inside.
    clipMinX--;
    clipMinY--;
    clipMaxX++;
    clipMaxY++;

#define RIGHT   (char) 0x01
#define LEFT    (char) 0x02
#define ABOVE   (char) 0x04
#define BELOW   (char) 0x08
    
#define REGION(reg, xc, yc)	\
    {	                        \
    reg = 0;                    \
    if (xc > clipMaxX)		\
        reg |= RIGHT;           \
    else if (xc < clipMinX)	\
        reg |= LEFT;            \
    if (yc > clipMaxY)		\
        reg |= BELOW;           \
    else if (yc < clipMinY)	\
        reg |= ABOVE;           \
    }
    
    // Compute position flags for each end point
    DWORD reg1, reg2;
    REGION (reg1, x1, y1);
    REGION (reg2, x2, y2);

    // If no flags, then both points are inside
    // the clipRect i.e. no clipping
    if (reg1 == 0 && reg2 == 0)		
        return true;

    // While there are any flags, we need to do some clipping
    // If we hit here, we must have some clipping to do
    // (this single or trick reduces the number of conditions checked)
    DASSERT(reg1 | reg2);

    // Iterate 
    LONG passes = 0; // This is bogus but I don't know why it was added <kd>
    do
    {
        passes++;	
        if (passes > 8)
        {
            // TODO: need to figure out when this happens and
            // to fix it right. <kd>

            return (false);	// hack because of this routine
        }

        // If both points are to the left, right, etc
        // then clip the entire line
        if (reg1 & reg2)	
            return (false);	// Line outside rect.

        // Normalize so that reg1 is outside 
        if (reg1 == 0) 
        {
            // Swap reg1 and reg2; don't use
            // the swap macro since that goes through 
            // a float conversion; ick.
            DWORD regT = reg1;
            reg1 = reg2;
            reg2 = regT;

            SWAP (x1, x2); 
            SWAP (y1, y2);
        }

        // Reg1 (i.e. x1, y1 is outside of the cliprect).
        DASSERT(reg1 != 0);

        // There are 4 cases, maybe we should use a switch..
        // Regardless, this tries to remove one bit from
        // reg1 by clipping the line to one of the 4 clip
        // edges.
        if (reg1 & LEFT) 
        {
            if (x2 != x1)		
                y1 +=  ((y2 - y1) * (clipMinX - x1)) / (x2 - x1);
            x1 = clipMinX;
        }
        else if (reg1 & RIGHT) 
        {
            if (x2 != x1)		
                y1 += ((y2 - y1) * (clipMaxX - x1)) / (x2 - x1);
            x1 = clipMaxX;
        }
        else if (reg1 & BELOW) 
        {
            if (y2 != y1)
                x1 +=  ((x2 - x1) * (clipMaxY - y1)) / (y2 - y1);
            y1 = clipMaxY;
        }
        else if (reg1 & ABOVE) 
        {
            if (y2 != y1)		
                x1 +=  ((x2 - x1) * (clipMinY - y1)) / (y2 - y1);
            y1 = clipMinY;
        }
                
        // Recompute region for reg1 (i.e. reg2 hasn't changed)
        // Is this really necessary? Can't we just mask off the appropriate
        // bit?
        REGION(reg1, x1, y1);
                    
    } while (reg1 | reg2);

    DASSERT(reg1 == 0);
    DASSERT(reg2 == 0);
    return true;
    
} // ClipRealLine

// -----------------------------------------------------------------------------------------------------------------
// LowLevelVerticalLine - We now treat the line as being inclusive/inclusive
// i.e. we render completely from SY to EY including the endpoints.
// -----------------------------------------------------------------------------------------------------------------
void CLineScanner::LowLevelVerticalLine (LONG slope, LONG sx, LONG sy, LONG ey)
{
#define _floorerr(a)    (((a)-FIX_FLOOR(a))>>8)
#define _ceilerr(a)     ((FIX_CEIL(a)-(a))>>8)
    
    ULONG pattern = LinePattern();
    
    if (!AntiAlias())
    {
        LONG start = roundfix2int(sy);
        LONG end = roundfix2int(ey);   

        // For Aliased lines, sy and ey are not perfectly clipped to the clipRect 
        // because precision errors can cause us to miss pixels when
        // we are asked to render with a clip rect
        while (start < m_clipRect.top)
        {
            // We should be pretty close here..
            DASSERT((m_clipRect.top - start) < 2);

            // Just increment out values without rendering
            sx = sx + slope;
            start++;
            pattern = RotateBitsLeft(pattern);
        }
        while (end >= m_clipRect.bottom)
        {
            // We should be pretty close here..
            DASSERT((m_clipRect.bottom - end) < 2);

            end--;
        }

        m_PointInfo.Weight = 255;     // It's all solid
        while (start <= end)
        {
            if (pattern & 0x80000000)
            {
                m_PointInfo.Pixel.p.x   = roundfix2int(sx);

                // We need to explicitly check against the clip-rect 
                // because we intentionally allow end-points to be slightly
                // extend past it. This compensates for the non-linear
                // rounding whereby a mathematical pixel that lies outside
                // the clip-rect can get "rounded" inside the clip-rect.
                if (m_PointInfo.Pixel.p.x >= m_clipRect.left &&
                        m_PointInfo.Pixel.p.x <  m_clipRect.right)
                {
                    m_PointInfo.Pixel.p.y   = start;
                    DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                    m_pRasterizer->SetPixel(&m_PointInfo);
                }
            }
            sx = sx + slope;
            start++;
            pattern = RotateBitsLeft(pattern);
        }
        SetLinePattern(pattern);
        return;
    }

    ///////////////////////////////////////////////
    // We are now in the Anti-Aliased case...
    //

    LONG start         = uff (FIX_FLOOR(sy));
    LONG end           = uff (FIX_CEIL(ey));

    LONG xval          = m_startFix;

    // Keep track of whether our line endpoints are real endpoints
    // or whether they have been clipped by the clipRect
    LONG first = start;
    LONG last = end;

    // For Anti-Aliased lines, our lines are not perfectly clipped to
    // the m_clipRect. This is to allow 'bleed' from pixels that are just outside
    // of the m_clipRect to be rendered.
    //
    // As a result, we need to clip explicitly to m_clipRect here.
    while (start < m_clipRect.top)
    {
        // We should be pretty close here..
        DASSERT((m_clipRect.top - start) < 2);

        // Just increment out values without rendering
        xval = xval + slope;
        sx = sx + slope;
        start++;
    }
    while (end >= m_clipRect.bottom)
    {
        // We should be pretty close here..
        DASSERT((m_clipRect.bottom - end) < 2);

        end--;
    }

    
    while (start <= end)
    {
        if (pattern & 0x80000000)
        {
            LONG fx1           = xval - m_cpixLineWidth;
            LONG fx2           = xval + m_cpixLineWidth;
            LONG fx3           = fx1 - (slope>>2);
            LONG fx4           = fx2 - (slope>>2);
            fx1                 = fx1 - (slope>>1) - (slope>>2);
            fx2                 = fx2 - (slope>>1) - (slope>>2);
            
            
            LONG xs, xe, xc;
            LONG errs, erre, errc;
            if (fx3 > fx1)      
            {
                errs            = _ceilerr      (fx1)>>1;
                erre            = _floorerr (fx4)>>1;
                xs              = uff (fx1);
                xe              = uff (fx4);
                if (xe == xs+1)
                {
                    errs        += _ceilerr             (fx3)>>1;
                    erre        += _floorerr    (fx2)>>1;
                    errc         = 0;
                }
                else
                {
                    errc        = min ((fx2 - fx3)>>8, 256);
                    xc          = (xe+xs)>>1;
                }
            }
            else
            {
                errs            = _ceilerr      (fx3)>>1;
                erre            = _floorerr (fx2)>>1;
                xs                      = uff (fx3);
                xe                      = uff (fx2);
                if (xe == xs+1)
                {
                    errs        += _ceilerr             (fx1)>>1;
                    erre        += _floorerr    (fx4)>>1;
                    errc         = 0;
                }
                else
                {
                    errc        = min ((fx4 - fx1)>>8, 256);
                    xc          = (xe+xs)>>1;
                }
            }
            
            // The purpose of this logic is to support
            // cases where a line may start on the middle of
            // a pixel; and it scales the alpha by what percentage
            // DOWN we are starting.. i.e. if we are starting half-way 
            // into sy, then scale by 1/2. 
            //
            // TODO: It doesn't take into account if what fraction of
            // sx we are starting at. This causes edge pixels to be darker.
            // It also doesn't modify the alpha based on what the cross-section
            // should look like at the endpoints. This causes 'overshoot' at
            // line joins.

            // modulate err by Y if it's an endpoint
            if (start == first)
            {
                LONG erry      = _ceilerr(sy);
                errs            = (errs*erry)>>8;
                erre            = (erre*erry)>>8;
                errc            = (errc*erry)>>8;
            }
            if (start == last)
            {
                LONG erry      = _floorerr (ey);
                errs            = (errs*erry)>>8;
                erre            = (erre*erry)>>8;
                errc            = (errc*erry)>>8;
            }
            
            // draw the pixel(s)
            m_PointInfo.Pixel.p.y = start;
            if (xs < m_clipRect.right && xs >= m_clipRect.left)
            {
                m_PointInfo.Pixel.p.x = xs;
                m_PointInfo.Weight = m_rgAlphaTable[errs];
                DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                m_pRasterizer->SetPixel(&m_PointInfo);
            }    
            if (xc < m_clipRect.right && xc >= m_clipRect.left && errc)
            {
                m_PointInfo.Pixel.p.x = xc;
                m_PointInfo.Weight = m_rgAlphaTable[errc];
                DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                m_pRasterizer->SetPixel(&m_PointInfo);
            }    
            if (xe < m_clipRect.right && xe >= m_clipRect.left)
            {
                m_PointInfo.Pixel.p.x = xe;
                m_PointInfo.Weight = m_rgAlphaTable[erre];
                DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                m_pRasterizer->SetPixel(&m_PointInfo);
            }    
        }
        
        xval    = xval  + slope;
        sx      = sx    + slope;
        start++;
        pattern = RotateBitsLeft(pattern);
    }
    SetLinePattern(pattern);
} // LowLevelVerticalLine

// -----------------------------------------------------------------------------------------------------------------
// LowLevelHorizontalLine - We now treat the line as being inclusive/inclusive
// i.e. we render completely from SX to EX including the endpoints.
// -----------------------------------------------------------------------------------------------------------------
void CLineScanner::LowLevelHorizontalLine (LONG slope, LONG sx, LONG sy, LONG ex)
{
    ULONG pattern = LinePattern();

    if (!AntiAlias())
    {
        LONG start = roundfix2int(sx);
        LONG end = roundfix2int(ex);   

        m_PointInfo.Weight = 255;

        // For Aliased lines, sx and ex are not perfectly clipped to the clipRect 
        // because precision errors can cause us to miss pixels when
        // we are asked to render with a clip rect
        while (start < m_clipRect.left)
        {
            // We should be pretty close here..
            DASSERT((m_clipRect.left - start) < 2);

            // Just increment out values without rendering
            sy = sy + slope;
            start++;
            pattern = RotateBitsLeft(pattern);
        }
        while (end >= m_clipRect.right)
        {
            // We should be pretty close here..
            DASSERT((m_clipRect.right - end) < 2);

            end--;
        }

        while (start <= end)
        {
            if (pattern & 0x80000000)
            {
                m_PointInfo.Pixel.p.y = roundfix2int(sy);

                // We need to explicitly check against the clip-rect 
                // because we intentionally allow end-points to be slightly
                // extend past it. This compensates for the non-linear
                // rounding whereby a mathematical pixel that lies outside
                // the clip-rect can get "rounded" inside the clip-rect.
                if (m_PointInfo.Pixel.p.y >= m_clipRect.top &&
                        m_PointInfo.Pixel.p.y <  m_clipRect.bottom)
                {
                    m_PointInfo.Pixel.p.x = start;
                    DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                    m_pRasterizer->SetPixel(&m_PointInfo);
                }
            }
            sy = sy + slope;
            start++;
            pattern = RotateBitsLeft(pattern);
        }
        SetLinePattern(pattern);
        return;
    }

    ///////////////////////////////////////////////
    // We are now in the Anti-Aliased case...
    //

    LONG start = uff (FIX_FLOOR(sx));
    LONG end = uff (FIX_CEIL(ex));   

    LONG yval = m_startFix;

    // Keep track of whether our line endpoints are real endpoints
    // or whether they have been clipped by the clipRect
    LONG first = start;
    LONG last = end;

    // For Anti-Aliased lines, our lines are not perfectly clipped to
    // the m_clipRect. This is to allow 'bleed' from pixels that are just outside
    // of the m_clipRect to be rendered.
    //
    // As a result, we need to clip explicitly to m_clipRect here.
    while (start < m_clipRect.left)
    {
        // We should be pretty close here..
        DASSERT(m_clipRect.left - start < 2);

        // Just increment out values without rendering
        yval = yval + slope;
        sy = sy + slope;
        start++;
        pattern = RotateBitsLeft(pattern);
    }
    while (end >= m_clipRect.right)
    {
        // We should be pretty close here..
        DASSERT((m_clipRect.right - end) < 2);
        end--;
    }

    while (start <= end)
    {
        if (pattern & 0x80000000)
        {
            LONG fy1 = yval - m_cpixLineWidth;
            LONG fy2 = yval + m_cpixLineWidth;
            LONG fy3 = fy1 - (slope>>2);
            LONG fy4 = fy2 - (slope>>2);

            fy1 = fy1 - (slope>>1) - (slope>>2);
            fy2 = fy2 - (slope>>1) - (slope>>2);
            
            LONG ys, ye, yc;
            LONG errs, erre, errc;
            if (fy3 > fy1)      
            {
                errs = _ceilerr(fy1)>>1;
                erre = _floorerr(fy4)>>1;
                ys = uff (fy1);
                ye = uff (fy4);
                if (ye == ys+1)
                {
                    errs += _ceilerr(fy3)>>1;
                    erre += _floorerr(fy2)>>1;
                    errc = 0;
                }
                else
                {
                    errc = min ((fy2 - fy3)>>8, 256);
                    yc = (ye+ys)>>1;
                }
            }
            else
            {
                errs = _ceilerr(fy3)>>1;
                erre = _floorerr(fy2)>>1;
                ys = uff (fy3);
                ye = uff (fy2);
                if (ye == ys+1)
                {
                    errs += _ceilerr(fy1)>>1;
                    erre += _floorerr(fy4)>>1;
                    errc = 0;
                }
                else
                {
                    errc = min ((fy4 - fy1)>>8, 256);
                    yc = (ye+ys)>>1;
                }
            }
            
            
            // The purpose of this logic is to support
            // cases where a line may start on the middle of
            // a pixel; and it scales the alpha by what percentage
            // ACROSS we are starting.. i.e. if we are starting half-way 
            // into sx, then scale by 1/2. 
            //
            // TODO: It doesn't take into account if what fraction of
            // sy we are starting at. This causes edge pixels to be darker.
            // It also doesn't modify the alpha based on what the cross-section
            // should look like at the endpoints. This causes 'overshoot' at
            // line joins.
            
            // modulate err by X if it's an endpoint
            if (start == first)
            {
                LONG errx = _ceilerr(sx);
                errs = (errs*errx)>>8;
                erre = (erre*errx)>>8;
                errc = (errc*errx)>>8;
            }
            if (start == last)
            {
                LONG errx = _floorerr (ex);
                errs = (errs*errx)>>8;
                erre = (erre*errx)>>8;
                errc = (errc*errx)>>8;
            }

            m_PointInfo.Pixel.p.x = start;
            if (ys < m_clipRect.bottom && ys >= m_clipRect.top)
            {
                m_PointInfo.Pixel.p.y = ys;
                m_PointInfo.Weight = m_rgAlphaTable[errs];
                DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                m_pRasterizer->SetPixel(&m_PointInfo);
            }
            if (yc < m_clipRect.bottom && yc >= m_clipRect.top && errc)
            {
                m_PointInfo.Pixel.p.y = yc;
                m_PointInfo.Weight = m_rgAlphaTable[errc];
                DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                m_pRasterizer->SetPixel(&m_PointInfo);
            }
            if (ye < m_clipRect.bottom && ye >= m_clipRect.top)
            {
                m_PointInfo.Pixel.p.y = ye;
                m_PointInfo.Weight = m_rgAlphaTable[erre];
                DASSERT(!IsPointClipped(m_PointInfo, m_clipRect));
                m_pRasterizer->SetPixel(&m_PointInfo);
            }
        }
        yval = yval + slope;
        sy = sy + slope;
        start++;
        pattern = RotateBitsLeft(pattern);
    }
    SetLinePattern(pattern);
} // LowLevelHorizontalLine

// -----------------------------------------------------------------------------------------------------------------
// RealLineTo
// -----------------------------------------------------------------------------------------------------------------
void CLineScanner::RealLineTo(float x1, float y1, float x2, float y2)
{
    // Compute whether we are more horizontal than vertical
    // before doing the clipping which introduces some errors
    // into the numbers.
    bool fHorizontal;
    float flDeltaX = fabs(x1 - x2);
    float flDeltaY = fabs(y1 - y2);
    if (flDeltaX > flDeltaY)
        fHorizontal = true;
    else
        fHorizontal = false;

    // Clip the line to our clip rect; a false return
    // means the line was totally clipped out.
    if (!ClipRealLine(x1, y1, x2, y2))
        return;
    
    float slope, xDist, yDist;
    
    xDist = x1 - x2;
    yDist = y1 - y2;

    // Are we moving faster in the X than in the Y
    if (fHorizontal)
    {
        // increment in x
        if (!xDist)	
            return;

        slope = yDist / xDist;
        if (x1>x2)
        {
            SWAP (x1, x2); 
            SWAP (y1, y2); 
            SetLinePattern(RotateBitsRight(LinePattern(), m_oldLength + 1 + (int)x2 - (int)x1));
        }
        else if (!m_fXInc)
        {
            SetLinePattern(RotateBitsRight(LinePattern(), m_oldLength));
            m_fXInc = true;
        }
        
        m_oldLength = (int)x2 - (int)x1 + 1;
        
        if (AntiAlias())
        {
            // compute scanline width and subpixel increment
            float mag = (float)sqrtinv(xDist*xDist + yDist*yDist) * .5f;
            float x = -yDist*mag;
            float y = xDist*mag;
            
            float m = (yDist == 0) ? 0 : xDist/yDist;
            float b = x - m*y;
            m_cpixLineWidth = max (abs (LONG (fl (-b*slope))), sfixhalf);
            
            float x0 = (float)(PB_Real2IntSafe(x1) + 1);
            float pre = x0 - x1;
            m_startFix = fl (y1 + slope*pre);
        }
        else
        {
            // For aliased lines; we need to adjust our starting
            // point (x1, y1) so that x1 is rounded to nearest
            // integer. This is to ensure that a line will draw the
            // same no matter what clip-rect is applied to it.
            float flXStart = (float)(int)(x1 + 0.5f);
            if (x1 < 0.0f && x1 != flXStart)
                flXStart -= 1.0f;
            
            float flError = x1 - flXStart;

            // Update x1 to be the rounded value
            x1 = flXStart;

            // We now need to modify the y1 component to account for this change
            y1 -= flError * slope;
        }
        
        // draw horizontal scanline
        LowLevelHorizontalLine(fl(slope), fl(x1), fl(y1), fl(x2));		
    }
    else    // (!fHorizontal), e.g. Vertical
    {
        // increment in y
        if (!yDist)	
            return;
        
        slope = xDist / yDist;
        if (y1 > y2)
        {
            SWAP(x1, x2);
            SWAP(y1, y2);
            SetLinePattern(RotateBitsRight(LinePattern(), m_oldLength + 1 + (int)y2 - (int)y1));
        }
        else if (m_fXInc)
        {
            SetLinePattern(RotateBitsRight(LinePattern(), m_oldLength));
            m_fXInc = false;
        }
        
        m_oldLength = (int)y2 - int(y1) + 1;
        
        if (AntiAlias())
        {
            // compute scanline width and subpixel increment
            float mag = (float) (sqrtinv(xDist*xDist + yDist*yDist) * .5);
            float x = -yDist*mag;
            float y = xDist*mag;
            
            float m = (xDist == 0) ? xDist : yDist/xDist;
            float b = y - m*x;
            m_cpixLineWidth = max (abs (LONG (fl (-b*slope))), sfixhalf);
            
            
            float y0 = (float)(PB_Real2IntSafe(y1) + 1);
            float pre = y0 - y1;
            m_startFix = fl (x1 + slope*pre);
        }
        else
        {
            // For aliased lines; we need to adjust our starting
            // point (x1, y1) so that x1 is rounded to nearest
            // integer. This is to ensure that a line will draw the
            // same no matter what clip-rect is applied to it.
            float flYStart = (float)(int)(y1 + 0.5f);
            if (y1 < 0.0f && y1 != flYStart)
                flYStart -= 1.0f;
            
            float flError = y1 - flYStart;

            // Update y1 to be the rounded value
            y1 = flYStart;

            // We now need to modify the x1 component to account for this change
            x1 -= flError * slope;
        }
       
        // draw vertical scanline
        LowLevelVerticalLine(fl(slope), fl(x1), fl(y1), fl(y2));
    }
} // RealLineTo

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\mscanner\mscanner2d.h ===
//************************************************************
//
// FileName:	    mlinescan.cpp
//
// Created:	    1996
//
// Author:	    Sree Kotay
// 
// Abstract:	    scan-based algorithm for drawing AA polygons
//
// Change History:
// ??/??/97 sree kotay  Wrote AA polygon scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************
#ifndef _FillScanner_H
#define _FillScanner_H

#include "MCoverage.h"

typedef void (*ScanlineProc) (LONG y, LONG start, LONG end, BYTE *weights, ULONG shift, ULONG cScan, void *procdata);

// =================================================================================================================
// Scanner
// =================================================================================================================
class CFillScanner
{
   
public:
    LONG m_subpixelscale;

    // These three allow for a linked-list of each edge that starts
    // at a particular scan line. 
    LONG *m_nexte;

    // This entry indicates the head of the current list (or -1 for null)
    // (Note you have to check m_sortc before looking at this.)
    LONG *m_sorte;

    // This entry indicates whether the head pointer is valid (if it equals cursortcount 
    // then it is valid)
    LONG *m_sortc;
    
    // These two are actually stored in fixed-point
    LONG *m_x;
    LONG *m_xi;

    // Start and End Y locations for each edge
    LONG *m_ys;
    LONG *m_ye;

    // Did we have to flip the edge to fit into our model? (Only needed for winding fill.)
    LONG *m_ef;

    // Alpha value to render with
    BYTE m_alpha;

    // Is winding enabled
    bool m_fWinding;
   
    RECT m_rectClip;
    ULONG m_cpixTargetWidth;
    ULONG m_cpixTargetHeight;
    CoverageBuffer m_coverage;
    
    void *m_scanlineProcData;
    ScanlineProc m_proc;
    
    // =================================================================================================================
    // Constructor/Destructor
    // =================================================================================================================
    CFillScanner();
    ~CFillScanner();
    
    // =================================================================================================================
    // Properties
    // =================================================================================================================
    bool SetVertexSpace(LONG maxverts, LONG height);
    void SetAlpha(ULONG alpha);
    
    // =================================================================================================================
    // Polygon Drawing
    // =================================================================================================================
    bool BeginPoly(LONG maxverts=20); // return false means failure (no memory)
    bool EndPoly(void); // return false means no drawing (clipped out)
    bool AddEdge(float x1, float y1, float x2, float y2); // return false means edge too small to add


protected:

    // =================================================================================================================
    // ScanEdges
    // =================================================================================================================
    void ScanEdges(void);
    void DrawScanLine(LONG e1, LONG e2, LONG scanline);
    void DrawScanLineVertical(LONG e1, LONG e2, LONG scanline);
    bool TestScanLine(LONG e1, LONG e2, LONG scanline);


    // Member data
    TArray<LONG> m_nextedge;
    TArray<LONG> m_sortedge;
    TArray<LONG> m_sortcount;
    
    TArray<LONG> m_xarray;
    TArray<LONG> m_xiarray;

    TArray<LONG> m_yarray;
    TArray<LONG> m_yiarray;

    TArray<LONG> m_ysarray;
    TArray<LONG> m_yearray;
    TArray<LONG> m_veflags;
    
    TArray<ULONG> m_sectsarray;
    
    LONG m_cursortcount;
    
    LONG m_leftflag, m_rightflag;
    LONG m_ystart, m_yend;

    LONG m_yLastStart;

    LONG m_edgecount;
    LONG m_vertspace;
    LONG m_heightspace;
    
    LONG m_topflag, m_bottomflag;
    LONG m_xstart, m_xend;
    
    LONG m_subpixelshift;
    
    BYTE m_alphatable[257];

    // Cached values to reduce computation
    // in critical paths
    // The left clip edge in subpixel space (= m_rectClip.left<<m_subPixelShift)
    LONG m_clipLeftSubPixel; 
    // The right clip edge in sub-pixel space (= m_rectClip.right<<m_subPixelShift)
    LONG m_clipRightSubPixel;
};

#endif // for entire file
//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\mscanner\mlinescan.h ===
//************************************************************
//
// FileName:	    mlinescan.cpp
//
// Created:	    1996
//
// Author:	    Sree Kotay
// 
// Abstract:	    line scanner header
//
// Change History:
// ??/??/97 sree kotay  Wrote AA line scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************
#ifndef _LineScanner_H
#define _LineScanner_H

#include "dxtrans.h"

// =================================================================================================================
// Scanner
// =================================================================================================================
class CLineScanner
{
public:
    // =================================================================================================================
    // Data
    // =================================================================================================================
    RECT m_clipRect;

    IDXRasterizer *m_pRasterizer;
    DXRASTERPOINTINFO m_PointInfo;
    
    // =================================================================================================================
    // Contructor
    // =================================================================================================================
    CLineScanner();
    
    // =================================================================================================================
    // Properties
    // =================================================================================================================
    bool AntiAlias()				
    {
        return m_fAntiAlias;
    } // AntiAlias

    ULONG LinePattern()			
    {
        return m_dwLinePattern;
    } // LinePattern
    
    void SetAntiAlias(bool fAA)	
    {
        m_fAntiAlias = fAA;
    } // SetAntiAlias

    void SetLinePattern(ULONG dwLinePattern)	
    {
        m_dwLinePattern = dwLinePattern;
    } // SetLinePattern

    void SetAlpha(ULONG alpha);
    
    // =================================================================================================================
    // Drawing Functions
    // =================================================================================================================
    void RealLineTo(float x1, float y1, float x2, float y2);
    
protected:
    // =================================================================================================================
    // Clipping
    // =================================================================================================================
    bool ClipRealLine(float &x1, float &y1, float &x2, float &y2);
    
    // =================================================================================================================
    // Vertical/Horizontal based Low-level routines
    // =================================================================================================================
    void LowLevelVerticalLine(LONG slope, LONG sx, LONG sy, LONG ey);
    void LowLevelHorizontalLine(LONG slope, LONG sx, LONG sy, LONG ex);

    // =================================================================================================================
    // Properties
    // =================================================================================================================

    // Flag indicating whether the line should be AA or not
    bool m_fAntiAlias;
    
    // Pattern (allows for dots and dashes etc)
    ULONG m_dwLinePattern;

    // Full Alpha value for the line
    ULONG m_dwAlpha;

    // Lookup table for computing partial alpha values
    BYTE m_rgAlphaTable[257];

    // LineWidth
    LONG m_cpixLineWidth;       // used by internal lowlevel routines

    // TODO: what are these things? Hungarian?
    LONG m_startFix;	    // used by internal lowlevel routines
    LONG m_oldLength;       // used for positioning line pattern
    bool m_fXInc;
    

}; // CLineScanner

#endif //_LineScanner_H
//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\mscanner\precomp.h ===
// This needs to be in this directory for PCH to work, but we actually keep
// all the directives down in ..\inc\common.h

#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\mscanner\mstroke.cpp ===
//************************************************************
//
// FileName:	    mcoverage.cpp
//
// Created:	    1997
//
// Author:	    Sree Kotay
// 
// Abstract:	    Stroke implementation file
//
// Change History:
// ??/??/97 sree kotay  Wrote sub-pixel AA scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************

#include "precomp.h"
#include "MSupport.h"
#include "MStroke.h"
#include "MScanner2d.h"
#include "MLineScan.h"

// Array points to use for circle caps; initialized only once
static float s_rgflCircle[(CStroke::CIRCLE_SAMPLES+1)*2];
static bool s_fCircleSampleInit = false;

// =================================================================================================================
// Constructor
// =================================================================================================================
CStroke::CStroke() :
    m_plinescanner(NULL),
    m_pscanner(NULL),
    m_fValidStarts(false),
    m_proc(NULL),
    m_pprocdata(NULL),
    m_flStrokeRadius(1.0f),
    m_flMaxStrokeRadius(1.0f),
    m_joinType(eRoundJoin),
    m_capType(eRoundCap),
    m_flMiterLimit(DEFAULT_MITER_LIMIT)
{
    // Sanity check that we have the right number of entries in
    // our array
    DASSERT(sizeof(s_rgflCircle)/sizeof(s_rgflCircle[0]) == (CIRCLE_SAMPLES+1)*2);
    
    if (!s_fCircleSampleInit)
    {
        float flStep = 1.0f / (float)(CIRCLE_SAMPLES);
        for (ULONG i = 0; i <= CIRCLE_SAMPLES; i++)
        {
            float ang = (float)(3.141592*2*flStep*float(i));
            s_rgflCircle[(i*2)]	= (float)::cos(ang);
            s_rgflCircle[(i*2) + 1]	= (float)::sin(ang);
        }
        s_fCircleSampleInit = true;
    }
} // CStroke

// =================================================================================================================
// BeginStroke
// =================================================================================================================
void CStroke::BeginStroke (void)
{
    m_fValidStarts = false;
} // BeginStroke

// =================================================================================================================
// EndStroke
// =================================================================================================================
void CStroke::EndStroke (void)
{
    m_fValidStarts = false;
} // EndStroke

// =================================================================================================================
// AddEdge
// =================================================================================================================
void CStroke::AddEdge(float x1, float y1, float x2, float y2)
{
    if (m_proc)
    {
        m_proc (&x1, &y1, m_pprocdata);
        m_proc (&x2, &y2, m_pprocdata);
    }
    
    if (m_plinescanner)
        m_plinescanner->RealLineTo(x1,y1,x2,y2);
    else
        m_pscanner->AddEdge(x1,y1,x2,y2);

    return;
} // AddEdge

// =================================================================================================================
// DrawCircle
// =================================================================================================================
void CStroke::DrawCircle (float x, float y)
{
    LONG step = (LONG)(float (float(CIRCLE_SAMPLES)/m_flMaxStrokeRadius + .5)*.5);

    // Clamp step to [1, 16]
    if (step <= 1)
        step = 1;
    else if (step > 16)
        step = 16;
        
    float xo1, yo1;
    for (LONG i = 0; i <= CIRCLE_SAMPLES; i += step)
    {
        LONG i1	= i * 2;
        float xc1 = s_rgflCircle[i1  ]*m_flStrokeRadius	+ x;
        float yc1 = s_rgflCircle[i1+1]*m_flStrokeRadius	+ y;
        
        if (i)		
        {
            AddEdge (xo1, yo1, xc1, yc1);
        }
        
        xo1			= xc1;
        yo1			= yc1;
    }
    float xc1	= s_rgflCircle[0]*m_flStrokeRadius	+ x;
    float yc1	= s_rgflCircle[1]*m_flStrokeRadius	+ y;
    AddEdge (xo1, yo1, xc1, yc1);
} // DrawCircle

// =================================================================================================================
// StartCap
// =================================================================================================================
void CStroke::StartCap (float x1, float y1, float x2, float y2)
{
    DASSERT (m_pscanner);
    if ((x1==x2) && (y1==y2))	
        return;
    
    float ax = x2 - x1;
    float ay = y2 - y1;
    
    float mag	= (float)((1.0 / sqrt(ax*ax + ay*ay)) * m_flStrokeRadius);
    ax *= mag;
    ay *= mag;
    
    // start cap
    switch (m_capType)
    {
    case eSquareCap:
        AddEdge (x1 - ay, y1 + ax, x1 - ay - ax, y1 + ax - ay);
        AddEdge (x1 - ay - ax, y1 + ax - ay, x1 + ay - ax, y1 - ax - ay);
        AddEdge (x1 + ay - ax, y1 - ax - ay, x1 + ay, y1 - ax);
        break;
    case eRoundCap:
        //flat cap
        AddEdge (x1 - ay, y1 + ax, x1 + ay, y1 - ax);
        
        //round cap
        DrawCircle (x1, y1);
        break;
    case eFlatCap:
    default:
        AddEdge (x1 - ay, y1 + ax, x1 + ay, y1 - ax);
        break;
    }
    
    m_fValidStarts	= true;
    m_flSx1			= x1 - ay;
    m_flSy1			= y1 + ax;
    m_flSx2			= x1 + ay;
    m_flSy2			= y1 - ax;
} // StartCap

// =================================================================================================================
// EndCap
// =================================================================================================================
void CStroke::EndCap (float x1, float y1, float x2, float y2)
{
    DASSERT (m_pscanner);
    if ((x1==x2) && (y1==y2))	
        return;
    
    float ax		 = x2 - x1;
    float ay		 = y2 - y1;
    
    float mag	= (float)((1.0 / sqrt(ax*ax + ay*ay)) * m_flStrokeRadius);
    ax			*= mag;
    ay			*= mag;
    
    // end cap
    switch (m_capType)
    {
    case eSquareCap:
        AddEdge (x2 + ay, y2 - ax,              x2 + ay + ax, y2 - ax + ay);
        AddEdge (x2 + ay + ax, y2 - ax + ay,    x2 - ay + ax, y2 + ax + ay);
        AddEdge (x2 - ay + ax, y2 + ax + ay,    x2 - ay, y2 + ax);
        break;
    case eRoundCap:
        // flat cap
        AddEdge (x2 + ay, y2 - ax, x2 - ay, y2 + ax);
        
        // round cap
        DrawCircle (x2, y2);
        break;
    case eFlatCap:
    default:
        AddEdge (x2 + ay, y2 - ax, x2 - ay, y2 + ax);
        break;
    }
    
    m_fValidStarts = false;
} // EndCap

// =================================================================================================================
// Segment
// =================================================================================================================
void CStroke::Segment(float x1, float y1, float x2, float y2)
{
    DASSERT(m_pscanner);
    if ((x1==x2) && (y1==y2))	
        return;
    
    float ax		 = x2 - x1;
    float ay		 = y2 - y1;
    
    float mag	= (float)((1.0 / sqrt(ax*ax + ay*ay)) * m_flStrokeRadius);
    ax			*= mag;
    ay			*= mag;
    
    // connect to previous segment if unconnected
    if (m_fValidStarts)
    {
        float sx1		= x1 - ay;
        float sy1		= y1 + ax;
        float sx2		= x1 + ay;
        float sy2		= y1 - ax;
        
        if ((sx1 != m_flSx1) || (sy1 != m_flSy1))
            AddEdge(sx1, sy1, m_flSx1, m_flSy1);
        
        if ((sx2 != m_flSx2) || (sy2 != m_flSy2))
            AddEdge(m_flSx2, m_flSy2, sx2, sy2);
    }
    
    
    // segment stroke
    AddEdge(x1 + ay, y1 - ax, x2 + ay, y2 - ax);
    AddEdge(x2 - ay, y2 + ax, x1 - ay, y1 + ax);
    
    
    m_fValidStarts	= true;
    m_flSx1			= x2 - ay;
    m_flSy1			= y2 + ax;
    m_flSx2			= x2 + ay;
    m_flSy2			= y2 - ax;
} // Segment

// =================================================================================================================
// LinesSect - Return the intersection of two lines. If the two lines don't intersect
//              return false.
// =================================================================================================================
bool LinesSect(float x1, float y1, float x2, float y2, 
               float x3, float y3, float x4, float y4,
               float &px, float &py)
{
    float ix1 = x2 - x1;
    float ix2 = x4 - x3;
    
    if (IsRealZero(ix1) && IsRealZero(ix2))		
        return false; //both vertical lines
    
    float m1	= (IsRealZero(ix1)) ? 0 : (y2-y1)/ix1;
    float m2	= (IsRealZero(ix2)) ? 0 : (y4-y3)/ix2;
    
    if (IsRealZero(ix1))
    {
        float b2	= y3 - m2*x3;
        px		= x1;
        py		= b2 + m2*px;
    }
    else if (IsRealZero(ix2))
    {
        float b1	= y1 - m1*x1;
        px		= x3;
        py		= b1 + m1*px;
    }
    else
    {
        if (IsRealEqual(m1, m2))			
            return false; //same slope
        
        float b1	= y1 - m1*x1;
        float b2	= y3 - m2*x3;
        
        px		= (b2-b1)/(m1-m2);

        // Use the smaller (in magnitude) slope to reduce
        // floating point errors; this prevents
        // wackiness when lines are nearly vertical. 
        // Bug #34817
        if (fabs(m1) < fabs(m2))        
            py = b1 + m1*px;
        else
            py = b2 + m2*px;
    }
    
    return true;
} // LinesSect

// =================================================================================================================
// PB_BetweenAB
// =================================================================================================================
bool PB_BetweenAB (float t, float a, float b)
{
    if (a < b)
    {
        if (t < a)	
            return false;
        if (t > b)	
            return false;
    }
    else
    {
        if (t < b)	
            return false;
        if (t > a)	
            return false;
    }
    return true;
} // PB_BetweenAB

// =================================================================================================================
// Join
// =================================================================================================================
void CStroke::Join(float x1, float y1, float x2, float y2, float x3, float y3)
{
    DASSERT(m_pscanner);
    if ((x1==x2) && (y1==y2))	
        return;
    if ((x3==x2) && (y3==y2))	
        return;
    
    // segment 1
    float ax		 = x2 - x1;
    float ay		 = y2 - y1;
    
    float mag	= (float)((1.0 / sqrt(ax*ax + ay*ay)));
    ax			*= mag;
    ay			*= mag;
    
    // segment 2
    float bx		 = x3 - x2;
    float by		 = y3 - y2;
    
    float mag2	= (float)(1.0 / sqrt(bx * bx + by * by));
    bx			*= mag2;
    by			*= mag2;
    
    float p1x, p1y, p2x, p2y;
    bool result	= true;
    float dot		= ax*bx + ay*by; 
    
    // scale by stroke
    ax	*= m_flStrokeRadius;
    ay	*= m_flStrokeRadius;
    bx	*= m_flStrokeRadius;
    by	*= m_flStrokeRadius;
   
    // miter join
    if ((dot > m_flMiterLimit) && (m_joinType == eMiterJoin) && (m_flMaxStrokeRadius > .75))
    {
        if (!LinesSect (x1 + ay, y1 - ax, x2 + ay, y2 - ax,
                x2 + by, y2 - bx, x3 + by, y3 - bx, p1x, p1y))	
        {
            result = false;
        }
        else if (!LinesSect (x1 - ay, y1 + ax, x2 - ay, y2 + ax,
                x2 - by, y2 + bx, x3 - by, y3 + bx, p2x, p2y))	
        {
            result = false;
        }
    }
    else
    {
        result = false;
    }
    
    
    if ((m_flMaxStrokeRadius > 1) && (m_joinType == eRoundJoin))
    {
        DrawCircle (x2, y2);
        // but we still need to bevel
    }
    
    // join stroke
    if (result)
    {
        // only miter if the intersection is not between the points
        if ((PB_BetweenAB (p1x, x1 + ay, x2 + ay)) && 
                (PB_BetweenAB (p1y, y1 - ax, y2 - ax)))
        {
            AddEdge (x2 + ay, y2 - ax, x2 + by, y2 - bx);
        }
        else
        {
            AddEdge (x2 + ay, y2 - ax,		p1x, p1y);
            AddEdge (p1x, p1y, x2 + by, y2 - bx);
        }
        
        // only miter if the intersection is not between the points
        if ((PB_BetweenAB (p2x, x1 - ay, x2 - ay)) && 
                (PB_BetweenAB (p2y, y1 + ax, y2 + ax)))
        {
            AddEdge (x2 - by, y2 + bx, x2 - ay, y2 + ax);
        }
        else
        {
            AddEdge (x2 - by, y2 + bx,	p2x, p2y);
            AddEdge (p2x, p2y, x2 - ay, y2 + ax);
        }
    }
    else
    {
        // bevel join
        AddEdge (x2 + ay, y2 - ax, x2 + by, y2 - bx);
        AddEdge (x2 - by, y2 + bx, x2 - ay, y2 + ax);
    }
    
    m_fValidStarts = false;
} // Join

//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\mscanner\mstroke.h ===
//************************************************************
//
// FileName:	    mstroke.cpp
//
// Created:	    1997
//
// Author:	    Sree Kotay
// 
// Abstract:	    Core Gradient filter
//
// Change History:
// ??/??/97 sree kotay  Wrote AA stroke engine for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************

#ifndef _CStroke_H
#define _CStroke_H

// forward declaration
class CLineScanner;
class CFillScanner;

// Allow the host to apply a post-transform on the points
typedef void (*PointProc) (float *x, float *y, void *procdata);

// =================================================================================================================
// CStroke
// =================================================================================================================
class CStroke
{
public:
    // Number of segments that a rounded cap will generate
    enum
    {
        CIRCLE_SAMPLES = 64
    };

protected:
    bool m_fValidStarts;
    float m_flSx1, m_flSy1;
    float m_flSx2, m_flSy2;
    

    void DrawCircle(float x, float y);
    void AddEdge(float x1, float y1, float x2, float y2);
    
public:
    enum
    {
        eMiterJoin,
        eBevelJoin,
        eRoundJoin,
        eFlatCap,
        eSquareCap,
        eRoundCap
    };
    
    // =================================================================================================================
    // Properties
    // =================================================================================================================
    float m_flStrokeRadius;
    float m_flMaxStrokeRadius;
    float m_flMiterLimit;		//as cosAng

    // Default miter-limit as "cosAng"?
#define DEFAULT_MITER_LIMIT (-0.3f)

    ULONG m_joinType;
    ULONG m_capType;
    
    
    CFillScanner *m_pscanner;
    CLineScanner *m_plinescanner;
    
    void *m_pprocdata;
    PointProc m_proc;
    
    // =================================================================================================================
    // Constructor/Destructor
    // =================================================================================================================
    CStroke();
    ~CStroke() 
    {
        // sanity check our data structures
        DASSERT(m_joinType == eMiterJoin || m_joinType == eBevelJoin || m_joinType == eRoundJoin);
        DASSERT(m_capType == eFlatCap || m_capType == eSquareCap || m_capType == eRoundCap);
    };
    
    // =================================================================================================================
    // Wrappers
    // =================================================================================================================
    void BeginStroke(void);
    void EndStroke(void);
    
    // =================================================================================================================
    // Functions
    // =================================================================================================================
    void StartCap(float x1, float y1, float x2, float y2);
    void EndCap(float x1, float y1, float x2, float y2);
    void Segment(float x1, float y1, float x2, float y2);
    void Join(float x1, float y1, float x2, float y2, float x3, float y3);
};

#endif // for entire file
//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\mscanner\msupport.h ===
//************************************************************
//
// FileName:	    msupport.h
//
// Created:	    1996
//
// Author:	    Sree Kotay
// 
// Abstract:	    Utility helper file
//
// Change History:
// ??/??/97 sree kotay  Wrote AA line scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
//
// Copyright 1998, Microsoft
//************************************************************

#ifndef __MSUPPORT_H__ // for entire file
#define __MSUPPORT_H__

#include "dassert.h"
#include "_tarray.h"
#include "math.h"



const LONG  	_maxint32 = 2147483647; 				//2^31 - 1
const SHORT  	_minint16 = -32768; 					//-2^15
const SHORT  	_maxint16 = 32767; 					//2^15 - 1
const LONG  	_minint32 = -_maxint32-1; 				//-2^31
const ULONG  	_maxuint32 = 4294967295; 				//2^32 - 1


/************************** comparison macros **************************/
#define IsRealZero(a)                   (fabs(a) < 1e-5)
#define IsRealEqual(a, b)               (IsRealZero((a) - (b)))

// Quick Routine for determining if a number is a pow-of-two
inline bool IsPowerOf2(LONG a)
{
    // This nifty function (a & a-1) has the property
    // that it turns off the lowest bit that is on
    // i.e. 0xABC1000 goes to 0xABC0000.
    if ((a & (a-1)) == 0)
    {
        if (a)
            return true;
    }
    return false;
}

// Helper function that returns the log base 2 of a number
inline LONG Log2(LONG value)
{
    if (value == 0)
    {
        DASSERT(FALSE);
        return 0;
    }
        
    LONG cShift = 0;
    while (value >>= 1)	
        cShift++;
    return cShift;
} // Log2

// Bitwise Rotation implemention.. (We
// implement this ourselves because _lrotl gave link
// errors in retail). (I don't use ASM because VC5 disables
// optimizations for functions that have ASM in them.)
inline DWORD RotateBitsLeft(DWORD dw, ULONG cShift = 1)
{   
    // Multiples of 32 are no-ops
    cShift = cShift % 32;

    // We shift the main term to the left, and then we OR
    // it with the high-bits which we shift right
    return ((dw << cShift) | (dw >> (32 - cShift)));
} // RotateBitsLeft

inline DWORD RotateBitsRight(DWORD dw, ULONG cShift = 1)
{   
    // Multiples of 32 are no-ops
    cShift = cShift % 32;

    // We shift the main term to the right, and then we OR
    // it with the low-bits which we shift left
    return ((dw >> cShift) | (dw << (32 - cShift)));
} // RotateBitsRight

// AbsoluteValue functions
// (Need this to prevent link errors.)
inline LONG abs(LONG lVal)
{
    if (lVal < 0)
        return -lVal;
    else
        return lVal;
} // abs

inline float fabs(float flVal)
{
    if (flVal < 0.0f)
        return -flVal;
    else
        return flVal;
} // fabs

// Returns one over the square root
inline float sqrtinv(float flValue)
{
    return (float)(1.0f / sqrt(flValue));
} // sqrtinv


// This function provides an automatic way for
// the fixed point Real calculations to be clipped to a 
// number that fits in their range. The original meta code
// used +/- 24000 as the appropriate range.
//
// TODO: This is inherently buggy.
const LONG _maxvali		=  24000;
const float _maxval		=  _maxvali;
const float _minval		= -_maxvali;
inline ULONG PB_Real2IntSafe(float flVal)
{
    // Check that the magnitude is reasonable
    if (fabs(flVal) < _maxval)
        return (ULONG)flVal;

    // Clamp to range (minval, maxval)
    if (flVal > 0)
        return (ULONG)_maxval;
    
    return (ULONG)_minval;
} // PB_Real2IntSafe

// -----------------------------------------------------------------------------------------------------------------
// Internal stuff for fixed-to-float conversions
// -----------------------------------------------------------------------------------------------------------------
#define fix_shift	16

const LONG		sfixed1			= (1)<<fix_shift;
const LONG		sfixhalf		= sfixed1>>1;
const float	        Real2fix		= (1)<<fix_shift;
const float	        fix2Real		= 1/((1)<<fix_shift);
const LONG		sfixedUnder1	= sfixed1 - 1;
const LONG		sfixedOver1		= ~sfixedUnder1;


inline ULONG PB_Real2Fix(float flVal)
{
    return (ULONG)(flVal * Real2fix);
}

// Convert a float to fixed point and forces it to
// stay within a reasonable range. 
//
// TODO: this is inherently buggy.
inline ULONG PB_Real2FixSafe(float flVal)
{
    // Check that the magnitude is reasonable
    if (fabs(flVal) < _maxval)
        return (ULONG)(flVal * Real2fix);

    // Clamp to range (minval, maxval)
    // Modified by the fixed point scaling factor
    if (flVal > 0)
        return (ULONG)(_maxval * Real2fix);
    
    return (ULONG)(_minval * Real2fix);
} // PB_Real2FixSafe

// Force a float to be within a reasonable range
// for the fixed point math
inline void PB_OutOfBounds(float *pflVal)
{
    // Check that the magnitude is reasonable
    if (fabs(*pflVal) < _maxval)
        return;

    // Clamp to range (minval, maxval)
    // Modified by 
    if (*pflVal > 0)
        *pflVal = (float)_maxval;
    else 
        *pflVal = (float)_minval;
    return;
}; // PB_OutOfBounds

#define ff(a)			((a)<<fix_shift)
#define uff(a)			((a)>>fix_shift)
#define uffr(a)			((a+sfixhalf)>>fix_shift)
#define	fl(a)			(PB_Real2Fix (a))
#define ufl(a)			(((dfloat)(a))*fix2float)
#define FIX_FLOOR(a)	        ((a)&sfixedOver1)
#define FIX_CEIL(a)		FIX_FLOOR((a)+sfixed1)
#define _fixhalf                (1<<(fix_shift -1)) // .5
#define	roundfix2int(a)		LONG(((a)+_fixhalf)>>fix_shift)


#endif //for entire file
//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\dll\debughelpers.c ===
//------------------------------------------------------------------------------
//
//  File:       debughelpers.c
//
//  Overview:   Helper functions to use during debugging.
//
//  History:
//  2000/01/26  mcalkins    Created.
//
//------------------------------------------------------------------------------

#if DBG == 1
#ifndef __DEBUGHELPERS_H_
#define __DEBUGHELPERS_H_

#include "debughelpers.h"


//+-----------------------------------------------------------------------------
//
//  Function:   EnsureDebugHelpers
//
//------------------------------------------------------------------------------
void EnsureDebugHelpers()
{
    showme(NULL);
}
//  Function:   EnsureDebugHelpers


//+-----------------------------------------------------------------------------
//
//  Function:   showme2
//
//------------------------------------------------------------------------------
void showme2(IDirectDrawSurface * surf, RECT * prc)
{
    HRESULT hr      = S_OK;
    HDC     srcDC;
    HDC     destDC  = GetDC(NULL);
    RECT    dr;
    RECT    sr;
    RECT    rcFrame;

    HBRUSH          hbrRed = NULL;
    HBRUSH          hbrGreen = NULL;
    LOGBRUSH        logbrush;
    DDSURFACEDESC   ddsd;

    ZeroMemory(&ddsd, sizeof(ddsd));

    hr = surf->GetDC(&srcDC);

    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;

    hr = surf->GetSurfaceDesc(&ddsd);

    SetRect(&sr, 0, 0, ddsd.dwWidth, ddsd.dwHeight);
    SetRect(&dr, 1, 1, ddsd.dwWidth + 1, ddsd.dwHeight + 1);
    SetRect(&rcFrame, 0, 0, ddsd.dwWidth + 2, ddsd.dwHeight + 2);
    
    StretchBlt(destDC,
               dr.left,
               dr.top,
               dr.right - dr.left,
               dr.bottom - dr.top,
               srcDC,
               sr.left,
               sr.top,
               sr.right - sr.left,
               sr.bottom - sr.top,
               SRCCOPY);

    logbrush.lbStyle    = BS_SOLID;
    logbrush.lbColor    = 0x000000FF;   // Red

    hbrRed = CreateBrushIndirect(&logbrush);
    if (hbrRed)
    {
        logbrush.lbColor    = 0x0000FF00;   // Green

        FrameRect(destDC, &rcFrame, hbrRed);
        
        if (prc != NULL)
        {
            hbrGreen = CreateBrushIndirect(&logbrush);
            if (hbrGreen)
            {
                RECT    rcBounds = *prc;
                rcBounds.right += 2;
                rcBounds.bottom += 2;

                FrameRect(destDC, &rcBounds, hbrGreen);
                DeleteObject(hbrGreen);
            }
        }
        DeleteObject(hbrRed);
    }

    hr = surf->ReleaseDC(srcDC);
    
    ReleaseDC(NULL, destDC);    
}
//  Function:   showme2


//+-----------------------------------------------------------------------------
//
//  Function:   showme
//
//------------------------------------------------------------------------------
void * showme(IUnknown * pUnk)
{
    HRESULT hr = S_OK;
    RECT    rc;

    CComPtr<IDirectDrawSurface> spDDSurf;
    CComPtr<IDXSurface>         spDXSurf;

    if (NULL == pUnk)
    {
        goto done;
    }

    hr = pUnk->QueryInterface(IID_IDirectDrawSurface, (void **)&spDDSurf);

    if (FAILED(hr))
    {
        hr = pUnk->QueryInterface(IID_IDXSurface, (void **)&spDXSurf);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDXSurf->GetDirectDrawSurface(IID_IDirectDrawSurface,
                                            (void **)&spDDSurf);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    /*
    if (pbnds)
    {
        pbnds->GetXYRect(rc);
    }
    */

    showme2(spDDSurf, NULL);

done:

    return pUnk;
}
//  Function:   showme

#endif // __DEBUGHELPERS_H_
#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\rsrc\makefile.inc ===
#
# makefile.inc
#
#     Makefile dependency rules for special files not
# automagically processed by BUILD.EXE.
#

dxtrans.rc :                    \
    $(SDK_LIB_PATH)\dxtrans.tlb \
    dxraster.rgs                \
    dxsurf.rgs                  \
    dxtfilter.rgs               \
    dxtfilterbehavior.rgs       \
    dxtfiltercollection.rgs     \
    dxtfilterfactory.rgs        \
    geo2d.rgs                   \
    gradient.rgs                \
    label.rgs                   \
    scale.rgs                   \
    surfmod.rgs                 \
    taskmgr.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\msft.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

!ENDIF

ROOT=$(SUBPROJROOT:\src\dxt\msft=)

# IE's common.inc says to treat level 4 warnings as errors.  We wish.

WARNING_LEVEL=W3


!include $(ROOT)\common.inc


USE_ATL=1
ATL_VER=21  


INCLUDES =                    \
    $(INCLUDES);              \
    $(SUBPROJROOT)\inc;       \
    $(SUBPROJROOT)\src;       \
    $(ROOT)\src\core\include; \
    $(SHELL_INC_PATH)

C_DEFINES=$(C_DEFINES) -D_WINDLL -D_WINDOWS

CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
    atlbase.h       \
    atlcom.h        \
    atlctl.h        \
    fp.h            \
    folders.h       \
    macapi.h        \
    macheaders.c    \
    macname1.h      \
    macname2.h      \
    macocidl.h      \
    macpub.h        \
    pictutils.h     \
    qdoffscreen.h   \
    rpcerr.h        \
    rpcmac.h        \
    stdafx.h        \
    timer.h         \
    thunk.h         \
    winwlm.h        \
    x86_prefix.h    \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\dll\objmap1.cpp ===
//***************************************************************************
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:            ObjMap1.cpp
//
// Created:             12/10/98
//
// Author:              PaulNash
//
// Description:         Object Map helper file (part 1). This file
//                      contains a portion of the DXTMSFT.DLL ATL object
//                      map.  It contains the entries for 15 objects.
//
// History
//
// 12/10/98 PaulNash    Created this file.
//
//***************************************************************************

#include "stdafx.h"
#include "resource.h"
#include <DXTMsft.h>

#include "ColorAdj.h"
#include "Composit.h"
#include "dxtwipe.h"
#include "convolve.h"
#include "CrBlur.h"

#include "Fade.h"
#include "Image.h"
#include "Pixelate.h"
#include "GradDsp.h"
#include "Iris.h"

#include "Barn.h"
#include "Blinds.h"
#include "RWipe.h"

// Start the first section of our OBJECT_MAP
//
_ATL_OBJMAP_ENTRY ObjectMap1[] = {
    OBJECT_ENTRY(CLSID_DXLUTBuilder,        CDXLUTBuilder       )
    OBJECT_ENTRY(CLSID_DXTComposite,        CDXTComposite       )
    OBJECT_ENTRY(CLSID_DXTWipe,             CDXTWipe            )
    OBJECT_ENTRY(CLSID_DXTGradientWipe,     CDXTGradientWipe    )
    OBJECT_ENTRY(CLSID_DXTConvolution,      CDXConvolution      )

    OBJECT_ENTRY(CLSID_CrBlur,              CCrBlur             )
    OBJECT_ENTRY(CLSID_CrEmboss,            CCrEmboss           )
    OBJECT_ENTRY(CLSID_CrEngrave,           CCrEngrave          )
    OBJECT_ENTRY(CLSID_DXFade,              CFade               )
    OBJECT_ENTRY(CLSID_BasicImageEffects,   CImage              )
    
    OBJECT_ENTRY(CLSID_Pixelate,            CPixelate           )
    OBJECT_ENTRY(CLSID_DXTGradientD,        CDXTGradientD       )
    OBJECT_ENTRY(CLSID_CrIris,              CDXTIris            )
    OBJECT_ENTRY(CLSID_DXTIris,             CDXTIrisOpt         )
    OBJECT_ENTRY(CLSID_CrRadialWipe,        CDXTRadialWipe      )

    OBJECT_ENTRY(CLSID_DXTRadialWipe,       CDXTRadialWipeOpt   )
    OBJECT_ENTRY(CLSID_CrBarn,              CDXTBarn            )
    OBJECT_ENTRY(CLSID_DXTBarn,             CDXTBarnOpt         )
    OBJECT_ENTRY(CLSID_CrBlinds,            CDXTBlinds          )
    OBJECT_ENTRY(CLSID_DXTBlinds,           CDXTBlindsOpt       )
};

int g_cObjs1 = sizeof(ObjectMap1) / sizeof(ObjectMap1[0]);

////////////////////////////////////////////////////
// End Of File
////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\core\mscanner\_tarray.h ===
//************************************************************
//
// FileName:	    _tarray.cpp
//
// Created:	    1996
//
// Author:	    Sree Kotay
// 
// Abstract:	    template-based array class
//
// Change History:
// ??/??/97 sree kotay  Wrote sub-pixel AA scanning for DxTrans 1.0
// 10/18/98 ketand      Reworked for coding standards and deleted unused code
// 08/07/99 a-matcal    Replaced calls to callod with malloc and ZeroMemory to
//                      use IE crt.
//
// Copyright 1998, Microsoft
//************************************************************

#ifndef _TArray_H // for entire file
#define _TArray_H

// =================================================================================================================
// TArray
// =================================================================================================================
template <class T> class TArray 
{
protected:
    // =================================================================================================================
    // Data
    // =================================================================================================================
    BYTE* m_pbBaseAddress;
    ULONG m_cElem;
    ULONG m_cElemSpace;
    ULONG m_cbElemSize;
    ULONG m_cElemGrowSize;
    bool m_fZeroMem;
    
    // =================================================================================================================
    // Array Data
    // =================================================================================================================
    T* m_ptPtr;														

    enum		
    {
        eDefaultGrowSize	= 32
    };
    
   
    // =================================================================================================================
    // Update Array Pointer
    // =================================================================================================================	
    void UpdateDataPointer()	 	
    {
        m_ptPtr=(T*)BaseAddress();
    } // UpdateDataPointer

    void ZeroInternals()
    {
        m_pbBaseAddress	= 0;
        m_cElem	= 0;
        m_cElemSpace = 0;
        m_fZeroMem = false;
        m_cbElemSize = 0;
        m_cElemGrowSize = 0;
        m_ptPtr	= 0;
        DASSERT(IsValid());
    } // UpdateDataPointer
    
public:
    // =================================================================================================================
    // Construction/Destruction
    // =================================================================================================================
    TArray(ULONG initialGrowSize = eDefaultGrowSize,  bool fZeroMem = true);			

    ~TArray();
    
    // =================================================================================================================
    // Allocation/Deallocation functions
    // =================================================================================================================
    bool ArrayAlloc(ULONG initialCount, ULONG initialSpace, ULONG initialGrowSize, bool fZeroMem);
    void ArrayFree();
    
    // =================================================================================================================
    // Validity
    // =================================================================================================================	
    inline bool IsValid() const
    {
        // CONSIDER: are there more checks that we can do in debug?
#ifdef DEBUG 
        if (m_pbBaseAddress)
        {
            DASSERT(m_cElem <= m_cElemSpace);
            // CONSIDER: add a check to see if 
            // unused memory is zero-ed for the fZeroMem case
        }
        else
        {
            DASSERT(m_cElem == 0);
            DASSERT(m_cElemSpace == 0);
        }
        DASSERT(m_cElem < 0x10000000);
        DASSERT(m_cElemSpace < 0x10000000);
#endif // DEBUG
        return true;
    } // IsValid
    
    // =================================================================================================================
    // Member Functions
    // =================================================================================================================	
    inline BYTE *BaseAddress()
    {
        DASSERT(IsValid());
        return m_pbBaseAddress;
    } // BaseAddress

    inline ULONG GetElemSize()
    {
        DASSERT(IsValid());
        return m_cbElemSize;
    } // GetElemSize
    
    inline bool	GetZeroMem()
    {
        DASSERT(IsValid());
        return m_fZeroMem;
    } // GetZeroMem    
    
    inline ULONG GetElemSpace()						
    {
        DASSERT(IsValid());
        return m_cElemSpace;
    } // GetElemSpace

    bool SetElemSpace(ULONG n);
    
    inline ULONG GetElemCount()
    {
        DASSERT(IsValid());
        return m_cElem;
    } // GetElemCount

    inline bool	SetElemCount(ULONG n);
    inline bool	AddElemCount(ULONG n);
    
    // =================================================================================================================
    // Access Methods
    // =================================================================================================================
    inline T* Pointer(ULONG i)				
    {
        DASSERT(IsValid());
        DASSERT(i < GetElemCount());
        return m_ptPtr + i;
    } // Pointer					
    
    inline T& operator[](ULONG i)
    {
        DASSERT(IsValid());				
        DASSERT(i < GetElemCount());			
        return m_ptPtr[i];
    } // Pointer					
    
    // =================================================================================================================
    // Array Functions
    // =================================================================================================================	
    inline bool SetElem(ULONG index, const T*  data);
    inline bool GetElem(ULONG index, T*  data);
    
    inline bool AddElem(const T*  data);										
    
    inline bool InsertElem(ULONG index, const T& data);
    
    inline bool CompactArray()
    {
        DASSERT(IsValid());
        return SetElemSpace(GetElemCount());
        DASSERT(IsValid());
    } // CompactArray

    inline bool ResetArray()						
    {
        DASSERT(IsValid());
        return SetElemCount(0);
        DASSERT(IsValid());
    } // CompactArray
    
}; // TArray

// =================================================================================================================
// =================================================================================================================
//
// 		Implementation of TArray -
// 		Done in the header because many compilers 
//		require template implementations this way
//
// =================================================================================================================
// =================================================================================================================

// =================================================================================================================
// Construction
// =================================================================================================================

// Note that this function has default parameters specified in the class decl.
template<class T> TArray<T>::TArray(ULONG initialGrowSize /* = eDefaultGrowSize */, 
        bool fZeroMem /* = true */)
{
    ZeroInternals ();
    
    // This doesn't really alloc anything because we pass zero as initial size
    if  (!ArrayAlloc (0 /* count */ , 0 /* space */, initialGrowSize, fZeroMem))	
    {
        DASSERT(0); 
        return;
    }
    DASSERT(IsValid());
} // TArray

// =================================================================================================================
// Destruction
// =================================================================================================================
template<class T> TArray<T>::~TArray ()
{
    DASSERT(IsValid());
    ArrayFree();
    DASSERT(IsValid());
} // ~TArray

// =================================================================================================================
// ArrayAlloc
// =================================================================================================================
template<class T> bool TArray<T>::ArrayAlloc (ULONG initialCount, ULONG initialSpace,
        ULONG initialGrowSize, bool fZeroMem)
{
    DASSERT(IsValid());
    ZeroInternals ();
    
    if (initialCount > initialSpace)		
    {
        DASSERT(0); 
        return false;
    }
    
    m_cbElemSize = sizeof (T);
    m_cElemGrowSize = initialGrowSize;
    m_fZeroMem = fZeroMem;
    
    if (!SetElemSpace (initialSpace))		
    {
        DASSERT(0); 
        return false;
    }
    if (!SetElemCount(initialCount))		
    {
        DASSERT(0); 
        return false;
    }
    
    DASSERT(IsValid());
    return true;
} // ArrayAlloc

// =================================================================================================================
// ArrayFree
// =================================================================================================================
template<class T> void TArray<T>::ArrayFree (void)
{
    DASSERT(IsValid());
    SetElemSpace(0);
    DASSERT(IsValid());
} // ArrayFree

// =================================================================================================================
// SetElemSpace
// =================================================================================================================
template<class T> bool TArray<T>::SetElemSpace(ULONG n)
{
    DASSERT(IsValid());
    DASSERT(GetElemSize()>0);	
    
    if (n == GetElemSpace())	
        return true;
    
    // set count
    m_cElem = min(n, m_cElem); //in case the new space is less than the count

    ULONG cbNewSize = 0;

    if (n)
    {
        cbNewSize = GetElemSize() * n;
    }

    BYTE *pbNewAddr;
    
    // try to resize base address
    if (cbNewSize)
    {
        if (!BaseAddress()) 
        {
            if (m_fZeroMem)
            {
                pbNewAddr = (BYTE *)::malloc(cbNewSize);

                if (pbNewAddr != NULL)
                {
                    ZeroMemory(pbNewAddr, cbNewSize);
                }
            }
            else
            {
                pbNewAddr = (BYTE *)::malloc(cbNewSize);
            }
        }
        else				
        {
            pbNewAddr = (BYTE *)::realloc(BaseAddress(), cbNewSize);

            // We may need to zero-out the new portion of
            // the allocation
            if (pbNewAddr && m_fZeroMem)
            {
                // Compute how many bytes we used to have
                ULONG cbOld = GetElemSpace()*GetElemSize();

                // Zero out starting at the first new byte, and continuing
                // for the rest of the allocation
                ZeroMemory(pbNewAddr + cbOld, cbNewSize - cbOld);
            }
        }
        
        if (pbNewAddr == NULL)		
        {
            DASSERT(0); 
            return false;
        }
    }
    else
    {
        if (BaseAddress())
            ::free(BaseAddress());
        pbNewAddr = NULL;
    }
    
    //set new pointer values and sizes
    m_pbBaseAddress = pbNewAddr;
    m_cElemSpace = n;
    
    UpdateDataPointer();
    DASSERT(IsValid());
    return true;
} // SetElemSpace

// =================================================================================================================
// SetElemCount
// =================================================================================================================
template<class T> bool TArray<T>::SetElemCount(ULONG n)
{
    DASSERT(IsValid());
    DASSERT(n >= 0);
    
    if (n > GetElemSpace())	
    {
        LONG space = n;
        if (m_cElemGrowSize)
            space = LONG((n + m_cElemGrowSize - 1)/m_cElemGrowSize) * m_cElemGrowSize;

        if (!SetElemSpace(space))	
        {
            DASSERT(0); 
            return false;
        }
    }
    
    m_cElem = n;
    
    DASSERT(IsValid());
    return true;
} // SetElemCount

// =================================================================================================================
// AddElemCount
// =================================================================================================================
template<class T> bool TArray<T>::AddElemCount(ULONG n)
{
    DASSERT(IsValid());
    return SelElemCount(n + GetElemCount());
} // AddElemCount

// =================================================================================================================
// SetElem
// =================================================================================================================
template<class T> bool TArray<T>::SetElem(ULONG index, const T*  data)
{
    DASSERT(IsValid());
    DASSERT(data);
    DASSERT(BaseAddress());
    
    DASSERT(index < GetElemCount());
    
    (*this)[index]	= *data;
    
    DASSERT(IsValid());
    return true;
} // SetElem

// =================================================================================================================
// GetElem
// =================================================================================================================
template<class T> bool TArray<T>::GetElem(ULONG index, T*  data)
{
    DASSERT(IsValid());
    DASSERT(data);
    DASSERT(BaseAddress());
    DASSERT(index < GetElemCount());
    
    *data	= (*this)[index];

    DASSERT(IsValid());
    return true;
} // GetElem

// =================================================================================================================
// AddElem
// =================================================================================================================
template<class T> inline bool TArray<T>::AddElem(const T*  data)							
{
    DASSERT(IsValid());
    DASSERT(data);
    
    if (!SetElemCount(GetElemCount() + 1))
    {
        DASSERT(0); 
        return false;
    }				
    
    m_ptPtr[GetElemCount() - 1]	= *data;										
    DASSERT(IsValid());
    return true;									
} // AddElem

// =================================================================================================================
// InsertElem
// =================================================================================================================
template<class T> bool TArray<T>::InsertElem(ULONG index, const T& data)
{
    DASSERT(IsValid());
    
    ULONG cElemCurrent = GetElemCount();
    
    /*
    we allow an Insert to the end (ie if GetElemCount == 4 (indexes 0-3) and then
    we call InsertElem(4, data) this will work even though the index 4 doesnt yet exist
    
      BECAUSE - if we have 0 elements then there is no baseAddress - but we want to be 
      able to insert to an empty list!!
    */
    
    if (index > cElemCurrent)
    {
        // if we allow them to grow the array automatically by inserting past the end of the array??
        if (AddElemCount(index - cElemCurrent + 1))	
            return SetElem(index, data);
        return false;
    }
    else if (AddElemCount(1))
    {
        ULONC cElemToMove = cElemCurrent - index;
        
        ULONG copySize		= GetElemSize() * cElemToMove;
        
        // since regions overlaps we must move memory 
        if (copySize)
        {
            ULONG srcOffset	= GetElemSize() * index;
            ULONG dstOffset	= GetElemSize() * (index + 1);
            
            DASSERT(BaseAddress());
            
            ::memmove(BaseAddress() + dstOffset, BaseAddress() + srcOffset, copySize);
        }
        
        SetElem(index, data);
        
        return true;
    }
    
    DASSERT(0);
    
    return false;
} // InsertElem

#endif // for entire file
//************************************************************
//
// End of file
//
//************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\dll\dxtmsft.cpp ===
// DXTMsft.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//          To build a separate proxy/stub DLL, 
//          run nmake -f DXTMsftps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <DXTMsft.h>

#ifdef _DEBUG
#include <crtdbg.h>
#endif


/////////////////////////////////////////////////////////////////////////////
// Global Variables...

CDXMMXInfo  g_MMXDetector;       // Determines the presence of MMX instructions.

CComModule  _Module;


//+-----------------------------------------------------------------------------
//
//  This section was added when moving code over to the Trident tree.  The
//  following global variables and functions are required to link properly.
//
//------------------------------------------------------------------------------

// lint !e509
// g_hProcessHeap is set by the CRT in dllcrt0.c

EXTERN_C HANDLE     g_hProcessHeap      = NULL;
LCID                g_lcidUserDefault   = 0;
DWORD               g_dwFALSE           = 0;


///////////////////////////////////////////////////////////////////
//
//  LOOKING FOR BEGIN_OBJECT_MAP()????
//
//   Here's the deal: Because ATL is based on templates, the classes
// that implement our objects have a lot of templatized code that must
// all be expanded by the compiler. This takes a lot of memory and time
// for the compiler to do, and it can get to the point where build
// machines run out of swap space. So the solution is to create an
// OBJECT_MAP structure dynamically. It's not hard, it's just an array
// of structures.
//
// So what we do is split the workload of expanding all these templates
// across multiple files by defining a "fragment" of the OBJECT_MAP
// in each file. Then we reference these global tables and in the final
// code, when we get called for DLL_PROCESS_ATTACH, we allocate an array
// big enough to hold all the fragments, and then we copy the OBJECT_MAP
// entries into it.  Then we just pass that pointer to ATL and everyone
// is happy.
//
// The core type for the OBJECT_MAP is _ATL_OBJMAP_ENTRY and the map
// is just an array of them. I use the END_OBJECT_MAP macro on the last
// one because that macro *does* add special entries. See files objmap*.cpp
// for the object map fragments.
//
///////////////////////////////////////////////////////////////////

// Reference the ATL object map data objects which are external to this
// file. They're external to prevent template code expansion from
// happening all in one file and swamping the compiler -- the intermediate
// file size of template expansion and the memory requirements of the
// compiler are quite huge.
extern _ATL_OBJMAP_ENTRY ObjectMap1[];
extern _ATL_OBJMAP_ENTRY ObjectMap2[];

// These variables tell us how many entries there are in each of the
// corresponding ObjectMap arrays defined above.
extern int g_cObjs1, g_cObjs2;

// This global pointer will hold the full object
// map for this instance of the DLL.
static _ATL_OBJMAP_ENTRY *g_pObjectMap = NULL;

///////////////////////////////////////
// InitGlobalObjectMap
//
BOOL InitGlobalObjectMap(void)
{
    // We should be getting here only because a new DLL data segment
    // exists for each process.
    _ASSERT(NULL == g_pObjectMap);

    // Assume the global object map was already successfully created.
    if (NULL != g_pObjectMap)
        return TRUE;

    // Allocate one big object map to give to ATL
    g_pObjectMap = new _ATL_OBJMAP_ENTRY[g_cObjs1 + g_cObjs2];
    if (NULL == g_pObjectMap)
        return FALSE;

    // Now copy the object map fragments into one complete
    // structure, and then we'll give this structure to ATL.
    CopyMemory(g_pObjectMap,
                ObjectMap1, sizeof(ObjectMap1[0]) * g_cObjs1);
    CopyMemory(g_pObjectMap + g_cObjs1,
                ObjectMap2, sizeof(ObjectMap2[0]) * g_cObjs2);

    return TRUE;
} // InitGlobalObjectMap

///////////////////////////////////////
// DeleteGlobalObjectMap
//
void DeleteGlobalObjectMap(void)
{
    if (NULL != g_pObjectMap)
    {
        delete[] g_pObjectMap;
        g_pObjectMap = NULL;
    }
} // DeleteGlobalObjectMap

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        if (!InitGlobalObjectMap())
            return FALSE;

        // If the above call returned success, then the object map BETTER be there...
        _ASSERT(NULL != g_pObjectMap);

        _Module.Init(g_pObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

#if DBG == 1
        // Turn on memory leak checking.

        int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
        _CrtSetDbgFlag(tmpFlag);

        // Make sure debug helpers are linked in.

        EnsureDebugHelpers();
#endif

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        DeleteGlobalObjectMap();
    }
    return TRUE;    // ok
} // DllMain

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} // DllCanUnloadNow


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
} // DllGetClassObject


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
} // DllRegisterServer


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();

#if(_ATL_VER < 0x0300)
    ::UnRegisterTypeLib(LIBID_DXTMSFTLib, 
                        DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER, 
                        LOCALE_NEUTRAL, SYS_WIN32);
#endif

    return S_OK;
} // DllUnregisterServer


//
//
//
STDAPI DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    if (i >= (g_cObjs1 + g_cObjs2) - 1)
    
    {
        return S_FALSE;
    }

    *pclsid = *(g_pObjectMap[i].pclsid);
    return _Module.GetClassObject(*pclsid, IID_IUnknown, (LPVOID*)ppUnk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\inc\debughelpers.h ===
//------------------------------------------------------------------------------
//
//  File:       debughelpers.h
//
//  Overview:   Helper functions to use during debugging.
//
//  History:
//  2000/01/26  mcalkins    Created.
//
//------------------------------------------------------------------------------

#if DBG == 1

void    EnsureDebugHelpers();
void    showme2(IDirectDrawSurface * surf, RECT * prc);
void *  showme(IUnknown * pUnk);

#ifdef _X86_
#define DASSERT(x)      {if (!(x)) _asm {int 3} }
#else  // !_X86_
#define DASSERT(x)      {if (!(x)) DebugBreak(); }
#endif // !_X86_

#else  // DBG != 1

#define DASSERT(x)

#endif // DBG != 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\dll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

// Since there are multiple directories that need to have stdafx.h, we put all
// the stuff in stdafx_common.h to have the actual code in only one place.

#include "stdafx_common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <dxtguid.c>
#include <atlctl.cpp>
#include <atlwin.cpp>
#include <dtbase.cpp>

#include "debughelpers.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\dll\objmap2.cpp ===
//***************************************************************************
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:            ObjMap2.cpp
//
// Created:             12/10/98
//
// Author:              PaulNash
//
// Description:         Object Map helper file (part 2). This file
//                      contains a portion of the DXTMSFT.DLL ATL object
//                      map.  It contains the entries for 15 objects.
//
// History
//
// 12/10/98 PaulNash    Created this file.
// 08/09/99 a-matcal    Removed MetaCreations transforms for move to Trident
//                      tree.  Moved CSS effects from objmap4.cpp to here.
//
//***************************************************************************

#include "stdafx.h"
#include "resource.h"
#include <dxtmsft.h>

#include "slide.h"
#include "inset.h"
#include "spiral.h"
#include "stretch.h"
#include "wheel.h"

#include "zigzag.h"
#include "chroma.h"
#include "dropshadow.h"
#include "glow.h"
#include "shadow.h"

#include "alpha.h"
#include "wave.h"
#include "light.h"
#include "checkerboard.h"
#include "revealtrans.h"

// TODO: This is the point to start a new objmapX.cpp file, but I'm just not in
//       the mood.

#include "maskfilter.h"
#include "redirect.h"
#include "alphaimageloader.h"
#include "randomdissolve.h"
#include "randombars.h"

#include "strips.h"
#include "motionblur.h"
#include "matrix.h"
#include "colormanagement.h"


_ATL_OBJMAP_ENTRY ObjectMap2[] = {
    OBJECT_ENTRY(CLSID_CrSlide,             CDXTSlide               )
    OBJECT_ENTRY(CLSID_DXTSlide,            CDXTSlideOpt            )
    OBJECT_ENTRY(CLSID_CrInset,             CDXTInset               )
    OBJECT_ENTRY(CLSID_DXTInset,            CDXTInsetOpt            )
    OBJECT_ENTRY(CLSID_CrSpiral,            CDXTSpiral              )

    OBJECT_ENTRY(CLSID_DXTSpiral,           CDXTSpiralOpt           )
    OBJECT_ENTRY(CLSID_CrStretch,           CDXTStretch             )
    OBJECT_ENTRY(CLSID_DXTStretch,          CDXTStretchOpt          )
    OBJECT_ENTRY(CLSID_CrWheel,             CWheel                  )
    OBJECT_ENTRY(CLSID_CrZigzag,            CDXTZigZag              )

    OBJECT_ENTRY(CLSID_DXTZigzag,           CDXTZigZagOpt           )
    OBJECT_ENTRY(CLSID_DXTChroma,           CChroma                 )
    OBJECT_ENTRY(CLSID_DXTDropShadow,       CDropShadow             )
    OBJECT_ENTRY(CLSID_DXTGlow,             CGlow                   )
    OBJECT_ENTRY(CLSID_DXTShadow,           CShadow                 )

    OBJECT_ENTRY(CLSID_DXTAlpha,            CAlpha                  )
    OBJECT_ENTRY(CLSID_DXTWave,             CWave                   )
    OBJECT_ENTRY(CLSID_DXTRevealTrans,      CDXTRevealTrans         )
    OBJECT_ENTRY(CLSID_DXTCheckerBoard,     CDXTCheckerBoard        )
    OBJECT_ENTRY(CLSID_DXTLight,            CLight                  )

    OBJECT_ENTRY(CLSID_DXTMaskFilter,       CDXTMaskFilter          )
    OBJECT_ENTRY(CLSID_DXTRedirect,         CDXTRedirect            )
    OBJECT_ENTRY(CLSID_DXTAlphaImageLoader, CDXTAlphaImageLoader    )
    OBJECT_ENTRY(CLSID_DXTRandomDissolve,   CDXTRandomDissolve      )
    OBJECT_ENTRY(CLSID_DXTRandomBars,       CDXTRandomBars          )

    OBJECT_ENTRY(CLSID_DXTStrips,           CDXTStrips              )
    OBJECT_ENTRY(CLSID_DXTMotionBlur,       CDXTMotionBlur          )
    OBJECT_ENTRY(CLSID_DXTMatrix,           CDXTMatrix              )
    OBJECT_ENTRY(CLSID_DXTICMFilter,        CDXTICMFilter           )

END_OBJECT_MAP()

int g_cObjs2 = sizeof(ObjectMap2) / sizeof(ObjectMap2[0]);

////////////////////////////////////////////////////
// End Of File
////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\rsrc\makefile.inc ===
#
# makefile.inc
#
#     Makefile dependency rules for special files not
# automagically processed by BUILD.EXE.
#

dxtmsft.rc : \
    $(SDK_LIB_PATH)\dxtmsft.tlb \
    alpha.rgs               \
    alphaimageloader.rgs    \
    barn.rgs                \
    barnopt.rgs             \
    blinds.rgs              \
    blindsopt.rgs           \
    checkerboard.rgs        \
    chroma.rgs              \
    coloradj.rgs            \
    colormanagement.rgs     \
    composit.rgs            \
    convolve.rgs            \
    crblur.rgs              \
    cremboss.rgs            \
    crengrav.rgs            \
    dropshadow.rgs          \
    dxtwipe.rgs             \
    fade.rgs                \
    glow.rgs                \
    graddsp.rgs             \
    gradientwipe.rgs        \
    image.rgs               \
    iris.rgs                \
    irisopt.rgs             \
    inset.rgs               \
    insetopt.rgs            \
    light.rgs               \
    matrix.rgs              \
    maskfilter.rgs          \
    motionblur.rgs          \
    pixelate.rgs            \
    randombars.rgs          \
    randomdissolve.rgs      \
    revealtrans.rgs         \
    rwipe.rgs               \
    rwipeopt.rgs            \
    shadow.rgs              \
    slide.rgs               \
    slideopt.rgs            \
    spiral.rgs              \
    spiralopt.rgs           \
    stretch.rgs             \
    stretchopt.rgs          \
    strips.rgs              \
    wave.rgs                \
    wheel.rgs               \
    zigzag.rgs              \
    zigzagopt.rgs           \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DXTMsft.rc
//
#define IDS_PROJNAME                    100
#define IDS_TITLERipProp                101
#define IDS_HELPFILERipProp             102
#define IDS_DOCSTRINGRipProp            103
#define IDS_TITLEDisProp                104
#define IDS_HELPFILEDisProp             105
#define IDR_EXPLODE                     106
#define IDD_RIPPROP                     106
#define IDS_IDS_DOCSTRINGDisProp        106
#define IDR_RUFFLE                      107
#define IDR_HEIGHTFIELD                 108
#define IDR_FADE                        109
#define IDS_TITLEFadePP                 110
#define IDS_HELPFILEFadePP              111
#define IDS_DOCSTRINGFadePP             112
#define IDR_FADEPP                      113
#define IDD_FADEPP                      114
#define IDS_TITLEExplodeProp1           115
#define IDS_HELPFILEExplodeProp1        116
#define IDS_DOCSTRINGExplodeProp1       117
#define IDR_EXPLODEPROP1                118
#define IDD_EXPLODEPROP1                119
#define IDS_TITLERuffleProp             120
#define IDS_HELPFILERuffleProp          121
#define IDS_DOCSTRINGRuffleProp         122
#define IDR_RUFFLEPROP                  123
#define IDD_RUFFLEPROP                  124
#define IDR_IMAGE                       125
#define IDS_TITLEImagePP                126
#define IDS_HELPFILEImagePP             127
#define IDS_DOCSTRINGImagePP            128
#define IDR_IMAGEPP                     129
#define IDD_IMAGEPP                     130
#define IDR_DXTWIPEPP                   131
#define IDC_ORIGIN                      201
#define IDC_WAVELEN                     202
#define IDC_FADE_OVERLAP                202
#define IDC_DISSOLVE_SPEEDPT0           202
#define IDR_RIPPLE                      203
#define IDC_AMPLITUDE                   203
#define IDC_FADE_CENTER                 203
#define IDC_DISSOLVE_SPEEDPT2           203
#define IDC_NUMWAVES                    204
#define IDR_RIPPROP                     204
#define IDC_0                           204
#define IDC_DISSOLVE_SPEEDPT4           204
#define IDR_DISSOLVE                    205
#define IDC_MINSTEPS                    205
#define IDC_90                          205
#define IDC_DISSOLVE_SPEEDPT6           205
#define IDR_FLIP                        206
#define IDC_MAXSTEPS                    206
#define IDC_180                         206
#define IDC_DISSOLVE_SPEEDPT8           206
#define IDD_DISPROP                     207
#define IDC_270                         207
#define IDC_DISSOLVE_SPEEDPT1           207
#define IDR_DXBUFFERCACHE               208
#define IDC_CHECK_GREY                  208
#define IDC_DISSOLVE_SPEEDPT3           208
#define IDR_DXLUTBUILDER                209
#define IDC_CHECK_MIRROR                209
#define IDC_DISSOLVE_SPEEDPT5           209
#define IDR_DXTCOMPOSITE                210
#define IDC_OPACITY                     210
#define IDC_DISSOLVE_SPEEDPT7           210
#define IDR_DXTRESAMPLER                211
#define IDC_INVERT                      211
#define IDC_DISSOLVE_SPEEDPT9           211
#define IDR_DXTDLABEL                   212
#define IDC_XRAY                        212
#define IDR_DXTWIPE                     213
#define IDC_BLUR_ADD                    213
#define IDC_MAXBOX                      213
#define IDR_EXPLODEP                    214
#define IDC_BLUR_STRENGTH               214
#define IDC_BLUR_DIRECTION              216
#define IDC_BLUR                        217
#define IDC_MASK                        218
#define IDC_MASK_COLOR                  219
#define IDD_ExplodePROP                 220
#define IDC_GLOW                        220
#define IDS_TITLEExplodeProp            221
#define IDC_GLOW_STRENGTH               221
#define IDS_HELPFILEExplodeProp         222
#define IDC_GLOW_COLOR                  222
#define IDS_DOCSTRINGExplodeProp        223
#define IDC_SHADOW                      223
#define IDR_EXPLODEPROP                 224
#define IDC_SHADOW_COLOR                224
#define IDS_TITLEDXTWipePP              224
#define IDC_Explode_Tumble              225
#define IDC_SHADOW_DIRECTION            225
#define IDS_HELPFILEDXTWipePP           225
#define IDC_Explode_MaxRotations        226
#define IDC_GRADIENT_SIZE               226
#define IDS_DOCSTRINGDXTWipePP          226
#define IDC_Explode_FinalVelocity       227
#define IDC_LEFT                        227
#define IDC_HORIZONTAL                  227
#define IDC_Explode_PositionJump        228
#define IDC_RIGHT                       228
#define IDC_VERTICAL                    228
#define IDC_Explode_DecayTime           229
#define IDC_Ruffle_MaxRotations         232
#define IDR_DXTCONVOLUTION              233
#define IDR_CRBLUR                      234
#define IDB_BITMAP1                     235
#define IDR_PIXELATE                    236
#define IRD_PIXELPP                     237
#define IDD_PIXELPP                     238
#define IDS_TITLEPixelPP                240
#define IDS_HELPFILEPixelPP             241
#define IDS_TITLECrBlurPP               241
#define IDS_DOCSTRINGPixelPP            242
#define IDS_TITLEGradientPP             242
#define IDR_PIXELPP                     243
#define IDS_TITLELabelPP                243
#define IDD_DXTWIPEPP                   244
#define IDS_TITLEResamplPP              244
#define IDS_TITLECompositePP            245
#define IDD_RESAMPLEPP                  250
#define IDD_LABELPP                     251
#define IDD_CRBLURPP                    252
#define IDD_GRADIENTPP                  253
#define IDD_COMPOSITEPP                 254
#define IDD_CONVOLVEPP                  255
#define IDD_LUTBUILDPP                  256
#define IDR_DXTIRIS                     257
#define IDR_DXTBARN                     258
#define IDR_DXTBLINDS                   259
#define IDR_DXTRADIALWIPE               260
#define IDR_DXTSLIDE                    261
#define IDR_DROPSHADOW                  262
#define IDR_CHROMA                      263
#define IDR_DXTSTRETCH                  264
#define IDR_DXTINSET                    265
#define IDR_DXTSPIRAL                   266
#define IDR_DXTZIGZAG                   267
#define IDR_WHEEL                       268
#define IDR_SHATTER                     269
#define IDR_BLACKHOLE                   270
#define IDR_ROLL                        271
#define IDR_SPIN                        272
#define IDR_GLOW                        273
#define IDR_SHADOW                      274
#define IDR_ALPHA                       275
#define IDR_WAVE                        276
#define IDR_LIGHT                       277

#define IDC_FT_NEAREST                  300
#define IDC_FT_BILINEAR                 301
#define IDC_ROTATION                    302
#define IDC_SCALEX                      303
#define IDC_SCALEY                      304
#define IDC_TEXT_STRING                 305
#define IDC_LABEL_FG_A                  306
#define IDC_LABEL_FG_R                  307
#define IDC_LABEL_FG_G                  308
#define IDC_LABEL_FG_B                  309
#define IDC_LABEL_BG_A                  310
#define IDC_LABEL_BG_R                  311
#define IDC_LABEL_BG_G                  312
#define IDC_LABEL_BG_B                  313
#define IDC_LABEL_FONT                  314
#define IDC_CRBLUR_PIXELRADIUS          315
#define IDC_LABEL_TEXTURE               315
#define IDC_CRBLUR_SHADOW               316
#define IDC_EDIT2                       317
#define IDC_CRBLUR_OPACITY              317
#define IDC_CONV_SPREAD1                317
#define IDC_LABEL_YORG                  317
#define IDC_GRAD_WIDTH                  317
#define IDC_GRAD_HORIZ                  318
#define IDC_CRBLUR_MAXEFFPIXELRADIUS    318
#define IDC_GRAD_VERT                   319
#define IDC_GRAD_FG_A                   320
#define IDC_GRAD_START_A                320
#define IDC_GRAD_FG_R                   321
#define IDC_GRAD_START_R                321
#define IDC_GRAD_FG_G                   322
#define IDC_GRAD_START_G                322
#define IDC_GRAD_FG_B                   323
#define IDC_GRAD_START_B                323
#define IDC_GRAD_BG_A                   324
#define IDC_GRAD_END_A                  324
#define IDC_GRAD_BG_R                   325
#define IDC_GRAD_END_R                  325
#define IDC_GRAD_BG_G                   326
#define IDC_GRAD_END_G                  326
#define IDC_GRAD_BG_B                   327
#define IDC_GRAD_END_B                  327
#define IDC_COMP_CLEAR                  328
#define IDC_COMP_MIN                    329
#define IDC_COMP_MAX                    330
#define IDC_COMP_A                      331
#define IDC_COMP_A_OVER_B               332
#define IDC_COMP_A_IN_B                 333
#define IDC_COMP_A_OUT_B                334
#define IDC_COMP_A_ATOP_B               335
#define IDC_COMP_A_SUB_B                336
#define IDC_COMP_A_ADD_B                337
#define IDC_COMP_A_XOR_B                338
#define IDC_COMP_B                      339
#define IDC_COMP_B_OVER_A               340
#define IDC_COMP_B_IN_A                 341
#define IDC_COMP_B_OUT_A                342
#define IDC_COMP_B_ATOP_A               343
#define IDC_COMP_B_SUB_A                344
#define IDC_COMP_B_ADD_A                345
#define IDC_COMP_B_XOR_A                346
#define IDC_CONV_BLUR3X3                347
#define IDC_CONV_SHARPEN                348
#define IDC_CONV_ROB_HR                 349
#define IDC_CONV_ROB_HC                 350
#define IDC_CONV_PREW_HR                351
#define IDC_CONV_PREW_HC                352
#define IDC_CONV_SOB_HR                 353
#define IDC_CONV_SOB_HC                 354
#define IDC_CONV_PC_E                   355
#define IDC_CONV_PC_NE                  356
#define IDC_CONV_PC_N                   357
#define IDC_CONV_PC_NW                  358
#define IDC_CONV_PC_W                   359
#define IDC_CONV_PC_SW                  360
#define IDC_CONV_PC_S                   361
#define IDC_CONV_PC_SE                  362
#define IDC_CONV_KC_E                   363
#define IDC_CONV_KC_NE                  364
#define IDC_CONV_KC_N                   365
#define IDC_CONV_KC_NW                  366
#define IDC_CONV_KC_W                   367
#define IDC_CONV_KC_SW                  368
#define IDC_CONV_KC_S                   369
#define IDC_CONV_KC_SE                  370
#define IDC_CONV_CUSTOM                 371
#define IDC_CONV_GAUSS                  372
#define IDC_EDIT3                       373
#define IDC_CONV_SPREAD2                373
#define IDC_GLOW_A                      374
#define IDC_GLOW_R                      375
#define IDC_GLOW_G                      376
#define IDC_GLOW_B                      377
#define IDC_SHADOW_A                    378
#define IDC_HtField_Width               378
#define IDC_SHADOW_R                    379
#define IDC_HtField_Height              379
#define IDC_SHADOW_G                    380
#define IDC_HtField_Depth               380
#define IDC_SHADOW_B                    381
#define IDC_HtField_Samples             381
#define IDC_MASK_A                      382
#define IDC_MASK_R                      383
#define IDC_LABEL_XORG                  383
#define IDC_MASK_G                      384
#define IDC_MASK_B                      385
#define IDC_GRAD_HEIGHT                 385
#define IDC_GRAD_ASPECT                 386
#define IDR_CRBLURPP                    400
#define IDR_GRADIENTPP                  401
#define IDR_LABELPP                     402
#define IDR_RESAMPLEPP                  403
#define IDR_DXTGRADDSP                  404
#define IDR_CONVOLVEPP                  406
#define IDR_COMPOSITEPP                 407
#define IDR_GRADDSP                     408
#define IDC_Flip_Depth                  409
#define IDC_Flip_Height                 410
#define IDC_Flip_Width                  411
#define IDS_TITLEFlipProp               412
#define IDS_HELPFILEFlipProp            413
#define IDS_DOCSTRINGFlipProp           414
#define IDR_FLIPPROP                    415
#define IDD_FLIPPROP                    416
#define IDS_TITLEHtFieldProp            417
#define IDS_HELPFILEHtFieldProp         418
#define IDS_DOCSTRINGHtFieldProp        419
#define IDR_HTFIELDPROP                 420
#define IDD_HTFIELDPROP                 421
#define IDS_TITLEDisslvpp               422
#define IDS_HELPFILEDisslvpp            423
#define IDS_DOCSTRINGDisslvpp           424
#define IDR_DISSLVPP                    425
#define IDD_DISSLVPP                    426

#define IDC_BRIGHTNESS                  1002
#define IDC_CONTRAST                    1003
#define IDC_GAMMA                       1004
#define IDC_POSTERIZELEVELS             1005
#define IDC_THRESHOLD                   1006
#define IDC_INVERTTHRESHOLD             1007
#define IDC_REDBAL_L                    1008
#define IDC_REDBAL_M                    1009
#define IDC_REDBAL_H                    1010
#define IDC_REDBAL                      1011
#define IDC_GREENBAL_L                  1012
#define IDC_GREENBAL_M                  1013
#define IDC_GREENBAL_H                  1014
#define IDC_GREENBAL                    1015
#define IDC_BLUEBAL_L                   1016
#define IDC_BLUEBAL_M                   1017
#define IDC_BLUEBAL_H                   1018
#define IDC_BLUEBAL                     1019
#define IDC_REDBAL_VAL                  1020
#define IDC_CONTRAST_VAL                1021
#define IDC_BRIGHTNESS_VAL              1022
#define IDC_OPACITY_VAL                 1023
#define IDC_BLUEBAL_VAL                 1024
#define IDC_GREENBAL_VAL                1025
#define IDC_LUTOPORDER                  1026
#define IDC_BTN_OPUP                    1027
#define IDC_BTN_OPDOWN                  1028
#define IDC_RESET_BTN                   1031
#define IDR_CREMBOSS                    1032
#define IDR_CRENGRAVE                   1033

#define IDR_METARTG                     1034

#define IDR_TEXT3D                      1035

#define IDR_METABURNFILM                1036
#define IDR_METACENTERPEEL              1037
#define IDR_METACOLORFADE               1038
#define IDR_METAFLOWMOTION              1039
#define IDR_METAGRIDDLER                1040
#define IDR_METAGRIDDLER2               1041
#define IDR_METAJAWS                    1042
#define IDR_METALIGHTWIPE               1043
#define IDR_METALIQUID                  1044
#define IDR_METAPAGETURN                1045
#define IDR_METAPEELPIECE               1046
#define IDR_METAPEELSMALL               1047
#define IDR_METAPEELSPLIT               1048
#define IDR_METARADIALSCALEWIPE         1049
#define IDR_METARIPPLE                  1050
#define IDR_METAROLL                    1051
#define IDR_METATHRESHOLD               1052
#define IDR_METATWISTER                 1053
#define IDR_METAVACUUM                  1054
#define IDR_METAWATER                   1055
#define IDR_METAWHITEOUT                1056
#define IDR_METAWORMHOLE                1057

#define IDR_SHAPES                      1058
#define IDR_DXTCHECKERBOARD             1059
#define IDR_DXTREVEALTRANS              1060
#define IDR_DXTMASKFILTER               1061
#define IDR_DXTREDIRECT                 1062
#define IDR_DXTALPHAIMAGELOADER         1063
#define IDR_DXTRANDOMDISSOLVE           1064
#define IDR_DXTRANDOMBARS               1065
#define IDR_DXTSTRIPS                   1066
#define IDR_DXTIRISOPT                  1067
#define IDR_DXTBARNOPT                  1068
#define IDR_DXTBLINDSOPT                1069
#define IDR_DXTRADIALWIPEOPT            1070
#define IDR_DXTSLIDEOPT                 1071
#define IDR_DXTINSETOPT                 1072
#define IDR_DXTSPIRALOPT                1073
#define IDR_DXTZIGZAGOPT                1074
#define IDR_DXTSTRETCHOPT               1075
#define IDR_DXTGRADIENTWIPE             1076
#define IDR_DXTMOTIONBLUR               1077
#define IDR_DXTMATRIX                   1078
#define IDR_DXTICMFILTER                1079


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        264
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         387
#define _APS_NEXT_SYMED_VALUE           427
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\inc\stdafx_common.h ===
// stdafx.h : include file for standard system include files,
//            or project specific include files that are used frequently,
//            but are changed infrequently

#if !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_)
#define AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define _ATL_APARTMENT_THREADED

// Added 1999/09/22 by a-matcal to support UNICODE on win95.
#include <w95wraps.h>


#define ATLTRACE 1 ? (void)0 : AtlTrace
#include <atlbase.h>
#pragma intrinsic(memset, memcpy)

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

// Added 1999/09/22 by a-matcal to support UNICODE on win95.
#include <shlwapi.h>
#include <shlwapip.h>

// Use Trident debug stuff.
#define INCMSG(X)

#include <f3debug.h>

#include <ddraw.h>
#include <dxtransp.h>
#include <dtbase.h>
#include <dxtmsft.h>
#include <mshtml.h>

#include "debughelpers.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

// When we moved the code over to trident, all the _ASSERTs stopped working, so
// we'll use Assert instead.

#undef _ASSERT
#define _ASSERT(x) Assert(x);

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately
// before the previous line.

#endif // !defined(AFX_STDAFX_H__5E77EB07_937C_11D1_B047_00AA003B6061__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\alphaimageloader.h ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  FileName:   alphaimageloader.h
//
//  Overview:   The alpha image loader is to be used as a filter on web pages
//  `           that would like to display images that contain per pixel alpha.
//             
//  Change History:
//  1999/09/23  a-matcal    Created.
//  1999/11/23  a-matcal    Added SizingMethod property.
//
//------------------------------------------------------------------------------

#ifndef __ALPHAIMAGELOADER_H_
#define __ALPHAIMAGELOADER_H_

#include "resource.h"   




class ATL_NO_VTABLE CDXTAlphaImageLoader : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTAlphaImageLoader, &CLSID_DXTAlphaImageLoader>,
    public IDispatchImpl<IDXTAlphaImageLoader, &IID_IDXTAlphaImageLoader, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTAlphaImageLoader>,
    public IObjectSafetyImpl2<CDXTAlphaImageLoader>,
    public IPersistStorageImpl<CDXTAlphaImageLoader>,
    public IPersistPropertyBagImpl<CDXTAlphaImageLoader>,
    public IDXTScaleOutput,
    public IHTMLDXTransform
{
private:

    typedef enum {
        IMAGE = 0,
        CROP,
        SCALE,
        SIZINGMETHOD_MAX
    } SIZINGMETHOD;

    BSTR                    m_bstrSrc;
    BSTR                    m_bstrHostUrl;
    SIZINGMETHOD            m_eSizingMethod;
    static const WCHAR *    s_astrSizingMethod[SIZINGMETHOD_MAX];
    SIZE                    m_sizeManual;
    SIZE                    m_sizeSurface;

    CComPtr<IDXSurface>     m_spDXSurfSrc;
    CComPtr<IDXTransform>   m_spDXTransformScale;
    CComPtr<IDXTScale>      m_spDXTScale;
    CComPtr<IUnknown>       m_cpUnkMarshaler;
    
public:

    CDXTAlphaImageLoader();
    virtual ~CDXTAlphaImageLoader();

    DECLARE_POLY_AGGREGATABLE(CDXTAlphaImageLoader)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTALPHAIMAGELOADER)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTAlphaImageLoader)
        COM_INTERFACE_ENTRY(IDXTAlphaImageLoader)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTScaleOutput)
        COM_INTERFACE_ENTRY(IHTMLDXTransform)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTAlphaImageLoader>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTAlphaImageLoader)
        PROP_ENTRY("src",           DISPID_DXTALPHAIMAGELOADER_SRC, 
                   CLSID_DXTAlphaImageLoaderPP)
        PROP_ENTRY("sizingmethod",  DISPID_DXTALPHAIMAGELOADER_SIZINGMETHOD, 
                   CLSID_DXTAlphaImageLoaderPP)
        PROP_PAGE(CLSID_DXTAlphaImageLoaderPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT DetermineBnds(CDXDBnds & bnds);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);

    // IObjectWithSite methods (CDXBaseNTo1 overrides.)

    STDMETHOD(GetSite)(REFIID riid, void ** ppvSite);
    STDMETHOD(SetSite)(IUnknown * pUnkSite);

    // IDXTScaleOutput methods.

    STDMETHOD(SetOutputSize)(const SIZE sizeOut, BOOL fMaintainAspectRatio);

    // IHTMLDXTransform methods.

    STDMETHOD(SetHostUrl)(BSTR bstrHostUrl);

    // IDXTAlphaImageLoader properties.

    STDMETHOD(get_Src)(BSTR * pbstrSrc);
    STDMETHOD(put_Src)(BSTR bstrSrc);
    STDMETHOD(get_SizingMethod)(BSTR * pbstrSizingMethod);
    STDMETHOD(put_SizingMethod)(BSTR bstrSizingMethod);
};

#endif //__ALPHAIMAGELOADER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\alpha.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    alpha.h
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	This is the header file for the Alpha transformation
//
// Change History:
//
// 05/20/99 phillu   Move from dtcss to dxtmsft. Re-implemented algorithms for
//                   creating linear/rectangular/elliptic surfaces.
//
//------------------------------------------------------------------------------

#ifndef __ALPHA_H_
#define __ALPHA_H_

#include "resource.h"       // main symbols

// enum for supported Alpha styles
typedef enum {
    ALPHA_STYLE_CONSTANT = 0,
    ALPHA_STYLE_LINEAR,
    ALPHA_STYLE_RADIAL,
    ALPHA_STYLE_SQUARE
} AlphaStyleType;




class ATL_NO_VTABLE CAlpha : 
    public CDXBaseNTo1,
    public CComCoClass<CAlpha, &CLSID_DXTAlpha>,
    public CComPropertySupport<CAlpha>,
    public IDispatchImpl<IDXTAlpha, &IID_IDXTAlpha, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CAlpha>,
    public IPersistStorageImpl<CAlpha>,
    public ISpecifyPropertyPagesImpl<CAlpha>,
    public IPersistPropertyBagImpl<CAlpha>
{
private:

    SIZE    m_sizeInput;
    long    m_lPercentOpacity;
    long    m_lPercentFinishOpacity;
    long    m_lStartX;
    long    m_lStartY;
    long    m_lFinishX;
    long    m_lFinishY;
    AlphaStyleType m_eStyle;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    // Methods for gradient alpha

    void CompLinearGradientRow(int nXPos, int nYPos, int nWidth, 
                               BYTE *pGradRow);
    void CompRadialRow(int nXPos, int nYPos, int nWidth, BYTE * pGradRow);
    void CompRadialSquareRow(int nXPos, int nYPos, int nWidth, 
                             BYTE *pGradRow);

public:

    CAlpha();

    DECLARE_POLY_AGGREGATABLE(CAlpha)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_ALPHA)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CAlpha)
        COM_INTERFACE_ENTRY(IDXTAlpha)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CAlpha>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CAlpha)
        PROP_ENTRY("Opacity"      , 1, CLSID_DXTAlphaPP)
        PROP_ENTRY("FinishOpacity", 2, CLSID_DXTAlphaPP)
        PROP_ENTRY("Style"        , 3, CLSID_DXTAlphaPP)
        PROP_ENTRY("StartX"       , 4, CLSID_DXTAlphaPP)
        PROP_ENTRY("StartY"       , 5, CLSID_DXTAlphaPP)
        PROP_ENTRY("FinishX"      , 6, CLSID_DXTAlphaPP)
        PROP_ENTRY("FinishY"      , 7, CLSID_DXTAlphaPP)
        PROP_PAGE(CLSID_DXTAlphaPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    void    OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest,
                                  ULONG aInIndex[], BYTE aWeight[]);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinueProcessing);
    HRESULT OnSetup(DWORD dwFlags);

    // IDXTAlpha methods.

    STDMETHOD(get_Opacity)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_Opacity)(/*[in]*/ long newVal);
    STDMETHOD(get_FinishOpacity)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_FinishOpacity)(/*[in]*/ long newVal);
    STDMETHOD(get_Style)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_Style)(/*[in]*/ long newVal);
    STDMETHOD(get_StartX)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_StartX)(/*[in]*/ long newVal);
    STDMETHOD(get_StartY)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_StartY)(/*[in]*/ long newVal);
    STDMETHOD(get_FinishX)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_FinishX)(/*[in]*/ long newVal);
    STDMETHOD(get_FinishY)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_FinishY)(/*[in]*/ long newVal);
};

#endif //__ALPHA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\alphaimageloader.cpp ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  FileName:   alphaimageloader.cpp
//
//  Overview:   The alpha image loader is to be used as a filter on web pages
//  `           that would like to display images that contain per pixel alpha.
//             
//  Change History:
//  1999/09/23  a-matcal    Created.
//  1999/11/23  a-matcal    AddedSizingMethod property.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "alphaimageloader.h"




//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader static variables initialization
//
//------------------------------------------------------------------------------

const WCHAR * CDXTAlphaImageLoader::s_astrSizingMethod[] = {
    L"image",
    L"crop",
    L"scale"
    // TODO:  Add "tile"
};


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::CDXTAlphaImageLoader
//
//------------------------------------------------------------------------------
CDXTAlphaImageLoader::CDXTAlphaImageLoader() :
    m_bstrSrc(NULL),
    m_bstrHostUrl(NULL),
    m_eSizingMethod(IMAGE)
{
    m_sizeManual.cx     = 320;
    m_sizeManual.cy     = 240;

    // Base class members.

    m_ulNumInRequired   = 0;
    m_ulMaxInputs       = 0;

    // Because this DXTransform uses another DXTransform at times, it should
    // only use one thread for itself to avoid potential deadlocks and thread
    // conflicts.

    m_ulMaxImageBands   = 1;
}
//  CDXTAlphaImageLoader::CDXTAlphaImageLoader


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::~CDXTAlphaImageLoader
//
//------------------------------------------------------------------------------
CDXTAlphaImageLoader::~CDXTAlphaImageLoader()
{
    SysFreeString(m_bstrSrc);
    SysFreeString(m_bstrHostUrl);
}
//  CDXTAlphaImageLoader::~CDXTAlphaImageLoader


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAlphaImageLoader::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTAlphaImageLoader::FinalConstruct, CComObjectRootEx



//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::DetermineBnds, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTAlphaImageLoader::DetermineBnds(CDXDBnds & bnds)
{
    HRESULT hr = S_OK;

    // If the sizing method is set to size to the image bounds, always return 
    // the image bounds.  Otherwise, we won't change the bounds.
    //
    // One exception.  If the bounds passed into us are empty, it's a "secret"
    // signal that we should pass back the bounds we'd prefer to draw to if we
    // were asked to draw right now.  

    if (IMAGE == m_eSizingMethod)
    {
        if (m_spDXSurfSrc)
        {
            hr = m_spDXSurfSrc->GetBounds(&bnds);
        }
    }
    else if (bnds.BoundsAreEmpty())
    {
        bnds.SetXYSize(m_sizeManual);
    }

    return hr;
}
//  CDXTAlphaImageLoader::DetermineBnds, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAlphaImageLoader::OnInitInstData(CDXTWorkInfoNTo1 & WI, 
                                     ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;

    // Setup the scale transform if we can and need to.

    if (   IsTransformDirty() 
        && m_spDXSurfSrc
        && m_spDXTransformScale
        && (SCALE == m_eSizingMethod))
    {
        IDXSurface * pDXSurfIn  = m_spDXSurfSrc;
        IDXSurface * pDXSurfOut = OutputSurface();

        hr = m_spDXTransformScale->Setup((IUnknown **)&pDXSurfIn,  1, 
                                         (IUnknown **)&pDXSurfOut, 1, 0);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = m_spDXTScale->ScaleFitToSize(NULL, m_sizeManual, FALSE);

        if (FAILED(hr))
        {
            goto done;
        }
    }

done:

    return hr;
}
//  CDXTAlphaImageLoader::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAlphaImageLoader::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT     hr      = S_OK;
    DWORD       dwFlags = 0;
    CDXDBnds    bndsSrc = WI.DoBnds;
    CDXDBnds    bndsDst = WI.OutputBnds;

    // If they haven't given us a good source surface yet, just don't draw 
    // anything.

    if (!m_spDXSurfSrc)
    {
        goto done;
    }

    if (m_spDXTransformScale && (SCALE == m_eSizingMethod))
    {
        CDXDVec vecPlacement;

        WI.OutputBnds.GetMinVector(vecPlacement);

        hr = m_spDXTransformScale->Execute(NULL, &WI.DoBnds, &vecPlacement);

        goto done;
    }

    if (CROP == m_eSizingMethod)
    {
        CDXDBnds    bnds;

        hr = m_spDXSurfSrc->GetBounds(&bnds);

        if (FAILED(hr))
        {
            goto done;
        }

        // If the do bounds don't intersect the source image bounds, we don't
        // need to draw anything.

        if (!bnds.TestIntersect(WI.DoBnds))
        {
            goto done;
        }

        // We can only copy bounds to the right and bottom extents of the source
        // image.

        if (bndsSrc.Right() > bnds.Right())
        {
            long nOverrun = bndsSrc.Right() - bnds.Right();

            bndsSrc.u.D[DXB_X].Max -= nOverrun;
            bndsDst.u.D[DXB_X].Max -= nOverrun;
        }

        if (bndsSrc.Bottom() > bnds.Bottom())
        {
            long nOverrun = bndsSrc.Bottom() - bnds.Bottom();

            bndsSrc.u.D[DXB_Y].Max -= nOverrun;
            bndsDst.u.D[DXB_Y].Max -= nOverrun;
        }
    }

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    hr = DXBitBlt(OutputSurface(), bndsDst,
                  m_spDXSurfSrc, bndsSrc,
                  dwFlags, INFINITE);

done:

    return hr;
} 
//  CDXTAlphaImageLoader::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAlphaImageLoader::OnSurfacePick(const CDXDBnds & OutPoint, 
                                    ULONG & ulInputIndex, CDXDVec & InVec)
{
    HRESULT hr = S_OK;

    OutPoint.GetMinVector(InVec);

    if (   (OutPoint[DXB_X].Min < 0)
        || (OutPoint[DXB_X].Min >= m_sizeManual.cx)
        || (OutPoint[DXB_Y].Min < 0)
        || (OutPoint[DXB_Y].Min >= m_sizeManual.cy)
        || !m_spDXSurfSrc)
    {
        hr = S_FALSE;

        goto done;
    }

    if (m_spDXTransformScale && (SCALE == m_eSizingMethod))
    {
        CDXDVec                 vecOutPoint(InVec);
        CComPtr<IDXSurfacePick> spDXSurfacePick;

        hr = m_spDXTransformScale->QueryInterface(__uuidof(IDXSurfacePick),
                                                  (void **)&spDXSurfacePick);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDXSurfacePick->PointPick(&vecOutPoint, &ulInputIndex, &InVec);

        if (FAILED(hr))
        {
            goto done;
        }

        // Since the alpha image loader is a zero input transform, it doesn't
        // makes sense to return S_OK, so we'll translate DXT_S_HITOUTPUT which
        // does.

        if (S_OK == hr)
        {
            hr = DXT_S_HITOUTPUT;
        }
    }
    else
    {
        DXSAMPLE                sample;
        CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

        // If we're in crop mode and the element is larger than the source image
        // we may be able to hit outside the source image.

        if (   (OutPoint[DXB_X].Min >= m_sizeSurface.cx)
            || (OutPoint[DXB_Y].Min >= m_sizeSurface.cy))
        {
            hr = S_FALSE;

            goto done;
        }

        hr = m_spDXSurfSrc->LockSurface(&OutPoint, m_ulLockTimeOut, 
                                        DXLOCKF_READ, __uuidof(IDXARGBReadPtr),
                                        (void **)&spDXARGBReadPtr, NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        spDXARGBReadPtr->MoveToRow(0);

        spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

        if (sample.Alpha)
        {
            hr = DXT_S_HITOUTPUT;
        }
        else
        {
            hr = S_FALSE;
        }
    }

done:

    return hr;
}
//  CDXTAlphaImageLoader::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::GetSite, IObjectWithSite, CDXBaseNTo1
//
//  Notes:  GetSite and SetSite in the base class call Lock() and Unlock().
//          Because we can't do that in this function, there is a chance that
//          threading issues could arise.  
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::GetSite(REFIID riid, void ** ppvSite)
{
    return CDXBaseNTo1::GetSite(riid, ppvSite);
}
//  CDXTAlphaImageLoader::GetSite, IObjectWithSite, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::SetSite, IObjectWithSite, CDXBaseNTo1
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::SetSite(IUnknown * pUnkSite)
{
    if (m_cpUnkSite != pUnkSite)
    {
        HRESULT hr = S_OK;

        CComPtr<IDXTransformFactory>    spDXTransformFactory;
        CComPtr<IDXTransform>           spDXTransform;
        CComPtr<IDXTScale>              spDXTScale;

        m_spDXTransformScale.Release();
        m_spDXTScale.Release();

        // SetSite returns an hr, but won't fail.  See CDXBaseNTo1 comments for
        // details.

        CDXBaseNTo1::SetSite(pUnkSite);

        if (pUnkSite)
        {
            // In practice, SetSite is called before any of the IDXTransform 
            // methods are called, and only once.  So we shouldn't ever have a 
            // case where we need to re-setup the scale transform because 
            // SetSite is called at some random time.

            hr = GetSite(__uuidof(IDXTransformFactory), (void **)&spDXTransformFactory);

            if (FAILED(hr))
            {
                goto done;
            }

            hr = spDXTransformFactory->CreateTransform(NULL, 0, NULL, 0, NULL,
                                                       NULL, CLSID_DXTScale,
                                                       __uuidof(IDXTransform),
                                                       (void **)&spDXTransform);

            if (FAILED(hr))
            {
                goto done;
            }

            hr = spDXTransform->QueryInterface(__uuidof(IDXTScale),
                                               (void **)&spDXTScale);

            if (FAILED(hr))
            {
                goto done;
            }

            m_spDXTransformScale    = spDXTransform;
            m_spDXTScale            = spDXTScale;
        }
    }

done:

    return S_OK;
}
//  CDXTAlphaImageLoader::SetSite, IObjectWithSite, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::SetOutputSize, IDXTScaleOutput
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::SetOutputSize(const SIZE sizeOut, 
                                    BOOL /* fMaintainAspectRatio */)
{
    DXAUTO_OBJ_LOCK;

    if ((sizeOut.cx <= 0) || (sizeOut.cy <= 0))
    {
        return E_INVALIDARG;
    }

    m_sizeManual = sizeOut;

    SetDirty();

    return S_OK;
}
//  CDXTAlphaImageLoader::SetOutputSize, IDXTScaleOutput


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::SetHostUrl, IHTMLDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::SetHostUrl(BSTR bstrHostUrl)
{
    HRESULT hr = S_OK;

    SysFreeString(m_bstrHostUrl);

    m_bstrHostUrl = NULL;

    if (bstrHostUrl)
    {
        m_bstrHostUrl = SysAllocString(bstrHostUrl);

        if (NULL == m_bstrHostUrl)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }
    }

done:

    return hr;
}
//  CDXTAlphaImageLoader::SetHostUrl, IHTMLDXTransform


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::get_Src, IDXTAlphaImageLoader
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::get_Src(BSTR * pbstrSrc)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrSrc)
    {
        return E_POINTER;
    }

    if (*pbstrSrc != NULL)
    {
        return E_INVALIDARG;
    }

    if (NULL == m_bstrSrc)
    {
        *pbstrSrc = SysAllocString(L"");
    }
    else
    {
        *pbstrSrc = SysAllocString(m_bstrSrc);
    }

    if (NULL == *pbstrSrc)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTAlphaImageLoader::get_Src, IDXTAlphaImageLoader


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::put_Src, IDXTAlphaImageLoader
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::put_Src(BSTR bstrSrc)
{
    DXAUTO_OBJ_LOCK;

    HRESULT     hr              = S_OK;
    BSTR        bstrTemp        = NULL;
    WCHAR       strURL[2048]    = L"";
    WCHAR *     pchSrc          = (WCHAR *)bstrSrc;
    DWORD       cchURL          = 2048;
    BOOL        fAllow          = FALSE;
    CDXDBnds    bnds;
    SIZE        sizeSurface;

    CComPtr<IServiceProvider>   spServiceProvider;
    CComPtr<IDXSurface>         spDXSurfTemp;
    CComPtr<IDXSurfaceFactory>  spDXSurfaceFactory;
    CComPtr<ISecureUrlHost>     spSecureUrlHost;

    if (NULL == bstrSrc)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = GetSite(__uuidof(IServiceProvider), (void **)&spServiceProvider);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spServiceProvider->QueryService(SID_SDXSurfaceFactory, 
                                         __uuidof(IDXSurfaceFactory), 
                                         (void **)&spDXSurfaceFactory);

    if (FAILED(hr))
    {
        goto done;
    }

    if (m_bstrHostUrl)
    {
        HRESULT hrNonBlocking = ::UrlCombine(m_bstrHostUrl, bstrSrc, strURL, 
                                             &cchURL, URL_UNESCAPE );

        if (SUCCEEDED(hrNonBlocking))
        {
            pchSrc = strURL;
        }
    }

    hr = spServiceProvider->QueryService(__uuidof(IElementBehaviorSite),
                                         __uuidof(ISecureUrlHost),
                                         (void **)&spSecureUrlHost);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spSecureUrlHost->ValidateSecureUrl(&fAllow, pchSrc, 0);

    if (FAILED(hr))
    {
        goto done;
    }
    else if (!fAllow)
    {
        hr = E_FAIL;
        goto done;
    }
      
    hr = spDXSurfaceFactory->LoadImage(pchSrc, NULL, NULL, &DDPF_PMARGB32,
                                       __uuidof(IDXSurface), 
                                       (void **)&spDXSurfTemp);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDXSurfTemp->GetBounds(&bnds);

    if (FAILED(hr))
    {
        goto done;
    }

    bnds.GetXYSize(sizeSurface);

    bstrTemp = SysAllocString(bstrSrc);

    if (NULL == bstrTemp)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    SysFreeString(m_bstrSrc);
    m_spDXSurfSrc.Release();

    m_bstrSrc           = bstrTemp;
    m_spDXSurfSrc       = spDXSurfTemp;
    m_sizeSurface.cx    = sizeSurface.cx;
    m_sizeSurface.cy    = sizeSurface.cy;

    SetDirty();

done:

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    return hr;
}
//  CDXTAlphaImageLoader::put_Src, IDXTAlphaImageLoader


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::get_SizingMethod, IDXTAlphaImageLoader
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::get_SizingMethod(BSTR * pbstrSizingMethod)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrSizingMethod)
    {
        return E_POINTER;
    }

    if (*pbstrSizingMethod != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrSizingMethod = SysAllocString(s_astrSizingMethod[m_eSizingMethod]);

    if (NULL == *pbstrSizingMethod)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTAlphaImageLoader::get_SizingMethod, IDXTAlphaImageLoader


//+-----------------------------------------------------------------------------
//
//  CDXTAlphaImageLoader::put_SizingMethod, IDXTAlphaImageLoader
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAlphaImageLoader::put_SizingMethod(BSTR bstrSizingMethod)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrSizingMethod)
    {
        return E_POINTER;
    }

    for ( ; i < (int)SIZINGMETHOD_MAX ; i++)
    {
        if (!_wcsicmp(bstrSizingMethod, s_astrSizingMethod[i]))
        {
            break;
        }
    }

    if ((int)SIZINGMETHOD_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eSizingMethod != i)
    {
        m_eSizingMethod = (SIZINGMETHOD)i;
         
        SetDirty();
    }

    return S_OK;
}
//  CDXTAlphaImageLoader::put_SizingMethod, IDXTAlphaImageLoader
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\barn.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:                barn.cpp
//
// Created:                 06/24/98
//
// Author:                  PhilLu
//
// Discription:             This file implements the Barn Door transform.
//
// 06/24/98 phillu      initial creation
// 07/09/98 phillu      implement OnSetSurfacePickOrder().
// 07/22/98 phillu      implement clipping
// 04/26/99 a-matcal    Optimize.
// 09/25/99 a-matcal    Implement ICrBarn2 interface.
// 10/22/99 a-matcal    Changed CBarn class to CDXTBarnBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "barn.h"




//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase static variables initialization.
//
//------------------------------------------------------------------------------
const WCHAR * CDXTBarnBase::s_astrMotion[] = {
    L"in",
    L"out"
};


const WCHAR * CDXTBarnBase::s_astrOrientation[] = {
    L"horizontal",
    L"vertical"
};


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::CDXTBarnBase
//
//------------------------------------------------------------------------------
CDXTBarnBase::CDXTBarnBase() :
    m_eMotion(MOTION_OUT),
    m_eOrientation(ORIENTATION_VERTICAL),
    m_fOptimize(true),
    m_fOptimizationPossible(false),
    m_cbndsDirty(0)
{
    m_sizeInput.cx    = 0;
    m_sizeInput.cy    = 0;

    for (int i = 0; i < MAX_BARN_BOUNDS; i++)
    {
        m_aulSurfaceIndex[i] = 0;
    }

    // Base class members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTBarnBase::CDXTBarnBase


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBarnBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTBarnBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBarnBase::OnSetup(DWORD dwFlags)
{
    HRESULT     hr = S_OK;

    hr = m_bndsPrevDoor.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    m_bndsPrevDoor.GetXYSize(m_sizeInput);

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTBarnBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTBarnBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                             ULONG aInIndex[], BYTE aWeight[])
{
    long pickX      = OutPoint.Left();
    long pickY      = OutPoint.Top();
    long doorWidth  = 0;
    long offset     = 0;
    bool fInDoor    = false;

    if (ORIENTATION_VERTICAL == m_eOrientation)
    {
        doorWidth   = (long)(m_Progress * m_sizeInput.cx + 0.5);

        if (MOTION_IN == m_eMotion)
        {
            offset      = doorWidth / 2;
            doorWidth   = m_sizeInput.cx - doorWidth;
        }
        else
        {
            offset      = (m_sizeInput.cx - doorWidth) / 2;
        }

        fInDoor = ((pickX >= offset) && (pickX < m_sizeInput.cx - offset));
    }
    else // Horizontal doors.
    {
        doorWidth = (long)(m_Progress * m_sizeInput.cy + 0.5F);

        if (MOTION_IN == m_eMotion)
        {
            offset      = doorWidth / 2;
            doorWidth   = m_sizeInput.cy - doorWidth;
        }
        else
        {
            offset      = (m_sizeInput.cy - doorWidth) / 2;
        }

        fInDoor = ((pickY >= offset) && (pickY < m_sizeInput.cy - offset));
    }

    if (MOTION_OUT == m_eMotion)
    {
        aInIndex[0] = fInDoor ? 1 : 0;
    }
    else
    {
        aInIndex[0] = fInDoor ? 0 : 1;
    }

    ulInToTest = 1;
    aWeight[0] = 255;
}
//  CDXTBarnBase::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::_CalcFullBounds
//
//  Overview:   This method will calculate one or three sets of bounds 
//              representing the rectangles on the output containing input A 
//              and input B.  
//
//              One set of bounds is generated in the case where the progress
//              is close enough to either 1.0 or 0.0 that the "barn door" is 
//              either completely closed (draw over entire output with input A) 
//              or completely opened (draw over entire output with input B.) 
// 
//              The barn door is considered to be completely "closed" when 
//              progress is equal to 0.0 and moves toward being completely
//              "open" when progress is 1.0.
//
//              Doors completely closed:        Doors completely opened:
//
//              AAAAAAAAAAA                     BBBBBBBBBBB         
//              AAAAAAAAAAA                     BBBBBBBBBBB
//              AAAAAAAAAAA                     BBBBBBBBBBB
//              AAAAAAAAAAA                     BBBBBBBBBBB
//
//
//              Three sets of bounds are generated when the "barn door" is
//              is paritally opened.  One set of bounds is adjacent to the left
//              side of the output surface and is drawn with input A.  Another
//              is on the right side of the output surface and draw with input
//              A.  These are the "doors" of the barn.  The third set of bounds
//              represents the center of the output and is set to be filled
//              using input B.
//
//              Doors partially opened:
//
//              AAAABBBAAAA                             
//              AAAABBBAAAA                     
//              AAAABBBAAAA                     
//              AAAABBBAAAA                     
//
//
//              Note:  All coordinates are calculated in input space coordinates
//              assuming the entire output will need to be drawn.  Bounds will
//              be clipped and transformed to output space if needed by the 
//              WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTBarnBase::_CalcFullBounds()
{
    HRESULT     hr = S_OK;
    CDXDBnds    bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    if (m_bndsCurDoor.BoundsAreEmpty())
    {
        // If the currect door area is empty, paint over the entire output
        // surface with the barn surface.

        m_cbndsDirty            = 1;
        m_abndsDirty[0]         = bndsInput;

        m_aulSurfaceIndex[0]    = (MOTION_OUT == m_eMotion) ? 0 : 1;
    }
    else if (m_bndsCurDoor == bndsInput)
    {
        // If the current door bounds are equal to the input bounds, paint
        // over the entire output surface with the door surface.

        m_cbndsDirty            = 1;
        m_abndsDirty[0]         = bndsInput;

        m_aulSurfaceIndex[0]    = (MOTION_OUT == m_eMotion) ? 1 : 0;
    }
    else
    {
        // In this case the door is partially opened so we pass three sets of
        // bounds.  The left and right barn areas, and the middle door area.

        RECT        rcTemp;

        m_cbndsDirty = 3;

        // Left/top barn area.

        bndsInput.GetXYRect(rcTemp);

        if (ORIENTATION_VERTICAL == m_eOrientation)
        {
            rcTemp.right    = m_bndsCurDoor.Left();
        }
        else // Horizontal doors.
        {
            rcTemp.bottom   = m_bndsCurDoor.Top();
        }

        m_abndsDirty[0].SetXYRect(rcTemp);

        // Middle door area.

        m_abndsDirty[1] = m_bndsCurDoor;

        // Right/bottom barn area.

        bndsInput.GetXYRect(rcTemp);

        if (ORIENTATION_VERTICAL == m_eOrientation)
        {
            rcTemp.left = m_bndsCurDoor.Right();
        }
        else // Horizontal doors.
        {
            rcTemp.top  = m_bndsCurDoor.Bottom(); 
        }

        m_abndsDirty[2].SetXYRect(rcTemp);

        // Assign surface indexes to barn and door bounds.

        if (MOTION_OUT == m_eMotion)
        {
            m_aulSurfaceIndex[0] = 0;
            m_aulSurfaceIndex[1] = 1;
            m_aulSurfaceIndex[2] = 0;
        }
        else
        {
            m_aulSurfaceIndex[0] = 1;
            m_aulSurfaceIndex[1] = 0;
            m_aulSurfaceIndex[2] = 1;
        }
    }

done:

    return hr;
}
//  CDXTBarnBase::_CalcFullBounds


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::_CalcOptBounds
//
//  Overview:   This method will calculate one or two sets of bounds to update
//              the contents of the output surface assuming the surface has not 
//              been dirtied and that the output of this transform is not being
//              blended over the current contents of the output surface.  These
//              conditions are guaranteed by the OnInitInstData method that
//              calls this method.
//
//              The OnInitInstData method will also guarantee that there has
//              been some visible change in progress before calling this method.
//
//              One set of bounds is generated if the barn door has just shut 
//              completely or has just gone from completely closed to partially
//              or completely opened.  If this is the case, the set of bounds
//              generated represent the middle section of the output that can
//              be seen through the "barn doors."  If the doors are closing
//              these bounds will be filled with Input A, otherwise they will
//              be filled with Input B.
//              
//              On the diagrams below, the hyphens represent areas that are
//              already filled with Input A pixels.
//
//              Doors closing:      Doors opening:
//
//              ----AAA----         ----BBB----         
//              ----AAA----         ----BBB----
//              ----AAA----         ----BBB----
//              ----AAA----         ----BBB----
//
//
//              Two sets of bounds are generated if the barn doors have opened
//              some or closed some and were not before and are not now
//              completely closed.  The bounds represent the different between
//              the previous door position and the current door position.
//
//              On the diagrams below, the hyphens in the middle represent areas
//              that are already filled with Input B pixels.  The hypens on the
//              right and left edges represent pixels that are already filled
//              with Input A pixels.
//
//              Doors closing some:         Doors opening some:
//
//              --AA---AA--                 --BB---BB--         
//              --AA---AA--                 --BB---BB--
//              --AA---AA--                 --BB---BB--
//              --AA---AA--                 --BB---BB--
//
//
//              Note:  All coordinates are calculated in input space coordinates
//              assuming the entire output will need to be drawn.  Bounds will
//              be clipped and transformed to output space if needed by the 
//              WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTBarnBase::_CalcOptBounds()
{
    HRESULT hr = S_OK;

    if (m_bndsCurDoor == m_bndsPrevDoor)
    {
        // If the door bounds are the same as the previous door bounds, no
        // update is required.

        m_cbndsDirty = 0;
    }
    else if (m_bndsPrevDoor.BoundsAreEmpty())
    {
        // If the previous door bounds are empty (have no area) then we just
        // need to pass one set of bounds to the WorkProc to draw the whole
        // newly opened door with the door surface.

        m_cbndsDirty            = 1;
        m_abndsDirty[0]         = m_bndsCurDoor;
        m_aulSurfaceIndex[0]    = (MOTION_OUT == m_eMotion) ? 1 : 0;
    }
    else if (m_bndsCurDoor.BoundsAreEmpty())
    {
        // If the current door bounds are empty (have no area) then we just
        // need to pass one set of bounds to the WorkProc to draw over the
        // recently closed door area with the barn surface.

        m_cbndsDirty            = 1;
        m_abndsDirty[0]         = m_bndsPrevDoor;
        m_aulSurfaceIndex[0]    = (MOTION_OUT == m_eMotion) ? 0 : 1;
    }
    else
    {
        // At this point we know the doors have either opened a little wider 
        // or closed a little and we need to pass two sets of bounds to
        // paint over the dirty area with the appropriate input.

        CDXDBnds    bndsInput;
        RECT        rcLeft;
        RECT        rcRight;

        hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty = 2;

        // Left/top update bounds.

        bndsInput.GetXYRect(rcLeft);

        if (ORIENTATION_VERTICAL == m_eOrientation)
        {
            rcLeft.left     = min(m_bndsCurDoor.Left(), m_bndsPrevDoor.Left());
            rcLeft.right    = max(m_bndsCurDoor.Left(), m_bndsPrevDoor.Left());
        }
        else // Horizontal doors.
        {
            rcLeft.top      = min(m_bndsCurDoor.Top(), m_bndsPrevDoor.Top());
            rcLeft.bottom   = max(m_bndsCurDoor.Top(), m_bndsPrevDoor.Top());
        }

        m_abndsDirty[0].SetXYRect(rcLeft);

        // Right/bottom update bounds.

        bndsInput.GetXYRect(rcRight);

        if (ORIENTATION_VERTICAL == m_eOrientation)
        {
            rcRight.left    = min(m_bndsCurDoor.Right(), m_bndsPrevDoor.Right());
            rcRight.right   = max(m_bndsCurDoor.Right(), m_bndsPrevDoor.Right());
        }
        else // Horizontal doors.
        {
            rcRight.top     = min(m_bndsCurDoor.Bottom(), m_bndsPrevDoor.Bottom());
            rcRight.bottom  = max(m_bndsCurDoor.Bottom(), m_bndsPrevDoor.Bottom());
        }

        m_abndsDirty[1].SetXYRect(rcRight);

        if ((m_bndsCurDoor.Left() < m_bndsPrevDoor.Left())
            || (m_bndsCurDoor.Top() < m_bndsPrevDoor.Top()))
        {
            // Door is getting wider, paint more door.

            m_aulSurfaceIndex[0] = (MOTION_OUT == m_eMotion) ? 1 : 0;
            m_aulSurfaceIndex[1] = (MOTION_OUT == m_eMotion) ? 1 : 0;
        }
        else
        {
            // Door is getting smaller, paint over door.

            m_aulSurfaceIndex[0] = (MOTION_OUT == m_eMotion) ? 0 : 1;
            m_aulSurfaceIndex[1] = (MOTION_OUT == m_eMotion) ? 0 : 1;
        }
    }

done:

    return hr;
}
//  CDXTBarnBase::_CalcOptBounds


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTBarnBase::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    HRESULT hr          = S_OK;
    LONG    lDoorWidth  = 0;
    RECT    rcDoor;

    // Calculate the barn door bounds for this execute.

    if (ORIENTATION_VERTICAL == m_eOrientation)
    {
        lDoorWidth  = (long)(GetEffectProgress() * m_sizeInput.cx + 0.5F);

        if (MOTION_IN == m_eMotion)
        {
            lDoorWidth = m_sizeInput.cx - lDoorWidth;
        }

        rcDoor.top      = 0;
        rcDoor.bottom   = m_sizeInput.cy;
        rcDoor.left     = (m_sizeInput.cx - lDoorWidth) / 2;
        rcDoor.right    = rcDoor.left + lDoorWidth;
    }
    else // Horizontal doors.
    {
        lDoorWidth  = (long)(GetEffectProgress() * m_sizeInput.cy + 0.5F);

        if (MOTION_IN == m_eMotion)
        {
            lDoorWidth = m_sizeInput.cy - lDoorWidth;
        }

        rcDoor.left     = 0;
        rcDoor.right    = m_sizeInput.cx;
        rcDoor.top      = (m_sizeInput.cy - lDoorWidth) / 2;
        rcDoor.bottom   = rcDoor.top + lDoorWidth;
    }

    m_bndsCurDoor.SetXYRect(rcDoor);

    // If the inputs, output, or transform is dirty, or if we can't optimize we 
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize
        || !m_fOptimizationPossible)
    {
        hr = _CalcFullBounds();

        if (FAILED(hr))
        {
            goto done;
        }
    }
    else // Create optimized dirty bounds.
    {
        hr = _CalcOptBounds();

        if (FAILED(hr))
        {
            goto done;
        }
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBarnBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    DWORD   dwFlags         = 0;
    long    lInOutOffsetX   = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY   = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    for (ULONG i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;

        if (bndsSrc.IntersectBounds(WI.DoBnds, m_abndsDirty[i]))
        {
            bndsDest = bndsSrc;
            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            hr = DXBitBlt(OutputSurface(), bndsDest,
                          InputSurface(m_aulSurfaceIndex[i]), bndsSrc,
                          dwFlags, INFINITE);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTBarnBase::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTBarnBase::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    m_bndsPrevDoor = m_bndsCurDoor;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTBarnBase::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::get_Motion, ICrBarn2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTBarnBase::get_Motion(BSTR * pbstrMotion)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrMotion)
    {
        return E_POINTER;
    }

    if (*pbstrMotion != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrMotion = SysAllocString(s_astrMotion[m_eMotion]);

    if (NULL == *pbstrMotion)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTBarnBase::get_Motion, ICrBarn2


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::put_Motion, ICrBarn2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTBarnBase::put_Motion(BSTR bstrMotion)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrMotion)
    {
        return E_POINTER;
    }

    for ( ; i < (int)MOTION_MAX ; i++)
    {
        if (!_wcsicmp(bstrMotion, s_astrMotion[i]))
        {
            break;
        }
    }

    if ((int)MOTION_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eMotion != i)
    {
        m_eMotion = (MOTION)i;

        SetDirty();
    }

    return S_OK;
}
//  CDXTBarnBase::put_Motion, ICrBarn2


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::get_Orientation, ICrBarn2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTBarnBase::get_Orientation(BSTR * pbstrOrientation)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrOrientation)
    {
        return E_POINTER;
    }

    if (*pbstrOrientation != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrOrientation = SysAllocString(s_astrOrientation[m_eOrientation]);

    if (NULL == *pbstrOrientation)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTBarnBase::get_Orientation, ICrBarn2


//+-----------------------------------------------------------------------------
//
//  CDXTBarnBase::put_Orientation, ICrBarn2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTBarnBase::put_Orientation(BSTR bstrOrientation)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrOrientation)
    {
        return E_POINTER;
    }

    for ( ; i < (int)ORIENTATION_MAX ; i++)
    {
        if (!_wcsicmp(bstrOrientation, s_astrOrientation[i]))
        {
            break;
        }
    }

    if ((int)ORIENTATION_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((ORIENTATION)i != m_eOrientation)
    {
        m_eOrientation = (ORIENTATION)i;

        SetDirty();
    }

    return S_OK;
}
//  CDXTBarnBase::put_Orientation, ICrBarn2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\barn.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:                barn.h
//
// Created:                 06/24/98
//
// Author:                  PhilLu
//
// Discription:             This file declares CrBarn (Barn Door Transform)
//
// Change History:
// 06/24/98 PhilLu      Developed 1.0 version for Chromeffects
// 11/04/98 PaulNash    Moved from DT 1.0 codebase to IE5/NT5 DXTMSFT.DLL
// 04/26/99 a-matcal    optimize.
// 09/25/99 a-matcal    Inherit from ICrBarn2 interface.
// 10/22/99 a-matcal    Changed CBarn class to CDXTBarnBase and created two new
//                      classes CDXTBarn and CDXTBarnOpt to represent
//                      non-optimized and optimized versions repectively.
//
//------------------------------------------------------------------------------

#ifndef __CRBARN_H_
#define __CRBARN_H_

#include "resource.h"   

#define MAX_BARN_BOUNDS 3




class ATL_NO_VTABLE CDXTBarnBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrBarn2, &IID_ICrBarn2, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTBarnBase>,
    public IObjectSafetyImpl2<CDXTBarnBase>
{
private:

    typedef enum {
        MOTION_IN = 0,
        MOTION_OUT,
        MOTION_MAX
    } MOTION;

    MOTION                  m_eMotion;
    static const WCHAR *    s_astrMotion[MOTION_MAX];

    typedef enum {
        ORIENTATION_HORIZONTAL = 0,
        ORIENTATION_VERTICAL,
        ORIENTATION_MAX
    } ORIENTATION;

    ORIENTATION             m_eOrientation;
    static const WCHAR *    s_astrOrientation[ORIENTATION_MAX];

    SIZE                m_sizeInput;
    CDXDBnds            m_bndsCurDoor;
    CDXDBnds            m_bndsPrevDoor;
    CDXDBnds            m_abndsDirty[MAX_BARN_BOUNDS];
    ULONG               m_aulSurfaceIndex[MAX_BARN_BOUNDS];
    ULONG               m_cbndsDirty;

    CComPtr<IUnknown>   m_cpUnkMarshaler;

    // Helpers.

    HRESULT _CalcFullBounds();
    HRESULT _CalcOptBounds();

    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

public:

    CDXTBarnBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTBarnBase)
        COM_INTERFACE_ENTRY(ICrBarn2)
        COM_INTERFACE_ENTRY(ICrBarn)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTBarnBase>)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTBarnBase)
        PROP_ENTRY("motion",        DISPID_CRBARN_MOTION,       CLSID_CrBarnPP)
        PROP_ENTRY("orientation",   DISPID_CRBARN_ORIENTATION,  CLSID_CrBarnPP)
        PROP_PAGE(CLSID_CrBarnPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);

    // ICrBarn2 properties.

    STDMETHOD(get_Motion)(BSTR * pbstrMotion);
    STDMETHOD(put_Motion)(BSTR bstrMotion);
    STDMETHOD(get_Orientation)(BSTR * pbstrOrientation);
    STDMETHOD(put_Orientation)(BSTR bstrOrientation);

    // IDXEffect properties.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTBarn :
    public CDXTBarnBase,
    public CComCoClass<CDXTBarn, &CLSID_CrBarn>,
    public IPersistStorageImpl<CDXTBarn>,
    public IPersistPropertyBagImpl<CDXTBarn>
{
public:

    CDXTBarn()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTBARN)
    DECLARE_POLY_AGGREGATABLE(CDXTBarn)

    BEGIN_COM_MAP(CDXTBarn)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTBarnBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTBarnOpt :
    public CDXTBarnBase,
    public CComCoClass<CDXTBarnOpt, &CLSID_DXTBarn>,
    public IPersistStorageImpl<CDXTBarnOpt>,
    public IPersistPropertyBagImpl<CDXTBarnOpt>
{
public:

    CDXTBarnOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTBARNOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTBarnOpt)

    BEGIN_COM_MAP(CDXTBarnOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTBarnBase)
    END_COM_MAP()
};


#endif //__CRBARN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\blinds.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:            blinds.cpp
//
// Created:             06/24/98
//
// Author:              phillu
//
// Discription:         This is the implementation of the CrBlinds transform.
//
// History
//
// 06/24/98 phillu      initial creation
// 07/02/98 phillu      return E_INVALIDARG rather than an error string
// 07/09/98 phillu      implement OnSetSurfacePickOrder().
// 07/23/98 phillu      implement clipping
// 05/18/99 a-matcal    Optimization.
// 09/25/99 a-matcal    Implemented ICrBlinds2.
// 10/22/99 a-matcal    Changed CBlinds class to CDXTBlindsBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "blinds.h"

static const OLECHAR * g_astrDirection[] = {
    L"up",
    L"down",
    L"left",
    L"right"
};




//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::CDXTBlindsBase
//
//------------------------------------------------------------------------------
CDXTBlindsBase::CDXTBlindsBase() :
    m_cBands(10),
    m_lCurBandCover(0),
    m_lPrevBandCover(0),
    m_cbndsDirty(0),
    m_eDirection(DOWN),
    m_fOptimize(false),
    m_fOptimizationPossible(false)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // CDXBaseNTo1 members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTBlindsBase::CDXTBlindsBase


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBlindsBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTBlindsBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::_CalcFullBoundsHorizontalBands
//
//------------------------------------------------------------------------------
HRESULT
CDXTBlindsBase::_CalcFullBoundsHorizontalBands(long lBandHeight)
{
    HRESULT     hr              = S_OK;
    long        lBandUnCovered = lBandHeight - m_lCurBandCover;
    RECT        rc;
    CDirtyBnds  dbnds;

    rc.left     = 0;
    rc.top      = 0;
    rc.right    = m_sizeInput.cx;
    rc.bottom   = 0;

    // Note: Some of the bounds may include areas outside the input surface
    //       area.  This is OK because the bounds will be clipped to the 
    //       appropriate size in the WorkProc.

    while (rc.bottom < m_sizeInput.cy)
    {
        // Top portion of band.

        if (DOWN == m_eDirection)
        {
            rc.bottom       = rc.top + m_lCurBandCover;
            dbnds.ulInput   = 1;
        }
        else
        {
            rc.bottom       = rc.top + lBandUnCovered;
            dbnds.ulInput   = 0;
        }

        dbnds.bnds.SetXYRect(rc);

        hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty++;

        // Bottom portion of band.

        rc.top = rc.bottom;

        if (DOWN == m_eDirection)
        {
            rc.bottom       = rc.top + lBandUnCovered;
            dbnds.ulInput   = 0;
        }
        else
        {
            rc.bottom       = rc.top + m_lCurBandCover;
            dbnds.ulInput   = 1;
        }

        dbnds.bnds.SetXYRect(rc);

        hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty++;

        rc.top      = rc.bottom;
    }

done:

    return hr;
}
//  CDXTBlindsBase::_CalcFullBoundsHorizontalBands


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::_CalcFullBoundsVerticalBands
//
//------------------------------------------------------------------------------
HRESULT
CDXTBlindsBase::_CalcFullBoundsVerticalBands(long lBandWidth)
{
    HRESULT     hr              = S_OK;
    long        lBandUnCovered  = lBandWidth - m_lCurBandCover;
    RECT        rc;
    CDirtyBnds  dbnds;

    rc.left     = 0;
    rc.top      = 0;
    rc.right    = 0;
    rc.bottom   = m_sizeInput.cy;

    // Note: Some of the bounds may include areas outside the input surface
    //       area.  This is OK because the bounds will be clipped to the 
    //       appropriate size in the WorkProc.

    while (rc.right < m_sizeInput.cx)
    {
        // Left portion of band.

        if (RIGHT == m_eDirection)
        {
            rc.right        = rc.left + m_lCurBandCover;
            dbnds.ulInput   = 1;
        }
        else
        {
            rc.right        = rc.left + lBandUnCovered;
            dbnds.ulInput   = 0;
        }

        dbnds.bnds.SetXYRect(rc);

        hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty++;

        // Right portion of band.

        rc.left = rc.right;

        if (RIGHT == m_eDirection)
        {
            rc.right        = rc.left + lBandUnCovered;
            dbnds.ulInput   = 0;
        }
        else
        {
            rc.right        = rc.left + m_lCurBandCover;
            dbnds.ulInput   = 1;
        }

        dbnds.bnds.SetXYRect(rc);

        hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty++;

        rc.left = rc.right;
    }

done:

    return hr;
}
//  CDXTBlindsBase::_CalcFullBoundsVerticalBands


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::_CalcOptBoundsHorizontalBands
//
//------------------------------------------------------------------------------
HRESULT
CDXTBlindsBase::_CalcOptBoundsHorizontalBands(long lBandHeight)
{
    HRESULT     hr      = S_OK;
    RECT        rc;
    CDirtyBnds  dbnds;

    rc.left     = 0;
    rc.right    = m_sizeInput.cx;

    rc.top      = min(m_lPrevBandCover, m_lCurBandCover);
    rc.bottom   = max(m_lPrevBandCover, m_lCurBandCover) + 1;

    // If we're going up, vertically mirror bounds in band.

    if (UP == m_eDirection)
    {
        long lTopTemp = rc.top;

        rc.top      = (lBandHeight - rc.bottom) + 1;
        rc.bottom   = (lBandHeight - lTopTemp)  + 1;
    }

    if (m_lCurBandCover > m_lPrevBandCover)
    {
        dbnds.ulInput = 1;
    }
    else
    {
        dbnds.ulInput = 0;
    }

    // Note: Some of the bounds may include areas outside the input surface
    //       area.  This is OK because the bounds will be clipped to the 
    //       appropriate size in the WorkProc.

    while (rc.top < m_sizeInput.cy)
    {
        dbnds.bnds.SetXYRect(rc);

        hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty++;

        rc.top      += lBandHeight;
        rc.bottom   += lBandHeight;
    }

done:

    return hr;
}
//  CDXTBlindsBase::_CalcOptBoundsHorizontalBands


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::_CalcOptBoundsVerticalBands
//
//------------------------------------------------------------------------------
HRESULT
CDXTBlindsBase::_CalcOptBoundsVerticalBands(long lBandWidth)
{
    HRESULT     hr      = S_OK;
    RECT        rc;
    CDirtyBnds  dbnds;

    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    rc.left     = min(m_lPrevBandCover, m_lCurBandCover);
    rc.right    = max(m_lPrevBandCover, m_lCurBandCover) + 1;

    // If we're going left, horizontally mirror bounds in band.

    if (LEFT == m_eDirection)
    {
        long lLeftTemp = rc.left;

        rc.left     = (lBandWidth - rc.right)  + 1;
        rc.right    = (lBandWidth - lLeftTemp) + 1;
    }

    if (m_lCurBandCover > m_lPrevBandCover)
    {
        dbnds.ulInput = 1;
    }
    else
    {
        dbnds.ulInput = 0;
    }

    // Note: Some of the bounds may include areas outside the input surface
    //       area.  This is OK because the bounds will be clipped to the 
    //       appropriate size in the WorkProc.

    while (rc.left < m_sizeInput.cx)
    {
        dbnds.bnds.SetXYRect(rc);

        hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

        if (FAILED(hr))
        {
            goto done;
        }

        m_cbndsDirty++;

        rc.left     += lBandWidth;
        rc.right    += lBandWidth;
    }

done:

    return hr;
}
//  CDXTBlindsBase::_CalcOptBoundsVerticalBands


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBlindsBase::OnSetup(DWORD dwFlags)
{
    HRESULT     hr      = S_OK;
    CDXDBnds    bndsIn;
    
    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsIn.GetXYSize(m_sizeInput);

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
// CDXTBlindsBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTBlindsBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                               ULONG aInIndex[], BYTE aWeight[])
{
    long lBandHeight = (m_sizeInput.cy + m_cBands - 1) / m_cBands;
    long lBandCover = (long)(lBandHeight * m_Progress + 0.5);
       
    if ((OutPoint.Top() % lBandHeight) < lBandCover)
    {
        aInIndex[0] = 1;
    }
    else
    {
        aInIndex[0] = 0;
    }

    ulInToTest = 1;
    aWeight[0] = 255;
}
//  CDXTBlindsBase::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBlindsBase::OnInitInstData(CDXTWorkInfoNTo1 & WorkInfo, ULONG & ulNumBandsToDo)
{
    HRESULT hr          = S_OK;
    long    lBandSize   = 0;

    if ((UP == m_eDirection) || (DOWN == m_eDirection)) // Horizontal bands.
    {
        lBandSize = (m_sizeInput.cy + m_cBands - 1) / m_cBands;
    }
    else // Vertical bands.
    {
        lBandSize = (m_sizeInput.cx + m_cBands - 1) / m_cBands;
    }

    // Reset count of dirty bounds.

    m_cbndsDirty = 0;

    // Calculate lines of each band that are covered by input B for this
    // execute.

    m_lCurBandCover = (long)((float)lBandSize * m_Progress + 0.5F);

    // If the inputs, output, or transform is dirty, or if we can't optimize we 
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize 
        || !m_fOptimizationPossible)
    {
        if ((0 == m_lCurBandCover) || (lBandSize == m_lCurBandCover))
        {
            // If all of the band is taken up with one input, just fill the
            // whole output with that input.

            RECT        rc;
            CDirtyBnds  dbnds;

            rc.top      = 0;
            rc.left     = 0;
            rc.bottom   = m_sizeInput.cy;
            rc.right    = m_sizeInput.cx;

            dbnds.bnds.SetXYRect(rc);

            if (0 == m_lCurBandCover)
            {
                dbnds.ulInput = 0;  // Fill with input A.
            }
            else
            {
                dbnds.ulInput = 1;  // Fill with input B.
            }

            hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

            if (FAILED(hr))
            {
                goto done;
            }

            m_cbndsDirty++;
        }
        else
        {
            if ((UP == m_eDirection) || (DOWN == m_eDirection))
            {
                hr = _CalcFullBoundsHorizontalBands(lBandSize);
            }
            else
            {
                hr = _CalcFullBoundsVerticalBands(lBandSize);
            }
        }
    }
    else
    {
        // We're not blending with output, so we can call the functions 
        // that will generate bounds that only cover the dirty areas
        // of the output surface.

        // If the stretch width hasn't changed, nothing needs to be updated.

        if (m_lCurBandCover == m_lPrevBandCover)
        {
            goto done;
        }

        if ((UP == m_eDirection) || (DOWN == m_eDirection))
        {
            hr = _CalcOptBoundsHorizontalBands(lBandSize);
        }
        else
        {
            hr = _CalcOptBoundsVerticalBands(lBandSize);
        }
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WorkInfo.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WorkInfo.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTBlindsBase::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTBlindsBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    DWORD   dwFlags         = 0;
    long    lInOutOffsetX   = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY   = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    for (ULONG i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;
        CDirtyBnds  dbnds;

        hr = m_dabndsDirty.GetItem(dbnds, i);

        if (FAILED(hr))
        {
            goto done;
        }

        if (bndsSrc.IntersectBounds(WI.DoBnds, dbnds.bnds))
        {
            bndsDest = bndsSrc;
            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            hr = DXBitBlt(OutputSurface(), bndsDest,
                          InputSurface(dbnds.ulInput), bndsSrc,
                          dwFlags, INFINITE);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTBlindsBase::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTBlindsBase::OnFreeInstData(CDXTWorkInfoNTo1 & WorkInfo)
{
    m_lPrevBandCover = m_lCurBandCover;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTBlindsBase::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::get_bands, ICrBlinds
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTBlindsBase::get_bands(short * pVal)
{
   HRESULT hr = S_OK;

    if (!pVal)
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_cBands;
    }

    return hr;
}
//  CDXTBlindsBase::get_bands, ICrBlinds


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::put_bands, ICrBlinds
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTBlindsBase::put_bands(short newVal)
{
    if (newVal > 0 && newVal < 101)
    {
        if (m_cBands != newVal)
        {
            Lock();
            m_cBands = newVal;
            SetDirty();
            Unlock();
        }
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}
//  CDXTBlindsBase::put_bands, ICrBlinds

//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::get_Direction, ICrBlinds2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTBlindsBase::get_Direction(BSTR * pbstrDirection)
{
    HRESULT hr = S_OK;

    if (NULL == pbstrDirection)
    {
        hr = E_POINTER;

        goto done;
    }

    if (*pbstrDirection != NULL)
    {
        hr = E_INVALIDARG;
        
        goto done;
    }

    _ASSERT(m_eDirection < DIRECTION_MAX);

    *pbstrDirection = SysAllocString(g_astrDirection[m_eDirection]);

    if (NULL == *pbstrDirection)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    if (FAILED(hr) && *pbstrDirection)
    {
        SysFreeString(*pbstrDirection);
    }

    return hr;
}
//  CDXTBlindsBase::get_Direction, ICrBlinds2


//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase::put_Direction, ICrBlinds2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTBlindsBase::put_Direction(BSTR bstrDirection)
{
    HRESULT hr              = S_OK;
    int     nNewDirection   = 0;

    if (NULL == bstrDirection)
    {
        hr = E_POINTER;

        goto done;
    }

    while (nNewDirection < (int)DIRECTION_MAX)
    {
        if (!_wcsicmp(bstrDirection, g_astrDirection[nNewDirection]))
        {
            break;
        }

        nNewDirection++;
    }

    if ((int)DIRECTION_MAX == nNewDirection)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (nNewDirection != (int)m_eDirection)
    {
        Lock();

        m_eDirection = (DIRECTION)nNewDirection;

        SetDirty();

        Unlock();
    }

done:

    return hr;
}
//  CDXTBlindsBase::put_Direction, ICrBlinds2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\alpha.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    alpha.cpp
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	Implementation of Alpha transform CAlpha
//
// Change History:
//
// 05/20/99 PhilLu      Move from dtcss to dxtmsft. Re-implemented algorithms
//                      for creating linear/rectangular/elliptic surfaces.
// 10/18/99 a-matcal    StartY and FinishY were reversed.  It looked like the 
//                      old filter was purposely reversing them, but it wasn't.
//                      Changed properties to change value as the old alpha
//                      property functions did.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include <math.h>
#include "Alpha.h"

#if DBG == 1
static s_ulMaxImageBands = 0;
#endif




//+-----------------------------------------------------------------------------
//
//  CAlpha::CAlpha
//
//------------------------------------------------------------------------------
CAlpha::CAlpha() :
    m_lPercentOpacity(100),
    m_lPercentFinishOpacity(0),
    m_lStartX(0),
    m_lStartY(50),
    m_lFinishX(100),
    m_lFinishY(50),
    m_eStyle(ALPHA_STYLE_CONSTANT)

{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // CDXBaseNTo1 members.

    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;

#if DBG == 1
    if (s_ulMaxImageBands)
    {
        m_ulMaxImageBands = s_ulMaxImageBands;
    }
#endif
}
//  CAlpha::CAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CAlpha::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CAlpha::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_Opacity, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_Opacity(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lPercentOpacity;
    return S_OK;
}
//  CAlpha::get_Opacity, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_Opacity, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_Opacity(long newVal)
{
    if (newVal < 0) 
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }

    if (newVal != m_lPercentOpacity)
    {
        Lock();
        m_lPercentOpacity = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_Opacity, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_FinishOpacity, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_FinishOpacity(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lPercentFinishOpacity;
    return S_OK;
}
//  CAlpha::get_FinishOpacity, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_FinishOpacity, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_FinishOpacity(long newVal)
{
    if (newVal < 0) 
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }

    if (newVal != m_lPercentFinishOpacity)
    {
        Lock();
        m_lPercentFinishOpacity = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_FinishOpacity, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_Style, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_Style(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_eStyle;
    return S_OK;
}
//  CAlpha::get_Style, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_Style, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_Style(long newVal)
{
    if ((newVal < 0) || (newVal > 3))
    {
        return E_INVALIDARG;
    }

    if (newVal != m_eStyle)
    {
        Lock();
        m_eStyle = (AlphaStyleType) newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_Style, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_StartX, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_StartX(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lStartX;
    return S_OK;
}
//  CAlpha::get_StartX, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_StartX, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_StartX(long newVal)
{
    if (newVal < 0) 
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }

    if (newVal != m_lStartX)
    {
        Lock();
        m_lStartX = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_StartX, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_StartY, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_StartY(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lStartY;
    return S_OK;
}
//  CAlpha::get_StartY, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_StartY, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_StartY(long newVal)
{
    if (newVal < 0) 
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }


    if( newVal != m_lStartY )
    {
        Lock();
        m_lStartY = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_StartY, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_FinishX, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_FinishX(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lFinishX;
    return S_OK;
}
//  CAlpha::get_FinishX, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_FinishX, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_FinishX(long newVal)
{
    if (newVal < 0) 
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }


    if(newVal != m_lFinishX)
    {
        Lock();
        m_lFinishX = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_FinishX, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::get_FinishY, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::get_FinishY(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lFinishY;
    return S_OK;
}
//  CAlpha::get_FinishY, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::put_FinishY, IDXTAlpha
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CAlpha::put_FinishY(long newVal)
{
    if (newVal < 0) 
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }

    if (newVal != m_lFinishY)
    {
        Lock();
        m_lFinishY = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CAlpha::put_FinishY, IDXTAlpha


//+-----------------------------------------------------------------------------
//
//  CAlpha::OnGetsurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CAlpha::OnGetSurfacePickOrder(const CDXDBnds & /* OutPoint */, ULONG & ulInToTest, 
                              ULONG aInIndex[], BYTE aWeight[])
{
    ulInToTest = 1;
    aInIndex[0] = 0;
    aWeight[0] = 255;
}
//  CAlpha::OnGetsurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CAlpha::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CAlpha::OnSetup(DWORD /* dwFlags */)
{
    HRESULT hr = S_OK;

    CDXDBnds bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (SUCCEEDED(hr))
    {
        bndsIn.GetXYSize(m_sizeInput);
    }

    return hr;

}
//  CAlpha::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  INT_MULT
//
//  This is a helper function that computes (BYTE) (a*b + 128)/255f)
//
//------------------------------------------------------------------------------
inline int 
INT_MULT( BYTE a, int b )
{  
	int temp = (a*b) + 128;
	return ((temp>>8) + temp)>>8;
}
//  INT_MULT


//+-----------------------------------------------------------------------------
//
//  CAlpha::CompLinearGradientRow
//
//  Given a starting position (nXPos,nYPos), this functions computes a 
//  horizontal row of pixel values of a linear surface. The gradient surface is
//  defined by two points (Start and Finish) and the opacity values at these 
//  two points. The gradient direction is the direction of connecting these two 
//  points (i.e. the surface has constant value along a line perpendicular to 
//  the gradient direction). Between the two points, the opacity value is a 
//  linear interpolation of the two given values. Outside of the range of the 
//  two points, the value at the nearer end-point will hold.
//
//------------------------------------------------------------------------------
void 
CAlpha::CompLinearGradientRow(int nXPos, int nYPos, int nWidth, 
                              BYTE * pGradRow)
{
    int nOpac1  = (m_lPercentOpacity       * 255)   / 100;
    int nOpac2  = (m_lPercentFinishOpacity * 255)   / 100;
    int nx1     = (m_sizeInput.cx * m_lStartX)      / 100;
    int ny1     = (m_sizeInput.cy * m_lStartY)      / 100;   
    int nx2     = (m_sizeInput.cx * m_lFinishX)     / 100;
    int ny2     = (m_sizeInput.cy * m_lFinishY)     / 100;  

    // Notice above that the ny coordinates have been inverted so that
    // m_lStartX = 0 represents the bottom of the image, not the top.

    int ndx     = nx2 - nx1;
    int ndy     = ny2 - ny1;
    int nDist2  = (ndx * ndx) + (ndy * ndy);

    int i = 0;

    if (nDist2 == 0)
    {
        // Start and Finish points coinside with each other. 
        // create a constant surface

        for (i = 0; i < nWidth; i++)
        {
            pGradRow[i] = (BYTE)nOpac1;
        }
    }
    else
    {
        // create a linear surface. Since opacity value increments linearly 
        // along the row, we pre-compute the start value (flOpacity) and 
        // increment (flOpacInc) to save multiplications
        //
        // The relative distance at (x,y), projected to (x1,y1) -- (x2,y2) is
        //
        // r = [(x-x1)(x2-x1)+(y-y1)*(y2-y1)]/[(x2-x1)^2 + (y2-y1)^2]
        //
        // Thus the opacity value at (x,y) will be
        // op = op1, for r < 0;
        // op = op1 + r*(op2-op1), for 0 <= r <= 1
        // op = op2, for r > 1.
        //
        // flOpacity is the opacity at the beginning of the row. flOpacInc is
        // the increment of flOpacity when x increments by 1.
        //
        // nProj is the numerator part of r, and it is used to test the range
        // of r. nProj is also incremented along the row.

        // REVIEW:  In the float calculations below, cast nProj and ndx to 
        // floats also, to clarify that you're not using an integer division
        // trick of some sort (even though it's not division).

        int nProj = (nXPos - nx1) * ndx + (nYPos - ny1) * ndy;
        float flOpacity = (float)nOpac1 + 
                          (float)(nOpac2 - nOpac1) * nProj / (float)nDist2;
        float flOpacInc = (float)(nOpac2 - nOpac1) * ndx / (float)nDist2;

        for (i=0; i<nWidth; i++)
        {
            if (nProj < 0) // corresponds to r < 0
            {
                pGradRow[i] = (BYTE)nOpac1; // hold the end-point value
            }
            else if (nProj > nDist2)  // corresponds to r > 1
            {
                pGradRow[i] = (BYTE)nOpac2; // hold the end-point value
            }
            else  // 0 <= r <= 1; the current flOpacity is interpolated
            {
                pGradRow[i] = (BYTE)(flOpacity + 0.5);
            }

            // increment values for the next pixel in the row
            nProj += ndx;  // when nXPox inc by 1; nProj inc by ndx.
            flOpacity += flOpacInc;
        }
    }
}
//  CAlpha::CompLinearGradientRow


//+-----------------------------------------------------------------------------
//
//  CAlpha::CompRadialSquareRow
//
//  Create a horizontal row of pixel values on a square (rectangular) surface.
//
//------------------------------------------------------------------------------
void 
CAlpha::CompRadialSquareRow(int nXPos, int nYPos, int nWidth, 
                            BYTE *pGradRow)
{
    int nOpac1 = (m_lPercentOpacity       * 255) / 100;
    int nOpac2 = (m_lPercentFinishOpacity * 255) / 100;
    int i = 0;

    // This option is to be consistent with the original CSS filter. The radiao
    // or square surface always centers at the center of image and expands fully
    // to the edge of image.

    int     nCenterX    = m_sizeInput.cx / 2;
    int     nCenterY    = m_sizeInput.cy / 2;
    float   fdx         = 0.5F;
    float   fdy         = 0.5F;
    float   fDist       = (float)max(fabs(fdx), fabs(fdy));

    float fXInc = 1.0f / (m_sizeInput.cx * fDist);
    float fX = ((int)nXPos - nCenterX) * fXInc;
    float fY = ((int)nYPos - nCenterY) / (m_sizeInput.cy * fDist);
    float fRatio;

    for (i = 0 ; i < nWidth ; i++)
    {
        // Square shape: Z = max(|X|, |Y|), X, Y are normalized coord
        fRatio = (float)max(fabs(fX), fabs(fY));

        if (fRatio >= 1.0f)
        {
            pGradRow[i] = (BYTE)nOpac2;
        }
        else
        {
            pGradRow[i] = (BYTE)(nOpac1 + (nOpac2 - nOpac1) * fRatio + 0.5f);
        }

        fX += fXInc;
    }
}
//  CAlpha::CompRadialSquareRow


//+-----------------------------------------------------------------------------
//
//  CAlpha::CompRadialRow
//
//  Create a horizontal row of pixel values on a radial (elliptic) surface.
//
//------------------------------------------------------------------------------
void 
CAlpha::CompRadialRow(int nXPos, int nYPos, int nWidth, BYTE *pGradRow)
{
    int nOpac1      = (m_lPercentOpacity       * 255) / 100;
    int nOpac2      = (m_lPercentFinishOpacity * 255) / 100;
    int i           = 0;

    float   flXInc          = 2.0F / (float)m_sizeInput.cx;
    float   flXPos          = ((float)nXPos * flXInc) - 1.0F;
    float   flYPos          = ((float)nYPos * (2.0F / (float)m_sizeInput.cy)) 
                              - 1.0F;
    float   flYPosSquared   = flYPos * flYPos;

    float   flOpacVector    = (float)(nOpac2 - nOpac1);
    float   flRatio         = 0.0F;

    while (nWidth)
    {
        flRatio = (float)sqrt((flXPos * flXPos) + flYPosSquared);

        if (flRatio < 1.0F)
        {
            pGradRow[i] = (BYTE)(nOpac1 + (int)(flRatio * flOpacVector));
        }
        else
        {
            pGradRow[i] = (BYTE)(nOpac2);
        }

        i++;
        nWidth--;

        // Possible float drift, but this thing has bad enough perf with the 
        // sqrt for every pixel that we'll take our chances.

        flXPos += flXInc;
    }
}
//  CAlpha::CompRadialRow


//+-----------------------------------------------------------------------------
//
//  CAlpha::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CAlpha::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * /* pbContinueProcessing */)
{
    HRESULT hr  = S_OK;
    int     y   = 0;
    int     i   = 0;

    BYTE    bOpacity    = (BYTE)((m_lPercentOpacity * 255) / 100);

    DXPMSAMPLE * pOverScratch   = NULL;
    DXPMSAMPLE * pPMBuff        = NULL;
    DXSAMPLE *   pBuffer        = NULL;
    BYTE *       pGradRow       = NULL;

    CComPtr<IDXARGBReadWritePtr>    pDest;
    CComPtr<IDXARGBReadPtr>         pSrc;

    DXDITHERDESC        dxdd;

    const int nDoWidth = WI.DoBnds.Width();
    const int nDoHeight = WI.DoBnds.Height();

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE, IID_IDXARGBReadWritePtr,
                                      (void**)&pDest, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = InputSurface()->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOverScratch = DXPMSAMPLE_Alloca(nDoWidth);
    }

    pBuffer = DXSAMPLE_Alloca(nDoWidth);
    pGradRow = (BYTE *)_alloca(nDoWidth);
    
    //
    //  Set up the dither structure
    //
    if (DoDither())
    {
        dxdd.x = WI.OutputBnds.Left();
        dxdd.y = WI.OutputBnds.Top();
        dxdd.pSamples = pBuffer;
        dxdd.cSamples = nDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    for (y = 0; y < nDoHeight; y++)
    {
        pSrc->MoveToRow(y);
        pSrc->Unpack(pBuffer, nDoWidth, FALSE);

        if (m_eStyle == ALPHA_STYLE_CONSTANT)
        {
            for (i = 0; i < nDoWidth; i++)
            {
                if (pBuffer[i].Alpha > bOpacity)
                {
                    pBuffer[i].Alpha = bOpacity;
                }
            }
        }
        else
        {
            if (m_eStyle == ALPHA_STYLE_LINEAR)
            {
                CompLinearGradientRow(WI.DoBnds.Left(), WI.DoBnds.Top()+y,
                                      nDoWidth, pGradRow);
            }
            else if (ALPHA_STYLE_RADIAL == m_eStyle)
            {
                CompRadialRow(WI.DoBnds.Left(), WI.DoBnds.Top() + y, nDoWidth,
                              pGradRow);
            }
            else // ALPHA_STYLE_SQUARE
            {
                CompRadialSquareRow(WI.DoBnds.Left(), WI.DoBnds.Top()+y, 
                                    nDoWidth, pGradRow);
            }

            for (i = 0; i < nDoWidth; i++)
            {
                pBuffer[i].Alpha = (BYTE)INT_MULT(pGradRow[i], pBuffer[i].Alpha);
            }
        }

        // Get the output row
        pDest->MoveToRow(y);
        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            pPMBuff = DXPreMultArray(pBuffer, nDoWidth);
            pDest->OverArrayAndMove(pOverScratch, pPMBuff, nDoWidth);
        }
        else
        {
            pDest->PackAndMove(pBuffer, nDoWidth);
        }
    } // End for

    return hr;
}
//  CAlpha::WorkProc, CDXBaseNTo1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\blinds.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:            blinds.h
//
// Created:             06/24/98
//
// Author:              phillu
//
// Discription:         This is the header file for the CrBlinds transformation
//
// Change History:
// 06/24/98 PhilLu      Developed 1.0 version for Chromeffects
// 11/04/98 PaulNash    Moved from DT 1.0 codebase to IE5/NT5 DXTMSFT.DLL
// 05/19/99 a-matcal    Optimization.
// 09/25/99 a-matcal    Inherit from ICRBlinds2.
// 10/22/99 a-matcal    Changed CBlinds class to CDXTBlindsBase and created two
//                      new classes CDXTBlinds and CDXTBlindsOpt to represent
//                      non-optimized and optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRBLINDS_H_
#define __CRBLINDS_H_

#include "resource.h"

// gridbase.h included for dynamic array template class, and the CDirtyBnds
// class for holding a single set of dirty bounds and its corresponding input
// index.

#include "gridbase.h"  




//+-----------------------------------------------------------------------------
//
//  CDXTBlindsBase class
//
//------------------------------------------------------------------------------
class ATL_NO_VTABLE CDXTBlindsBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrBlinds2, &IID_ICrBlinds2, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTBlindsBase>,
    public IObjectSafetyImpl2<CDXTBlindsBase>,
    public ISpecifyPropertyPagesImpl<CDXTBlindsBase>
{
private:

    typedef enum {
        UP = 0,
        DOWN,
        LEFT,
        RIGHT,
        DIRECTION_MAX
    } DIRECTION;

    short       m_cBands;
    long        m_lCurBandCover;
    long        m_lPrevBandCover;
    SIZE        m_sizeInput;
    ULONG       m_cbndsDirty;
    DIRECTION   m_eDirection;

    CDynArray<CDirtyBnds>   m_dabndsDirty;

    CComPtr<IUnknown>       m_cpUnkMarshaler;

    HRESULT _CalcFullBoundsHorizontalBands(long lBandHeight);
    HRESULT _CalcOptBoundsHorizontalBands(long lBandHeight);

    HRESULT _CalcFullBoundsVerticalBands(long lBandWidth);
    HRESULT _CalcOptBoundsVerticalBands(long lBandWidth);

    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

public:

    CDXTBlindsBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTBlindsBase)
        COM_INTERFACE_ENTRY(ICrBlinds2)
        COM_INTERFACE_ENTRY(ICrBlinds)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTBlindsBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTBlindsBase)
        PROP_ENTRY("bands",     DISPID_CRBLINDS_BANDS,      CLSID_CrBlindPP)
        PROP_ENTRY("direction", DISPID_CRBLINDS_DIRECTION,  CLSID_CrBlindPP)
        PROP_PAGE(CLSID_CrBlindPP)
    END_PROPERTY_MAP()

    HRESULT FinalConstruct();

    // CDXTBaseNTo1 overrides.

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, 
                                  ULONG & ulInToTest, ULONG aInIndex[], 
                                  BYTE aWeight[]);
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WorkInfo, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WorkInfo);

    // ICrBlinds properties.

    STDMETHOD(get_bands)(/*[out, retval]*/ short *pVal);
    STDMETHOD(put_bands)(/*[in]*/ short newVal);

    // ICrBlinds2 properties.

    STDMETHOD(get_Direction)(BSTR * pbstrDirection);
    STDMETHOD(put_Direction)(BSTR bstrDirection);

    // IDXEffect properties.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTBlinds :
    public CDXTBlindsBase,
    public CComCoClass<CDXTBlinds, &CLSID_CrBlinds>,
    public IPersistStorageImpl<CDXTBlinds>,
    public IPersistPropertyBagImpl<CDXTBlinds>
{
public:

    CDXTBlinds()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTBLINDS)
    DECLARE_POLY_AGGREGATABLE(CDXTBlinds)

    BEGIN_COM_MAP(CDXTBlinds)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTBlindsBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTBlindsOpt :
    public CDXTBlindsBase,
    public CComCoClass<CDXTBlindsOpt, &CLSID_DXTBlinds>,
    public IPersistStorageImpl<CDXTBlindsOpt>,
    public IPersistPropertyBagImpl<CDXTBlindsOpt>
{
public:

    CDXTBlindsOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTBLINDSOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTBlindsOpt)

    BEGIN_COM_MAP(CDXTBlindsOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTBlindsBase)
    END_COM_MAP()
};

#endif //__CRBLINDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\chroma.cpp ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:        chroma.cpp
//
// Created:         1998/10/01
//
// Author:          MikeAr
//
// Discription:     This file implements the Chroma transform.
//
// 1998/10/01   MikeAr      Created.
// 1998/11/09   mcalkins    Moved to dxtmsft.dll.
// 1998/12/11   PaulNash    Remove OLE_COLOR, use VARIANT as VT_UI4 or 
//                          VT_BSTR.
// 2000/06/19   mcalkins    Store color as BSTR, return BSTR from get_color.
//
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "dxtmsft.h"
#include "dxclrhlp.h"
#include "filterhelpers.h"
#include "chroma.h"




//+-----------------------------------------------------------------------------
//
//  Method: CChroma::CChroma
//
//------------------------------------------------------------------------------
CChroma::CChroma() :
    m_clrChromaColor(0xFF0000FF)
{
    VariantInit(&m_varChromaColor);

    m_sizeInput.cx      = 0;
    m_sizeInput.cy      = 0;

    // CDXBaseNTo1 base class members.

    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;
}
//  Method: CChroma::CChroma


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::~CChroma
//
//------------------------------------------------------------------------------
CChroma::~CChroma()
{
    ::VariantClear(&m_varChromaColor);
}
//  Method: CChroma::~CChroma


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT
CChroma::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_spUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    _ASSERT(VT_EMPTY == m_varChromaColor.vt);

    m_varChromaColor.bstrVal = ::SysAllocString(L"blue");

    if (NULL == m_varChromaColor.bstrVal)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    m_varChromaColor.vt = VT_BSTR;

done:

    return hr;
}
//  Method: CChroma::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::put_Color, IDXTChroma
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CChroma::put_Color(VARIANT newVal)
{
    HRESULT     hr          = S_OK;
    DWORD       dwColor     = 0x00000000;
    BSTR        bstrTemp    = NULL;

    hr = FilterHelper_GetColorFromVARIANT(newVal, &dwColor, &bstrTemp);

    if (FAILED(hr))
    {
        goto done;
    }

    // The filter helper always allocates a BSTR because in many of the
    // DXTransforms property methods it's exactly what we want, but not here.

    SysFreeString(bstrTemp);

    if (!(dwColor & 0xFF000000))
    {
        dwColor |= 0xFF000000;
    }

    if (m_clrChromaColor != dwColor)
    {
        m_clrChromaColor = dwColor;
        SetDirty();
    }

    hr = ::VariantClear(&m_varChromaColor);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = ::VariantCopy(&m_varChromaColor, &newVal);

    if (FAILED(hr))
    {
        goto done;
    }

done:

    return S_OK;
}
//  Method: CChroma::put_Color, IDXTChroma


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::get_Color, IDXTChroma
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CChroma::get_Color(VARIANT * pVal)
{
    HRESULT hr = S_OK;

    if (NULL == pVal)
    {
        hr = E_POINTER;

        goto done;
    }

    hr = ::VariantClear(pVal);

    if (FAILED(hr))
    {
        goto done;
    }
    
    hr = ::VariantCopy(pVal, &m_varChromaColor);

    if (FAILED(hr))
    {
        goto done;
    }
    
done:

    return hr;
}
//  Method: CChroma::get_Color, IDXTChroma


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CChroma::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                       CDXDVec & InVec)
{
    HRESULT                 hr                  = S_OK;
    DXSAMPLE                sample              = 0x00000000;
    CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

    if (ulInputIndex != 0)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (!InputSurface(0))
    {
        hr = E_UNEXPECTED;

        goto done;
    }

    if (   (OutPoint[DXB_X].Min < 0)
        || (OutPoint[DXB_X].Max > m_sizeInput.cx)
        || (OutPoint[DXB_Y].Min < 0)
        || (OutPoint[DXB_Y].Max > m_sizeInput.cy))
    {
        hr = S_FALSE;

        goto done;
    }

    hr = InputSurface(0)->LockSurface(&OutPoint, m_ulLockTimeOut, DXLOCKF_READ,
                                      __uuidof(IDXARGBReadPtr), 
                                      (void **)&spDXARGBReadPtr, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    spDXARGBReadPtr->MoveToRow(0);

    spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

    if (   !sample.Alpha 
        || (sample == (DXSAMPLE)m_clrChromaColor))
    {
        hr = S_FALSE;
    }

done:

    return hr;
}
//  Method: CChroma::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CChroma::OnSetup(DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    CDXDBnds    bnds;

    hr = InputSurface(0)->GetBounds(&bnds);

    if (SUCCEEDED(hr))
    {
        bnds.GetXYSize(m_sizeInput);
    }

    return hr;
}
//  Method: CChroma::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CChroma::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CChroma::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinueProcessing)
{
    HRESULT hr = S_OK;

    const ULONG DoWidth     = WI.DoBnds.Width();
    const ULONG DoHeight    = WI.DoBnds.Height();
    BOOL        bDoOver     = m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT;

    CComPtr<IDXARGBReadWritePtr> pDest;
    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, (void**)&pDest, NULL);

    if (FAILED(hr)) 
        return hr;

    CComPtr<IDXARGBReadPtr> pSrc;
    hr = InputSurface()->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);
    
    if (FAILED(hr)) 
        return hr;

    DXPMSAMPLE*         pBuffer     = NULL;
    BOOL                bDirectCopy = FALSE;
    DXNATIVETYPEINFO    NTI;

    if (OutputSampleFormat() == DXPF_PMARGB32 && (!DoOver()))
    {
        bDirectCopy = TRUE;
    }

    if (bDirectCopy)
    {
        pDest->GetNativeType(&NTI);

        if (NTI.pFirstByte)
        {
            pBuffer = (DXPMSAMPLE *)NTI.pFirstByte;
        }
        else
        {
            bDirectCopy = FALSE;
        }
    }

    if (pBuffer == NULL)
    {
        pBuffer = DXPMSAMPLE_Alloca(DoWidth);
    }

    DXPMSAMPLE* pOverScratch = (DoOver() && OutputSampleFormat() != DXPF_PMARGB32) ?
                                DXPMSAMPLE_Alloca(DoWidth) : NULL;

    //
    //  Set up the dither structure
    //

    DXDITHERDESC dxdd;

    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = pBuffer;
        dxdd.cSamples       = DoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    DXPACKEDRECTDESC prd;

    prd.bPremult    = TRUE;
    prd.lRowPadding = 0;
    prd.rect.top    = 0; 
    prd.rect.bottom = 1;
    prd.rect.left   = 0; 
    prd.rect.right  = DoWidth;

    for (ULONG y = 0; y < DoHeight; y++)
    {
        prd.pSamples = pBuffer;
        pSrc->UnpackRect(&prd);
        prd.rect.top    += 1;
        prd.rect.bottom += 1;

        DWORD v;
        DWORD dwChroma = m_clrChromaColor & 0x00ffffff;

        for (ULONG x = 0; x < DoWidth; x++)
        {
            v = DXUnPreMultSample(pBuffer[x]);
            v &= 0x00ffffff;

            if (v == dwChroma)
            {
                pBuffer[x] = 0;
            }
        }

        if (bDirectCopy)
        {
            pBuffer = (DXPMSAMPLE*)(((BYTE*)pBuffer) + NTI.lPitch);
        }
        else
        {
            if (DoDither())
            {
                DXDitherArray(&dxdd);
                dxdd.y++;
            }

            pDest->MoveToRow(y);

            if (bDoOver)
            {
                //
                //  NOTE:  If any other effect can change alpha, do test here.
                //  The BltFlags which will be 0 if the
                //  source is opqaue.
                //

                if (m_dwBltFlags & DXBOF_DO_OVER)
                {
                    pDest->OverArrayAndMove(pOverScratch, pBuffer, DoWidth);
                }
                else
                {
                    pDest->PackPremultAndMove(pBuffer, DoWidth);
                }
            }
            else
            {
                pDest->PackPremultAndMove(pBuffer, DoWidth);
            }
        }
    }

    return hr;
}
//  Method: CChroma::WorkProc, CDXBaseNTo1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\chroma.h ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:        chroma.h
//
// Created:         1998/10/01
//
// Author:          MikeAr
//
// Discription:     Definition of the Chroma transform.
//
// 1998/10/01   MikeAr      Created.
// 1998/11/09   mcalkins    Moved to dxtmsft.dll.
// 2000/06/19   mcalkins    Keep a bstr version of the chroma color.
//
//------------------------------------------------------------------------------

#ifndef __CHROMA_H_
#define __CHROMA_H_

#include "resource.h" 




class ATL_NO_VTABLE CChroma : 
    public CDXBaseNTo1,
    public CComCoClass<CChroma, &CLSID_DXTChroma>,
    public IDispatchImpl<IDXTChroma, &IID_IDXTChroma, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CChroma>,
    public IPersistStorageImpl<CChroma>,
    public IObjectSafetyImpl2<CChroma>,
    public ISpecifyPropertyPagesImpl<CChroma>,
    public IPersistPropertyBagImpl<CChroma>
{
private:

    CComPtr<IUnknown>   m_spUnkMarshaler;

    DWORD               m_clrChromaColor;
    VARIANT             m_varChromaColor;
    SIZE                m_sizeInput;

public:

    CChroma();
    virtual ~CChroma();

    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_CHROMA)
    DECLARE_POLY_AGGREGATABLE(CChroma)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CChroma)
        COM_INTERFACE_ENTRY(IDXTChroma)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CChroma>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CChroma)
        PROP_ENTRY("Color", 1, CLSID_DXTChromaPP)
        PROP_PAGE(CLSID_DXTChromaPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);

    // IDXTChroma properties.

    STDMETHOD(get_Color)(VARIANT * pVal);
    STDMETHOD(put_Color)(VARIANT newVal);
};

#endif //__CHROMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\coloradj.cpp ===
/*******************************************************************************
* ColorAdj.cpp *
*--------------*
*   Description:
*    This module is the main implementation file for the CDXLUTBuilder class.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*  @doc EXTERNAL
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "ColorAdj.h"
#include <math.h>
#include <dxhelper.h>

//--- Local

/*****************************************************************************
* CDXLUTBuilder::CDXLUTBuilder *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
CDXLUTBuilder::CDXLUTBuilder()
{
    int i;
    m_dwGenerationId     = 1;
    m_dwBuiltGenId       = 0;
    m_Gamma              = 1.0;
    m_Opacity            = 1.0;
    m_InversionThreshold = 1.0;
    m_Threshold          = 0;
    m_LevelsPerChannel   = 255;
    m_dwNumBuildSteps    = 0;
    m_pBrightnessCurve   = NULL;
    m_pContrastCurve     = NULL;
    m_BrightnessCurveCnt = 0;
    m_ContrastCurveCnt   = 0;

    for( i = 0; i < 3; ++i )
    {
        m_TintCurves[i]    = NULL;
        m_TintCurveCnts[i] = 0;
    }

    for( i = 0; i < 256; ++i )
    {
        m_RedTable[i]   = (BYTE)i;
        m_GreenTable[i] = (BYTE)i;
        m_BlueTable[i]  = (BYTE)i;
        m_AlphaTable[i] = (BYTE)i;
    }
} /* CDXLUTBuilder::CDXLUTBuilder */

/*****************************************************************************
* CDXLUTBuilder::~CDXLUTBuilder *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
CDXLUTBuilder::~CDXLUTBuilder()
{
    int i;
    delete[] m_pBrightnessCurve;
    delete[] m_pContrastCurve;

    for( i = 0; i < 3; ++i )
    {
        delete[] m_TintCurves[i];
    }

} /* CDXLUTBuilder::~CDXLUTBuilder */

/*****************************************************************************
* CDXLUTBuilder::_RecalcTables *
*------------------------------*
*   Description:
*       This method is used to recalculate the lookup table based on the
*   current property settings. Intermediate results are calculated in floating
*   point to maintain precision.
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
void CDXLUTBuilder::_RecalcTables( void )
{
    ULONG i, j;
    float fVal, Red, Green, Blue, Alpha;
    float GammaValue = 1.0F / m_Gamma;
    static float Mid = .5;

    //--- Increment the table generation ID
    ++m_dwGenerationId;

    m_SampIdent = (DXBASESAMPLE)0x01010101; // Set to all TRUE initialally

    //--- Recalc the tables
    for( i = 0; i < 256; ++i )
    {
        //--- Initialize with normalized values
        Red = Green = Blue = Alpha = ((float)i) / 255.0F;

        //--- Perform ops in order
        for( j = 0; j < m_dwNumBuildSteps; ++j )
        {
            switch( m_OpOrder[j] )
            {
              case OPID_DXLUTBUILDER_Gamma:
                Red   = (float)pow( Red  , GammaValue );
                Green = (float)pow( Green, GammaValue );
                Blue  = (float)pow( Blue , GammaValue );
                break;

              case OPID_DXLUTBUILDER_Opacity:
                Alpha *= m_Opacity;
                break;

              case OPID_DXLUTBUILDER_Brightness:
                fVal = _GetWeightedValue( i, m_pBrightnessCurve, m_BrightnessCurveCnt );
                Red   *= fVal;
                Green *= fVal;
                Blue  *= fVal;
                break;

              case OPID_DXLUTBUILDER_Contrast:
                fVal = _GetWeightedValue( i, m_pContrastCurve, m_ContrastCurveCnt );
                Red   = ((Red   - Mid) * fVal) + Mid;
                Green = ((Green - Mid) * fVal) + Mid;
                Blue  = ((Blue  - Mid) * fVal) + Mid;
                break;

              case OPID_DXLUTBUILDER_ColorBalance:
                Red   *= _GetWeightedValue( i, m_TintCurves[DXLUTCOLOR_RED]  , m_TintCurveCnts[DXLUTCOLOR_RED] );
                Green *= _GetWeightedValue( i, m_TintCurves[DXLUTCOLOR_GREEN], m_TintCurveCnts[DXLUTCOLOR_GREEN] );
                Blue  *= _GetWeightedValue( i, m_TintCurves[DXLUTCOLOR_BLUE] , m_TintCurveCnts[DXLUTCOLOR_BLUE] );
                break;

              case OPID_DXLUTBUILDER_Posterize:
              {
                Red   = _BucketVal( m_LevelsPerChannel, Red   );
                Green = _BucketVal( m_LevelsPerChannel, Green );
                Blue  = _BucketVal( m_LevelsPerChannel, Blue  );
                break;
              }

              case OPID_DXLUTBUILDER_Invert:
                if( m_InversionThreshold < 1.0 )
                {
                    if( Red   > m_InversionThreshold ) Red   = 1.0F - Red;
                    if( Green > m_InversionThreshold ) Green = 1.0F - Green;
                    if( Blue  > m_InversionThreshold ) Blue  = 1.0F - Blue;
                }
                break;

              case OPID_DXLUTBUILDER_Threshold:
                Red   = ( Red   < m_Threshold )?(0.0F):(1.0F);
                Green = ( Green < m_Threshold )?(0.0F):(1.0F);
                Blue  = ( Blue  < m_Threshold )?(0.0F):(1.0F);
                break;
            }
        }

        //--- Assign
        if( Red != 0. || Green != 0. || Blue != 0. )
        {
            Red = Red;
        }

        //--- Clamp
        if( Red > 1.0 )
        {
            Red   = 1.0;
        }
        else if( Red < 0.0 )
        {
            Red   = 0.0;
        }

        if( Green > 1.0 )
        {
            Green = 1.0;
        }
        else if( Green < 0.0 )
        {
            Green = 0.0;
        }

        if( Blue > 1.0 )
        {
            Blue  = 1.0;
        }
        else if( Blue  < 0.0 )
        {
            Blue  = 0.0;
        }

        if( Alpha > 1.0 )
        {
            Alpha = 1.0;
        }
        else if( Alpha < 0.0 )
        {
            Alpha = 0.0;
        }

        m_RedTable[i]   = (BYTE)(Red   * 255.0F);
        m_GreenTable[i] = (BYTE)(Green * 255.0F);
        m_BlueTable[i]  = (BYTE)(Blue  * 255.0F);
        m_AlphaTable[i] = (BYTE)(Alpha * 255.0F);

        //
        //--- Assign boolean for channel identity mapping
        //
        m_SampIdent.Alpha &= (m_AlphaTable[i] == i);
        m_SampIdent.Red &= (m_RedTable[i] == i);
        m_SampIdent.Green &= (m_GreenTable[i] == i);
        m_SampIdent.Blue &= (m_BlueTable[i] == i);
    }

    m_dwBuiltGenId = m_dwGenerationId;

} /* CDXLUTBuilder::_RecalcTables */

/*****************************************************************************
* CDXLUTBuilder::_GetWeightedValue *
*----------------------------------*
*   Description:
*       This method is used to return a weighted value derived from the
*   specified weight array. We just bucket the indices for now.
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/22/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
float CDXLUTBuilder::
    _GetWeightedValue( ULONG dwIndex, float Weights[], ULONG dwNumWeights )
{
    float fVal;

    if( dwNumWeights == 0 )
    {
        fVal = 1.0F;
    }
    else if( dwNumWeights == 1 )
    {
        fVal = Weights[0];
    }
    else
    {
        ULONG dwRangeSize = 255 / (dwNumWeights-1);
        ULONG dwRange = dwIndex / dwRangeSize;
        if( dwRange >= dwNumWeights ) dwRange = dwNumWeights - 1;
        fVal = Weights[dwRange];
    }

    //--- Scale positive weights 100% over = 3.55
    // Hmmm.. Is this what we want? 
    if( fVal > 1.0F )
    {
        fVal = ((fVal - 1.0F) * 2.55F) + 1.0F;
    }

    return fVal;
} /* CDXLUTBuilder::_GetWeightedValue */

/*****************************************************************************
* CDXLUTBuilder::GetTables *
*--------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetTables( BYTE RedLUT[256], BYTE GreenLUT[256],
                                       BYTE BlueLUT[256], BYTE AlphaLUT[256] )
{
    HRESULT hr = S_OK;

    if( ::DXIsBadWritePtr( RedLUT, sizeof(RedLUT) ) || 
        ::DXIsBadWritePtr( GreenLUT, sizeof(GreenLUT) ) ||
        ::DXIsBadWritePtr( BlueLUT, sizeof(BlueLUT) ) ||
        ::DXIsBadWritePtr( AlphaLUT, sizeof(AlphaLUT) ) )
    {
        return E_INVALIDARG;
    }

    if( m_dwBuiltGenId != m_dwGenerationId )
    {
        _RecalcTables();
    }

    if( RedLUT   ) memcpy( RedLUT  , m_RedTable  , sizeof( m_RedTable   ) );
    if( GreenLUT ) memcpy( GreenLUT, m_GreenTable, sizeof( m_GreenTable ) );
    if( BlueLUT  ) memcpy( BlueLUT , m_BlueTable , sizeof( m_BlueTable  ) );
    if( AlphaLUT ) memcpy( AlphaLUT, m_AlphaTable, sizeof( m_AlphaTable ) );

    return hr;
} /* CDXLUTBuilder::GetTables */

/*****************************************************************************
* CDXLUTBuilder::IsChannelIdentity *
*----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::IsChannelIdentity( DXBASESAMPLE* pSampleBools )
{
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr( pSampleBools, sizeof( DXBASESAMPLE ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if( m_dwBuiltGenId != m_dwGenerationId )
        {
            _RecalcTables();
        }
        *pSampleBools = m_SampIdent;
    }
    return hr;
} /* CDXLUTBuilder::IsChannelIdentity */

/*****************************************************************************
* CDXLUTBuilder::GetIndexValues *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetIndexValues( ULONG Index, DXBASESAMPLE* pSample )
{
    HRESULT hr = S_OK;
    if( Index > 255 ) 
    {
        hr = E_INVALIDARG;
    } 
    else
    {
        if( DXIsBadWritePtr( pSample, sizeof( DXBASESAMPLE ) ) )
        {
            hr = E_POINTER;
        }
        else
        {
            if( m_dwBuiltGenId != m_dwGenerationId )
            {
                _RecalcTables();
            }
            pSample->Alpha = m_AlphaTable[Index];
            pSample->Red   = m_RedTable[Index];
            pSample->Green = m_GreenTable[Index];
            pSample->Blue  = m_BlueTable[Index];
        }
    }

    return hr;
} /* CDXLUTBuilder::GetIndexValues */

/*****************************************************************************
* CDXLUTBuilder::ApplyTables *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::ApplyTables( DXSAMPLE *pSamples, ULONG cSamples )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pSamples, cSamples * sizeof( ULONG ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_dwBuiltGenId != m_dwGenerationId )
        {
            _RecalcTables();
        }
        DXApplyColorChannelLookupArray( (DXBASESAMPLE *)pSamples, cSamples,
                                         m_AlphaTable, m_RedTable,
                                         m_GreenTable, m_BlueTable );
    }

    return hr;
} /* CDXLUTBuilder::ApplyTables */

/*****************************************************************************
* CDXLUTBuilder::GetNumBuildSteps *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetNumBuildSteps( ULONG *pNumSteps )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pNumSteps, sizeof( ULONG ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pNumSteps = m_dwNumBuildSteps;
    }
    return hr;
} /* CDXLUTBuilder::GetNumBuildSteps */

/*****************************************************************************
* CDXLUTBuilder::GetBuildOrder *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetBuildOrder( OPIDDXLUTBUILDER OpOrder[], ULONG ulSize )
{
    HRESULT hr = S_OK;

    // Note: check for !ulSize required for ulSize of 0 (bug#27580)
    if( !ulSize || DXIsBadWritePtr( OpOrder, sizeof( OPIDDXLUTBUILDER ) * ulSize ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        memcpy( OpOrder, m_OpOrder,
                min( ulSize, m_dwNumBuildSteps ) * sizeof( OPIDDXLUTBUILDER ) );
    }
    return hr;
} /* CDXLUTBuilder::GetBuildOrder */

/*****************************************************************************
* CDXLUTBuilder::SetBuildOrder *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetBuildOrder(const OPIDDXLUTBUILDER OpOrder[], ULONG ulNumSteps )
{
    HRESULT hr = S_OK;

    if( !ulNumSteps || ::DXIsBadReadPtr( OpOrder, sizeof( OpOrder[0] ) * ulNumSteps ) ) 
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_dwGenerationId++;
        m_dwNumBuildSteps = ulNumSteps;
        memcpy( m_OpOrder, OpOrder, ulNumSteps * sizeof( OpOrder[0] ) );
    }

    return hr;
} /* CDXLUTBuilder::SetBuildOrder */

/*****************************************************************************
* CDXLUTBuilder::GetOpacity *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetOpacity( float * pVal )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVal, sizeof( float ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_Opacity;
    }

    return hr;
} /* CDXLUTBuilder::GetOpacity */

/*****************************************************************************
* CDXLUTBuilder::SetOpacity *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetOpacity(float newVal)
{
    HRESULT hr = S_OK;
    m_dwGenerationId++;

    if( ( newVal < 0.0 ) || ( newVal > 1.0 ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_Opacity = newVal;
    }

    return hr;
} /* CDXLUTBuilder::SetOpacity */

/*****************************************************************************
* CDXLUTBuilder::GetBrightness *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetBrightness( ULONG *pulCount, float Weights[] )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pulCount, sizeof( ULONG ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if( Weights == NULL )
        {
            *pulCount = m_BrightnessCurveCnt;
        }
        else if( !DXIsBadWritePtr( Weights, m_BrightnessCurveCnt * sizeof( float ) ) )
        {
            memcpy( Weights, m_pBrightnessCurve, m_BrightnessCurveCnt * sizeof( float ) );
            *pulCount = m_BrightnessCurveCnt;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
} /* CDXLUTBuilder::GetBrightness */

/*****************************************************************************
* CDXLUTBuilder::SetBrightness *
*------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetBrightness( ULONG ulCount, const float Weights[] )
{
    HRESULT hr = S_OK;
    m_dwGenerationId++;

    if( !ulCount || ulCount > 256 || DXIsBadReadPtr( Weights, sizeof( float ) * ulCount ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_BrightnessCurveCnt < ulCount )
        {
            delete[] m_pBrightnessCurve;
            m_BrightnessCurveCnt = ulCount;
            m_pBrightnessCurve = new float[ulCount];
            if( !m_pBrightnessCurve )
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if( SUCCEEDED( hr ) )
        {
            memcpy( m_pBrightnessCurve, Weights,
                    m_BrightnessCurveCnt * sizeof( float ) );
        }
    }

    return hr;
} /* CDXLUTBuilder::SetBrightness */

/*****************************************************************************
* CDXLUTBuilder::GetContrast *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetContrast( ULONG *pulCount, float Weights[] )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pulCount, sizeof( ULONG ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if( Weights == NULL )
        {
            *pulCount = m_ContrastCurveCnt;
        }
        else if( !DXIsBadWritePtr( Weights, m_ContrastCurveCnt * sizeof( float ) ) )
        {
            memcpy( Weights, m_pContrastCurve, m_ContrastCurveCnt * sizeof( float ) );
            *pulCount = m_ContrastCurveCnt;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
} /* CDXLUTBuilder::GetContrast */

/*****************************************************************************
* CDXLUTBuilder::SetContrast *
*----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetContrast(ULONG ulCount, const float Weights[])
{
    HRESULT hr = S_OK;
    m_dwGenerationId++;

    if( !ulCount || ulCount > 256 || DXIsBadReadPtr( Weights, sizeof( float ) * ulCount ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_ContrastCurveCnt < ulCount )
        {
            delete[] m_pContrastCurve;
            m_ContrastCurveCnt = ulCount;
            m_pContrastCurve = new float[ulCount];
            if( !m_pContrastCurve )
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if( SUCCEEDED( hr ) )
        {
            memcpy( m_pContrastCurve, Weights,
                    m_ContrastCurveCnt * sizeof( float ) );
        }
    }

    return hr;
} /* CDXLUTBuilder::SetContrast */

/*****************************************************************************
* CDXLUTBuilder::GetGamma *
*-------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetGamma( float * pVal )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVal, sizeof( float ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_Gamma;
    }

    return hr;
} /* CDXLUTBuilder::GetGamma */

/*****************************************************************************
* CDXLUTBuilder::SetGamma *
*-------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetGamma(float newVal)
{
    HRESULT hr = S_OK;

    if( newVal <= 0.0 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_Gamma = newVal;
        m_dwGenerationId++;
    }

    return hr;
} /* CDXLUTBuilder::SetGamma */

/*****************************************************************************
* CDXLUTBuilder::GetColorBalance *
*--------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetColorBalance( DXLUTCOLOR Color, ULONG *pulCount, float Weights[] )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pulCount, sizeof( ULONG ) ) )
    {
        hr = E_INVALIDARG;
    }
    else if( Weights == NULL )
    {
        *pulCount = m_TintCurveCnts[Color];
    }
    else if( m_TintCurveCnts[Color] > *pulCount )
    {
        *pulCount = m_TintCurveCnts[Color];
        hr = S_FALSE;
    }
    else if( !DXIsBadWritePtr( Weights, m_TintCurveCnts[Color] * sizeof( float ) ) )
    {
        memcpy( Weights, m_TintCurves[Color], m_TintCurveCnts[Color] * sizeof( float ) );
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
} /* CDXLUTBuilder::GetColorBalance */

/*****************************************************************************
* CDXLUTBuilder::SetColorBalance *
*--------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetColorBalance( DXLUTCOLOR Color, ULONG ulCount, const float Weights[] )
{
    HRESULT hr = S_OK;
    m_dwGenerationId++;

    if( ulCount == 0 || ulCount > 256 || DXIsBadReadPtr( Weights, sizeof( Weights[0] ) * ulCount ) )
    {
        hr = E_INVALIDARG;
    }
    else if( m_TintCurveCnts[Color] < ulCount )
    {
        delete[] m_TintCurves[Color];
        m_TintCurveCnts[Color] = ulCount;
        m_TintCurves[Color] = new float[ulCount];

        if( !m_TintCurves[Color] )
        {
            m_TintCurveCnts[Color] = 0;
            hr = E_OUTOFMEMORY;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        memcpy( m_TintCurves[Color], Weights, ulCount * sizeof( float ) );
    }

    return hr;
} /* CDXLUTBuilder::SetColorBalance */

/*****************************************************************************
* CDXLUTBuilder::GetLevelsPerChannel *
*------------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetLevelsPerChannel( ULONG *pVal )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVal, sizeof( ULONG ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_LevelsPerChannel;
    }

    return hr;
} /* CDXLUTBuilder::GetLevelsPerChannel */

/*****************************************************************************
* CDXLUTBuilder::SetLevelsPerChannel *
*------------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetLevelsPerChannel( ULONG newVal )
{
    HRESULT hr = S_OK;
    m_dwGenerationId++;

    if( ( newVal < 2 ) || ( newVal > 255 ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_LevelsPerChannel = (BYTE)newVal;
    }

    return hr;
} /* CDXLUTBuilder::SetLevelsPerChannel */

/*****************************************************************************
* CDXLUTBuilder::GetInvert *
*--------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetInvert( float *pVal )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVal, sizeof( float ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_InversionThreshold;
    }

    return hr;
} /* CDXLUTBuilder::GetInvert */

/*****************************************************************************
* CDXLUTBuilder::SetInvert *
*--------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetInvert( float newVal )
{
    HRESULT hr = S_OK;

    if( newVal > 1.0 )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_dwGenerationId++;
        m_InversionThreshold = newVal;
    }
    return hr;
} /* CDXLUTBuilder::SetInvert */

/*****************************************************************************
* CDXLUTBuilder::GetThreshold *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::GetThreshold( float *pVal )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVal, sizeof( float ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_Threshold;
    }

    return hr;
} /* CDXLUTBuilder::GetThreshold */

/*****************************************************************************
* CDXLUTBuilder::SetThreshold *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::SetThreshold( float newVal )
{
    HRESULT hr = S_OK;
    m_dwGenerationId++;

    if( newVal < 0.0F )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_Threshold = newVal;
    }

    return hr;
} /* CDXLUTBuilder::SetThreshold */

//
//=== Dispatch translation functions ==========================================
//
/*****************************************************************************
* CDXLUTBuilder::get_BuildOrder *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::get_BuildOrder( VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_dwNumBuildSteps == 1 )
        {
            pVar->vt = VT_I4;
            hr = GetBuildOrder( (OPIDDXLUTBUILDER*)&pVar->lVal, 1 );
        }
        else
        {
            pVar->vt = VT_ARRAY | VT_I4;
            SAFEARRAYBOUND rgsabound;
            rgsabound.lLbound   = 1;
            rgsabound.cElements = m_dwNumBuildSteps;
            pVar->parray = SafeArrayCreate( VT_I4, 1, &rgsabound );

            if( pVar->parray == NULL )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                void *pData;
                hr = SafeArrayAccessData( pVar->parray, &pData );

                if( SUCCEEDED( hr ) )
                {
                    hr = GetBuildOrder( (OPIDDXLUTBUILDER*)pData, m_dwNumBuildSteps );
                    hr = SafeArrayUnaccessData( pVar->parray );
                }
            }
        }
    }

    return hr;
} /* CDXLUTBuilder::get_BuildOrder */

/*****************************************************************************
* CDXLUTBuilder::put_BuildOrder *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::put_BuildOrder( VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadReadPtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( pVar->vt == ( VT_ARRAY | VT_I4 ) )
        {
            SAFEARRAY *pSA = pVar->parray;
            void *pData;

            if( ( pSA->cDims != 1 ) ||
                ( pSA->cbElements != sizeof(OPIDDXLUTBUILDER) ) ||
                ( pSA->rgsabound->lLbound != 1 ) ||
                ( pSA->rgsabound->cElements > OPID_DXLUTBUILDER_NUM_OPS ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                if( SUCCEEDED( hr = SafeArrayAccessData(pSA, &pData) ) )
                {
                    hr = SetBuildOrder( (OPIDDXLUTBUILDER*)pData, pSA->rgsabound->cElements );
                    SafeArrayUnaccessData( pSA );
                }
            }
        }
        else if( pVar->vt == VT_I4 )
        {
            hr = SetBuildOrder( (OPIDDXLUTBUILDER*)&pVar->lVal, 1 );
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
} /* CDXLUTBuilder::put_BuildOrder */

/*****************************************************************************
* CDXLUTBuilder::get_Brightness *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::get_Brightness( VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_BrightnessCurveCnt == 1 )
        {
            pVar->vt = VT_R4;
            hr = GetBrightness( &m_BrightnessCurveCnt, &pVar->fltVal );
        }
        else
        {
            pVar->vt = VT_ARRAY | VT_R4;
            SAFEARRAYBOUND rgsabound;
            rgsabound.lLbound   = 1;
            rgsabound.cElements = m_BrightnessCurveCnt;
            pVar->parray = SafeArrayCreate( VT_R4, 1, &rgsabound );
            if( pVar->parray == NULL )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                void *pData;
                hr = SafeArrayAccessData( pVar->parray, &pData );

                if( SUCCEEDED( hr ) )
                {
                    hr = GetBrightness( &m_BrightnessCurveCnt, (float*)pData );
                    hr = SafeArrayUnaccessData( pVar->parray );
                }
            }
        }
    }

    return hr;
} /* CDXLUTBuilder::get_Brightness */

/*****************************************************************************
* CDXLUTBuilder::put_Brightness *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::put_Brightness( VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadReadPtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( pVar->vt == ( VT_ARRAY | VT_R4 ) )
        {
            SAFEARRAY *pSA = pVar->parray;
            void *pData;

            if( ( pSA->cDims != 1 ) || ( pSA->cbElements != sizeof(float) ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                if( SUCCEEDED( hr = SafeArrayAccessData(pSA, &pData) ) )
                {
                    ULONG ulCount = ( pSA->rgsabound->lLbound )?
                                    ( pSA->rgsabound->cElements ):
                                    ( pSA->rgsabound->cElements-1 );
                    hr = SetBrightness( ulCount, (float*)pData );
                    SafeArrayUnaccessData( pSA );
                }
            }
        }
        else if( pVar->vt == VT_R4 )
        {
            hr = SetBrightness( 1, &pVar->fltVal );
        }
        else if( pVar->vt == VT_R8 )
        {
            float fltVal = (float)pVar->dblVal;
            hr = SetBrightness( 1, &fltVal );
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
} /* CDXLUTBuilder::put_Brightness */

/*****************************************************************************
* CDXLUTBuilder::get_Contrast *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::get_Contrast( VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_ContrastCurveCnt == 1 )
        {
            pVar->vt = VT_R4;
            hr = GetContrast( &m_ContrastCurveCnt, &pVar->fltVal );
        }
        else
        {
            pVar->vt = VT_ARRAY | VT_R4;
            SAFEARRAYBOUND rgsabound;
            rgsabound.lLbound   = 1;
            rgsabound.cElements = m_ContrastCurveCnt;
            pVar->parray = SafeArrayCreate( VT_R4, 1, &rgsabound );

            if( pVar->parray == NULL )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                void *pData;
                hr = SafeArrayAccessData( pVar->parray, &pData );

                if( SUCCEEDED( hr ) )
                {
                    hr = GetContrast( &m_ContrastCurveCnt, (float*)pData );
                    hr = SafeArrayUnaccessData( pVar->parray );
                }
            }
        }
    }

    return hr;
} /* CDXLUTBuilder::get_Contrast */

/*****************************************************************************
* CDXLUTBuilder::put_Contrast *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::put_Contrast( VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadReadPtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( pVar->vt == ( VT_ARRAY | VT_R4 ) )
        {
            SAFEARRAY *pSA = pVar->parray;
            void *pData;

            if( ( pSA->cDims != 1 ) ||
                ( pSA->cbElements != sizeof(float) ) ||
                ( pSA->rgsabound->lLbound != 1 ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                if( SUCCEEDED( hr = SafeArrayAccessData(pSA, &pData) ) )
                {
                    hr = SetContrast( pSA->rgsabound->cElements, (float*)pData );
                    SafeArrayUnaccessData( pSA );
                }
            }
        }
        else if( pVar->vt == VT_R4 )
        {
            hr = SetContrast( 1, &pVar->fltVal );
        }
        else if( pVar->vt == VT_R8 )
        {
            float fltVal = (float)pVar->dblVal;
            hr = SetContrast( 1, &fltVal );
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
} /* CDXLUTBuilder::put_Contrast */

/*****************************************************************************
* CDXLUTBuilder::get_ColorBalance *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::get_ColorBalance( DXLUTCOLOR Color, VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( m_TintCurveCnts[Color] == 1 )
        {
            pVar->vt = VT_R4;
            hr = GetColorBalance( Color, &m_TintCurveCnts[Color], &pVar->fltVal );
        }
        else
        {
            pVar->vt = VT_ARRAY | VT_R4;
            SAFEARRAYBOUND rgsabound;
            rgsabound.lLbound   = 1;
            rgsabound.cElements = m_TintCurveCnts[Color];
            pVar->parray = SafeArrayCreate( VT_R4, 1, &rgsabound );

            if( pVar->parray == NULL )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                void *pData;
                hr = SafeArrayAccessData( pVar->parray, &pData );

                if( SUCCEEDED( hr ) )
                {
                    hr = GetColorBalance( Color, &m_TintCurveCnts[Color], (float*)pData );
                    hr = SafeArrayUnaccessData( pVar->parray );
                }
            }
        }
    }

    return hr;
} /* CDXLUTBuilder::get_ColorBalance */

/*****************************************************************************
* CDXLUTBuilder::put_ColorBalance *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 09/30/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CDXLUTBuilder::put_ColorBalance( DXLUTCOLOR Color, VARIANT *pVar )
{
    HRESULT hr = S_OK;

    if( DXIsBadReadPtr( pVar, sizeof( VARIANT ) ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if( pVar->vt == ( VT_ARRAY | VT_R4 ) )
        {
            SAFEARRAY *pSA = pVar->parray;
            void *pData;

            if( ( pSA->cDims != 1 ) ||
                ( pSA->cbElements != sizeof(float) ) ||
                ( pSA->rgsabound->lLbound != 1 ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                if( SUCCEEDED( hr = SafeArrayAccessData(pSA, &pData) ) )
                {
                    hr = SetColorBalance( Color, pSA->rgsabound->cElements, (float*)pData );
                    SafeArrayUnaccessData( pSA );
                }
            }
        }
        else if( pVar->vt == VT_R4 )
        {
            hr = SetColorBalance( Color, 1, &pVar->fltVal );
        }
        else if( pVar->vt == VT_R8 )
        {
            float fltVal = (float)pVar->dblVal;
            hr = SetColorBalance( Color, 1, &fltVal );
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
} /* CDXLUTBuilder::put_ColorBalance */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\coloradj.h ===
/*******************************************************************************
* ColorAdj.h *
*------------*
*   Description:
*       This is the header file for the CDXLUTBuilder implementation.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/12/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef ColorAdj_h
#define ColorAdj_h

#include "resource.h"

//--- Additional includes
#ifndef __DXTrans_h__
#include <DXTrans.h>
#endif
#include <DXHelper.h>

//=== Constants ================================================================

//=== Class declarations =======================================================

/*** CDXLUTBuilder
*
*/
class ATL_NO_VTABLE CDXLUTBuilder : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CDXLUTBuilder, &CLSID_DXLUTBuilder>,
    public IDispatchImpl<IDXDLUTBuilder, &IID_IDXDLUTBuilder, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IDXLookupTable,
    public CComPropertySupport<CDXLUTBuilder>,
    public IObjectSafetyImpl2<CDXLUTBuilder>,
    public IPersistStorageImpl<CDXLUTBuilder>,
    public ISpecifyPropertyPagesImpl<CDXLUTBuilder>,
    public IPersistPropertyBagImpl<CDXLUTBuilder>,
    public IDXLUTBuilder
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_POLY_AGGREGATABLE(CDXLUTBuilder)
    DECLARE_REGISTRY_RESOURCEID(IDR_DXLUTBUILDER)

    BEGIN_COM_MAP(CDXLUTBuilder)
        COM_INTERFACE_ENTRY(IDXLUTBuilder)
        COM_INTERFACE_ENTRY(IDXDLUTBuilder)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXLookupTable)
        COM_INTERFACE_ENTRY(IDXBaseObject)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXLUTBuilder>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXLUTBuilder)
        PROP_ENTRY("BuildOrder"        ,  2, CLSID_LUTBuilderPP)
        PROP_ENTRY("Gamma"             ,  3, CLSID_LUTBuilderPP)
        PROP_ENTRY("Opacity"           ,  4, CLSID_LUTBuilderPP)
        PROP_ENTRY("Brightness"        ,  5, CLSID_LUTBuilderPP)
        PROP_ENTRY("Contrast"          ,  6, CLSID_LUTBuilderPP)
        PROP_ENTRY("ColorBalance"      ,  7, CLSID_LUTBuilderPP)
        PROP_ENTRY("Levels Per Channel",  8, CLSID_LUTBuilderPP)
        PROP_ENTRY("Invert"            ,  9, CLSID_LUTBuilderPP)
        PROP_ENTRY("Threshold"         , 10, CLSID_LUTBuilderPP)
        PROP_PAGE(CLSID_LUTBuilderPP)
    END_PROPERTY_MAP()

  /*=== Member Data ===*/
  protected:
    float  m_Gamma;
    float  m_Opacity;
    float* m_pBrightnessCurve;
    DWORD  m_BrightnessCurveCnt;
    float* m_pContrastCurve;
    DWORD  m_ContrastCurveCnt;
    float* m_TintCurves[3];
    DWORD  m_TintCurveCnts[3];
    float  m_Threshold;
    float  m_InversionThreshold;
    BYTE   m_LevelsPerChannel;
    BYTE   m_RedTable[256];
    BYTE   m_GreenTable[256];
    BYTE   m_BlueTable[256];
    BYTE   m_AlphaTable[256];
    DWORD  m_dwNumBuildSteps;
    DWORD  m_dwBuiltGenId;
    DWORD  m_dwGenerationId;
    DXBASESAMPLE m_SampIdent;
    OPIDDXLUTBUILDER m_OpOrder[OPID_DXLUTBUILDER_NUM_OPS];

  /*=== Methods =======*/
  public:
    /*--- Constructors/Setup ---*/
    CDXLUTBuilder();
    ~CDXLUTBuilder();

    /*--- Non-interface methods ---*/
    void _RecalcTables( void );
    float _GetWeightedValue( DWORD dwIndex, float Weights[], DWORD dwNumWeights );
    float _BucketVal( DWORD NumLevels, float fVal );

  public:
    STDMETHOD( GetGenerationId )( DWORD* pID );
    STDMETHOD( IncrementGenerationId ) (BOOL bRefresh);
    STDMETHOD( GetObjectSize) (ULONG *pcbSize);

    //=== IDXLookupTable interface ===========================
    STDMETHOD( GetTables )( BYTE RedLUT[256], BYTE GreenLUT[256],
                            BYTE BlueLUT[256], BYTE AlphaLUT[256] );
    STDMETHODIMP IsChannelIdentity(DXBASESAMPLE * pSampleBools);
    STDMETHODIMP GetIndexValues(ULONG Index, DXBASESAMPLE *pSampleBools);
    STDMETHODIMP ApplyTables(DXSAMPLE *pSamples, ULONG cSamples);

    //=== IDXLUTBuilder interface ===========================
    STDMETHOD(GetNumBuildSteps)( ULONG *pNumSteps );
    STDMETHOD(GetBuildOrder)( OPIDDXLUTBUILDER OpOrder[], ULONG ulSize );
    STDMETHOD(SetBuildOrder)( const OPIDDXLUTBUILDER OpOrder[], ULONG ulNumSteps );
    STDMETHOD(SetGamma)( float newVal);
    STDMETHOD(GetGamma)( float *pVal);
    STDMETHOD(GetOpacity)( float *pVal);
    STDMETHOD(SetOpacity)( float newVal);
    STDMETHOD(GetBrightness)( ULONG *pulCount, float Weights[] );
    STDMETHOD(SetBrightness)( ULONG ulCount, const float Weights[] );
    STDMETHOD(GetContrast)( ULONG *pulCount, float Weights[] );
    STDMETHOD(SetContrast)( ULONG ulCount, const float Weights[]);
    STDMETHOD(GetColorBalance)( DXLUTCOLOR Color, ULONG *pulCount, float Weights[] );
    STDMETHOD(SetColorBalance)( DXLUTCOLOR Color, ULONG ulCount, const float Weights[] );
    STDMETHOD(GetLevelsPerChannel)( ULONG *pVal);
    STDMETHOD(SetLevelsPerChannel)( ULONG newVal);
    STDMETHOD(GetInvert)( float *pThreshold );
    STDMETHOD(SetInvert)( float Threshold );
    STDMETHOD(GetThreshold)( float *pVal);
    STDMETHOD(SetThreshold)( float newVal);

    //=== IDXDLUTBuilder interface ===========================
    STDMETHOD(get_NumBuildSteps)( long *pNumSteps );
    STDMETHOD(get_BuildOrder)( VARIANT *pOpOrder );
    STDMETHOD(put_BuildOrder)( VARIANT *pOpOrder );
    STDMETHOD(put_Gamma)( float newVal);
    STDMETHOD(get_Gamma)( float *pVal);
    STDMETHOD(get_Opacity)( float *pVal);
    STDMETHOD(put_Opacity)( float newVal);
    STDMETHOD(get_Brightness)( VARIANT *pWeights );
    STDMETHOD(put_Brightness)( VARIANT *pWeights );
    STDMETHOD(get_Contrast)( VARIANT *pWeights );
    STDMETHOD(put_Contrast)( VARIANT *pWeights );
    STDMETHOD(get_ColorBalance)( DXLUTCOLOR Color, VARIANT *pWeights );
    STDMETHOD(put_ColorBalance)( DXLUTCOLOR Color, VARIANT *pWeights );
    STDMETHOD(get_LevelsPerChannel)( long *pVal);
    STDMETHOD(put_LevelsPerChannel)( long newVal);
    STDMETHOD(get_Invert)( float *pThreshold );
    STDMETHOD(put_Invert)( float Threshold );
    STDMETHOD(get_Threshold)( float *pVal);
    STDMETHOD(put_Threshold)( float newVal);
};

//=== Inline Function Definitions ==================================

inline STDMETHODIMP CDXLUTBuilder::GetGenerationId( DWORD* pID )
{
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr(pID, sizeof(*pID)) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pID = m_dwGenerationId;
    }
    return hr;
}

inline STDMETHODIMP CDXLUTBuilder::IncrementGenerationId(BOOL /*bRefresh */)
{
    InterlockedIncrement((long *)&m_dwGenerationId);
    return S_OK;
}

inline STDMETHODIMP CDXLUTBuilder::GetObjectSize(ULONG *pcbSize)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pcbSize, sizeof(*pcbSize)))
    {
        hr = E_POINTER;
    }
    else
    {
        *pcbSize = sizeof(*this);
    }
    return hr;
}

inline float CDXLUTBuilder::_BucketVal( DWORD NumLevels, float fVal )
{
    fVal *= 255.0F;
    float BucketSize = 256.0F / (NumLevels-1);
    float HalfBucket = BucketSize / 2.0F;
    float fTemp = (fVal + HalfBucket) / BucketSize;
    long  lTemp = (long)(((long)fTemp) * BucketSize);
    fVal = ((float)lTemp) / 255.0F;
    return fVal;
} /* CDXLUTBuilder::_BucketVal */

inline STDMETHODIMP CDXLUTBuilder::get_LevelsPerChannel( long *pVal) { return GetLevelsPerChannel( (DWORD*)pVal ); }
inline STDMETHODIMP CDXLUTBuilder::put_LevelsPerChannel( long newVal){ return SetLevelsPerChannel( (DWORD)newVal ); }
inline STDMETHODIMP CDXLUTBuilder::get_Invert( float *pThreshold ) { return GetInvert( pThreshold ); }
inline STDMETHODIMP CDXLUTBuilder::put_Invert( float Threshold ) { return SetInvert( Threshold ); }
inline STDMETHODIMP CDXLUTBuilder::get_Threshold( float *pVal) { return GetThreshold( pVal );}
inline STDMETHODIMP CDXLUTBuilder::put_Threshold( float newVal) { return SetThreshold( newVal ); }
inline STDMETHODIMP CDXLUTBuilder::put_Gamma( float newVal) { return SetGamma( newVal ); }
inline STDMETHODIMP CDXLUTBuilder::get_Gamma( float *pVal) { return GetGamma( pVal ); }
inline STDMETHODIMP CDXLUTBuilder::get_Opacity( float *pVal) { return GetOpacity( pVal ); }
inline STDMETHODIMP CDXLUTBuilder::put_Opacity( float newVal) { return SetOpacity( newVal ); }
inline STDMETHODIMP CDXLUTBuilder::get_NumBuildSteps( long *pNumSteps ) { return GetNumBuildSteps( (DWORD*)pNumSteps ); }

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\checkerboard.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
//  FileName:   checkerboard.cpp
//
//  Overview:   CheckerBoard transform.
//
//  Change History:
//  1999/09/16  a-matcal    Created.
//  1999/09/25  a-matcal    Fixed bug where all squares weren't getting updated
//                          in horizontal cases.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "checkerboard.h"

#define VERTICAL_MOVEMENT ((UP == m_eDirection) || (DOWN == m_eDirection))
#define REVERSE_MOVEMENT  ((UP == m_eDirection) || (LEFT == m_eDirection))

static const OLECHAR * g_astrDirection[] = {
    L"up",
    L"down",
    L"left",
    L"right"
};

#if DBG == 1
static s_ulMaxImageBands = 0;
#endif




//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::CDXTCheckerBoard
//
//------------------------------------------------------------------------------
CDXTCheckerBoard::CDXTCheckerBoard() :
    m_eDirection(RIGHT),
    m_nSquaresX(12),
    m_nSquaresY(10)
{
    m_sizeInput.cx      = 0;
    m_sizeInput.cy      = 0;

    // Base class members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;

#if DBG == 1
    if (s_ulMaxImageBands)
    {
        m_ulMaxImageBands = s_ulMaxImageBands;
    }
#endif
}
//  CDXTCheckerBoard::CDXTCheckerBoard


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTCheckerBoard::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTCheckerBoard::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTCheckerBoard::OnSetup(DWORD dwFlags)
{
    HRESULT     hr  = S_OK;
    CDXDBnds    bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsInput.GetXYSize(m_sizeInput);

done:

    return hr;
} 
//  CDXTCheckerBoard::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTCheckerBoard::OnGetSurfacePickOrder(const CDXDBnds & OutPoint,
                                        ULONG & ulInToTest, ULONG aInIndex[], 
                                        BYTE aWeight[])
{
    BRICKINFO   brickinfo;

    _CalcBrickInfo(brickinfo);

    // Assume Input A will be picked.

    aInIndex[0] = 0;

    // Calculate correct picked input.

    if (VERTICAL_MOVEMENT)
    {
        // Vertical movement.  Translate the y coordinate to brick coordinates.

        long y = OutPoint.Bottom();
        
        // If this is in one of the columns of offset bricks, compensate for
        // brick offset.

        if ((OutPoint.Right() / brickinfo.size.cx) % 2)
        {
            // Subtract the brick offset and add one brick height to guarantee
            // a positive value.

            y = y - brickinfo.nBrickOffset + brickinfo.size.cy;
        }

        // Normalize to brick coordinates.

        y = y % brickinfo.size.cy;

        if ((y >= brickinfo.rcInputB.top) && (y < brickinfo.rcInputB.bottom))
        {
            aInIndex[0] = 1; // Change to Input B.
        }
    }
    else
    {
        // Horizontal movement.  Translate the x coordinate to brick 
        // coordinates.

        long x = OutPoint.Right();

        // If the output point is in one of the rows of offset bricks,
        // compensate for brick offset.

        if ((OutPoint.Bottom() / brickinfo.size.cy) % 2)
        {
            // Subtract the brick offset and add one brick width to guarantee
            // a positive value.

            x = x - brickinfo.nBrickOffset + brickinfo.size.cx;
        }

        // Normalize to birck coordinates.

        x = x % brickinfo.size.cx;

        if ((x >= brickinfo.rcInputB.left) && (x < brickinfo.rcInputB.right))
        {
            aInIndex[0] = 1; // Change to Input B.
        }
    }

    // Set additional output parameters.  There will always be only one input to
    // test and it will therefore be weighted as 255.

    ulInToTest  = 1;
    aWeight[0]  = 255;
}
//  CDXTCheckerBoard::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTCheckerBoard::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr      = S_OK;
    DWORD   dwFlags = 0;

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    if (VERTICAL_MOVEMENT)
    {
        hr = _WorkProcForVerticalBricks(WI, pbContinue, dwFlags);
    }
    else
    {
        hr = _WorkProcForHorizontalBricks(WI, pbContinue, dwFlags);
    }

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTCheckerBoard::WorkProc, CDXBaseNTo1


STDMETHODIMP
CDXTCheckerBoard::_WorkProcForVerticalBricks(const CDXTWorkInfoNTo1 & WI, 
                                             BOOL * pbContinue,
                                             DWORD & dwFlags)
{
    HRESULT hr = S_OK;

    long    lInOutOffsetX   = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY   = WI.OutputBnds.Top() - WI.DoBnds.Top();
    long    cBricksX        = 0;
    long    cBricksY        = 0;
    long    x               = 0;
    long    y               = 0;

    CDXDBnds    bndsBrickA;
    CDXDBnds    bndsBrickB;

    BRICKINFO   brickinfo;

    _CalcBrickInfo(brickinfo);

    // How many whole bricks fit, then add one to columns and two to rows (one 
    // for each side of centered offset columns.)

    cBricksX = (m_sizeInput.cx / brickinfo.size.cx) + 1;
    cBricksY = (m_sizeInput.cy / brickinfo.size.cy) + 2;

    bndsBrickA.SetXYRect(brickinfo.rcInputA);
    bndsBrickB.SetXYRect(brickinfo.rcInputB);

    // Blit Input A portion of bricks.

    if (!bndsBrickA.BoundsAreEmpty())
    {
        for (x = 0; x < cBricksX; x++)
        {
            CDXDBnds bndsSrcA;

            // Calculate source bounds.

            bndsSrcA = bndsBrickA;
            bndsSrcA.Offset(x * brickinfo.size.cx, 0, 0, 0);

            // Use brick offset if this is an odd column.

            if (x & 1)
            {
                bndsSrcA.Offset(0, brickinfo.nBrickOffset - brickinfo.size.cy,
                                0, 0);
            }

            for (y = 0; y < cBricksY; y++)
            {
                CDXDBnds bndsIntersect;
                CDXDBnds bndsDest;

                // Intersect bounds with DoBnds bounds so they're valid.

                bndsIntersect.IntersectBounds(bndsSrcA, WI.DoBnds);

                // Move bounds down one brick for next iteration.

                bndsSrcA.Offset(0, brickinfo.size.cy, 0, 0);

                if (bndsIntersect.BoundsAreEmpty())
                {
                    continue;
                }

                bndsDest = bndsIntersect;
                bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(0), bndsIntersect,
                              dwFlags, INFINITE);

                if (FAILED(hr))
                {
                    goto done;
                }
            }

        }
    }

    // Blit Input B portion of bricks.

    if (!bndsBrickB.BoundsAreEmpty())
    {
        for (x = 0; x < cBricksX; x++)
        {
            CDXDBnds bndsSrcB;

            // Calculate source bounds.

            bndsSrcB = bndsBrickB;
            bndsSrcB.Offset(x * brickinfo.size.cx, 0, 0, 0);

            // Use brick offset if this is an odd column.

            if (x & 1)
            {
                bndsSrcB.Offset(0, brickinfo.nBrickOffset - brickinfo.size.cy,
                                0, 0);
            }

            for (y = 0; y < cBricksY; y++)
            {
                CDXDBnds bndsIntersect;
                CDXDBnds bndsDest;

                // Intersect bounds with DoBnds bounds so they're valid.

                bndsIntersect.IntersectBounds(bndsSrcB, WI.DoBnds);

                // Move bounds down one brick for next iteration.

                bndsSrcB.Offset(0, brickinfo.size.cy, 0, 0);

                if (bndsIntersect.BoundsAreEmpty())
                {
                    continue;
                }

                bndsDest = bndsIntersect;
                bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(1), bndsIntersect,
                              dwFlags, INFINITE);

                if (FAILED(hr))
                {
                    goto done;
                }
            }

        }
    }

done:

    return hr;
}


STDMETHODIMP
CDXTCheckerBoard::_WorkProcForHorizontalBricks(const CDXTWorkInfoNTo1 & WI, 
                                               BOOL * pbContinue,
                                               DWORD & dwFlags)
{
    HRESULT hr = S_OK;

    long    lInOutOffsetX   = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY   = WI.OutputBnds.Top() - WI.DoBnds.Top();
    long    cBricksX        = 0;
    long    cBricksY        = 0;
    long    x               = 0;
    long    y               = 0;

    CDXDBnds    bndsBrickA;
    CDXDBnds    bndsBrickB;

    BRICKINFO   brickinfo;

    _CalcBrickInfo(brickinfo);

    // How many whole bricks fit, then add one for rows and two for columns (one
    // for each side of centered offset rows.)

    cBricksX = (m_sizeInput.cx / brickinfo.size.cx) + 2;
    cBricksY = (m_sizeInput.cy / brickinfo.size.cy) + 1;

    bndsBrickA.SetXYRect(brickinfo.rcInputA);
    bndsBrickB.SetXYRect(brickinfo.rcInputB);

    // Blit Input A portion of bricks.

    if (!bndsBrickA.BoundsAreEmpty())
    {
        for (y = 0; y < cBricksY; y++)
        {
            CDXDBnds bndsSrcA;

            // Calculate source bounds.

            bndsSrcA = bndsBrickA;
            bndsSrcA.Offset(0, y * brickinfo.size.cy, 0, 0);

            // Use brick offset if this is an odd row.

            if (y & 1)
            {
                bndsSrcA.Offset(brickinfo.nBrickOffset - brickinfo.size.cx, 0,
                                0, 0);
            }

            for (x = 0; x < cBricksX; x++)
            {
                CDXDBnds bndsIntersect;
                CDXDBnds bndsDest;

                // Intersect bounds with DoBnds bounds so they're valid.

                bndsIntersect.IntersectBounds(bndsSrcA, WI.DoBnds);

                // Move bounds down one brick for next iteration.

                bndsSrcA.Offset(brickinfo.size.cx, 0, 0, 0);

                if (bndsIntersect.BoundsAreEmpty())
                {
                    continue;
                }

                bndsDest = bndsIntersect;
                bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(0), bndsIntersect,
                              dwFlags, INFINITE);

                if (FAILED(hr))
                {
                    goto done;
                }
            }

        }
    }

    // Blit Input B portion of bricks.

    if (!bndsBrickB.BoundsAreEmpty())
    {
        for (y = 0; y < cBricksY; y++)
        {
            CDXDBnds bndsSrcB;

            // Calculate source bounds.

            bndsSrcB = bndsBrickB;
            bndsSrcB.Offset(0, y * brickinfo.size.cy, 0, 0);

            // Use brick offset if this is an odd row.

            if (y & 1)
            {
                bndsSrcB.Offset(brickinfo.nBrickOffset - brickinfo.size.cx, 0,
                                0, 0);
            }

            for (x = 0; x < cBricksX; x++)
            {
                CDXDBnds bndsIntersect;
                CDXDBnds bndsDest;

                // Intersect bounds with DoBnds bounds so they're valid.

                bndsIntersect.IntersectBounds(bndsSrcB, WI.DoBnds);

                // Move bounds down one brick for next iteration.

                bndsSrcB.Offset(brickinfo.size.cx, 0, 0, 0);

                if (bndsIntersect.BoundsAreEmpty())
                {
                    continue;
                }

                bndsDest = bndsIntersect;
                bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(1), bndsIntersect,
                              dwFlags, INFINITE);

                if (FAILED(hr))
                {
                    goto done;
                }
            }

        }
    }

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::get_Direction, IDXTCheckerBoard
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTCheckerBoard::get_Direction(BSTR * pbstrDirection)
{
    HRESULT hr = S_OK;

    // Parameter validation.

    if (NULL == pbstrDirection)
    {
        hr = E_POINTER;

        goto done;
    }

    if (*pbstrDirection != NULL)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    // Allocate BSTR representing checkerboard direction.

    _ASSERT(m_eDirection < DIRECTION_MAX);

    *pbstrDirection = SysAllocString(g_astrDirection[m_eDirection]);

    if (NULL == *pbstrDirection)
    {
        hr = E_OUTOFMEMORY;
    }

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::put_Direction, IDXTCheckerBoard
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTCheckerBoard::put_Direction(BSTR bstrDirection)
{
    HRESULT hr              = S_OK;
    int     nNewDirection   = 0;

    if (NULL == bstrDirection)
    {
        hr = E_POINTER;

        goto done;
    }

    while (nNewDirection < (int)DIRECTION_MAX)
    {
        if (!_wcsicmp(bstrDirection, g_astrDirection[nNewDirection]))
        {
            break;
        }

        nNewDirection++;
    }

    if ((int)DIRECTION_MAX == nNewDirection)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (nNewDirection != (int)m_eDirection)
    {
        Lock();

        m_eDirection = (DIRECTION)nNewDirection;

        SetDirty();

        Unlock();
    }

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::get_SquaresX, IDXTCheckerBoard
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTCheckerBoard::get_SquaresX(int * pnSquaresX)
{
    HRESULT hr = S_OK;

    if (NULL == pnSquaresX)
    {
        hr = E_POINTER;

        goto done;
    }

    *pnSquaresX = m_nSquaresX;

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::put_SquaresX, IDXTCheckerBoard
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTCheckerBoard::put_SquaresX(int nSquaresX)
{
    HRESULT hr = S_OK;

    if (nSquaresX < 2)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (nSquaresX != m_nSquaresX)
    {
        m_nSquaresX = nSquaresX;

        SetDirty();
    }

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::get_SquaresY, IDXTCheckerBoard
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTCheckerBoard::get_SquaresY(int * pnSquaresY)
{
    HRESULT hr = S_OK;

    if (NULL == pnSquaresY)
    {
        hr = E_POINTER;

        goto done;
    }

    *pnSquaresY = m_nSquaresY;

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::put_SquaresY, IDXTCheckerBoard
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTCheckerBoard::put_SquaresY(int nSquaresY)
{
    HRESULT hr = S_OK;

    if (nSquaresY < 2)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    if (nSquaresY != m_nSquaresY)
    {
        m_nSquaresY = nSquaresY;

        SetDirty();
    }

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTCheckerBoard::_CalcBrickInfo
//
//------------------------------------------------------------------------------
void
CDXTCheckerBoard::_CalcBrickInfo(BRICKINFO & brickinfo)
{
    // Each square of the checkerboard will be measured in whole pixel units.
    // If the image is 500 pixels wide, and the user specified that there should
    // be 1000 squares horizontally, each square will set to 1 pixel wide and
    // there will be effectively only 500 squares in the x direction instead of
    // 1000.

    // Calculate square size.

    brickinfo.size.cx = m_sizeInput.cx / m_nSquaresX;

    if ((brickinfo.size.cx * m_nSquaresX) < m_sizeInput.cx)
    {
        brickinfo.size.cx++;
    }

    brickinfo.size.cy = m_sizeInput.cy / m_nSquaresY;

    if ((brickinfo.size.cy * m_nSquaresY) < m_sizeInput.cy)
    {
        brickinfo.size.cy++;
    }

    // Calculate brick size, brick offset, and portion of brick showing input B.

    if (VERTICAL_MOVEMENT)
    {
        long nBrickProgress     = 0;

        brickinfo.nBrickOffset  = brickinfo.size.cy;
        brickinfo.size.cy       = brickinfo.size.cy * 2;

        nBrickProgress = (long)(((float)brickinfo.size.cy + 0.5F) * m_Progress);

        // Calculate portion of brick showing input B.

        brickinfo.rcInputA.left   = 0;
        brickinfo.rcInputA.right  = brickinfo.size.cx;
        brickinfo.rcInputB.left   = 0;
        brickinfo.rcInputB.right  = brickinfo.size.cx;

        if (REVERSE_MOVEMENT)
        {
            brickinfo.rcInputB.top      = brickinfo.size.cy - nBrickProgress;
            brickinfo.rcInputB.bottom   = brickinfo.size.cy;

            brickinfo.rcInputA.top      = 0;
            brickinfo.rcInputA.bottom   = brickinfo.rcInputB.top;
        }
        else
        {
            brickinfo.rcInputB.top      = 0;
            brickinfo.rcInputB.bottom   = nBrickProgress;

            brickinfo.rcInputA.top      = brickinfo.rcInputB.bottom;
            brickinfo.rcInputA.bottom   = brickinfo.size.cy;
        }
    }
    else // Horizontal movement.
    {
        long nBrickProgress     = 0;

        brickinfo.nBrickOffset  = brickinfo.size.cx;
        brickinfo.size.cx       = brickinfo.size.cx * 2;

        nBrickProgress = (long)(((float)brickinfo.size.cx + 0.5F) * m_Progress);

        // Calculate portion of brick showing input B.

        brickinfo.rcInputA.top      = 0;
        brickinfo.rcInputA.bottom   = brickinfo.size.cy;
        brickinfo.rcInputB.top      = 0;
        brickinfo.rcInputB.bottom   = brickinfo.size.cy;

        if (REVERSE_MOVEMENT)
        {
            brickinfo.rcInputB.left     = brickinfo.size.cx - nBrickProgress;
            brickinfo.rcInputB.right    = brickinfo.size.cx;

            brickinfo.rcInputA.left     = 0;
            brickinfo.rcInputA.right    = brickinfo.rcInputB.left;
        }
        else
        {
            brickinfo.rcInputB.left     = 0;
            brickinfo.rcInputB.right    = nBrickProgress;

            brickinfo.rcInputA.left     = brickinfo.rcInputB.right;
            brickinfo.rcInputA.right    = brickinfo.size.cx;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\checkerboard.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:   checkerboard.h
//
//  Overview:   CheckerBoard transform.
//
//  Change History:
//  1999/09/16  a-matcal    Created.
//
//------------------------------------------------------------------------------

#ifndef __CHECKERBOARD_H_
#define __CHECKERBOARD_H_

#include "resource.h"   

typedef struct _BRICKINFO {
    SIZE    size;           // The size of each brick in pixels.
    RECT    rcInputA;       // The portion of each brick showing input A.
    RECT    rcInputB;       // The portion of each brick showing input B.
    long    nBrickOffset;   // The number of pixels to offset the bricks in the
                            // odd rows or columns.
} BRICKINFO;




class ATL_NO_VTABLE CDXTCheckerBoard : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTCheckerBoard, &CLSID_DXTCheckerBoard>,
    public IDispatchImpl<IDXTCheckerBoard, &IID_IDXTCheckerBoard, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTCheckerBoard>,
    public IObjectSafetyImpl2<CDXTCheckerBoard>,
    public IPersistStorageImpl<CDXTCheckerBoard>,
    public IPersistPropertyBagImpl<CDXTCheckerBoard>
{
private:

    typedef enum {
        UP = 0,
        DOWN,
        LEFT,
        RIGHT,
        DIRECTION_MAX
    } DIRECTION;

    DIRECTION                   m_eDirection;

    int                         m_nSquaresX;
    int                         m_nSquaresY;

    SIZE                        m_sizeInput;

    CComPtr<IUnknown>           m_cpUnkMarshaler;

    // Helpers.

    void _CalcBrickInfo(BRICKINFO & brickinfo);

    STDMETHOD(_WorkProcForVerticalBricks)(const CDXTWorkInfoNTo1 & WI, 
                                          BOOL * pbContinue,
                                          DWORD & dwFlags);
    STDMETHOD(_WorkProcForHorizontalBricks)(const CDXTWorkInfoNTo1 & WI, 
                                            BOOL * pbContinue,
                                            DWORD & dwFlags);

public:

    CDXTCheckerBoard();

    DECLARE_POLY_AGGREGATABLE(CDXTCheckerBoard)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTCHECKERBOARD)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTCheckerBoard)
        COM_INTERFACE_ENTRY(IDXTCheckerBoard)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTCheckerBoard>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTCheckerBoard)
        PROP_ENTRY("Direction", 1,  CLSID_DXTCheckerBoardPP)
        PROP_ENTRY("SquaresX",  2,  CLSID_DXTCheckerBoardPP)
        PROP_ENTRY("SquaresY",  3,  CLSID_DXTCheckerBoardPP)

        PROP_PAGE(CLSID_DXTCheckerBoardPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);

    // IDXTCheckerBoard properties.

    STDMETHOD(get_Direction)(BSTR * pbstrDirection);
    STDMETHOD(put_Direction)(BSTR bstrDirection);
    STDMETHOD(get_SquaresX)(int * pnSquaresX);
    STDMETHOD(put_SquaresX)(int nSquaresX);
    STDMETHOD(get_SquaresY)(int * pnSquaresY);
    STDMETHOD(put_SquaresY)(int nSquaresY);

    // IDXEffect methods.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};

#endif //__CHECKERBOARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\colormanagement.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    colormanagement.cpp
//
// Description: Color management filter transform.
//
// Change History:
//
// 2000/02/06   mcalkins    Created.  Ported code from an old filter.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "colormanagement.h"




//+-----------------------------------------------------------------------------
//
//  CDXTICMFilter static variables initialization.
//
//------------------------------------------------------------------------------

const TCHAR * 
CDXTICMFilter::s_strSRGBColorSpace = _T("sRGB Color Space Profile.icm");


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::CDXTICMFilter
//
//------------------------------------------------------------------------------
CDXTICMFilter::CDXTICMFilter() :
    m_bstrColorSpace(NULL)
{
    USES_CONVERSION;

    OSVERSIONINFO osvi;

    // Initialize LOGCOLORSPACE structure.

    m_LogColorSpace.lcsSignature = 'PSOC';
    m_LogColorSpace.lcsVersion   = 0x0400;
    m_LogColorSpace.lcsSize      = sizeof(LOGCOLORSPACE);
    m_LogColorSpace.lcsCSType    = LCS_CALIBRATED_RGB;
    m_LogColorSpace.lcsIntent    = LCS_GM_IMAGES;

    ::StringCchCopyW(m_LogColorSpace.lcsFilename, MAX_PATH, s_strSRGBColorSpace);

    // Are we on Win95 specifically?

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osvi);

    if ((osvi.dwMajorVersion == 4) && (osvi.dwMinorVersion == 0) 
        && (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS))
    {
        m_fWin95 = true;
    }
    else
    {
        m_fWin95 = false;
    }

    // CDXBaseNTo1 members.

    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;

    // Let's not deal with multithreading this transform.  Too many shared
    // structures.

    m_ulMaxImageBands   = 1;
}
//  Method:  CDXTICMFilter::CDXTICMFilter


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTICMFilter::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_spUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    m_bstrColorSpace = SysAllocString(L"sRGB");

    if (NULL == m_bstrColorSpace)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  Method:  CDXTICMFilter::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTICMFilter::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pfContinueProcessing)
{
    HRESULT                         hr              = S_OK;
    HDC                             hdcOut          = NULL;
    HDC                             hdcIn           = NULL;
    HDC                             hdcCompat       = NULL;
    HBITMAP                         hBitmap         = NULL;
    HBITMAP                         hOldBitmap      = NULL;
    HCOLORSPACE                     hColorSpace     = NULL;
    HCOLORSPACE                     hOldColorSpace  = NULL;
    int                             y               = 0;
    int                             nICMMode        = ICM_OFF;
    int                             nLines          = 0;
    const int                       nDoWidth        = WI.DoBnds.Width();
    const int                       nDoHeight       = WI.DoBnds.Height();

    BYTE *                          pBitmapBits     = NULL;
    BITMAPINFOHEADER *              pbmi            = NULL;
    DXPMSAMPLE *                    pOverScratch    = NULL;
    DXPMSAMPLE *                    pPMBuff         = NULL;
    DXSAMPLE *                      pBuffer         = NULL;

    CComPtr<IDXDCLock>              spDXDCLockOut;
    CComPtr<IDXDCLock>              spDXDCLockIn;

    DXDITHERDESC                    dxdd;
    RECT                            rcCompatDCClip;

    // Lock output surface.

    hr = OutputSurface()->LockSurfaceDC(&WI.OutputBnds, m_ulLockTimeOut, 
                                        DXLOCKF_READWRITE, &spDXDCLockOut);

    if (FAILED(hr))
    {
        goto done;
    }

    hdcOut = spDXDCLockOut->GetDC();

    // Lock input surface.

    hr = InputSurface()->LockSurfaceDC(&WI.DoBnds, m_ulLockTimeOut,
                                       DXLOCKF_READ, &spDXDCLockIn);

    if (FAILED(hr))
    {
        goto done;
    }
    
    hdcIn = spDXDCLockIn->GetDC();

    // Create a compatible DC to hdcOut.

    if (!(hdcCompat = ::CreateCompatibleDC(hdcOut)))
    {
        hr = E_FAIL;

        goto done;
    }

    // Create a compatible bitmap.

    if (!(hBitmap = ::CreateCompatibleBitmap(hdcOut, nDoWidth, nDoHeight)))
    {
        hr = E_FAIL;

        goto done;
    }

    // Select the compatible bitmap into our compatible DC.

    if (!(hOldBitmap = (HBITMAP)::SelectObject(hdcCompat, hBitmap)))
    {
        hr = E_FAIL;

        goto done;
    }

    // Create an appropriate clipping rectangle for the new DC.

    rcCompatDCClip.left     = 0;
    rcCompatDCClip.top      = 0;
    rcCompatDCClip.right    = nDoWidth;
    rcCompatDCClip.bottom   = nDoHeight;

    // Blit from the input surface onto our output compatible DC.

    if (!::BitBlt(hdcCompat, 0, 0, nDoWidth, nDoHeight, hdcIn, WI.DoBnds.Left(),
                  WI.DoBnds.Top(), SRCCOPY))
    {
        hr = E_FAIL;

        goto done;
    }

#if DBG == 1
    ::DrawText(hdcCompat, L"ICM Filter", 10, &rcCompatDCClip, 
               DT_CENTER | DT_SINGLELINE | DT_VCENTER);
#endif // DBG == 1

    // Allocate some bitmap bits.  

    // TODO: (mcalkins) We alocate 1MB of bits here, copied from old
    //        ICMFilter, maybe we could only allocate as much as we need.

    pBitmapBits = new BYTE[1024*1024];

    if (NULL == pBitmapBits)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    ZeroMemory(pBitmapBits, 1024*1024);

    // Allocate a bitmap info header.

    pbmi = (BITMAPINFOHEADER *) new BYTE[sizeof(BITMAPINFOHEADER) + (256 * sizeof(RGBQUAD))];

    if (NULL == pbmi)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    ZeroMemory(pbmi, sizeof(BITMAPINFOHEADER) + (256 * sizeof(RGBQUAD)));

    pbmi->biSize = sizeof(BITMAPINFOHEADER);

    // Fill in the BITMAPINFO structure.

    nLines = ::GetDIBits(hdcCompat, hBitmap, 0, nDoHeight, NULL,
                         (BITMAPINFO *)pbmi, DIB_RGB_COLORS);

    if (0 == nLines)
    {
#if DBG == 1
        DWORD dwError = ::GetLastError();
#endif
        
        hr = E_FAIL;

        goto done;
    }

    // Actually get the bits.

    nLines = ::GetDIBits(hdcCompat, hBitmap, 0, nDoHeight, pBitmapBits,
                         (BITMAPINFO *)pbmi, DIB_RGB_COLORS);

    if (0 == nLines)
    {
#if DBG == 1
        DWORD dwError = ::GetLastError();
#endif

        hr = E_FAIL;

        goto done;
    }

    // Make sure ICMMode is on for the output.

    nICMMode = ::SetICMMode(hdcOut, ICM_QUERY);

    if (nICMMode != ICM_ON)
    {
        if (!::SetICMMode(hdcOut, ICM_ON))
        {
            hr = E_FAIL;

            goto done;
        }
    }

    hColorSpace = ::CreateColorSpace(&m_LogColorSpace);

    if (NULL == hColorSpace)
    {
        hr = E_FAIL;

        goto done;
    }

    hOldColorSpace = (HCOLORSPACE)::SetColorSpace(hdcOut, hColorSpace);

    nLines = ::SetDIBitsToDevice(hdcOut, WI.OutputBnds.Left(),
                                 WI.OutputBnds.Top(), nDoWidth, nDoHeight, 0, 0,
                                 0, nDoHeight, pBitmapBits, (BITMAPINFO *)pbmi, 
                                 DIB_RGB_COLORS);

    if (0 == nLines)
    {
#if DBG == 1
        DWORD dwError = ::GetLastError();
#endif
        hr = E_FAIL;

        goto done;
    }
    
    // Reset ICMMode on output surface to what it was before.

    if (nICMMode != ICM_ON)
    {
        // It's possible but unlikely that this will fail.  We really don't care
        // anymore, so no need to pay attention.

        ::SetICMMode(hdcOut, nICMMode);
    }

done:

    if (pBitmapBits)
    {
        delete [] pBitmapBits;
    }

    if (pbmi)
    {
        delete [] pbmi;
    }

    if (hOldBitmap)
    {
        ::SelectObject(hdcCompat, hOldBitmap);
    }

    if (hBitmap)
    {
        ::DeleteObject(hBitmap);
    }

    if (hdcCompat)
    {
        ::DeleteDC(hdcCompat);
    }

    if (hOldColorSpace)
    {
        ::SetColorSpace(hdcOut, hOldColorSpace);
    }

    if (hColorSpace)
    {
        ::DeleteColorSpace(hColorSpace);
    }

    return hr;
}
//  Method:  CDXTICMFilter::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::get_ColorSpace, IDXTICMFilter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTICMFilter::get_ColorSpace(BSTR * pbstrColorSpace)
{
    HRESULT hr = S_OK;

    if (NULL == pbstrColorSpace)
    {
        hr = E_POINTER;

        goto done;
    }

    if (*pbstrColorSpace != NULL)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    *pbstrColorSpace = SysAllocString(m_bstrColorSpace);

    if (NULL == *pbstrColorSpace)
    {
        hr = E_OUTOFMEMORY;
    }

done:

    return hr;
}
//  Method:  CDXTICMFilter::get_ColorSpace, IDXTICMFilter


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::put_ColorSpace, IDXTICMFilter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTICMFilter::put_ColorSpace(BSTR bstrColorSpace)
{
    HRESULT hr                  = S_OK;
    UINT    ui                  = 0;
    BSTR    bstrTemp            = NULL;
    TCHAR   strPath[MAX_PATH]   = _T("");
    BOOL    fAllow              = FALSE;

    CComPtr<IServiceProvider>   spServiceProvider;
    CComPtr<ISecureUrlHost>     spSecureUrlHost;
    
    if (NULL == bstrColorSpace)
    {
        hr = E_POINTER;

        goto done;
    }

    bstrTemp = SysAllocString(bstrColorSpace);

    if (NULL == bstrTemp)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    if (m_fWin95)
    {
        ui = ::GetSystemDirectory(strPath, MAX_PATH);

        if (0 == ui)
        {
            hr = E_FAIL;

            goto done;
        }

        hr = ::StringCchCatW(strPath, MAX_PATH, L"\\color\\");

        if (FAILED(hr))
        {
            goto done;
        }
    }

    // Complete path.

    if (!::_wcsicmp(L"srgb", bstrColorSpace))
    {
        hr = ::StringCchCatW(strPath, MAX_PATH, s_strSRGBColorSpace);

        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        hr = ::StringCchCatW(strPath, MAX_PATH, bstrColorSpace);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    hr = GetSite(__uuidof(IServiceProvider), (void **)&spServiceProvider);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spServiceProvider->QueryService(__uuidof(IElementBehaviorSite),
                                         __uuidof(ISecureUrlHost),
                                         (void **)&spSecureUrlHost);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spSecureUrlHost->ValidateSecureUrl(&fAllow, strPath, 0);

    if (FAILED(hr))
    {
        goto done;
    }
    else if (!fAllow)
    {
        hr = E_FAIL;
        goto done;
    }
      
    // Copy path to LOGCOLORSPACE structure.

    hr = ::StringCchCopyW(m_LogColorSpace.lcsFilename, MAX_PATH, strPath);

    if (FAILED(hr))
    {
        goto done;
    }

    // Free current color space string.

    if (m_bstrColorSpace)
    {
        SysFreeString(m_bstrColorSpace);
    }

    // Save new color space string.

    m_bstrColorSpace = bstrTemp;

done:

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    return hr;
}
//  Method:  CDXTICMFilter::put_ColorSpace, IDXTICMFilter


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::get_Intent, IDXTICMFilter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTICMFilter::get_Intent(short * pnIntent)
{
    if (NULL == pnIntent)
    {
        return E_POINTER;
    }

    // It's kind of a crazy mapping, but here it is:
    // Filter Intent    GDI Intent
    // -------------    ----------------------------
    //  0                LCS_GM_IMAGES (default)
    //  1                LCS_GM_GRAPHICS
    //  2                LCS_GM_BUSINESS
    //  4                LCS_GM_ABS_COLORIMETRIC

    switch (m_LogColorSpace.lcsIntent)
    {
    case LCS_GM_IMAGES:
        *pnIntent = 0;
        break;

    case LCS_GM_GRAPHICS:
        *pnIntent = 1;
        break;

    case LCS_GM_BUSINESS:
        *pnIntent = 2;
        break;

    case LCS_GM_ABS_COLORIMETRIC:
        *pnIntent = 4;
        break;
    
    default:
        *pnIntent = 0;
        _ASSERT(false);  // We should never get here.
        break;
    }

    return S_OK;
}
//  Method:  CDXTICMFilter::get_Intent, IDXTICMFilter


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTICMFilter::put_Intent, IDXTICMFilter
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTICMFilter::put_Intent(short nIntent)
{
    // No parameter checking to match old filter logic.

    switch (nIntent)
    {
    case 1:
        m_LogColorSpace.lcsIntent = LCS_GM_GRAPHICS;
        break;

    case 2:
        m_LogColorSpace.lcsIntent = LCS_GM_BUSINESS;
        break;

    case 4:
        m_LogColorSpace.lcsIntent = LCS_GM_ABS_COLORIMETRIC; // 8
        break;

    default:
        m_LogColorSpace.lcsIntent = LCS_GM_IMAGES;
        break;
    }

    return S_OK;
}
//  Method:  CDXTICMFilter::put_Intent, IDXTICMFilter
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\colormanagement.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    colormanagement.h
//
// Description: Color management filter transform.
//
// Change History:
//
// 2000/02/06   mcalkins    Created.  Ported code from an old filter.
//
//------------------------------------------------------------------------------

#ifndef __COLORMANAGEMENT_H_
#define __COLORMANAGEMENT_H_

#include "resource.h"

class ATL_NO_VTABLE CDXTICMFilter : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTICMFilter, &CLSID_DXTICMFilter>,
    public CComPropertySupport<CDXTICMFilter>,
    public IDispatchImpl<IDXTICMFilter, &IID_IDXTICMFilter, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CDXTICMFilter>,
    public IPersistStorageImpl<CDXTICMFilter>,
    public ISpecifyPropertyPagesImpl<CDXTICMFilter>,
    public IPersistPropertyBagImpl<CDXTICMFilter>
{
private:

    CComPtr<IUnknown>       m_spUnkMarshaler;

    LOGCOLORSPACE           m_LogColorSpace;
    BSTR                    m_bstrColorSpace;

    static const TCHAR *    s_strSRGBColorSpace;

    // m_fWin95         True if we're on Windows 95 specifically.  In ths case
    //                  we need to have some special treatment of the color 
    //                  space directories.

    unsigned                m_fWin95 : 1;

public:

    CDXTICMFilter();

    DECLARE_POLY_AGGREGATABLE(CDXTICMFilter)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_DXTICMFILTER)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTICMFilter)
        COM_INTERFACE_ENTRY(IDXTICMFilter)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTICMFilter>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTICMFilter)
        PROP_ENTRY("colorspace",    DISPID_DXTICMFILTER_COLORSPACE, CLSID_DXTICMFilterPP)
        PROP_ENTRY("intent",        DISPID_DXTICMFILTER_INTENT,     CLSID_DXTICMFilterPP)
        PROP_PAGE(CLSID_DXTICMFilterPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pfContinueProcessing);
    //HRESULT OnSetup(DWORD dwFlags);

    // IDXTICMFilter methods.

    STDMETHOD(get_ColorSpace)(BSTR * pbstrColorSpace);
    STDMETHOD(put_ColorSpace)(BSTR bstrColorSpace);
    STDMETHOD(get_Intent)(short * pnIntent);
    STDMETHOD(put_Intent)(short nIntent);
};

#endif // __COLORMANAGEMENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\convolve.cpp ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998-2000
//
//  FileName:   convolve.cpp
//
//  Overview:   The CDXConvolution transform implementation.
//             
//  Change History:
//  1998/05/08  edc         Created.
//  2000/02/08  mcalkins    Fixed partial redraw cases.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "Convolve.h"
#include <math.h>

static SIZE g_StaticFilterSize = { 3, 3 };
static float g_SharpenFilter[] = { 0, -1, 0, -1, 5, -1, 0, -1, 0 };
static float g_EmbossFilter[] = { 1, 0, 0, 0, 0, 0, 0, 0, -1 };
static float g_EngraveFilter[] = { -1, 0, 0, 0, 0, 0, 0, 0, 1 };

static float g_Blur3x3Filter[] = 
    { 1.f/16.f, 1.f/8.f, 1.f/16.f, 1.f/8.f , 1.f/4.f, 1.f/8.f , 1.f/16.f, 1.f/8.f, 1.f/16.f };


    
    
/*****************************************************************************
* CDXConvolution::FinalConstruct *
*--------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 08/08/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT 
CDXConvolution::FinalConstruct()
{
    DXTDBG_FUNC( "CDXConvolution::FinalConstruct" );

    HRESULT hr = S_OK;

    // Some transforms should just not run multithreaded, this is one of them.
    // It locks and unlocks inputs and outputs too radically which could cause
    // lockups very easily.

    m_ulMaxImageBands = 1;

    // Init base class variables to control setup.

    m_ulMaxInputs     = 1;
    m_ulNumInRequired = 1;

    // Member data.

    m_pFilter              = NULL;
    m_pCustomFilter        = NULL;
    m_pFilterLUTIndexes    = NULL;
    m_pPMCoeffLUT          = NULL;
    m_bConvertToGray       = false;
    m_bDoSrcCopyOnly       = false;
    m_MarginedSurfSize.cx  = 0;
    m_MarginedSurfSize.cy  = 0;
    m_Bias                 = 0.;
    m_bExcludeAlpha        = true;

    // Set the default filter, this will initialize the rest of the
    // member variables.

    hr = SetFilterType(DXCFILTER_BLUR3X3);

    if (FAILED(hr))
    {
        goto done;
    }

    // Create marshaler.

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_spUnkMarshaler);

done:

    return hr;
} /* CDXConvolution::FinalConstruct */


/*****************************************************************************
* CDXConvolution::FinalRelease *
*------------------------------*
*   Description:
*       The CDXConvolution destructor
*-----------------------------------------------------------------------------
*  Created By: Ed Connell                            Date: 07/17/97
*-----------------------------------------------------------------------------
*   Parameters:
*
*****************************************************************************/
void CDXConvolution::FinalRelease( void )
{
    DXTDBG_FUNC( "CDXConvolution::FinalRelease" );
    delete[] m_pCustomFilter;
    delete[] m_pFilterLUTIndexes;
    delete[] m_pPMCoeffLUT;
} /* CDXConvolution::FinalRelease */


/*****************************************************************************
* CDXConvolution::OnSetup *
*-------------------------*
*   Description:
*       This method is used to determine the types of the inputs and select
*   the optimal execution case.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 01/06/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXConvolution::OnSetup( DWORD dwFlags )
{
    DXTDBG_FUNC( "CDXConvolution::OnSetup" );
    HRESULT hr = S_OK;

    //--- Cache input surface size
    hr = InputSurface()->GetBounds( &m_InputSurfBnds );

    _DetermineUnpackCase();

    return hr;
} /* CDXConvolution::OnSetup */


/*****************************************************************************
* CDXConvolution::_DetermineUnpackCase *
*--------------------------------------*
*   Description:
*       This method is used to determine the types of the inputs and select
*   the optimal execution case.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 06/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
void CDXConvolution::_DetermineUnpackCase()
{
    DXTDBG_FUNC( "CDXConvolution::_DetermineUnpackCase" );
    HRESULT hr = S_OK;

    if( HaveInput() )
    {
        //--- Figure out how to unpack input and output
        if( m_bDoSampleClamp )
        {
            m_bInUnpackPremult  = false;
            m_bOutUnpackPremult = ( m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT )?(true):(false);
        }
        else
        {
            if( m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT )
            {
                //--- Has gotta be premult to do the over
                m_bInUnpackPremult = true;
                m_bOutUnpackPremult = true;
            }
            else
            {
                //--- Match the output format
                m_bInUnpackPremult  = ( OutputSampleFormat() & DXPF_NONPREMULT )?( false ):( true );
                m_bOutUnpackPremult = m_bInUnpackPremult;
            }
        }

        //--- Determine whether we need buffers
        if( (  m_bOutUnpackPremult   && ( OutputSampleFormat() == DXPF_PMARGB32 )) ||
            ( (!m_bOutUnpackPremult) && ( OutputSampleFormat() == DXPF_ARGB32   )) )
        {
            m_bNeedOutUnpackBuff = false;
        }
        else
        {
            m_bNeedOutUnpackBuff = true;
        }

        //
        //  We need the input buffer if we are dithering even if it's in the native
        //  format because we will dither in place
        //
        if( ( m_bInUnpackPremult   && ( InputSampleFormat() == DXPF_PMARGB32 )) ||
            ((!m_bInUnpackPremult) && ( InputSampleFormat() == DXPF_ARGB32  )) )
        {
            m_bNeedInUnpackBuff = false;
        }
        else
        {
            m_bNeedInUnpackBuff = true;
        }
    }
} /* CDXConvolution::_DetermineUnpackCase */


/*****************************************************************************
* CDXConvolution::OnInitInstData *
*--------------------------------*
*   Description:
*       This method is called once per execution.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 08/08/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXConvolution::OnInitInstData( CDXTWorkInfoNTo1& WI, ULONG& ulNB )
{
    DXTDBG_FUNC( "CDXConvolution::OnInitInstData" );
    HRESULT hr = S_OK;

    //--- Save base row when banding
    m_DoBndsBaseRow = WI.DoBnds.Top();

    //--- Create/resize the margined surface if necessary
    CDXDBnds InBnds( false );
    hr = MapBoundsOut2In( 0, &m_InputSurfBnds, 0, &InBnds );

    if( SUCCEEDED( hr ) )
    {
        CDXDBnds Bnds( InBnds );

        //--- We need a surface with an extra row/col to
        //    handle an inner loop boundary condition.
        Bnds[DXB_X].Max += ( 4 * m_FilterSize.cx ) + 1;
        Bnds[DXB_Y].Max += ( 4 * m_FilterSize.cy ) + 1;

        if( ( m_cpMarginedSurf == NULL ) ||
            ( (long)Bnds.Width()  > m_MarginedSurfSize.cx ) ||
            ( (long)Bnds.Height() > m_MarginedSurfSize.cy ) )
        {
            DXTDBG_MSG0( _CRT_WARN, "Creating Margined Surface\n" );
            m_cpMarginedSurf.Release();

            //--- Force a surface refresh
            m_LastDoBnds.SetEmpty();

            //--- Make our working surface the same format as the
            //    unpack type for performance reasons
            m_bMarginedIsPremult = m_bInUnpackPremult;
            const GUID* pPixelFormat = ( m_bInUnpackPremult )?( &DDPF_PMARGB32 ):( &DDPF_ARGB32 );

            hr = m_cpSurfFact->CreateSurface( NULL, NULL, pPixelFormat, &Bnds, 0, NULL,
                                              IID_IDXSurface, (void**)&m_cpMarginedSurf );

            if( SUCCEEDED( hr ) )
            {
                Bnds.GetXYSize( m_MarginedSurfSize );
            }
            else
            {
                //--- Make sure it's null on error because we key off it above.
                DXTDBG_MSG0( _CRT_WARN, "Failed to create Margined Surface\n" );
                m_cpMarginedSurf.p = NULL;
            }
        }
        else
        {
            //--- We call this to convert the current sample format
            //    in case we don't have to resize the margined surface.
            hr = _SetToPremultiplied( m_bInUnpackPremult );
        }
    }

    //--- Update our working surface contents if we have one and its necessary
    if( SUCCEEDED( hr ) && ( ( InBnds != m_LastDoBnds ) || IsInputDirty() ) )
    {
        m_LastDoBnds = InBnds;

        //--- Determine what portion of the input should be copied
        //    Note: Since our working surface has a margin, to eliminate boundary
        //          conditions in the inner loop, we must fill it with something.
        //          if the requested region plus its margin is within the bounds of
        //          the input, we fill fill the margins with input data, otherwise
        //          we will fill it with 0 alpha.
        CDXDBnds DestBnds( false );
        SIZE HalfSpread, DestOffset;

        // We used to use just half the spread, but that wasn't always enough
        // so now we use the whole spread at the risk that maybe we'll have too 
        // much input.

        HalfSpread.cx = m_OutputSpread.cx;
        HalfSpread.cy = m_OutputSpread.cy;

        //=== Expand the input bounds to include margin ===
        //--- X Min
        if( InBnds[DXB_X].Min - HalfSpread.cx < 0 )
        {
            DestOffset.cx = m_OutputSpread.cx - InBnds[DXB_X].Min;
            InBnds[DXB_X].Min = 0;
        }
        else
        {
            InBnds[DXB_X].Min -= HalfSpread.cx;
            DestOffset.cx = HalfSpread.cx;
        }
        //--- X Max
        InBnds[DXB_X].Max += HalfSpread.cx;
        if( InBnds[DXB_X].Max > m_InputSurfBnds[DXB_X].Max )
        {
            InBnds[DXB_X].Max = m_InputSurfBnds[DXB_X].Max;
        }

        //--- Y Min
        if( InBnds[DXB_Y].Min - HalfSpread.cy < 0 )
        {
            DestOffset.cy = m_OutputSpread.cy - InBnds[DXB_Y].Min;
            InBnds[DXB_Y].Min = 0;
        }
        else
        {
            InBnds[DXB_Y].Min -= HalfSpread.cy;
            DestOffset.cy = HalfSpread.cy;
        }
        //--- Y Max
        InBnds[DXB_Y].Max += HalfSpread.cy;
        if( InBnds[DXB_Y].Max > m_InputSurfBnds[DXB_Y].Max )
        {
            InBnds[DXB_Y].Max = m_InputSurfBnds[DXB_Y].Max;
        }

        //--- Do the blit filling the margins with 0 alpha
        //InBnds.GetSize( DestBnds );
        //DestBnds.Offset( DestOffset.cx, DestOffset.cy, 0, 0 );

        DestBnds = InBnds;
        DestBnds.Offset(m_FilterSize.cx, m_FilterSize.cy, 0, 0);

        hr = DXFillSurface(m_cpMarginedSurf, 0);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = DXBitBlt(m_cpMarginedSurf, DestBnds, InputSurface(), InBnds, 0, 10000);

        if (FAILED(hr))
        {
            goto done;
        }

        if (m_bConvertToGray)
        {
            hr = _ConvertToGray(DestBnds);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    return hr;
} /* CDXConvolution::OnInitInstData */


/*****************************************************************************
* CDXConvolution::_ConvertToGray *
*--------------------------------*
*   Description:
*       This method is called to convert the cached image to gray scale.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 08/08/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXConvolution::_ConvertToGray( CDXDBnds& Bnds )
{
    DXTDBG_FUNC( "CDXConvolution::ConvertToGray" );
    HRESULT hr = S_OK;

    CComPtr<IDXARGBReadWritePtr> cpSurf;
    hr = m_cpMarginedSurf->LockSurface( &Bnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                        IID_IDXARGBReadWritePtr, (void**)&cpSurf, NULL );
    if( SUCCEEDED( hr ) )
    {
        cpSurf->GetNativeType( &m_MarginedSurfInfo );
        DXBASESAMPLE* pSamp = (DXBASESAMPLE*)m_MarginedSurfInfo.pFirstByte;
        ULONG Wid = Bnds.Width(), Hgt = Bnds.Height();

        for( ULONG y = 0; y < Hgt; ++y )
        {
            for( ULONG x = 0; x < Wid; ++x )
            {
                pSamp[x] = DXConvertToGray( pSamp[x] );
            }
            pSamp = (DXBASESAMPLE*)(((BYTE*)pSamp) + m_MarginedSurfInfo.lPitch);
        }
    }

    return hr;
} /* CDXConvolution::_ConvertToGray */


/*****************************************************************************
* CDXConvolution::_SetToPremultiplied *
*-------------------------------------*
*   Description:
*       This method is called to convert the cached image to either
*   premultiplied or non-premultiplied samples.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 06/16/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXConvolution::_SetToPremultiplied( BOOL bWantPremult )
{
    DXTDBG_FUNC( "CDXConvolution::_SetToPremultiplied" );
    HRESULT hr = S_OK;

    if( m_cpMarginedSurf && ( m_bMarginedIsPremult != bWantPremult ) )
    {
        m_bMarginedIsPremult = bWantPremult;

        CComPtr<IDXARGBReadWritePtr> cpSurf;
        hr = m_cpMarginedSurf->LockSurface( NULL, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                            IID_IDXARGBReadWritePtr, (void**)&cpSurf, NULL );
        if( SUCCEEDED( hr ) )
        {
            cpSurf->GetNativeType( &m_MarginedSurfInfo );
            DXBASESAMPLE* pSamp = (DXBASESAMPLE*)m_MarginedSurfInfo.pFirstByte;

            for( long y = 0; y < m_MarginedSurfSize.cy; ++y )
            {
                if( bWantPremult )
                {
                    DXPreMultArray( (DXSAMPLE*)pSamp, m_MarginedSurfSize.cx );
                }
                else
                {
                    DXUnPreMultArray( (DXPMSAMPLE*)pSamp, m_MarginedSurfSize.cx );
                }
                pSamp = (DXBASESAMPLE*)(((BYTE*)pSamp) + m_MarginedSurfInfo.lPitch);
            }
        }
    }
    return hr;
} /* CDXConvolution::_SetToPremultiplied */


//
//=== IDXTransform overrides =================================================
//


/*****************************************************************************
* CDXConvolution::MapBoundsIn2Out *
*---------------------------------*
*   Description:
*       The MapBoundsIn2Out method is used to perform coordinate transformation
*   from the input to the output coordinate space.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 10/24/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXConvolution::MapBoundsIn2Out( const DXBNDS *pInBounds, ULONG ulNumInBnds,
                                              ULONG ulOutIndex, DXBNDS *pOutBounds )
{
    DXTDBG_FUNC( "CDXConvolution::MapBoundsIn2Out" );
    HRESULT hr = S_OK;
    
    if( ( ulNumInBnds && DXIsBadReadPtr( pInBounds, sizeof( *pInBounds ) * ulNumInBnds ) ) ||
        ( ulNumInBnds > 1 ) || ( ulOutIndex > 0 ) )
    {
        hr = E_INVALIDARG;
    }
    else if( DXIsBadWritePtr( pOutBounds, sizeof( *pOutBounds ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- If the caller does not specify a bounds we
        //    will use the bounds of the input
        CDXDBnds Bnds;
        if( ulNumInBnds == 0 )
        {
            Bnds.SetToSurfaceBounds(InputSurface());
            pInBounds = &Bnds;
        }

        *pOutBounds = *pInBounds;

        //--- Inflate by the size of the filter if we are
        //    not just doing a copy.
        if( !m_bDoSrcCopyOnly )
        {
            pOutBounds->u.D[DXB_X].Max += m_OutputSpread.cx;
            pOutBounds->u.D[DXB_Y].Max += m_OutputSpread.cy;
        }
    }
    return hr;
} /* CDXConvolution::MapBoundsIn2Out */


/*****************************************************************************
* CDXConvolution::MapBoundsOut2In *
*---------------------------------*
*   Description:
*       The MapBoundsOut2In method is used to perform coordinate transformation
*   from the input to the output coordinate space.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 10/24/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXConvolution::MapBoundsOut2In( ULONG ulOutIndex, const DXBNDS *pOutBounds,
                                              ULONG ulInIndex, DXBNDS *pInBounds )
{
    DXTDBG_FUNC( "CDXConvolution::MapBoundsOut2In" );
    HRESULT hr = S_OK;
    
    if( DXIsBadReadPtr( pOutBounds, sizeof( *pOutBounds ) ) || ( ulOutIndex > 0 ) )
    {
        hr = E_INVALIDARG;
    }
    else if( DXIsBadWritePtr( pInBounds, sizeof( *pInBounds ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pInBounds = *pOutBounds;

        // How this works:  To calculate each pixel, each is centered in a
        // group of pixels that is the same size as m_FilterSize.  Knowing this,
        // we can add half of the m_FilterSize (rounding up) to our output 
        // bounds and be sure we include at least all the pixels we need and
        // maybe a couple more.  Then we offset the bounds into input space and
        // insersect those bounds with the full input bounds to make sure we 
        // don't return invalid bounds.

        // Temporary surface used to compute output. 
        // "0" = m_OutputSpread pixels.
        // "I" = Input surface pixels.
        // "-" = Output bounds for which input bounds were requested.
        //
        // 00000000000000000000000000
        // 0-----00000000000000000000
        // 0-----IIIIIIIIIIIIIIIIII00
        // 0-----IIIIIIIIIIIIIIIIII00
        // 0-----IIIIIIIIIIIIIIIIII00
        // 00IIIIIIIIIIIIIIIIIIIIII00
        // 00IIIIIIIIIIIIIIIIIIIIII00
        // 00000000000000000000000000
        // 00000000000000000000000000
        //
        // "-" = Expanded bounds after expanding by half of m_FilterSize.
        //       (2 in both directions)
        // 
        // --------000000000000000000
        // --------000000000000000000
        // --------IIIIIIIIIIIIIIII00
        // --------IIIIIIIIIIIIIIII00
        // --------IIIIIIIIIIIIIIII00
        // --------IIIIIIIIIIIIIIII00
        // --------IIIIIIIIIIIIIIII00
        // 00000000000000000000000000
        // 00000000000000000000000000
        //
        // "-" = Offset by negative half of m_OutputSpread to put into input
        //       surface coordinates.
        //
        // --------
        // --------
        // --------IIIIIIIIIIIIIIII
        // --------IIIIIIIIIIIIIIII
        // --------IIIIIIIIIIIIIIII
        // --------IIIIIIIIIIIIIIII
        // --------IIIIIIIIIIIIIIII
        //
        // "-" = Clip to input surface coordinates.
        //
        //   ------IIIIIIIIIIIIIIII
        //   ------IIIIIIIIIIIIIIII
        //   ------IIIIIIIIIIIIIIII
        //   ------IIIIIIIIIIIIIIII
        //   ------IIIIIIIIIIIIIIII

        if (!m_bDoSrcCopyOnly)
        {
            CDXDBnds    bndsInput;
            CDXDBnds *  pbndsOut2In = (CDXDBnds *)pInBounds;
            SIZE        sizeFilterExtends;

            sizeFilterExtends.cx = (m_FilterSize.cx + 1) / 2; 
            sizeFilterExtends.cy = (m_FilterSize.cy + 1) / 2;

            bndsInput.SetToSurfaceBounds(InputSurface());

            pbndsOut2In->u.D[DXB_X].Min -= sizeFilterExtends.cx;
            pbndsOut2In->u.D[DXB_X].Max += sizeFilterExtends.cx;
            pbndsOut2In->u.D[DXB_Y].Min -= sizeFilterExtends.cy;
            pbndsOut2In->u.D[DXB_Y].Max += sizeFilterExtends.cy;

            pbndsOut2In->Offset(- (m_OutputSpread.cx / 2), - (m_OutputSpread.cy / 2), 0, 0);

            pbndsOut2In->IntersectBounds(bndsInput);
        }
    }

    return hr;
} /* CDXConvolution::MapBoundsOut2In */


//
//=== IDXTConvolution ========================================================
//


/*****************************************************************************
* CDXConvolution::SetFilterType *
*-------------------------------*
*   Description:
*       The SetFilterType method is used to select a predefined filter.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 05/08/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXConvolution::SetFilterType( DXCONVFILTERTYPE eType )
{
    DXTDBG_FUNC( "CDXConvolution::SetFilterType" );
    HRESULT hr = S_OK;

    //--- Check args
    if( ( eType < 0 ) || ( eType >= DXCFILTER_NUM_FILTERS ) )
    {
        hr =  E_INVALIDARG;
    }
    else
    {
        //--- Force a margined surface refresh
        m_LastDoBnds.SetEmpty();

        m_FilterType = eType;
        m_FilterSize = g_StaticFilterSize;
        m_bDoSrcCopyOnly = false;

        //--- Select predefined filter type
        switch( eType )
        {
          case DXCFILTER_SRCCOPY:
            m_bDoSrcCopyOnly = true;
            m_pFilter = NULL;
            SetConvertToGray( false );
            break;
          case DXCFILTER_BOX7X7:
          {
            float* pFilt = (float*)alloca( 49 * sizeof( float ) );
            for( int i = 0; i < 49; ++i ) pFilt[i] = (float)(1./49.);
            static SIZE Size = { 7, 7 };
            hr = SetCustomFilter( pFilt, Size );
            SetExcludeAlpha( false );
            SetBias( 0. );
            m_FilterType = DXCFILTER_BOX7X7;
            SetConvertToGray( false );
            break;
          }
          case DXCFILTER_BLUR3X3:
            m_pFilter = g_Blur3x3Filter;
            SetExcludeAlpha( false );
            SetBias( 0. );
            SetConvertToGray( false );
            break;
          case DXCFILTER_SHARPEN:
            m_pFilter = g_SharpenFilter;
            SetExcludeAlpha( true );
            SetBias( 0. );
            SetConvertToGray( false );
            break;
          case DXCFILTER_EMBOSS:
            m_pFilter = g_EmbossFilter;
            SetBias( .7f );
            SetExcludeAlpha( true );
            SetConvertToGray( true );
            break;
          case DXCFILTER_ENGRAVE:
            m_pFilter = g_EngraveFilter;
            SetBias( .7f );
            SetExcludeAlpha( true );
            SetConvertToGray( true );
            break;
        }

        if( !m_bDoSrcCopyOnly )
        {
            hr = _BuildFilterLUTs();
        }
        SetDirty();
    }

    return hr;
} /* CDXConvolution::SetFilterType */


/*****************************************************************************
* CDXConvolution::GetFilterType *
*-------------------------------*
*   Description:
*       The GetFilterType method is used to perform any required one-time setup
*   before the Execute method is called.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXConvolution::GetFilterType( DXCONVFILTERTYPE* peType )
{
    DXTDBG_FUNC( "CDXConvolution::GetFilterType" );
    HRESULT hr = S_OK;

    if( DXIsBadWritePtr( peType, sizeof( *peType ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *peType = m_FilterType;
    }

    return hr;
} /* CDXConvolution::GetFilterType */


/*****************************************************************************
* CDXConvolution::SetCustomFilter *
*---------------------------------*
*   Description:
*       The SetCustomFilter method is used to define the convolution kernel.
*   A size of one causes a source copy since a normalized 1x1 pass would have
*   the same effect.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/28/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXConvolution::SetCustomFilter( float *pFilter, SIZE Size )
{
    HRESULT hr = S_OK;
    int NumCoeff = Size.cx * Size.cy;

    if( DXIsBadReadPtr( pFilter, NumCoeff * sizeof(float) ) ||
        ( Size.cx < 1 ) || ( Size.cy < 1 ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Force a margined surface refresh to adjust for new filter size
        m_LastDoBnds.SetEmpty();

        if( ( Size.cx == 1 ) && ( Size.cy == 1 ) )
        {
            m_bDoSrcCopyOnly = true;
        }
        else
        {
            //--- Make sure the filter doesn't sum to a negative value
            m_bDoSrcCopyOnly = false;
            float FilterSum = 0.;
            for( int i = 0; i < NumCoeff; ++i ) FilterSum += pFilter[i];
            if( FilterSum <= 0. )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                //--- Set type to user defined
                m_FilterType = DXCFILTER_CUSTOM;

                //--- Save size
                m_FilterSize = Size;

                //--- Copy the filter
                delete[] m_pCustomFilter;
                m_pCustomFilter = new float[NumCoeff];
                if( !m_pCustomFilter )
                {
                    hr = E_OUTOFMEMORY;
                    m_pFilter = NULL;
                }
                else
                {
                    memcpy( m_pCustomFilter, pFilter, NumCoeff * sizeof(float) );
                    m_pFilter = m_pCustomFilter;
                }

                if( SUCCEEDED( hr ) )
                {
                    hr = _BuildFilterLUTs();
                }
            }
        }
        SetDirty();
    }
    return hr;
} /* CDXConvolution::SetCustomFilter */


/*****************************************************************************
* CDXConvolution::_BuildFilterLUTs *
*----------------------------------*
*   Description:
*       The _BuildFilterLUTs method is used to build the filter coefficient
*   lookup tables used to process the image.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 05/08/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXConvolution::_BuildFilterLUTs( void )
{
    DXTDBG_FUNC( "CDXConvolution::_BuildFilterLUTs" );
    HRESULT hr = S_OK;
    int NumCoeff = m_FilterSize.cx * m_FilterSize.cy;
    int i, j;

    //--- Determine output spread
    m_OutputSpread.cx = 2 * ( m_FilterSize.cx / 2 );
    m_OutputSpread.cy = 2 * ( m_FilterSize.cy / 2 );

    //--- Do a quick check to determine if this is a box filter
    if( m_bExcludeAlpha )
    {
        //--- If we are excluding the alpha channel then we can't
        //    do the box filter special case code because it
        //    requires non-premultiplied alpha to work correctly.
        m_bIsBoxFilter = false;
    }
    else
    {
        m_bIsBoxFilter = true;
        float FirstCoeff = m_pFilter[0];
        for( i = 0; i < NumCoeff; ++i )
        {
            if( m_pFilter[i] != FirstCoeff )
            {
                m_bIsBoxFilter = false;
                break;
            }
        }
        if( m_bIsBoxFilter ) NumCoeff = 1;
    }

    //--- Allocate array that is the same size as the filter and
    //    populate with the corresponding lookup table indexes to use.
    delete[] m_pFilterLUTIndexes;
    m_pFilterLUTIndexes = new ULONG[NumCoeff];

    if( !m_pFilterLUTIndexes )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        //--- Determine how many unique coefficients there are
        //    and build the filter lookup table index
        float* TableCoefficient = (float*)alloca( NumCoeff * sizeof( float ) );
        m_pFilterLUTIndexes[0] = 0;
        int UniqueCnt = 0;
        for( i = 0; i < NumCoeff; ++i )
        {
            for( j = 0; j < i; ++j )
            {
                if( m_pFilter[i] == m_pFilter[j] )
                {
                    //--- Duplicate found
                    m_pFilterLUTIndexes[i] = m_pFilterLUTIndexes[j];
                    break;
                }
            }

            if( j == i )
            {
                //--- New coefficient
                TableCoefficient[UniqueCnt] = m_pFilter[i];
                m_pFilterLUTIndexes[i] = UniqueCnt++;
            }
        }

        //--- Clamp if the filter sum exceeds 1 or has a negative coefficient
        float FilterSum = 0.;
        m_bDoSampleClamp = false;
        for( i = 0; i < NumCoeff; ++i )
        {
            FilterSum += m_pFilter[i];
            if( m_pFilter[i] < 0. )
            {
                m_bDoSampleClamp = true;
                break;
            }
        }
        if( ( FilterSum > 1.00001f ) || ( m_Bias != 0. ) || m_bExcludeAlpha )
        {
            m_bDoSampleClamp = true;
        }

        //--- Create lookup tables
        delete[] m_pPMCoeffLUT;
        m_pPMCoeffLUT = new long[UniqueCnt*256];

        if( !m_pPMCoeffLUT )
        {
            hr = E_OUTOFMEMORY;
        }

        //--- Init table values with 16 bit signed fixed point values
        if( SUCCEEDED( hr ) )
        {
            long* pVal = m_pPMCoeffLUT;
            for( i = 0; i < UniqueCnt; ++i )
            {
                float Coeff = TableCoefficient[i] * ( 1L << 16 );

                for( ULONG j = 0; j < 256; ++j, ++pVal )
                {
                    *pVal = (long)(j * Coeff);
                }
            }
        }
    }

    if( SUCCEEDED( hr ) )
    {
        _DetermineUnpackCase();
    }

    return hr;
} /* CDXConvolution::_BuildFilterLUTs */


//
//=== Work Procedures ========================================================
//  FROM THIS POINT ON, OPTIMIZE FOR SPEED.  PUT ALL CODE THAT IS NON-SPEED
//  SENSITIVE ABOVE THIS LINE 
#if DBG != 1
#pragma optimize("agt", on)
#endif


/*****************************************************************************
* WorkProc *
*----------*
*   Description:
*       This function performs the convolution with the current filter.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                 Date: 05/08/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXConvolution::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    DXTDBG_FUNC( "CDXConvolution::WorkProc" );
    HRESULT hr = S_OK;

    //=== Special case where the filter was too small
    if( m_bDoSrcCopyOnly )
    {
        hr = DXBitBlt( OutputSurface(), WI.OutputBnds, InputSurface(), WI.DoBnds,
                       m_dwBltFlags, 10000 );
        return hr;
    }
    else if( m_bIsBoxFilter )
    {
        hr = _DoBoxFilter( WI, pbContinue );
        return hr; 
    }

    ULONG DoBndsWid = WI.DoBnds.Width();
    ULONG DoBndsHgt = WI.DoBnds.Height();

    //=== General convolution case. The filter will be at least 2x2
    //--- Get input sample access pointer. Since we are doing arbitrary
    //    mapping, we'll put a read lock on the whole input to simplify logic.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadPtr> cpIn;
    hr = m_cpMarginedSurf->LockSurface( NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                        IID_IDXARGBReadPtr, (void**)&cpIn, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Put a write lock only on the region we are updating so multiple
    //    threads don't conflict.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadWritePtr> cpOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                        IID_IDXARGBReadWritePtr, (void**)&cpOut, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Get pointer to input samples
    cpIn->GetNativeType( &m_MarginedSurfInfo );

    //--- Allocate output unpacking buffer if necessary.
    //    We only need a scratch buffer if we're doing an over
    //    operation to a non-PMARGB32 surface
    BOOL bDirectCopy = FALSE;
    DXPMSAMPLE *pOutScratchBuff = NULL;
    DXNATIVETYPEINFO OutInfo;

    //--- We check the option flags directly because we are
    //    working from a different source
    if( m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT )
    {
        if( m_bNeedOutUnpackBuff )
        {
            pOutScratchBuff = DXPMSAMPLE_Alloca(DoBndsWid);
        }
    }
    else
    {
        if (!m_bNeedOutUnpackBuff && !m_bDoSampleClamp)
        {
            cpOut->GetNativeType(&OutInfo);
            bDirectCopy = (OutInfo.pFirstByte != NULL);
        }
    }

    //--- If we're doing a direct copy then compose directly into the output surface,
    //    otherwise allocate a new buffer.
    DXBASESAMPLE *pComposeBuff = (bDirectCopy)?((DXBASESAMPLE *)OutInfo.pFirstByte):
                                 (DXBASESAMPLE_Alloca( DoBndsWid ));

    //--- Set up the dither structure if needed.
    DXDITHERDESC dxdd;
    if( DoDither() ) 
    {
        //  We will never get here when doing a direct copy since we don't dither
        //  for 32-bit samples, so pCompose buff always points to a buffer.
        dxdd.pSamples = pComposeBuff;
        dxdd.cSamples = DoBndsWid;
        dxdd.x = WI.OutputBnds.Left();
        dxdd.y = WI.OutputBnds.Top();
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    //--- Create fixed point bias value
    long lBias = (long)(m_Bias * 255. * ( 1L << 16 ));

    //--- Process each output row
    //    Note: Output coordinates are relative to the lock region
    DXBASESAMPLE* pInSamp = (DXBASESAMPLE*)(m_MarginedSurfInfo.pFirstByte
                                            + ((WI.DoBnds.Top() /*-  m_DoBndsBaseRow*/)
                                               * m_MarginedSurfInfo.lPitch)
                                            + (WI.DoBnds.Left() * sizeof(DXBASESAMPLE)));
    /*
    DXBASESAMPLE* pInSamp = (DXBASESAMPLE*)(m_MarginedSurfInfo.pFirstByte +
                                            ( ( WI.DoBnds.Top() - m_DoBndsBaseRow ) *
                                                m_MarginedSurfInfo.lPitch));
    */

    ULONG i, j, k, FiltWid = m_FilterSize.cx, FiltHgt = m_FilterSize.cy;

    //--- Number of DWORD to add to the input sample pointer to get to
    //    the alpha value at the center of the kernel
    ULONG ulAlphaOffset = ((FiltHgt / 2) * ( m_MarginedSurfInfo.lPitch /
                             sizeof( DXBASESAMPLE ))) + ( FiltWid / 2 );

    for( ULONG OutY = 0; *pbContinue && ( OutY < DoBndsHgt ); ++OutY )
    {
        if( m_bDoSampleClamp )
        {
            //--- Sample each point along the row with clamping
            if( m_bExcludeAlpha )
            {
                for( i = 0; i < DoBndsWid; ++i )
                {
                    DXBASESAMPLE* pCellStart = pInSamp + i;
                    long R = 0, G = 0, B = 0, lFilterLUTIndex = 0;

                    for( j = 0; j < FiltHgt; ++j )
                    {
                        for( k = 0; k < FiltWid; ++k, ++lFilterLUTIndex )
                        {
                            if( pCellStart[k].Alpha )
                            {
                                long* Table = m_pPMCoeffLUT +
                                                (m_pFilterLUTIndexes[lFilterLUTIndex] << 8);
                                R += Table[pCellStart[k].Red];
                                G += Table[pCellStart[k].Green];
                                B += Table[pCellStart[k].Blue];
                            }
                        }
                        pCellStart = (DXBASESAMPLE*)(((BYTE*)pCellStart) + m_MarginedSurfInfo.lPitch);
                    }

                    //--- Drop fractional component, clamp, and store
                    pComposeBuff[i].Alpha = pInSamp[ulAlphaOffset + i].Alpha;
                    pComposeBuff[i].Red   = ShiftAndClampChannelVal( R + lBias );
                    pComposeBuff[i].Green = ShiftAndClampChannelVal( G + lBias );
                    pComposeBuff[i].Blue  = ShiftAndClampChannelVal( B + lBias );
                }
            }
            else
            {
                for( i = 0; i < DoBndsWid; ++i )
                {
                    DXBASESAMPLE* pCellStart = pInSamp + i;
                    long R = 0, G = 0, B = 0, A = 0, lFilterLUTIndex = 0;

                    for( j = 0; j < FiltHgt; ++j )
                    {
                        for( k = 0; k < FiltWid; ++k, ++lFilterLUTIndex )
                        {
                            int Alpha = pCellStart[k].Alpha;
                            if( Alpha )
                            {
                                long* Table = m_pPMCoeffLUT +
                                                (m_pFilterLUTIndexes[lFilterLUTIndex] << 8);
                                R += Table[pCellStart[k].Red];
                                G += Table[pCellStart[k].Green];
                                B += Table[pCellStart[k].Blue];
                                A += Table[Alpha];
                            }
                        }
                        pCellStart = (DXBASESAMPLE*)(((BYTE*)pCellStart) + m_MarginedSurfInfo.lPitch);
                    }

                    //--- Drop fractional component, clamp, and store
                    pComposeBuff[i].Alpha = ShiftAndClampChannelVal( A );
                    pComposeBuff[i].Red   = ShiftAndClampChannelVal( R + lBias );
                    pComposeBuff[i].Green = ShiftAndClampChannelVal( G + lBias );
                    pComposeBuff[i].Blue  = ShiftAndClampChannelVal( B + lBias );
                }
            }

            if( m_bOutUnpackPremult )
            {
                //--- Premult if we are doing an over or the output is premult
                DXPreMultArray( (DXSAMPLE*)pComposeBuff, DoBndsWid );
            }
        }
        else
        {
            //--- Sample each point along the row without clamping
            for( i = 0; i < DoBndsWid; ++i )
            {
                DXBASESAMPLE* pCellStart = pInSamp + i;
                long R = 0, G = 0, B = 0, A = 0, lFilterLUTIndex = 0;

                for( j = 0; j < FiltHgt; ++j )
                {
                    for( k = 0; k < FiltWid; ++k, ++lFilterLUTIndex )
                    {
                        int Alpha = pCellStart[k].Alpha;
                        if( Alpha )
                        {
                            long* Table = m_pPMCoeffLUT +
                                            (m_pFilterLUTIndexes[lFilterLUTIndex] << 8);
                            R += Table[pCellStart[k].Red];
                            G += Table[pCellStart[k].Green];
                            B += Table[pCellStart[k].Blue];
                            A += Table[Alpha];
                        }
                    }
                    pCellStart = (DXBASESAMPLE*)(((BYTE*)pCellStart) + m_MarginedSurfInfo.lPitch);
                }

                //--- Drop fractional component, recombine, and store
                pComposeBuff[i] = ((A & 0x00FF0000) << 8) | (R & 0x00FF0000) |
                                  ((G & 0x00FF0000) >> 8) | (B >> 16);
            }
        }

        //--- Point to next row of input samples
        pInSamp = (DXBASESAMPLE*)(((BYTE*)pInSamp) + m_MarginedSurfInfo.lPitch);

        //--- Output
        if( bDirectCopy )
        {
            //--- Just move pointer to the next row
            pComposeBuff = (DXBASESAMPLE *)(((BYTE *)pComposeBuff) + OutInfo.lPitch);
        }
        else
        {
            if( DoDither() )
            {
                DXDitherArray( &dxdd );
                dxdd.y++;
            }

            cpOut->MoveToRow( OutY );
            if( m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT )
            {
                cpOut->OverArrayAndMove( pOutScratchBuff, (DXPMSAMPLE *)pComposeBuff, DoBndsWid);
            } 
            else
            {
                if( m_bOutUnpackPremult )
                {
                    cpOut->PackPremultAndMove( (DXPMSAMPLE*)pComposeBuff, DoBndsWid );
                }
                else
                {
                    cpOut->PackAndMove( (DXSAMPLE*)pComposeBuff, DoBndsWid );
                }
            }
        }
    } // End main row loop

    return hr;
} /* CDXConvolution::WorkProc */


/*****************************************************************************
* CDXConvolution::_DoBoxFilter *
*------------------------------*
*   Description:
*       This function performs the convolution with a box filter of the current
*   size. This is an optimized case inteneded for animation.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                 Date: 06/11/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXConvolution::_DoBoxFilter( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{
    DXTDBG_FUNC( "CDXConvolution::_DoBoxFilter" );
    HRESULT hr = S_OK;
    ULONG DoBndsWid = WI.DoBnds.Width();
    ULONG DoBndsHgt = WI.DoBnds.Height();

    //=== General convolution case. The filter will be at least 2x2
    //--- Get input sample access pointer. Since we are doing arbitrary
    //    mapping, we'll put a read lock on the whole input to simplify logic.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadPtr> cpIn;
    hr = m_cpMarginedSurf->LockSurface( NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                        IID_IDXARGBReadPtr, (void**)&cpIn, NULL );

    if (FAILED(hr))
    {
        return hr;
    }

    //--- Put a write lock only on the region we are updating so multiple
    //    threads don't conflict.
    //    Note: Lock may fail due to a lost surface.
    CComPtr<IDXARGBReadWritePtr> cpOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                        IID_IDXARGBReadWritePtr, (void**)&cpOut, NULL );

    if (FAILED(hr))
    {
        return hr;
    }

    //--- Get pointer to input samples
    cpIn->GetNativeType( &m_MarginedSurfInfo );

    //--- Allocate output unpacking buffer if necessary.
    //    We only need a scratch buffer if we're doing an over
    //    operation to a non-PMARGB32 surface
    BOOL bDirectCopy = FALSE;
    DXPMSAMPLE *pOutScratchBuff = NULL;
    DXNATIVETYPEINFO OutInfo;

    //--- We check the option flags directly because we are
    //    working from a different source
    if( m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT )
    {
        if( m_bNeedOutUnpackBuff )
        {
            pOutScratchBuff = DXPMSAMPLE_Alloca(DoBndsWid);
        }
    }
    else
    {
        if( !m_bNeedOutUnpackBuff )
        {
            cpOut->GetNativeType(&OutInfo);
            bDirectCopy = (OutInfo.pFirstByte != NULL);
        }
    }

    //--- If we're doing a direct copy then compose directly into the output surface,
    //    otherwise allocate a new buffer.
    DXBASESAMPLE *pComposeBuff = (bDirectCopy)?((DXBASESAMPLE *)OutInfo.pFirstByte):
                                 (DXBASESAMPLE_Alloca( DoBndsWid ));

    //--- Set up the dither structure if needed.
    DXDITHERDESC dxdd;
    if( DoDither() ) 
    {
        //  We will never get here when doing a direct copy since we don't dither
        //  for 32-bit samples, so pCompose buff always points to a buffer.
        dxdd.pSamples       = pComposeBuff;
        dxdd.cSamples       = DoBndsWid;
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    //--- Process each output row
    //    Note: Output coordinates are relative to the lock region
    DXBASESAMPLE* pInSamp = (DXBASESAMPLE*)(m_MarginedSurfInfo.pFirstByte
                                            + ((WI.DoBnds.Top() /*-  m_DoBndsBaseRow*/)
                                               * m_MarginedSurfInfo.lPitch)
                                            + (WI.DoBnds.Left() * sizeof(DXBASESAMPLE)));

    ULONG   i       = 0;
    ULONG   j       = 0;
    ULONG   k       = 0;
    ULONG   FiltWid = m_FilterSize.cx;
    ULONG   FiltHgt = m_FilterSize.cy;
    long    InitR   = 0;
    long    InitG   = 0;
    long    InitB   = 0;
    long    InitA   = 0;

    // Compute the initial sum and assign.

    DXBASESAMPLE * pInitCellStart   = pInSamp;
    long RowSampPitch               = m_MarginedSurfInfo.lPitch 
                                      / sizeof(DXBASESAMPLE);

    for( j = 0; j < FiltHgt; ++j )
    {
        for( k = 0; k < FiltWid; ++k )
        {
            int Alpha = pInitCellStart[k].Alpha;
            if( Alpha )
            {
                InitR += m_pPMCoeffLUT[pInitCellStart[k].Red];
                InitG += m_pPMCoeffLUT[pInitCellStart[k].Green];
                InitB += m_pPMCoeffLUT[pInitCellStart[k].Blue];
                InitA += m_pPMCoeffLUT[Alpha];
            }
        }
        pInitCellStart += RowSampPitch;
    }

    //--- Compute the rest of the samples based on deltas
    ULONG BottomOffset = FiltHgt * RowSampPitch;

    for( ULONG OutY = 0; *pbContinue && ( OutY < DoBndsHgt ); ++OutY )
    {
        long    R = InitR;
        long    G = InitG;
        long    B = InitB;
        long    A = InitA;

        for (i = 0 ; i < DoBndsWid ; ++i)
        {
            //--- Drop fractional component, recombine, and store
            pComposeBuff[i] = ((A & 0x00FF0000) << 8) | (R & 0x00FF0000) |
                              ((G & 0x00FF0000) >> 8) | (B >> 16);

            //--- Move the kernel sum right by subtracting off
            //    the left edge and adding the right
            DXBASESAMPLE* pCellStart = pInSamp + i;
            for( j = 0; j < FiltHgt; ++j )
            {
                R -= m_pPMCoeffLUT[pCellStart->Red];
                G -= m_pPMCoeffLUT[pCellStart->Green];
                B -= m_pPMCoeffLUT[pCellStart->Blue];
                A -= m_pPMCoeffLUT[pCellStart->Alpha];
                R += m_pPMCoeffLUT[pCellStart[FiltWid].Red];
                G += m_pPMCoeffLUT[pCellStart[FiltWid].Green];
                B += m_pPMCoeffLUT[pCellStart[FiltWid].Blue];
                A += m_pPMCoeffLUT[pCellStart[FiltWid].Alpha];
                pCellStart += RowSampPitch;
            }
        }

        //--- Subtract off the current top row of the kernel from the running sum
        //    And add on the new bottom row to the running sum
        for (j = 0 ; j < FiltWid ; ++j)
        {
            InitR -= m_pPMCoeffLUT[pInSamp[j].Red];
            InitG -= m_pPMCoeffLUT[pInSamp[j].Green];
            InitB -= m_pPMCoeffLUT[pInSamp[j].Blue];
            InitA -= m_pPMCoeffLUT[pInSamp[j].Alpha];

            InitR += m_pPMCoeffLUT[pInSamp[BottomOffset+j].Red];
            InitG += m_pPMCoeffLUT[pInSamp[BottomOffset+j].Green];
            InitB += m_pPMCoeffLUT[pInSamp[BottomOffset+j].Blue];
            InitA += m_pPMCoeffLUT[pInSamp[BottomOffset+j].Alpha];
        }

        //--- Point to next row of input samples
        pInSamp += RowSampPitch;

        //=== Output the result of the last row ====================================
        if( bDirectCopy )
        {
            //--- Just move pointer to the next row
            pComposeBuff = (DXBASESAMPLE *)(((BYTE *)pComposeBuff) + OutInfo.lPitch);
        }
        else
        {
            if( DoDither() )
            {
                DXDitherArray( &dxdd );
                dxdd.y++;
            }

            cpOut->MoveToRow(OutY);

            if (m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT)
            {
                cpOut->OverArrayAndMove(pOutScratchBuff, (DXPMSAMPLE *)pComposeBuff, DoBndsWid);
            } 
            else
            {
                if (m_bOutUnpackPremult)
                {
                    cpOut->PackPremultAndMove((DXPMSAMPLE *)pComposeBuff, DoBndsWid);
                }
                else
                {
                    cpOut->PackAndMove((DXSAMPLE *)pComposeBuff, DoBndsWid);
                }
            }
        }
    } // End main row loop

    return hr;
} /* CDXConvolution::_DoBoxFilter */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\convolve.h ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998-2000
//
//  FileName:   convolve.h
//
//  Overview:   The CDXConvolution transform.  This transform performs a 
//              convolution using the currently defined filter.
//             
//  Change History:
//  1997/07/27  edc         Created.
//  2000/02/08  mcalkins    Fixed partial redraw cases.
//
//------------------------------------------------------------------------------
#ifndef __CONVOLVE_H_
#define __CONVOLVE_H_

#include "resource.h"




class ATL_NO_VTABLE CDXConvolution : 
    public CDXBaseNTo1,
    public CComCoClass<CDXConvolution, &CLSID_DXTConvolution>,
    public IDXTConvolution
{
private:

    CComPtr<IUnknown> m_spUnkMarshaler;

    //--- Filter vars
    DXCONVFILTERTYPE    m_FilterType;
    SIZE                m_FilterSize;
    SIZE                m_OutputSpread;
    RECT                m_FilterMargins;
    float*              m_pCustomFilter;
    float*              m_pFilter;
    ULONG*              m_pFilterLUTIndexes;
    long*               m_pPMCoeffLUT;
    float               m_Bias;

    //--- Cacheing vars
    CComPtr<IDXSurface> m_cpMarginedSurf;
    DXNATIVETYPEINFO    m_MarginedSurfInfo;
    SIZE                m_MarginedSurfSize;
    CDXDBnds            m_InputSurfBnds;
    BOOL                m_bConvertToGray;
    BOOL                m_bMarginedIsPremult;

    //--- processing vars
    BOOL                m_bDoSampleClamp;
    CDXDBnds            m_LastDoBnds;
    long                m_DoBndsBaseRow;
    BOOL                m_bDoSrcCopyOnly;
    BOOL                m_bExcludeAlpha;
    BOOL                m_bIsBoxFilter;

public:

    DECLARE_POLY_AGGREGATABLE(CDXConvolution)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_DXTCONVOLUTION)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXConvolution)
        COM_INTERFACE_ENTRY(IDXTConvolution)
    	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BYTE m_bInUnpackPremult;
    BYTE m_bOutUnpackPremult;
    BYTE m_bNeedInUnpackBuff;
    BYTE m_bNeedOutUnpackBuff;

    //--- Constructors
    HRESULT FinalConstruct();
    void    FinalRelease();

    //--- Base class overrides
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT WorkProc(const CDXTWorkInfoNTo1& WI, BOOL* pbContinue);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1& WI, ULONG& ulNB);

    //--- Helper functions
    HRESULT _DoBoxFilter(const CDXTWorkInfoNTo1& WI, BOOL* pbContinue);
    HRESULT _BuildFilterLUTs(void);
    HRESULT _ConvertToGray(CDXDBnds& Bnds);
    void    _DetermineUnpackCase(void);
    HRESULT _SetToPremultiplied(BOOL bWantPremult);

    // IDXTransform methods.

    STDMETHOD(MapBoundsIn2Out)(const DXBNDS * pInBounds, ULONG ulNumInBnds,
                               ULONG ulOutIndex, DXBNDS * pOutBounds);
    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTConvolution methods.

    STDMETHOD(SetFilterType)(DXCONVFILTERTYPE eType);
    STDMETHOD(GetFilterType)(DXCONVFILTERTYPE * peType);
    STDMETHOD(SetCustomFilter)(float * pFilter, SIZE Size);
    STDMETHOD(SetConvertToGray)(BOOL bConvertToGray);
    STDMETHOD(GetConvertToGray)(BOOL * pbConvertToGray);
    STDMETHOD(SetBias)(float Bias);
    STDMETHOD(GetBias)(float * pBias);
    STDMETHOD(SetExcludeAlpha)(BOOL bExcludeAlpha);
    STDMETHOD(GetExcludeAlpha)(BOOL * pbExcludeAlpha);
};


//=== Inline Function Definitions ==================================
inline STDMETHODIMP CDXConvolution::SetBias(float Bias)
{
    HRESULT hr = S_OK;
    if ((Bias < -1.) || (Bias > 1.))
    {
        hr = E_INVALIDARG;
    }
    else if (m_Bias != Bias)
    {
        m_Bias = Bias;
        SetDirty();
    }
    return hr;
}

inline STDMETHODIMP CDXConvolution::GetBias(float* pBias)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pBias, sizeof(*pBias)))
    {
        hr = E_POINTER;
    }
    else
    {
        *pBias = m_Bias;
    }
    return hr;
} /* CDXConvolution::GetBias */

inline STDMETHODIMP CDXConvolution::SetConvertToGray(BOOL bConvertToGray)
{
    if (m_bConvertToGray != bConvertToGray)
    {
        m_bConvertToGray = bConvertToGray;
        SetDirty();
    }
    return S_OK;
} /* CDXConvolution::SetConvertToGray */

inline STDMETHODIMP CDXConvolution::GetConvertToGray(BOOL* pbConvertToGray)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pbConvertToGray, sizeof(*pbConvertToGray)))
    {
        hr = E_POINTER;
    }
    else
    {
        *pbConvertToGray = m_bConvertToGray;
    }
    return hr;
} /* CDXConvolution::GetConvertToGray */

inline STDMETHODIMP CDXConvolution::SetExcludeAlpha(BOOL bExcludeAlpha)
{
    if (m_bExcludeAlpha != bExcludeAlpha)
    {
        m_bExcludeAlpha = bExcludeAlpha;
        if (!m_bDoSrcCopyOnly)
        {
            _BuildFilterLUTs();
        }
        SetDirty();
    }
    return S_OK;
} /* CDXConvolution::SetExcludeAlpha */

inline STDMETHODIMP CDXConvolution::GetExcludeAlpha(BOOL* pbExcludeAlpha)
{
    HRESULT hr = S_OK;
    if (DXIsBadWritePtr(pbExcludeAlpha, sizeof(*pbExcludeAlpha)))
    {
        hr = E_POINTER;
    }
    else
    {
        *pbExcludeAlpha = m_bExcludeAlpha;
    }
    return hr;
} /* CDXConvolution::GetExcludeAlpha */

inline BYTE ShiftAndClampChannelVal(long Value)
{
    Value >>= 16;

    if (Value > 255)
    {
        return 255;
    }
    else if (Value < 0)
    {
        return 0;
    }
    else
    {
        return (BYTE)Value;
    }
}


#endif // __CONVOLVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\crblur.cpp ===
/*******************************************************************************
* CrBlur.cpp *
*------------*
*   Description:
*      This module contains the CCrBlur transform implemenation.
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 05/10/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "CrBlur.h"

//--- Local data

/*****************************************************************************
* CCrBlur::FinalConstruct *
*-------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrBlur::FinalConstruct()
{
    DXTDBG_FUNC( "CCrBlur::FinalConstruct" );
    HRESULT hr = S_OK;

    //--- Member data
    m_bSetupSucceeded   = false;
    m_bMakeShadow       = false;
    m_ShadowOpacity     = .75;
    m_PixelRadius       = 2.0;
    m_PixelRadius       = 2.0;
    m_pConvolutionTrans = NULL;
    m_pConvolution      = NULL;

    //--- Create inner convolution
    IUnknown* punkCtrl = GetControllingUnknown();
    hr = ::CoCreateInstance( CLSID_DXTConvolution, punkCtrl, CLSCTX_INPROC,
                             IID_IUnknown, (void **)&m_cpunkConvolution );

    if( SUCCEEDED( hr ) )
    {
        hr = m_cpunkConvolution->
                QueryInterface( IID_IDXTransform, (void **)&m_pConvolutionTrans );
        if( SUCCEEDED( hr ) )
        {
            //--- Getting an interface from the inner causes the outer to be addref'ed
            //    aggregation rules state that we need to release the outer.
            punkCtrl->Release();

            hr = m_cpunkConvolution->QueryInterface( IID_IDXTConvolution, (void **)&m_pConvolution );
            if( SUCCEEDED( hr ) )
            {
                punkCtrl->Release();
            }
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = put_PixelRadius( m_PixelRadius );
    }

    //--- Create the surface modifier and lookup
    if( SUCCEEDED( hr ) )
    {
        hr = ::CoCreateInstance( CLSID_DXSurfaceModifier, NULL, CLSCTX_INPROC,
                                 IID_IDXSurfaceModifier, (void **)&m_cpInSurfMod );

        if( SUCCEEDED( hr ) )
        {
            m_cpInSurfMod->QueryInterface( IID_IDXSurface, (void**)&m_cpInSurfModSurf );

            hr = ::CoCreateInstance( CLSID_DXLUTBuilder, NULL, CLSCTX_INPROC,
                                     IID_IDXLUTBuilder, (void **)&m_cpLUTBldr );
        }

        if( SUCCEEDED( hr ) )
        {
            //--- Set the threshold for shadows
            static OPIDDXLUTBUILDER OpOrder[] = { OPID_DXLUTBUILDER_Threshold,
                                                  OPID_DXLUTBUILDER_Opacity,
                                                };
            m_cpLUTBldr->SetThreshold( 1.1f );
            m_cpLUTBldr->SetOpacity( m_ShadowOpacity );
            m_cpLUTBldr->SetBuildOrder( OpOrder, 2 );

            //--- Associate objects
            CComPtr<IDXLookupTable> cpLUT;
            m_cpLUTBldr->QueryInterface( IID_IDXLookupTable, (void**)&cpLUT );
            if( SUCCEEDED( hr ) )
            {
                hr = m_cpInSurfMod->SetLookup( cpLUT );
            }
        }
    }

    return hr;
} /* CCrBlur::FinalConstruct */

/*****************************************************************************
* CCrBlur::FinalRelease *
*-----------------------*
*   Description:
*       The inner interfaces are released using COM aggregation rules. Releasing
*   the inner causes the outer to be released, so we addref the outer prior to
*   protect it.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrBlur::FinalRelease()
{
    DXTDBG_FUNC( "CCrBlur::FinalRelease" );
    HRESULT hr = S_OK;

    //--- Safely free the inner interfaces held
    IUnknown* punkCtrl = GetControllingUnknown();
    if( m_pConvolutionTrans )
    {
        punkCtrl->AddRef();
        m_pConvolutionTrans->Release();
    }

    if( m_pConvolution )
    {
        punkCtrl->AddRef();
        m_pConvolution->Release();
    }

    return hr;
} /* CCrBlur::FinalRelease */

/*****************************************************************************
* CCrBlur::Setup *
*----------------*
*   Description:
*       This method is used to create the surface modifier, lookup table builder,
*   and convolution transform.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CCrBlur::Setup( IUnknown * const * punkInputs, ULONG ulNumIn,
                             IUnknown * const * punkOutputs, ULONG ulNumOut,
                             DWORD dwFlags )
{
    DXTDBG_FUNC( "CCrBlur::Setup" );
    HRESULT hr = S_OK;

    //--- Check for unsetup case
    if( ( ulNumIn == 0 ) && ( ulNumOut == 0 ) )
    {
        m_cpInputSurface.Release();
        m_cpOutputSurface.Release();
        if( m_pConvolutionTrans )
        {
            hr = m_pConvolutionTrans->Setup( NULL, 0, NULL, 0, 0 );
        }
        return hr;
    }

    //--- Validate the input ( the convolution setup will validate the rest )
    if( ( ulNumIn != 1 ) || ( ulNumOut != 1 ) ||
         DXIsBadReadPtr( punkInputs, sizeof( *punkInputs ) ) ||
         DXIsBadInterfacePtr( punkInputs[0] ) ||
         DXIsBadReadPtr( punkOutputs, sizeof( *punkOutputs ) ) ||
         DXIsBadInterfacePtr( punkOutputs[0] ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Save for later
        m_dwSetupFlags = dwFlags;
        m_cpOutputSurface = punkOutputs[0];

        //--- Get a DXSurface for the input
        m_cpInputSurface.Release();
        hr = punkInputs[0]->QueryInterface( IID_IDXSurface, (void**)&m_cpInputSurface );

        if( FAILED( hr ) )
        {
            IDirectDrawSurface* pDDSurf;
            hr = punkInputs[0]->QueryInterface( IID_IDirectDrawSurface, (void**)&pDDSurf );
            if( FAILED( hr ) )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                CComPtr<IObjectWithSite>    spObjectWithSite;
                CComPtr<IServiceProvider>   spServiceProvider;
                CComPtr<IDXSurfaceFactory>  spDXSurfaceFactory;

                hr = m_pConvolution->QueryInterface(__uuidof(IObjectWithSite),
                                                    (void **)&spObjectWithSite);

                if (SUCCEEDED(hr))
                {
                    hr = spObjectWithSite->GetSite(__uuidof(IServiceProvider), 
                                                   (void **)&spServiceProvider);
                }

                if (SUCCEEDED(hr))
                {
                    hr = spServiceProvider->QueryService(SID_SDXSurfaceFactory,
                                                         __uuidof(IDXSurfaceFactory),
                                                         (void **)&spDXSurfaceFactory);
                }

                if (SUCCEEDED(hr))
                {
                    //--- Create a DXSurface from the DDraw surface
                    hr = spDXSurfaceFactory->CreateFromDDSurface(
                                                    pDDSurf, NULL, 0, NULL, 
                                                    IID_IDXSurface,
                                                    (void **)&m_cpInputSurface);
                }
                else
                {
                    hr = DXTERR_UNINITIALIZED;
                }
            }
        }

        //--- Setup the convolution
        if( SUCCEEDED( hr ) )
        {
            //--- Attach the new input to the surface modifier
            hr = m_cpInSurfMod->SetForeground( m_cpInputSurface, false, NULL );
            if( SUCCEEDED( hr ) )
            {
                hr = _DoShadowSetup();
            }
        }
    }

    return hr;
} /* CCrBlur::Setup */

/*****************************************************************************
* CCrBlur::_SetPixelRadius *
*--------------------------*
*   Description:
*       This method 
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrBlur::put_PixelRadius( float PixelRadius )
{
    DXTDBG_FUNC( "CCrBlur::put_PixelRadius" );
    HRESULT hr = S_OK;

    if( ( PixelRadius < 0 ) || ( PixelRadius > 100. ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // We allow the user to enter a pixelradius of 0 since intuitively,
        // they think zero means "off", but really 0.5 means off.  So since
        // we need a kernel of at least 1 pixel, we bump up to 0.5 radius here.
        if (PixelRadius < 0.5)
            PixelRadius = 0.5;

        m_PixelRadius = PixelRadius;
        SIZE Size;
        Size.cy = Size.cx = (long)(2 * m_PixelRadius);
        int nPRSQ = Size.cy * Size.cx;
        float fPRSQ = 1.f/(float)nPRSQ;
        float* pFilt = (float*)alloca( nPRSQ * sizeof( float ) );
        for( int i = 0; i < nPRSQ; ++i ) pFilt[i] = fPRSQ;
        return m_pConvolution->SetCustomFilter( pFilt, Size );
    }
    return hr;
} /* CCrBlur::put_PixelRadius */

/*****************************************************************************
* CCrBlur::get_PixelRadius *
*--------------------------*
*   Description:
*       This method sets the value of the pixel radius when IDXEffect percent
*   complete is equal to one.
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 06/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CCrBlur::get_PixelRadius( float *pPixelRadius )
{
    DXTDBG_FUNC( "CCrBlur::get_PixelRadius" );
    if( DXIsBadWritePtr( pPixelRadius, sizeof( *pPixelRadius ) ) )
    {
        return E_POINTER;
    }
    else
    {
        *pPixelRadius = m_PixelRadius;
        return S_OK;
    }
} /* CCrBlur::get_PixelRadius */

/*****************************************************************************
* CCrBlur::get_MakeShadow *
*-------------------------*
*   Description:
*       This method 
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CCrBlur::get_MakeShadow( VARIANT_BOOL *pVal )
{
    DXTDBG_FUNC( "CCrBlur::get_MakeShadow" );
    if( DXIsBadWritePtr( pVal, sizeof( *pVal ) ) )
    {
        return E_POINTER;
    }
    else
    {
        *pVal = m_bMakeShadow;
        return S_OK;
    }
} /* CCrBlur::get_MakeShadow */

/*****************************************************************************
* CCrBlur::get_MakeShadow *
*-------------------------*
*   Description:
*       This method 
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                                     Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
STDMETHODIMP CCrBlur::put_MakeShadow( VARIANT_BOOL newVal )
{
    DXTDBG_FUNC( "CCrBlur::put_MakeShadow" );
    HRESULT hr = S_OK;

    if( m_bMakeShadow != newVal )
    {
        m_bMakeShadow = newVal;
        if( m_bSetupSucceeded )
        {
            hr = _DoShadowSetup();
        }
    }
    return hr;
} /* CCrBlur::put_MakeShadow */

//
//=== CCrEmboss implementation ==============================================
//
/*****************************************************************************
* CCrEmboss::FinalConstruct *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 06/11/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrEmboss::FinalConstruct()
{
    DXTDBG_FUNC( "CCrEmboss::FinalConstruct" );
    HRESULT hr = S_OK;
    m_pConvolution = NULL;

    //--- Create inner convolution
    IUnknown* punkCtrl = GetControllingUnknown();
    hr = ::CoCreateInstance( CLSID_DXTConvolution, punkCtrl, CLSCTX_INPROC,
                             IID_IUnknown, (void **)&m_cpunkConvolution );

    if( SUCCEEDED( hr ) )
    {
        hr = m_cpunkConvolution->QueryInterface( IID_IDXTConvolution, (void **)&m_pConvolution );
        if( SUCCEEDED( hr ) )
        {
            punkCtrl->Release();
            hr = m_pConvolution->SetFilterType( DXCFILTER_EMBOSS );
            if( SUCCEEDED( hr ) )
            {
                hr = m_pConvolution->SetConvertToGray( true );
            }
        }
    }

    return hr;
} /* CCrEmboss::FinalConstruct */

/*****************************************************************************
* CCrEmboss::FinalRelease *
*-------------------------*
*   Description:
*       The inner interfaces are released using COM aggregation rules. Releasing
*   the inner causes the outer to be released, so we addref the outer prior to
*   protect it.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 06/11/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrEmboss::FinalRelease()
{
    DXTDBG_FUNC( "CCrEmboss::FinalRelease" );
    HRESULT hr = S_OK;

    //--- Safely free the inner interfaces held
    IUnknown* punkCtrl = GetControllingUnknown();
    if( m_pConvolution )
    {
        punkCtrl->AddRef();
        m_pConvolution->Release();
        m_pConvolution = NULL;
    }

    return hr;
} /* CCrEmboss::FinalRelease */

//
//=== CCrEngrave implementation ==============================================
//
/*****************************************************************************
* CCrEngrave::FinalConstruct *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 06/11/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrEngrave::FinalConstruct()
{
    DXTDBG_FUNC( "CCrEngrave::FinalConstruct" );
    HRESULT hr = S_OK;
    m_pConvolution = NULL;

    //--- Create inner convolution
    IUnknown* punkCtrl = GetControllingUnknown();
    hr = ::CoCreateInstance( CLSID_DXTConvolution, punkCtrl, CLSCTX_INPROC,
                             IID_IUnknown, (void **)&m_cpunkConvolution );

    if( SUCCEEDED( hr ) )
    {
        hr = m_cpunkConvolution->QueryInterface( IID_IDXTConvolution, (void **)&m_pConvolution );
        if( SUCCEEDED( hr ) )
        {
            punkCtrl->Release();
            hr = m_pConvolution->SetFilterType( DXCFILTER_ENGRAVE );
            if( SUCCEEDED( hr ) )
            {
                hr = m_pConvolution->SetConvertToGray( true );
            }
        }
    }

    return hr;
} /* CCrEngrave::FinalConstruct */

/*****************************************************************************
* CCrEngrave::FinalRelease *
*--------------------------*
*   Description:
*       The inner interfaces are released using COM aggregation rules. Releasing
*   the inner causes the outer to be released, so we addref the outer prior to
*   protect it.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 06/11/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CCrEngrave::FinalRelease()
{
    DXTDBG_FUNC( "CCrEngrave::FinalRelease" );
    HRESULT hr = S_OK;

    //--- Safely free the inner interfaces held
    IUnknown* punkCtrl = GetControllingUnknown();
    if( m_pConvolution )
    {
        punkCtrl->AddRef();
        m_pConvolution->Release();
        m_pConvolution = NULL;
    }

    return hr;
} /* CCrEngrave::FinalRelease */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\composit.h ===
/*******************************************************************************
* Composit.h *
*------------*
*   Description:
*       This is the header file for the CDXTComposite implementation.
*-------------------------------------------------------------------------------
*  Created By: Ed Connell                            Date: 07/27/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef Composit_h
#define Composit_h

//--- Additional includes
#ifndef DTBase_h
#include <DTBase.h>
#endif

#include "resource.h"

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================
class CDXTComposite;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CDXTComposite
*	This transform performs a copy blend operation. The
*	caller specifies the blend function to be performed. The default is
*   a standard A over B operation.
*/
class ATL_NO_VTABLE CDXTComposite : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTComposite, &CLSID_DXTComposite>,
    public IDispatchImpl<IDXTComposite, &IID_IDXTComposite, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTComposite>,
    public IObjectSafetyImpl2<CDXTComposite>,
    public IPersistStorageImpl<CDXTComposite>,
    public ISpecifyPropertyPagesImpl<CDXTComposite>,
    public IPersistPropertyBagImpl<CDXTComposite>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_POLY_AGGREGATABLE(CDXTComposite)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_DXTCOMPOSITE)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTComposite)
        COM_INTERFACE_ENTRY(IDXTComposite)
        COM_INTERFACE_ENTRY(IDispatch)
    	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p )
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTComposite>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN( CDXBaseNTo1 )
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTComposite)
        PROP_ENTRY("Function", DISPID_DXCOMPOSITE_Function, CLSID_CompositePP)
        PROP_PAGE(CLSID_CompositePP)
    END_PROPERTY_MAP()

  /*=== Member Data ===*/
    CComPtr<IUnknown> m_cpUnkMarshaler;
    DXCOMPFUNC        m_eFunction;

  /*=== Methods =======*/
  public:
    //--- Constructor
    HRESULT FinalConstruct();

    //--- Base class overrides
    HRESULT WorkProc( const CDXTWorkInfoNTo1& WorkInfo, BOOL * pbContinue );
    HRESULT OnSurfacePick( const CDXDBnds& OutPoint, ULONG& ulInputIndex, CDXDVec& InVec );

  public:
    //=== IDXTComposite ==================================================
    STDMETHOD( put_Function )( DXCOMPFUNC eFunc );
    STDMETHOD( get_Function )( DXCOMPFUNC *peFunc );
};

//=== Inline Function Definitions ==================================
inline STDMETHODIMP CDXTComposite::put_Function( DXCOMPFUNC eFunc )
{
    DXAUTO_OBJ_LOCK
    HRESULT hr = S_OK;
    if( eFunc < DXCOMPFUNC_CLEAR || eFunc >= DXCOMPFUNC_NUMFUNCS )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_eFunction = eFunc;
        SetDirty();
    }
    return hr;
} /* CDXTComposite::put_Function */

inline STDMETHODIMP CDXTComposite::get_Function( DXCOMPFUNC *peFunc )
{
    DXAUTO_OBJ_LOCK
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr( peFunc, sizeof( *peFunc ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *peFunc = m_eFunction;
    }
    return hr;
} /* CDXTComposite::get_Function */

//=== Macro Definitions ============================================


//=== Global Data Declarations =====================================

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\crblur.h ===
/*******************************************************************************
* CrBlur.h *
*----------*
*   Description:
*       This is the header file for the Chrome wrapper implementations.
*-------------------------------------------------------------------------------
*  Created By: Ed Connell                            Date: 07/27/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef CrBlur_h
#define CrBlur_h

//--- Additional includes
#ifndef DTBase_h
#include <DTBase.h>
#endif

#include "resource.h"

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================
class CCrBlur;
class CCrEmboss;
class CCrEngrave;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CCrBlur
*   This transform performs a blur using the DXConvolution transform.
*/
class ATL_NO_VTABLE CCrBlur : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CCrBlur, &CLSID_CrBlur>,
    public CComPropertySupport<CCrBlur>,
    public IDispatchImpl<ICrBlur, &IID_ICrBlur, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IDXTransform,
    public IPersistStorageImpl<CCrBlur>,
    public ISpecifyPropertyPagesImpl<CCrBlur>,
    public IPersistPropertyBagImpl<CCrBlur>,
    public IObjectSafetyImpl2<CCrBlur>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_CRBLUR)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CCrBlur)
        COM_INTERFACE_ENTRY(ICrBlur)
        COM_INTERFACE_ENTRY(IDXTransform)
        COM_INTERFACE_ENTRY(IDXBaseObject)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CCrBlur>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_AGGREGATE_BLIND( m_cpunkConvolution.p )
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CCrBlur)
        PROP_ENTRY("MakeShadow"    , DISPID_CRB_MakeShadow    , CLSID_CrBlurPP)
        PROP_ENTRY("ShadowOpacity" , DISPID_CRB_ShadowOpacity , CLSID_CrBlurPP)
        PROP_ENTRY("PixelRadius"   , DISPID_CRB_PixelRadius   , CLSID_CrBlurPP)
        PROP_PAGE(CLSID_CrBlurPP)
    END_PROPERTY_MAP()
    
  /*=== Member Data ===*/
  protected:
    CComPtr<IDXSurface>         m_cpInputSurface;
    CComPtr<IUnknown>           m_cpOutputSurface;
    CComPtr<IDXLUTBuilder>      m_cpLUTBldr;
    CComPtr<IDXSurfaceModifier> m_cpInSurfMod;
    CComPtr<IDXSurface>         m_cpInSurfModSurf;
    CComPtr<IUnknown>           m_cpunkConvolution;
    IDXTConvolution*            m_pConvolution;
    IDXTransform*               m_pConvolutionTrans;
    VARIANT_BOOL                m_bMakeShadow;
    float                       m_ShadowOpacity;
    float                       m_PixelRadius;
    DWORD                       m_dwSetupFlags;
    BOOL                        m_bSetupSucceeded;

  /*=== Methods =======*/
  public:
    /*--- Constructors ---*/
    HRESULT FinalConstruct();
    HRESULT FinalRelease();
    HRESULT _DoShadowSetup();

  public:
    //=== IDXBaseObject =========================================
    STDMETHOD( GetGenerationId ) (ULONG * pGenId);
    STDMETHOD( IncrementGenerationId) (BOOL bRefresh);
    STDMETHOD( GetObjectSize ) (ULONG * pcbSize); 

    //=== IDXTransform (These are all delegated to the convolution except Setup) ====
    STDMETHOD( Setup )( IUnknown * const * punkInputs, ULONG ulNumIn, IUnknown * const * punkOutputs, ULONG ulNumOut, DWORD dwFlags );
    STDMETHOD( Execute )( const GUID* pRequestID, const DXBNDS *pOutBounds, const DXVEC *pPlacement );
    STDMETHOD( MapBoundsIn2Out )( const DXBNDS *pInBounds, ULONG ulNumInBnds, ULONG ulOutIndex, DXBNDS *pOutBounds );
    STDMETHOD( MapBoundsOut2In )( ULONG ulOutIndex, const DXBNDS *pOutBounds, ULONG ulInIndex, DXBNDS *pInBounds );
    STDMETHOD( SetMiscFlags ) ( DWORD dwOptionFlags );
    STDMETHOD( GetMiscFlags ) ( DWORD * pdwMiscFlags );
    STDMETHOD( GetInOutInfo )( BOOL bOutput, ULONG ulIndex, DWORD *pdwFlags, GUID * pIDs, ULONG * pcIDs, IUnknown **ppUnkCurObj);
    STDMETHOD( SetQuality )( float fQuality );
    STDMETHOD( GetQuality )( float *pfQuality );

    //=== ICrBlur ======================================================
    STDMETHOD( get_MakeShadow )( VARIANT_BOOL *pVal );
    STDMETHOD( put_MakeShadow )( VARIANT_BOOL newVal );
    STDMETHOD( get_ShadowOpacity )( float *pVal );
    STDMETHOD( put_ShadowOpacity )( float newVal );
    STDMETHOD( get_PixelRadius )( float *pPixelRadius );
    STDMETHOD( put_PixelRadius )( float PixelRadius );
};

/*** CCrEmboss
*   This transform performs an embossing using the DXConvolution transform.
*/
class ATL_NO_VTABLE CCrEmboss : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CCrEmboss, &CLSID_CrEmboss>,
    public CComPropertySupport<CCrEmboss>,
    public IDispatchImpl<ICrEmboss, &IID_ICrEmboss, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IPersistStorageImpl<CCrEmboss>,
    public ISpecifyPropertyPagesImpl<CCrEmboss>,
    public IPersistPropertyBagImpl<CCrEmboss>,
    public IObjectSafetyImpl2<CCrEmboss>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_CREMBOSS)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CCrEmboss)
        COM_INTERFACE_ENTRY(ICrEmboss)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CCrEmboss>)
        COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_cpunkConvolution.p)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CCrEmboss)
        PROP_ENTRY("Bias", DISPID_CRB_MakeShadow, CLSID_NULL)
//        PROP_PAGE(CLSID_NULL)
    END_PROPERTY_MAP()

  /*=== Member Data ===*/
  protected:
    CComPtr<IUnknown>   m_cpunkConvolution;
    IDXTConvolution*    m_pConvolution;

  /*=== Methods =======*/
  public:
    /*--- Constructors ---*/
    HRESULT FinalConstruct();
    HRESULT FinalRelease();

    //=== ICrEmboss =================================================
    STDMETHOD( get_Bias )( float *pVal  ) { return m_pConvolution->GetBias( pVal ); }
    STDMETHOD( put_Bias )( float newVal ) { return m_pConvolution->SetBias( newVal ); }
};

/*** CCrEngrave
*   This transform performs an engraving using the DXConvolution transform.
*/
class ATL_NO_VTABLE CCrEngrave : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CCrEngrave, &CLSID_CrEngrave>,
    public CComPropertySupport<CCrEngrave>,
    public IDispatchImpl<ICrEngrave, &IID_ICrEngrave, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IPersistStorageImpl<CCrEngrave>,
    public ISpecifyPropertyPagesImpl<CCrEngrave>,
    public IPersistPropertyBagImpl<CCrEngrave>,
    public IObjectSafetyImpl2<CCrEngrave>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_CRENGRAVE)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CCrEngrave)
        COM_INTERFACE_ENTRY(ICrEngrave)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CCrEngrave>)
        COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_cpunkConvolution.p)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CCrEngrave)
        PROP_ENTRY("Bias", DISPID_CRB_MakeShadow, CLSID_NULL)
//        PROP_PAGE(CLSID_NULL)
    END_PROPERTY_MAP()

  /*=== Member Data ===*/
  protected:
    CComPtr<IUnknown>   m_cpunkConvolution;
    IDXTConvolution*    m_pConvolution;

  /*=== Methods =======*/
  public:
    /*--- Constructors ---*/
    HRESULT FinalConstruct();
    HRESULT FinalRelease();

    //=== ICrEngrave =================================================
    STDMETHOD( get_Bias )( float *pVal  ) { return m_pConvolution->GetBias( pVal ); }
    STDMETHOD( put_Bias )( float newVal ) { return m_pConvolution->SetBias( newVal ); }
};

//=== Inline Function Definitions ==================================
inline STDMETHODIMP CCrBlur::GetGenerationId( ULONG * pGenId )
{
    return m_pConvolutionTrans->GetGenerationId( pGenId );
}

inline STDMETHODIMP CCrBlur::IncrementGenerationId( BOOL bRefresh )
{
    return m_pConvolutionTrans->IncrementGenerationId( bRefresh );
}

inline STDMETHODIMP CCrBlur::GetObjectSize( ULONG * pcbSize )
{
    return m_pConvolutionTrans->GetObjectSize( pcbSize );
}

inline STDMETHODIMP CCrBlur::Execute( const GUID* pRequestID, const DXBNDS *pOutBounds, const DXVEC *pPlacement )
{
    return m_pConvolutionTrans->Execute( pRequestID, pOutBounds, pPlacement );
}

inline STDMETHODIMP CCrBlur::MapBoundsIn2Out( const DXBNDS *pInBounds, ULONG ulNumInBnds, ULONG ulOutIndex, DXBNDS *pOutBounds )
{
    return m_pConvolutionTrans->MapBoundsIn2Out( pInBounds, ulNumInBnds, ulOutIndex, pOutBounds );
}

inline STDMETHODIMP CCrBlur::MapBoundsOut2In( ULONG ulOutIndex, const DXBNDS *pOutBounds, ULONG ulInIndex, DXBNDS *pInBounds )
{
    return m_pConvolutionTrans->MapBoundsOut2In( ulOutIndex, pOutBounds, ulInIndex, pInBounds );
}

inline STDMETHODIMP CCrBlur::SetMiscFlags( DWORD dwOptionFlags )
{
    return m_pConvolutionTrans->SetMiscFlags( dwOptionFlags );
}

inline STDMETHODIMP CCrBlur::GetMiscFlags( DWORD * pdwMiscFlags )
{
    return m_pConvolutionTrans->GetMiscFlags( pdwMiscFlags );
}

inline STDMETHODIMP CCrBlur::GetInOutInfo( BOOL bOutput, ULONG ulIndex, DWORD *pdwFlags, GUID * pIDs, ULONG * pcIDs, IUnknown **ppUnkCurObj)
{
    return m_pConvolutionTrans->GetInOutInfo( bOutput, ulIndex, pdwFlags, pIDs, pcIDs, ppUnkCurObj );
}

inline STDMETHODIMP CCrBlur::SetQuality( float fQuality )
{
    return m_pConvolutionTrans->SetQuality( fQuality );
}

inline STDMETHODIMP CCrBlur::GetQuality( float *pfQuality )
{
    return m_pConvolutionTrans->GetQuality( pfQuality );
}

inline STDMETHODIMP CCrBlur::get_ShadowOpacity( float *pVal )
{
    HRESULT hr = S_OK;
    if( DXIsBadWritePtr( pVal, sizeof( *pVal ) ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_ShadowOpacity;
    }
    return hr;
}

inline STDMETHODIMP CCrBlur::put_ShadowOpacity( float newVal )
{
    HRESULT hr = S_OK;
    if( ( newVal < 0. ) || ( newVal > 1.0 ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_ShadowOpacity = newVal;
        hr = m_cpLUTBldr->SetOpacity( m_ShadowOpacity );
    }
    return hr;
}

inline HRESULT CCrBlur::_DoShadowSetup()
{
    HRESULT hr = S_OK;
    if( m_bMakeShadow )
    {
        //--- Indirect through the surface modifier to make a shadow
        hr = m_pConvolutionTrans->Setup( (IUnknown**)&m_cpInSurfModSurf.p, 1,
                                         (IUnknown**)&m_cpOutputSurface.p, 1,
                                          m_dwSetupFlags );
    }
    else
    {
        hr = m_pConvolutionTrans->Setup( (IUnknown**)&m_cpInputSurface.p, 1,
                                         (IUnknown**)&m_cpOutputSurface.p, 1,
                                          m_dwSetupFlags );
    }
    m_bSetupSucceeded = ( SUCCEEDED( hr ) )?(true):(false);

    return hr;
}

//=== Macro Definitions ============================================

//=== Global Data Declarations =====================================

//=== Function Prototypes ==========================================

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\composit.cpp ===
/*******************************************************************************
* Composit.cpp *
*--------------*
*   Description:
*    This module contains the CDXTComposite transform
*-------------------------------------------------------------------------------
*  Created By: Edward W. Connell                            Date: 07/28/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
//--- Additional includes
#include "stdafx.h"
#include "Composit.h"

#define COMP_CASE( fctn, runtype ) case ((DXCOMPFUNC_##fctn << 3) + DXRUNTYPE_##runtype)

/*****************************************************************************
* CDXTComposite::FinalConstruct *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 08/08/97
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXTComposite::FinalConstruct()
{
    //--- Uncomment this when debugging to allow only
    //    one thread to execute the work proc at a time
//    m_ulMaxImageBands = 1;

    //--- Init base class variables to control setup
    m_ulMaxInputs     = 2;
    m_ulNumInRequired = 2;
    m_dwOptionFlags   = DXBOF_SAME_SIZE_INPUTS;
    put_Function( DXCOMPFUNC_A_OVER_B );
    return CoCreateFreeThreadedMarshaler( GetControllingUnknown(), &m_cpUnkMarshaler);
} /* CDXTComposite::FinalConstruct */

/*****************************************************************************
* CDXTComposite::OnSurfacePick *
*------------------------------*
*   Description:
*       This method performs a pick test. The compositing logic must be
*   performed to determine each inputs contribution.
*-----------------------------------------------------------------------------
*   Created By: Edward W. Connell                            Date: 05/11/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXTComposite::
    OnSurfacePick( const CDXDBnds& OutPoint, ULONG& ulInputIndex, CDXDVec& InVec )
{
    HRESULT hr = S_OK;
    ULONG IndexA, IndexB;
    DXPMSAMPLE SampleA, SampleB;

    //--- Determine which indexes to use for A and B
    DXCOMPFUNC eFunc = (DXCOMPFUNC)(m_eFunction & DXCOMPFUNC_FUNCMASK);
    if( m_eFunction & DXCOMPFUNC_SWAP_AB )
    {
        IndexA = 1;
        IndexB = 0;
    }
    else
    {
        IndexA = 0;
        IndexB = 1;
    }

    //--- Get input A sample
    {
        CComPtr<IDXARGBReadPtr> cpInA;
        hr = InputSurface( IndexA )->LockSurface( &OutPoint, m_ulLockTimeOut, DXLOCKF_READ,
                                                  IID_IDXARGBReadPtr, (void**)&cpInA, NULL );
        if( FAILED( hr ) )
        {
            //--- No hit if the bounds are invalid
            return ( hr == DXTERR_INVALID_BOUNDS )?( S_FALSE ):( hr );
        }
        cpInA->UnpackPremult( &SampleA, 1, false );
    }

    //--- Get input B sample
    {
        CComPtr<IDXARGBReadPtr> cpInB;
        hr = InputSurface( IndexB )->LockSurface( &OutPoint, m_ulLockTimeOut, DXLOCKF_READ,
                                                  IID_IDXARGBReadPtr, (void**)&cpInB, NULL );
        if( FAILED( hr ) )
        {
            //--- No hit if the bounds are invalid
            return ( hr == DXTERR_INVALID_BOUNDS )?( S_FALSE ):( hr );
        }
        cpInB->UnpackPremult( &SampleB, 1, false );
    }

    //--- Check for trivial cases
    if( m_eFunction == DXCOMPFUNC_CLEAR )
    {
        //--- No hit
        return S_FALSE;
    }
    else if( eFunc == DXCOMPFUNC_A )
    {
        if( SampleA.Alpha )
        {
            ulInputIndex = IndexA;
        }
        else
        {
            hr = S_FALSE;
        }
        return hr;
    }

    //=== Check based on function ==========================
    DWORD SwitchDisp = eFunc << 3;
    switch( DXRUNTYPE_UNKNOWN + SwitchDisp )
    {
      //====================================================
      COMP_CASE(A_OVER_B, UNKNOWN):
      {
        if( SampleA.Alpha )
        {
            ulInputIndex = IndexA;
        }
        else if( SampleB.Alpha )
        {
            ulInputIndex = IndexB;
        }
        else
        {
            hr = S_FALSE;
        }
        break;
      }

      //====================================================
      COMP_CASE(A_IN_B, UNKNOWN):
      {
        if( SampleA.Alpha && SampleB.Alpha )
        {
            ulInputIndex = IndexA;
        }
        else
        {
            //--- We only get hits on A when B exists
            hr = S_FALSE;
        }
        break;
      }

      //====================================================
      COMP_CASE(A_OUT_B, UNKNOWN):
      {
        if( SampleA.Alpha && !SampleB.Alpha )
        {
            ulInputIndex = IndexA;
        }
        else
        {
            //--- We only get hits on A when B does not exist
            hr = S_FALSE;
        }
        break;
      }

      //====================================================
      COMP_CASE(A_ATOP_B, UNKNOWN):
      {
        if( SampleB.Alpha )
        {
            ulInputIndex = ( SampleA.Alpha )?( IndexA ):( IndexB );
        }
        else
        {
            //--- We only get hits on A when B exists and A has alpha
            hr = S_FALSE;
        }
        break;
      }

      //====================================================
      COMP_CASE(A_XOR_B, UNKNOWN):
      {
        if( SampleA.Alpha )
        {
            if( SampleB.Alpha )
            {
                hr = S_FALSE;
            }
            else
            {
                ulInputIndex = IndexA;
            }
        }
        else if( SampleB.Alpha )
        {
            ulInputIndex = IndexB;
        }
        break;
      }

      //====================================================
      COMP_CASE(A_ADD_B, UNKNOWN):
      {
        if( SampleA.Alpha )
        {
            ulInputIndex = ( SampleB.Alpha )?( IndexB ):( IndexA );
        }
        else
        {
            hr = S_FALSE;
        }
        break;
      }

      //====================================================
      COMP_CASE(A_SUBTRACT_B, UNKNOWN):
      {
        if( SampleA.Alpha )
        {
            ulInputIndex = IndexA;
        }
        else
        {
            hr = S_FALSE;
        }
        break;
      }
    }   // End of huge switch

    return hr;
} /* CDXTComposite::OnSurfacePick */

//
//=== Composite Work Procedures ==================================================
//
/*****************************************************************************
* Composite *
*-----------*
*   Description:
*       The Composite function is used to copy the source to the destination
*   performing the current compositing function.
*
*-----------------------------------------------------------------------------
*   Created By: Ed Connell                            Date: 07/31/97
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
HRESULT CDXTComposite::WorkProc( const CDXTWorkInfoNTo1& WI, BOOL* pbContinue )
{ 
    HRESULT hr = S_OK;
    ULONG IndexA, IndexB;
    const ULONG Width = WI.DoBnds.Width();
    const ULONG Height = WI.DoBnds.Height();

    //--- Determine which indexes to use for A and B
    DXCOMPFUNC eFunc = (DXCOMPFUNC)(m_eFunction & DXCOMPFUNC_FUNCMASK);
    if( m_eFunction & DXCOMPFUNC_SWAP_AB )
    {
        IndexA = 1;
        IndexB = 0;
    }
    else
    {
        IndexA = 0;
        IndexB = 1;
    }

    //--- Check for trivial cases
    if( m_eFunction == DXCOMPFUNC_CLEAR )
    {
        //--- NoOp
        return hr;
    }
    else if( eFunc == DXCOMPFUNC_A )
    {
        CDXDVec Placement(false);
        WI.OutputBnds.GetMinVector(Placement);
        return m_cpSurfFact->BitBlt( OutputSurface(), &Placement,
                                     InputSurface( IndexA ), &WI.DoBnds, m_dwBltFlags );
    }

    //--- Get input A sample access pointer.
    CComPtr<IDXARGBReadPtr> cpInA;
    hr = InputSurface( IndexA )->LockSurface( &WI.DoBnds, m_ulLockTimeOut,
                                              DXLOCKF_READ | DXLOCKF_WANTRUNINFO,
                                              IID_IDXARGBReadPtr, (void**)&cpInA, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Get input B sample access pointer.
    CComPtr<IDXARGBReadPtr> cpInB;
    hr = InputSurface( IndexB )->LockSurface( &WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                              IID_IDXARGBReadPtr, (void**)&cpInB, NULL );
    if( FAILED( hr ) ) return hr;

    //--- Put a write lock only on the region we are rendering so multiple
    //    threads don't conflict.
    CComPtr<IDXARGBReadWritePtr> cpOut;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                        IID_IDXARGBReadWritePtr, (void**)&cpOut, NULL );
    if( FAILED( hr ) ) return hr;

    //=== Process each row ===========================================
    DXSAMPLEFORMATENUM InTypeA = cpInA->GetNativeType(NULL);
    //--- Allocate working output buffers if necessary
    DXSAMPLEFORMATENUM InTypeB = cpInB->GetNativeType(NULL);
    DXPMSAMPLE *pInBuffA = ( InTypeA == DXPF_PMARGB32 )?( NULL ):
                           ( DXPMSAMPLE_Alloca( Width ) );
    DXPMSAMPLE *pInBuffB = DXPMSAMPLE_Alloca( Width );

    //--- Optimize if both sources are fully opaque
    DXPMSAMPLE *pOutBuff = (DoOver() && cpOut->GetNativeType(NULL) != DXPF_PMARGB32) ? 
                             DXPMSAMPLE_Alloca( Width ) : NULL;

    //--- We'll be adding the run type into the low bits
    DWORD SwitchDisp = eFunc << 3;

    for( ULONG Y = 0; *pbContinue && (Y < Height); ++Y )
    {
        //--- Move to A input row and get runs
        const DXRUNINFO *pRunInfo;
        ULONG cRuns = cpInA->MoveAndGetRunInfo(Y, &pRunInfo);

        //--- Unpack all of B
        cpInB->MoveToRow( Y );
        DXPMSAMPLE *pDest = cpInB->UnpackPremult( pInBuffB, Width, false );

        //--- Apply each run of A to B
        do
        {
            ULONG ulRunLen = pRunInfo->Count;

            switch( pRunInfo->Type + SwitchDisp )
            {
              //====================================================
              //--- Composite the translucent
              COMP_CASE(A_OVER_B, TRANS):
              {
                DXOverArrayMMX( pDest,
                                cpInA->UnpackPremult( pInBuffA, ulRunLen, true ),
                                ulRunLen );
                pDest += ulRunLen;
              }
              break;

              COMP_CASE(A_OVER_B, UNKNOWN):
              {
                //--- Do not use MMX in this case because it is faster
                //    to check for early exits
                DXOverArray( pDest,
                             cpInA->UnpackPremult( pInBuffA, ulRunLen, true ),
                             ulRunLen );
                pDest += ulRunLen;
              }
              break;

              //====================================================
              COMP_CASE(MIN, OPAQUE ):
              COMP_CASE(MIN, TRANS  ):
              COMP_CASE(MIN, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    *pDest = ( DXConvertToGray(*pSrc) < DXConvertToGray(*pDest) )?
                                ( *pSrc ):( *pDest );
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(MAX, OPAQUE ):
              COMP_CASE(MAX, TRANS  ):
              COMP_CASE(MAX, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    *pDest = ( DXConvertToGray(*pSrc) > DXConvertToGray(*pDest) )?
                                ( *pSrc ):( *pDest );
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_IN_B, OPAQUE):
              COMP_CASE(A_IN_B, TRANS):
              COMP_CASE(A_IN_B, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    //--- Do composite if we have non-clear destination
                    BYTE DstAlpha = pDest->Alpha;
                    if( DstAlpha )
                    {
                        DXPMSAMPLE Src = *pSrc;
                        ULONG t1, t2;
        
                        t1 = (Src & 0x00ff00ff) * DstAlpha + 0x00800080;
                        t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                        t2 = ((Src >> 8) & 0x00ff00ff) * DstAlpha + 0x00800080;
                        t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;
        
                        *pDest = (t1 | t2);
                    }
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_OUT_B, OPAQUE):
              COMP_CASE(A_OUT_B, TRANS):
              COMP_CASE(A_OUT_B, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    if( pDest->Alpha )
                    {
                        if( ( pDest->Alpha != 255 ) && ( pSrc->Alpha ) )
                        {
                            //--- Do the weighted assignment
                            *pDest = DXScaleSample( *pSrc, 255 - pDest->Alpha );
                        }
                        else 
                        {
                           //--- If the destination is opaque we destroy it
                           *pDest = 0;
                        }
                    }
                    else
                    {
                        //--- If the destination is clear we assign the source
                        *pDest = *pSrc;
                    }
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_ATOP_B, OPAQUE):
              COMP_CASE(A_ATOP_B, TRANS):
              COMP_CASE(A_ATOP_B, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    DXPMSAMPLE Dst = *pDest;
                    if( Dst.Alpha > 0 ) //--- If the destination is clear we skip
                    {
                        DXPMSAMPLE Src = *pSrc;
                        BYTE beta = 255 - Src.Alpha;
                        ULONG t1, t2, t3, t4;
        
                        //--- Compute B weighted by inverse alpha A
                        t1 = (Dst & 0x00ff00ff) * beta + 0x00800080;
                        t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                        t2 = ((Dst >> 8) & 0x00ff00ff) * beta + 0x00800080;
                        t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;
        
                        //--- Compute A weighted by alpha B
                        t3 = (Src & 0x00ff00ff) * Dst.Alpha + 0x00800080;
                        t3 = ((t3 + ((t3 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                        t4 = ((Src >> 8) & 0x00ff00ff) * Dst.Alpha + 0x00800080;
                        t4 = (t4 + ((t4 >> 8) & 0x00ff00ff)) & 0xff00ff00;
                
                        //--- Assign the sums
                        *pDest = ((t1 | t2) + (t3 | t4));
                    }
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_XOR_B, OPAQUE):
              COMP_CASE(A_XOR_B, TRANS):
              COMP_CASE(A_XOR_B, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    DXPMSAMPLE Dst = *pDest;
                    if(Dst.Alpha == 0 )
                    {
                        //--- If the destination is clear we assign A
                        *pDest = *pSrc;
                    }
                    else
                    {
                        DXPMSAMPLE Src = *pSrc;
                        //--- If both exist we do composite
                        BYTE SrcBeta = 255 - Src.Alpha;
                        BYTE DstBeta = 255 - Dst.Alpha;
                        ULONG t1, t2, t3, t4;
        
                        //--- Compute B weighted by inverse alpha A
                        t1 = (Dst & 0x00ff00ff) * SrcBeta + 0x00800080;
                        t1 = ((t1 + ((t1 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                        t2 = ((Dst >> 8) & 0x00ff00ff) * SrcBeta + 0x00800080;
                        t2 = (t2 + ((t2 >> 8) & 0x00ff00ff)) & 0xff00ff00;
        
                        //--- Compute A weighted by inverse alpha B
                        t3 = (Src & 0x00ff00ff) * DstBeta + 0x00800080;
                        t3 = ((t3 + ((t3 >> 8) & 0x00ff00ff)) >> 8) & 0x00ff00ff;

                        t4 = ((Src >> 8) & 0x00ff00ff) * DstBeta + 0x00800080;
                        t4 = (t4 + ((t4 >> 8) & 0x00ff00ff)) & 0xff00ff00;
                
                        //--- Assign the sums
                        *pDest = ((t1 | t2) + (t3 | t4));
                    }
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_ADD_B, OPAQUE):
              COMP_CASE(A_ADD_B, TRANS):
              COMP_CASE(A_ADD_B, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    if( pSrc->Alpha )
                    {
                        if( pDest->Alpha )
                        {
                            //--- Add the alpha weighted colors from A
                            unsigned Val;
                            DXSAMPLE A = DXUnPreMultSample( *pSrc  );
                            Val     = (unsigned)A.Red + pDest->Red;
                            A.Red   = ( Val > 255 )?(255):(Val);
                            Val     = (unsigned)A.Green + pDest->Green;
                            A.Green = ( Val > 255 )?(255):(Val);
                            Val     = (unsigned)A.Blue + pDest->Blue;
                            A.Blue  = ( Val > 255 )?(255):(Val);
                            *pDest  = DXPreMultSample( A );
                        }
                        else
                        {
                            *pDest = *pSrc;
                        }
                    }
                    else
                    {
                        *pDest = 0;
                    }
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_SUBTRACT_B, OPAQUE):
              COMP_CASE(A_SUBTRACT_B, TRANS):
              COMP_CASE(A_SUBTRACT_B, UNKNOWN):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                const DXPMSAMPLE *pPastEndDest = pDest + ulRunLen;
                do
                {
                    if( pSrc->Alpha )
                    {
                        if( pDest->Alpha )
                        {
                            //--- Subtract the alpha weighted colors from A
                            DXSAMPLE A = DXUnPreMultSample( *pSrc  );
                            A.Red   = ( A.Red   <= pDest->Red   )?(0):( A.Red   - pDest->Red   );
                            A.Green = ( A.Green <= pDest->Green )?(0):( A.Green - pDest->Green );
                            A.Blue  = ( A.Blue  <= pDest->Blue  )?(0):( A.Blue  - pDest->Blue  );
                            *pDest = DXPreMultSample( A );
                        }
                        else
                        {
                            *pDest = *pSrc;
                        }
                    }
                    else
                    {
                        *pDest = 0;
                    }
                    pDest++;
                    pSrc++;
                } while (pDest < pPastEndDest);
              }
              break;

              //====================================================
              COMP_CASE(A_OVER_B, OPAQUE):
              {
                DXPMSAMPLE *pSrc = cpInA->UnpackPremult( pInBuffA, ulRunLen, true );
                for( ULONG i = 0; i < ulRunLen; ++i ) pDest[i] = pSrc[i];
                pDest += ulRunLen;
                break;
              }

              //--- Skip this many clear
              COMP_CASE(MAX     , CLEAR):
              COMP_CASE(A_OVER_B, CLEAR):
              COMP_CASE(A_ATOP_B, CLEAR):
              COMP_CASE(A_XOR_B , CLEAR):
                cpInA->Move(ulRunLen);
                pDest += ulRunLen;
                break;

              //--- Destroy this many
              COMP_CASE(MIN         , CLEAR):
              COMP_CASE(A_ADD_B     , CLEAR):
              COMP_CASE(A_SUBTRACT_B, CLEAR):
              COMP_CASE(A_IN_B      , CLEAR):
              COMP_CASE(A_OUT_B     , CLEAR):
              {
                for( ULONG i = 0; i < ulRunLen; ++i ) pDest[i] = 0;
                pDest += ulRunLen;
                cpInA->Move(ulRunLen);
              }
              break;
            }   // End of huge switch

            //--- Next run
            pRunInfo++;
            cRuns--;
        } while (cRuns);

        //--- Write out the composite row
        //--- Move to output row
        cpOut->MoveToRow( Y );

        if( DoOver() )
        {
            cpOut->OverArrayAndMove(pOutBuff, pInBuffB, Width);
        }
        else
        {
            cpOut->PackPremultAndMove( pInBuffB, Width );
        }
    } /* end for loop */

    return hr;
} /* Composite */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\dropshadow.cpp ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:        dropshadow.cpp
//
// Created:         10/01/98
//
// Author:          MikeAr
//
// Discription:     This file implements the Drop Shadow transform.
//
// 10/01/98 MikeAr      Created.
// 11/09/98 mcalkins    Moved to dxtmsft.dll
// 12/15/99 mcalkins    Rewrote.  Now alpha values are used when determining
//                      shadow alpha.  Original input alpha taken into
//                      consideration when original input drawn over shadow.
//                      Positive properties works as described in the docs.
//
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "dxtmsft.h"
#include "dxclrhlp.h"
#include "dropshadow.h"
#include "filterhelpers.h"




//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::CDropShadow
//
//------------------------------------------------------------------------------
CDropShadow::CDropShadow() :
    m_nOffX(5),
    m_nOffY(5),
    m_bstrColor(NULL),
    m_dwColor(0xFF404040),
    m_fPositive(true),
    m_fColorTableDirty(true)
{
    // Make sure bounds structures have some area in the Z and Time dimensions
    // so as not to fail intersections.

    m_bndsAreaInput.u.D[DXB_Z].Max      = 1;
    m_bndsAreaInput.u.D[DXB_T].Max      = 1;
    m_bndsAreaShadow.u.D[DXB_Z].Max     = 1;
    m_bndsAreaShadow.u.D[DXB_T].Max     = 1;
    m_bndsAreaInitialize.u.D[DXB_Z].Max = 1;
    m_bndsAreaInitialize.u.D[DXB_T].Max = 1;

    // Base class members.

    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;

    // Due to the the row caching method and other complexities of this 
    // transform, multithreaded rendering would be more complex than it's worth.
    // This keeps the number of threads down to 1.

    m_ulMaxImageBands   = 1;
}
//  Method: CDropShadow::CDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::~CDropShadow
//
//------------------------------------------------------------------------------
CDropShadow::~CDropShadow()
{
    SysFreeString(m_bstrColor);
}
//  Method: CDropShadow::~CDropShadow


//+-----------------------------------------------------------------------------
//
//  CDropShadow::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDropShadow::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_spUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    m_bstrColor = SysAllocString(L"#FF404040");

    if (NULL == m_bstrColor)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CDropShadow::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::put_Color, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::put_Color(VARIANT newVal)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr          = S_OK;
    DWORD   dwColor     = 0x00000000;
    BSTR    bstrTemp    = NULL;

    hr = FilterHelper_GetColorFromVARIANT(newVal, &dwColor, &bstrTemp);

    if (FAILED(hr))
    {
        goto done;
    }

    if (!(dwColor & 0xFF000000))
    {
        dwColor |= 0xFF000000;
    }

    if (m_dwColor != dwColor)
    {
        _ASSERT(bstrTemp);

        SysFreeString(m_bstrColor);

        m_dwColor   = dwColor;
        m_bstrColor = bstrTemp;

        SetDirty();

        m_fColorTableDirty = true;
    }

done:

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    return hr;
}
//  CDropShadow::put_Color, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::get_Color, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::get_Color(VARIANT * pVal)
{
    HRESULT hr = S_OK;

    if (NULL == pVal)
    {
        hr = E_POINTER;

        goto done;
    }

    _ASSERT(m_bstrColor);

    VariantClear(pVal);

    pVal->vt       = VT_BSTR;
    pVal->bstrVal  = SysAllocString(m_bstrColor);

    if (NULL == pVal->bstrVal)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CDropShadow::get_Color, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::get_OffX, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::get_OffX(int * pVal)
{
    DXAUTO_OBJ_LOCK;

    if(DXIsBadWritePtr(pVal, sizeof(*pVal))) 
        return E_POINTER;

    *pVal = m_nOffX;

    return S_OK;
}
//  CDropShadow::get_OffX, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::put_OffX, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::put_OffX(int newVal)
{
    DXAUTO_OBJ_LOCK;

    if (newVal != m_nOffX)
    {
        m_nOffX = newVal;

        SetDirty();
    }

    return S_OK;
}
//  CDropShadow::put_OffX, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::get_OffY, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::get_OffY(int * pVal)
{
    DXAUTO_OBJ_LOCK;

    if(DXIsBadWritePtr(pVal, sizeof(*pVal))) 
        return E_POINTER;

    *pVal = m_nOffY;

    return S_OK;
}
//  CDropShadow::get_OffY, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::put_OffY, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::put_OffY(int newVal)
{
    DXAUTO_OBJ_LOCK;

    if (newVal != m_nOffY)
    {
        m_nOffY = newVal;

        SetDirty();
    }

    return S_OK;
}
//  CDropShadow::put_OffY, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::get_Positive, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::get_Positive(VARIANT_BOOL * pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal))) 
        return E_POINTER;

    if (m_fPositive)
    {
        *pVal = VARIANT_TRUE;
    }
    else
    {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}
//  CDropShadow::get_Positive, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::put_Positive, IDXTDropShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDropShadow::put_Positive(VARIANT_BOOL newVal)
{
    DXAUTO_OBJ_LOCK;

    if ((newVal != VARIANT_TRUE) && (newVal != VARIANT_FALSE))
    {
        return E_INVALIDARG;
    }

    // If the newVal is true and the current val is false or vice-
    // versa, then update ourselves.
    if ((newVal == VARIANT_FALSE && m_fPositive)
            || (newVal == VARIANT_TRUE && !m_fPositive))
    {
        if (newVal == VARIANT_TRUE)
        {
            m_fPositive = true;
        }
        else
        {
            m_fPositive = false;
        }

        SetDirty();

        m_fColorTableDirty = true;
    }

    return S_OK;
}
//  CDropShadow::put_Positive, IDXTDropShadow


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDropShadow::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                   ULONG & ulInToTest, ULONG aInIndex[], 
                                   BYTE aWeight[])
{
    ulInToTest  = 1;
    aInIndex[0] = 0;
    aWeight[0]  = 255;
}
//  CDropShadow::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::DetermineBnds, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDropShadow::DetermineBnds(CDXDBnds & bnds)
{
    bnds.u.D[DXB_X].Max += max(m_nOffX, - m_nOffX);
    bnds.u.D[DXB_Y].Max += max(m_nOffY, - m_nOffY);

    return S_OK;
}
//  Method: CDropShadow::DetermineBnds, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::MapBoundsOut2In, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDropShadow::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                             ULONG ulInIndex, DXBNDS * pInBounds)
{
    CDXDBnds    bnds;

    if ((NULL == pOutBounds) || (NULL == pInBounds))
    {
        return E_POINTER;
    }

    if (ulOutIndex || ulInIndex)
    {
        return E_INVALIDARG;
    }

    if (NULL == InputSurface())
    {
        return E_UNEXPECTED;
    }

    // What we do here is expand the bounds in the opposite direction of the 
    // drop shadow by the offset amount in both directions and then intersect
    // those bounds with the original input bounds.  This will give us the
    // input bounds needed to calculate the output area.

    *pInBounds = *pOutBounds;

    if (m_nOffX > 0)
    {
        pInBounds->u.D[DXB_X].Min -= m_nOffX;  // Sub |m_nOffX| from Min
    }
    else
    {
        pInBounds->u.D[DXB_X].Min += m_nOffX;  // Sub |m_nOffX| from Min
    }

    if (m_nOffY > 0)
    {
        pInBounds->u.D[DXB_Y].Min -= m_nOffY;  // Sub |m_nOffY| from Min
    }
    else
    {
        pInBounds->u.D[DXB_Y].Min += m_nOffY;  // Sub |m_nOffY| from Min
    }

    bnds = *pInBounds;

    bnds.IntersectBounds(m_bndsInput);

    *pInBounds = bnds;

    return S_OK;
}
//  Method: CDropShadow::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDropShadow::OnSetup(DWORD dwFlags)
{
    return InputSurface()->GetBounds(&m_bndsInput);
}
//  Method: CDropShadow::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDropShadow::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    if (IsTransformDirty())
    {
        _CalcAreaBounds();
    }

    if (m_fColorTableDirty)
    {
        _CalcColorTable();
    }

    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDropShadow::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinueProcessing)
{
    HRESULT hr = S_OK;

    CDXDVec     vecDoOutOffset;
    CDXDBnds    bndsOut;
    CDXDBnds    bndsIn;

    vecDoOutOffset.u.D[DXB_X] = WI.OutputBnds.Left() - WI.DoBnds.Left();
    vecDoOutOffset.u.D[DXB_Y] = WI.OutputBnds.Top() - WI.DoBnds.Top();

    bndsOut = WI.DoBnds;

    bndsOut.IntersectBounds(m_bndsAreaShadow);

    if (!bndsOut.BoundsAreEmpty())
    {
        int nDoWidth        = WI.DoBnds.Width();
        int nShadowOffset   = 0;
        int nShadowWidth    = 0;
        int y               = 0;

        DXSAMPLE *      asamplesOutputBuffer    = DXSAMPLE_Alloca(nDoWidth);
        DXBASESAMPLE *  abasesamplesScratch     = DXBASESAMPLE_Alloca(nDoWidth);

        CComPtr<IDXARGBReadPtr>         spSrcPtr;
        CComPtr<IDXARGBReadWritePtr>    spDstPtr;

        // Initialize output buffer.

        ZeroMemory((void *)asamplesOutputBuffer, nDoWidth * sizeof(DXSAMPLE));

        bndsIn = bndsOut;

        bndsIn.Offset(min(0, - m_nOffX), min(0, - m_nOffY), 0, 0);

        nShadowOffset   = bndsOut.Left() - WI.DoBnds.Left();
        nShadowWidth    = bndsOut.Width();

        bndsOut.u.D[DXB_X].Min = WI.DoBnds.Left();
        bndsOut.u.D[DXB_X].Max = WI.DoBnds.Right();

        bndsOut.Offset(vecDoOutOffset);

        hr = InputSurface()->LockSurface(&bndsIn, m_ulLockTimeOut,
                                         DXLOCKF_READ, __uuidof(IDXARGBReadPtr),
                                         (void **)&spSrcPtr, NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = OutputSurface()->LockSurface(&bndsOut, m_ulLockTimeOut, 
                                          DXLOCKF_READWRITE, 
                                          __uuidof(IDXARGBReadWritePtr),
                                          (void **)&spDstPtr, NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        for (y = 0 ; y < (int)bndsOut.Height() ; y++)
        {
            spSrcPtr->MoveToRow(y);

            spSrcPtr->Unpack(&asamplesOutputBuffer[nShadowOffset], nShadowWidth, 
                             FALSE);

            for (int x = nShadowOffset ; x < nShadowWidth + nShadowOffset ; x++)
            {
                asamplesOutputBuffer[x] 
                               = m_adwColorTable[asamplesOutputBuffer[x].Alpha];
            }

            spDstPtr->MoveToRow(y);

            if (DoOver())
            {
                DXPMSAMPLE * ppmsamples = DXPreMultArray(asamplesOutputBuffer,
                                                         nDoWidth);

                spDstPtr->OverArrayAndMove(abasesamplesScratch, ppmsamples, 
                                           nDoWidth);
            }
            else
            {
                spDstPtr->PackAndMove(asamplesOutputBuffer, nDoWidth);
            }
        }
    }

    // If we're not blending with output, initialize the non-shadow area to
    // clear.

    if (!DoOver())
    {
        bndsOut = WI.DoBnds;

        bndsOut.IntersectBounds(m_bndsAreaInitialize);

        if (!bndsOut.BoundsAreEmpty())
        {
            CComPtr<IDXARGBReadWritePtr> spDstPtr;

            bndsOut.Offset(vecDoOutOffset);

            hr = OutputSurface()->LockSurface(&bndsOut, m_ulLockTimeOut, 
                                              DXLOCKF_READWRITE, 
                                              __uuidof(IDXARGBReadWritePtr),
                                              (void **)&spDstPtr, NULL);

            if (FAILED(hr))
            {
                goto done;
            }

            spDstPtr->FillRect(NULL, 0x00000000, FALSE);
        }
    }

    // Blit original over top.

    bndsOut = WI.DoBnds;

    bndsOut.IntersectBounds(m_bndsAreaInput);

    if (!bndsOut.BoundsAreEmpty())
    {
        // We always blit this over the top of the output.  If the user is not
        // trying to blend with the output, any output area will already be
        // initialize either by the drop shadow or to clear by this time.

        DWORD dwFlags = DXBOF_DO_OVER;

        if (DoDither())
        {
            dwFlags |= DXBOF_DITHER;
        }

        bndsIn = bndsOut;

        bndsIn.Offset(min(0, m_nOffX), min(0, m_nOffY), 0, 0);

        bndsOut.Offset(vecDoOutOffset);

        hr = DXBitBlt(OutputSurface(), bndsOut,
                      InputSurface(), bndsIn,
                      dwFlags, INFINITE);
    }

done:

    return hr;
}
//  Method: CDropShadow::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::GetClipOrigin, IDXTClipOrigin
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDropShadow::GetClipOrigin(DXVEC * pvecClipOrigin)
{
    HRESULT hr = S_OK;

    if (NULL == pvecClipOrigin)
    {
        hr = E_POINTER;

        goto done;
    }

    if (m_nOffX < 0)
    {
        pvecClipOrigin->u.D[DXB_X] = - m_nOffX;
    }
    else
    {
        pvecClipOrigin->u.D[DXB_X] = 0;
    }

    if (m_nOffY < 0)
    {
        pvecClipOrigin->u.D[DXB_Y] = - m_nOffY;
    }
    else
    {
        pvecClipOrigin->u.D[DXB_Y] = 0;
    }

done:

    return hr;
}
//  Method: CDropShadow::GetClipOrigin, IDXTClipOrigin


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::_CalcAreaBounds
//
//------------------------------------------------------------------------------
void
CDropShadow::_CalcAreaBounds()
{
    // If m_nOffx and m_nOffY are both set to zero, this transform should just
    // do a bit blit of the source to the destination.

    if ((0 == m_nOffX) && (0 == m_nOffY))
    {
        m_bndsAreaInput = m_bndsInput;

        m_bndsAreaShadow.SetEmpty();
        m_bndsAreaInitialize.SetEmpty();

        return;
    }

    // Input area bounds.

    m_bndsAreaInput = m_bndsInput;

    if (m_nOffX < 0)
    {
        m_bndsAreaInput.Offset(- m_nOffX, 0, 0, 0);
    }

    if (m_nOffY < 0)
    {
        m_bndsAreaInput.Offset(0, - m_nOffY, 0, 0);
    }

    // Shadow area bounds.

    m_bndsAreaShadow = m_bndsAreaInput;

    m_bndsAreaShadow.Offset(m_nOffX, m_nOffY, 0, 0);

    // Area to initialize to clear if we're not blending with the output.

    m_bndsAreaInitialize.u.D[DXB_X].Min = 0;
    m_bndsAreaInitialize.u.D[DXB_X].Max = m_bndsInput.Width() 
                                          + max(m_nOffX, - m_nOffX);

    if (m_nOffY > 0)
    {
        m_bndsAreaInitialize.u.D[DXB_Y].Min = m_bndsAreaInput.Top();
        m_bndsAreaInitialize.u.D[DXB_Y].Max = m_bndsAreaShadow.Top();
    }
    else
    {
        m_bndsAreaInitialize.u.D[DXB_Y].Min = m_bndsAreaShadow.Bottom();
        m_bndsAreaInitialize.u.D[DXB_Y].Max = m_bndsAreaInput.Bottom();
    }
}
//  Method: CDropShadow::_CalcAreaBounds


//+-----------------------------------------------------------------------------
//
//  Method: CDropShadow::_CalcColorTable
//
//------------------------------------------------------------------------------
void
CDropShadow::_CalcColorTable()
{
    if (0xFF000000 == (m_dwColor & 0xFF000000))
    {
        for (DWORD i = 0 ; i < 256 ; i++)
        {
            if (m_fPositive)
            {
                m_adwColorTable[i] = (i << 24) | (m_dwColor & 0x00FFFFFF);
            }
            else
            {
                m_adwColorTable[i] = ((255 - i) << 24) 
                                     | (m_dwColor & 0x00FFFFFF);
            }
        }
    }
    else
    {
        float flAlpha           = 0.0F;
        float flAlphaOriginal   = (float)((m_dwColor & 0xFF000000) >> 24) + 0.99F;

        for (DWORD i = 0 ; i < 256 ; i++)
        {
            if (i)
            {
                flAlpha = flAlphaOriginal * ((float)i / 255.0F);
            }

            if (m_fPositive)
            {
                m_adwColorTable[i] = ((DWORD)flAlpha << 24) 
                                     | (m_dwColor & 0x00FFFFFF); 
            }
            else
            {
                m_adwColorTable[i] = ((DWORD)(flAlphaOriginal - flAlpha) << 24)
                                     | (m_dwColor & 0x00FFFFFF);
            }
        }
    }

    m_fColorTableDirty = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\dropshadow.h ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:        dropshadow.h
//
// Created:         10/01/98
//
// Author:          MikeAr
//
// Discription:     Definition of the Drop Shadow transform.
//
// 1998/10/01   MikeAr      Created.
// 1998/11/09   mcalkins    Moved to dxtmsft.dll
// 2000/01/31   mcalkins    Support IDXTClipOrigin interface to support good 
//                          clipping for old names.
//
//------------------------------------------------------------------------------

#ifndef __DROPSHADOW_H_
#define __DROPSHADOW_H_

#include "resource.h"       // main symbols




class ATL_NO_VTABLE CDropShadow : 
    public CDXBaseNTo1,
    public CComCoClass<CDropShadow, &CLSID_DXTDropShadow>,
    public IDispatchImpl<IDXTDropShadow, &IID_IDXTDropShadow, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDropShadow>,
    public IObjectSafetyImpl2<CDropShadow>,
    public IPersistStorageImpl<CDropShadow>,
    public ISpecifyPropertyPagesImpl<CDropShadow>,
    public IPersistPropertyBagImpl<CDropShadow>,
    public IDXTClipOrigin
{
private:

    CComPtr<IUnknown>   m_spUnkMarshaler;

    CDXDBnds            m_bndsInput;

    CDXDBnds            m_bndsAreaShadow;
    CDXDBnds            m_bndsAreaInput;
    CDXDBnds            m_bndsAreaInitialize;

    int                 m_nOffX;
    int                 m_nOffY;
    BSTR                m_bstrColor;
    DWORD               m_dwColor;
    DWORD               m_adwColorTable[256];

    unsigned            m_fPositive         : 1;
    unsigned            m_fColorTableDirty  : 1;

    // Helpers.

    void _CalcAreaBounds();
    void _CalcColorTable();

public:

    CDropShadow();
    virtual ~CDropShadow();

    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_DROPSHADOW)
    DECLARE_POLY_AGGREGATABLE(CDropShadow)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDropShadow)
        COM_INTERFACE_ENTRY(IDXTDropShadow)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTClipOrigin)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDropShadow>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDropShadow)
        PROP_ENTRY("Color"   , 1, CLSID_DXTDropShadowPP)
        PROP_ENTRY("OffX"    , 2, CLSID_DXTDropShadowPP)
        PROP_ENTRY("OffY"    , 3, CLSID_DXTDropShadowPP)
        PROP_ENTRY("Positive", 4, CLSID_DXTDropShadowPP)
        PROP_PAGE(CLSID_DXTDropShadowPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT DetermineBnds(CDXDBnds & bnds);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing);
    void    OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);

    // IDXTransform methods.

    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTClipOrigin methods.

    STDMETHOD(GetClipOrigin)(DXVEC * pvecClipOrigin);

    // IDXTDropShadow properties.

    STDMETHOD(get_Color)(VARIANT * pVal);
    STDMETHOD(put_Color)(VARIANT newVal);
    STDMETHOD(get_OffX)(int * pval);
    STDMETHOD(put_OffX)(int newVal);
    STDMETHOD(get_OffY)(int * pval);
    STDMETHOD(put_OffY)(int newVal);
    STDMETHOD(get_Positive)(VARIANT_BOOL * pval);
    STDMETHOD(put_Positive)(VARIANT_BOOL newVal);
};


#endif //__DROPSHADOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\dynarray.h ===
// dynarray.h

#ifndef __DYNARRAY_H_
#define __DYNARRAY_H_

#define DYNARRAY_INITIAL_SIZE 8




template <class T> class CDynArray
{
public:

    CDynArray();
    virtual ~CDynArray();

    STDMETHOD(SetItem)(T & item, ULONG ulPosition);
    STDMETHOD(GetItem)(T & item, ULONG ulPosition);
    STDMETHOD(ExpandTo)(ULONG ulPosition);

    void    Empty();
    ULONG   GetSize() { return m_cFilled; }

private:

    T       m_aT[DYNARRAY_INITIAL_SIZE];
    T *     m_pT;
    ULONG   m_cArraySize;
    ULONG   m_cFilled;
    bool    m_fAllocated;
};


template <class T> 
CDynArray<T>::CDynArray()
{
    m_pT            = m_aT;
    m_cArraySize    = DYNARRAY_INITIAL_SIZE;
    m_cFilled       = 0;
    m_fAllocated    = false;
}


template <class T> 
CDynArray<T>::~CDynArray()
{
    if (m_fAllocated)
    {
        delete [] m_pT;
    }
}


template <class T> 
STDMETHODIMP 
CDynArray<T>::SetItem(T & item, ULONG ulPosition)
{
    HRESULT hr = S_OK;

    _ASSERT(m_cFilled <= m_cArraySize);
    _ASSERT((m_pT == m_aT) ? (m_cArraySize == DYNARRAY_INITIAL_SIZE) : (m_fAllocated));
    _ASSERT(m_fAllocated ? ((m_pT != NULL) && (m_pT != m_aT)) : (m_pT == m_aT));

    // Fail if items are not filled sequentially.

    if (ulPosition > m_cFilled)
    {
        hr = E_FAIL;
        goto done;
    }

    // Expand array if more space is needed.

    if (ulPosition == m_cArraySize)
    {
        // Double current size.

        hr = ExpandTo(m_cArraySize + m_cArraySize);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    // Copy item to array postion.

    m_pT[ulPosition] = item;

    // Increment count of items filled if needed.

    if (ulPosition == m_cFilled)
    {
        m_cFilled++;
    }

done:

    return hr;
}


template <class T>
STDMETHODIMP
CDynArray<T>::GetItem(T & item, ULONG ulPosition)
{
    _ASSERT(m_cFilled <= m_cArraySize);
    _ASSERT((m_pT == m_aT) ? (m_cArraySize == DYNARRAY_INITIAL_SIZE) : (m_fAllocated));
    _ASSERT(m_fAllocated ? ((m_pT != NULL) && (m_pT != m_aT)) : (m_pT == m_aT));

    // Fail if item hasn't been initialized.

    if (ulPosition >= m_cFilled)
    {
        return E_FAIL;
    }

    item = m_pT[ulPosition];

    return S_OK;
}

        
template <class T>
STDMETHODIMP
CDynArray<T>::ExpandTo(ULONG ulSize)
{
    HRESULT hr = S_OK;

    ULONG   ul = 0;
    T *     pT = NULL;

    _ASSERT(m_cFilled <= m_cArraySize);
    _ASSERT((m_pT == m_aT) ? (m_cArraySize == DYNARRAY_INITIAL_SIZE) : (m_fAllocated));
    _ASSERT(m_fAllocated ? ((m_pT != NULL) && (m_pT != m_aT)) : (m_pT == m_aT));

    // Fail if array is already large enough.

    if (ulSize <= m_cArraySize)
    {
        hr = E_FAIL;
        goto done;
    }

    // Allocate new array.

    pT = new T[ulSize];

    // Check for out of memory.

    if (NULL == pT)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Copy previous array to new array.

    for (ul = 0; ul < m_cFilled; ul++)
    {
        pT[ul] = m_pT[ul];
    }

    // Delete old array if needed.

    if (m_fAllocated)
    {
        delete [] m_pT;
    }

    // Set member pointer to new array.

    m_pT = pT;

    // Set allocated flag.

    m_fAllocated = true;

    // Set new array size.

    m_cArraySize = ulSize;

done:

    return hr;
}


template <class T>
void
CDynArray<T>::Empty()
{
    _ASSERT(m_cFilled <= m_cArraySize);
    _ASSERT((m_pT == m_aT) ? (m_cArraySize == DYNARRAY_INITIAL_SIZE) : (m_fAllocated));
    _ASSERT(m_fAllocated ? ((m_pT != NULL) && (m_pT != m_aT)) : (m_pT == m_aT));

    if (m_fAllocated)
    {
        delete [] m_pT;
    }

    m_pT            = m_aT;
    m_fAllocated    = false;
    m_cArraySize    = DYNARRAY_INITIAL_SIZE;
    m_cFilled       = 0;
}

#endif // __DYNARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\fade.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-2000
//
// FileName:    fade.h
//
// Description: Declaration of the CFade class.
//
// Change History:
//
// 1998/01/01   ????        Created.
// 1909/01/25   mcalkins    Fixed property map entries.
// 2000/01/28   mcalkins    Fixed bad fading with 0.0 < overlap < 1.0.
//
//------------------------------------------------------------------------------
#ifndef __FADE_H_
#define __FADE_H_

#include "resource.h" 




class ATL_NO_VTABLE CFade : 
    public CDXBaseNTo1,
    public CComCoClass<CFade, &CLSID_DXFade>,
    public CComPropertySupport<CFade>,
    public IDispatchImpl<IDXTFade, &IID_IDXTFade, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CFade>,
    public IPersistStorageImpl<CFade>,
    public ISpecifyPropertyPagesImpl<CFade>,
    public IPersistPropertyBagImpl<CFade>
{
private:

    CComPtr<IUnknown>   m_spUnkMarshaler;

    BYTE    m_ScaleA[256];
    BYTE    m_ScaleB[256];
    float   m_Overlap;

    void    _ComputeScales(void);
    HRESULT FadeOne(const CDXTWorkInfoNTo1 & WI, IDXSurface *pInSurf,
                    const BYTE *AlphaTable);

public:

    CFade();

    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_FADE)
    DECLARE_POLY_AGGREGATABLE(CFade)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CFade)
        COM_INTERFACE_ENTRY(IDXTFade)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CFade>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CFade)
        PROP_ENTRY("Overlap",   1,  CLSID_FadePP)
        PROP_ENTRY("Center",    2,  CLSID_FadePP)
        PROP_PAGE(CLSID_FadePP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing);
    void    OnGetSurfacePickOrder(const CDXDBnds & BndsPoint, 
                                  ULONG & ulInToTest, ULONG aInIndex[], 
                                  BYTE aWeight[]);

    // IDXTFade methods.

    STDMETHOD(get_Center)(BOOL * pVal);
    STDMETHOD(put_Center)(BOOL newVal);
    STDMETHOD(get_Overlap)(float * pVal);
    STDMETHOD(put_Overlap)(float newVal);

    // IDXEffect methods.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};

#endif //__FADE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\fade.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-2000
//
// FileName:    fade.cpp
//
// Description: Implementation of CFade, the fade transform.
//
// Change History:
//
// 2000/01/28   mcalkins    Fixed bad fading with 0.0 < overlap < 1.0.
//
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "DXTMsft.h"
#include "Fade.h"

#if defined(_X86_)

static void _DoDoubleBlendMMX(const DXPMSAMPLE * pSrcA, 
                              const DXPMSAMPLE * pSrcB, DXPMSAMPLE * pDest, 
                              ULONG nSamples, ULONG ulWeightA, ULONG ulWeightB);

#endif // defined(_X86_)

extern CDXMMXInfo   g_MMXDetector;       // Determines the presence of MMX instructions.




//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
CFade::CFade() :
    m_Overlap(1.0f)
{
    m_ulNumInRequired = 1;
    m_ulMaxInputs = 2;
    m_dwOptionFlags = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
}


//+-----------------------------------------------------------------------------
//
//  Method: CFade::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CFade::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  Method: CFade::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
STDMETHODIMP CFade::get_Overlap(float * pVal)
{
    if (NULL == pVal)
    {
        return E_POINTER;
    }

    *pVal = m_Overlap;
    return S_OK;
}

//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
STDMETHODIMP CFade::put_Overlap(float newVal)
{
    if (newVal < 0.0f || newVal > 1.0f)
    {
        return E_INVALIDARG;
    }
    
    if (m_Overlap != newVal)
    {
        Lock();
        m_Overlap = newVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}

//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
STDMETHODIMP CFade::get_Center(BOOL * pVal)
{
    if (NULL == pVal)
    {
        return E_POINTER;
    }
    
    *pVal = (m_dwOptionFlags & DXBOF_CENTER_INPUTS) ? TRUE : FALSE;
    return S_OK;
}

//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
STDMETHODIMP CFade::put_Center(BOOL newVal)
{
    DWORD dwFlags = m_dwOptionFlags & (~DXBOF_CENTER_INPUTS);
    if (newVal) dwFlags |= DXBOF_CENTER_INPUTS;
    if (dwFlags != m_dwOptionFlags)
    {
        m_dwOptionFlags = dwFlags;
        IncrementGenerationId(TRUE);
    }
    return S_OK;
}

//
//  Optimize this file for SPEED
//
#if DBG != 1
#pragma optimize("agtp", on)
#endif

//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
void CFade::_ComputeScales(void)
{
    if (HaveInput(1))
    {
        if (m_Overlap > 0.9960784f) // 254.0F / 255.0f
        {
            BYTE CurAAlpha = (BYTE)((1.0f - m_Progress) * 255.5f);
           // if (m_ScaleA[CurAAlpha] != CurAAlpha)
            {
                for (int i = 0; i < 256; ++i )
                {
                    m_ScaleA[i] = (BYTE)((CurAAlpha * i) / 255);
                    m_ScaleB[i] = (BYTE)(i - m_ScaleA[i]);
                }
            }
        }
        else
        {
            float Scale = 1.0f / (0.5f + (m_Overlap / 2));
            float APercent = 1.0f - (m_Progress * Scale);
            float BPercent = 1.0f - ((1.0f - m_Progress) * Scale);
            if (APercent > 0.0f)
            {
                BYTE A = (BYTE)(APercent * 255.5f);
                for (int i = 0; i < 256; ++i )
                {
                    m_ScaleA[i] = (BYTE)(A * i / 255);
                }
            }
            else
            {
                m_ScaleA[255] = 0;
            }
            if (BPercent > 0.0f)
            {
                BYTE B = (BYTE)(BPercent * 255.5f);
                for (int i = 0; i < 256; ++i )
                {
                    m_ScaleB[i] = (BYTE)(B * i / 255);
                }
            }
            else
            {
                m_ScaleB[255] = 0;
            }
        }
    }
    else
    {
        BYTE AlphaProgress = (BYTE)((1.0f - m_Progress) * 255.5f);
        for (int i = 0; i < 256; ++i )
        {
            m_ScaleA[i] = (BYTE)((AlphaProgress * i) / 255);
        }
    }
}


//+-----------------------------------------------------------------------------
//
//  Method: CFade::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CFade::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    _ComputeScales();

    return S_OK;
}
//  Method: CFade::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CFade::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CFade::OnGetSurfacePickOrder(const CDXDBnds & /*BndsPoint*/, 
                             ULONG & ulInToTest, ULONG aInIndex[], 
                             BYTE aWeight[])
{
    _ComputeScales();

    ulInToTest  = 1;
    aWeight[0]  = 255;
    aInIndex[0] = 0;

    if (HaveInput(1))
    {
        if (m_ScaleA[255] < 255)    // If == 255 then initial settings correct
        {
            if (m_ScaleB[255] == 255)
            {
                aInIndex[0] = 1;
            }
            else
            {
                ulInToTest = 2;
                if (m_Progress < 0.5)
                {
                    aInIndex[0] = 0;
                    aWeight[0] = m_ScaleA[255];
                    aInIndex[1] = 1;
                    aWeight[1] = m_ScaleB[255];
                }
                else
                {
                    aInIndex[0] = 1;
                    aWeight[0] = m_ScaleB[255];
                    aInIndex[1] = 0;
                    aWeight[1] = m_ScaleA[255];
                }
            }
        }
    }
}
//  Method: CFade::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
HRESULT CFade::FadeOne(const CDXTWorkInfoNTo1 & WI, IDXSurface *pInSurf,
                       const BYTE *AlphaTable)
{
    HRESULT hr = S_OK;
    if (AlphaTable[255] == 255)
    {
        return DXBitBlt(OutputSurface(), WI.OutputBnds, 
                        pInSurf,
                        WI.DoBnds, m_dwBltFlags, m_ulLockTimeOut);
    }

    CComPtr<IDXARGBReadWritePtr> cpDest;
    hr = OutputSurface()->LockSurface( &WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                       IID_IDXARGBReadWritePtr, (void**)&cpDest, NULL );
    if( FAILED( hr ) ) return hr;

    if (AlphaTable[255] == 0)
    {
        if ((m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT) == 0)
        {
            DXPMSAMPLE nothing;
            nothing = 0;
            cpDest->FillRect(NULL, nothing, FALSE);
        }
        return hr;
    }

    //
    //  In this function we don't want to use the base class DoOver() because it will
    //  be false if both of the input surfaces are opaque.  Since we are creating translucent
    //  pixels, we want to look directly at the appropriate flag.
    //
    BOOL bDoOver = (m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT);
    CComPtr<IDXARGBReadPtr> cpSrc;
    hr = pInSurf->LockSurface( &WI.DoBnds, m_ulLockTimeOut,
                               bDoOver ? (DXLOCKF_READ | DXLOCKF_WANTRUNINFO) : DXLOCKF_READ,
                               IID_IDXARGBReadPtr, (void**)&cpSrc, NULL);
    if(SUCCEEDED(hr)) 
    {
        //
        //  We don't bother about optimizing the direct copy case since this
        //  transform will most likely be used with an over.  In any case, we
        //  would always need a source buffer since we're going to smash the samples
        //
        const ULONG Width = WI.DoBnds.Width();
        DXPMSAMPLE *pSrcBuff = DXPMSAMPLE_Alloca(Width);
        DXDITHERDESC dxdd;
        if (DoDither())
        {
            dxdd.x = WI.OutputBnds.Left();
            dxdd.y = WI.OutputBnds.Top();
            dxdd.pSamples = pSrcBuff;
            dxdd.cSamples = Width;
            dxdd.DestSurfaceFmt = OutputSampleFormat();
        }
        const ULONG Height = WI.DoBnds.Height();
        if (bDoOver)
        {
            DXPMSAMPLE *pDestScratchBuff = NULL;
            if( OutputSampleFormat() != DXPF_PMARGB32 )
            {
                pDestScratchBuff = DXPMSAMPLE_Alloca(Width);
            }
            for (ULONG y = 0; y < Height; y++)
            {
                cpDest->MoveToRow(y);
                const DXRUNINFO *pRunInfo;
                ULONG ul = cpSrc->MoveAndGetRunInfo(y, &pRunInfo);
                const DXRUNINFO *pLimit = pRunInfo + ul;
                do
                {
                    dxdd.x = WI.OutputBnds.Left();
                    while (pRunInfo < pLimit && pRunInfo->Type == DXRUNTYPE_CLEAR)
                    {
                        dxdd.x += pRunInfo->Count;
                        cpSrc->Move(pRunInfo->Count);
                        cpDest->Move(pRunInfo->Count);
                        pRunInfo++;
                    }
                    if (pRunInfo < pLimit)
                    {
                        ULONG cRunLen = pRunInfo->Count;
                        pRunInfo++;
                        while (pRunInfo < pLimit && pRunInfo->Type != DXRUNTYPE_CLEAR)
                        {
                            cRunLen += pRunInfo->Count;
                            pRunInfo++;
                        }
                        cpSrc->UnpackPremult(pSrcBuff, cRunLen, TRUE);
                        if (DoDither())
                        {
                            dxdd.cSamples = cRunLen;
                            DXDitherArray(&dxdd);
                            dxdd.x += cRunLen;
                        }
                        DXApplyLookupTableArray(pSrcBuff, cRunLen, AlphaTable);
                        DXPMSAMPLE *pOverDest = cpDest->UnpackPremult(pDestScratchBuff, cRunLen, FALSE);
                        DXOverArrayMMX(pOverDest, pSrcBuff, cRunLen);
                        cpDest->PackPremultAndMove(pDestScratchBuff, cRunLen);
                    }
                } while (pRunInfo < pLimit);
                dxdd.y++;
            }
        }
        else
        {
            for (ULONG y = 0; y < Height; y++)
            {
                cpSrc->MoveToRow(y);
                cpSrc->UnpackPremult(pSrcBuff, Width, FALSE);
                DXApplyLookupTableArray(pSrcBuff, Width, AlphaTable);
                if (DoDither())
                {
                    DXDitherArray(&dxdd);
                    dxdd.y++;
                }
                cpDest->MoveToRow(y);
                cpDest->PackPremultAndMove(pSrcBuff, Width);
            }
        }
    }
    return hr;
}


//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
HRESULT 
CFade::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinueProcessing)
{
    HRESULT hr = S_OK;

    CComPtr<IDXARGBReadPtr>         pSrcA;
    CComPtr<IDXARGBReadPtr>         pSrcB;
    CComPtr<IDXARGBReadWritePtr>    cpDest;

    const ULONG     DoWidth     = WI.DoBnds.Width();
    const ULONG     DoHeight    = WI.DoBnds.Height();
    ULONG           y           = 0;

    BOOL    bDoOver     = (m_ScaleA[255] + m_ScaleB[255] == 255) 
                          ? DoOver() : (m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT);
    BOOL    bDirectCopy = (OutputSampleFormat() == DXPF_PMARGB32 && (!bDoOver));

    DXPMSAMPLE *    pBuffA          = NULL;
    DXPMSAMPLE *    pBuffB          = NULL;
    DXPMSAMPLE *    pDestBuff       = NULL;
    DXPMSAMPLE *    pOverScratch    = NULL;

    DXNATIVETYPEINFO    NTI;
    DXDITHERDESC        dxdd;

    if ((!HaveInput(1)) || m_ScaleB[255] == 0)
    {
        return FadeOne(WI, InputSurface(0), m_ScaleA);
    }
    if (m_ScaleA[255] == 0)
    {
        return FadeOne(WI, InputSurface(1), m_ScaleB);
    }

    pBuffA          = (InputSampleFormat(0) == DXPF_PMARGB32)
                      ? NULL : DXPMSAMPLE_Alloca(DoWidth);
    pBuffB          = (InputSampleFormat(1) == DXPF_PMARGB32)
                      ? NULL : DXPMSAMPLE_Alloca(DoWidth);
    pOverScratch    = (bDoOver && OutputSampleFormat() != DXPF_PMARGB32) 
                      ? DXPMSAMPLE_Alloca(DoWidth) : NULL;

    hr = InputSurface(0)->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, (void **)&pSrcA, 
                                      NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = InputSurface(1)->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, (void* *)&pSrcB, 
                                      NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, (void **)&cpDest,
                                      NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    //
    //  The base class DoOver() will be the appropriate value iff the scales
    //  add up to 255.  Otherwise, use the MiscFlags to determine if we want 
    //  to do an over operation.
    //

    if (bDirectCopy)
    {
        cpDest->GetNativeType(&NTI);
        if (NTI.pFirstByte)
        {
            pDestBuff = (DXPMSAMPLE *)NTI.pFirstByte;
        }
        else
        {
            bDirectCopy = FALSE;
        }
    }

    if (pDestBuff == NULL)
    {
        pDestBuff = DXPMSAMPLE_Alloca(DoWidth);
    }

    //
    //  Set up the dither structure. 
    //

    if (DoDither())
    {
        dxdd.x = WI.OutputBnds.Left();
        dxdd.y = WI.OutputBnds.Top();
        dxdd.pSamples = pDestBuff;
        dxdd.cSamples = DoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    for (y = 0; y < DoHeight; y++)
    {
        pSrcA->MoveToRow(y);
        const DXPMSAMPLE *pASamples = pSrcA->UnpackPremult(pBuffA, DoWidth, FALSE);
        pSrcB->MoveToRow(y);
        const DXPMSAMPLE *pBSamples = pSrcB->UnpackPremult(pBuffB, DoWidth, FALSE);

        ULONG cTranslucent = 0;
        ULONG cTransparent = 0;
        bool  fForceOver = false;

#if defined(_X86_)

        if (g_MMXDetector.MinMMXOverCount() != 0xFFFFFFFF)
        {
            ULONG   ulWeightA = 0;
            ULONG   ulWeightB = 0;

            // The code below does some kind of funky counting of translucent vs. transparent
            // pixels to try and optimize when they should use DXOverArrayMMX instead of OverArray().
            fForceOver = true;

            if (m_Overlap > 0.9960784f) // 254.0F / 255.0f
            {
                ulWeightA = (ULONG)(BYTE)((1.0f - m_Progress) * 255.5f);
                ulWeightB = 255 - ulWeightA;
            }
            else
            {
                float Scale = 1.0f / (0.5f + (m_Overlap / 2));

                ulWeightA = (ULONG)((1.0f - (m_Progress * Scale)) * 255.5f);
                ulWeightB = (ULONG)((1.0f - ((1.0f - m_Progress) * Scale)) 
                                    * 255.5f);
            }

            _DoDoubleBlendMMX(pASamples, pBSamples, pDestBuff, DoWidth, 
                              ulWeightA, ulWeightB);
        }
        else
        {

#endif // !defined(_X86_)

            for (ULONG i = 0; i < DoWidth; i++)
            {
                const DWORD av = pASamples[i];
                const DWORD bv = pBSamples[i];
                DWORD a = m_ScaleA[av >> 24] + m_ScaleB[bv >> 24];
                if (a)
                {
                    if (a < 0xFF) cTranslucent++;
                    DWORD r = m_ScaleA[(BYTE)(av >> 16)];
                    DWORD g = m_ScaleA[(BYTE)(av >> 8)];
                    DWORD b = m_ScaleA[(BYTE)av];

                    r += m_ScaleB[(BYTE)(bv >> 16)];
                    g += m_ScaleB[(BYTE)(bv >> 8)];
                    b += m_ScaleB[(BYTE)bv];
                
                    pDestBuff[i] = ((a << 24) | (r << 16) | (g << 8) | b);
                }
                else 
                {
                    pDestBuff[i] = 0;
                    cTransparent++;
                }

            }

#if defined(_X86_)
        }
#endif // !defined(_X86_)

        if (bDirectCopy)
        {
            pDestBuff = (DXPMSAMPLE *)(((BYTE *)pDestBuff) + NTI.lPitch);
        }
        else
        {
            if (DoDither())
            {
                DXDitherArray(&dxdd);
                dxdd.y++;
            }
            cpDest->MoveToRow(y);

            // TODO: Probably we should just totally cut out DXOverArrayMMX opt.
            //      The blending routine that does the fade is a much better win and this other
            //      one is seriously questionable.

            // We need fForceOver here to force the code into the "over" case instead of the
            // "copy" (packpremult) case if we did the MMX code path above because we didn't
            // count cTranslucent and cTransparent
            if (bDoOver && (fForceOver || (cTransparent + cTranslucent)))
            {
                // In the common case, there aren't many translucent pixels.  It's only worth
                // going through the MMX over (and taking the hit for the Unpack) if there are
                // a lot.  In the case of MMX blending code above (fForceOver == true), we will
                // simply assume that it's faster to NOT go through this MMX code (i.e. the image
                // doesn't have many translucent pixels).  The reason we must guess is because the
                // MMX code above is not setup to count translucent pixels.
                if (!fForceOver && (cTranslucent > DoWidth / 4))
                {
                    DXPMSAMPLE *pOverDest = cpDest->UnpackPremult(pOverScratch, DoWidth, FALSE);
                    DXOverArrayMMX(pOverDest, pDestBuff, DoWidth);
                    cpDest->PackPremultAndMove(pOverScratch, DoWidth);
                }
                else
                {
                    cpDest->OverArrayAndMove(pOverScratch, pDestBuff, DoWidth);
                }
            }
            else
            {
                cpDest->PackPremultAndMove(pDestBuff, DoWidth);
            }
        }
    }
    
done:

    return hr;
}

// MMX Code is X86 processor-specific (duh)
#if defined(_X86_)

//+-----------------------------------------------------------------------
//
//
//------------------------------------------------------------------------
static void 
_DoDoubleBlendMMX(const DXPMSAMPLE *pSrcA, const DXPMSAMPLE *pSrcB,
                  DXPMSAMPLE *pDest, ULONG nSamples, ULONG ulWeightA,
                  ULONG ulWeightB)
{
    _ASSERT(NULL != pSrcA && NULL != pSrcB && NULL != pDest);
    _ASSERT(0 < nSamples);
    _ASSERT(0 < ulWeightA && 255 >= ulWeightA);

    ULONG   nCount = nSamples;
    bool    fDoTrailing = false;

    static __int64 ROUND = 0x0080008000800080;

    // TODO: do we want to be quad word aligned here?

    // Make sure we have an even count.

    if (nCount & 1)
    {
        fDoTrailing = true;
        --nCount;
    }

    // If we only have one column, don't do MMX at all.

    if (0 == nCount)
    {
        goto trailing;
    }

    // Crank through the middle.

    __asm
    {
        xor ebx, ebx	            // offset for the three pointers
        mov edx, pDest              // edx -> Destination
        mov esi, pSrcB              // esi -> Background source
        mov edi, pSrcA              // edi -> Foreground source (destination)
        mov ecx, nCount             // ecx = loop count

        //  prolog: prime the pump
        //

        // mm7 will hold the alpha weight (a1) for the pSrcA samples.

        movd      mm7,ulWeightA     //      mm7 = 0000 0000 0000 00a1
        pxor      mm0,mm0           //      mm0 = 0000 0000 0000 0000

        punpcklwd mm7,mm7           //      mm7 = 0000 0000 00a1 00a1
        punpcklwd mm7,mm7           //      mm7 = 00a1 00a1 00a1 00a1

        // mm1 will hold the alpha weight (a2) for the pSrcB samples.

        movd      mm1,ulWeightB     //      mm1 = 0000 0000 0000 00a2
        punpcklwd mm1,mm1           //      mm1 = 0000 0000 00a2 00a2
        punpcklwd mm1,mm1           //      mm1 = 00a2 00a2 00a2 00a2

        movq      mm3,[edi+ebx]     // 3.04 mm3= Aa Ar Ag Ab Ba Br Bg Bb
        shr       ecx,1             // divide loop counter by 2; pixels are processed in pairs
        movq      mm4,mm3           // 4.05 mm4= Aa Ar Ag Ab Ba Br Bg Bb
        punpcklbw mm3,mm0           // 3.06 mm3=  00Ba  00Br  00Bg  00Bb

        dec       ecx               // do one less loop to correct for prolog/postlog
        jz        skip              // if original loop count=2

loopb:
        punpckhbw mm4,mm0           // 4.06 mm4=  00Aa  00Ar  00Ag  00Ab 
        pmullw    mm3,mm7           // 3.07 mm3=  (1-a1)*B

        pmullw    mm4,mm7           // 4.07 mm4=  (1-a1)*A

        movq      mm2,[esi+ebx]     // **PRN mm2= Ca Cr Cg Cb Da Dr Dg Db
        add       ebx,8             //      increment offset

        movq      mm5,ROUND
        movq      mm6,mm5

        paddw     mm5,mm3           // 5.09 mm5=  FBr
        paddw     mm6,mm4           // 6.09 mm6=  GAr

        psrlw     mm5,8             // 5.10 mm5=  FBr>>8 
        psrlw     mm6,8             // 6.10 mm6=  GAr>>8 

        paddw     mm5,mm3           // 5.11 mm5=  FBr+(FBr>>8)
        paddw     mm6,mm4           // 6.11 mm6=  GAr+(GAr>>8)

        psrlw     mm5,8             // 5.12 mm5= (FBr+(FBr>>8)>>8)= 00Sa 00Sr 00Sg 00Sb
        psrlw     mm6,8             // 6.12 mm6= (GAr+(GAr>>8)>>8)= 00Ta 00Tr 00Tg 00Tb

        packuswb  mm5,mm6           // 5.13 mm5= Ta Tr Tg Tb Sa Sr Sg Sb 

        movq      mm4,mm2           // **PRN mm4= Ca Cr Cg Cb Da Dr Dg Db

        punpcklbw mm2,mm0           // **PRN mm2=  00Da  00Dr  00Dg  00Db
        punpckhbw mm4,mm0           // **PRN mm4=  00Ca  00Cr  00Cg  00Cb 

        pmullw    mm2,mm1           // **PRN mm2=  (a1)*D
        pmullw    mm4,mm1           // **PRN mm4=  (a1)*C

        movq      mm6,ROUND
        movq      mm3,mm5           // **PRN move result from first scale into mm3

        movq      mm5,mm6

        paddw     mm5,mm2           // 5.09 mm5=  FBr
        paddw     mm6,mm4           // 6.09 mm6=  GAr

        psrlw     mm5,8             // **PRN mm5=  FBr>>8 
        psrlw     mm6,8             // **PRN mm6=  GAr>>8 

        paddw     mm5,mm2           // **PRN mm5=  FBr+(FBr>>8)
        paddw     mm6,mm4           // **PRN mm6=  GAr+(GAr>>8)

        psrlw     mm5,8             // **PRN mm5= (FBr+(FBr>>8)>>8)= 00Xa 00Xr 00Xg 00Xb
        psrlw     mm6,8             // **PRN mm6= (GAr+(GAr>>8)>>8)= 00Ya 00Yr 00Yg 00Yb

        packuswb  mm5,mm6           // **PRN mm5= Ya Yr Yg Yb Xa Xr Xg Xb
        paddusb   mm5,mm3           // **PRN add two scaled pixels

        movq      mm3,[edi+ebx]     //+3.04 mm3= Aa Ar Ag Ab Ba Br Bg Bb
        dec       ecx               // decrement loop counter

        movq      [edx+ebx-8],mm5   // **PRN store result

        movq      mm4,mm3           //+4.05 mm4= Aa Ar Ag Ab Ba Br Bg Bb
        punpcklbw mm3,mm0           //+3.06 mm3=  00Ba  00Br  00Bg  00Bb 
    
        jg        loopb             // loop

        // 
        // loop postlog, drain the pump
        //
skip:
        punpckhbw mm4,mm0           // 4.06 mm4=  00Aa  00Ar  00Ag  00Ab
        pmullw    mm3,mm7           // 3.07 mm3=  (1-Fa)*B
        pmullw    mm4,mm7           // 4.07 mm4=  (1-Ga)*A
        paddw     mm3,ROUND         // 3.08 mm3=  prod+128=FBr
        paddw     mm4,ROUND         // 4.08 mm4=  prod+128=Gar
        movq      mm5,mm3           // 5.09 mm5=  FBr
        movq      mm6,mm4           // 6.09 mm6=  GAr
        psrlw     mm5,8             // 5.10 mm5=  FBr>>8
        psrlw     mm6,8             // 6.10 mm6=  GAr>>8
        paddw     mm5,mm3           // 5.11 mm5=  FBr+(FBr>>8)
        paddw     mm6,mm4           // 6.11 mm6=  GAr+(GAr>>8)
        psrlw     mm5,8             // 5.12 mm5= (FBr+(FBr>>8)>>8)= 00Sa 00Sr 00Sg 00Sb
        psrlw     mm6,8             // 6.12 mm6= (Gar+(GAr>>8)>>8)= 00Ta 00Tr 00Tg 00Tb
        packuswb  mm5,mm6           // 5.13 mm5= Sa Sr Sg Sb Ta Tr Tg Tb
        movq      mm2,mm5           // **PRN store to stack for a moment...

        movq      mm3,[esi+ebx]     // **PRN mm3= Ca Cr Cg Cb Da Dr Dg Db
        movq      mm4,mm3           // **PRN mm4= Ca Cr Cg Cb Da Dr Dg Db
        punpcklbw mm3,mm0           // **PRN mm3=  00Da  00Dr  00Dg  00Db
        punpckhbw mm4,mm0           // **PRN mm4=  00Ca  00Cr  00Cg  00Cb 

        pmullw    mm3,mm1           // **PRN mm3=  (a1)*B
        pmullw    mm4,mm1           // **PRN mm4=  (a2)*A
        paddw     mm3,ROUND         // **PRN mm3=  prod+128=FBr
        paddw     mm4,ROUND         // **PRN mm4=  prod+128=Gar
        movq      mm5,mm3           // **PRN mm5=  FBr
        movq      mm6,mm4           // **PRN mm6=  GAr
        psrlw     mm5,8             // **PRN mm5=  FBr>>8 
        psrlw     mm6,8             // **PRN mm6=  GAr>>8 
        paddw     mm5,mm3           // **PRN mm5=  FBr+(FBr>>8)
        paddw     mm6,mm4           // **PRN mm6=  GAr+(GAr>>8)
        psrlw     mm5,8             // **PRN mm5= (FBr+(FBr>>8)>>8)= 00Xa 00Xr 00Xg 00Xb
        psrlw     mm6,8             // **PRN mm6= (GAr+(GAr>>8)>>8)= 00Ya 00Yr 00Yg 00Yb
        packuswb  mm5,mm6           // **PRN mm5= Ta Tr Tg Tb Sa Sr Sg Sb

        movq      mm6,mm2           // **PRN restore from stack
        paddusb   mm5,mm6           // **PRN add two scaled pixels
        movq      [edx+ebx],mm5     // **PRN store result

        //
        // really done now
        //
        EMMS
    }

trailing:

    // Do the last one non-MMX if the count was odd.

    if (fDoTrailing)
    {
        pDest[nCount] = DXScaleSample(pSrcA[nCount], ulWeightA) +
                        DXScaleSample(pSrcB[nCount], ulWeightB);
    }
}


#endif //defined(_X86_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\dxtwipe.h ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) 1998-1999 Microsoft Corporation
//
//  File:       dxtwipe.h
//
//  Overview:   This is the header file for the CDXTWipe implementation.
//
//  01/06/98    edc         Created.
//  01/25/99    a-matcal    Fixed property map entries.
//  01/31/99    a-matcal    Optimization.
//  05/14/99    a-matcal    More optimization.
//  10/24/99    a-matcal    Changed CDXTWipe class to CDXTWipeBase and created
//                          two new classes CDXTWipe and CDXTGradientWipe to  
//                          represent non-optimized and optimized versions 
//                          respectively.
//
//------------------------------------------------------------------------------

#ifndef __DXTWIPE
#define __DXTWIPE

#include "resource.h"

#define MAX_WIPE_BOUNDS 3




class ATL_NO_VTABLE CDXTWipeBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<IDXTWipe2, &IID_IDXTWipe2, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTWipeBase>,
    public IObjectSafetyImpl2<CDXTWipeBase>,
    public ISpecifyPropertyPagesImpl<CDXTWipeBase> 
{
private:

    typedef enum {
        MOTION_FORWARD = 0,
        MOTION_REVERSE,
        MOTION_MAX
    } MOTION;

    MOTION                  m_eMotion;
    static const WCHAR *    s_astrMotion[MOTION_MAX];

    long            m_lGradientSize;
    float           m_flGradPercentSize;
    PULONG          m_pulGradientWeights;
    DXWIPEDIRECTION m_eWipeStyle;
    SIZE            m_sizeInput;

    long            m_lCurGradMax;
    long            m_lPrevGradMax;

    CDXDBnds        m_abndsDirty[MAX_WIPE_BOUNDS];
    long            m_alInputIndex[MAX_WIPE_BOUNDS];
    ULONG           m_cbndsDirty;

    CComPtr<IUnknown>   m_cpUnkMarshaler;

    unsigned        m_fOptimizationPossible : 1;

protected:

    unsigned        m_fOptimize             : 1;

private:

    // Functions to calculate optimized bounds when the entire output needs to
    // be redrawn.

    HRESULT _CalcFullBoundsHorizontal();
    HRESULT _CalcFullBoundsVertical();

    // Functions to calculate optimized bounds when only the dirty parts of the
    // output need to be redrawn.

    HRESULT _CalcOptBoundsHorizontal();
    HRESULT _CalcOptBoundsVertical();

    // Function to draw the gradient.

    HRESULT _DrawGradientRect(const CDXDBnds bndsDest, const CDXDBnds bndsSrc,
                              const CDXDBnds bndsGrad, BOOL * pbContinue);

    HRESULT _UpdateStepResAndGradWeights(float flNewGradPercent);

public:

    CDXTWipeBase();
    virtual ~CDXTWipeBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTWipeBase)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDXTWipe)
        COM_INTERFACE_ENTRY(IDXTWipe2)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTWipeBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTWipeBase)
        PROP_ENTRY("GradientSize",  DISPID_DXW_GradientSize,    CLSID_DXTWipePP)
        PROP_ENTRY("WipeStyle",     DISPID_DXW_WipeStyle,       CLSID_DXTWipePP)
        PROP_ENTRY("motion",        DISPID_DXW_Motion,          CLSID_DXTWipePP)
        PROP_PAGE(CLSID_DXTWipePP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides

    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);
    HRESULT OnSetup(DWORD dwFlags);
    void    OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);

    // IDXEffect methods

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)

    // IDXTWipe properties

    STDMETHOD(get_GradientSize)(float *pPercentSize);
    STDMETHOD(put_GradientSize)(float PercentSize);
    STDMETHOD(get_WipeStyle)(DXWIPEDIRECTION *pVal);
    STDMETHOD(put_WipeStyle)(DXWIPEDIRECTION newVal);

    // IDXTWipe2 properties

    STDMETHOD(get_Motion)(BSTR * pbstrMotion);
    STDMETHOD(put_Motion)(BSTR bstrMotion);
};


class ATL_NO_VTABLE CDXTWipe :
    public CDXTWipeBase,
    public CComCoClass<CDXTWipe, &CLSID_DXTWipe>,
    public IPersistStorageImpl<CDXTWipe>,
    public IPersistPropertyBagImpl<CDXTWipe>,
    public IOleObjectDXImpl<CDXTWipe>
{
public:

    CDXTWipe()
    {
        m_fOptimize = false;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTWIPE)
    DECLARE_POLY_AGGREGATABLE(CDXTWipe)

    BEGIN_COM_MAP(CDXTWipe)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_DXIMPL(IOleObject)
        COM_INTERFACE_ENTRY_CHAIN(CDXTWipeBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTGradientWipe :
    public CDXTWipeBase,
    public CComCoClass<CDXTGradientWipe, &CLSID_DXTGradientWipe>,
    public IPersistStorageImpl<CDXTGradientWipe>,
    public IPersistPropertyBagImpl<CDXTGradientWipe>,
    public IOleObjectDXImpl<CDXTGradientWipe>
{
public:

    CDXTGradientWipe()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTGRADIENTWIPE)
    DECLARE_POLY_AGGREGATABLE(CDXTGradientWipe)

    BEGIN_COM_MAP(CDXTGradientWipe)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_DXIMPL(IOleObject)
        COM_INTERFACE_ENTRY_CHAIN(CDXTWipeBase)
    END_COM_MAP()
};


#endif // __DXTWIPE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\dxtwipe.cpp ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) 1998-1999 Microsoft Corporation
//
//  File:       dxtwipe.cpp
//
//  Overview:   This module contains the CDXTWipe transform.
//
//  01/06/98    edc         Created.
//  01/01/99    a-matcal    Added bounds reduction optimization.
//  05/13/99    paulnash    Added MMX optimization.
//  05/14/99    a-matcal    Restructured code.  Use bnds loop in WorkProc.
//  09/29/99    a-matcal    _DrawGradientRect was setting up its dithering 
//                          structure with a NULL pointer to the samples.
//  10/24/99    a-matcal    Changed CDXTWipe class to CDXTWipeBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"

#include "dxtmsft.h"   
#include "dxtwipe.h"
#include <string.h>

#define DO_GRADIENT 0xFFFFFFFFL

void _DoGradientMMXHorz(DXPMSAMPLE *pTarget, DXPMSAMPLE *pSource,
                        ULONG *paulWeights, ULONG cWeights);

/////////////////////////////////////////////////////////////////////////////
// Global Variables...

extern CDXMMXInfo   g_MMXDetector;       // Determines the presence of MMX instructions.


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase static variables initialization
//
//------------------------------------------------------------------------------

const WCHAR * CDXTWipeBase::s_astrMotion[] = {
    L"forward",
    L"reverse"
};


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::CDXTWipeBase
//
//------------------------------------------------------------------------------
CDXTWipeBase::CDXTWipeBase() :
    m_eMotion(MOTION_FORWARD),
    m_flGradPercentSize(0.25F),
    m_lGradientSize(0),
    m_pulGradientWeights(NULL),
    m_eWipeStyle(DXWD_HORIZONTAL),
    m_lCurGradMax(0),
    m_lPrevGradMax(0),
    m_cbndsDirty(0),
    m_fOptimize(false),
    m_fOptimizationPossible(false)
{
    m_sizeInput.cx    = 0;
    m_sizeInput.cy    = 0;

    // CDXBaseNTo1 members

    // Uncomment this when debugging to allow only one thread to execute the
    // work proc at a time.

    // m_ulMaxImageBands = 1;

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 0.5F;
}
// CDXTWipeBase::CDXTWipeBase


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::~CDXTWipeBase
//
//------------------------------------------------------------------------------
CDXTWipeBase::~CDXTWipeBase()
{
    if (m_pulGradientWeights != NULL)
    {
        delete [] m_pulGradientWeights; 
    }
}
// CDXTWipeBase::~CDXTWipeBase


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTWipeBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTWipeBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_UpdateStepResAndGradWeights
//
//  Overview:   This is a helper method used to generate the transition 
//              gradient wieghts.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTWipeBase::_UpdateStepResAndGradWeights(float flNewGradPercent)
{
    HRESULT hr              = S_OK;
    long    i               = 0;
    float   flWeight        = 0.0F;
    float   flInc           = 0.0F;
    long    lNewGradSize    = 0;
    float   flNewStepRes    = 0.0F;

    ULONG * pulNewGradWeights = NULL;

    if (m_eWipeStyle == DXWD_HORIZONTAL)
    {
        lNewGradSize    = (long)(m_sizeInput.cx * flNewGradPercent);
        flNewStepRes    = (float)(m_sizeInput.cx + lNewGradSize);
    }
    else // (m_eWipeStyle == DXWD_VERTICAL)
    {
        lNewGradSize    = (long)(m_sizeInput.cy * flNewGradPercent);
        flNewStepRes    = (float)(m_sizeInput.cy + lNewGradSize);
    }

    // If gradient weights are the same size, no need to recalculate.

    if (lNewGradSize == m_lGradientSize)
    {
        goto done;
    }

    // If the gradient size isn't zero, allocate memory to hold the
    // gradient weights.

    if (lNewGradSize > 0)
    {
        pulNewGradWeights = new ULONG[lNewGradSize];

        if (NULL == pulNewGradWeights)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }

        flWeight    = 1.0F;
        flInc       = 1.0F / (float)lNewGradSize;

        for (i = 0; i < lNewGradSize; i++)
        {
            pulNewGradWeights[i] = (ULONG)(flWeight * 255.0F);

            flWeight -= flInc;
        }

        // Everything's OK, delete old gradient weights and transfer new pointer.

        if (m_pulGradientWeights)
        {
            delete [] m_pulGradientWeights;
        }

        m_pulGradientWeights = pulNewGradWeights;
    }

    m_lGradientSize     = lNewGradSize;
    m_StepResolution    = flNewStepRes;

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
// CDXTWipeBase::_UpdateGradWeights


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_CalcFullBoundsHorizontal
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::_CalcFullBoundsHorizontal()
{
    RECT    rc;
    long    lGradMin = m_lCurGradMax - m_lGradientSize;

    // Note:    Some of the bounds may go outside of the input bounds, but that's
    //          OK because they will be clipped appropriately in WorkProc().

    // Solid left area.

    if (lGradMin > 0)
    {
        rc.left     = 0;
        rc.top      = 0;
        rc.right    = lGradMin;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }

        m_cbndsDirty++;
    }

    // Gradient area.

    if (m_lCurGradMax > 0 && lGradMin < m_sizeInput.cx)
    {
        rc.left     = lGradMin;
        rc.top      = 0;
        rc.right    = m_lCurGradMax;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = DO_GRADIENT;
        m_cbndsDirty++;
    }

    // Sold right area.

    if (m_lCurGradMax < m_sizeInput.cx)
    {
        rc.left     = m_lCurGradMax;
        rc.top      = 0;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }

        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTWipeBase::_CalcFullBoundsHorizontal


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_CalcFullBoundsVertical
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::_CalcFullBoundsVertical()
{
    RECT    rc;
    long    lGradMin = m_lCurGradMax - m_lGradientSize;

    // Note:    Some of the bounds may go outside of the input bounds, but that's
    //          OK because they will be clipped appropriately in WorkProc().

    // Solid top area.

    if (lGradMin > 0)
    {
        rc.left     = 0;
        rc.top      = 0;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = lGradMin;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }

        m_cbndsDirty++;
    }

    // Gradient area.

    if (m_lCurGradMax > 0 && lGradMin < m_sizeInput.cy)
    {
        rc.left     = 0;
        rc.top      = lGradMin;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_lCurGradMax;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = DO_GRADIENT;
        m_cbndsDirty++;
    }

    // Solid bottom area.

    if (m_lCurGradMax < m_sizeInput.cy)
    {
        rc.left     = 0;
        rc.top      = m_lCurGradMax;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }

        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTWipeBase::_CalcFullBoundsVertical


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_CalcOptBoundsHorizontal
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::_CalcOptBoundsHorizontal()
{
    RECT    rc;
    long    lGradMin    = m_lCurGradMax - m_lGradientSize;
    long    lGradDiff   = m_lCurGradMax - m_lPrevGradMax;

    // Positive lGradDiff indicates forward movement.

    // Note:    Some of the bounds may go outside of the input bounds, but that's
    //          OK because they will be clipped appropriately in WorkProc().

    // Solid left area.

    if ((lGradDiff > 0) && (lGradMin > 0))
    {
        rc.left     = lGradMin - lGradDiff;
        rc.top      = 0;
        rc.right    = lGradMin;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }

        m_cbndsDirty++;
    }

    // Gradient area.

    if (m_lCurGradMax > 0 && lGradMin < m_sizeInput.cx)
    {
        rc.left     = lGradMin;
        rc.top      = 0;
        rc.right    = m_lCurGradMax;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = DO_GRADIENT;
        m_cbndsDirty++;
    }

    // Solid right area.

    if ((lGradDiff < 0) && (m_lCurGradMax < m_sizeInput.cx))
    {
        rc.left     = m_lCurGradMax;
        rc.top      = 0;
        rc.right    = m_lCurGradMax - lGradDiff;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }

        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTWipeBase::_CalcOptBoundsHorizontal


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_CalcOptBoundsVertical
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::_CalcOptBoundsVertical()
{
    RECT    rc;
    long    lGradMin    = m_lCurGradMax - m_lGradientSize;
    long    lGradDiff   = m_lCurGradMax - m_lPrevGradMax;

    // Positive lGradDiff indicates forward movement.

    // Note:    Some of the bounds may go outside of the input bounds, but that's
    //          OK because they will be clipped appropriately in WorkProc().

    // Solid top area.

    if ((lGradDiff > 0) && (lGradMin > 0))
    {
        rc.left     = 0;
        rc.top      = lGradMin - lGradDiff;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = lGradMin;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }

        m_cbndsDirty++;
    }

    // Gradient area.

    if (m_lCurGradMax > 0 && lGradMin < m_sizeInput.cx)
    {
        rc.left     = 0;
        rc.top      = lGradMin;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_lCurGradMax;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = DO_GRADIENT;
        m_cbndsDirty++;
    }

    // Solid bottom area.

    if ((lGradDiff < 0) && (m_lCurGradMax < m_sizeInput.cx))
    {
        rc.left     = 0;
        rc.top      = m_lCurGradMax;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_lCurGradMax - lGradDiff;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_alInputIndex[m_cbndsDirty] = 1;
        }
        else
        {
            m_alInputIndex[m_cbndsDirty] = 0;
        }

        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTWipeBase::_CalcOptBoundsVertical


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::OnSetup, CDXBaseNTo1
//
//  Description:    This method is used to get the size of the inputs and 
//                  validate that they are the same.
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::OnSetup(DWORD dwFlags)
{
    DXTDBG_FUNC( "CDXTWipeBase::OnSetup" );

    HRESULT hr = S_OK;

    CDXDBnds InBounds(InputSurface(0), hr);

    if (FAILED(hr))
    {
        goto done;
    }

    // Compute the effect step resolution and weights.

    InBounds.GetXYSize(m_sizeInput);

    hr = _UpdateStepResAndGradWeights(m_flGradPercentSize);

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
// CDXTWipeBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//  Description:    This method is used to determine which input has been 
//                  picked.
//
//------------------------------------------------------------------------------
void CDXTWipeBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                         ULONG & ulInToTest, ULONG aInIndex[], 
                                         BYTE aWeight[])
{
    long    lPointCoord = 0;
    long    lGradMin    = m_lCurGradMax - m_lGradientSize;

    ulInToTest  = 1;
    aWeight[0]  = 255;

    // Which coordinate to use?  If we're in "reverse" mode it's easier just to
    // invert lPointCoord than to invert everything else.

    if (DXWD_HORIZONTAL == m_eWipeStyle)
    {
        lPointCoord = OutPoint.Left();

        if (MOTION_REVERSE == m_eMotion)
        {
            lPointCoord = m_sizeInput.cx - lPointCoord;
        }
    }
    else
    {
        lPointCoord = OutPoint.Top();

        if (MOTION_REVERSE == m_eMotion)
        {
            lPointCoord = m_sizeInput.cy - lPointCoord;
        }
    }

    if (lPointCoord < lGradMin)
    {
        aInIndex[0] = 1;  // Input B
    }
    else if (lPointCoord < m_lCurGradMax)
    {
        ulInToTest = 2;

        BYTE byteWeight = (BYTE)m_pulGradientWeights[lPointCoord - lGradMin];

        if (byteWeight > 127)
        {
            aInIndex[0] = 1;
            aWeight[0]  = byteWeight;

            aInIndex[1] = 0;
            aWeight[1]  = DXInvertAlpha(byteWeight);
        }
        else
        {
            aInIndex[0] = 0;
            aWeight[0]  = DXInvertAlpha(byteWeight);

            aInIndex[1] = 1;
            aWeight[1]  = byteWeight;
        }
    }
    else
    {
        aInIndex[0] = 0;  // Input A
    }
}
//  CDXTWipeBase::OnGetSurfacePickOrder, CDXBaseNTo1




//  ALL CODE FROM THIS POINT ON IS TIME-CRITICAL SO OPTIMIZE FOR SPEED OVER 
//  SIZE!

#if DBG != 1
#pragma optimize("agtp", on)
#endif




//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::OnInitInstData, CDXBaseNTo1
//
//  Overview:   Calculate dirty bounds for WorkProc().
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;

    // Reset dirty bounds count.

    m_cbndsDirty = 0;

    // Calculate current gradient position.

    if (m_eWipeStyle == DXWD_HORIZONTAL)
    {
        m_lCurGradMax = (long)((float)(m_sizeInput.cx + m_lGradientSize) 
                                * m_Progress);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_lCurGradMax = (m_sizeInput.cx - m_lCurGradMax) + m_lGradientSize;
        }
    }
    else if (m_eWipeStyle == DXWD_VERTICAL)
    {
        m_lCurGradMax = (long)((float)(m_sizeInput.cy + m_lGradientSize) 
                                * m_Progress);

        if (MOTION_REVERSE == m_eMotion)
        {
            m_lCurGradMax = (m_sizeInput.cy - m_lCurGradMax) + m_lGradientSize;
        }
    }
    else
    {
        _ASSERT(0);
    }
    
    // If the inputs, output, or transform is dirty, or if we can't optimize we 
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize
        || !m_fOptimizationPossible)
    {
        if (DXWD_HORIZONTAL == m_eWipeStyle)
        {
            hr = _CalcFullBoundsHorizontal();
        }
        else
        {
            hr = _CalcFullBoundsVertical();
        }
    }
    else
    {
        // If the gradient position hasn't change, nothing is dirty.

        if (m_lCurGradMax == m_lPrevGradMax)
        {
            goto done;
        }

        // The only area that's dirty is the area including both the previous
        // gradient area and the current gradient area.

        if (DXWD_HORIZONTAL == m_eWipeStyle)
        {
            hr = _CalcOptBoundsHorizontal();
        }
        else
        {
            hr = _CalcOptBoundsVertical();
        }
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
// CDXTWipeBase::OnInitInstData


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::WorkProc, CDXBaseNTo1
//
//  Overview:   This function is used to calculate the result based on the 
//              specifiedbounds and the current effect progress. This is a 
//              simple subset of the full functionality to provide the simplest 
//              example possible (not necessarily the most efficient). THIS 
//              JUST WIPES RIGHT TO KEEP IT SIMPLE.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTWipeBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr      = S_OK;
    DWORD   dwFlags = 0;
    ULONG   i       = 0;

    long    lInOutOffsetX = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }


    for (i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;

        if (bndsSrc.IntersectBounds(WI.DoBnds, m_abndsDirty[i]))
        {
            bndsDest = bndsSrc;
            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            if (DO_GRADIENT == m_alInputIndex[i])
            {
                hr = _DrawGradientRect(bndsDest, bndsSrc, m_abndsDirty[i],
                                       pbContinue);
            }
            else
            {
                _ASSERT(m_alInputIndex[i] < (long)m_ulMaxInputs);

                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(m_alInputIndex[i]), bndsSrc,
                              dwFlags, INFINITE);
            }

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTWipeBase::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_DrawGradientRect
//
//  Arguments:  bndsDest    Bounds relative to the output surface to update.
//              bndsSrc     Bounds retative to the source images to blend.
//              bndsGrad    The full gradient bounds relative to the source
//                          images.
//              pbContinue  Pointer to a boolean variable that will be set to
//                          FALSE to indicate that the function should abort.
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::_DrawGradientRect(const CDXDBnds bndsDest, const CDXDBnds bndsSrc,
                                const CDXDBnds bndsGrad, BOOL * pbContinue)
{
    HRESULT     hr              = S_OK;
    ULONG       ulDestWidth     = 0;
    ULONG       ulDestHeight    = 0;
    ULONG       ulOutY          = 0;
    bool        fDirectCopy     = (OutputSampleFormat() == DXPF_PMARGB32 
                                   && (!DoOver()));


    DXPMSAMPLE *    pRowBuff    = NULL;
    DXPMSAMPLE *    pGradBuff   = NULL;
    DXPMSAMPLE *    pOutBuff    = NULL;

    IDXSurface *    pDXSurfaceFrom  = NULL;
    IDXSurface *    pDXSurfaceTo    = NULL;

    DXDITHERDESC        dxdd;
    DXNATIVETYPEINFO    nti;

    CComPtr<IDXARGBReadPtr>         pInA;
    CComPtr<IDXARGBReadPtr>         pInB;
    CComPtr<IDXARGBReadWritePtr>    pOut;

    _ASSERT(m_pulGradientWeights);

    // Pre-calculate width and height.

    ulDestWidth     = bndsDest.Width();
    ulDestHeight    = bndsDest.Height();

    if (MOTION_REVERSE == m_eMotion)
    {
        pDXSurfaceFrom  = InputSurface(1);
        pDXSurfaceTo    = InputSurface(0);
    }
    else
    {
        pDXSurfaceFrom  = InputSurface(0);
        pDXSurfaceTo    = InputSurface(1);
    }

    // Get input sample access pointer for the requested region.

    // TODO:    Rename pInA, and pInB to the more appropos pInFrom and pInTo.

    hr = pDXSurfaceFrom->LockSurface(&bndsSrc, m_ulLockTimeOut,
                                     DXLOCKF_READ, IID_IDXARGBReadPtr, 
                                     (void **)&pInA, NULL);
    if (FAILED(hr)) 
    {
        goto done;
    }

    hr = pDXSurfaceTo->LockSurface(&bndsSrc, m_ulLockTimeOut,
                                   DXLOCKF_READ, IID_IDXARGBReadPtr, 
                                   (void **)&pInB, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Put a write lock only on the region we are updating so multiple
    // threads don't conflict.

    hr = OutputSurface()->LockSurface(&bndsDest, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, (void **)&pOut, 
                                      NULL);

    if (FAILED(hr)) 
    {
        goto done;
    }

    // If it's possible to directly modify the samples of the output surface,
    // get needed info about the surface and the pointer to the first sample.
    // If for some reason a pointer isn't available, we  can't do direct copy.

    if (fDirectCopy)
    {
        pOut->GetNativeType(&nti);

        if (nti.pFirstByte)
        {
            pRowBuff = (DXPMSAMPLE *)nti.pFirstByte;
        }
        else
        {
            fDirectCopy = false;
        }
    }

    // Allocate row and gradient buffers.

    pGradBuff = DXPMSAMPLE_Alloca(ulDestWidth);

    if (NULL == pRowBuff)
    {
        pRowBuff = DXPMSAMPLE_Alloca(ulDestWidth);
    }

    // Allocate an output buffer if needed.

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(ulDestWidth);
    }

    //
    //  Set up the dither structure
    //

    if (DoDither())
    {
        dxdd.x              = bndsDest.Left();
        dxdd.y              = bndsDest.Top();
        dxdd.pSamples       = pRowBuff;
        dxdd.cSamples       = ulDestWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    //
    // Gradient loop.
    //

    if (m_eWipeStyle == DXWD_HORIZONTAL)
    {
        ULONG ulGradWgtStart = bndsSrc.Left() - bndsGrad.Left();
    
        for (ulOutY = 0; *pbContinue && (ulOutY < ulDestHeight); ulOutY++)
        {
            // Get B samples

            pInB->MoveToRow(ulOutY);
            pInB->UnpackPremult(pRowBuff, ulDestWidth, FALSE);

            // Get A samples

            pInA->MoveToRow(ulOutY);
            pInA->UnpackPremult(pGradBuff, ulDestWidth, FALSE);

            _DoGradientMMXHorz(pRowBuff, pGradBuff, 
                               &m_pulGradientWeights[ulGradWgtStart], 
                               ulDestWidth);

            if (fDirectCopy)
            {
                // If we've been modifying the output pixels directly, just
                // reset the buffer pointer to the beginning of the next row.

                pRowBuff = (DXPMSAMPLE *)(((BYTE *)pRowBuff) + nti.lPitch);
            }
            else
            {
                // Get the output row.

                pOut->MoveToRow(ulOutY);

                // Dither if needed.

                if (DoDither())
                {
                    DXDitherArray(&dxdd);
                    dxdd.y++;
                }

                // Copy buffer to output surface.

                if (DoOver())
                {
                    pOut->OverArrayAndMove(pOutBuff, pRowBuff, ulDestWidth);
                }
                else
                {
                    pOut->PackPremultAndMove(pRowBuff, ulDestWidth);
                }
            } // if (!fDirectCopy)
        } // End for
    }
    else // (m_eWipeStyle == DXWD_VERTICAL)
    {
        ULONG ulGradWgtStart = bndsSrc.Top() - bndsGrad.Top();
        
        for(ulOutY = 0; *pbContinue && (ulOutY < ulDestHeight); ulOutY++)
        {
            // Get B samples.

            pInB->MoveToRow(ulOutY);
            pInB->UnpackPremult(pRowBuff, ulDestWidth, FALSE);

            // Get A samples.

            pInA->MoveToRow(ulOutY);
            pInA->UnpackPremult(pGradBuff, ulDestWidth, FALSE);

            ULONG ulWgt = m_pulGradientWeights[ulGradWgtStart + ulOutY];
                
            for (ULONG i = 0; i < ulDestWidth; i++)
            {
                pRowBuff[i] = DXScaleSample(pGradBuff[i], ulWgt ^ 0xFF) + 
                              DXScaleSample(pRowBuff[i], ulWgt); 
            }

            if (fDirectCopy)
            {
                // If we've been modifying the output pixels directly, just
                // reset the buffer pointer to the beginning of the next row.

                pRowBuff = (DXPMSAMPLE *)(((BYTE *)pRowBuff) + nti.lPitch);
            }
            else
            {
                // Get the output row

                pOut->MoveToRow(ulOutY);

                if (DoDither())
                {
                    DXDitherArray(&dxdd);
                    dxdd.y++;
                }

                if (DoOver())
                {
                    pOut->OverArrayAndMove(pOutBuff, pRowBuff, ulDestWidth);
                }
                else
                {
                    pOut->PackPremultAndMove(pRowBuff, ulDestWidth);
                }
            } // if (!fDirectCopy)
        } // End for
    }

done:
    
    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTWipeBase::_DrawGradientRect


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTWipeBase::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    m_lPrevGradMax = m_lCurGradMax;

    // Calling IsOutputDirty clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTWipeBase::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::get_WipeStyle, IDXTWipe
//
//  Description:    This method is used to get the current wipe style.
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTWipeBase::get_WipeStyle(DXWIPEDIRECTION *pVal)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if(DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        hr = E_POINTER;
        goto done;
    }

    *pVal = m_eWipeStyle;

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTWipeBase::get_WipeStyle, IDXTWipe


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::put_WipeStyle, IDXTWipe
//
//  Description:    This method is used to specify whether the wipe is 
//                  horizontal or vertical.
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTWipeBase::put_WipeStyle(DXWIPEDIRECTION newVal)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (newVal != DXWD_HORIZONTAL && newVal != DXWD_VERTICAL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (newVal == m_eWipeStyle)
    {
        goto done;
    }

    hr = _UpdateStepResAndGradWeights(m_flGradPercentSize);

    if (FAILED(hr))
    {
        goto done;
    }

    m_eWipeStyle = newVal;

    SetDirty();

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTWipeBase::put_WipeStyle, IDXTWipe


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::get_GradientSize, IDXTWipe
//
//  Description:    This method is used to get the size of the transition area 
//                  between image A and image B.
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTWipeBase::get_GradientSize(float *pflPercentSize)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (DXIsBadWritePtr(pflPercentSize, sizeof(*pflPercentSize)))
    {
        hr = E_POINTER;
        goto done;
    }

    *pflPercentSize = m_flGradPercentSize;

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTWipeBase::get_GradientSize, IDXTWipe


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::put_GradientSize, IDXTWipe
//
//  Description:    This method is used to set the size of the transition area 
//                  between image A and image B.
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTWipeBase::put_GradientSize(float flPercentSize)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (flPercentSize < 0.0F || flPercentSize > 1.0F)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    if (flPercentSize == m_flGradPercentSize)
    {
        goto done;
    }

    hr = _UpdateStepResAndGradWeights(flPercentSize);

    if (FAILED(hr))
    {
        goto done;
    }

    m_flGradPercentSize = flPercentSize;

    SetDirty();

done:
    
    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTWipeBase::put_GradientSize, IDXTWipe


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::get_Motion, IDXTWipe2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTWipeBase::get_Motion(BSTR * pbstrMotion)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrMotion)
    {
        return E_POINTER;
    }

    if (*pbstrMotion != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrMotion = SysAllocString(s_astrMotion[m_eMotion]);

    if (NULL == *pbstrMotion)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTWipeBase::get_Motion, IDXTWipe2


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::put_Motion, IDXTWipe2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTWipeBase::put_Motion(BSTR bstrMotion)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrMotion)
    {
        return E_POINTER;
    }

    for ( ; i < (int)MOTION_MAX ; i++)
    {
        if (!_wcsicmp(bstrMotion, s_astrMotion[i]))
        {
            break;
        }
    }

    if ((int)MOTION_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eMotion != i)
    {
        m_eMotion = (MOTION)i;

        SetDirty();
    }

    return S_OK;
}
//  CDXTWipeBase::put_Motion, IDXTWipe2


//+-----------------------------------------------------------------------------
//
//  CDXTWipeBase::_DoGradientMMXHorz
//
//------------------------------------------------------------------------------
void _DoGradientMMXHorz(DXPMSAMPLE *pTarget, DXPMSAMPLE *pSource,
                        ULONG *paulWeights, ULONG cWeights)
{
#if defined(_X86_)

    // The global MMX detector tells us there's no MMX instructions by setting
    // MinMMXOverCount() equal to 0xFFFFFFFF.
    //
    // Pixels are processed in pairs, so if there are less than 2 pixels there's
    // no need to do MMX optimization.

    if (   (g_MMXDetector.MinMMXOverCount() == 0xFFFFFFFF)
        || (cWeights < 2))
    {
        goto NonMMXPath;
    }
    else
    {
        ULONG   nCount = cWeights;

        static __int64 MASK  = 0x000000FF000000FF;
        static __int64 MASK2 = 0x00FF00FF00FF00FF;
        static __int64 ROUND = 0x0080008000800080;
        //--- TODO do we want to be quad word aligned here?

        //--- Make sure we have an even count
        bool fDoTrailing = false;
        if( nCount & 1 )
        {
            fDoTrailing = true;
            --nCount;
        }

        __int64     TempPixel;

        //--- Crank through the middle
        __asm
        {
            xor ebx, ebx	            // offset for the three pointers
            mov edx, pTarget            // edx -> Destination
            mov esi, edx                // esi -> Background source
            mov edi, pSource            // edi -> Foreground source (destination)
            mov ecx, nCount             // ecx = loop count
            mov eax, paulWeights        // eax -> Alpha values (gradient weights)

            //  prolog: prime the pump
            //
            pxor      mm0,mm0           //      mm0 = 0000 0000 0000 0000
            movq      mm7,MASK          //      mm7 = 0000 00FF 0000 00FF

            movq      mm1,[eax+ebx]     // 1.01 mm1= 0000 00a2 0000 00a1
                                        // 2.01 Unpaired
            pxor      mm1,MASK          // 1.03 mm1= 0000 1-a2 0000 1-a1
                                        // 2.03 Unpaired
            movq      mm2,mm1           // 2.04 mm2= 0000 1-a2 0000 1-a1
            punpcklwd mm1,mm1           // 1.05 mm1= 0000 0000 1-a1 1-a1
            punpckhwd mm2,mm2           // 2.05 mm2= 0000 0000 1-a2 1-a2
            punpcklwd mm1,mm1           // 1.06 mm1= 1-a1 1-a1 1-a1 1-a1
            punpcklwd mm2,mm2           // 2.06 mm2= 1-a2 1-a2 1-a2 1-a2

            movq      mm3,[edi+ebx]     // 3.04 mm3= Aa Ar Ag Ab Ba Br Bg Bb
            movq      mm4,mm3           // 4.05 mm4= Aa Ar Ag Ab Ba Br Bg Bb
            punpcklbw mm3,mm0           // 3.06 mm3=  00Ba  00Br  00Bg  00Bb

            shr ecx, 1                  // divide loop counter by 2; pixels are processed in pairs
            dec ecx                     // do one less loop to correct for prolog/postlog
            jz skip                     // if original loop count=2

    loopb:
            punpckhbw mm4,mm0           // 4.06 mm4=  00Aa  00Ar  00Ag  00Ab 
            pmullw    mm3,mm1           // 3.07 mm3=  (1-Fa)*B

            pmullw    mm4,mm2           // 4.07 mm4=  (1-Ga)*A      // <PN 05/13/99> Stopped fixing r/b switch here

            // Flip the masks back so we can scale the source pixel
            pxor      mm1,MASK2         // **PRN mm1= 00a1 00a1 00a1 00a1   XFER FROM SECOND HALF BELOW
            pxor      mm2,MASK2         // **PRN mm2= 00a2 00a2 00a2 00a2   XFER FROM SECOND HALF BELOW

            paddw     mm3,ROUND         // 3.08 mm3=  prod+128=FBr
            add       ebx,8             //      increment offset
            paddw     mm4,ROUND         // 4.08 mm4=  prod+128=Gar

            movq      mm5,mm3           // 5.09 mm5=  FBr
            movq      mm6,mm4           // 6.09 mm6=  GAr

            psrlw     mm5,8             // 5.10 mm5=  FBr>>8 
            psrlw     mm6,8             // 6.10 mm6=  GAr>>8 

            paddw     mm5,mm3           // 5.11 mm5=  FBr+(FBr>>8)
            paddw     mm6,mm4           // 6.11 mm6=  GAr+(GAr>>8)

            psrlw     mm5,8             // 5.12 mm5= (FBr+(FBr>>8)>>8)= 00Sa 00Sr 00Sg 00Sb
            psrlw     mm6,8             // 6.12 mm6= (GAr+(GAr>>8)>>8)= 00Ta 00Tr 00Tg 00Tb

            movq      mm3,[esi+ebx-8]   // **PRN mm3= Ca Cr Cg Cb Da Dr Dg Db
            packuswb  mm5,mm6           // 5.13 mm5= Ta Tr Tg Tb Sa Sr Sg Sb 

            movq      mm4,mm3           // **PRN mm4= Ca Cr Cg Cb Da Dr Dg Db

            punpcklbw mm3,mm0           // **PRN mm3=  00Da  00Dr  00Dg  00Db
            punpckhbw mm4,mm0           // **PRN mm4=  00Ca  00Cr  00Cg  00Cb 

            pmullw    mm3,mm1           // **PRN mm3=  (a1)*B
            pmullw    mm4,mm2           // **PRN mm4=  (a2)*A

            movq      mm1,[eax+ebx]     // 1.01 mm1= 0000 00a1 0000 00a2
            movq      mm2,mm5           // **PRN move result from first scale into mm2

            paddw     mm3,ROUND         // **PRN mm3=  prod+128=FBr
            paddw     mm4,ROUND         // **PRN mm4=  prod+128=Gar

            pxor      mm1,mm7           //+1.03 mm1= 0000 1-a2 0000 1-a1

            movq      mm5,mm3           // **PRN mm5=  FBr
            movq      mm6,mm4           // **PRN mm6=  GAr

            psrlw     mm5,8             // **PRN mm5=  FBr>>8 
            psrlw     mm6,8             // **PRN mm6=  GAr>>8 

            paddw     mm5,mm3           // **PRN mm5=  FBr+(FBr>>8)
            paddw     mm6,mm4           // **PRN mm6=  GAr+(GAr>>8)

            psrlw     mm5,8             // **PRN mm5= (FBr+(FBr>>8)>>8)= 00Xa 00Xr 00Xg 00Xb
            psrlw     mm6,8             // **PRN mm6= (GAr+(GAr>>8)>>8)= 00Ya 00Yr 00Yg 00Yb

            packuswb  mm5,mm6           // **PRN mm5= Ta Tr Tg Tb Sa Sr Sg Sb
            paddusb   mm5,mm2           // **PRN add two scaled pixels

    // Setup next iteration
            movq      mm2,mm1           //+2.04 mm2= 0000 1-a2 0000 1-a1
            punpcklwd mm1,mm1           //+1.05 mm1= 0000 0000 1-a1 1-a1

            movq      [edx+ebx-8],mm5   // **PRN store result

            punpckhwd mm2,mm2           //+2.05 mm2= 0000 0000 1-a2 1-a2 
            punpcklwd mm1,mm1           //+1.06 mm1=  1-a1  1-a1  1-a1  1-a1 
            punpcklwd mm2,mm2           //+2.06 mm2=  1-a2  1-a2  1-a2  1-a2 

            movq      mm3,[edi+ebx]     //+3.04 mm3= Aa Ar Ag Ab Ba Br Bg Bb
            movq      mm4,mm3           //+4.05 mm4= Aa Ar Ag Ab Ba Br Bg Bb
            punpcklbw mm3,mm0           //+3.06 mm3=  00Ba  00Br  00Bg  00Bb 
        
            dec ecx                     // decrement loop counter
            jg loopb                    // loop

            // 
            // loop postlog, drain the pump
            //
    skip:
            punpckhbw mm4,mm0           // 4.06 mm4=  00Aa  00Ar  00Ag  00Ab
            pmullw    mm3,mm1           // 3.07 mm3=  (1-Fa)*B
            pmullw    mm4,mm2           // 4.07 mm4=  (1-Ga)*A
            paddw     mm3,ROUND         // 3.08 mm3=  prod+128=FBr
            paddw     mm4,ROUND         // 4.08 mm4=  prod+128=Gar
            movq      mm5,mm3           // 5.09 mm5=  FBr
            movq      mm6,mm4           // 6.09 mm6=  GAr
            psrlw     mm5,8             // 5.10 mm5=  FBr>>8
            psrlw     mm6,8             // 6.10 mm6=  GAr>>8
            paddw     mm5,mm3           // 5.11 mm5=  FBr+(FBr>>8)
            paddw     mm6,mm4           // 6.11 mm6=  GAr+(GAr>>8)
            psrlw     mm5,8             // 5.12 mm5= (FBr+(FBr>>8)>>8)= 00Sa 00Sr 00Sg 00Sb
            psrlw     mm6,8             // 6.12 mm6= (Gar+(GAr>>8)>>8)= 00Ta 00Tr 00Tg 00Tb
            packuswb  mm5,mm6           // 5.13 mm5= Sa Sr Sg Sb Ta Tr Tg Tb
            movq      TempPixel,mm5     // **PRN store to stack for a moment...

            pxor      mm1,MASK2         // **PRN mm1= 00a1 00a1 00a1 00a1
            pxor      mm2,MASK2         // **PRN mm2= 00a2 00a2 00a2 00a2
            movq      mm3,[esi+ebx]     // **PRN mm3= Ca Cr Cg Cb Da Dr Dg Db
            movq      mm4,mm3           // **PRN mm4= Ca Cr Cg Cb Da Dr Dg Db
            punpcklbw mm3,mm0           // **PRN mm3=  00Da  00Dr  00Dg  00Db
            punpckhbw mm4,mm0           // **PRN mm4=  00Ca  00Cr  00Cg  00Cb 

            pmullw    mm3,mm1           // **PRN mm3=  (a1)*B
            pmullw    mm4,mm2           // **PRN mm4=  (a2)*A
            paddw     mm3,ROUND         // **PRN mm3=  prod+128=FBr
            paddw     mm4,ROUND         // **PRN mm4=  prod+128=Gar
            movq      mm5,mm3           // **PRN mm5=  FBr
            movq      mm6,mm4           // **PRN mm6=  GAr
            psrlw     mm5,8             // **PRN mm5=  FBr>>8 
            psrlw     mm6,8             // **PRN mm6=  GAr>>8 
            paddw     mm5,mm3           // **PRN mm5=  FBr+(FBr>>8)
            paddw     mm6,mm4           // **PRN mm6=  GAr+(GAr>>8)
            psrlw     mm5,8             // **PRN mm5= (FBr+(FBr>>8)>>8)= 00Xa 00Xr 00Xg 00Xb
            psrlw     mm6,8             // **PRN mm6= (GAr+(GAr>>8)>>8)= 00Ya 00Yr 00Yg 00Yb
            packuswb  mm5,mm6           // **PRN mm5= Ta Tr Tg Tb Sa Sr Sg Sb

            movq      mm6,TempPixel     // **PRN restore from stack
            paddusb   mm5,mm6           // **PRN add two scaled pixels
            movq      [edx+ebx],mm5     // **PRN store result

            //
            // really done now
            //
            EMMS
        }

        //--- Do the last one non-MMX if the count was odd
        if( fDoTrailing )
        {
            ULONG Wgt = paulWeights[nCount];

            pTarget[nCount] = DXScaleSample(pSource[nCount], Wgt ^ 0xFF) +
                                DXScaleSample(pTarget[nCount], Wgt);
        }
    }

    return;

NonMMXPath:

#endif // defined(_X86_)

    for( ULONG i = 0; i < cWeights; ++i )
    {
        ULONG Wgt = paulWeights[i];
        pTarget[i] = DXScaleSample( pSource[i], Wgt ^ 0xFF ) + 
                     DXScaleSample( pTarget[i], Wgt ); 
    }

    return;
} // _DoGradientMMXHorz
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\filterhelpers.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       filterhelpers.cpp
//
//  Overview:       Helper functions for transforms that are trying to be 
//                  backward compatible with their filter couterparts.
//
//  Change History:
//  1999/09/21  a-matcal    Created.
//  2001/05/30  mcalkins    IE6 Bug 35204
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "filterhelpers.h"
#include "dxclrhlp.h"




HRESULT
FilterHelper_GetColorFromVARIANT(VARIANT varColorParam, DWORD * pdwColor, 
                                 BSTR * pbstrColor)
{
    HRESULT hr          = S_OK;
    BSTR    bstrTemp    = NULL;
    VARIANT varColor;

    Assert(pdwColor);
    Assert(pbstrColor);
    Assert(*pbstrColor == NULL);

    // 2001/05/30 mcalkins
    // IE6 Bug 35204
    // Someone outside of this function is hanging on to a pointer to the
    // original BSTR data in varColorParam.  We used to use VariantChangeType
    // which may release that data, then we'd allocate another BSTR to that same
    // location which would later be released again outside this function
    // causing much havoc.  Now we make a copy of the variant for our uses inside
    // this function.

    ::VariantInit(&varColor);

    hr = ::VariantCopy(&varColor, &varColorParam);

    if (FAILED(hr))
    {
        goto done;
    }

    if (varColor.vt != VT_UI4)
    {
        hr = VariantChangeType(&varColor, &varColor, 0, VT_UI4);
    }

    if (SUCCEEDED(hr)) // It's a number variant.
    {
        *pdwColor = V_UI4(&varColor);
    }
    else // Is it a BSTR variant?
    {
        if (varColor.vt != VT_BSTR)
        {
            hr = VariantChangeType(&varColor, &varColor, 0, VT_BSTR);

            // If this is neither a UI4 or a BSTR, we can't do anything with it.

            if (FAILED(hr))
            {
                goto done;
            }
        }

        hr = DXColorFromBSTR(varColor.bstrVal, pdwColor);

        if (FAILED(hr) && (6 == SysStringLen(varColor.bstrVal)))
        {
            // Nasty back compat issue.  If the color conversion failed, let's
            // try putting a # in front of it because _someone_ decided when
            // they made the original filters not to require it.  grrrr....

            bstrTemp = SysAllocString(L"#RRGGBB");

            if (NULL == bstrTemp)
            {
                hr = E_OUTOFMEMORY;

                goto done;
            }

            wcsncpy(&bstrTemp[1], varColor.bstrVal, 6);

            hr = DXColorFromBSTR(bstrTemp, pdwColor);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

    // If a BSTR representation of our color hasn't been created yet, create it.

    if (NULL == bstrTemp)
    {
        if (varColor.vt != VT_BSTR)
        {
            hr = VariantChangeType(&varColor, &varColor, 0, VT_BSTR);
        }

        if (FAILED(hr))
        {
            goto done;
        }

        bstrTemp = SysAllocString(varColor.bstrVal);

        if (NULL == bstrTemp)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }
    }

    Assert(bstrTemp);

done:

    ::VariantClear(&varColor);

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    *pbstrColor = bstrTemp;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\glow.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    glow.h
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	header file for glow transform implementation CGlow
//
// Change History:
//
// 05/20/99 PhilLu      Move code from dtcss to dxtmsft. New algorithm.
// 09/21/99 a-matcal    Changed color parameter to VARIANT.
// 12/03/99 a-matcal    Add support for IDXTClipOrigin interface.
//
//------------------------------------------------------------------------------

#ifndef __GLOW_H_
#define __GLOW_H_

#include "resource.h"




class ATL_NO_VTABLE CGlow : 
    public CDXBaseNTo1,
    public CComCoClass<CGlow, &CLSID_DXTGlow>,
    public CComPropertySupport<CGlow>,
    public IDispatchImpl<IDXTGlow, &IID_IDXTGlow, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IPersistStorageImpl<CGlow>,
    public ISpecifyPropertyPagesImpl<CGlow>,
    public IPersistPropertyBagImpl<CGlow>,
    public IObjectSafetyImpl2<CGlow>,
    public IDXTClipOrigin
{
private:

    BSTR        m_bstrColor;
    DXSAMPLE    m_rgbColor;
    long        m_lStrength;
    SIZE        m_sizeInput;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    // Helpers

    void _PropagateGlow(DXSAMPLE *pBuffer, int nWidth, int nHeight);

    inline long RandOffset(void)
    {
        const int RAND_RANGE = 32;  // range of random variation of glow color
        return (rand() % (2*RAND_RANGE+1) - RAND_RANGE);
    }

    inline BYTE NClamp(int i)
    {
        return (i < 0 ? 0 : (i > 255 ? 255 : i));
    }

public:

    CGlow();
    virtual ~CGlow();

    DECLARE_POLY_AGGREGATABLE(CGlow)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_GLOW)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CGlow)
        COM_INTERFACE_ENTRY(IDXTGlow)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTClipOrigin)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CGlow>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CGlow)
        PROP_ENTRY("Color"   , 1, CLSID_DXTGlowPP)
        PROP_ENTRY("Strength", 2, CLSID_DXTGlowPP)
        PROP_PAGE(CLSID_DXTGlowPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides

    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing);
    HRESULT OnSetup(DWORD dwFlags);
    void OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                               ULONG aInIndex[], BYTE aWeight[]);
    HRESULT DetermineBnds(CDXDBnds & Bnds);

    // IDXTransform methods.

    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTClipOrigin methods.

    STDMETHOD(GetClipOrigin)(DXVEC * pvecClipOrigin);

    // IDXTGlow methods

    STDMETHOD(get_Color)(VARIANT * pvarColor);
    STDMETHOD(put_Color)(VARIANT varColor);
    STDMETHOD(get_Strength)(long * pval);
    STDMETHOD(put_Strength)(long lStrength);
};

#endif //__GLOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\glow.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    glow.cpp
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	Implementation of CGlow, the Glow transform
//
// Change History:
//
// 05/20/99 PhilLu      Move code from dtcss to dxtmsft. New implementation of
//                      glow algorithm.
// 09/04/99 a-matcal    Fixed some memory overrun issues.
// 09/21/99 a-matcal    Changed color parameter to VARIANT.
// 12/03/99 a-matcal    Implement IDXTClipOrigin interface.
// 12/03/99 a-matcal    Default glow color red.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "glow.h"
#include "filterhelpers.h"


//+-----------------------------------------------------------------------------
//
//  CGlow::CGlow
//
//------------------------------------------------------------------------------
CGlow::CGlow() :
    m_lStrength(5),
    m_bstrColor(NULL)
{
    m_rgbColor      = (DXSAMPLE)0xFFFF0000;

    m_sizeInput.cx  = 0;
    m_sizeInput.cy  = 0;

    // Base class members.

    m_ulMaxImageBands = 1; // disable banding
    m_ulMaxInputs     = 1;
    m_ulNumInRequired = 1;
}
//  CGlow::CGlow


//+-----------------------------------------------------------------------------
//
//  CGlow::~CGlow
//
//------------------------------------------------------------------------------
CGlow::~CGlow()
{
    if (m_bstrColor)
    {
        SysFreeString(m_bstrColor);
    }
}
//  CGlow::~CGlow


//+-----------------------------------------------------------------------------
//
//  CGlow::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CGlow::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_cpUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    m_bstrColor = SysAllocString(L"red");

    if (NULL == m_bstrColor)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CGlow::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CGlow::put_Color, IDXTGlow
//
//------------------------------------------------------------------------------
STDMETHODIMP
CGlow::put_Color(VARIANT varColor)
{
    HRESULT hr          = S_OK;
    DWORD   dwColor     = 0x00000000;
    BSTR    bstrTemp    = NULL;

    hr = FilterHelper_GetColorFromVARIANT(varColor, &dwColor, &bstrTemp);

    if (FAILED(hr))
    {
        goto done;
    }

    _ASSERT(bstrTemp);

    Lock();

    SysFreeString(m_bstrColor);

    m_bstrColor = bstrTemp;
    m_rgbColor  = (DXSAMPLE)dwColor;

    SetDirty();

    Unlock();

done:

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    return hr;
}
//  CGlow::put_Color, IDXTGlow


//+-----------------------------------------------------------------------------
//
//  CGlow::get_Color, IDXTGlow
//
//------------------------------------------------------------------------------
STDMETHODIMP
CGlow::get_Color(VARIANT * pvarColor)
{
    HRESULT hr = S_OK;

    if (NULL == pvarColor)
    {
        hr = E_POINTER;

        goto done;
    }

    _ASSERT(m_bstrColor);

    VariantClear(pvarColor);

    pvarColor->vt       = VT_BSTR;
    pvarColor->bstrVal  = SysAllocString(m_bstrColor);

    if (NULL == pvarColor->bstrVal)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CGlow::get_Color, IDXTGlow


//+-----------------------------------------------------------------------------
//
//  CGlow::get_Strength, IDXTGlow
//
//------------------------------------------------------------------------------
STDMETHODIMP
CGlow::get_Strength(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lStrength;
    return S_OK;
}
//  CGlow::get_Strength, IDXTGlow


//+-----------------------------------------------------------------------------
//
//  CGlow::put_Strength, IDXTGlow
//
//------------------------------------------------------------------------------
STDMETHODIMP
CGlow::put_Strength(long lStrength)
{
    long Strength = min(max(lStrength, 1), 255);

    if (Strength != m_lStrength)
    {
        Lock();
        m_lStrength = Strength;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CGlow::put_Strength, IDXTGlow


//+-----------------------------------------------------------------------------
//
//  CGlow::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CGlow::OnSetup(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CDXDBnds bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (SUCCEEDED(hr))
    {
        bndsIn.GetXYSize(m_sizeInput);
    }

    return hr;

}
//  CGlow::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CGlow::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CGlow::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                             ULONG aInIndex[], BYTE aWeight[])
{
    ulInToTest = 1;
    aInIndex[0] = 0;
    aWeight[0] = 255;
}
//  CGlow::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CGlow::DetermineBnds, CDXBaseNTo1
//
//  This overrides the base function so as to map to an output surface larger
//  than the input surface.
//
//------------------------------------------------------------------------------
HRESULT 
CGlow::DetermineBnds(CDXDBnds & Bnds)
{
    SIZE size;
    Bnds.GetXYSize(size);
    size.cx += (m_lStrength*2);
    size.cy += (m_lStrength*2);
    Bnds.SetXYSize(size);
    return S_OK;
} /* CGlow::DetermineBnds */


//+-----------------------------------------------------------------------------
//
//  CGlow::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CGlow::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing)
{
    HRESULT hr      = S_OK;
    int     y       = 0;

    DXPMSAMPLE * pOutBuff         = NULL;
    DXPMSAMPLE * pPMBuff          = NULL;
    DXSAMPLE *   pOperationBuffer = NULL;
    DXSAMPLE *   pRowInBuffer     = NULL;

    SIZE            sizeOperationBuffer = {0, 0};
    DXDITHERDESC    dxdd;

    CComPtr<IDXARGBReadWritePtr>    pDest;
    CComPtr<IDXARGBReadPtr>         pSrc;

    const int nDoWidth = WI.DoBnds.Width();
    const int nDoHeight = WI.DoBnds.Height();

    // This is the size of the operation buffer we'll need.

    sizeOperationBuffer.cx = m_sizeInput.cx + (m_lStrength * 2);
    sizeOperationBuffer.cy = m_sizeInput.cy + (m_lStrength * 2);

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE, 
                                      IID_IDXARGBReadWritePtr, 
                                      (void**)&pDest, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = InputSurface()->LockSurface(NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    if (DoOver() && OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(nDoWidth);
    }

    //
    //  Set up the dither structure
    //
    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = NULL;                     // to be filled
        dxdd.cSamples       = nDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();     // TODO: ??
    }

    // The output surface has a frame of width m_lStrength. Thus the output
    // surface is 2*Strength larger in both dimensions. Create a buffer the
    // same size as the output surface to hold a copy of the input surface. 
    // Center the input surface in the buffer and pad a frame of value 0. 
    // Note there is an offset m_lStrength from the buffer origin to the start
    // of the input surface.

    // TODO:  Buffering the whole surface is just plain wrong, not to mention
    //        expensive.

    pOperationBuffer = new DXSAMPLE[sizeOperationBuffer.cx * sizeOperationBuffer.cy];

    if (!pOperationBuffer) 
    {
        return E_OUTOFMEMORY;
    }

    memset(pOperationBuffer, 0, 
           sizeOperationBuffer.cx * sizeOperationBuffer.cy * sizeof(DXSAMPLE));

    // Skip m_lStrength rows, as well as m_lStrength pixels on the current row.

    pRowInBuffer = pOperationBuffer + (sizeOperationBuffer.cx * m_lStrength) + m_lStrength;

    for (y = 0; y < m_sizeInput.cy; y++)
    {
        pSrc->MoveToRow(y);
        pSrc->Unpack(pRowInBuffer, m_sizeInput.cx, FALSE);

        pRowInBuffer += sizeOperationBuffer.cx;
    }

    // Create glowing effect in the buffer.

    _PropagateGlow(pOperationBuffer, sizeOperationBuffer.cx, sizeOperationBuffer.cy);

    // Copy the result to output surface.  First move to the correct location of
    // the operation buffer.

    pRowInBuffer = &pOperationBuffer[ 
                    (WI.DoBnds.Top() * sizeOperationBuffer.cx) // Row
                    + WI.DoBnds.Left()                         // + Column
                    ];                         

    for (y = 0; y < nDoHeight; y++)
    {
        // Move to the appropriate row of the output surface.

        pDest->MoveToRow(y);

        if (DoDither())
        {
            dxdd.pSamples = pRowInBuffer;
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            pPMBuff = DXPreMultArray(pRowInBuffer, nDoWidth);
            pDest->OverArrayAndMove(pOutBuff, pPMBuff, nDoWidth);
        }
        else
        {
            pDest->PackAndMove(pRowInBuffer, nDoWidth);
        }

        pRowInBuffer += sizeOperationBuffer.cx;
    }

    delete [] pOperationBuffer;

    return hr;
}
//  CGlow::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CGlow::MapBoundsOut2In, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CGlow::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                       ULONG ulInIndex, DXBNDS * pInBounds)
{
    CDXDBnds    bndsInput;

    if (ulOutIndex || ulInIndex)
    {
        return E_INVALIDARG;
    }

    if (!pOutBounds || !pInBounds)
    {
        return E_POINTER;
    }

    if (NULL == InputSurface())
    {
        return E_UNEXPECTED;
    }

    *pInBounds = *pOutBounds;

    // Glow needs an input area that is the output area plus a border of 
    // m_lStrength pixels to properly render the requested output area.

    pInBounds->u.D[DXB_X].Min -= m_lStrength;
    pInBounds->u.D[DXB_X].Max += m_lStrength;
    pInBounds->u.D[DXB_Y].Min -= m_lStrength;
    pInBounds->u.D[DXB_Y].Max += m_lStrength;

    bndsInput.SetXYSize(m_sizeInput);

    ((CDXDBnds *)pInBounds)->IntersectBounds(bndsInput);

    return S_OK;
}
//  CGlow::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  CGlow::GetClipOrigin, IDXTClipOrigin
//
//------------------------------------------------------------------------------
STDMETHODIMP
CGlow::GetClipOrigin(DXVEC * pvecClipOrigin)
{
    if (NULL == pvecClipOrigin)
    {
        return E_POINTER;
    }

    pvecClipOrigin->u.D[DXB_X] = m_lStrength;
    pvecClipOrigin->u.D[DXB_Y] = m_lStrength;

    return S_OK;
}
//  CGlow::GetClipOrigin, IDXTClipOrigin


//+-----------------------------------------------------------------------------
//
//  CGlow::_PropagateGlow
//
//  Propagate the alpha value of opaque pixels to transparent pixels to create
//  the glowing effect. The algorithm is similar to the "Mathematical 
//  Morphology" type of algorithm and it scans the image twice.
//
//------------------------------------------------------------------------------
void 
CGlow::_PropagateGlow(DXSAMPLE *pOperationBuffer, int nWidth, int nHeight)
{
    int iCol        = 0;
    int iRow        = 0;
    int iAlphaStep  = 255 / (m_lStrength + 1);
    int iNoise      = 0;
    int iAlpha      = 0;

    DXSAMPLE * pBufRow = NULL;
    DXSAMPLE * pBufPix = NULL;

    // Scan the image twice. The first time is normal scan direction (top-down, 
    // left-right). Add glow effect to the current pixel if either the top or
    // left neighbour (which are scanned before the current pixel) has 
    // sufficiently larger alpha value than the alpha of the current pixel. 
    // Every generation of propagation decreases the alpha value by
    // iAlphaStep = 255/(m_lStrength+1). Thus it takes a maximum of m_lStrength
    // steps to propapage a solid color to transparent ones.

    pBufRow = pOperationBuffer + nWidth;
    for (iRow = 1; iRow < nHeight; iRow++, pBufRow += nWidth)
    {
        pBufPix = pBufRow + 1;
        for (iCol = 1; iCol < nWidth; iCol++, pBufPix++)
        {
            iAlpha = max((pBufPix-1)->Alpha, (pBufPix-nWidth)->Alpha)
                     - iAlphaStep;
            if (iAlpha > 0 && pBufPix->Alpha < iAlpha)
            {
                // add glowing effect: change to glow color with a random noise
                // The alpha value is gradually decreasing.
                iNoise = (int) RandOffset();
                pBufPix->Red = NClamp(m_rgbColor.Red + iNoise);
                pBufPix->Green = NClamp(m_rgbColor.Green + iNoise);
                pBufPix->Blue = NClamp(m_rgbColor.Blue + iNoise);
                pBufPix->Alpha = (BYTE)iAlpha;
            }
        }
    }

    // The second time scan the image in reverse order (bottom-up, right to 
    // left). Add glow effect to the current pixel based the bottom or right
    // neighbour. 
    
    pBufRow = pOperationBuffer + nWidth * (nHeight - 2);
    for (iRow = nHeight - 2; iRow >= 0; iRow--, pBufRow -= nWidth)
    {
        pBufPix = pBufRow + nWidth - 2;
        for (iCol = nWidth - 2; iCol >= 0; iCol--, pBufPix--)
        {
            iAlpha = max((pBufPix+1)->Alpha, (pBufPix+nWidth)->Alpha)
                     - iAlphaStep;
            if (iAlpha > 0 && pBufPix->Alpha < iAlpha)
            {
                iNoise = (int) RandOffset();
                pBufPix->Red = NClamp(m_rgbColor.Red + iNoise);
                pBufPix->Green = NClamp(m_rgbColor.Green + iNoise);
                pBufPix->Blue = NClamp(m_rgbColor.Blue + iNoise);
                pBufPix->Alpha = (BYTE)iAlpha;
            }
        }
    }

}
//  CGlow::_PropageteGlow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\filterhelpers.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       filterhelpers.h
//
//  Overview:       Helper functions for transforms that are trying to be 
//                  backward compatible with their filter couterparts.
//
//  Change History:
//  1999/09/21  a-matcal    Created.
//  2001/05/30  mcalkins    IE6 Bug 35204
//
//------------------------------------------------------------------------------





HRESULT FilterHelper_GetColorFromVARIANT(VARIANT varColorParam, 
                                         DWORD * pdwColor, 
                                         BSTR * pbstrColor);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\graddsp.h ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997-2000
//
// FileName:    graddsp.h
//
// Description: Dispatch capable version of the gradient filter.
//
// Change History:
//
// 1997/09/05   mikear      Created.
// 1999/01/25   mcalkins    Fixed property map entries.
// 2000/05/10   mcalkins    Added marshaler, aggregation, cleanup.
//
//------------------------------------------------------------------------------
#ifndef __GradDsp_H_
#define __GradDsp_H_

#include <DTBase.h>
#include "resource.h"




class ATL_NO_VTABLE CDXTGradientD : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CDXTGradientD, &CLSID_DXTGradientD>,
    public CComPropertySupport<CDXTGradientD>,
    public IDispatchImpl<IDXTGradientD, &IID_IDXTGradientD, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CDXTGradientD>,
    public IPersistStorageImpl<CDXTGradientD>,
    public ISpecifyPropertyPagesImpl<CDXTGradientD>,
    public IPersistPropertyBagImpl<CDXTGradientD>
{
private:

    CComBSTR            m_cbstrStartColor;
    CComBSTR            m_cbstrEndColor;
    CComPtr<IUnknown>   m_cpunkGradient;
    CComPtr<IUnknown>   m_cpUnkMarshaler;

    IDXGradient *       m_pGradient;
    IDXTransform *      m_pGradientTrans;
    DXSAMPLE            m_StartColor;
    DXSAMPLE            m_EndColor;
    DXGRADIENTTYPE      m_GradType;
    VARIANT_BOOL        m_bKeepAspect;

public:

    CDXTGradientD();

    // TODO:  I'd like this to be aggregatable, but when I specify this macro,
    //        the object enters into FinalConstruct() with a reference count of
    //        zero instead of one (as it does w/o the macro) which causes the
    //        object to destroy itself when it releases the AddRefs it does
    //        on itself via QI.  

    // DECLARE_POLY_AGGREGATABLE(CDXTGradientD)

    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_GRADDSP)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CDXTGradientD)
        COM_INTERFACE_ENTRY(IDXTGradientD)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTGradientD>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_cpunkGradient.p)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTGradientD)
        PROP_ENTRY("GradientType",      DISPID_GradientType,    CLSID_GradientPP)
        PROP_ENTRY("StartColor",        DISPID_StartColor,      CLSID_GradientPP)
        PROP_ENTRY("EndColor",          DISPID_EndColor,        CLSID_GradientPP)
        PROP_ENTRY("GradientHeight",    DISPID_GradientHeight,  CLSID_GradientPP)
        PROP_ENTRY("GradientWidth",     DISPID_GradientWidth,   CLSID_GradientPP)
        PROP_ENTRY("KeepAspectRatio",   DISPID_GradientAspect,  CLSID_GradientPP)
        PROP_ENTRY("StartColorStr",     DISPID_StartColorStr,   CLSID_GradientPP)
        PROP_ENTRY("EndColorStr",       DISPID_EndColorStr,     CLSID_GradientPP)
        PROP_PAGE( CLSID_GradientPP )
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();
    HRESULT FinalRelease();

    // IDXTGradientD properties.

    STDMETHOD(get_GradientType)(/*[out, retval]*/ DXGRADIENTTYPE *pVal);
    STDMETHOD(put_GradientType)(/*[in]*/ DXGRADIENTTYPE newVal);
    STDMETHOD(get_StartColor)(/*[out, retval]*/ OLE_COLOR *pVal);
    STDMETHOD(put_StartColor)(/*[in]*/ OLE_COLOR newVal);
    STDMETHOD(get_EndColor)(/*[out, retval]*/ OLE_COLOR *pVal);
    STDMETHOD(put_EndColor)(/*[in]*/ OLE_COLOR newVal);
    STDMETHOD(get_GradientWidth)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_GradientWidth)(/*[in]*/ long newVal);
    STDMETHOD(get_GradientHeight)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_GradientHeight)(/*[in]*/ long newVal);
    STDMETHOD(get_KeepAspectRatio)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_KeepAspectRatio)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(get_StartColorStr)(/*[out, retval]*/ BSTR* pVal);
    STDMETHOD(put_StartColorStr)(/*[in]*/ BSTR Color);
    STDMETHOD(get_EndColorStr)(/*[out, retval]*/ BSTR* pVal);
    STDMETHOD(put_EndColorStr)(/*[in]*/ BSTR Color);
};

#endif //__GradDsp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\gridbase.cpp ===
//+-----------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       \aspen\src\dxt\packages\msft\src\gridbase.cpp
//
//  Contents:   A base class for grid oriented transforms.
//
//  Created By: a-matcal
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "gridbase.h"




// 
// ----- CGridBase methods -----
//


//+-----------------------------------------------------------------------------
//
//  CGridBase::CGridBase
//
//------------------------------------------------------------------------------
CGridBase::CGridBase() :
    m_padwGrid(NULL),
    m_paulIndex(NULL),
    m_paulBordersX(NULL),
    m_paulBordersY(NULL),
    m_ulPrevProgress(0),
    m_cbndsDirty(0),
    m_fGridDirty(true),
    m_fOptimizationPossible(false),
    m_fOptimize(false)
{
    m_sizeGrid.cx     = 16;
    m_sizeGrid.cy     = 16;

    m_sizeInput.cx    = 0;
    m_sizeInput.cy    = 0;

    // CDXBaseNTo1 base class members

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0F;
}
//  CGridBase::CGridBase

    
//+-----------------------------------------------------------------------------
//
//  CGridBase::~CGridBase
//
//------------------------------------------------------------------------------
CGridBase::~CGridBase()
{
    if (m_padwGrid)
    {
        delete [] m_padwGrid;
    }

    if (m_paulIndex)
    {
        delete [] m_paulIndex;
    }

    if (m_paulBordersX)
    {
        delete [] m_paulBordersX;
    }

    if (m_paulBordersY)
    {
        delete [] m_paulBordersY;
    }
}
//  CGridBase::~CGridBase


//+-----------------------------------------------------------------------------
//
//  CGridBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CGridBase::FinalConstruct()
{
    return _CreateNewGridAndIndex(m_sizeGrid);
}
//  CGridBase::FinalConstruct


//+-----------------------------------------------------------------------------
//
//  CGridBase::_CreateNewGridAndIndex
// 
//  Overview:   This function allocates memory for a new grid, index, and border
//              position arrays if the size of the grid changes.  It is called
//              once from FinalContruct() for initialization and from the 
//              property functions put_gridSizeY() and put_gridSizeX().
//              
//  Arguments:  sizeNewGrid   The desired grid size. 
//
//  Returns:    S_OK            new objects were created propertly.
//              E_OUTOFMEMORY   new objects could not be created for lack of
//                              memory.
//
//------------------------------------------------------------------------------
HRESULT
CGridBase::_CreateNewGridAndIndex(SIZE & sizeNewGrid)
{
    HRESULT hr = S_OK;

    DWORD * padwGrid        = NULL;
    ULONG * paulIndex       = NULL;
    ULONG * paulBordersX    = NULL;
    ULONG * paulBordersY    = NULL;

    padwGrid = new DWORD[sizeNewGrid.cx * sizeNewGrid.cy];

    if (NULL == padwGrid)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    paulIndex = new ULONG[sizeNewGrid.cx * sizeNewGrid.cy];

    if (NULL == paulIndex)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    paulBordersX = new ULONG[sizeNewGrid.cx + 1];

    if (NULL == paulBordersX)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    paulBordersY = new ULONG[sizeNewGrid.cy + 1];

    if (NULL == paulBordersY)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

done:

    if (FAILED(hr))
    {
        if (padwGrid)
        {
            delete [] padwGrid;
        }

        if (paulIndex)
        {
            delete [] paulIndex;
        }

        if (paulBordersX)
        {
            delete [] paulBordersX;
        }

        if (paulBordersY)
        {
            delete [] paulBordersY;
        }

        return hr;
    }

    // Success

    if (m_padwGrid)
    {
        delete [] m_padwGrid;
    }

    if (m_paulIndex)
    {
        delete [] m_paulIndex;
    }

    if (m_paulBordersX)
    {
        delete [] m_paulBordersX;
    }

    if (m_paulBordersY)
    {
        delete [] m_paulBordersY;
    }

    m_padwGrid      = padwGrid;
    m_paulIndex     = paulIndex;
    m_paulBordersX  = paulBordersX;
    m_paulBordersY  = paulBordersY;

    return S_OK;
}
//  CGridBase::_CreateNewGridAndIndex


//+-----------------------------------------------------------------------------
//
//  CGridBase::_GenerateBoundsFromGrid
//
//------------------------------------------------------------------------------
HRESULT 
CGridBase::_GenerateBoundsFromGrid()
{
    HRESULT hr          = S_OK;
    DWORD * padwCurRow  = NULL;

    int x = 0;
    int y = 0;

    _ASSERT(m_padwGrid != NULL);

    m_cbndsDirty = 0;

    for (y = 0; y < m_sizeGrid.cy; y++)
    {
        padwCurRow = &m_padwGrid[y * m_sizeGrid.cx];

        for (x = 0; x < m_sizeGrid.cx; x++)
        {
            if (padwCurRow[x] & GRID_DRAWCELL)
            {
                DWORD       dw = 0;
                RECT        rc;

                CDXDBnds    bnds;
                CDirtyBnds  dbnds;

                // A block has been found, determine its dimensions and remove
                // it's cells' draw flags.  The steps to do this are:
                // A.  Determine the width, right edge.
                // B.  Determine the height, bottom edge.
                // C.  Calculate the actual surface bounds and add a new bounds
                //     structure to the array.

                rc.left     = x;
                rc.top      = y;
                rc.right    = x + 1;
                rc.bottom   = y + 1;

                dw = padwCurRow[x];

                padwCurRow[x] &= (~GRID_DRAWCELL);

                // A. Find the right edge of this block (width).

                while (((x + 1) < m_sizeGrid.cx) && (padwCurRow[x + 1] == dw))
                {
                    rc.right++;
                    x++;

                    padwCurRow[x] &= (~GRID_DRAWCELL);
                } // block width loop.

                // B. Find the bottom edge of this block (height).

                while (rc.bottom < m_sizeGrid.cy)
                {
                    int     x2 = 0;
                    DWORD * padwCandidateRow = &m_padwGrid[rc.bottom * m_sizeGrid.cx];

                    // This loop performs 3 tests on each candidate row to make
                    // sure we should expand the vertical height of the block.
                    // 1.  The left edge must match.
                    // 2.  The right edge must match.
                    //
                    //   If the cells needing to be painted spill over the right
                    //   or left edges, it's more optimal for them to be placed
                    //   in a different block.
                    //
                    // 3.  All the cells between the left and right edge must
                    //     require painting of the same input.


                    // 1. If the left edge of our block is not the left edge of
                    // the matrix AND the cell to the left of our block on this
                    // row is the same as the cell type we're looking for, these
                    // cells don't belong in our block.  Exit.
                   
                    if ((rc.left > 0)
                        && (padwCandidateRow[rc.left - 1] == dw))
                    {
                        break;
                    }

                    // 2. If the right edge of our block is not touching the
                    // right edge of the matrix AND the cell to our right is the
                    // same as the cell type we're looking for, these cells
                    // don't belong in our block.  Exit.

                    if ((rc.right < m_sizeGrid.cx) 
                        && (padwCandidateRow[rc.right] == dw))
                    {
                        break;
                    }

                    // 3. Traverse the cells that would be a part of our block 
                    // to see if they are all the appropriate type.

                    x2 = rc.left;
                    
                    while (x2 < rc.right && padwCandidateRow[x2] == dw)
                    {
                        x2++;
                    }

                    // If we didn't traverse all the way to the right edge of 
                    // our block, these cells don't belong in our block.  Exit.

                    if (x2 < rc.right)
                    {
                        break;
                    }

                    // These cells belong in our block so traverse the cells
                    // again to remove the draw flag from each of them.

                    for (x2 = rc.left; x2 < rc.right; x2++)
                    {
                        padwCandidateRow[x2] &= (~GRID_DRAWCELL);
                    }

                    // Increase the vertical size of our block to include the
                    // cells in this row.

                    rc.bottom++;

                } // block height loop.

                // C. Create new bounds from block size, add to array, and keep
                // going.

                rc.left     = m_paulBordersX[rc.left];
                rc.top      = m_paulBordersY[rc.top];
                rc.right    = m_paulBordersX[rc.right];
                rc.bottom   = m_paulBordersY[rc.bottom];

                dbnds.bnds.SetXYRect(rc);
                dbnds.ulInput = dw & 0x0000FFFFL;

                hr = m_dabndsDirty.SetItem(dbnds, m_cbndsDirty);

                if (FAILED(hr))
                {
                    goto done;
                }

                m_cbndsDirty++;
            }
        } // x loop
    } // y loop

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CGridBase::_GenerateBoundsFromGrid


//+-----------------------------------------------------------------------------
//
//  CGridBase::_CalculateBorders
// 
//  Overview:  This function calculates the borders of the squares in the grid
//             in measurements of pixels in the x and y directions. The function
//             should be called in two cases:
//
//      1.  If the grid is dirty this function will be called from 
//          OnInitInstData()
//      2.  The input size has changed this function will be called from 
//          OnSetup()
//
//------------------------------------------------------------------------------
void
CGridBase::_CalculateBorders()
{
    long i = 0;
    float   flTemp1 = (float)m_sizeInput.cx / (float)m_sizeGrid.cx;
    float   flTemp2 = (float)m_sizeInput.cy / (float)m_sizeGrid.cy;

    _ASSERT(m_paulBordersX != NULL);
    _ASSERT(m_paulBordersY != NULL);

    // Calculate horizontal borders.

    m_paulBordersX[0] = 0;

    for (i = 1; i < m_sizeGrid.cx; i++)
    {
        m_paulBordersX[i] = (ULONG)((float)i * flTemp1);
    }

    m_paulBordersX[i] = m_sizeInput.cx;

    // Calculate vertical borders.

    m_paulBordersY[0] = 0;

    for (i = 1; i < m_sizeGrid.cy; i++)
    {
        m_paulBordersY[i] = (ULONG)((float)i * flTemp2);
    }

    m_paulBordersY[i] = m_sizeInput.cy;
}
// CGridBase::_CalculateBorders

   
//
// ----- CDXBaseNTo1 methods -----
//


//+-----------------------------------------------------------------------------
//
//  CGridBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CGridBase::OnSetup(DWORD dwFlags)
{
    HRESULT hr = S_OK;
    
    CDXDBnds bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsIn.GetXYSize(m_sizeInput);

    _CalculateBorders();

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
// CGridBase::OnSetup


//+-----------------------------------------------------------------------------
//
//  CGridBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CGridBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                                 ULONG aInIndex[], BYTE aWeight[])
{
    POINT   ptLoc;
    ULONG   ulX;
    ULONG   ulY;

    ulX = OutPoint.Left();
    ulY = OutPoint.Top();

    ptLoc.x = 0;
    ptLoc.y = 0;

    // Check for out of bounds.

    if ((OutPoint.Left() < 0) || (OutPoint.Left() >= m_sizeInput.cx))
    {
        ulInToTest = 0;
        goto done;
    }

    if ((OutPoint.Top() < 0) || (OutPoint.Top() >= m_sizeInput.cy))
    {
        ulInToTest = 0;
        goto done;
    }

    ulInToTest  = 1;
    aWeight[0]  = 255;

    // Which column?

    while (ptLoc.x < m_sizeGrid.cx)
    {
        if (ulX > m_paulBordersX[ptLoc.x + 1])
        {
            ptLoc.x++;
        }
        else
        {
            break;
        }
    }

    // Which row?

    while (ptLoc.y < m_sizeGrid.cy)
    {
        if (ulY > m_paulBordersY[ptLoc.y + 1])
        {
            ptLoc.y++;
        }
        else
        {
            break;
        }
    }

    aInIndex[0] = m_padwGrid[ptLoc.y * m_sizeGrid.cx + ptLoc.x] & (~GRID_DRAWCELL);
    
done:

    return;
}
//  CGridBase::OnGetSurfacePickOrder


//+-----------------------------------------------------------------------------
//
//  CGridBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CGridBase::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;
    
    ULONG   ulMax       = m_sizeGrid.cx * m_sizeGrid.cy;
    ULONG   ulProgress  = (ULONG)(GetEffectProgress() * ((float)ulMax + 0.5F));
    ULONG   i           = 0;

    if (m_fGridDirty)
    {
        OnDefineGridTraversalPath();
        _CalculateBorders();
        m_fGridDirty = false;
    }

    // If the inputs, output, or transform is dirty, or if we can't optimize we
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize
        || !m_fOptimizationPossible)
    {
        for (i = 0; i < ulProgress; i++)
        {
            m_padwGrid[m_paulIndex[i]] = GRID_DRAWCELL | 1;
        }

        for (i = ulProgress; i < ulMax; i++)
        {
            m_padwGrid[m_paulIndex[i]] = GRID_DRAWCELL;
        }
    }
    else // Create optimized dirty bounds.
    {
        if (ulProgress == m_ulPrevProgress)
        {
            m_cbndsDirty = 0;
            goto done;
        }

        // TODO: Clear matrix.

        if (ulProgress > m_ulPrevProgress)
        {
            // We're going forward in the spiral, fill cells with input B.

            for (i = m_ulPrevProgress; i < ulProgress; i++)
            {
                m_padwGrid[m_paulIndex[i]] = GRID_DRAWCELL | 1;
            }
        }
        else
        {
            // We're going backward in the spiral, fill cells with input A.

            for (i = ulProgress; i < m_ulPrevProgress; i++)
            {
                m_padwGrid[m_paulIndex[i]] = GRID_DRAWCELL;
            }
        }
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

    m_ulPrevProgress = ulProgress;

    hr = _GenerateBoundsFromGrid();

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
// CGridBase::OnInitInstData


//+-----------------------------------------------------------------------------
//
//  CGridBase::WorkProc, CDXBaseNTo1
//
//  Overview:   This function is used to calculate the result based on the
//              specified bounds and the current effect progress.
//
//------------------------------------------------------------------------------
HRESULT 
CGridBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    DWORD   dwFlags         = 0;
    long    lInOutOffsetX   = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY   = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    for (ULONG i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;
        CDirtyBnds  dbnds;

        hr = m_dabndsDirty.GetItem(dbnds, i);

        if (FAILED(hr))
        {
            goto done;
        }

        if (bndsSrc.IntersectBounds(WI.DoBnds, dbnds.bnds))
        {
            bndsDest = bndsSrc;
            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            hr = DXBitBlt(OutputSurface(), bndsDest,
                          InputSurface(dbnds.ulInput), bndsSrc,
                          dwFlags, INFINITE);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
// CGridBase::WorkProc


//+-----------------------------------------------------------------------------
//
//  CGridBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CGridBase::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CGridBase::OnFreeInstData


//
//  ----- IDXTGridSize methods -----
//


//+-----------------------------------------------------------------------------
//
//  CGridBase::get_gridSizeX, IDXTGridSize
//
//  Overview:   Get the horizontal grid size (number of cells in a row)
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CGridBase::get_gridSizeX(short * pX)
{
    if (!pX)
    {
        return E_POINTER;
    }

    *pX = (short)m_sizeGrid.cx;

    return S_OK;
}
//  CGridBase::get_gridSizeX


//+-----------------------------------------------------------------------------
//
//  CGridBase::put_gridSizeX, IDXTGridSize
//
//  Overview:   Set the horizontal grid size (number of cells in a row)
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CGridBase::put_gridSizeX(short newX)
{
    HRESULT hr = S_OK;

    if (newX > 0 && newX < 101)
    {
        if (m_sizeGrid.cx != newX)
        {
            SIZE szNew = m_sizeGrid;

            szNew.cx = newX;

            hr = _CreateNewGridAndIndex(szNew);

            if (FAILED(hr))
            {
                goto done;
            }

            Lock();
            m_sizeGrid.cx   = newX;
            m_fGridDirty    = true;
            Unlock();

            SetDirty();
        }
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CGridBase::put_gridSizeX


//+-----------------------------------------------------------------------------
//
//  CGridBase::get_gridSizeY, IDXTGridSize
//
//  Overview:   Get the vertical grid size (number of cells in a column)
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CGridBase::get_gridSizeY(short *pY)
{
    if (!pY)
    {
        return E_POINTER;
    }

    *pY = (short)m_sizeGrid.cy;

    return S_OK;
}
//  CGridBase::get_gridSizeY


//+-----------------------------------------------------------------------------
//
//  CGridBase::put_gridSizeY, IDXTGridSize
//
//  Overview:   Set the vertical grid size (number of cells in a column)
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CGridBase::put_gridSizeY(short newY)
{
    HRESULT hr = S_OK;

    if (newY > 0 && newY < 101)
    {
        if (m_sizeGrid.cy != newY)
        {
            SIZE szNew = m_sizeGrid;

            szNew.cy = newY;

            hr = _CreateNewGridAndIndex(szNew);

            if (FAILED(hr))
            {
                goto done;
            }

            Lock();
            m_sizeGrid.cy   = newY;
            m_fGridDirty    = true;
            Unlock();

            SetDirty();
        }
    }
    else
    {
        hr = E_INVALIDARG;
        goto done;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CGridBase::put_gridSizeY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\graddsp.cpp ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997-2000
//
// FileName:    graddsp.cpp
//
// Description: Dispatch capable version of the gradient filter.
//
// Change History:
//
// 1997/09/05   mikear      Created.
// 2000/05/10   mcalkisn    Cleaned up construction.
//
//------------------------------------------------------------------------------
#include "stdafx.h"
#include <DXTrans.h>
#include "GradDsp.h"
#include <DXClrHlp.h>




//+-----------------------------------------------------------------------------
//
//  Method: CDXTGradientD::CDXTGradientD
//
//------------------------------------------------------------------------------
CDXTGradientD::CDXTGradientD() :
    m_pGradientTrans(NULL),
    m_pGradient(NULL),
    m_StartColor(0xFF0000FF),
    m_EndColor(0xFF000000),
    m_GradType(DXGRADIENT_VERTICAL),
    m_bKeepAspect(false)
{
}
//  Method: CDXTGradientD::CDXTGradientD

    
/////////////////////////////////////////////////////////////////////////////
// CDXTGradientD
/*****************************************************************************
* CDXTGradientD::FinalConstruct *
*---------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXTGradientD::FinalConstruct()
{
    HRESULT     hr          = S_OK;
    BSTR        bstr        = NULL;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_cpUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    bstr = SysAllocString(L"#FF0000FF");

    if (NULL == bstr)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    m_cbstrStartColor.Attach(bstr);

    bstr = SysAllocString(L"#FF000000");

    if (NULL == bstr)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    m_cbstrEndColor.Attach(bstr);

    hr = ::CoCreateInstance(CLSID_DXGradient, GetControllingUnknown(), 
                            CLSCTX_INPROC, __uuidof(IUnknown), 
                            (void **)&m_cpunkGradient);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_cpunkGradient->QueryInterface(__uuidof(IDXTransform), 
                                         (void **)&m_pGradientTrans);

    if (FAILED(hr))
    {
        goto done;
    }

    // Querying an aggregated interface causes us to have a reference count on
    // ourself.  This is bad, so call release on the outer object to reduce the
    // count.

    GetControllingUnknown()->Release();

    hr = m_cpunkGradient->QueryInterface(IID_IDXGradient, 
                                         (void **)&m_pGradient);
    
    if (FAILED(hr))
    {
        goto done;
    }

    // Querying an aggregated interface causes us to have a reference count on
    // ourself.  This is bad, so call release on the outer object to reduce the
    // count.

    GetControllingUnknown()->Release();

done:

    return hr;
} /* CDXTGradientD::FinalConstruct */

/*****************************************************************************
* CDXTGradientD::FinalRelease *
*--------------------------*
*   Description:
*       The inner interfaces are released using COM aggregation rules. Releasing
*   the inner causes the outer to be released, so we addref the outer prior to
*   protect it.
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 05/10/98
*-----------------------------------------------------------------------------
*   
*****************************************************************************/
HRESULT CDXTGradientD::FinalRelease()
{
    // Safely free the inner interfaces held.

    if (m_pGradientTrans)
    {
        GetControllingUnknown()->AddRef();

        m_pGradientTrans->Release();
    }

    if (m_pGradient)
    {
        GetControllingUnknown()->AddRef();

        m_pGradient->Release();
    }

    return S_OK;
} /* CDXTGradientD::FinalRelease */


//
//=== IDXTGradientD ==============================================================
//

/*****************************************************************************
* CDXTGradientD::put_StartColor *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_StartColor( OLE_COLOR Color )
{
    USES_CONVERSION;

    HRESULT hr = S_OK;

    if( m_StartColor != Color )
    {
        TCHAR   szStartColor[10];
        BSTR    bstrStartColor;

        // Format OLE_COLOR into a BSTR color.

        wsprintf(szStartColor, _T("#%08X"), Color);

        bstrStartColor = SysAllocString(T2OLE(szStartColor));

        if (bstrStartColor == NULL)
            return E_OUTOFMEMORY;

        // Set gradient color.

        hr = m_pGradient->SetGradient(Color, m_EndColor, 
                                      m_GradType == DXGRADIENT_HORIZONTAL);

        // If everything worked out OK, alter internal property settings.

        if( SUCCEEDED( hr ) )
        {
            m_StartColor = Color;
            m_cbstrStartColor.Empty();
            m_cbstrStartColor.Attach(bstrStartColor);
        }
        else
        {
            SysFreeString(bstrStartColor);
        }
    }

    return hr;
} /* CDXTGradientD::put_StartColor */


/*****************************************************************************
* CDXTGradientD::get_StartColor *
*-------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_StartColor( OLE_COLOR *pColor )
{
    if( DXIsBadWritePtr( pColor, sizeof(*pColor) ) ) return E_POINTER;
    *pColor = m_StartColor;
    return S_OK;
} /* CDXTGradientD::get_StartColor */


/*****************************************************************************
* CDXTGradientD::put_EndColor *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_EndColor( OLE_COLOR Color )
{
    USES_CONVERSION;

    HRESULT hr = S_OK;

    if( m_EndColor != Color )
    {
        TCHAR   szEndColor[10];
        BSTR    bstrEndColor;

        // Format OLE_COLOR into a BSTR color.

        wsprintf(szEndColor, _T("#%08X"), Color);

        bstrEndColor = SysAllocString(T2OLE(szEndColor));

        if (bstrEndColor == NULL)
            return E_OUTOFMEMORY;

        // Set gradient color.

        hr = m_pGradient->SetGradient(m_StartColor, Color, 
                                      m_GradType == DXGRADIENT_HORIZONTAL);

        // If everything worked out OK, alter internal property settings.

        if( SUCCEEDED( hr ) )
        {
            m_EndColor = Color;
            m_cbstrEndColor.Empty();
            m_cbstrEndColor.Attach(bstrEndColor);
        }
        else
        {
            SysFreeString(bstrEndColor);
        }
    }

    return hr;
} /* CDXTGradientD::put_EndColor */


/*****************************************************************************
* CDXTGradientD::get_EndColor *
*-----------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_EndColor( OLE_COLOR *pColor )
{
    if( DXIsBadWritePtr( pColor, sizeof(*pColor) ) ) return E_POINTER;
    *pColor = m_EndColor;
    return S_OK;
} /* CDXTGradientD::get_EndColor */


/*****************************************************************************
* CDXTGradientD::put_GradientType *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_GradientType( DXGRADIENTTYPE Type )
{
    HRESULT hr = S_OK;
    if( Type < DXGRADIENT_VERTICAL || Type > DXGRADIENT_HORIZONTAL )
    {
        hr = E_INVALIDARG;
    }
    else if( m_GradType != Type )
    {
        hr = m_pGradient->SetGradient( m_StartColor, m_EndColor, Type );
        if( SUCCEEDED( hr ) )
        {
            m_GradType = Type;
        }
    }
    return hr;
} /* CDXTGradientD::put_GradientType */


/*****************************************************************************
* CDXTGradientD::get_GradientType *
*---------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_GradientType( DXGRADIENTTYPE *pType )
{
    if( DXIsBadWritePtr( pType, sizeof(*pType) ) ) return E_POINTER;
    *pType = m_GradType;
    return S_OK;
} /* CDXTGradientD::get_GradientType */


/*****************************************************************************
* CDXTGradientD::put_GradientWidth *
*----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_GradientWidth( long lVal )
{
    if( lVal <= 0 ) return E_INVALIDARG;

    SIZE sz;
    m_pGradient->GetOutputSize( &sz );
    sz.cx = lVal;
    return m_pGradient->SetOutputSize( sz, m_bKeepAspect );
} /* CDXTGradientD::put_GradientWidth */


/*****************************************************************************
* CDXTGradientD::get_GradientWidth *
*----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_GradientWidth( long *pVal )
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) ) return E_POINTER;

    SIZE sz;
    m_pGradient->GetOutputSize( &sz );
    *pVal = sz.cx;
    return S_OK;
} /* CDXTGradientD::get_GradientWidth */


/*****************************************************************************
* CDXTGradientD::put_GradientHeight *
*-----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_GradientHeight( long lVal )
{
    if( lVal <= 0 ) return E_INVALIDARG;

    SIZE sz;
    m_pGradient->GetOutputSize( &sz );
    sz.cy = lVal;
    return m_pGradient->SetOutputSize( sz, m_bKeepAspect );
} /* CDXTGradientD::put_GradientHeight */


/*****************************************************************************
* CDXTGradientD::get_GradientHeight *
*-----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_GradientHeight( long *pVal )
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) ) return E_POINTER;

    SIZE sz;
    m_pGradient->GetOutputSize( &sz );
    *pVal = sz.cy;
    return S_OK;
} /* CDXTGradientD::get_GradientHeight */


/*****************************************************************************
* CDXTGradientD::put_KeepAspectRatio *
*------------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_KeepAspectRatio( VARIANT_BOOL b )
{
    HRESULT hr = S_OK;
    if( m_bKeepAspect != b )
    {
        SIZE sz;
        m_pGradient->GetOutputSize( &sz );
        hr = m_pGradient->SetOutputSize( sz, b );

        if( SUCCEEDED( hr ) )
        {
            m_bKeepAspect = b;
        }
    }
    return hr;
} /* CDXTGradientD::put_KeepAspectRatio */


/*****************************************************************************
* CDXTGradientD::get_KeepAspectRatio *
*------------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_KeepAspectRatio( VARIANT_BOOL *pVal )
{
    if( DXIsBadWritePtr( pVal, sizeof(*pVal) ) ) return E_POINTER;
    *pVal = m_bKeepAspect;
    return S_OK;
} /* CDXTGradientD::get_KeepAspectRatio */

/*****************************************************************************
* CDXTGradientD::put_StartColorStr *
*----------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_StartColorStr( BSTR Color )
{
    HRESULT hr      = S_OK;
    DWORD   dwColor = 0;
    
    if (DXIsBadReadPtr(Color, SysStringByteLen(Color)))
        return E_POINTER;

    hr = ::DXColorFromBSTR(Color, &dwColor);

    if( SUCCEEDED( hr ) )
    {
        // Copy the Color BSTR.

        BSTR bstrStartColor = SysAllocString(Color);

        if (bstrStartColor == NULL)
            return E_OUTOFMEMORY;

        // Set gradient color.

        hr = m_pGradient->SetGradient(dwColor, m_EndColor, 
                                      m_GradType == DXGRADIENT_HORIZONTAL);

        // If everything worked out OK, alter internal property settings.

        if( SUCCEEDED( hr ) )
        {
            m_StartColor = dwColor;
            m_cbstrStartColor.Empty();
            m_cbstrStartColor.Attach(bstrStartColor);
        }
        else
        {
            SysFreeString(bstrStartColor);
        }
    }

    return hr;
} /* CDXTGradientD::put_StartColorStr */


/*****************************************************************************
* CDXTGradientD::get_StartColorStr *
*--------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Matt Calkins                                    Date: 01/25/99
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_StartColorStr(BSTR* pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;

    *pVal = m_cbstrStartColor.Copy();

    if (NULL == *pVal)
        return E_OUTOFMEMORY;

    return S_OK;
} /* CDXTGradientD::get_StartColorStr */


/*****************************************************************************
* CDXTGradientD::put_EndColorStr *
*--------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Mike Arnstein                            Date: 06/06/98
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::put_EndColorStr( BSTR Color )
{
    HRESULT hr      = S_OK;
    DWORD   dwColor = 0;
     
    if (DXIsBadReadPtr(Color, SysStringByteLen(Color)))
        return E_POINTER;

    hr = ::DXColorFromBSTR(Color, &dwColor);

    if( SUCCEEDED( hr ) )
    {
        // Copy the Color BSTR.

        BSTR bstrEndColor = SysAllocString(Color);

        if (bstrEndColor == NULL)
            return E_OUTOFMEMORY;

        // Set gradient color.

        hr = m_pGradient->SetGradient(m_StartColor, dwColor, 
                                      m_GradType == DXGRADIENT_HORIZONTAL);

        // If everything worked out OK, alter internal property settings.

        if( SUCCEEDED( hr ) )
        {
            m_EndColor = dwColor;
            m_cbstrEndColor.Empty();
            m_cbstrEndColor.Attach(bstrEndColor);
        }
        else
        {
            SysFreeString(bstrEndColor);
        }
    }

    return hr;
} /* CDXTGradientD::put_EndColorStr */


/*****************************************************************************
* CDXTGradientD::get_EndColorStr *
*--------------------------------*
*   Description:
*-----------------------------------------------------------------------------
*   Created By: Matt Calkins                                    Date: 01/25/99
*-----------------------------------------------------------------------------
*   Parameters:
*****************************************************************************/
STDMETHODIMP CDXTGradientD::get_EndColorStr(BSTR* pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;

    *pVal = m_cbstrEndColor.Copy();

    if (NULL == *pVal)
        return E_OUTOFMEMORY;

    return S_OK;
} /* CDXTGradientD::get_EndColorStr */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\guids.c ===
#include <objbase.h>
#include <initguid.h>

#include <ddraw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\gridbase.h ===
//+-----------------------------------------------------------------------------
//
//  Microsoft
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       \aspen\src\dxt\packages\msft\src\gridbase.h
//
//  Contents:   A base class for grid oriented transforms.
//
//  Created By: a-matcal
//
//------------------------------------------------------------------------------

#ifndef __GRIDBASE
#define __GRIDBASE

#include "dynarray.h"

#define GRID_DRAWCELL 0x00010000L




//+-----------------------------------------------------------------------------
//
// CDirtyBnds class
//
//------------------------------------------------------------------------------
class CDirtyBnds
{
public:

    CDXDBnds    bnds;
    ULONG       ulInput;

    CDirtyBnds() : ulInput(0) {};
};


//+-----------------------------------------------------------------------------
//
// CGridBase class
//
//------------------------------------------------------------------------------
class CGridBase :
    public CDXBaseNTo1
{
private:

    DWORD * m_padwGrid;
    ULONG * m_paulBordersX;
    ULONG * m_paulBordersY;

    SIZE    m_sizeInput;

    ULONG   m_ulPrevProgress;
    ULONG   m_cbndsDirty;

    CDynArray<CDirtyBnds>   m_dabndsDirty;

    unsigned    m_fGridDirty            : 1;
    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

private:

    HRESULT _CreateNewGridAndIndex(SIZE & sizeNewGrid);
    HRESULT _GenerateBoundsFromGrid();
    void    _CalculateBorders();

    // CDXBaseNTo1

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1& WI, BOOL* pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);
                                  
protected:

    SIZE    m_sizeGrid;
    ULONG * m_paulIndex;

    virtual HRESULT OnDefineGridTraversalPath() = 0;

public:

    CGridBase();
    virtual ~CGridBase();
    HRESULT FinalConstruct();

    // IDXTGridSize

    STDMETHOD(get_gridSizeX)(/*[out, retval]*/ short *pX);
    STDMETHOD(put_gridSizeX)(/*[in]*/ short newX);
    STDMETHOD(get_gridSizeY)(/*[out, retval]*/ short *pY);
    STDMETHOD(put_gridSizeY)(/*[in]*/ short newY);
};

// Makes it easy for derived classes to implement forwarding functions to the implementations
// of these interface methods, which are actually in this class.

#define DECLARE_IDXTGRIDSIZE_METHODS() \
    STDMETHODIMP get_gridSizeX(short *pX) { return CGridBase::get_gridSizeX(pX); }      \
    STDMETHODIMP put_gridSizeX(short newX) { return CGridBase::put_gridSizeX(newX); }   \
    STDMETHODIMP get_gridSizeY(short *pY) { return CGridBase::get_gridSizeY(pY); }      \
    STDMETHODIMP put_gridSizeY(short newY) { return CGridBase::put_gridSizeY(newY); }

#endif // __GRIDBASE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\image.h ===
//------------------------------------------------------------------------------
//
//  image.h
//
//  This file provides the declaration of the CImage class which is the 
//  class behind the Basic Image transform.
//
//  Created:    1998        EdC, RalhpL
//
//  1998/11/04 mcalkins Added Comments.
//                      Moved sample modification code out of WorkProc and into
//                      private inline functions.
//
//  2000/01/05 mcalkins If mask color alpha is zero, set to 0xFF
//                      Default mask color black instead of clear.
//                      Added support for free threaded marshaler.
//
//  2000/01/25 mcalkins Implement OnSurfacePick instead of OnGetSurfacePickOrder
//                      To ensure that we pass back the transformed input point
//                      even when nothing is hit (the input pixel is clear.)
//
//------------------------------------------------------------------------------

#ifndef __IMAGE_H_
#define __IMAGE_H_

#include "resource.h"




class ATL_NO_VTABLE CImage : 
    public CDXBaseNTo1,
    public CComCoClass<CImage, &CLSID_BasicImageEffects>,
    public CComPropertySupport<CImage>,
    public IDispatchImpl<IDXBasicImage, &IID_IDXBasicImage, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CImage>,
    public IPersistStorageImpl<CImage>,
    public ISpecifyPropertyPagesImpl<CImage>,
    public IPersistPropertyBagImpl<CImage>
{
private:

    CDXScale            m_Scale;
    CDXDBnds            m_InputBounds;

    CComPtr<IUnknown>   m_spUnkMarshaler;

    long                m_Rotation;
    BOOL                m_fMirror;
    BOOL                m_fGrayScale;
    BOOL                m_fInvert;
    BOOL                m_fXRay;
    BOOL                m_fGlow;
    BOOL                m_fMask;
    int                 m_MaskColor;

    // Helper methods.

    void OpInvertColors(DXPMSAMPLE * pBuffer, ULONG ulSize);
    void OpXRay(DXPMSAMPLE * pBuffer, ULONG ulSize);
    void OpGrayScale(DXPMSAMPLE * pBuffer, ULONG ulSize);
    void OpMask(DXPMSAMPLE * pBuffer, ULONG ulSize);
    void FlipBounds(const CDXDBnds & DoBnds, CDXDBnds & Flip);

public:

    CImage();

    DECLARE_POLY_AGGREGATABLE(CImage)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_IMAGE)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CImage)
        COM_INTERFACE_ENTRY(IDXBasicImage)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CImage>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CImage)
        PROP_ENTRY("Rotation"       , 1, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("Mirror"         , 2, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("GrayScale"      , 3, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("Opacity"        , 4, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("Invert"         , 5, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("XRay"           , 6, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("Mask"           , 7, CLSID_BasicImageEffectsPP)
        PROP_ENTRY("MaskColor"      , 8, CLSID_BasicImageEffectsPP)
        PROP_PAGE(CLSID_BasicImageEffectsPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD /*dwFlags*/);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pfContinueProcessing);
    HRESULT DetermineBnds(CDXDBnds & Bnds);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);

    // IDXTransform methods.

    STDMETHODIMP MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                                 ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXBasicImage properties.

    STDMETHOD(get_Rotation)(/*[out, retval]*/ int *pVal);
    STDMETHOD(put_Rotation)(/*[in]*/ int newVal);
    STDMETHOD(get_Mirror)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Mirror)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_GrayScale)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_GrayScale)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_Opacity)(/*[out, retval]*/ float *pVal);
    STDMETHOD(put_Opacity)(/*[in]*/ float newVal);
    STDMETHOD(get_Invert)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Invert)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_XRay)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_XRay)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_Mask)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Mask)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_MaskColor)(/*[out, retval]*/ int *pVal);
    STDMETHOD(put_MaskColor)(/*[in]*/ int newVal);
};

//
// Inline method implementations.
//

////////////////////////////////////////////////////////////////////////////////
//  CImage::OpInvertColors
//
//  This method modifies an array of DXPMSAMPLEs by inverting the color portion
//  of the samples.
//
////////////////////////////////////////////////////////////////////////////////
inline void CImage::OpInvertColors(DXPMSAMPLE* pBuffer, ULONG ulSize)
{
    for (ULONG x = 0 ; x < ulSize ; x++)
    {
        // Don't do any work if there's no alpha.

        if (pBuffer[x].Alpha != 0)
        {
            DXSAMPLE s = DXUnPreMultSample(pBuffer[x]);
        
            // XOR with 1's to invert the color bits.

            s = (DWORD)s ^ 0x00FFFFFF;

            pBuffer[x] = DXPreMultSample(s);
        }
    }
} // CImage::OpInvertColors


////////////////////////////////////////////////////////////////////////////////
//  CImage::OpXRay
//
//  This method modifies an array of DXPMSAMPLEs by taking the inverse of the
//  average of the red and green components and using that as a gray scale,
//  preserving the alpha.
//
////////////////////////////////////////////////////////////////////////////////
inline void CImage::OpXRay(DXPMSAMPLE* pBuffer, ULONG ulSize)
{
    for (ULONG x = 0 ; x < ulSize ; x++)
    {
        // Don't do any work if there's no alpha.

        if (pBuffer[x].Alpha != 0)
        {
            // Get original RGB values.

            DXSAMPLE    s = DXUnPreMultSample(pBuffer[x]);

            // Determine the level of gray.

            BYTE        gray = (BYTE)(255 - ((s.Red + s.Green) / 2));

            // Create gray scale.

            s = DXSAMPLE(s.Alpha, gray, gray, gray);

            // Copy back to buffer.

            pBuffer[x] = DXPreMultSample(s);
        }
    }
} // CImage::OpXRay


////////////////////////////////////////////////////////////////////////////////
//  CImage::OpGrayScale
//
//  This method modifies an array of DXPMSAMPLEs so that colored pixels are 
//  converted to gray scale.
//
////////////////////////////////////////////////////////////////////////////////
inline void CImage::OpGrayScale(DXPMSAMPLE* pBuffer, ULONG ulSize)
{
    for (ULONG x = 0 ; x < ulSize ; x++)
    {
        // Don't do any work if there's no alpha.

        if (pBuffer[x].Alpha != 0)
        {
            DXPMSAMPLE  s = pBuffer[x];

            // This calculates the Y (luminance) portion of a YIQ (black-and-white TV)
            // color space from the RGB components.  The weights are .299, .587, and .114
            // which are approximately equal to 306/1024, 601/1024 and 117/1024.  It's faster
            // to divide by 1024, that's why this is done with weird weights.  Plus, this
            // way we can do integer math instead of using floating point.  See Foley and
            // van Dam, page 589 for a discussion of this RGB<->YIQ conversion.

            DWORD   dwSaturation = (s.Red * 306 + s.Green * 601 + s.Blue * 117) >> 10;

            s = (DWORD)s & 0xFF000000;
            s = (DWORD)s | (dwSaturation << 16) | (dwSaturation << 8) | dwSaturation;
        
            pBuffer[x] = s;
        }
    }
} //CImage::OpGrayScale


////////////////////////////////////////////////////////////////////////////////
//  CImage::OpMask
//
//  This method modifies an array of DXPMSAMPLEs so that:
//
//  1. Opaque samples become clear.
//  2. Transparent samples take on the alpha and color stored in m_MaskColor.
//  3. Translucent samples have their alpha inverted and take on the color 
//     stored in m_MaskColor.
//
////////////////////////////////////////////////////////////////////////////////
inline void CImage::OpMask(DXPMSAMPLE* pBuffer, ULONG ulSize)
{
    // PreMultiply the mask color for transparent pixels.

    DXPMSAMPLE pmsMaskColor = DXPreMultSample(m_MaskColor);

    for (ULONG x = 0 ; x < ulSize ; x++)
    {
        if (pBuffer[x].Alpha != 0)
        {
            // Non-clear (aka, partially or fully opaque) pixels.

            DXPMSAMPLE s = pBuffer[x];

            if (s.Alpha == 0xFF)
            {
                // Opaque pixels should become transparent.

                pBuffer[x] = 0;
            }
            else
            {
                // Pixels that are translucent invert alpha.

                s = ~((DWORD)s) & 0xFF000000;

                // Set color to mask color.

                s = (DWORD)s | (m_MaskColor & 0x00FFFFFF);

                // We've created a new sample so we need to pre-multiply
                // it before putting it back into the buffer.

                pBuffer[x] = DXPreMultSample(s);
            }
        }
        else
        {
            // Transparent pixels should take on the mask color.

            pBuffer[x] = pmsMaskColor;
        }
    }
} // CImage::OpMask


#endif //__IMAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\inset.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:        inset.cpp
//
// Created:         06/24/98
//
// Author:          PhilLu
//
// Discription:     This file implements the Inset transform.
//
// Revisions:
//
// 06/24/98 phillu      Initial creation.
// 07/09/98 phillu      Implement OnSetSurfacePickOrder().
// 07/22/98 phillu      Implement clipping.
// 06/02/99 a-matcal    Optimization.
// 10/24/99 a-matcal    Changed CInset class to CDXTInsetBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "inset.h"




//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::CDXTInsetBase
//
//------------------------------------------------------------------------------
CDXTInsetBase::CDXTInsetBase() :
    m_cbndsDirty(0),
    m_fOptimizationPossible(false),
    m_fOptimize(false)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    for (int i = 0; i < MAX_INSET_BOUNDS; i++)
    {
        m_aulSurfaceIndex[i] = 0;
    }

    // CDXBaseNTo1 members

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTInsetBase::CDXTInsetBase


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTInsetBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTInsetBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::_CalcFullBounds
//
//  Overview:   This method creates one or three sets of bounds that represent
//              the entire output surface.  
//          
//              One set of bounds is generated if the current progress is close
//              enough to 0.0 or 1.0 so that the output surface should be 
//              entirely Input A or Input B.  
//
//              Three sets of bounds are generated if the current progress is
//              somewhere in the middle.  One set of bounds represents the inset
//              area that is filled with input B.  The other two sets of bounds
//              represent the areas to the right and below the inset bounds and
//              are filled with input A.
//
//              000000011111	
//              000000011111	
//              000000011111	
//              000000011111
//              222222222222
//              222222222222
//
//              0 - inset area       (dirty bound idx 0 Input B)
//              1 - non-inset area 1 (dirty bound idx 1 Input A)
//              2 - non-inset area 2 (dirty bound idx 2 Input A)
//
//
//              Note:  All coordinates are calculated in input space coordinates
//              assuming the entire output will need to be drawn.  Bounds will
//              be clipped and transformed to output space if needed by the 
//              WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTInsetBase::_CalcFullBounds()
{
    HRESULT     hr = S_OK;
    CDXDBnds    bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    if (m_bndsCurInset.BoundsAreEmpty())
    {
        // If the current inset area is empty, paint over the entier output
        // surface with input A.

        m_cbndsDirty          = 1;
        m_abndsDirty[0]         = bndsInput;
        m_aulSurfaceIndex[0]    = 0;
    }
    else if (m_bndsCurInset == bndsInput)
    {
        // If the current inset bounds are equal to the input bounds, paint
        // over the entire output surface with input B.

        m_cbndsDirty          = 1;
        m_abndsDirty[0]         = bndsInput;
        m_aulSurfaceIndex[0]    = 1;
    }
    else
    {
        // In this case the inset is in progress so we pass three sets of 
        // bounds.  The inset area representing input B, and two bounds 
        // representing the rest of the output surface area, input A.

        RECT rcTemp;

        m_cbndsDirty = 3;

        // Inset area.

        m_abndsDirty[0]         = m_bndsCurInset;

        // Portion one of non-inset area.

        m_bndsCurInset.GetXYRect(rcTemp);

        rcTemp.left     = rcTemp.right;
        rcTemp.right    = m_sizeInput.cx;

        m_abndsDirty[1].SetXYRect(rcTemp);

        // Portion two of non-inset area.

        rcTemp.left     = 0;
        rcTemp.top      = rcTemp.bottom;
        rcTemp.bottom   = m_sizeInput.cy;

        m_abndsDirty[2].SetXYRect(rcTemp);

        m_aulSurfaceIndex[0]    = 1;
        m_aulSurfaceIndex[1]    = 0;
        m_aulSurfaceIndex[2]    = 0;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTInsetBase::_CalcFullBounds


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::_CalcOptBounds
//
//  XXXXX11YYYYY	1 - transition area part 1  (difference between old
//  XXXXX11YYYYY	2 - transition area part 2    and new inset regions)
//  XXXXX11YYYYY	X - inset area not updated
//  2222222YYYYY	Y - non-inset area not updated
//  YYYYYYYYYYYY
//  YYYYYYYYYYYY
//
//              Note:  All coordinates are calculated in input space coordinates
//              assuming the entire output will need to be drawn.  Bounds will
//              be clipped and transformed to output space if needed by the 
//              WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTInsetBase::_CalcOptBounds()
{
    if (m_bndsCurInset == m_bndsPrevInset)
    {
        // If the inset bounds are the same as the previous inset bounds, no
        // update is required.

        m_cbndsDirty = 0;
    }
    else if (m_bndsPrevInset.BoundsAreEmpty())
    {
        // If the previous inset bounds are empty (have no area) then we just
        // need to pass one set of bounds to the WorkProc to draw the whole
        // new inset area using input B.

        m_cbndsDirty          = 1;
        m_abndsDirty[0]         = m_bndsCurInset;
        m_aulSurfaceIndex[0]    = 1;
    }
    else if (m_bndsCurInset.BoundsAreEmpty())
    {
        // If the current inset bounds are empty (have no area) then we just
        // need to pass one set of bounds to the WorkProc to draw over the whole
        // old inset area using input A.

        m_cbndsDirty          = 1;
        m_abndsDirty[0]         = m_bndsPrevInset;
        m_aulSurfaceIndex[0]    = 0;
    }
    else
    {
        // At this point we know the inset has become either larger or smaller
        // and we need to pass two sets of bounds to paint over the dirty area
        // with the appropriate input.

        RECT rcTemp;

        m_cbndsDirty = 2;

        // Portion 1

        rcTemp.top      = 0;
        rcTemp.left     = min(m_bndsCurInset.Right(), m_bndsPrevInset.Right());
        rcTemp.right    = max(m_bndsCurInset.Right(), m_bndsPrevInset.Right());
        rcTemp.bottom   = min(m_bndsCurInset.Bottom(), m_bndsPrevInset.Bottom());

        m_abndsDirty[0].SetXYRect(rcTemp);

        // Portion 2

        rcTemp.left     = 0;
        rcTemp.top      = rcTemp.bottom;
        rcTemp.bottom   = max(m_bndsCurInset.Bottom(), m_bndsPrevInset.Bottom());

        m_abndsDirty[1].SetXYRect(rcTemp);

        // Inputs

        if ((m_bndsCurInset.Right() > m_bndsPrevInset.Right())
            || (m_bndsCurInset.Bottom() > m_bndsPrevInset.Bottom()))
        {
            // Inset is growing so paint with input B.
            m_aulSurfaceIndex[0] = 1;
            m_aulSurfaceIndex[1] = 1;
        } 
        else
        {
            // Inset is shrinking so paint with input A.
            m_aulSurfaceIndex[0] = 0;
            m_aulSurfaceIndex[1] = 0;
        }
    }

    return S_OK;
}
//  CDXTInsetBase::_CalcOptBounds


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTInsetBase::OnSetup(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CDXDBnds bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsInput.GetXYSize(m_sizeInput);

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTInsetBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTInsetBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                     ULONG & ulInToTest, 
                                     ULONG aInIndex[], BYTE aWeight[])
{
    long pickX = OutPoint.Left();
    long pickY = OutPoint.Top();
    long insetHeight = (long)(GetEffectProgress() * m_sizeInput.cy + 0.5);
    long insetWidth = (long)(GetEffectProgress() * m_sizeInput.cx + 0.5);

    if (pickX < insetWidth && pickY < insetHeight)
        aInIndex[0] = 1;
    else
        aInIndex[0] = 0;

    ulInToTest = 1;
    aWeight[0] = 255;
}
//  CDXTInsetBase::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTInsetBase::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;

    RECT    rcInset;

    // Calculate inset bounds.

    rcInset.left    = 0;
    rcInset.top     = 0;

    if (0.0F == GetEffectProgress())
    {
        rcInset.right   = 0;
        rcInset.bottom  = 0;
    }
    else if (1.0F == GetEffectProgress())
    {
        rcInset.right   = m_sizeInput.cx;
        rcInset.bottom  = m_sizeInput.cy;
    }
    else
    {
        rcInset.right   = (LONG)((m_Progress * (float)m_sizeInput.cx) + 0.5F);
        rcInset.bottom  = (LONG)((m_Progress * (float)m_sizeInput.cy) + 0.5F);
    }

    m_bndsCurInset.SetXYRect(rcInset);

    // If the inputs, output, or transform is dirty, or if we can't optimize we 
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize
        || !m_fOptimizationPossible)
    {
        hr = _CalcFullBounds();
    }
    else // Create optimized dirty bounds.
    {
        hr = _CalcOptBounds();

        if (FAILED(hr))
        {
            goto done;
        }
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTInsetBase::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::WorkProc, CDXBaseNTo1 
//
//------------------------------------------------------------------------------
HRESULT 
CDXTInsetBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    DWORD   dwFlags         = 0;
    long    lInOutOffsetX   = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY   = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    for (ULONG i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;

        if (bndsSrc.IntersectBounds(WI.DoBnds, m_abndsDirty[i]))
        {
            bndsDest = bndsSrc;
            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            hr = DXBitBlt(OutputSurface(), bndsDest,
                          InputSurface(m_aulSurfaceIndex[i]), bndsSrc,
                          dwFlags, INFINITE);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTInsetBase::WorkProc, CDXBaseNTo1 


//+-----------------------------------------------------------------------------
//
//  CDXTInsetBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTInsetBase::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    m_bndsPrevInset = m_bndsCurInset;

    // Calling IsOuputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTInsetBase::OnFreeInstData, CDXBaseNTo1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\image.cpp ===
//------------------------------------------------------------------------------
//
//  image.cpp
//
//  This file provides the implementation of the CImage class which is the 
//  class behind the Basic Image transform.
//
//  Created:    1998        EdC, RalhpL
//
//  1998/11/04 mcalkins Added Comments.
//                      Moved sample modification code out of WorkProc and into
//                      private inline functions.
//
//  2000/01/05 mcalkins If mask color alpha is zero, set to 0xFF
//                      Default mask color black instead of clear.
//                      Added support for free threaded marshaler.
//
//  2000/01/25 mcalkins Implement OnSurfacePick instead of OnGetSurfacePickOrder
//                      To ensure that we pass back the transformed input point
//                      even when nothing is hit (the input pixel is clear.)
//
//------------------------------------------------------------------------------
      
#include "stdafx.h"
#include "DXTMsft.h"
#include "Image.h"




//+-----------------------------------------------------------------------------
//
//  Method: CImage::CImage
//
//------------------------------------------------------------------------------
CImage::CImage() :
    m_Rotation(0),
    m_fMirror(FALSE),
    m_fGrayScale(FALSE),
    m_fInvert(FALSE),
    m_fXRay(FALSE),
    m_fGlow(FALSE),
    m_fMask(FALSE),
    m_MaskColor(0xFF000000)
{
}
//  Method: CImage::CImage


//+-----------------------------------------------------------------------------
//
//  Method: CImage::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CImage::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  Method: CImage::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CImage::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CImage::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                      CDXDVec & InVec)
{
    HRESULT     hr          = S_OK;
    CDXDBnds    bndsInPoint;

    ulInputIndex = 0;

    if (GetNumInputs() == 0 || !InputSurface())
    {
        hr = E_FAIL;

        goto done;
    }

    hr = MapBoundsOut2In(0, &OutPoint, 0, &bndsInPoint);

    if (FAILED(hr))
    {
        goto done;
    }

    // Reset to S_OK just in case MapBoundsOut2In changed it.

    hr = S_OK;

    bndsInPoint.GetMinVector(InVec);

    if (!m_Scale.GetScaleAlphaValue())
    {
        hr = S_FALSE;
    }
    else
    {
        DXSAMPLE                sample;
        CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

        hr = InputSurface()->LockSurface(NULL, INFINITE, DXLOCKF_READ,
                                         __uuidof(IDXARGBReadPtr),
                                         (void **)&spDXARGBReadPtr,
                                         NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        // Reset to S_OK just in case LockSurface changed it.

        hr = S_OK;

        spDXARGBReadPtr->MoveToXY(InVec.u.D[DXB_X], InVec.u.D[DXB_Y]);

        spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

        if (!sample.Alpha)
        {
            // Sample is clear, we're not hit.

            hr = S_FALSE;
        }
        else if (m_Scale.ScaleType() == DXRUNTYPE_TRANS)
        {
            // Scale the sample if they're using scaling and see if the scaled
            // sample is clear.

            if (!(m_Scale.ScaleSample(sample) & 0xFF000000))
            {
                hr = S_FALSE;
            }
        }
    }

done:

    return hr;
}
//  CImage::OnSurfacePick, CDXBaseNTo1


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_Rotation
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_Rotation(int newVal)
{
    DXAUTO_OBJ_LOCK;

    if (newVal < 0 || newVal > 3)
        return E_INVALIDARG;

    if (m_Rotation != newVal)
    {
        m_Rotation = newVal;
        SetDirty();
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_Rotation
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_Rotation(int *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_Rotation;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_Mirror
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_Mirror(BOOL newVal)
{
    DXAUTO_OBJ_LOCK;

    m_fMirror = newVal;
    SetDirty();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_Mirror
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_Mirror(BOOL *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_fMirror;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_XRay
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_XRay(BOOL newVal)
{
    DXAUTO_OBJ_LOCK;

    m_fXRay = newVal;
    SetDirty();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_XRay
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_XRay(BOOL *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_fXRay;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_Invert
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_Invert(BOOL newVal)
{
    DXAUTO_OBJ_LOCK;

    m_fInvert = newVal;
    SetDirty();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_Invert
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_Invert(BOOL *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_fInvert;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_GrayScale
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_GrayScale(BOOL newVal)
{
    DXAUTO_OBJ_LOCK;

    m_fGrayScale = newVal;
    SetDirty();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_GrayScale
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_GrayScale(BOOL *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_fGrayScale;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//`CImage::put_Mask
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_Mask(BOOL newVal)
{
    DXAUTO_OBJ_LOCK;

    m_fMask = newVal;
    SetDirty();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_Mask
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_Mask(BOOL *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_fMask;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_MaskColor
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_MaskColor(int newVal)
{
    DXAUTO_OBJ_LOCK;

    // If no alpha value was provided (clear) assume opaque.

    if (!(newVal & 0xFF000000))
    {
        newVal |= 0xFF000000;
    }

    if (m_MaskColor != newVal)
    {
        m_MaskColor = newVal;
        SetDirty();
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_MaskColor
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_MaskColor(int *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
        return E_POINTER;
    *pVal = m_MaskColor;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::put_Opacity
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::put_Opacity(float newVal)
{
    DXAUTO_OBJ_LOCK;

    SetDirty();
    return m_Scale.SetScale(newVal);
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::get_Opacity
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::get_Opacity(float *pVal)
{
    DXAUTO_OBJ_LOCK;

    if (DXIsBadWritePtr(pVal, sizeof(*pVal)) ) 
        return E_POINTER;
    *pVal = m_Scale.GetScale();

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::OnSetup
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CImage::OnSetup(DWORD /*dwFlags*/)
{
    return InputSurface()->GetBounds(&m_InputBounds);
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::DetermineBnds
//
//  This function modifies the Bnds parameter to correctly indicate the
//  dimensions of the output bounds.  The placement of the bounds may
//  not necessarily match the placement of the actual output bounds.
//
//  If the image will be rotated 90 or 270 degrees (m_Rotation = 1 or 3)
//  the function will switch the x and y bounds.
// 
////////////////////////////////////////////////////////////////////////////////
HRESULT CImage::DetermineBnds(CDXDBnds & Bnds)
{
    if (m_Rotation & 1)
    {
        long tMin, tMax;
        tMin = Bnds[DXB_X].Min;
        tMax = Bnds[DXB_X].Max;
        Bnds[DXB_X].Min = Bnds[DXB_Y].Min;
        Bnds[DXB_X].Max = Bnds[DXB_Y].Max;
        Bnds[DXB_Y].Min = tMin;
        Bnds[DXB_Y].Max = tMax;
    }

    return S_OK;
} // CImage::DetermineBnds


////////////////////////////////////////////////////////////////////////////////
//  FlipX (inline local function, not a class method)
//
//  If the Width parameter represents the width of the entire image, this 
//  fuction will mirror the x bounds of the Flip parameter.
// 
////////////////////////////////////////////////////////////////////////////////
void inline FlipX(CDXDBnds & Flip, ULONG Width)
{
    ULONG FlipWidth = Flip.Width();

    Flip[DXB_X].Min = Width - Flip[DXB_X].Max;
    Flip[DXB_X].Max = Flip[DXB_X].Min + FlipWidth;
}


////////////////////////////////////////////////////////////////////////////////
//  FlipY (inline local function, not a class method)
//
//  If the Height parameter represents the width of the entire image, this
//  fuction will mirror the y bounds of the Flip parameter.
// 
////////////////////////////////////////////////////////////////////////////////
void inline FlipY(CDXDBnds & Flip, ULONG Height)
{
    ULONG FlipHeight = Flip.Height();

    Flip[DXB_Y].Min = Height - Flip[DXB_Y].Max;
    Flip[DXB_Y].Max = Flip[DXB_Y].Min + FlipHeight;
}


////////////////////////////////////////////////////////////////////////////////
//  CImage::FlipBounds
//
//  This function takes DoBnds, which are in output coordinates and modifies
//  them so that they are in input coordinates based on whether the input
//  is being rotated, mirrored, or both.
//
//  Consequently, this function is the basis for MapBoundsOut2In and is used
//  by the WorkProc to calculate the input pixels it needs to work with.
//
//  The benefit to not just having this code in MapBoundsOut2In is that it
//  will improve the speed of WorkProc to be able to call this code directly
//  without the overhead of calling MapBoundsOut2In.  (???)
//  
////////////////////////////////////////////////////////////////////////////////
void CImage::FlipBounds(const CDXDBnds & DoBnds, CDXDBnds & Flip)
{
    Flip            = DoBnds;
    ULONG Width     = m_InputBounds.Width();
    ULONG Height    = m_InputBounds.Height();

    if (m_Rotation & 1)
    {
        long tMin, tMax;
        tMin = Flip[DXB_X].Min;
        tMax = Flip[DXB_X].Max;
        Flip[DXB_X].Min = Flip[DXB_Y].Min;
        Flip[DXB_X].Max = Flip[DXB_Y].Max;
        Flip[DXB_Y].Min = tMin;
        Flip[DXB_Y].Max = tMax;
    }

    switch (m_Rotation)
    {
    case 0:
        if (m_fMirror) FlipX(Flip, Width);
        break;
    case 1:
        if (!m_fMirror) FlipY(Flip, Height);
        break;
    case 2:
        FlipY(Flip, Height);
        if (!m_fMirror) FlipX(Flip, Width);
        break;
    case 3:
        FlipX(Flip, Width);
        if (m_fMirror) FlipY(Flip, Height);
        break;
    }
} // CImage::FlipBounds


////////////////////////////////////////////////////////////////////////////////
//  CImage::MapBoundsOut2In
//
//  This method translates output coordinates to input coordinates using
//  the FlipBounds method implimented directly above.
//
////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CImage::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS *pOutBounds, 
                                     ULONG ulInIndex, DXBNDS *pInBounds)
{
    HRESULT hr = CDXBaseNTo1::MapBoundsOut2In(ulOutIndex, pOutBounds, 
                                              ulInIndex, pInBounds);

    if (SUCCEEDED(hr) && HaveInput())
    {
        FlipBounds(*(CDXDBnds *)pOutBounds, *(CDXDBnds *)pInBounds);
    }

    return hr;
} // CImage::MapBoundsOut2In



////////////////////////////////////////////////////////////////////////////////
//  CImage::WorkProc
//
//  This method performs the modifications on the inputs.
//
////////////////////////////////////////////////////////////////////////////////
HRESULT 
CImage::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinueProcessing)
{
    HRESULT hr = S_OK;

    // The FlipSrc bounds declared and initialized below will be used as the
    // locking bounds for the input surface.  The FlipBounds method translates
    // output bounds to input bounds.

    CDXDBnds FlipSrc(false);
    FlipBounds(WI.DoBnds, FlipSrc);

    // Save height and width of the DoBnds for later use.

    const ULONG DoWidth     = WI.DoBnds.Width();
    const ULONG DoHeight    = WI.DoBnds.Height();

    // REVIEW:  Why fDoOver instead of DoOver()?

    BOOL fDoOver = m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT;

    // Get output pointer.

    CComPtr<IDXARGBReadWritePtr> pDest;
    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, (void**)&pDest, NULL);

    if( FAILED(hr) ) 
        return hr;

    // Opacity Check:  If the user has set opacity to 0 (invisible), then
    //                 leave this function early:
    //
    //  If blending with output:
    //      Do nothing.  Return.
    //  If not blending:
    //      Fill output with black, clear pixels.  Return.

    if (m_Scale.ScaleType() == DXRUNTYPE_CLEAR)
    {
        if (!fDoOver)
        {
            DXPMSAMPLE Color;
            Color = 0;
            pDest->FillRect(NULL, Color, FALSE);
        }

        return hr;
    }    

    // Get input pointer.

    CComPtr<IDXARGBReadPtr> pSrc;
    hr = InputSurface()->LockSurface(&FlipSrc, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);

    if (FAILED(hr) ) 
        return hr;

    // Declare and initialize the pointer to the temporary sample buffer
    // this function will make modifications to.

    DXPMSAMPLE* pBuffer = NULL;

    // We can modify samples the output surface directly if the output
    // surface format is DXPF_PMARGB32 and we aren't blending the results
    // of this transform with the original output. The local variable 
    // fDirectCopy will be set to TRUE if this is the case.

    DXNATIVETYPEINFO    NTI;
    BOOL                fDirectCopy = (OutputSampleFormat() == DXPF_PMARGB32 
                                       && (!DoOver()));

    // If it's possible to directly modify the samples of the output
    // surface, get needed info about the surface and the pointer to the
    // first sample.  If for some reason a pointer isn't available, we 
    // can't do direct copy.

    if (fDirectCopy)
    {
        pDest->GetNativeType(&NTI);
        if (NTI.pFirstByte)
        {
            pBuffer = (DXPMSAMPLE*)NTI.pFirstByte;
        }
        else
        {
            fDirectCopy = FALSE;
        }
    }

    // If we're not directly modifying the samples of the output surface, 
    // allocate memory for the temporary sample buffer.

    if (pBuffer == NULL)
    {
        pBuffer = DXPMSAMPLE_Alloca(DoWidth);
    }

    // If we're blending with the original output surface and the output
    // surface sample format isn't PMARGB32, we'll need a scratch buffer
    // for some of the blit functions.

    DXPMSAMPLE *pOverScratch = NULL;
    
    if (DoOver() && OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOverScratch = DXPMSAMPLE_Alloca(DoWidth);
    }

    //  Set up the dither structure

    DXDITHERDESC dxdd;

    if (DoDither())
    {
        dxdd.x = WI.OutputBnds.Left();
        dxdd.y = WI.OutputBnds.Top();
        dxdd.pSamples = pBuffer;
        dxdd.cSamples = DoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    // Structure describing which input samples to retrieve.

    DXPACKEDRECTDESC    prd;

    // Retrieve the samples with their pre-multiplied values.
    // Don't separate the rows.
    // REVIEW:  This transform could be optimized by setting the
    //          prd.bPremult value to FALSE and modifiying the
    //          Op functions to use non-premultiplied samples.

    prd.bPremult    = TRUE;
    prd.lRowPadding = 0;

    // The following code initializes the following local variables:
    //
    // RECT prd.rect
    // This rectangle is relative to the input surface and represents a single
    // row or column of pixels.  This group of pixels will become the first
    // output row.  A column will be used if the rotation requested is 90 or
    // 270 degrees.  By using this input column as an output row, the rotation
    // is implemented.
    //
    // BOOL fReverse
    // The other part of implementing rotation and flip is making sure the
    // order of the pixels is reversed if needed, which is why the fReverse
    // flag is set.
    //
    // long XInc, YInc
    // These variables represent how the rectangle should be translated to
    // retrieve the next output row of input samples.

    long    YInc, XInc;
    BOOL    fReverse;

    switch (m_Rotation)
    {
    case 0:
        fReverse = m_fMirror;
        prd.rect.top = 0; prd.rect.bottom = 1;
        prd.rect.left = 0; prd.rect.right = DoWidth;
        YInc = 1;
        XInc = 0;
        break;
    case 1:
        fReverse = m_fMirror ? FALSE : TRUE;
        prd.rect.top = 0; prd.rect.bottom = DoWidth;
        prd.rect.left = 0; prd.rect.right = 1;
        YInc = 0;
        XInc = 1;
        break;
    case 2:
        fReverse = m_fMirror ? FALSE : TRUE;
        prd.rect.top = DoHeight - 1; prd.rect.bottom = DoHeight;
        prd.rect.left = 0; prd.rect.right = DoWidth;
        XInc = 0;
        YInc = -1;
        break;
    case 3:
        fReverse = m_fMirror;
        prd.rect.top = 0; prd.rect.bottom = DoWidth;
        prd.rect.left = DoHeight - 1; prd.rect.right = DoHeight;
        XInc = -1;
        YInc = 0;
        break;
    }

    //
    // This is the row loop.  Each iteration of this loop will retrieve
    // a row of output samples, perform the requested modifications, and
    // write the samples to the output.
    //

    for (ULONG y = 0 ; y < DoHeight ; y++)
    {
        // Retrieve the output row into pBuffer.

        prd.pSamples = pBuffer;
        pSrc->UnpackRect(&prd);

        // Translate the input rect for the next iteration.

        prd.rect.left   += XInc;
        prd.rect.right  += XInc;
        prd.rect.top    += YInc;
        prd.rect.bottom += YInc;

        // fReverse is TRUE if the row of samples needs to be reversed to
        // properly mirror or rotate the image.

        if (fReverse)
        {
            DXPMSAMPLE * pA = pBuffer;
            DXPMSAMPLE * pB = pBuffer + DoWidth - 1;
            while (pB > pA)
            {
                DXPMSAMPLE Temp;
                Temp = *pA;
                *pA++ = *pB;
                *pB-- = Temp;
            }
        }

        //
        // Insert more effects here.
        //
        // TODO:    Switch to unpacking as DXSAMPLES so I can get rid of all
        //          these unpremultiplying and premultiplying calls.
        //

        // Invert Colors
        
        if (m_fInvert)
        {
            OpInvertColors(pBuffer, DoWidth);
        }

        // X-Ray

        if (m_fXRay)
        {
            OpXRay(pBuffer, DoWidth);
        }

        // Gray Scale

        if (m_fGrayScale)
        {
            OpGrayScale(pBuffer, DoWidth);
        }

        // Mask

        if (m_fMask)
        {
            OpMask(pBuffer, DoWidth);
        }

        // Opacity
        // Only modify the samples of the user has not set opacity 0 or 1.

        if (m_Scale.ScaleType() == DXRUNTYPE_TRANS)
        {
            m_Scale.ScalePremultArray(pBuffer, DoWidth);
        }

        if (fDirectCopy)
        {
            // If we've been modifying the output pixels directly, just
            // reset the buffer pointer to the beginning of the next row.

            pBuffer = (DXPMSAMPLE *)(((BYTE *)pBuffer) + NTI.lPitch);
        }
        else
        {
            // Blend or copy the modified samples to the output surface.

            if (DoDither())
            {
                DXDitherArray(&dxdd);
                dxdd.y++;
            }

            pDest->MoveToRow(y);

            if (fDoOver)
            {
                if (m_Scale.ScaleType() == DXRUNTYPE_TRANS)
                {
                    DXOverArrayMMX(pDest->UnpackPremult(pOverScratch, DoWidth, FALSE), pBuffer, DoWidth);
                    pDest->PackPremultAndMove(pOverScratch, DoWidth);
                }
                else
                {
                    //  NOTE:  If any other effect can change alpha, do test here.
                    //  The BltFlags which will be 0 if the
                    //  source is opqaue.

                    if (m_dwBltFlags & DXBOF_DO_OVER)
                    {
                        pDest->OverArrayAndMove(pOverScratch, pBuffer, DoWidth);
                    }
                    else
                    {
                        pDest->PackPremultAndMove(pBuffer, DoWidth);
                    }
                }
            }
            else
            {
                pDest->PackPremultAndMove(pBuffer, DoWidth);
            }
        }
    }

    return hr;
} // CImage::WorkProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\inset.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:        inset.h
//
// Created:         06/24/98
//
// Author:          PhilLu
//
// Discription:     This file declares CInset (Inset Transform)
//
// Revisions:
//
// 06/02/99 a-matcal    Optimization.
// 10/24/99 a-matcal    Changed CInset class to CDXTInsetBase and created two
//                      new classes CDXTInset and CDXTInsetOpt to represent  
//                      non-optimized and optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRINSET_H_
#define __CRINSET_H_

#include "resource.h"

#define MAX_INSET_BOUNDS 3




class ATL_NO_VTABLE CDXTInsetBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrInset, &IID_ICrInset, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTInsetBase>,
    public IObjectSafetyImpl2<CDXTInsetBase>
{
private:

    SIZE        m_sizeInput;
    ULONG       m_cbndsDirty;

    ULONG       m_aulSurfaceIndex[MAX_INSET_BOUNDS];
    CDXDBnds    m_abndsDirty[MAX_INSET_BOUNDS];
    
    CDXDBnds    m_bndsCurInset;
    CDXDBnds    m_bndsPrevInset;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    HRESULT _CalcFullBounds();
    HRESULT _CalcOptBounds();

    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

public:

    CDXTInsetBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTInsetBase)
        COM_INTERFACE_ENTRY(ICrInset)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTInsetBase>)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTInsetBase)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, 
                                  ULONG & ulInToTest, ULONG aInIndex[], 
                                  BYTE aWeight[]);

    // IDXEffect

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTInset :
    public CDXTInsetBase,
    public CComCoClass<CDXTInset, &CLSID_CrInset>,
    public IPersistStorageImpl<CDXTInset>,
    public IPersistPropertyBagImpl<CDXTInset>
{
public:

    CDXTInset()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTINSET)
    DECLARE_POLY_AGGREGATABLE(CDXTInset)

    BEGIN_COM_MAP(CDXTInset)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTInsetBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTInsetOpt :
    public CDXTInsetBase,
    public CComCoClass<CDXTInsetOpt, &CLSID_DXTInset>,
    public IPersistStorageImpl<CDXTInsetOpt>,
    public IPersistPropertyBagImpl<CDXTInsetOpt>
{
public:

    CDXTInsetOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTINSETOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTInsetOpt)

    BEGIN_COM_MAP(CDXTInsetOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTInsetBase)
    END_COM_MAP()
};


#endif // __CRINSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\iris.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:            iris.h
//
// Created:             06/18/98
//
// Author:              kipo
//
// Description:         This is the header file for the CrIris transformation
//
// Change History:
// 06/24/98 PhilLu      Developed 1.0 version for Chromeffects
// 11/04/98 PaulNash    Moved from DT 1.0 codebase to IE5/NT5 DXTMSFT.DLL
// 05/20/99 a-matcal    Code scrub.
// 09/25/99 a-matcal    Inherit from ICrIris2 interface.
// 10/22/99 a-matcal    Changed CIris class to CDXTIrisBase and created two new
//                      classes CDXTIris and CDXTIrisOpt to represent 
//                      non-optimized and optimized versions respectively.
// 2000/01/16 mcalkins  Added rectangle option.
//
//------------------------------------------------------------------------------

#ifndef __CRIRIS_H_
#define __CRIRIS_H_

#include "resource.h"




class ATL_NO_VTABLE CDXTIrisBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrIris2, &IID_ICrIris2, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTIrisBase>,
    public IObjectSafetyImpl2<CDXTIrisBase>,
    public ISpecifyPropertyPagesImpl<CDXTIrisBase>
{
private:

    typedef enum
    {
        STYLE_DIAMOND,
        STYLE_CIRCLE,
        STYLE_CROSS,
        STYLE_PLUS,
        STYLE_SQUARE,
        STYLE_STAR,
        STYLE_RECTANGLE,
        STYLE_MAX
    } STYLE;

    STYLE                   m_eStyle;
    static const WCHAR *    s_astrStyle[STYLE_MAX];

    typedef enum {
        MOTION_IN = 0,
        MOTION_OUT,
        MOTION_MAX
    } MOTION;

    MOTION                  m_eMotion;
    static const WCHAR *    s_astrMotion[MOTION_MAX];

    SIZE                m_sizeInput;
    CComPtr<IUnknown>   m_cpUnkMarshaler;

    // Helpers.

    void _ScanlineIntervals(long width, long height, float progress, 
                            long YScanline, long *XBounds);
    void _ClipBounds(long offset, long width, long *XBounds);

protected:

    unsigned        m_fOptimize : 1;

public:

    CDXTIrisBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTIrisBase)
        COM_INTERFACE_ENTRY(ICrIris2)
        COM_INTERFACE_ENTRY(ICrIris)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTIrisBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CIris)
        PROP_ENTRY("irisstyle", DISPID_CRIRIS_IRISSTYLE,    CLSID_CrIrisPP)
        PROP_ENTRY("motion",    DISPID_CRIRIS_MOTION,       CLSID_CrIrisPP)
        PROP_PAGE(CLSID_CrIrisPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, 
                                  ULONG & ulInToTest, ULONG aInIndex[], 
                                  BYTE aWeight[]);
    HRESULT WorkProc(const CDXTWorkInfoNTo1& WI, BOOL* pbContinue);
    HRESULT OnSetup(DWORD dwFlags );

    // ICrIris properties.

    STDMETHOD(get_irisStyle)(BSTR * pbstrStyle);
    STDMETHOD(put_irisStyle)(BSTR bstrStyle);

    // ICrIris2 properties.

    STDMETHOD(get_Motion)(BSTR * pbstrMotion);
    STDMETHOD(put_Motion)(BSTR bstrMotion);

    // IDXEffect methods.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTIris :
    public CDXTIrisBase,
    public CComCoClass<CDXTIris, &CLSID_CrIris>,
    public IPersistStorageImpl<CDXTIris>,
    public IPersistPropertyBagImpl<CDXTIris>
{
public:

    CDXTIris()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTIRIS)
    DECLARE_POLY_AGGREGATABLE(CDXTIris)

    BEGIN_COM_MAP(CDXTIris)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTIrisBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTIrisOpt :
    public CDXTIrisBase,
    public CComCoClass<CDXTIrisOpt, &CLSID_DXTIris>,
    public IPersistStorageImpl<CDXTIrisOpt>,
    public IPersistPropertyBagImpl<CDXTIrisOpt>
{
public:

    CDXTIrisOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTIRISOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTIrisOpt)

    BEGIN_COM_MAP(CDXTIrisOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTIrisBase)
    END_COM_MAP()
};

#endif //__CRIRIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\iris.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:		iris.cpp
//
// Created:             06/17/98
//
// Author:              PhilLu
//
// Discription:		This file implements the CrIris transformation.
//
// History:
//
// 06/23/98 phillu      Added PLUS iris style.
// 06/24/98 phillu      Removed copyright related methods.
// 06/29/98 phillu      Rename irisType to irisStyle.
// 07/02/98 phillu      Return E_INVALIDARG rather than an error string; check 
//                      for E_POINTER.
// 07/09/98 phillu      Implement OnSetSurfacePickOrder().
// 07/22/98 phillu      Implement clipping.
// 05/19/99 a-matcal    Check for out of memory in get_ functions allocating
//                      BSTRs.
// 05/20/99 a-matcal    Code scrub.
// 09/25/99 a-matcal    Implemented ICrIris2 interface.
// 10/22/99 a-matcal    Changed CIris class to CDXTIrisBase base class.
// 2000/01/16 mcalkins  Added rectangle option.
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "iris.h"

// Constants for drawing a star of unit radius.

const double STAR_VPOS1         = -1.0;
const double STAR_VPOS2	        = -0.309017;
const double STAR_VPOS3	        = 0.118034;
const double STAR_VPOS4	        = 0.381966;
const double STAR_VPOS5	        = 0.951057;

const double STAR_SLOPE1        = 0.324920;
const double STAR_INTERCEPT1    = 0.324920;
const double STAR_SLOPE2        = -1.376382;
const double STAR_INTERCEPT2    = 0.525731;

const int    MAXBOUNDS          = 10;




//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase static variables initialization
//
//------------------------------------------------------------------------------

const WCHAR * CDXTIrisBase::s_astrStyle[] = {
    L"diamond",
    L"circle",
    L"cross",
    L"plus",
    L"square",
    L"star",
    L"rectangle"
};

const WCHAR * CDXTIrisBase::s_astrMotion[] = {
    L"in",
    L"out"
};


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::CDXTIrisBase
//
//------------------------------------------------------------------------------
CDXTIrisBase::CDXTIrisBase() :
    m_eStyle(STYLE_PLUS),
    m_eMotion(MOTION_OUT),
    m_fOptimize(false)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // CDXBaseNTo1 members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTIrisBase::CDXTIrisBase


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTIrisBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTIrisBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTIrisBase::OnSetup(DWORD dwFlags)
{
    HRESULT hr;

    CDXDBnds InBounds(InputSurface(0), hr);

    if (SUCCEEDED(hr))
    {
        InBounds.GetXYSize(m_sizeInput);
    }

    return hr;
}
//  CDXTIrisBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTIrisBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                    ULONG & ulInToTest, ULONG aInIndex[], 
                                    BYTE aWeight[])
{
    long    XBounds[10];
    long    pickX           = OutPoint.Left();
    long    pickY           = OutPoint.Top();

    aInIndex[0] = 0;

    if((pickX >= 0) && (pickX < m_sizeInput.cx) && (pickY >= 0) 
        && (pickY < m_sizeInput.cy))
    {
        _ScanlineIntervals(m_sizeInput.cx, m_sizeInput.cy, m_Progress,
                           pickY, XBounds);
    
        for(long i=0; XBounds[i] < pickX; i++)
        {
            aInIndex[0] = 1 - aInIndex[0];
        }
    }

    ulInToTest = 1;
    aWeight[0] = 255;
}
//  CDXTIrisBase::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::get_irisStyle, ICrIris
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTIrisBase::get_irisStyle(BSTR * pbstrStyle)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrStyle)
    {
        return E_POINTER;
    }

    if (*pbstrStyle != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrStyle = SysAllocString(s_astrStyle[m_eStyle]);

    if (NULL == *pbstrStyle)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTIrisBase::get_irisStyle, ICrIris


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::put_irisStyle, ICrIris
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTIrisBase::put_irisStyle(BSTR bstrStyle)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrStyle)
    {
        return E_POINTER;
    }

    for ( ; i < (int)STYLE_MAX ; i++)
    {
        if (!_wcsicmp(bstrStyle, s_astrStyle[i]))
        {
            break;
        }
    }

    if ((int)STYLE_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eStyle != i)
    {
        m_eStyle = (STYLE)i;

        SetDirty();
    }

    return S_OK;
}
//  CDXTIrisBase::put_irisStyle, ICrIris


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::get_Motion, ICrIris2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTIrisBase::get_Motion(BSTR * pbstrMotion)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrMotion)
    {
        return E_POINTER;
    }

    if (*pbstrMotion != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrMotion = SysAllocString(s_astrMotion[m_eMotion]);

    if (NULL == *pbstrMotion)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTIrisBase::get_Motion, ICrIris2


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::put_Motion, ICrIris2
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTIrisBase::put_Motion(BSTR bstrMotion)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrMotion)
    {
        return E_POINTER;
    }

    for ( ; i < (int)MOTION_MAX ; i++)
    {
        if (!_wcsicmp(bstrMotion, s_astrMotion[i]))
        {
            break;
        }
    }

    if ((int)MOTION_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eMotion != i)
    {
        m_eMotion = (MOTION)i;
        
        SetDirty();
    }

    return S_OK;
}
//  CDXTIrisBase::put_Motion, ICrIris2


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::_ScanlineIntervals
//
// A helper method that calculates the transition boundaries between the
// two image regions on a scanline. Based on the type of iris, the scanline
// consists of a series of alternating A and B image sections. The upper X
// bound of each section is calculated and saved in array XBounds. The number
// of useful entries in XBounds is variable. The end of array is determined
// when one entry equals to the scanline (image) width. It is assumed that
// XBounds[0] is the upper bound of the first A section. So if the scanline
// starts with a B section, XBounds[0] will be 0.
//
// Example 1: scanline length = 16, first section is from A image
//
//    AAAABBBBBAAABBAA      XBounds should contain {4, 9, 12, 14, 16}.
//
// Example 2: scanline length = 16, first section is from B image
//
//    BBBAAAAAABBBBBBB      XBounds should contain {0, 3, 9, 16}.
//
//
// Note: It is possible that some section has length 0 (i.e. two adjacent
//       bounds equal). {3, 9, 9, 16} is equivalent to {3, 16}.
//
// Parameters:
//
// width, height: width and height of both images.
// progress: progress value from 0.0 to 1.0
// YScanline: Y cooridnate (height) of the current scanline
// XBounds: array to hold the computed X bounds on return.
//
//
// 06/17/98 phillu      Created.
//
//------------------------------------------------------------------------------
void 
CDXTIrisBase::_ScanlineIntervals(long width, long height, float progress, 
                                 long YScanline, long *XBounds)
{
    long    CenterX         = 0;
    long    CenterY         = 0;
    long    range           = 0;
    long    deltaY          = 0;
    double  scale           = 0.0;
    float   flIrisProgress  = progress;

    // flIrisProgress represents the progress of the iris.  At 0.0 the iris
    // is an invisible dot in the center of the image, at 1.0 the iris is
    // large enough to cover the entire image.  If we're in "out" motion mode,
    // iris progress goes from 0.0 to 1.0 (matching the transform progress),
    // if we're in "in" motion mode, it goes from 1.0 to 0.0.
    
    if (MOTION_IN == m_eMotion)
    {
        flIrisProgress = 1.0F - flIrisProgress;
    }

    // Center of image
    CenterX = width/2;
    CenterY = height/2;

    switch(m_eStyle)
    {
    case STYLE_DIAMOND:
        range = (long)((CenterX + CenterY) * flIrisProgress + 0.5);
        deltaY = labs(YScanline - CenterY);

        if(deltaY > range)
        {
            XBounds[0] = width; // image A only
        }
        else
        {
            XBounds[0] = max(CenterX - range + deltaY, 0);
            XBounds[1] = min(CenterX + range - deltaY, width);
            XBounds[2] = width;
        }

        break;
    
    case STYLE_SQUARE:

        range = (long)((max(CenterX, CenterY) * flIrisProgress) + 0.5F);

        deltaY = labs(YScanline - CenterY);

        if (deltaY > range)
        {
            XBounds[0] = width;
        }
        else
        {
            XBounds[0] = max(CenterX - range, 0);
            XBounds[1] = min(CenterX + range, width);
            XBounds[2] = width;
        }

        break;

    case STYLE_RECTANGLE:

        range = (long)(((float)CenterY * flIrisProgress) + 0.5F);

        deltaY = labs(YScanline - CenterY);

        if (deltaY > range)
        {
            XBounds[0] = width;
        }
        else
        {
            long lXRange = (long)(((float)CenterX * flIrisProgress) + 0.5F);

            XBounds[0] = max(CenterX - lXRange, 0);
            XBounds[1] = min(CenterX + lXRange, width);
            XBounds[2] = width;
        }

        break;

    case STYLE_CIRCLE:
        range = (long)(sqrt((double)(CenterX*CenterX+CenterY*CenterY))*flIrisProgress + 0.5);
        deltaY = labs(YScanline - CenterY);

        if(deltaY > range)
        {
            XBounds[0] = width;
        }
        else
        {
            long temp = (long)(sqrt((double)(range*range-deltaY*deltaY)) + 0.5);
            XBounds[0] = max(CenterX - temp, 0);
            XBounds[1] = min(CenterX + temp, width);
            XBounds[2] = width;
        }

        break;

    case STYLE_CROSS:
        range = (long)(max(CenterX,CenterY)*flIrisProgress + 0.5);
        deltaY = labs(YScanline - CenterY);

        if(deltaY > CenterX - range)
        {
            XBounds[0] = 0;
            XBounds[3] = width;
        }
        else
        {
            XBounds[0] = max(CenterX - range - deltaY, 0);
            XBounds[3] = min(CenterX + range + deltaY, width);
            XBounds[4] = width;
        }

        if(deltaY > range)
        {
            XBounds[1] = max(CenterX + range - deltaY, 0);
            XBounds[2] = min(CenterX - range + deltaY, width);
        }
        else
        {
            XBounds[1] = XBounds[2] = XBounds[0];
        }

        break;

    case STYLE_PLUS:
        range = (long)(max(CenterX,CenterY)*flIrisProgress + 0.5);
        deltaY = labs(YScanline - CenterY);
        
        if (deltaY >= range)
        {
            XBounds[0] = max(CenterX - range, 0);
            XBounds[1] = min(CenterX + range, width);
            XBounds[2] = width;
        }
        else
        {
            XBounds[0] = 0;
            XBounds[1] = width;
        }
        break;

    case STYLE_STAR:
        scale = max(width, height)*2*flIrisProgress;
        deltaY = YScanline - CenterY;

        if(deltaY < (long)(STAR_VPOS1*scale) || deltaY >= (long)(STAR_VPOS5*scale))
        {
            XBounds[0] = width;
        }
        else if(deltaY < (long)(STAR_VPOS2*scale))
        {
            long temp = (long)(STAR_SLOPE1*deltaY+STAR_INTERCEPT1*scale);
            temp = max(temp, 0);
            XBounds[0] = max(CenterX - temp, 0);
            XBounds[1] = min(CenterX + temp, width);
            XBounds[2] = width;
        }
        else if(deltaY < (long)(STAR_VPOS3*scale))
        {
            long temp = (long)(STAR_SLOPE2*deltaY+STAR_INTERCEPT2*scale);
            temp = max(temp, 0);
            XBounds[0] = max(CenterX - temp, 0);
            XBounds[1] = min(CenterX + temp, width);
            XBounds[2] = width;
        }
        else if(deltaY < (long)(STAR_VPOS4*scale))
        {
            long temp = (long)(STAR_SLOPE1*deltaY+STAR_INTERCEPT1*scale);
            temp = max(temp, 0);
            XBounds[0] = max(CenterX - temp, 0);
            XBounds[1] = min(CenterX + temp, width);
            XBounds[2] = width;
        }
        else
        {
            long temp = (long)(STAR_SLOPE1*deltaY+STAR_INTERCEPT1*scale);
            temp = max(temp, 0);
            XBounds[0] = max(CenterX - temp, 0);
            XBounds[3] = min(CenterX + temp, width);
            temp = (long)(STAR_SLOPE2*deltaY+STAR_INTERCEPT2*scale);
            temp = min(temp, 0);
            XBounds[1] = max(CenterX + temp, 0);
            XBounds[2] = min(CenterX - temp, width);
            XBounds[4] = width;
        }

        break;

    default:
        _ASSERT(0);
        break;
    }
}


//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::_ClipBounds
//
//  Description:
//  Initially the X-bounds are specified relative to the entire image. After clipping,
//  the bounds should be transformed to be relative to the clipping region.
//
//  Parameters;
//  offset, width: offset and width of the clipping region (along X)
//  XBounds: array of X-bounds
//
//  Created by: PhilLu    07/21/98
//
//------------------------------------------------------------------------------
void 
CDXTIrisBase::_ClipBounds(long offset, long width, long *XBounds)
{
    int i;

    for(i=0; XBounds[i] < offset+width; i++)
    {
        if (XBounds[i] < offset)
            XBounds[i] = 0;
        else
            XBounds[i] -= offset;
    }

    XBounds[i] = width;
}
//  CDXTIrisBase::_ClipBounds



//+-----------------------------------------------------------------------------
//
//  CDXTIrisBase::WorkProc, CDXBaseNTo1
//
//  Overview:   This function is used to calculate the result based on the 
//              specified bounds and the current effect progress.
//
//  Created by: PhilLu    06/17/98
//
//------------------------------------------------------------------------------
HRESULT 
CDXTIrisBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    long    lDoWidth        = WI.DoBnds.Width();
    long    lDoHeight       = WI.DoBnds.Height();
    long    lOutY           = 0;

    long    alXBounds[MAXBOUNDS];   // To hold the X bounds of A/B 
                                    // image sections on a scanline.

    DXPMSAMPLE * pRowBuff = NULL;
    DXPMSAMPLE * pOutBuff = NULL;

    DXDITHERDESC dxdd;

    IDXSurface *                    pDXSurfOuter    = NULL;
    IDXSurface *                    pDXSurfInner    = NULL;

    CComPtr<IDXARGBReadPtr>         cpOuterInput;
    CComPtr<IDXARGBReadPtr>         cpInnerInput;
    CComPtr<IDXARGBReadWritePtr>    cpOut;

    if (MOTION_IN == m_eMotion)
    {
        pDXSurfOuter = InputSurface(1);
        pDXSurfInner = InputSurface(0);
    }
    else
    {
        pDXSurfOuter = InputSurface(0);
        pDXSurfInner = InputSurface(1);
    }

    // Get a read pointer to the outer surface.

    hr = pDXSurfOuter->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                   IID_IDXARGBReadPtr, 
                                   (void **)&cpOuterInput, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get a read pointer to the inner surface.

    hr = pDXSurfInner->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                   IID_IDXARGBReadPtr, 
                                   (void **)&cpInnerInput, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get a read/write pointer to the output surface.

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE, 
                                      IID_IDXARGBReadWritePtr, 
                                      (void **)&cpOut, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Allocate a buffer.

    pRowBuff = DXPMSAMPLE_Alloca(lDoWidth);

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(lDoWidth);
    }

    // Set up the dither structure.

    if (DoDither())
    {
        dxdd.x                  = WI.OutputBnds.Left();
        dxdd.y                  = WI.OutputBnds.Top();
        dxdd.pSamples           = pRowBuff;
        dxdd.cSamples           = lDoWidth;
        dxdd.DestSurfaceFmt     = OutputSampleFormat();
    }

    for (lOutY = 0; *pbContinue && (lOutY < lDoHeight); lOutY++)
    {
        long    i           = 0;
        long    lScanLength = 0;    // Cumulative scan length on the current 
                                    // scanline.

        // Compute the inner/outer image section bounds.

        _ScanlineIntervals(m_sizeInput.cx, m_sizeInput.cy, 
                           m_Progress, lOutY + WI.DoBnds.Top(), alXBounds);

        _ClipBounds(WI.DoBnds.Left(), lDoWidth, alXBounds);

        while (lScanLength < lDoWidth)
        {
            // Copy a section of outer image to output buffer.

            if (alXBounds[i] - lScanLength > 0)
            {
                cpOuterInput->MoveToXY(lScanLength, lOutY);
                cpOuterInput->UnpackPremult(pRowBuff + lScanLength, 
                                            alXBounds[i] - lScanLength, FALSE);
            }

            lScanLength = alXBounds[i++];

            if (lScanLength >= lDoWidth)
            {
                break;
            }

            // Copy a section of inner image to output buffer.

            if (alXBounds[i] - lScanLength > 0)
            {
                cpInnerInput->MoveToXY(lScanLength, lOutY);
                cpInnerInput->UnpackPremult(pRowBuff + lScanLength, 
                                            alXBounds[i] - lScanLength, FALSE);
            }

            lScanLength = alXBounds[i++];
        }

        cpOut->MoveToRow(lOutY);

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            cpOut->OverArrayAndMove(pOutBuff, pRowBuff, lDoWidth);
        }
        else
        {
            cpOut->PackPremultAndMove(pRowBuff, lDoWidth);
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTIrisBase::WorkProc, CDXBaseNTo1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\maskfilter.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       maskfilter.cpp
//
//  Overview:       The MaskFilter transform simply wraps the BasicImage
//                  transform to ensure backward compatibility for the mask 
//                  filter.
//
//  Change History:
//  1999/09/19  a-matcal    Created.
//  1999/12/03  a-matcal    put_Color now ensures that the mask color is opaque.
//  1999/12/03  a-matcal    Default mask color is now black instead of clear.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "maskfilter.h"
#include "dxclrhlp.h"
#include "filterhelpers.h"




//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::CDXTMaskFilter
//
//------------------------------------------------------------------------------
CDXTMaskFilter::CDXTMaskFilter() :
    m_bstrColor(NULL)
{
}
//  CDXTMaskFilter::CDXTMaskFilter


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::~CDXTMaskFilter
//
//------------------------------------------------------------------------------
CDXTMaskFilter::~CDXTMaskFilter()
{
    if (m_bstrColor)
    {
        SysFreeString(m_bstrColor);
    }
}
//  CDXTMaskFilter::~CDXTMaskFilter


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT
CDXTMaskFilter::FinalConstruct()
{
    HRESULT hr = S_OK;

    CComPtr<IDXTransformFactory>    spDXTransformFactory;

    hr =  CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                        &m_spUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    m_bstrColor = SysAllocString(L"#FF000000");

    if (NULL == m_bstrColor)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CDXTMaskFilter::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::GetSite, IObjectWithSite
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMaskFilter::GetSite(REFIID riid, void ** ppvSite)
{
    if (!m_spUnkSite)
    {
        return E_FAIL;
    }
    else
    {
        return m_spUnkSite->QueryInterface(riid, ppvSite);
    }
}
//  Method: CDXTMaskFilter::GetSite, IObjectWithSite


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::SetSite, IObjectWithSite
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMaskFilter::SetSite(IUnknown * pUnkSite)
{
    if (pUnkSite == m_spUnkSite)
    {
        goto done;
    }

    m_spDXBasicImage.Release();
    m_spDXTransform.Release();

    m_spUnkSite = pUnkSite;

    if (pUnkSite)
    {
        HRESULT hr          = S_OK;
        DWORD   dwColor;

        CComPtr<IDXTransformFactory>    spDXTransformFactory;
        CComPtr<IDXBasicImage>          spDXBasicImage;
        CComPtr<IDXTransform>           spDXTransform;

        hr = pUnkSite->QueryInterface(__uuidof(IDXTransformFactory),
                                      (void **)&spDXTransformFactory);

        if (FAILED(hr))
        {
            goto done;
        }

        // Create BasicImage transform.

        hr = spDXTransformFactory->CreateTransform(NULL, 0, NULL, 0, NULL, NULL,
                                                   CLSID_BasicImageEffects, 
                                                   __uuidof(IDXBasicImage), 
                                                   (void **)&spDXBasicImage);

        if (FAILED(hr))
        {
            goto done;
        }

        // Get IDXTransform interface.

        hr = spDXBasicImage->QueryInterface(__uuidof(IDXTransform),
                                              (void **)&spDXTransform);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDXBasicImage->put_Mask(TRUE);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = DXColorFromBSTR(m_bstrColor, &dwColor);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDXBasicImage->put_MaskColor(dwColor);

        if (FAILED(hr))
        {
            goto done;
        }

        m_spDXBasicImage    = spDXBasicImage;
        m_spDXTransform     = spDXTransform;
    }

done:

    return S_OK;
}
//  Method: CDXTMaskFilter::SetSite, IObjectWithSite


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::get_Color, IDXTMask
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMaskFilter::get_Color(VARIANT * pvarColor)
{
    HRESULT hr = S_OK;

    if (NULL == pvarColor)
    {
        hr = E_POINTER;

        goto done;
    }

    // Copy our stored color and change to BSTR format.  The type of the VARIANT
    // returned by this function is considered the default type and we want it
    // to be BSTR

    VariantClear(pvarColor);

    _ASSERT(m_bstrColor);

    pvarColor->vt       = VT_BSTR;
    pvarColor->bstrVal  = SysAllocString(m_bstrColor);

    if (NULL == pvarColor->bstrVal)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CDXTMaskFilter::get_Color, IDXTMask


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMaskFilter::put_Color, IDXTMask
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMaskFilter::put_Color(VARIANT varColor)
{
    HRESULT hr          = S_OK;
    BSTR    bstrTemp    = NULL;
    DWORD   dwColor     = 0x00000000;

    hr = FilterHelper_GetColorFromVARIANT(varColor, &dwColor, &bstrTemp);

    if (FAILED(hr))
    {
        goto done;
    }

    // If zero is specified as the alpha value, in the case of filters this
    // means the user probably meant that the color should be opaque as this
    // is how the old filters treated it.

    if (!(dwColor & 0xFF000000))
    {
        dwColor |= 0xFF000000;
    }

    if (m_spDXBasicImage)
    {
        hr = m_spDXBasicImage->put_MaskColor((int)dwColor);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    _ASSERT(bstrTemp);

    SysFreeString(m_bstrColor);

    m_bstrColor = bstrTemp;

done:

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    return hr;
}
//  CDXTMaskFilter::put_Color, IDXTMask
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\maskfilter.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       maskfilter.h
//
//  Overview:       The MaskFilter transform simply wraps the BasicImage
//                  transform to ensure backward compatibility for the mask 
//                  filter.
//
//  Change History:
//  1999/09/19  a-matcal    Created.
//
//------------------------------------------------------------------------------

#ifndef __MASKFILTER_H_
#define __MASKFILTER_H_

#include "resource.h"




class ATL_NO_VTABLE CDXTMaskFilter : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDXTMaskFilter, &CLSID_DXTMaskFilter>,
    public IDispatchImpl<IDXTMask, &IID_IDXTMask, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTMaskFilter>,
    public IObjectSafetyImpl2<CDXTMaskFilter>,
    public IPersistStorageImpl<CDXTMaskFilter>,
    public ISpecifyPropertyPagesImpl<CDXTMaskFilter>,
    public IPersistPropertyBagImpl<CDXTMaskFilter>,
    public IDXTransform,
    public IObjectWithSite
{
private:

    BSTR                    m_bstrColor;

    CComPtr<IDXBasicImage>  m_spDXBasicImage;
    CComPtr<IDXTransform>   m_spDXTransform;

    CComPtr<IUnknown>       m_spUnkSite;
    CComPtr<IUnknown>       m_spUnkMarshaler;

public:

    CDXTMaskFilter();
    virtual ~CDXTMaskFilter();

    DECLARE_POLY_AGGREGATABLE(CDXTMaskFilter)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTMASKFILTER)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTMaskFilter)
        COM_INTERFACE_ENTRY(IDXTMask)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTransform)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTMaskFilter>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTMaskFilter)
        PROP_ENTRY("color" , 1, CLSID_NULL)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // IObjectWithSite methods.

    STDMETHOD(GetSite)(REFIID riid, void ** ppvSite);
    STDMETHOD(SetSite)(IUnknown * pUnkSite);

    // IDXTMask methods.

    STDMETHOD(get_Color)(VARIANT * pvarColor);
    STDMETHOD(put_Color)(VARIANT varColor);

    // IDXTransform wrappers.

    STDMETHOD(Execute)(const GUID * pRequestID, const DXBNDS * pPortionBnds,
                       const DXVEC * pPlacement)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->Execute(pRequestID, pPortionBnds, pPlacement);
    }
    STDMETHOD(GetInOutInfo)(BOOL bIsOutput, ULONG ulIndex, DWORD * pdwFlags,
                            GUID * pIDs, ULONG * pcIDs, 
                            IUnknown ** ppUnkCurrentObject)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->GetInOutInfo(bIsOutput, ulIndex, pdwFlags,
                                             pIDs, pcIDs, ppUnkCurrentObject);
    }
    STDMETHOD(GetMiscFlags)(DWORD * pdwMiscFlags)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->GetMiscFlags(pdwMiscFlags);
    }
    STDMETHOD(GetQuality)(float * pfQuality)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->GetQuality(pfQuality);
    }
    STDMETHOD(MapBoundsIn2Out)(const DXBNDS * pInBounds, ULONG ulNumInBnds,
                               ULONG ulOutIndex, DXBNDS * pOutBounds)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->MapBoundsIn2Out(pInBounds, ulNumInBnds,
                                                ulOutIndex, pOutBounds);
    }
    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                               ULONG ulInIndex, DXBNDS * pInBounds)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->MapBoundsOut2In(ulOutIndex, pOutBounds, 
                                                ulInIndex, pInBounds);
    }
    STDMETHOD(SetMiscFlags)(DWORD dwMiscFlags)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->SetMiscFlags(dwMiscFlags);
    }
    STDMETHOD(SetQuality)(float fQuality)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->SetQuality(fQuality);
    }
    STDMETHOD(Setup)(IUnknown * const * punkInputs, ULONG ulNumInputs,
	             IUnknown * const * punkOutputs, ULONG ulNumOutputs,	
                     DWORD dwFlags)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->Setup(punkInputs, ulNumInputs, punkOutputs, 
                                      ulNumOutputs, dwFlags);
    }

    // IDXBaseObject wrappers.

    STDMETHOD(GetGenerationId)(ULONG * pnID)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->GetGenerationId(pnID);
    }
    STDMETHOD(GetObjectSize)(ULONG * pcbSize)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->GetObjectSize(pcbSize);
    }
    STDMETHOD(IncrementGenerationId)(BOOL fRefresh)
    {
        if (!m_spDXTransform) { return DXTERR_UNINITIALIZED; }

        return m_spDXTransform->IncrementGenerationId(fRefresh);
    }
};

#endif //__MASKFILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\light.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    light.cpp
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	Implementation of CLight
//
// Change History:
//
// 05/20/99 PhilLu   Move code from dtcss to dxtmsft. Clean up.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "Light.h"

const float PI = 3.14159265359f;


//+-----------------------------------------------------------------------------
//
//  CLight::CLight
//
//------------------------------------------------------------------------------
CLight::CLight() :
    m_lAmount(100),
    m_cLights(0)
{
    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;
}
//  CLight::CLight


//+-----------------------------------------------------------------------------
//
//  CLight::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CLight::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CLight::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CLight::addAmbient, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CLight::addAmbient(int r, int g, int b, int strength)
{
    if (m_cLights < MAXLIGHTS)
    {
        Lock();
        m_apLights[m_cLights++] = new ambientLight(r, g, b, strength);
        if (!m_apLights[m_cLights-1])
        {
            m_cLights--;
            return E_OUTOFMEMORY;
        }

        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CLight::addAmbient, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::addPoint, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP  
CLight::addPoint(int x, int y, int z, int r, int g, int b, int strength) 
{
    if (m_cLights < MAXLIGHTS)
    {
        Lock();
        m_apLights[m_cLights++] = new ptLight(x, y, z, r, g, b, strength);
        if (!m_apLights[m_cLights-1])
        {
            m_cLights--;
            return E_OUTOFMEMORY;
        }

        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CLight::addPoint, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::addCone, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP  
CLight::addCone(int x, int y, int z, int tx, int ty, int r, int g, int b, 
                 int strength, int spread)
{
    if (m_cLights < MAXLIGHTS)
    {
        Lock();
        m_apLights[m_cLights++] = new coneLight(x, y, z, tx, ty, r, g, b, strength, spread);
        if (!m_apLights[m_cLights-1])
        {
            m_cLights--;
            return E_OUTOFMEMORY;
        }

        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CLight::addCone, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::moveLight, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP  
CLight::moveLight(int lightNum, int x, int y, int z, BOOL fAbsolute) 
{
    if (lightNum < m_cLights)
    {
        Lock();
        m_apLights[lightNum]->move(x, y, z, fAbsolute);
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CLight::moveLight, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::ChangeStrength, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP  
CLight::ChangeStrength(int lightNum, int dStrength, BOOL fAbsolute)
{
    if (lightNum < m_cLights)
    {
        Lock();
        m_apLights[lightNum]->changeStrength(dStrength, fAbsolute);
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CLight::ChangeStrength, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::ChangeColor, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CLight::ChangeColor(int lightNum, int R, int G, int B, BOOL fAbsolute)
{
    if (lightNum < m_cLights)
    {
        Lock();
        m_apLights[lightNum]->changeColor(R, G, B, fAbsolute);
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CLight::ChangeColor, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::Clear, IDXTLight
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CLight::Clear()
{
    Lock();
    for (int i = 0; i < m_cLights; i++)
    {
        delete m_apLights[i];
    }

    m_cLights = 0;
    SetDirty();
    Unlock();
    return S_OK;
}
//  CLight::Clear, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CLight::OnSetup(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CDXDBnds bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (SUCCEEDED(hr))
    {
        bndsIn.GetXYSize(m_sizeInput);
    }

    return hr;

}
//  CLight::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CLight::Clear, IDXTLight
//
//------------------------------------------------------------------------------
void 
CLight::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                               ULONG aInIndex[], BYTE aWeight[])
{
    ulInToTest = 1;
    aInIndex[0] = 0;
    aWeight[0] = 255;
}
//  CLight::Clear, IDXTLight


//+-----------------------------------------------------------------------------
//
//  CLight::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT CLight::WorkProc(const CDXTWorkInfoNTo1 & WI, 
                         BOOL * pbContinueProcessing)
{
    HRESULT hr  = S_OK;
    int     y   = 0;

    DXSAMPLE *      pInputBuffer    = NULL;
    DXPMSAMPLE *    pPMBuff         = NULL;
    DXPMSAMPLE *    pOverScratch    = NULL;

    CComPtr<IDXARGBReadWritePtr>    pDest;
    CComPtr<IDXARGBReadPtr>         pSrc;

    DXDITHERDESC dxdd;

    const int nDoWidth  = WI.DoBnds.Width();
    const int nDoHeight = WI.DoBnds.Height();

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, 
                                      (void**)&pDest, NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = InputSurface()->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // If the output surface isn't in PMARGB32 or ARGB32 formats and we're 
    // blending with the output we'll need a scratch buffer blend with the
    // output surface.

    if ((OutputSampleFormat() != DXPF_PMARGB32) 
        && (OutputSampleFormat() != DXPF_ARGB32)
        && DoOver())
    {
        pOverScratch = DXPMSAMPLE_Alloca(nDoWidth);
    }

    // Allocate a working buffer.

    pInputBuffer = DXSAMPLE_Alloca(nDoWidth);

    //  Initialize the dither structure

    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = pInputBuffer;
        dxdd.cSamples       = nDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    // Row loop.

    for (y = 0; y < nDoHeight; y++)
    {
        // Move to the appropriate input row.

        pSrc->MoveToRow(y);

        // Unpack the pixels to our working buffer.

        pSrc->Unpack(pInputBuffer, nDoWidth, FALSE);

        // Light this row of pixels.

        CompLightingRow(WI.DoBnds.Left(), WI.DoBnds.Top() + y, nDoWidth, 
                        pInputBuffer);

        // Dither if requested.

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        // Move to the appropriate output row.

        pDest->MoveToRow(y);

        if (DoOver())
        {
            pPMBuff = DXPreMultArray(pInputBuffer, nDoWidth);
            pDest->OverArrayAndMove(pOverScratch, pPMBuff, nDoWidth);
        }
        else
        {
            pDest->PackAndMove(pInputBuffer, nDoWidth);
        }
    } // Row loop.

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CLight::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CLight::CompLightingRow
//
//------------------------------------------------------------------------------
void
CLight::CompLightingRow(int nStartX, int nStartY, int nWidth, DXSAMPLE *pDrawingBuffer)
{
    int  j  = 0;
    int  k  = 0;

    dRGB     dRGBCurrent;
    DXSAMPLE pix;

    for (j = 0; j < nWidth; j++)
    {
        pix = pDrawingBuffer[j];
        //Is the alpha set?
        if (pix.Alpha)
        {
            //Clear the light sum;
            dRGBCurrent.clear();
            for (k = 0; k < m_cLights; k++)
            {
                //Add in the light contribution
                m_apLights[k]->getLight(nStartX+j, nStartY, dRGBCurrent);
            }
            //Now adjust the screen bits;
            pix.Red = (UCHAR)clamp((ULONG)(pix.Red * dRGBCurrent.m_R), 255);
            pix.Green = (UCHAR)clamp((ULONG)(pix.Green * dRGBCurrent.m_G), 255);
            pix.Blue = (UCHAR)clamp((ULONG)(pix.Blue * dRGBCurrent.m_B), 255);
            pDrawingBuffer[j] = pix;
        }
    }
}
//  CLight::CompLightingRow

    
//+-----------------------------------------------------------------------------
//
//  lightObj::lightObj
//
//  This is the base class for all light types
//  C++ note: need to make the member functions virtual
//------------------------------------------------------------------------------
lightObj::lightObj(int x, int y, int z, int R, int G, int B, int strength)
{
    m_x = x;
    m_y = y;
    m_z = max(1, z);
    m_R = colCvt(R);
    m_G = colCvt(G);
    m_B = colCvt(B);
    if (strength < 0)
    {
        m_strength = 0.0f;
    }
    else
    {
        m_strength = min(1.0f, (float)strength / 100.0f);
    }
}
//  lightObj::lightObj


//+-----------------------------------------------------------------------------
//
//  lightObj::move
//
//  Either relative or absolute move for the light source
//------------------------------------------------------------------------------
void 
lightObj::move(int x, int y, int z, BOOL fAbsolute)
{
    if (!fAbsolute)
    {
        m_x += x;
        m_y += y;
        m_z += z;
    }
    else
    {
        m_x = x;
        m_y = y;
        m_z = z;
    }
    m_z = max(1, m_z);
}
//  lightObj::move


//+-----------------------------------------------------------------------------
//
//  lightObj::changeStregth
//
//------------------------------------------------------------------------------
void 
lightObj::changeStrength(int dStrength, BOOL fAbsolute) 
{
    if (!fAbsolute)
    {
        m_strength += static_cast<float>(dStrength) / 100.0f;
    }
    else
    {
        m_strength = static_cast<float>(dStrength) / 100.0f;
    }
    m_strength = min(1.0f, max(0.0f, m_strength));
}
//  lightObj::changeStregth


//+-----------------------------------------------------------------------------
//
//  lightObj::changeColor
//
//------------------------------------------------------------------------------
void 
lightObj::changeColor(int R, int G, int B, BOOL fAbsolute) 
{
    if (!fAbsolute)
    {
        m_R = lightClip(m_R + relativeColCvt(R));
        m_G = lightClip(m_G + relativeColCvt(G));
        m_B = lightClip(m_B + relativeColCvt(B));
    }
    else
    {
        m_R = colCvt(R);
        m_G = colCvt(G);
        m_B = colCvt(B);
    }
}
//  lightObj::changeColor


//+-----------------------------------------------------------------------------
//
//  ambientLight::ambientLight
//
//------------------------------------------------------------------------------
ambientLight::ambientLight(int R, int G, int B, int strength) : 
    lightObj(0, 0, 0, R, G, B, strength)
{
    premultiply();
}
//  ambientLight::ambientLight


//+-----------------------------------------------------------------------------
//
//  ambientLight::changeStrength, lightObj
//
//------------------------------------------------------------------------------
void 
ambientLight::changeStrength(int dStrength, BOOL fAbsolute)
{
    lightObj::changeStrength(dStrength,fAbsolute);
    premultiply();
}
//  ambientLight::changeStrength, lightObj

	
//+-----------------------------------------------------------------------------
//
//  ambientLight::changeColor, lightObj
//
//------------------------------------------------------------------------------
void 
ambientLight::changeColor(int R, int G, int B, BOOL fAbsolute)
{
    lightObj::changeColor(R, G, B, fAbsolute);
    premultiply();
}
//  ambientLight::changeColor, lightObj


//+-----------------------------------------------------------------------------
//
//  ambientLight::getLight, lightObj
//
//------------------------------------------------------------------------------
void 
ambientLight::getLight(int x, int y, dRGB &col) 
{
    //Calculate ambient values
    col.add(m_RStr, m_GStr, m_BStr);
}
//  ambientLight::getLight, lightObj


//+-----------------------------------------------------------------------------
//
//  ambientLight::premultiply
//
//------------------------------------------------------------------------------
void 
ambientLight::premultiply(void)
{
    m_RStr = m_R * m_strength;
    m_GStr = m_G * m_strength;
    m_BStr = m_B * m_strength;
}
//  ambientLight::premultiply


//+-----------------------------------------------------------------------------
//
//  ptLight::ptLight
//
//------------------------------------------------------------------------------
ptLight::ptLight(int x, int y, int z, int R, int G, int B, int strength) :
    lightObj(x, y, z, R, G, B, strength),
    bounded()
{
    CalculateBoundingRect();
}
//  ptLight::ptLight


//+-----------------------------------------------------------------------------
//
//  ptLight::CalculateBoundingRect, bounded
//
//  The idea is to not calculate anything that falls
//  so far away it's beneath a strength threshold.
//  strength = (m_strength / r^2) * cos(alpha)
//  where r = [ ((x-m_x)^2 + (y-m_y)^2 + m_z^2)^1/2 ] / m_z;
//  and cos(alpha) is really just 1/r.
//  We solve for threshold = m_strength * (m_z/rT)^3
//  where rT = iRadius^2 + m_z^2 and we don't consider
//  pixels lying outside the rect given by iRadius and m_x, m_y.
//  Note: the getLight function uses m_strength * m_z^3 
//  and m_z^2 for each x,y; so pre-calc these here too.
//------------------------------------------------------------------------------
void 
ptLight::CalculateBoundingRect(void)
{
    float  fltDistNormal = (float) abs(m_z);
    float  fltThresh     = (float) s_iThresholdStr / 255.0f;
    int    iRadius;
    RECT   rectBounds;
    float  fltMaxClrStr;

    m_fltNormalDistSquared  = fltDistNormal * fltDistNormal;
    m_fltIntensityNumerator = m_strength * 
                              fltDistNormal * 
                              m_fltNormalDistSquared;

    fltMaxClrStr = m_R;
    if (m_G > fltMaxClrStr)
    {
        fltMaxClrStr = m_G;
    }

    if (m_B > fltMaxClrStr)
    {
        fltMaxClrStr = m_B;
    }

    fltMaxClrStr *= m_strength;

    if ((fltMaxClrStr > 0.0f) && 
        (m_fltIntensityNumerator > 0.0f))
    {
        iRadius = (int)(
            fltDistNormal * 
            (float) sqrt(pow(fltMaxClrStr,2.0f/3.0f) *
                          pow(fltThresh, -2.0f/3.0f) -
                          1.0f));

        rectBounds.left   = m_x - iRadius;
        rectBounds.right  = m_x + iRadius;
        rectBounds.top    = m_y - iRadius;
        rectBounds.bottom = m_y + iRadius;	
    }
    else
    {
        rectBounds.left  = rectBounds.top    = 0;
        rectBounds.right = rectBounds.bottom = 0;
    }

    SetRect(rectBounds);
}
//  ptLight::CalculateBoundingRect, bounded


//+-----------------------------------------------------------------------------
//
//  ptLight::changeColor, lightObj
//
//------------------------------------------------------------------------------
void 
ptLight::changeColor(int R, int G, int B, BOOL fAbsolute)
{
    lightObj::changeColor(R, G, B, fAbsolute);
    CalculateBoundingRect();
}
//  ptLight::changeColor, lightObj


//+-----------------------------------------------------------------------------
//
//  ptLight::changeColor, lightObj
//
//------------------------------------------------------------------------------
void 
ptLight::changeStrength(int dStrength, BOOL fAbsolute)
{
    lightObj::changeStrength(dStrength, fAbsolute);
    CalculateBoundingRect();
}
//  ptLight::changeColor, lightObj


//+-----------------------------------------------------------------------------
//
//  ptLight::getLight, lightObj
//
//------------------------------------------------------------------------------
#pragma optimize("agt", on)
void 
ptLight::getLight(int x, int y, dRGB &col)
{
    //Light strength
    float n;
    float dp;

    if (InBounds(x, y))
    {
        dp = (((float)(x - m_x) * (float)(x - m_x)) + 
               ((float)(y - m_y) * (float)(y - m_y)) + 
               m_fltNormalDistSquared);

        dp = 1.0f / static_cast<float>(sqrt(dp));
        n = m_fltIntensityNumerator * dp * dp * dp;

        col.add(m_R*n, m_G*n, m_B*n);
    }
}
#pragma optimize("", on)
//  ptLight::getLight, lightObj


//+-----------------------------------------------------------------------------
//
//  ptLight::move, lightObj
//
//------------------------------------------------------------------------------
void 
ptLight::move(int x, int y, int z, BOOL fAbsolute)
{
    lightObj::move(x, y, z, fAbsolute);
    CalculateBoundingRect();
}
//  ptLight::move, lightObj



//+-----------------------------------------------------------------------------
//
//  coneLight::coneLight
//  Here's the constructor. Note that it takes extra parameters
//
//------------------------------------------------------------------------------
coneLight::coneLight(int x, int y, int z, int targX, int targY, int R, int G, 
                     int B, int strength, int spread) : 
	lightObj(x, y, z, R, G, B, strength)
{
    m_targdx = targX - m_x;
    m_targdy = targY - m_y;	

    //Convert cone spread to cosine range
    m_conespread = (float) cos(abs(spread)*PI/180.0);
    if (m_conespread < 0.0f)
        m_conespread = 0.0f;	

    CalculateConstants();
}
//  coneLight::coneLight


//+-----------------------------------------------------------------------------
//
//  coneLight::CalculateConstants
//  Here's the constructor. Note that it takes extra parameters
//
//------------------------------------------------------------------------------
void coneLight::CalculateConstants(void)
{
    float fltDistTargetSquared;

    m_fltDistNormalSquared = (float)(m_z * m_z);

    fltDistTargetSquared   = ((float)m_targdx * (float)m_targdx) +
                             ((float)m_targdy * (float)m_targdy) + 
                             m_fltDistNormalSquared;

    m_fltComparisonAngle = m_conespread * 
                           m_conespread * 
                           fltDistTargetSquared;
}
//  coneLight::CalculateConstants


//+-----------------------------------------------------------------------------
//
//  coneLight::getLight, lightObj
//
//------------------------------------------------------------------------------
#pragma optimize("agt", on)
void coneLight::getLight(int x, int y, dRGB &col)
{
    float  fltDistPSquared =    0.0f;	
    float  fltDotSquared =      0.0f;
    float  fltDenom =           0.0f;
    float  fltStr =             0.0f;

    float  fltDot = ((m_targdx) * (x-m_x)) + 
                    ((m_targdy) * (y-m_y)) +
                    m_fltDistNormalSquared;

    if (fltDot < 0.0f)
        return;

    fltDotSquared = fltDot * fltDot;
    fltDistPSquared = ((float)(x-m_x) * (float)(x-m_x)) +
                        ((float)(y-m_y) * (float)(y-m_y)) +
                        m_fltDistNormalSquared;

    // We want to compare the angle between
    // vector-xy and vector-target with m_conespread.
    // Instead we compare the cosine-squared of the angle,
    // which we get by squaring the dot-product and
    // cross-multiplying by the vector magnitudes.
    // The target vector magnitude has been pre-calculated.
    // The fltDot<0 test above preserves sign and early-outs.
    // No division, no sqrt, save those for col.add pixels.
    if (fltDotSquared >= 
        (fltDistPSquared * m_fltComparisonAngle))
    {
        // strength = m_strength * cos^2(xy-to-target) * 1/r^2
        // cos(xy-to-target) = fltDot / 
        //            sqrt(fltDistPSquared*fltDistTargetSquared)
        // cos^2 is close enough and avoids a sqrt!
        // and 1/r^2 ~= m_fltDistTargetSquared/fltDistPSquared
        // All this reduces to ...

        fltDenom = fltDistPSquared * fltDistPSquared;
        fltStr   = m_strength * fltDotSquared / fltDenom;

        col.add(m_R*fltStr, m_G*fltStr, m_B*fltStr);
    }
}
#pragma optimize("", on)
//  coneLight::getLight, lightObj



//+-----------------------------------------------------------------------------
//
//  coneLight::getLight, lightObj
//  Relative move of the target not source
//
//------------------------------------------------------------------------------
void 
coneLight::move(int x, int y, int z, BOOL fAbsolute)
{
    if (!fAbsolute)
    {
        m_targdx += x;
        m_targdy += y;
    }
    else
    {
        m_targdx = x - m_x;
        m_targdy = y - m_y;
    }

    CalculateConstants();
}
//  coneLight::getLight, lightObj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\light.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    light.h
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	This is the header file for the light transformation.
//
// Change History:
//
// 1999/05/20 phillu    Move from dtcss to dxtmsft. Re-implemented algorithms
//                      for creating linear/rectangular/elliptic surfaces.
// 2000/05/10 mcalkins  Support IObjectSafety appropriately.
//
//------------------------------------------------------------------------------

#ifndef __LIGHT_H_
#define __LIGHT_H_

#include "resource.h"

class lightObj;




class ATL_NO_VTABLE CLight : 
    public CDXBaseNTo1,
    public CComCoClass<CLight, &CLSID_DXTLight>,
    public CComPropertySupport<CLight>,
    public IDispatchImpl<IDXTLight, &IID_IDXTLight, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CLight>,
    public IPersistStorageImpl<CLight>,
    public ISpecifyPropertyPagesImpl<CLight>,
    public IPersistPropertyBagImpl<CLight>
{
private:

    enum { MAXLIGHTS = 10 };

    long                m_lAmount;
    lightObj *          m_apLights[MAXLIGHTS];
    int                 m_cLights;
    SIZE                m_sizeInput;
    CComPtr<IUnknown>   m_cpUnkMarshaler;

    inline DWORD clamp(DWORD i, DWORD d)
    {
        if (i <= d)
            return (i & d);
        else
            return d;
    }

    void CompLightingRow(int nStartX, int nStartY, int nWidth, 
                         DXSAMPLE *pBuffer);

public:

    CLight();

    ~CLight()
    {
        Clear();
    }

    DECLARE_POLY_AGGREGATABLE(CLight)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_LIGHT)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CLight)
        COM_INTERFACE_ENTRY(IDXTLight)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CLight>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CLight)
        PROP_PAGE(CLSID_DXTLightPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing);
    void    OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest,
                                  ULONG aInIndex[], BYTE aWeight[]);
    HRESULT OnSetup(DWORD dwFlags);

    // IDXTLight methods.

    STDMETHOD(addAmbient)(int r, int g, int b, int strength);
    STDMETHOD(addPoint)(int x, int y, int z, int r, int g, int b, int strength);
    STDMETHOD(addCone)(int x, int y, int z, int tx, int ty, int r, int g, int b, int strength, int spread);
    STDMETHOD(moveLight)(int lightNum, int x, int y, int z, BOOL fAbsolute);
    STDMETHOD(ChangeStrength)(int lightNum, int dStrength, BOOL fAbsolute);
    STDMETHOD(ChangeColor)(int lightNum, int R, int G, int B, BOOL fAbsolute);
    STDMETHOD(Clear)();
};

//
//  This class stores and manages a color
//
class dRGB 
{
public: // to simplify some code ...

    float m_R, m_G, m_B;

public:

    dRGB() : m_R(0.0f), m_G(0.0f), m_B(0.0f) {};

    inline void clear()
    { 
        m_R = m_G = m_B = 0.0f; 
    }

    inline void set(float R, float G, float B)
    {
        m_R = R; m_G = G; m_B = B;
    }

    inline void add(const dRGB & c)
    {
        m_R += c.m_R; m_G += c.m_G; m_B += c.m_B;
    }

    inline void add(float R, float G, float B)
    {
        m_R += R; m_G += G; m_B += B;
    }
};


// 
// This is the base class for all light types
// 
class lightObj 
{
protected:

    int m_x, m_y, m_z;    //Coordinates of the light source
    float m_R, m_G, m_B;  //Light color
    float m_strength;     //Light strength

    // helper
    inline float lightClip(float v)
    {
        if (v < 0.0f) v = 0.0f;
        if (v > 1.0f) v = 1.0f;
        return v;
    }

public:

    lightObj(int x, int y, int z, int R, int G, int B, int strength);

    virtual void getLight(int x, int y, dRGB &col){}
    virtual void move(int x, int y, int z, BOOL fAbsolute);
    virtual void changeStrength(int dStrength, BOOL fAbsolute);
    virtual void changeColor(int R, int G, int B, BOOL fAbsolute);

    //Converts a color value (0..255) to a percent
    //Clips to valid range
    inline float lightObj::colCvt(int c)
    {
        if (c < 0) c = 0;
        if (c > 255) c = 255;
        return ((float) c)/255.0f;
    }

    inline float lightObj::relativeColCvt( int c )
    {
        if( c < -255 ) c = -255;
        if( c > 255 ) c = 255;
        return static_cast<float>(c) / 255.0f;
    }
};

//
//  Implement ambient light
//  Ambient light isn't effected by position
//
class ambientLight : 
    public lightObj 
{
private:

    float  m_RStr, m_GStr, m_BStr;

    void  premultiply(void);

public:

    ambientLight(int R, int G, int B, int strength);

    // overrides lightObj functions
    void getLight(int x, int y, dRGB &col);
    void changeStrength(int dStrength, BOOL fAbsolute);
    void changeColor(int R, int G, int B, BOOL fAbsolute);
};

//
//  Helper class to implement rectangular bounds checking
//
class bounded
{
private:

    RECT  m_rectBounds;

public:
    bounded(){ClearBoundingRect();}
    bounded(const RECT & rectBounds){SetRect(rectBounds);}
    bounded(int left, int top, int right, int bottom )
    {
        RECT rectBound;
        ::SetRect( &m_rectBounds, left, top, right, bottom );
        SetRect( rectBound );
    }

    virtual ~bounded(){}

    virtual void CalculateBoundingRect() = 0;
    virtual void ClearBoundingRect()
    { 
        m_rectBounds.left   = LONG_MIN;
        m_rectBounds.top    = LONG_MIN;
        m_rectBounds.right  = LONG_MAX;
        m_rectBounds.bottom = LONG_MAX;
    }

    inline BOOL InBounds( POINT & pt )
    {
        return PtInRect( &m_rectBounds, pt ); 
    }

    inline BOOL InBounds( int x, int y )
    {
        // Intentional bitwise-AND for speed
        return( (x >= m_rectBounds.left)  &
                (x <= m_rectBounds.right) & 
                (y >= m_rectBounds.top)   &
                (y <= m_rectBounds.bottom) );
    }

    void GetRect(RECT & theRect) const { theRect = m_rectBounds; }
    void SetRect(const RECT & theRect) { m_rectBounds = theRect; }
};


//
// Implement a point light source
// A point light drops off proportionate to the cosine of the angle between 
// the light vector and the viewer vector
//
class ptLight : 
    public lightObj, 
    public bounded
{
private:

    float  m_fltIntensityNumerator;
    float  m_fltNormalDistSquared;

    enum { s_iThresholdStr = 8 };

public:
    ptLight(int x, int y, int z, int R, int G, int B, int strength);

    // overrides lightObj::
    virtual void changeColor(int R, int G, int B, BOOL fAbsolute);
    virtual void changeStrength(int dStrength, BOOL fAbsolute);
    virtual void getLight(int x, int y, dRGB &col);
    virtual void move(int x, int y, int z, BOOL fAbsolute);

    // overrides bounded::
    virtual void CalculateBoundingRect( void );
};


//
// Implement a cone light source
//
class coneLight : 
    public lightObj 
{
private:

    int   m_targdx;
    int   m_targdy;
    float m_fltDistTargetSquared;
    float m_fltDistNormalSquared;
    float m_fltComparisonAngle;	
    float m_conespread;

    virtual void CalculateConstants();

public:

    // constructor. Note that it takes extra parameters
    coneLight(int x, int y, int z, int targX, int targY, int R, int G, int B, 
              int strength, int spread);

    // overrides lightObj
    void getLight(int x, int y, dRGB &col);
    virtual void move(int x, int y, int, BOOL fAbsolute);
};


#endif //__LIGHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\matrix.cpp ===
//+-----------------------------------------------------------------------------
//
//  Filename:       matrix.cpp
//
//  Overview:       Applies a transformation matrix to an image.
//
//  History:
//  1998/10/30      phillu      Created.
//  1999/11/08      a-matcal    Changed from procedural surface to transform.
//                              Changed to IDXTWarp dual interface.
//                              Moved from dxtrans.dll to dxtmsft.dll.
//  2000/02/03      mcalkins    Changed from "warp" to "matrix"
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "matrix.h"




//+-----------------------------------------------------------------------------
//
//  CDXTMatrix static variables initialization.
//
//------------------------------------------------------------------------------

const WCHAR * CDXTMatrix::s_astrFilterTypes[] = {
    L"nearest",
    L"bilinear",
    L"cubic",
    L"bspline"
};

const WCHAR * CDXTMatrix::s_astrSizingMethods[] = {
    L"clip to original",
    L"auto expand"
};


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::CDXTMatrix
//
//------------------------------------------------------------------------------
CDXTMatrix::CDXTMatrix() :
    m_apsampleRows(NULL),
    m_asampleBuffer(NULL),
    m_eFilterType(BILINEAR),
    m_eSizingMethod(CLIP_TO_ORIGINAL),
    m_fInvertedMatrix(true)
{
    m_matrix.eOp            = DX2DXO_GENERAL_AND_TRANS;
    m_matrixInverted.eOp    = DX2DXO_GENERAL_AND_TRANS;

    m_sizeInput.cx          = 0;
    m_sizeInput.cy          = 0;

    // Base class members.

    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;
}
//  CDXTMatrix::CDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::~CDXTMatrix
//
//------------------------------------------------------------------------------
CDXTMatrix::~CDXTMatrix() 
{
    delete [] m_asampleBuffer;
    delete [] m_apsampleRows;
}
//  CDXTMatrix::~CDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT
CDXTMatrix::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  CDXTMatrix::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTMatrix::OnSetup(DWORD dwFlags)
{
    HRESULT hr  = S_OK;
    int     i   = 0;
    
    CDXDBnds bnds;

    hr = InputSurface()->GetBounds(&bnds);

    if (FAILED(hr))
    {
        goto done;
    }

    bnds.GetXYSize(m_sizeInput);

    _CreateInvertedMatrix();

    // Allocate a buffer to hold the input surface.

    delete [] m_asampleBuffer;
    delete [] m_apsampleRows;

    m_asampleBuffer = new DXSAMPLE[(m_sizeInput.cx + 2) * (m_sizeInput.cy + 2)];
    m_apsampleRows  = new DXSAMPLE *[m_sizeInput.cy + 2];

    if ((NULL == m_apsampleRows) || (NULL == m_asampleBuffer))
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    // m_apsampleRows is an array of pointers to the first sample of each row
    // of the input.  We need to set up these pointers now.  We add two pixels
    // the the row width because there will be a clear pixel on the right and
    // left side to help us anti-alias the border of the output.

    for (i = 0 ; i < (m_sizeInput.cy + 2) ; i++)
    {
        m_apsampleRows[i] = &m_asampleBuffer[i * (m_sizeInput.cx + 2)];
    }

    hr = _UnpackInputSurface();

    if (FAILED(hr))
    {
        goto done;
    }

    // Set the border pixels to clear.

    for (i = 0 ; i < m_sizeInput.cy ; i++)
    {
        m_apsampleRows[i + 1][0]                    = 0;
        m_apsampleRows[i + 1][m_sizeInput.cx + 1]   = 0;
    }

    for (i = 0 ; i <= (m_sizeInput.cx + 1) ; i++)
    {
        m_apsampleRows[0][i]                    = 0;
        m_apsampleRows[m_sizeInput.cy + 1][i]   = 0;
    }

done:

    return hr;
}
//  CDXTMatrix::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::DetermineBnds, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTMatrix::DetermineBnds(CDXDBnds & Bnds)
{
    if (AUTO_EXPAND == m_eSizingMethod)
    {
        RECT        rc;
        DXFPOINT    flptIn;
        DXFPOINT    flptOut;

        // Top/Left

        flptIn.x = (float)Bnds.Left();
        flptIn.y = (float)Bnds.Top();

        m_matrix.TransformPoints(&flptIn, &flptOut, 1);

        rc.top      = (long)flptOut.y;
        rc.bottom   = (long)(flptOut.y + 0.5F);
        rc.left     = (long)flptOut.x;
        rc.right    = (long)(flptOut.x + 0.5F);

        // Bottom/Left

        flptIn.y = (float)(Bnds.Bottom() - 1);

        m_matrix.TransformPoints(&flptIn, &flptOut, 1);

        rc.top      = min(rc.top,       (long)flptOut.y);
        rc.bottom   = max(rc.bottom,    (long)(flptOut.y + 0.5F));
        rc.left     = min(rc.left,      (long)flptOut.x);
        rc.right    = max(rc.right,     (long)(flptOut.x + 0.5F));

        // Bottom/Right

        flptIn.x = (float)(Bnds.Right() - 1);

        m_matrix.TransformPoints(&flptIn, &flptOut, 1);

        rc.top      = min(rc.top,       (long)flptOut.y);
        rc.bottom   = max(rc.bottom,    (long)(flptOut.y + 0.5F));
        rc.left     = min(rc.left,      (long)flptOut.x);
        rc.right    = max(rc.right,     (long)(flptOut.x + 0.5F));

        // Top/Right

        flptIn.y = (float)Bnds.Top();

        m_matrix.TransformPoints(&flptIn, &flptOut, 1);

        rc.top      = min(rc.top,       (long)flptOut.y);
        rc.bottom   = max(rc.bottom,    (long)(flptOut.y + 0.5F));
        rc.left     = min(rc.left,      (long)flptOut.x);
        rc.right    = max(rc.right,     (long)(flptOut.x + 0.5F));

        OffsetRect(&rc, -rc.left, -rc.top);

        // Since we calculated the bounds using points, we need to increment the
        // bottom and right values to have the bounds include all relevent 
        // points.

        rc.bottom++;
        rc.right++;

        Bnds.SetXYRect(rc);
    }

    return S_OK;
}
//  CDXTMatrix::DetermineBnds, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMatrix::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;

    if (IsInputDirty())
    {
        hr = _UnpackInputSurface();
    }
        
    return hr;
}
//  CDXTMatrix::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTMatrix::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT     hr          = S_OK;
    DXFPOINT    flptFirstDoPtInRow;

    long        nDoHeight   = WI.DoBnds.Height();
    long        nDoWidth    = WI.DoBnds.Width();
    long        y           = 0;

    CComPtr<IDXARGBReadWritePtr>    spDXARGBReadWritePtr;

    DXSAMPLE *      asampleRowBuffer        = DXSAMPLE_Alloca(nDoWidth);
    DXBASESAMPLE *  abasesampleRowScratch   = DXBASESAMPLE_Alloca(nDoWidth);

    // If the current matrix can't produce an inverted matrix, there's no
    // visible output and we don't need to render.

    if (!m_fInvertedMatrix)
    {
        goto done;
    }

    // Get pointer to output surface.

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut,
                                      DXLOCKF_READWRITE, 
                                      __uuidof(IDXARGBReadWritePtr),
                                      (void **)&spDXARGBReadWritePtr, NULL);

    if (FAILED(hr))
    {
        goto done;
    }
                                      
    // Transform the start point and step vector to the input coordinates.

    flptFirstDoPtInRow.x = (float)WI.DoBnds.Left();

    for (y = 0 ; (y < nDoHeight) && *pbContinue ; y++)
    {
        DXFPOINT flpt;

        flptFirstDoPtInRow.y = (float)(WI.DoBnds.Top() + y);

        // Store the first input point needed in flpt.

        m_matrixInverted.TransformPoints(&flptFirstDoPtInRow, &flpt, 1);

        switch (m_eFilterType)
        {
        case BILINEAR:

            hr = _DoBilinearRow(asampleRowBuffer, &flpt, nDoWidth);
            break;

        default:

            hr = _DoNearestNeighbourRow(asampleRowBuffer, &flpt, nDoWidth);
            break;
        }

        if (FAILED(hr))
        {
            goto done;
        }

        // Write row to output surface.

        spDXARGBReadWritePtr->MoveToRow(y);

        if (DoOver())
        {
            DXPMSAMPLE * ppmsampleFirst = DXPreMultArray(asampleRowBuffer, 
                                                         nDoWidth);

            spDXARGBReadWritePtr->OverArrayAndMove(abasesampleRowScratch, 
                                                   ppmsampleFirst,
                                                   nDoWidth);
        }
        else
        {
            spDXARGBReadWritePtr->PackAndMove(asampleRowBuffer, nDoWidth);
        }
    }

done:

    return hr;
}
//  CDXTMatrix::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTMatrix::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                        CDXDVec & InVec)
{
    DXFPOINT    flptIn;
    DXFPOINT    flptOut;

    ulInputIndex = 0;

    // If the current matrix can't be inverted, there's no visible output and
    // therefore no point on the input could have been hit.

    if (!m_fInvertedMatrix)
    {
        return S_FALSE;
    }

    flptOut.x = (float)OutPoint.u.D[DXB_X].Min;
    flptOut.y = (float)OutPoint.u.D[DXB_Y].Min;

    m_matrixInverted.TransformPoints(&flptOut, &flptIn, 1);

    InVec.u.D[DXB_X] = (long)flptIn.x;
    InVec.u.D[DXB_Y] = (long)flptIn.y;

    // If this is a point outside the original element bounds or the point hit
    // is very translucent, we aren't hit.

    if ((InVec.u.D[DXB_X] < 0) 
        || (InVec.u.D[DXB_X] >= m_sizeInput.cx)
        || (InVec.u.D[DXB_Y] < 0)
        || (InVec.u.D[DXB_Y] >= m_sizeInput.cy)
        || (0 == (m_apsampleRows[InVec.u.D[DXB_Y] + 1][InVec.u.D[DXB_X] + 1]
                   & 0xFF000000)))
    {
        return S_FALSE;
    }
    
    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::MapBoundsOut2In, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                            ULONG ulInIndex, DXBNDS * pInBounds)
{
    if (ulOutIndex || ulInIndex)
    {
        return E_INVALIDARG;
    }

    if ((NULL == pInBounds) || (NULL == pOutBounds))
    {
        return E_POINTER;
    }

    if (m_fInvertedMatrix)
    {
        CDXDBnds    bndsInput;

        // This sets z and t components to reasonable values.

        *pInBounds = *pOutBounds;

        // TransformBounds has problems: it doesn't compute bounding boxes,
        // instead it assumes the top-left point of the input maps to top-left
        // of the output, etc.  Instead, call TransformPoints and do the rest of 
        // the work myself.

        DXFPOINT OutPoints[4], InPoints[4];
        
        OutPoints[0].x = (float)pOutBounds->u.D[DXB_X].Min;
        OutPoints[0].y = (float)pOutBounds->u.D[DXB_Y].Min;
        OutPoints[1].x = (float)pOutBounds->u.D[DXB_X].Min;
        OutPoints[1].y = (float)(pOutBounds->u.D[DXB_Y].Max - 1);
        OutPoints[2].x = (float)(pOutBounds->u.D[DXB_X].Max - 1);
        OutPoints[2].y = (float)pOutBounds->u.D[DXB_Y].Min;
        OutPoints[3].x = (float)(pOutBounds->u.D[DXB_X].Max - 1);
        OutPoints[3].y = (float)(pOutBounds->u.D[DXB_Y].Max - 1);

        m_matrixInverted.TransformPoints(OutPoints, InPoints, 4);

        pInBounds->u.D[DXB_X].Min = pInBounds->u.D[DXB_X].Max = (LONG)InPoints[0].x;
        pInBounds->u.D[DXB_X].Min = pInBounds->u.D[DXB_Y].Max = (LONG)InPoints[0].y;

        for (int i=1; i<4; ++i)
        {
            if (pInBounds->u.D[DXB_X].Min > (LONG)InPoints[i].x)
            {
                pInBounds->u.D[DXB_X].Min = (LONG)InPoints[i].x;
            }

            if (pInBounds->u.D[DXB_X].Max < (LONG)InPoints[i].x)
            {
                pInBounds->u.D[DXB_X].Max = (LONG)InPoints[i].x;
            }

            if (pInBounds->u.D[DXB_Y].Min > (LONG)InPoints[i].y)
            {
                pInBounds->u.D[DXB_Y].Min = (LONG)InPoints[i].y;
            }

            if (pInBounds->u.D[DXB_Y].Max < (LONG)InPoints[i].y)
            {
                pInBounds->u.D[DXB_Y].Max = (LONG)InPoints[i].y;
            }
        }

        // Since we were working with points, but need to return bounds, we need
        // to increment the Max members so that the bounds include all relevant
        // points.

        pInBounds->u.D[DXB_X].Max++;
        pInBounds->u.D[DXB_Y].Max++;

        // Expand the bounds by one pixel on all sides just to make extra sure 
        // we have the input bounds we need.  (IE6 Bug: 19343)

        pInBounds->u.D[DXB_X].Min--;
        pInBounds->u.D[DXB_Y].Min--;
        pInBounds->u.D[DXB_X].Max++;
        pInBounds->u.D[DXB_Y].Max++;

        // Since we're returning an area of the input surface, we need to 
        // intersect our proposed input bounds with the actual input surface
        // bounds.

        bndsInput.SetXYSize(m_sizeInput);

        ((CDXDBnds *)pInBounds)->IntersectBounds(bndsInput);
    }
    else
    {
        ((CDXDBnds)*pInBounds).SetEmpty();
    }

    return S_OK;
}
//  CDXTMatrix::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_M11, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_M11(float * pflM11)
{
    DXAUTO_OBJ_LOCK;

    if (!pflM11)
    {
        return E_POINTER;
    }

    *pflM11 = m_matrix.eM11;

    return S_OK;
}
//  CDXTMatrix::get_M11, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_M11, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_M11(const float flM11)
{
    DXAUTO_OBJ_LOCK;

    return _SetMatrixValue(MATRIX_M11, flM11);
}
//  CDXTMatrix::put_M11, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_M12, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_M12(float * pflM12)
{
    DXAUTO_OBJ_LOCK;

    if (!pflM12)
    {
        return E_POINTER;
    }

    *pflM12 = m_matrix.eM12;

    return S_OK;
}
//  CDXTMatrix::get_M12, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_M12, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_M12(const float flM12)
{
    DXAUTO_OBJ_LOCK;

    return _SetMatrixValue(MATRIX_M12, flM12);
}
//  CDXTMatrix::put_M12, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_Dx, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_Dx(float * pfldx)
{
    DXAUTO_OBJ_LOCK;

    if (!pfldx)
    {
        return E_POINTER;
    }

    *pfldx = m_matrix.eDx;

    return S_OK;
}
//  CDXTMatrix::get_Dx, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_Dx, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_Dx(const float fldx)
{
    DXAUTO_OBJ_LOCK;

    return _SetMatrixValue(MATRIX_DX, fldx);
}
//  CDXTMatrix::put_Dx, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_M21, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_M21(float * pflM21)
{
    DXAUTO_OBJ_LOCK;

    if (!pflM21)
    {
        return E_POINTER;
    }

    *pflM21 = m_matrix.eM21;

    return S_OK;
}
//  CDXTMatrix::get_M21, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_M21, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_M21(const float flM21)
{
    DXAUTO_OBJ_LOCK;

    return _SetMatrixValue(MATRIX_M21, flM21);
}
//  CDXTMatrix::put_M21, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_M22, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_M22(float * pflM22)
{
    DXAUTO_OBJ_LOCK;

    if (!pflM22)
    {
        return E_POINTER;
    }

    *pflM22 = m_matrix.eM22;

    return S_OK;
}
//  CDXTMatrix::get_M22, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_M22, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_M22(const float flM22)
{
    DXAUTO_OBJ_LOCK;

    return _SetMatrixValue(MATRIX_M22, flM22);
}
//  CDXTMatrix::put_M22, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_Dy, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_Dy(float * pfldy)
{
    DXAUTO_OBJ_LOCK;

    if (!pfldy)
    {
        return E_POINTER;
    }

    *pfldy = m_matrix.eDy;

    return S_OK;
}
//  CDXTMatrix::get_Dy, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_Dy, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_Dy(const float fldy)
{
    DXAUTO_OBJ_LOCK;

    return _SetMatrixValue(MATRIX_DY, fldy);
}
//  CDXTMatrix::put_Dy, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_SizingMethod, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_SizingMethod(BSTR * pbstrSizingMethod)
{
    DXAUTO_OBJ_LOCK;

    if (!pbstrSizingMethod)
    {
        return E_POINTER;
    }

    if (*pbstrSizingMethod != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrSizingMethod = SysAllocString(s_astrSizingMethods[m_eSizingMethod]);

    if (NULL == *pbstrSizingMethod)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTMatrix::get_SizingMethod, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_SizingMethod, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_SizingMethod(const BSTR bstrSizingMethod)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr  = S_OK;
    int     i   = 0;

    if (NULL == bstrSizingMethod)
    {
        hr = E_POINTER;

        goto done;
    }

    for ( ; i < (int)SIZINGMETHOD_MAX ; i++)
    {
        if (!_wcsicmp(s_astrSizingMethods[i], bstrSizingMethod))
        {
            m_eSizingMethod = (SIZINGMETHOD)i;

            SetDirty();

            goto done;
        }
    }

    hr = E_INVALIDARG;

done:

    return hr;
}
//  CDXTMatrix::put_SizingMethod, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::get_FilterType, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::get_FilterType(BSTR * pbstrFilterType)
{
    DXAUTO_OBJ_LOCK;

    if (!pbstrFilterType)
    {
        return E_POINTER;
    }

    if (*pbstrFilterType != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrFilterType = SysAllocString(s_astrFilterTypes[m_eFilterType]);

    if (NULL == *pbstrFilterType)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTMatrix::get_FilterType, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::put_FilterType, IDXTMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::put_FilterType(const BSTR bstrFilterType)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr  = S_OK;
    int     i   = 0;

    if (NULL == bstrFilterType)
    {
        hr = E_POINTER;

        goto done;
    }

    for ( ; i < (int)FILTERTYPE_MAX ; i++)
    {
        if (!_wcsicmp(s_astrFilterTypes[i], bstrFilterType))
        {
            m_eFilterType = (FILTERTYPE)i;

            SetDirty();

            goto done;
        }
    }

    hr = E_INVALIDARG;

done:

    return hr;
}
//  CDXTMatrix::put_FilterType, IDXTMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::_DoNearestNeighbourRow
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::_DoNearestNeighbourRow(DXSAMPLE * psampleRowBuffer, DXFPOINT * pflpt, 
                                 long cSamples)
{
    _ASSERT(psampleRowBuffer);
    _ASSERT(pflpt);

    float       fldx    = m_matrixInverted.eM11;
    float       fldy    = m_matrixInverted.eM21;
    long        i       = 0;

    // TODO:  This method will work fine when we convert to using a direct 
    //        pointer to the input pixels in certain cases.  Just remove the
    //        "+ 1"s. 

    for ( ; i < cSamples ; i++)
    {
        if ((pflpt->x >= -0.5F) 
            && (pflpt->x < (float)m_sizeInput.cx - 0.5F) 
            && (pflpt->y >= -0.5F) 
            && (pflpt->y < ((float)m_sizeInput.cy - 0.5F)))
        {
            // Round to the nearest pixel and use that.

            // Note:  the array buffer index is off by 1 in both X and Y 
            // directions.

            long x = (long)(pflpt->x + 0.5F) + 1;
            long y = (long)(pflpt->y + 0.5F) + 1;
        
            psampleRowBuffer[i] = m_apsampleRows[y][x];
        }
        else
        {
            psampleRowBuffer[i] = 0;
        }
        
        // There is a potential for drift here with very large images and 
        // certain matrices.

        pflpt->x += fldx;
        pflpt->y += fldy;
    }

    return S_OK;
}
//  CDXTMatrix::_DoNearestNeighbourRow


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::_DoBilinearRow
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::_DoBilinearRow(DXSAMPLE * psampleRowBuffer, DXFPOINT * pflpt, 
                         long cSamples)
{
    _ASSERT(psampleRowBuffer);
    _ASSERT(pflpt);

    float   fldx    = m_matrixInverted.eM11;
    float   fldy    = m_matrixInverted.eM21;
    float   flInt   = 0.0F;
    long    i       = 0;

    // Bilinear resampling: the one-pixel frame at the four edges of the 
    // surface automatically takes care of the anti-aliasing at the edge.

    for ( ; i < cSamples ; i++)
    {
        if ((pflpt->x >= -1.0F) 
            && (pflpt->x < (float)m_sizeInput.cx) 
            && (pflpt->y >= -1.0F) 
            && (pflpt->y < (float)m_sizeInput.cy))
        {
            // Note:  the array buffer index is off by 1 in both X and Y 
            //        directions, hence the "+ 1"s.

            BYTE    byteWeightX = (BYTE)(modf(pflpt->x + 1, &flInt) * 255.0F);
            long    x           = (long)flInt;

            BYTE    byteWeightY = (BYTE)(modf(pflpt->y + 1, &flInt) * 255.0F);
            long    y           = (long)flInt;
      
            DXSAMPLE sampleT = _DXWeightedAverage2(m_apsampleRows[y][x + 1], 
                                                   m_apsampleRows[y][x], 
                                                   byteWeightX);

            DXSAMPLE sampleB = _DXWeightedAverage2(m_apsampleRows[y + 1][x + 1],
                                                   m_apsampleRows[y + 1][x], 
                                                   byteWeightX);

            psampleRowBuffer[i] = _DXWeightedAverage2(sampleB, sampleT, 
                                                      byteWeightY);
        }
        else
        {
            psampleRowBuffer[i] = 0;
        }

        // There is a potential for drift here with very large images and 
        // certain matrices.

        pflpt->x += fldx;
        pflpt->y += fldy;
    }

    return S_OK;
}
//  CDXTMatrix::_DoBilinearRow


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::_SetMatrixValue
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::_SetMatrixValue(MATRIX_VALUE eMatrixValue, const float flValue)
{
    _ASSERT(eMatrixValue < MATRIX_VALUE_MAX);

    if ((&m_matrix.eM11)[eMatrixValue] != flValue)
    {
        // Update the matrix.

        (&m_matrix.eM11)[eMatrixValue] = flValue;

        _CreateInvertedMatrix();

        SetDirty();
    }

    return S_OK;
}
//  CDXTMatrix::_SetMatrixValue


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::_CreateInvertedMatrix
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::_CreateInvertedMatrix()
{
    HRESULT hr = S_OK;

    CDX2DXForm  matrixTemp = m_matrix;

    if (AUTO_EXPAND == m_eSizingMethod) 
    {
        DXFPOINT    flptOffset;
        DXFPOINT    flptIn;
        DXFPOINT    flptOut;

        // Top/Left

        flptIn.x = 0.0F;
        flptIn.y = 0.0F;

        matrixTemp.TransformPoints(&flptIn, &flptOffset, 1);

        // Bottom/Left

        flptIn.y = (float)(m_sizeInput.cy - 1);

        matrixTemp.TransformPoints(&flptIn, &flptOut, 1);

        flptOffset.x = min(flptOffset.x, flptOut.x);
        flptOffset.y = min(flptOffset.y, flptOut.y);

        // Top/Right

        flptIn.x = (float)(m_sizeInput.cx - 1);
        flptIn.y = 0.0;

        matrixTemp.TransformPoints(&flptIn, &flptOut, 1);

        flptOffset.x = min(flptOffset.x, flptOut.x);
        flptOffset.y = min(flptOffset.y, flptOut.y);

        // Bottom/Right

        flptIn.y = (float)(m_sizeInput.cy - 1);

        matrixTemp.TransformPoints(&flptIn, &flptOut, 1);

        flptOffset.x = min(flptOffset.x, flptOut.x);
        flptOffset.y = min(flptOffset.y, flptOut.y);

        matrixTemp.eDx = matrixTemp.eDx - flptOffset.x;
        matrixTemp.eDy = matrixTemp.eDy - flptOffset.y;
    }

    m_fInvertedMatrix = matrixTemp.Invert();

    m_matrixInverted = matrixTemp;

    return hr;
}
//  CDXTMatrix::_CreateInvertedMatrix


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::_UnpackInputSurface
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMatrix::_UnpackInputSurface()
{
    HRESULT hr  = S_OK;
    int     i   = 0;

    CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

    _ASSERT(InputSurface());
    _ASSERT(m_apsampleRows);
    _ASSERT(m_asampleBuffer);

    hr = InputSurface()->LockSurface(NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                     __uuidof(IDXARGBReadPtr), 
                                     (void**)&spDXARGBReadPtr, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    for (i = 0 ; i < m_sizeInput.cy ; i++)
    {
        spDXARGBReadPtr->MoveToRow(i);

        spDXARGBReadPtr->Unpack(&m_apsampleRows[i + 1][1], m_sizeInput.cx, 
                                FALSE);
    }

done:

    return hr;
}
//  CDXTMatrix::_UnpackInputSurface
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\matrix.h ===
//+-----------------------------------------------------------------------------
//
//  Filename:       matrix.h
//
//  Overview:       Applies a transformation matrix to an image.
//
//  History:
//  10/30/1998      phillu      Created.
//  11/08/1999      a-matcal    Changed from procedural surface to transform.
//                              Changed to IDXTWarp dual interface.
//                              Moved from dxtrans.dll to dxtmsft.dll.
//  2000/02/03      mcalkins    Changed from "warp" to "matrix"
//
//------------------------------------------------------------------------------

#ifndef __MATRIX_H_
#define __MATRIX_H_

#include "resource.h" 
#include <dxtransp.h>
#include <dxtpriv.h>
#include <dxhelper.h>




class ATL_NO_VTABLE CDXTMatrix : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTMatrix, &CLSID_DXTMatrix>,
    public IDispatchImpl<IDXTMatrix, &IID_IDXTMatrix, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTMatrix>,
    public IObjectSafetyImpl2<CDXTMatrix>,
    public IPersistStorageImpl<CDXTMatrix>,
    public IPersistPropertyBagImpl<CDXTMatrix>
{
private:

    CComPtr<IUnknown>           m_spUnkMarshaler;
    CDX2DXForm                  m_matrix;
    CDX2DXForm                  m_matrixInverted;

    SIZE                        m_sizeInput;

    // m_asampleBuffer is a buffer of the entire input image.  Obviously we'll
    // try to get rid of this ASAP.

    DXSAMPLE *                  m_asampleBuffer;

    // m_apsampleRows is an a array of pointers to the rows.  Using this, the
    // samples in m_asampleBuffer can be accessed using the convenient
    // m_apsampleRows[y][x] notation.

    DXSAMPLE **                 m_apsampleRows;

    typedef enum {
        NEAREST = 0,
        BILINEAR,
        CUBIC,
        BSPLINE,
        FILTERTYPE_MAX
    } FILTERTYPE;

    FILTERTYPE                  m_eFilterType;
    static const WCHAR *        s_astrFilterTypes[FILTERTYPE_MAX];

    typedef enum {
        CLIP_TO_ORIGINAL = 0,
        AUTO_EXPAND,
        SIZINGMETHOD_MAX
    } SIZINGMETHOD;

    SIZINGMETHOD                m_eSizingMethod;
    static const WCHAR *        s_astrSizingMethods[SIZINGMETHOD_MAX];

    // m_fInvertedMatrix    True when the current matrix settings are able to be
    //                      inverted.

    unsigned                    m_fInvertedMatrix : 1;

    // If you view CDX2DXForm as an array of floats, these enum values can be
    // used to specify the indices of the values.

    typedef enum {
        MATRIX_M11 = 0,
        MATRIX_M12,
        MATRIX_M21,
        MATRIX_M22,
        MATRIX_DX,
        MATRIX_DY,
        MATRIX_VALUE_MAX
    } MATRIX_VALUE;

    // Helpers.

    float   modf(const float flIn, float * pflIntPortion);
    DWORD   _DXWeightedAverage2(DXBASESAMPLE S1, DXBASESAMPLE S2, 
                                ULONG nWgt);

    // Helpers to calculate one row of transformed pixels.

    STDMETHOD(_DoNearestNeighbourRow)(DXSAMPLE * psampleRowBuffer, 
                                      DXFPOINT * pflpt, long cSamples);
    STDMETHOD(_DoBilinearRow)(DXSAMPLE * psampleRowBuffer,
                              DXFPOINT * pflpt, long cSamples);

    // General Helpers.

    STDMETHOD(_SetMatrixValue)(MATRIX_VALUE eMatrixValue, const float flValue);
    STDMETHOD(_CreateInvertedMatrix)();
    STDMETHOD(_UnpackInputSurface)();
    

public:

    CDXTMatrix();
    virtual ~CDXTMatrix();

    DECLARE_POLY_AGGREGATABLE(CDXTMatrix)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTMATRIX)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTMatrix)
        COM_INTERFACE_ENTRY(IDXTMatrix)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTMatrix>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTMatrix)
        PROP_ENTRY("m11",           DISPID_DXTMATRIX_M11,           CLSID_DXTMatrixPP)
        PROP_ENTRY("m12",           DISPID_DXTMATRIX_M12,           CLSID_DXTMatrixPP)
        PROP_ENTRY("dx",            DISPID_DXTMATRIX_DX,            CLSID_DXTMatrixPP)
        PROP_ENTRY("m21",           DISPID_DXTMATRIX_M21,           CLSID_DXTMatrixPP)
        PROP_ENTRY("m22",           DISPID_DXTMATRIX_M22,           CLSID_DXTMatrixPP)
        PROP_ENTRY("dy",            DISPID_DXTMATRIX_DY,            CLSID_DXTMatrixPP)
        PROP_ENTRY("sizingmethod",  DISPID_DXTMATRIX_SIZINGMETHOD,  CLSID_DXTMatrixPP)
        PROP_ENTRY("filtertype",    DISPID_DXTMATRIX_FILTERTYPE,    CLSID_DXTMatrixPP)
        PROP_PAGE(CLSID_DXTMatrixPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT DetermineBnds(CDXDBnds & Bnds);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);

    // IDXTransform methods.

    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTMatrix properties.

    STDMETHOD(get_M11)(float * pflM11);
    STDMETHOD(put_M11)(const float flM11);
    STDMETHOD(get_M12)(float * pflM12);
    STDMETHOD(put_M12)(const float flM12);
    STDMETHOD(get_Dx)(float * pfldx);
    STDMETHOD(put_Dx)(const float fldx);
    STDMETHOD(get_M21)(float * pflM21);
    STDMETHOD(put_M21)(const float flM21);
    STDMETHOD(get_M22)(float * pflM22);
    STDMETHOD(put_M22)(const float flM22);
    STDMETHOD(get_Dy)(float * pfldy);
    STDMETHOD(put_Dy)(const float fldy);
    STDMETHOD(get_SizingMethod)(BSTR * pbstrSizingMethod);
    STDMETHOD(put_SizingMethod)(const BSTR bstrSizingMethod);
    STDMETHOD(get_FilterType)(BSTR * pbstrFilterType);
    STDMETHOD(put_FilterType)(const BSTR bstrFilterType);
};


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::modf
//
//  Overview:   The usual modf function takes doubles, but we only use floats
//              so lets avoid the conversions.
//
//------------------------------------------------------------------------------
inline float 
CDXTMatrix::modf(const float flIn, float * pflIntPortion)
{
    _ASSERT(pflIntPortion);

    *pflIntPortion = (float)((long)flIn);

    return flIn - (*pflIntPortion);
}
//  CDXTMatrix::modf


//+-----------------------------------------------------------------------------
//
//  Method: CDXTMatrix::_DXWeightedAverage2
//
//  Overview:   The DXWeightedAverage function included in dxhelper.h will 
//              average the color data of a pixel that has no alpha.  This is 
//              a bad thing.  This function checks the alpha first.  It's still
//              a bit messed up, though.  If you have a color 0x01FF0000 and a
//              color 0xFF00FF00 weighted 50/50, should the red really get half
//              the weight?
//
//------------------------------------------------------------------------------
inline DWORD   
CDXTMatrix::_DXWeightedAverage2(DXBASESAMPLE S1, DXBASESAMPLE S2, ULONG nWgt)
{
    if (S1.Alpha || S2.Alpha)
    {
        if (!S1.Alpha)
        {
            S1 = S2 & 0x00FFFFFF;
        }
        else if (!S2.Alpha)
        {
            S2 = S1 & 0x00FFFFFF;
        }

        return DXWeightedAverage(S1, S2, nWgt);
    }

    return 0;
}
//  CDXTMatrix::_DXWeightedAverage2


#endif //__MATRIX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\motionblur.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       motionblur.cpp
//
//  Description:    The motion blur transform class.
//
//  Change History:
//  1999/10/26  a-matcal    Created.
//  1999/11/19  a-matcal    The wrong information was being sent by put_Strength
//                          and put_Direction to _CreateNewBuffer which would
//                          cause a crash in drastic cases, and bad rendering
//                          in most cases.
//          
//                          Also made a fix to the horizontal case where it
//                          would sometimes add pixels to the sum node when
//                          nAddIndex was out of bounds.  This was causing bad
//                          rendering in certain cases.  (Oddly, I never
//                          witnessed a crash.)
//  1999/12/03  a-matcal    Changed default blur direction to 270 instead of 90.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "motionblur.h"




//+-----------------------------------------------------------------------------
//
//  CBlurBuffer::Initialize
//
//------------------------------------------------------------------------------
STDMETHODIMP
CBlurBuffer::Initialize(const short nDirection, const long nStrength, 
                        const long nOutputWidth)
{
    if (1 == nStrength)
    {
        return S_OK;
    }

    m_cRowNodes = nStrength;

    // If this is a purely horizontal blur, we only need one row node, and
    // we don't need any sum nodes.

    if ((90 == nDirection) || (270 == nDirection))
    {
        m_cRowNodes = 1;
    }
    else
    {
        m_pSumNodes = new CSumNode[nOutputWidth];

        if (!m_pSumNodes)
        {
            _FreeAll();

            return E_OUTOFMEMORY;
        }
    }

    m_pRowNodes = new CRowNode[m_cRowNodes];
    m_psamples  = new DXSAMPLE[nOutputWidth * m_cRowNodes];

    if (!m_pRowNodes || !m_psamples)
    {
        _FreeAll();

        return E_OUTOFMEMORY;
    }

    m_nOutputWidth  = nOutputWidth;
    m_nDirection    = nDirection;
    m_nStrength     = nStrength;

    _GenerateStructure();

    return S_OK;
}
//  CBlurBuffer::Initialize


//+-----------------------------------------------------------------------------
//
//  CBlurBuffer::GetSumNodePointers
//
//------------------------------------------------------------------------------
void 
CBlurBuffer::GetSumNodePointers(CSumNode ** ppSumNodeFirstCol,
                                CSumNode ** ppSumNodeFirstAdd,
                                const CDXDBnds bndsDo)
{
    *ppSumNodeFirstCol = &m_pSumNodes[0];

    if ((m_nDirection > 0) && (m_nDirection < 180)) // Right
    {
        *ppSumNodeFirstAdd = &m_pSumNodes[max(0, 
                                      (m_nStrength - 1) - bndsDo.Left())];
    }
    else if ((m_nDirection > 180) && (m_nDirection < 360)) // Left
    {
        *ppSumNodeFirstAdd = &m_pSumNodes[max(0,  
                  (m_nStrength - 1) - (m_nOutputWidth - bndsDo.Right()))];
    }
    else // Vertical
    {
        *ppSumNodeFirstAdd = &m_pSumNodes[0];
    }
}
//  CBlurBuffer::GetSumNodePointers


//+-----------------------------------------------------------------------------
//
//  CBlurBuffer::_FreeAll
//
//------------------------------------------------------------------------------
void
CBlurBuffer::_FreeAll()
{
    delete [] m_pSumNodes; 
    delete [] m_pRowNodes; 
    delete [] m_psamples;

    m_pSumNodes = NULL;
    m_pRowNodes = NULL;  
    m_psamples  = NULL;
}
//  CBlurBuffer::_FreeAll


//+-----------------------------------------------------------------------------
//
//  CBlurBuffer::_GenerateStructure
//
//------------------------------------------------------------------------------
void
CBlurBuffer::_GenerateStructure()
{
    int i = 0;

    if (m_pSumNodes)
    {
        // Create sum nodes list structure.

        m_pSumNodes[m_nOutputWidth - 1].pNext = &m_pSumNodes[0];

        for (i = 0 ; i < (m_nOutputWidth - 1) ; i++)
        {
            m_pSumNodes[i].pNext = &m_pSumNodes[i + 1];
        }
    }

    // Create row nodes list structure.

    m_pRowNodes[m_cRowNodes - 1].pNext = &m_pRowNodes[0];

    for (i = 0 ; i < (m_cRowNodes - 1) ; i++)
    {
        m_pRowNodes[i].pNext = &m_pRowNodes[i + 1];
    }

    // Associate sample memory with row nodes.

    for (i = 0 ; i < m_cRowNodes ; i++)
    {
        m_pRowNodes[i].pSamples = &m_psamples[i * m_nOutputWidth];
    }
}
//  CBlurBuffer::_GenerateStructure


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::CDXTMotionBlur
//
//------------------------------------------------------------------------------
CDXTMotionBlur::CDXTMotionBlur() :
    m_pblurbuffer(NULL),
    m_nStrength(5),
    m_nDirection(270),
    m_fAdd(true),
    m_fSetup(false)
{
    m_sizeInput.cx  = 0;
    m_sizeInput.cy  = 0;

    m_sizeOutput.cx = 0;
    m_sizeOutput.cy = 0;

    // Base class members.

    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;

    // Due to the the row caching method and other complexities of this 
    // transform, multithreaded rendering would be more complex than it's worth.
    // This keeps the number of threads down to 1.

    m_ulMaxImageBands   = 1;
}
//  CDXTMotionBlur::CDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::~CDXTMotionBlur
//
//------------------------------------------------------------------------------
CDXTMotionBlur::~CDXTMotionBlur()
{
    delete m_pblurbuffer;
}
//  CDXTMotionBlur::~CDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                               &m_cpUnkMarshaler.p);
}
//  CDXTMotionBlur::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::DetermineBnds, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::DetermineBnds(CDXDBnds & Bnds)
{
    return _DetermineBnds(Bnds, m_nStrength, m_nDirection);
}
//  CDXTMotionBlur::DetermineBnds, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::MapBoundsOut2In, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                                ULONG ulInIndex, DXBNDS * pInBounds)
{
    HRESULT     hr = S_OK;
    CDXDBnds    bndsInput;

    if ((NULL == pOutBounds) || (NULL == pInBounds))
    {
        hr = E_POINTER;

        goto done;
    }

    if (ulOutIndex || ulInIndex)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    *pInBounds = *pOutBounds;

    // If the blur direction isn't purely up or down, we'll have an X offset to
    // consider.  It works out that if we just subtract (m_nStrength - 1) from
    // the minimum X bound and then intersect with the input bounds, we'll
    // have the correct X bounds.

    if ((m_nDirection != 0) && (m_nDirection != 180))
    {
        pInBounds->u.D[DXB_X].Min -= m_nStrength - 1;
    }

    // Same idea as the X bound above except we test to see that the blur
    // direciton isn't purley left or right.

    if ((m_nDirection != 90) && (m_nDirection != 270))
    {
        pInBounds->u.D[DXB_Y].Min -= m_nStrength - 1;
    }

    // Intersect with input surface bounds.

    bndsInput.SetXYSize(m_sizeInput);

    ((CDXDBnds *)pInBounds)->IntersectBounds(bndsInput);

done:

    return hr;
}
//  CDXTMotionBlur::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::OnSetup(DWORD dwFlags)
{
    HRESULT         hr      = S_OK;
    CDXDBnds        bndsIn;
    CDXDBnds        bndsOut;

    m_fSetup = false;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsOut = bndsIn;

    DetermineBnds(bndsOut);

    hr = _CreateNewBuffer(m_nDirection, m_nStrength, bndsOut.Width());

    if (FAILED(hr))
    {
        goto done;
    }

    bndsIn.GetXYSize(m_sizeInput);
    bndsOut.GetXYSize(m_sizeOutput);

    m_fSetup = true;

done:

    return hr;
} 
//  CDXTMotionBlur::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr          = S_OK;
    int     x           = 0;
    int     y           = 0;

    CSumNode *  pSumNodeFirstAdd    = NULL;
    CSumNode *  pSumNodeFirstCol    = NULL;
    CSumNode *  pSumNodeCur         = NULL;
    CRowNode *  pRowNodeFar         = NULL;
    CRowNode *  pRowNodeCur         = NULL;

    CDXDBnds    bndsInput;

    CComPtr<IDXARGBReadPtr>         spInput;
    CComPtr<IDXARGBReadWritePtr>    spOutput;

    // When strength is equal to 1, the transform doesn't actually do anything.

    if (1 == m_nStrength)
    {
        DWORD dwFlags = 0;

        if (DoOver())
        {
            dwFlags |= DXBOF_DO_OVER;
        }

        if (DoDither())
        {
            dwFlags |= DXBOF_DITHER;
        }

        hr = DXBitBlt(OutputSurface(), WI.OutputBnds,
                      InputSurface(), WI.DoBnds,
                      dwFlags, m_ulLockTimeOut);

        goto done;
    }

    // Get the input surface portion needed to calculate the requested DoBnds.

    hr = MapBoundsOut2In(0, &WI.DoBnds, 0, &bndsInput);

    if (FAILED(hr))
    {
        goto done;
    }

    // Clear out the sample rows and nodes.

    m_pblurbuffer->Clear();

    // Lock input surface.

    hr = InputSurface()->LockSurface(&bndsInput, m_ulLockTimeOut, DXLOCKF_READ,
                                     __uuidof(IDXARGBReadPtr), 
                                     (void **)&spInput, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Lock output surface.

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE, 
                                      __uuidof(IDXARGBReadWritePtr),
                                      (void **)&spOutput, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Call appropriate WorkProc.

    if ((90 == m_nDirection) || (270 == m_nDirection))
    {
        hr = _WorkProcHorizontal(WI, bndsInput, spInput, spOutput, pbContinue);
    }
    else
    {
        hr = _WorkProcVertical(WI, bndsInput, spInput, spOutput, pbContinue);
    }

done:

    return hr;
} 
//  CDXTMotionBlur::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                              CDXDVec & InVec)
{
    HRESULT hr          = S_OK;
    CDXDVec vecInPoint;

    ulInputIndex = 0;

    if (GetNumInputs() == 0 || NULL == InputSurface())
    {
        hr = E_FAIL;

        goto done;
    }

    OutPoint.GetMinVector(vecInPoint);

    if ((m_nDirection > 180) && (m_nDirection < 360))
    {
        vecInPoint.u.D[DXB_X] -= (m_nStrength - 1);
    }

    if ((m_nDirection > 90) && (m_nDirection < 270))
    {
        vecInPoint.u.D[DXB_Y] -= (m_nStrength - 1);
    }

    if ((vecInPoint.u.D[DXB_X] >= m_sizeInput.cx)
        || (vecInPoint.u.D[DXB_X] < 0)
        || (vecInPoint.u.D[DXB_Y] >= m_sizeInput.cy)
        || (vecInPoint.u.D[DXB_Y] < 0))
    {
        // Out of bounds, say that we hit the output, but no input surface is 
        // related.

        hr = DXT_S_HITOUTPUT;
    }
    else
    {
        // We have a valid input point.

        CDXDBnds    bndsLock(vecInPoint);
        CDXDVec     vecCurrent;
        CDXDVec     vecMax;
        DXSAMPLE    sample;
        int         nXInc   = 1;
        int         nYInc   = 1;
        int         nAlpha  = 0;

        CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

        // This is our input point.  

        InVec = vecInPoint;

        // Expand useful bounds in the x direction.

        if ((m_nDirection > 0) && (m_nDirection < 180))
        {
            // Blur to the right, so look at pixels to the left.

            bndsLock.u.D[DXB_X].Min -= (m_nStrength - 1);
            bndsLock.u.D[DXB_X].Min = max(bndsLock.u.D[DXB_X].Min, 0); 
        }
        else if ((m_nDirection > 180) && (m_nDirection < 360))
        {
            // Blur to the left, so look at pixels to the right.

            bndsLock.u.D[DXB_X].Max += (m_nStrength - 1);
            bndsLock.u.D[DXB_X].Max = min(bndsLock.u.D[DXB_X].Max, 
                                          m_sizeInput.cx);
        }
        else
        {
            nXInc = 0;
        }

        // Expand useful bounds in the y direction.

        if ((m_nDirection > 90) && (m_nDirection < 270))
        {
            // Blur down, so look at pixels above.

            bndsLock.u.D[DXB_Y].Min -= (m_nStrength - 1);
            bndsLock.u.D[DXB_Y].Min = max(bndsLock.u.D[DXB_Y].Min, 0); 
        }
        else if ((m_nDirection < 90) || (m_nDirection > 270))
        {
            // Blur up, so look at pixels below.

            bndsLock.u.D[DXB_Y].Max += (m_nStrength - 1);
            bndsLock.u.D[DXB_Y].Max = min(bndsLock.u.D[DXB_Y].Max, 
                                          m_sizeInput.cy);
        }
        else
        {
            nYInc = 0;
        }

        bndsLock.GetMinVector(vecCurrent);
        bndsLock.GetMaxVector(vecMax);

        // Lock entire input surface so we don't have to do any offset 
        // calculations.

        hr = InputSurface()->LockSurface(NULL, INFINITE, DXLOCKF_READ,
                                         __uuidof(IDXARGBReadPtr),
                                         (void **)&spDXARGBReadPtr,
                                         NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        // Reset to S_OK, just in case LockSurface changed it.

        hr = S_OK;

        // Now walk vecCurrent up to vecMax;

        while ((vecCurrent.u.D[DXB_X] < vecMax.u.D[DXB_X])
               && (vecCurrent.u.D[DXB_Y] < vecMax.u.D[DXB_Y]))
        {
            spDXARGBReadPtr->MoveToXY(vecCurrent.u.D[DXB_X], 
                                      vecCurrent.u.D[DXB_Y]);

            spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

            if ((vecCurrent == vecInPoint) && m_fAdd)
            {
                nAlpha += sample.Alpha * m_nStrength;
            }
            else
            {
                nAlpha += sample.Alpha;
            }

            vecCurrent.u.D[DXB_X] += nXInc;
            vecCurrent.u.D[DXB_Y] += nYInc;
        }
        
        // Check the output pixel for transparency.

        if (m_fAdd)
        {
            if (0 == (nAlpha / ((m_nStrength * 2) - 1)))
            {
                hr = S_FALSE;
            }
        }
        else
        {
            if (0 == (nAlpha / m_nStrength))
            {
                hr = S_FALSE;
            }
        }
    }

done:

    return hr;
}
//  CDXTMotionBlur::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::GetClipOrigin, IDXTClipOrigin
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::GetClipOrigin(DXVEC * pvecClipOrigin)
{
    if (NULL == pvecClipOrigin)
    {
        return E_POINTER;
    }

    // X offset.

    if (m_nDirection > 180)
    {
        pvecClipOrigin->u.D[DXB_X] = m_nStrength - 1;
    }
    else
    {
        pvecClipOrigin->u.D[DXB_X] = 0;
    }

    // Y offset.

    if ((m_nDirection < 90) || (m_nDirection > 270))
    {
        pvecClipOrigin->u.D[DXB_Y] = m_nStrength - 1;
    }
    else
    {
        pvecClipOrigin->u.D[DXB_Y] = 0;
    }

    return S_OK;
}
//  CDXTMotionBlur::GetClipOrigin, IDXTClipOrigin


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::get_Add, IDXTMotionBlur
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::get_Add(VARIANT_BOOL * pfAdd)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (NULL == pfAdd)
    {
        hr = E_POINTER;

        goto done;
    }

    *pfAdd = m_fAdd ? VARIANT_TRUE : VARIANT_FALSE;

done:

    return hr;
}


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::put_Add, IDXTMotionBlur
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::put_Add(VARIANT_BOOL fAdd)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if ((fAdd != VARIANT_TRUE) && (fAdd != VARIANT_FALSE))
    {
        hr = E_INVALIDARG;

        goto done;
    }

    // If we're already set this way, just return.

    if ((m_fAdd && (VARIANT_TRUE == fAdd))
        || (!m_fAdd && (VARIANT_FALSE == fAdd)))
    {
        goto done;
    }

    m_fAdd = !m_fAdd;

    SetDirty();

done:

    return hr;
}
//  CDXTMotionBlur::put_Add, IDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::get_Direction, IDXTMotionBlur
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::get_Direction(short * pnDirection)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (NULL == pnDirection)
    {
        hr = E_POINTER;

        goto done;
    }

    *pnDirection = m_nDirection;

done:

    return hr;
}
//  CDXTMotionBlur::get_Direction, IDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::put_Direction, IDXTMotionBlur
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::put_Direction(short nDirection)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    nDirection = nDirection % 360;

    if (nDirection < 0)
    {
        nDirection = 360 + nDirection;
    }

    if (m_nDirection != nDirection)
    {
        if (m_fSetup)
        {
            CDXDBnds bnds;

            hr = InputSurface()->GetBounds(&bnds);

            if (FAILED(hr))
            {
                goto done;
            }

            // What would the output size be with this new property setting?

            hr = _DetermineBnds(bnds, m_nStrength, nDirection);

            if (FAILED(hr))
            {
                goto done;
            }

            hr = _CreateNewBuffer(nDirection, m_nStrength, bnds.Width());

            if (FAILED(hr))
            {
                goto done;
            }

            // Save output size to our member variable.

            bnds.GetXYSize(m_sizeOutput);
        }

        m_nDirection = nDirection;

        SetDirty();
    }

done:

    return hr;
}
//  CDXTMotionBlur::put_Direction, IDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::get_Strength, IDXTMotionBlur
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::get_Strength(long * pnStrength)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (NULL == pnStrength)
    {
        hr = E_POINTER;

        goto done;
    }

    *pnStrength = m_nStrength;

done:

    return hr;
}
//  CDXTMotionBlur::get_Strength, IDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::put_Strength, IDXTMotionBlur
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::put_Strength(long nStrength)
{
    DXAUTO_OBJ_LOCK;

    HRESULT hr = S_OK;

    if (nStrength < 1)
    {
        nStrength = 1;
    }

    if (m_nStrength != nStrength)
    {
        if (m_fSetup)
        {
            CDXDBnds bnds;

            hr = InputSurface()->GetBounds(&bnds);

            if (FAILED(hr))
            {
                goto done;
            }

            // What would the output size be with this new property setting?

            hr = _DetermineBnds(bnds, nStrength, m_nDirection);

            if (FAILED(hr))
            {
                goto done;
            }

            hr = _CreateNewBuffer(m_nDirection, nStrength, bnds.Width());

            if (FAILED(hr))
            {
                goto done;
            }

            // Save output size to our member variable.

            bnds.GetXYSize(m_sizeOutput);
        }

        m_nStrength = nStrength;

        SetDirty();
    }

done:

    return hr;
}
//  CDXTMotionBlur::put_Strength, IDXTMotionBlur


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::_CreateNewBuffer
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::_CreateNewBuffer(const short nDirection, const long nStrength, 
                                 const long nOutputWidth)
{
    HRESULT hr = S_OK;

    CBlurBuffer * pblurbufferNew = new CBlurBuffer;

    if (NULL == pblurbufferNew)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    hr = pblurbufferNew->Initialize(nDirection, nStrength, nOutputWidth);

    if (FAILED(hr))
    {
        goto done;
    }

    delete m_pblurbuffer;

    m_pblurbuffer = pblurbufferNew;

done:

    if (FAILED(hr))
    {
        delete pblurbufferNew;
    }

    return hr;
}
//  CDXTMotionBlur::_CreateNewBuffer


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::_DetermineBnds
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTMotionBlur::_DetermineBnds(CDXDBnds & bnds, long nStrength,
                               long nDirection)
{
    // Horizontal bounds.

    if ((nDirection != 0) && (nDirection != 180))
    {
        bnds.u.D[DXB_X].Max += nStrength - 1;
    }

    // Vertical bounds.

    if ((nDirection != 90) && (nDirection != 270))
    {
        bnds.u.D[DXB_Y].Max += nStrength - 1;
    }

    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::_WorkProcHorizontal
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::_WorkProcHorizontal(const CDXTWorkInfoNTo1 &    WI, 
                                    CDXDBnds &                  bndsInput, 
                                    IDXARGBReadPtr *            pInput,
                                    IDXARGBReadWritePtr *       pOutput,
                                    BOOL *                      pfContinue)
{
    HRESULT hr              = S_OK;
    int     y               = 0;
    int     i               = 0;
    int     cDoHeight       = WI.DoBnds.Height();
    int     cDoWidth        = WI.DoBnds.Width();
    int     cInWidth        = bndsInput.Width();

    int     nAddIndex       = 0;
    int     nCurIndex       = 0;
    int     nOutIndex       = 0;
    int     nUnpackIndex    = 0;
    int     nInc            = 0;

    CRowNode *  pRowNode    = NULL;
    CSumNode    sumnode;

    DXDITHERDESC dxdd;

    DXSAMPLE *      psampleBuffer           = DXSAMPLE_Alloca(cDoWidth);
    DXBASESAMPLE *  psampleBufferScratch    = DXBASESAMPLE_Alloca(cDoWidth);

    // Get a row node for our use.

    m_pblurbuffer->GetFirstRowNode(&pRowNode);

    // Set up dither structure.

    if (DoDither())
    {
        dxdd.x                  = WI.OutputBnds.Left();
        dxdd.y                  = WI.OutputBnds.Top();
        dxdd.pSamples           = psampleBuffer;
        dxdd.cSamples           = cDoWidth;
        dxdd.DestSurfaceFmt     = OutputSampleFormat();
    }

    // Row loop

    for (y = 0 ; (y < cDoHeight) && *pfContinue ; y++)
    {
        if (90 == m_nDirection) // Blur to the right.
        {
            nAddIndex       = WI.DoBnds.Right() - 1;
            nCurIndex       = nAddIndex;
            nOutIndex       = cDoWidth - 1;
            nUnpackIndex    = bndsInput.Left();

            nInc      = -1;
        }
        else // Blur to the left.
        {
            nAddIndex       = WI.DoBnds.Left();
            nCurIndex       = nAddIndex;
            nOutIndex       = 0;
            nUnpackIndex    = bndsInput.Left() + (m_nStrength - 1);

            nInc      = 1;
        }

        // Go the correct input row and unpack the needed samples to a good 
        // place in the row node's sample buffer.

        pInput->MoveToRow(y);
        pInput->Unpack(&pRowNode->pSamples[nUnpackIndex], cInWidth, FALSE);

        // We need to prime the sumnode with (m_nStrength - 1) samples to get
        // it ready to calculate output samples.

        for (i = 1 ; i < m_nStrength ; i++)
        {
            if ((nAddIndex >= 0) && (nAddIndex < m_sizeOutput.cx))
            {
                sumnode.AddSample(pRowNode->pSamples[nAddIndex]);
            }

            nAddIndex += nInc;
        }
            
        // Calculate the output samples.

        for (i = 0 ; i < cDoWidth ; i++)
        {
            // If nAddIndex is a valid index, add the far sample to our sumnode.
            // This sample will be the one (m_nStrength - 1) pixels away from 
            // the current pixel.

            if ((nAddIndex >= 0) && (nAddIndex < m_sizeOutput.cx))
            {
                sumnode.AddSample(pRowNode->pSamples[nAddIndex]);
            }

            // Calculate the output sample value.
            // TODO:  move check for m_fAdd outside of loop.

            if (m_fAdd)
            {
                sumnode.CalcWeightedSample(&psampleBuffer[nOutIndex],
                                           pRowNode->pSamples[nCurIndex],
                                           m_nStrength);
            }
            else
            {
                sumnode.CalcSample(&psampleBuffer[nOutIndex], m_nStrength);
            }

            // Subtract the current pixel from the sumnode since it won't be
            // used to calculate the next pixel.
            
            sumnode.SubtractSample(pRowNode->pSamples[nCurIndex]);

            nAddIndex += nInc;
            nCurIndex += nInc;
            nOutIndex += nInc;
        }

        // Clear values in sum node.

        sumnode.ZeroSumNode();

        // Move to the correct output row.

        pOutput->MoveToRow(y);

        // Dither

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        // Over or Pack the samples.

        if (DoOver())
        {
            DXPMSAMPLE * ppmsamples = DXPreMultArray(psampleBuffer, cDoWidth);

            pOutput->OverArrayAndMove(psampleBufferScratch, ppmsamples, 
                                      cDoWidth);
        }
        else
        {
            pOutput->PackAndMove(psampleBuffer, cDoWidth);
        }
    } // Row loop

    return hr;
}
//  CDXTMotionBlur::_WorkProcHorizontal


//+-----------------------------------------------------------------------------
//
//  CDXTMotionBlur::_WorkProcVertical
//
//------------------------------------------------------------------------------
HRESULT 
CDXTMotionBlur::_WorkProcVertical(const CDXTWorkInfoNTo1 &  WI, 
                                  CDXDBnds &                bndsInput, 
                                  IDXARGBReadPtr *          pInput,
                                  IDXARGBReadWritePtr *     pOutput,
                                  BOOL *                    pfContinue)
{
    HRESULT hr              = S_OK;

    int     cDoHeight       = WI.DoBnds.Height();
    int     cDoWidth        = WI.DoBnds.Width();
    int     cInWidth        = bndsInput.Width();
    int     cInHeight       = bndsInput.Height();

    // Iterator variables.

    int     i               = 0;
    int     j               = 0;

    int     nsrcCurX        = 0;
    int     nsrcX           = 0;
    int     nsrcY           = 0;
    int     ndstX           = 0;
    int     ndstY           = 0;

    // cPrimerRows  The number of rows needed to be gathered from the input 
    //              before the method can start processing output rows.  This
    //              can vary depending on the location of the do bounds 
    //              within the output bounds.
    //
    //  nsrcStartX  This is the index of the first sample in the buffer row 
    //              needed to calculate each row in this method.  
    //
    //  nsrcStartY  This is the y coordinate of the first row needed from the
    //              locked input area for use in this method.
    //
    //  nsrcOffsetX This is the index of the first sample in the buffer row that
    //              should be "added" to the first output pixel calculated in
    //              each row when m_fAdd is set.
    //
    //  nsrcPackX   This is the index of the first element in our row buffer
    //              that should be filled with the first pixel unpacked.  We may
    //              offset the unpacking to leave some clear pixels for use at
    //              various times and so we won't have to do too much bounds 
    //              checking.
    //
    //  ndstStartX  This is the index of the first sample in psampleBuffer that
    //              will be calculated for each row.
    //
    //  ndstStartY  This is the y coordinate of the first row of the locked
    //              ouput area that will be calculated by this method.
    //
    //  fRotateSumNodes To simplify the the calculation of blurs with left or
    //                  right vectors, we set this flag to true and rotate the
    //                  some nodes after calculating each row.

    int     cPrimerRows     = 0;
    int     nsrcStartX      = 0;
    int     nsrcStartY      = 0;
    int     nsrcOffsetX     = 0;
    int     nsrcPackX       = 0;
    int     ndstStartX      = 0;
    int     ndstStartY      = 0;

    int     nIncX           = 0;
    int     nIncY           = 0;

    bool    fRotateSumNodes = false;

    CRowNode *      pRowNodeCur             = NULL;
    CRowNode *      pRowNodeFar             = NULL;
    CSumNode *      pSumNodeFirstAdd        = NULL;
    CSumNode *      pSumNodeFirstCol        = NULL;

    DXDITHERDESC dxdd;

    DXSAMPLE *      psampleBuffer           = DXSAMPLE_Alloca(cDoWidth);
    DXBASESAMPLE *  psampleBufferScratch    = DXBASESAMPLE_Alloca(cDoWidth);

    // Vertical setup.

    if ((m_nDirection > 90) && (m_nDirection < 270)) // Down
    {
        nsrcStartY  = cInHeight - 1;
        ndstStartY  = cDoHeight - 1;


        cPrimerRows = min(m_sizeOutput.cy - WI.DoBnds.Bottom(), 
                          (m_nStrength - 1));

        nIncY       = -1;
    }
    else // Up
    {
        nsrcStartY  = 0;
        ndstStartY  = 0;

        cPrimerRows = min(WI.DoBnds.Top(), m_nStrength - 1);

        nIncY       = 1;
    }

    // Horizontal setup.

    if (m_nDirection > 180) // Left
    {
        nsrcPackX   = m_nStrength - 1;
        nsrcStartX  = nsrcPackX + cInWidth - 1;
        ndstStartX  = cDoWidth - 1;
        nsrcOffsetX = nsrcPackX + (cInWidth - 1) 
                      - min(m_sizeOutput.cx - WI.DoBnds.Right(), m_nStrength - 1);
        nIncX       = -1;

        fRotateSumNodes = true;
    }
    else if ((m_nDirection > 0) && (m_nDirection < 180)) // Right
    {
        nsrcPackX   = 0;
        nsrcStartX  = 0;
        ndstStartX  = 0;
        nsrcOffsetX = min(WI.DoBnds.Left(), (m_nStrength - 1));
        nIncX       = 1;

        fRotateSumNodes = true;
    }
    else // Vertical
    {
        nsrcPackX   = 0;
        nsrcStartX  = 0;
        ndstStartX  = 0;
        nsrcOffsetX = 0;
        nIncX       = 1;

        fRotateSumNodes = false;
    }

    // Get a row node for our use.

    m_pblurbuffer->GetFirstRowNode(&pRowNodeFar);

    // Get sum nodes for our use.

    m_pblurbuffer->GetSumNodePointers(&pSumNodeFirstCol, 
                                      &pSumNodeFirstAdd,
                                      WI.DoBnds);
    
    // Set up dither structure.

    if (DoDither())
    {
        dxdd.x                  = WI.OutputBnds.Left();
        dxdd.y                  = nIncY == 1 ? WI.OutputBnds.Top() 
                                               : WI.OutputBnds.Bottom();
        dxdd.pSamples           = psampleBuffer;
        dxdd.cSamples           = cDoWidth;
        dxdd.DestSurfaceFmt     = OutputSampleFormat();
    }

    // We need to prime the row nodes with (m_nStrength - 1) rows of data to get
    // them ready to calculate output samples.

    nsrcX = nsrcStartX;
    nsrcY = nsrcStartY;
    ndstX = ndstStartX;
    ndstY = ndstStartY;

    for (i = 0 ; (i < cPrimerRows) && *pfContinue ; i++)
    {
        CSumNode * pSumNodeTempAdd = pSumNodeFirstAdd;

        if ((nsrcY >= 0) && (nsrcY < cInHeight))
        {
            pInput->MoveToRow(nsrcY);
            pInput->Unpack(&pRowNodeFar->pSamples[nsrcPackX], cInWidth, FALSE);

            for (nsrcX = nsrcStartX, j = 0 ; j < cInWidth ; nsrcX += nIncX, j++)
            {
                pSumNodeTempAdd->AddSample(pRowNodeFar->pSamples[nsrcX]);

                pSumNodeTempAdd = pSumNodeTempAdd->pNext;
            }
        }

        if (fRotateSumNodes)
        {
            pSumNodeFirstCol->ZeroSumNode();

            pSumNodeFirstAdd = pSumNodeFirstAdd->pNext;
            pSumNodeFirstCol = pSumNodeFirstCol->pNext;
        }

        pRowNodeFar = pRowNodeFar->pNext;
        nsrcY      += nIncY;
    }

    // Set current row node.

    pRowNodeCur = pRowNodeFar->pNext;

    // Row loop

    for (i = 0 ; (i < cDoHeight) && *pfContinue ; i++)
    {
        CSumNode * pSumNodeTempCol = pSumNodeFirstCol;
        CSumNode * pSumNodeTempAdd = pSumNodeFirstAdd;

        if ((nsrcY >= 0) && (nsrcY < cInHeight))
        {
            pInput->MoveToRow(nsrcY);
            pInput->Unpack(&pRowNodeFar->pSamples[nsrcPackX], cInWidth, FALSE);

            for (nsrcX = nsrcStartX, j = 0 ; j < cInWidth ; nsrcX += nIncX, j++)
            {
                pSumNodeTempAdd->AddSample(pRowNodeFar->pSamples[nsrcX]);

                pSumNodeTempAdd = pSumNodeTempAdd->pNext;
            }
        }

        // Calculate the output samples.

        for (nsrcCurX = nsrcOffsetX, ndstX = ndstStartX, j = 0 
             ; j < cDoWidth 
             ; nsrcCurX += nIncX, ndstX += nIncX, j++)
        {
            if (m_fAdd)
            {
                pSumNodeTempCol->CalcWeightedSample(&psampleBuffer[ndstX], 
                                                    pRowNodeCur->pSamples[nsrcCurX],
                                                    m_nStrength);
            }
            else
            {
                pSumNodeTempCol->CalcSample(&psampleBuffer[ndstX], m_nStrength);
            }

            if (nsrcCurX >= 0)
            {
                pSumNodeTempCol->SubtractSample(pRowNodeCur->pSamples[nsrcCurX]);
            }

            pSumNodeTempCol = pSumNodeTempCol->pNext;
        }

        // Move to the correct output row.

        pOutput->MoveToRow(ndstY);

        // Dither.

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y += nIncY;
        }

        // Over or Pack the samples.

        if (DoOver())
        {
            DXPMSAMPLE * ppmsamples = DXPreMultArray(psampleBuffer, cDoWidth);

            pOutput->OverArrayAndMove(psampleBufferScratch, ppmsamples, 
                                      cDoWidth);
        }
        else
        {
            pOutput->PackAndMove(psampleBuffer, cDoWidth);
        }

        if (fRotateSumNodes)
        {
            pSumNodeFirstCol->ZeroSumNode();

            pSumNodeFirstAdd = pSumNodeFirstAdd->pNext;
            pSumNodeFirstCol = pSumNodeFirstCol->pNext;
        }

        pRowNodeFar = pRowNodeFar->pNext;
        pRowNodeCur = pRowNodeFar->pNext;

        nsrcY += nIncY;
        ndstY += nIncY;
    } // Row loop

    return hr;
}
//  CDXTMotionBlur::_WorkProcVertical
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\motionblur.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       motionblur.h
//
//  Description:    The declaration of the motion blur transform class.
//
//  Change History:
//  1999/10/26  a-matcal    Created.
//  1999/11/19  a-matcal    Changed color members of CSumNode to ULONGs instead
//                          of WORDs.  With only 255 pixels of white, the sum
//                          node would overflow, giving sometimes interesting
//                          results, mostly just ugly ones though.  Also do 
//                          calculations using doubles instead of floats now.
//
//------------------------------------------------------------------------------

#ifndef __DXTMOTIONBLUR_H_
#define __DXTMOTIONBLUR_H_

#include "resource.h"   




class CSumNode
{
public:

    CSumNode *  pNext;
    int         cSamples;

    ULONG       Red;
    ULONG       Green;
    ULONG       Blue;
    ULONG       Alpha;

    CSumNode() : pNext(NULL), cSamples(0), Red(0), Green(0), Blue(0), 
                 Alpha(0) {}

    void ZeroSumNode() 
    { 
        Blue = 0; Green = 0; Red = 0; Alpha = 0; cSamples = 0; 
    }

    void AddSample(const DXSAMPLE & sample);
    void SubtractSample(const DXSAMPLE & sample);
    void CalcSample(DXSAMPLE * psampleOut, const long nStrength);
    void CalcWeightedSample(DXSAMPLE * psampleOut, 
                            const DXSAMPLE & sampleWeight, 
                            const long nStrength);
};


class CRowNode
{
public:

    CRowNode *  pNext;
    DXSAMPLE *  pSamples;

    CRowNode() : pNext(NULL), pSamples(NULL) {}

    // A CRowNode does not allocate memory for its samples and will not delete
    // them either.  The user of a CRowNode should do this.
};


class CBlurBuffer
{
private:

    CSumNode *  m_pSumNodes;
    CRowNode *  m_pRowNodes;
    DXSAMPLE *  m_psamples;

    long        m_cRowNodes;
    long        m_nOutputWidth;
    long        m_nStrength;
    short       m_nDirection;

    unsigned    m_fInitialized : 1;

    STDMETHOD_(void, _FreeAll)();
    STDMETHOD_(void, _GenerateStructure)();

public:

    CBlurBuffer() : m_pSumNodes(NULL), m_pRowNodes(NULL), m_psamples(NULL),
                    m_cRowNodes(0), m_nOutputWidth(0), m_nStrength(0), 
                    m_nDirection(0), m_fInitialized(NULL) {}

    virtual ~CBlurBuffer() { _FreeAll(); }

    STDMETHOD(Initialize)(const short nDirection, const long nStrength, 
                          const long nOutputWidth);

    STDMETHOD_(void, GetSumNodePointers)(CSumNode ** ppSumNodeFirstCol,
                                         CSumNode ** ppSumNodeFirstAdd,
                                         const CDXDBnds bndsDo);

    inline 
    STDMETHOD_(void, Clear)()
    {
        ZeroMemory(m_psamples, m_nOutputWidth * m_cRowNodes * sizeof(DXSAMPLE));

        if (m_pSumNodes)
        {
            CSumNode * pSumNodeCur = &m_pSumNodes[0];

            do
            {
                pSumNodeCur->ZeroSumNode();

                pSumNodeCur = pSumNodeCur->pNext;
            }
            while (pSumNodeCur != &m_pSumNodes[0]);
        }
    }

    inline 
    STDMETHOD_(void, GetFirstSumNode)(CSumNode ** ppSumNodeFirst)
    {
        *ppSumNodeFirst = &m_pSumNodes[0];
    }

    inline 
    STDMETHOD_(void, GetFirstRowNode)(CRowNode ** ppRowNodeFirst)
    {
        *ppRowNodeFirst = &m_pRowNodes[0];
    }
};

    
class ATL_NO_VTABLE CDXTMotionBlur : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTMotionBlur, &CLSID_DXTMotionBlur>,
    public IDispatchImpl<IDXTMotionBlur, &IID_IDXTMotionBlur, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTMotionBlur>,
    public IObjectSafetyImpl2<CDXTMotionBlur>,
    public IPersistPropertyBagImpl<CDXTMotionBlur>,
    public IPersistStorageImpl<CDXTMotionBlur>,
    public IDXTClipOrigin
{
private:

    CComPtr<IUnknown>   m_cpUnkMarshaler;

    CBlurBuffer *       m_pblurbuffer;

    SIZE                m_sizeInput;
    SIZE                m_sizeOutput;

    long                m_nStrength;
    short               m_nDirection;

    unsigned            m_fAdd      : 1;
    unsigned            m_fSetup    : 1;

    STDMETHOD(_CreateNewBuffer)(const short nDirection, const long nStrength, 
                                const long nOutputWidth);

    STDMETHOD(_DetermineBnds)(CDXDBnds & bnds, long nStrength, long nDirection);

    STDMETHOD(_WorkProcHorizontal)(const CDXTWorkInfoNTo1 & WI, 
                                   CDXDBnds &               bndsInput, 
                                   IDXARGBReadPtr *         pInput,
                                   IDXARGBReadWritePtr *    pOutput,
                                   BOOL *                   pfContinue);

    STDMETHOD(_WorkProcVertical)  (const CDXTWorkInfoNTo1 & WI, 
                                   CDXDBnds &               bndsInput, 
                                   IDXARGBReadPtr *         pInput,
                                   IDXARGBReadWritePtr *    pOutput,
                                   BOOL *                   pfContinue);
public:

    CDXTMotionBlur();
    virtual ~CDXTMotionBlur();

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTMOTIONBLUR)
    DECLARE_POLY_AGGREGATABLE(CDXTMotionBlur)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTMotionBlur)
        COM_INTERFACE_ENTRY(IDXTMotionBlur)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTClipOrigin)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTMotionBlur>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTMotionBlur)
        PROP_ENTRY("add",       DISPID_DXTMOTIONBLUR_ADD,       CLSID_DXTMotionBlurPP)
        PROP_ENTRY("direction", DISPID_DXTMOTIONBLUR_DIRECTION, CLSID_DXTMotionBlurPP)
        PROP_ENTRY("strength",  DISPID_DXTMOTIONBLUR_STRENGTH,  CLSID_DXTMotionBlurPP)
        PROP_PAGE(CLSID_DXTMotionBlurPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT DetermineBnds(CDXDBnds & Bnds);
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);

    // IDXTransform methods.

    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTClipOrigin methods.

    STDMETHOD(GetClipOrigin)(DXVEC * pvecClipOrigin);

    // IDXTMotionBlur properties.

    STDMETHOD(get_Add)(VARIANT_BOOL * pfAdd);
    STDMETHOD(put_Add)(VARIANT_BOOL fAdd);
    STDMETHOD(get_Direction)(short * pnDirection);
    STDMETHOD(put_Direction)(short nDirection);
    STDMETHOD(get_Strength)(long * pnStrength);
    STDMETHOD(put_Strength)(long nStrength);
};


//+-----------------------------------------------------------------------------
//
//  CSumNode::AddSample
//
//------------------------------------------------------------------------------
inline void
CSumNode::AddSample(const DXSAMPLE & sample)
{
    if (sample.Alpha)
    {
        cSamples++;

        Red     += sample.Red;
        Blue    += sample.Blue;
        Green   += sample.Green;
        Alpha   += sample.Alpha;
    }
}
//  CSumNode::AddSample


//+-----------------------------------------------------------------------------
//
//  CSumNode::SubtractSample
//
//------------------------------------------------------------------------------
inline void
CSumNode::SubtractSample(const DXSAMPLE & sample)
{
    // TODO:  This assert is firing during the horizontal case.
    // _ASSERT(cSamples);

    if (sample.Alpha)
    {
        cSamples--;

        Red     -= sample.Red;
        Blue    -= sample.Blue;
        Green   -= sample.Green;
        Alpha   -= sample.Alpha;
    }
}
//  CSumNode::SubtractSample


//+-----------------------------------------------------------------------------
//
//  CSumNode::CalcSample
//
//------------------------------------------------------------------------------
inline void
CSumNode::CalcSample(DXSAMPLE * psampleOut, long nStrength)
{
    _ASSERT(psampleOut);

    if (cSamples)
    {
        double dblDiv = 1.0F / (double)cSamples;

        psampleOut->Red     = (BYTE)((double)Red   * dblDiv);
        psampleOut->Green   = (BYTE)((double)Green * dblDiv);
        psampleOut->Blue    = (BYTE)((double)Blue  * dblDiv);
        psampleOut->Alpha   = (BYTE)((double)Alpha / (double)nStrength);
    }
    else
    {
        *((DWORD *)psampleOut) = 0;
    }
}
//  CSumNode::CalcSample


//+-----------------------------------------------------------------------------
//
//  CSumNode::CalcWeightedSample
//
//------------------------------------------------------------------------------
inline void
CSumNode::CalcWeightedSample(DXSAMPLE * psampleOut, 
                             const DXSAMPLE & sampleWeight, 
                             const long nStrength)
{
    _ASSERT(psampleOut);

    if (cSamples)
    {
        double dblDiv = 1.0F / (double)cSamples;

        if (sampleWeight.Alpha)
        {
            psampleOut->Red     = (BYTE)((sampleWeight.Red   
                                          + (short)((double)Red   * dblDiv)) / 2);
            psampleOut->Green   = (BYTE)((sampleWeight.Green 
                                          + (short)((double)Green * dblDiv)) / 2);
            psampleOut->Blue    = (BYTE)((sampleWeight.Blue  
                                          + (short)((double)Blue  * dblDiv)) / 2);
        }
        else
        {
            psampleOut->Red     = (BYTE)((double)Red   * dblDiv);
            psampleOut->Green   = (BYTE)((double)Green * dblDiv);
            psampleOut->Blue    = (BYTE)((double)Blue  * dblDiv);
        }

        psampleOut->Alpha   = (BYTE)((sampleWeight.Alpha 
                                      + (short)((double)Alpha / (double)nStrength)) / 2);
    }
    else
    {
        *((DWORD *)psampleOut) = 0;
    }
}
//  CSumNode::CalcWeightedSample


#endif //__DXTMOTIONBLUR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\redirect.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:            redirect.h
//
//  Discription:         The redirect transform.
//
//  Change History:
//  1999/09/20  a-matcal    Created.
//  1999/11/07  a-matcal    Handle OnSetup.
//
//------------------------------------------------------------------------------

#ifndef __REDIRECT_H_
#define __REDIRECT_H_

#include "resource.h"
#include "danim.h"
#include "datime.h"
#include "mshtml.h"




class ATL_NO_VTABLE CDXTRedirect : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTRedirect, &CLSID_DXTRedirect>,
    public IDispatchImpl<IDXTRedirect, &IID_IDXTRedirect, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTRedirect>,
    public IObjectSafetyImpl2<CDXTRedirect>,
    public IPersistStorageImpl<CDXTRedirect>,
    public IPersistPropertyBagImpl<CDXTRedirect>,
    public ITIMEDAElementRenderSite,
    public IDXTRedirectFilterInit
{
private:

    CDXDBnds                        m_bndsInput;

    CComPtr<IDAStatics>             m_spDAStatics;
    CComPtr<IDAImage>               m_spDAImage;
    CComPtr<ITIMEDAElementRender>   m_spTIMEDAElementRender;
    CComPtr<IHTMLPaintSite>         m_spHTMLPaintSite;
    CComPtr<IDirectDrawSurface>     m_spDDSurfBuffer;
    CComPtr<IDXSurface>             m_spDXSurfBuffer;

    CComPtr<IUnknown>               m_cpUnkMarshaler;

    DWORD                           m_dwChromaColor;

    unsigned                        m_fDetached : 1;

public:

    CDXTRedirect();

    DECLARE_POLY_AGGREGATABLE(CDXTRedirect)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTREDIRECT)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTRedirect)
        COM_INTERFACE_ENTRY(IDXTRedirect)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITIMEDAElementRenderSite)
        COM_INTERFACE_ENTRY(IDXTRedirectFilterInit)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTRedirect>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CIris)
    END_PROPERTY_MAP()

    HRESULT FinalConstruct();

    // CDXTBaseNTo1 overrides.

    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnSetup(DWORD dwFlags);

    // ITIMEDAElementRenderSite methods.

    STDMETHOD(Invalidate)(LPRECT prc);

    // IDXTRedirectFilterInit methods.

    STDMETHOD(SetHTMLPaintSite)(void * pvHTMLPaintSite);

    // IDXTRedirect methods.

    STDMETHOD(ElementImage)(VARIANT * pvarImage);
    STDMETHOD(SetDAViewHandler)(IDispatch * pDispViewHandler);
    STDMETHOD(HasImageBeenAllocated)(BOOL * pfAllocated);
    STDMETHOD(DoRedirection)(IUnknown * pInputSurface,
                             HDC hdcOutput,
                             RECT * pDrawRect);
};

#endif //__REDIRECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\randomdissolve.cpp ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  Filename:   randomdissolve.cpp
//
//  Overview:   A random dissolve transform.
//
//  Change History:
//  1999/09/26  a-matcal    Created.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "randomdissolve.h"

DWORD g_adwRandMask[33] = {
    // Mask     // Bit width
    0x0,        //  0 Not available
    0x0,        //  1 Not available
    0x00000003, //  2
    0x00000006, //  3
    0x0000000C, //  4
    0x00000014, //  5
    0x00000030, //  6
    0x00000060, //  7
    0x000000B8, //  8
    0x00000110, //  9
    0x00000240, // 10
    0x00000500, // 11
    0x00000CA0, // 12
    0x00001B00, // 13
    0x00003500, // 14
    0x00006000, // 15
    0x0000B400, // 16
    0x00012000, // 17
    0x00020400, // 18
    0x00072000, // 19
    0x00090000, // 20
    0x00140000, // 21
    0x00300000, // 22
    0x00420000, // 23 BUG 9432 - This guy was 0x00400000 and his pixels would 
                //    cluster about the left and top asymptotically close.  I
                //    added the 0x20000 bit to give a little more noise to the
                //    column result.  
                //
                //    (mcalkins) while porting this I noticed the old
                //    filter was grabbing the rand mask for an index 2 larger
                //    than it needed, causing over calculation and possibly the
                //    cause of this bug.  This table comes straight out of 
                //    Graphics Gems I.
                //
    0x00D80000, // 24
    0x01200000, // 25
    0x03880000, // 26
    0x07200000, // 27
    0x09000000, // 28 
    0x14000000, // 29
    0x32800000, // 30
    0x48000000, // 31
    0xA3000000  // 32
};




//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::CDXTRandomDissolve
//
//------------------------------------------------------------------------------
CDXTRandomDissolve::CDXTRandomDissolve() :
    m_cdwPitch(0),
    m_cPixelsMax(0),
    m_pdwBitBuffer(NULL),
    m_dwRandMask(0)
{
    m_sizeInput.cx      = 0;
    m_sizeInput.cy      = 0;

    // Base class members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  Method: CDXTRandomDissolve::CDXTRandomDissolve


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::~CDXTRandomDissolve
//
//------------------------------------------------------------------------------
CDXTRandomDissolve::~CDXTRandomDissolve()
{
    if (m_pdwBitBuffer)
    {
        delete [] m_pdwBitBuffer;
    }
}
//  Method: CDXTRandomDissolve::~CDXTRandomDissolve


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRandomDissolve::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  Method: CDXTRandomDissolve::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::OnSetup, CDXBaseNTo1
//
//  Overview:   This function will create a buffer surface with a bit depth of
//              1 to hold a mask of the output.  The buffer will have a row size
//              that is a multiple of four bytes, and will have four extra bytes
//              in front of the first bit representing pixel {0, 0} so that we
//              can avoid dealing with the problem of zero never coming out of
//              our random number generator.  (Otherwise pixel {0, 0} would
//              always be the first or last pixel selected.)
//              
//------------------------------------------------------------------------------
HRESULT 
CDXTRandomDissolve::OnSetup(DWORD dwFlags)
{
    HRESULT hr          = S_OK;
    UINT    cdwPitch    = 0;

    SIZE        sizeNew;
    CDXDBnds    bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsInput.GetXYSize(sizeNew);

    // If the input size hasn't changed, we don't have to do any work here.

    if ((sizeNew.cx == m_sizeInput.cx) && (sizeNew.cy == m_sizeInput.cy))
    {
        goto done;
    }

    // How many DWORDs would be needed per row to hold this image in 1 bit per
    // pixel format.

    cdwPitch = sizeNew.cx / 32;

    if (sizeNew.cx % 32)
    {
        cdwPitch++;  // Add one if division truncated.
    }
    
    if ((cdwPitch == m_cdwPitch) 
        && (sizeNew.cy == m_sizeInput.cy) && m_pdwBitBuffer)
    {
        // Our bit buffer is already the correct size, so just change the input
        // size width and return.

        m_sizeInput.cx = sizeNew.cx;
    }
    else // We need to allocate a new bit buffer.
    {
        DWORD * pdwBitsTemp = NULL;

        // We add one DWORD to buffer size so we can ignore the first DWORD and
        // not deal with the 0th element never being selected. (A side effect of
        // the random number generator used.)

        int cdwBufferSize = (cdwPitch * sizeNew.cy) + 1;

        pdwBitsTemp = new DWORD[cdwBufferSize];

        if (NULL == pdwBitsTemp)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        m_sizeInput.cx  = sizeNew.cx;
        m_sizeInput.cy  = sizeNew.cy;
        m_cdwPitch      = cdwPitch;

        // What is the maximum pixel represented by our buffer?  (This will be
        // different than the maximum pixel of the input surfaces.)

        m_cPixelsMax    = cdwBufferSize * 32;

        // The maximum number we need our random number generator to create is
        // m_cPixelsMax - 1.  So we get the bit width of that number and then
        // get the appropriate random number generating mask from the global 
        // array.

        m_dwRandMask    = g_adwRandMask[_BitWidth(m_cPixelsMax -1)];

        // Even if the inputs are 1x1 pixel, the bit mask will be at
        // least 64-bits (representing 64 pixels) and it will be impossible
        // for us to get a 0 rand mask.  But we'll assert, just to be sure.

        _ASSERT(m_dwRandMask);

        // Replace the bit buffer.

        if (m_pdwBitBuffer)
        {
            delete [] m_pdwBitBuffer;
        }

        m_pdwBitBuffer = pdwBitsTemp;
    }

done:

    return hr;
} 
//  Method: CDXTRandomDissolve::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTRandomDissolve::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                          ULONG & ulInToTest,  ULONG aInIndex[],
                                          BYTE aWeight[])
{
    DWORD dwCurrent = m_pdwBitBuffer[  (m_cdwPitch * OutPoint[DXB_Y].Min)
                                     + (OutPoint[DXB_X].Min >> 5 /* / 32 */)
                                     + 1 /* we don't use the first DWORD */];
    int   nBit      = OutPoint[DXB_X].Min % 32;

    ulInToTest  = 1;
    aWeight[0]  = 255;
    aInIndex[0] = ((dwCurrent << nBit) & 0x80000000) ? 1 : 0;
}
//  Method: CDXTRandomDissolve::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::OnInitInstData, CDXBaseNTo1
//
//  Overview:   This method is responsible for updating the bitmask representing
//              the output of the transform.  Lit bits represent pixels of input
//              B and 0 bits represent pixels of input A.
//
//              Keep in mind that what we consider a "row" in this function is
//              32 bits.  This has no relation to the number of pixels in a row
//              of the output surface.  
//
//------------------------------------------------------------------------------
HRESULT
CDXTRandomDissolve::OnInitInstData(CDXTWorkInfoNTo1 & WI, 
                                   ULONG & ulNumBandsToDo)
{
    DWORD   dwElement   = 1;
    UINT    nRow        = 0;
    UINT    cPixelsCur  = 0;
    UINT    cPixelsMax  = (UINT)(((float)m_cPixelsMax + 0.5F) * m_Progress);

    // TODO:  We can optimize if nothing is dirty and we're not blending with
    //        the output.  Keep track of the last execute's dwElement and 
    //        cPixelsCur and take if from there.  (Don't zero memory.)

    ZeroMemory(m_pdwBitBuffer, m_cPixelsMax / 8);

    while (cPixelsCur < cPixelsMax)
    {
        // The random number generator will generate number our of our range
        // so we need to make sure this number is in our range before we set
        // a value in our bit buffer.

        if (dwElement < m_cPixelsMax)
        {
            // For the purpose of this function, our rows are 32 bits wide so we
            // get the row number by dividing by 32.

            nRow = dwElement >> 5;   // row = dwElement / 32

            // Once in the row, we have to set the appropriate bit, which is the
            // remainder after dividing by 32.

            m_pdwBitBuffer[nRow] |= (0x80000000 >> (dwElement & 31)); 
                                                    // ^^ dwElement % 32

            // We've set a pixel, increment the pixel count.

            cPixelsCur++;
        }

        // Get next random value.  See Graphics Gems I for explanation.

        if (dwElement & 1)
        {
            dwElement = (dwElement >> 1) ^ m_dwRandMask;
        }
        else
        {
            dwElement = (dwElement >> 1);
        }

        // (1 == dwElement) should only happen when cPixelsMax == m_cPixelsMax.

        // SamBent:  Not quite.  When cPixelsMax == m_cPixelsMax - 1,
        // dwElement will need to cycle through all 2^n-1 values before finding 
        // the last good one (at dwElement == 1).  The comment a few lines
        // below (about "zero is never selected") should have been a tipoff.

        if (1 == dwElement)
        {
            _ASSERT(cPixelsMax >= m_cPixelsMax - 1);

            break;
        }
    }

    // At this point, cPixelsCur should be equal to cPixelsMax except when 
    // cPixelsMax == m_cPixelsMax (m_Progress == 1.0) where cPixelsCur will
    // equal cPixelsMax - 1 because zero is never selected.

    _ASSERT((cPixelsCur == cPixelsMax) || ((cPixelsCur == cPixelsMax - 1) && (cPixelsMax == m_cPixelsMax)));

    return S_OK;
}
//  Method: CDXTRandomDissolve::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::WorkProc, CDXBaseNTo1
//
//  Overview:   WorkProc takes the bit buffer updated in OnInitInstData and
//              updates the output surface using it.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRandomDissolve::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    long    lDoWidth        = WI.DoBnds.Width();
    long    lDoHeight       = WI.DoBnds.Height();
    long    lOutY           = 0;

    // nCurrent will be the index of the first DWORD in our bit buffer that
    // holds the bit representing the first pixel we care about in the first
    // row we care about.  For each row nCurrent will be incremented by 
    // m_cdwPitch.

    UINT    nCurrent        = (m_cdwPitch * WI.DoBnds.Top())// Row we want.
                              + (WI.DoBnds.Left() / 32)     // Column we want.
                              + 1;                          // We ignore the
                                                            //  first DWORD.

    // dwFirstBit will represent the first bit in the DWORD that represents
    // the left side of the bounds we were requested to draw.

    DWORD   dwFirstBit      = 0x80000000 >> (WI.DoBnds.Left() % 32);

    DXPMSAMPLE * pRowBuffA  = NULL;
    DXPMSAMPLE * pRowBuffB  = NULL;
    DXPMSAMPLE * pOutBuff   = NULL;

    DXDITHERDESC dxdd;

    CComPtr<IDXARGBReadPtr>         spReadA;
    CComPtr<IDXARGBReadPtr>         spReadB;
    CComPtr<IDXARGBReadWritePtr>    spOut;

    // Get a read pointer to input A.

    hr = InputSurface(0)->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, 
                                     (void **)&spReadA, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get a read pointer to input B.

    hr = InputSurface(1)->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, 
                                     (void **)&spReadB, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get a read/write pointer to the output surface.

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE, 
                                      IID_IDXARGBReadWritePtr, 
                                      (void **)&spOut, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Allocate a buffer.

    pRowBuffA = DXPMSAMPLE_Alloca(lDoWidth);
    pRowBuffB = DXPMSAMPLE_Alloca(lDoWidth);

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(lDoWidth);
    }

    // Set up the dither structure.

    if (DoDither())
    {
        dxdd.x                  = WI.OutputBnds.Left();
        dxdd.y                  = WI.OutputBnds.Top();
        dxdd.pSamples           = pRowBuffA;
        dxdd.cSamples           = lDoWidth;
        dxdd.DestSurfaceFmt     = OutputSampleFormat();
    }

    for (lOutY = 0; *pbContinue && (lOutY < lDoHeight); lOutY++)
    {
        // TODO:  Optimize by copying pixels from the surface that will be 
        //        likely to have less pixels needing to be copied.

        long    x           = 0;

        // pdwBits points to the first DWORD containing bits correstponding
        // to this output row.

        DWORD * pdwBits     = &m_pdwBitBuffer[nCurrent];

        // dwCurBit is initialized to the left-most bit.

        DWORD   dwCurBit    = dwFirstBit;                  

        // Read samples from both inputs.

        spReadA->MoveToRow(lOutY);
        spReadB->MoveToRow(lOutY);

        spReadA->UnpackPremult(pRowBuffA, lDoWidth, FALSE);
        spReadB->UnpackPremult(pRowBuffB, lDoWidth, FALSE);

        for ( ; x < lDoWidth ; x++)
        {
            if (*pdwBits & dwCurBit)
            {
                // Copy this pixel from input B's buffer to input A's buffer.
                // After these operations, input A's buffer will be copied onto
                // the output surface.

                pRowBuffA[x] = pRowBuffB[x];
            }

            dwCurBit >>= 1;

            if (!dwCurBit)
            {
                // We've used up the current DWORD's bits.  Move ahead one 
                // DWORD and reset current bit to the left-most bit.

                pdwBits++;
                
                dwCurBit = 0x80000000;
            }
        }

        // Move to the correct output row.

        spOut->MoveToRow(lOutY);

        // Dither if requested.

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        // Blend the bits or just copy.

        if (DoOver())
        {
            spOut->OverArrayAndMove(pOutBuff, pRowBuffA, lDoWidth);
        }
        else
        {
            spOut->PackPremultAndMove(pRowBuffA, lDoWidth);
        }

        // Increment our DWORD counter by the pitch.

        nCurrent += m_cdwPitch;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTRandomDissolve::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomDissolve::_BitWidth
//
//------------------------------------------------------------------------------
UINT
CDXTRandomDissolve::_BitWidth(UINT n)
{
    UINT nWidth = 0;

    while (n)
    {
        n >>= 1;

        nWidth++;
    }

    return nWidth;
}
//  Method: CDXTRandomDissolve::_BitWidth
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\pixelate.cpp ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//  Filename:   pixelate.cpp
//
//  Overview:   Implementation of a pixelate DXTransform.
//
//  Change History:
//  2000/04/13  mcalkins    Code cleanup, NoOp optimization fix.
//
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "Pixelate.h"

// Functions for doing WorkProc color averaging in the 2 input case.

static DXPMSAMPLE
_DoPixelateBlock_TwoInputs(DXPMSAMPLE * pSrc1, DXPMSAMPLE *pSrc2,
                           int nBoxWidth, int nBoxHeight, ULONG uOtherWeight,
                           int cbStride1, int cbStride2);
static DXPMSAMPLE
_DoPixelateBlockMMX_TwoInputs(DXPMSAMPLE * pSrc1, DXPMSAMPLE *pSrc2,
                              int nBoxWidth, int nBoxHeight, ULONG uOtherWeight,
                              int cbStride1, int cbStride2);

// Functions for doing WorkProc color averaging in the 1 input case.

static DXPMSAMPLE
_DoPixelateBlock_OneInput(DXPMSAMPLE *pSrc, int nBoxWidth, int nBoxHeight,
                          int cbStride);
static DXPMSAMPLE
_DoPixelateBlockMMX_OneInput(DXPMSAMPLE *pSrc, int nBoxWidth, int nBoxHeight,
                             int cbStride);

// Is MMX available?

extern CDXMMXInfo g_MMXDetector;




//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::CPixelate
//
//------------------------------------------------------------------------------
CPixelate::CPixelate() :
    m_fNoOp(false),
    m_fOptimizationPossible(false),
    m_nMaxSquare(50),
    m_nPrevSquareSize(0),
    m_pfnOneInputFunc(NULL),
    m_pfnTwoInputFunc(NULL)
{
    m_sizeInput.cx      = 0;
    m_sizeInput.cy      = 0;

    // CDXTBaseNTo1 members.

    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 1;
    m_Progress          = 1.0f;

    // If we're on the X86, we'll try asking the MMX detector if there's MMX instructions and if so
    // we'll set our WorkProc() helper functions to the MMX versions. The CDXMMXInfo object will correctly
    // tell us that there's no MMX even if we're *not* on X86, but we go the extra step to hardcode the fact
    // that we know it's a waste of time to even ask.

#ifdef _X86_
    if (g_MMXDetector.MinMMXOverCount() == 0xFFFFFFFF)
    {
#endif // _X86_
        m_pfnOneInputFunc = _DoPixelateBlock_OneInput;
        m_pfnTwoInputFunc = _DoPixelateBlock_TwoInputs;
#ifdef _X86_
    }
    else
    {
        m_pfnOneInputFunc = _DoPixelateBlockMMX_OneInput;
        m_pfnTwoInputFunc = _DoPixelateBlockMMX_TwoInputs;
    }
#endif // _X86_
}
//  Method: CPixelate::CPixelate


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT CPixelate::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(),
                                         &m_spUnkMarshaler.p);
}
//  Method: CPixelate::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::OnSetup, CDXTBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT CPixelate::OnSetup(DWORD /*dwFlags*/)
{
    HRESULT     hr = S_OK;
    CDXDBnds    bnds;

    hr = InputSurface()->GetBounds(&bnds);

    if (FAILED(hr))
    {
        goto done;
    }

    bnds.GetXYSize(m_sizeInput);

done:

    m_fOptimizationPossible = false;

    return hr;
}
//  Method: CPixelate::OnSetup, CDXTBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::OnGetSurfacePickOrder, CDXTBaseNTo1
//
//------------------------------------------------------------------------------
void
CPixelate::OnGetSurfacePickOrder(const CDXDBnds & /*BndsPoint*/,
                                 ULONG & ulInToTest, ULONG aInIndex[],
                                 BYTE aWeight[])
{
    ulInToTest  = 1;
    aWeight[0]  = 255;
    aInIndex[0] = 0;

    if (HaveInput(1))
    {
        if (m_Progress < 0.5)
        {
            if (m_Progress > 0.25f)
            {
                aWeight[0] = (BYTE)((m_Progress - 0.25f) * 255.1f * 2.0f);
                aWeight[1] = DXInvertAlpha(aWeight[0]);
                aInIndex[1] = 1;
                ulInToTest = 2;
            }
        }
        else
        {
            aInIndex[0] = 1;
            if (m_Progress < 0.75f)
            {
                aWeight[0] = (BYTE)((0.75 - m_Progress) * 255.1f * 2.0f);
                aWeight[1] = DXInvertAlpha(aWeight[0]);
                aInIndex[1] = 0;
                ulInToTest = 2;
            }
        }
        aWeight[1] = DXInvertAlpha(aWeight[0]);
    }
}
//  Method: CPixelate::OnGetSurfacePickOrder, CDXTBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::OnInitInstData, CDXTBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CPixelate::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    long nSquareSize = 1 + (long)(((float)(m_nMaxSquare) - 0.0001f)
                                  * m_Progress);

    if (   !m_fOptimizationPossible
        || (nSquareSize != m_nPrevSquareSize)
        || IsInputDirty(0)
        || (HaveInput(1) ? IsInputDirty(1) : false)
        || IsOutputDirty()
        || IsTransformDirty()
        || DoOver())
    {
        m_fNoOp             = false;
        m_nPrevSquareSize   = nSquareSize;
    }
    else
    {
        m_fNoOp = true;
    }

    if (   (WI.DoBnds.Width()  == (ULONG)m_sizeInput.cx)
        && (WI.DoBnds.Height() == (ULONG)m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

    return S_OK;
}
//  Method: CPixelate::OnInitInstData, CDXTBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::WorkProc, CDXTBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT CPixelate::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing)
{
    HRESULT     hr          = S_OK;
    ULONG       SourceSurf  = 0;
    float       prog        = m_Progress;
    BYTE        OtherWeight = 0;

    if (m_fNoOp)
    {
        // TODO:  Move all local variables to the top of the function so we can
        //        use the "goto done" syntax.

        return S_OK;
    }

    if (HaveInput(1))
    {
        if (prog >= 0.5f)
        {
            if (prog < 0.75f)
            {
                OtherWeight = (BYTE)((0.75f - prog) * 255.1f * 2.0f);
            }
            prog = (1.0f - prog);
            SourceSurf = 1;
        }
        else
        {
            if (prog > 0.25f)
            {
                OtherWeight = (BYTE)((prog - 0.25f) * 255.1f * 2.0f);
            }
        }
        prog *= 2.0f;
    }

    long Square = 1 + (ULONG)((((float)(m_nMaxSquare)) - 0.0001f) * prog);

    if (Square < 2)
    {
        return DXBitBlt(OutputSurface(), WI.OutputBnds,
                        InputSurface(SourceSurf), WI.DoBnds,
                        m_dwBltFlags, m_ulLockTimeOut);
    }

    //
    //  Always lock the entire source for reading
    //
    CComPtr<IDXARGBReadPtr> pSrc;

    hr = InputSurface(SourceSurf)->LockSurface(NULL, m_ulLockTimeOut,
                                               DXLOCKF_READ,
                                               IID_IDXARGBReadPtr,
                                               (void**)&pSrc, NULL);

    if (FAILED(hr))
    {
        return hr;
    }

    CComPtr<IDXARGBReadPtr> pSrcOther;

    if (OtherWeight)
    {
        hr = InputSurface((SourceSurf + 1) % 2)->LockSurface(NULL,
                                                             m_ulLockTimeOut,
                                                             DXLOCKF_READ,
                                                             IID_IDXARGBReadPtr,
                                                             (void**)&pSrcOther, NULL);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    CComPtr<IDXARGBReadWritePtr> pDest;

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut,
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr,
                                      (void**)&pDest, NULL);

    if (FAILED(hr))
    {
        return hr;
    }

    BOOL bDoOver = m_dwMiscFlags & DXTMF_BLEND_WITH_OUTPUT;

    RECT rectOut;
    rectOut.left = rectOut.top = 0;
    rectOut.right = m_sizeInput.cx;
    rectOut.bottom = m_sizeInput.cy;

    RECT DoRect;
    WI.DoBnds.GetXYRect(DoRect);

    long cbRowWidth = Square * sizeof(DXPMSAMPLE);
    // Find SquareBytes mod 8
    long nPadding = 8 - (cbRowWidth & 7);

    if (nPadding == 8)
        nPadding = 0;

    // Find width rounded up to nearest multiple of 8
    long nWidth = (cbRowWidth + 7) & ~(7);

    // Allocate our pitched rows and an extra 8 pixels so we can adjust the pointer to
    // QWord alignment
    long nBytesToAlloc = (nWidth * Square) + 8;

    DXPMSAMPLE *pBuff = (DXPMSAMPLE *)alloca(nBytesToAlloc);
    DXPMSAMPLE *pOtherBuff = (DXPMSAMPLE *)alloca(nBytesToAlloc);

    // Adjust the pointers to QWord alignment by rounding up to nearest multiple of 8
    pBuff = (DXPMSAMPLE *)((INT_PTR)((BYTE *)pBuff + 7) & ~(7));
    pOtherBuff = (DXPMSAMPLE *)((INT_PTR)((BYTE *)pOtherBuff + 7) & ~(7));

    long CenterX = (m_sizeInput.cx / 2) - (Square / 2);
    long CenterY = (m_sizeInput.cy / 2) - (Square / 2);


    DXPACKEDRECTDESC prd1;
    DXPACKEDRECTDESC prd2;


    prd1.pSamples = pBuff;
    prd1.bPremult = TRUE;
    prd1.lRowPadding = nPadding / sizeof(DXPMSAMPLE);

    prd2.pSamples = pOtherBuff;
    prd2.bPremult = TRUE;
    prd2.lRowPadding = nPadding / sizeof(DXPMSAMPLE);

    long StartX = (CenterX % Square);
    long StartY = (CenterY % Square);

    if (StartX)
    {
        StartX -= Square;
    }
    if (StartY)
    {
        StartY -= Square;
    }

    for (long y = StartY; y < DoRect.bottom; y += Square)
    {
        //
        //  Do a quick clipping check -- If the output region does not contain
        //  the rows then skip.
        //
        if (y + Square > DoRect.top)
        {
            for (long x = StartX; x < m_sizeInput.cx; x += Square)
            {
                DXPMSAMPLE  Color;
                RECT        r;
                RECT        rectOutClipped;

                r.left = x; r.right = x+Square;
                r.top = y; r.bottom = y+Square;

                IntersectRect(&prd1.rect, &r, &rectOut);

                if (IntersectRect(&rectOutClipped, &prd1.rect, &DoRect))
                {
                    long    lWidth = (prd1.rect.right - prd1.rect.left);
                    long    lHeight = (prd1.rect.bottom - prd1.rect.top);

                    // Set the padding to be the remainder to move to the next QWord boundary after
                    // one row of the rectangle.  QWord boundaries are important for the MMX optimizations
                    // we've made because they allow us to move more quickly through the data.
                    long cbRectWidth = (lWidth * sizeof(DXPMSAMPLE));


                    DXNATIVETYPEINFO    nti;
                    DXNATIVETYPEINFO    nti2;
                    DXSAMPLEFORMATENUM  format;
                    DXSAMPLEFORMATENUM  format2;
                    DXPMSAMPLE *pData = NULL;
                    DXPMSAMPLE *pData2 = NULL;
                    long    cbRowStride;
                    long    cbRowStride2;


                    format = pSrc->GetNativeType(&nti);

                    if (format == DXPF_PMARGB32 && !DoOver() && NULL != nti.pFirstByte)
                    {
                        pData = (DXPMSAMPLE *)(nti.pFirstByte + (nti.lPitch * prd1.rect.top) + (prd1.rect.left * sizeof(DXPMSAMPLE)));
                        cbRowStride = nti.lPitch;
                    }
                    else
                    {
                        prd1.lRowPadding = (cbRectWidth & 7) ? ((8 - (cbRectWidth & 7)) / sizeof(DXPMSAMPLE)) : 0;
                        pSrc->UnpackRect(&prd1);
                        pData = pBuff;
                        cbRowStride = (cbRectWidth + 7) & ~(7);
                    }

                    if (OtherWeight)
                    {
                        format2 = pSrcOther->GetNativeType(&nti2);
                        CopyRect(&prd2.rect, &prd1.rect);

                        if (format2 == DXPF_PMARGB32 && !DoOver() && NULL != nti2.pFirstByte)
                        {
                            pData2 = (DXPMSAMPLE *)(nti2.pFirstByte + (nti2.lPitch * prd2.rect.top) + (prd2.rect.left * sizeof(DXPMSAMPLE)));
                            cbRowStride2 = nti2.lPitch;
                        }
                        else
                        {
                            prd2.lRowPadding = (cbRectWidth & 7) ? ((8 - (cbRectWidth & 7)) / sizeof(DXPMSAMPLE)) : 0;
                            pSrcOther->UnpackRect(&prd2);
                            pData2 = pOtherBuff;
                            cbRowStride2 = (cbRectWidth + 7) & ~(7);
                        }

                        Color = (*m_pfnTwoInputFunc)(pData, pData2, lWidth, lHeight, OtherWeight,
                                                     cbRowStride, cbRowStride2);
                    }
                    else
                    {
                        Color = (*m_pfnOneInputFunc)(pData, lWidth, lHeight, cbRowStride);
                    }

                    if (Color.Alpha || (!bDoOver))
                    {
                        rectOutClipped.left -= DoRect.left;
                        rectOutClipped.right -= DoRect.left;
                        rectOutClipped.top -= DoRect.top;
                        rectOutClipped.bottom -= DoRect.top;
                        pDest->FillRect(&rectOutClipped, Color, bDoOver);
                    }
                }
            }
        }
    }
    return hr;
}
//  Method: CPixelate::WorkProc, CDXTBaseNTo1

//+-----------------------------------------------------------------------------
//
//  CBarn::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CPixelate::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    // Calling IsOutputDirty() clears the dirty state we just caused by writing
    // to the output in WorkProc().

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CPixelate::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::put_MaxSquare, IDXPixelate
//
//------------------------------------------------------------------------------
STDMETHODIMP
CPixelate::put_MaxSquare(int newVal)
{
    DXAUTO_OBJ_LOCK;

    if (newVal < 2 || newVal > 50)
    {
        return E_INVALIDARG;
    }

    if (m_nMaxSquare != newVal)
    {
        m_nMaxSquare = newVal;
        SetDirty();
    }

    return S_OK;
}
//  Method: CPixelate::put_MaxSquare, IDXPixelate


//+-----------------------------------------------------------------------------
//
//  Method: CPixelate::get_MaxSquare, IDXPixelate
//
//------------------------------------------------------------------------------
STDMETHODIMP
CPixelate::get_MaxSquare(int * pVal)
{
    if (!pVal)
    {
        return E_POINTER;
    }

    *pVal = m_nMaxSquare;

    return S_OK;
}
//  Method: CPixelate::get_MaxSquare, IDXPixelate


//////////////////////////////////////////////////////////////////////////////////
//
// PIXELATE_MMX_VALS
//
// Simple structure to represent the values that get stored to memory from the
// two quadwords that were holding the summed pixel values. The ordering is
// crucial here. The MMX quadword registers were storing AAAAAAAA RRRRRRRR and
// GGGGGGGG BBBBBBBB but in the packing, the DWORD's get swapped. Therefore the
// ordering becomes Red, Alpha, Blue, Green.

struct PIXELATE_MMX_VALS
{
    DWORD   Red;
    DWORD   Alpha;
    DWORD   Blue;
    DWORD   Green;
};

//////////////////////////////////////////////////////////////////////////////////
//

static DXPMSAMPLE
_DoPixelateBlockMMX_TwoInputs(DXPMSAMPLE * pSrc1, DXPMSAMPLE *pSrc2,
                              int nBoxWidth, int nBoxHeight, ULONG uOtherWeight,
                              int cbStride1, int cbStride2)
{
#if defined(_X86_)        // (In other words, use MMX)

    _ASSERT(g_MMXDetector.MinMMXOverCount() != 0xFFFFFFFF);

    // Calculate pointers that are at the beginning of the last row so we can move backwards
    // through the block of memory.
    DXPMSAMPLE  *pSrcEnd1 = (DXPMSAMPLE *)((BYTE *)pSrc1 + ((nBoxHeight-1) * cbStride1));
    DXPMSAMPLE  *pSrcEnd2 = (DXPMSAMPLE *)((BYTE *)pSrc2 + ((nBoxHeight-1) * cbStride2));

    PIXELATE_MMX_VALS   rgMMXOutputs[2];

    if (nBoxWidth > 0 && nBoxHeight > 0)
    {
        __asm
        {
            // Setup our pointers into memory for building the first image's average
            mov     ebx,pSrcEnd1        // Read pointer base
            mov     edx,80000000h       // Set high bit to indicate first pass
            mov     edi,cbStride1       // Number of bytes to back up the base pointer in ebx

StartOfBlock:
            mov     eax,nBoxHeight      // Number of rows (height)
            mov     esi,nBoxWidth       // Store width here for quick access in the future

            ///////////////////////////////////////////////////////
            // Register Layout
            //
            // eax  Count of rows remaining
            // ebx  Base pointer to current row start
            // ecx  Count of 8-pixel blocks per row
            //  dx  Count of leftover pixels per row (0 <= dx <= 8)
            //      (High bit of edx tracks first vs. second source. 1 for first source, zero for second)
            // esi  Extra copy of nBoxWidth to use in refreshing counters
            // edi  Row stride -- amount to subtract from ebx to move up one row
            //
            // mm0  Zero (constant)
            // mm1  Temp storage
            // mm2  Temp storage
            // mm3  Temp storage
            // mm4  Temp storage
            // mm5  Stores high-order DWORD's of running total (AAAA AAAA  RRRR RRRR)
            // mm6  Stores low-order DWORD's of running total  (BBBB BBBB  GGGG GGGG)
            // mm7  Accumulator for running total within a row

            pxor        mm0,mm0         // 0000 0000  0000 0000
            pxor        mm5,mm5         // AAAA AAAA  RRRR RRRR
            pxor        mm6,mm6         // BBBB BBBB  GGGG GGGG

StartOfRow:
            // Setup these counters which get destroyed in the processing of the row
            mov     ecx,esi
            mov     dx,si
            and     dx, 7               // Number of extra pixels beyond nearest multiple of 8
            and     ecx, 0fffffff8h     // Number of pixels rounded down to mult of 8

            shl     ecx,2               // Multiply by four to turn into a pointer offset

            pxor        mm7,mm7         // Running total for this row

// Do the first straggler pixels
            push    ebx
            add     ebx,ecx
            shl     dx,2                // Turn nStragglers into a byte count

            // Add (nStragglers-2)*sizeof(DXPMSAMPLE) to the base pointer in ebx
            push    edx
            and     edx,7fffffffh
            sub     edx,8               // Move back 2 pixels (8 bytes)
            add     ebx,edx
            pop     edx

StragglerLoop:
            cmp     dx,4
            jle     StragglerSingle

            movq        mm1,[ebx]
            sub     dx,8
            sub     ebx,8

            movq        mm2,mm1
            punpcklbw   mm1,mm0
            punpckhbw   mm2,mm0
            paddusw     mm7,mm1
            paddusw     mm7,mm2

            jmp StragglerLoop

StragglerSingle:
            cmp     dx,0
            je      StragglerEnd

            mov     ebx,dword ptr [ebx+4]

            movd        mm1,ebx
            punpcklbw   mm1,mm0
            paddusw     mm7,mm1

StragglerEnd:
            pop ebx
            cmp     ecx,0                   // Check to see if there are any 8-pixel blocks to do
            jle     FinishedRow             // If not, jump past the "GoLikeCrazy" loop

GoLikeCrazy:
            movq        mm1,[ebx+ecx-8]     // 1.01
            sub     ecx,32                  // Setup ecx for loop invariant below

            movq        mm2,mm1             // 1.02
            punpcklbw   mm1,mm0             // 1.03
            punpckhbw   mm2,mm0             // 1.04
            movq        mm3,[ebx+ecx+16]    // 2.01
            paddusw     mm7,mm1             // 1.05
            paddusw     mm7,mm2             // 1.06

            movq        mm4,mm3             // 2.02
            punpcklbw   mm3,mm0             // 2.03
            punpckhbw   mm4,mm0             // 2.04
            movq        mm1,[ebx+ecx+8]     // 3.01
            paddusw     mm7,mm3             // 2.05
            paddusw     mm7,mm4             // 2.06

            movq        mm2,mm1             // 3.02
            punpcklbw   mm1,mm0             // 3.03
            punpckhbw   mm2,mm0             // 3.04
            movq        mm3,[ebx+ecx]       // 4.01
            paddusw     mm7,mm1             // 3.05
            paddusw     mm7,mm2             // 3.06

            movq        mm4,mm3             // 4.02
            punpcklbw   mm3,mm0             // 4.03
            punpckhbw   mm4,mm0             // 4.04
            paddusw     mm7,mm3             // 4.05
            paddusw     mm7,mm4             // 4.06

            jnz GoLikeCrazy     // Zero flag state comes from "sub ecx,32" above

FinishedRow:
            // Pack two low-order WORD's into DWORD temp storage in mm5
            // Pack two high-order WORD's into DWORD temp storage in mm6

            movq        mm3,mm7
            punpckhwd   mm3,mm0
            punpcklwd   mm7,mm0

            // Accumulate those DWORD's to the running total in mm3 and mm4

            paddd       mm5,mm3     // High
            paddd       mm6,mm7     // Low

            sub     ebx,edi
            dec     eax
            jnz     StartOfRow

//FinishedBlock:

            // The high bit of edx tells us whether this is the first pass (set) or the second
            // pass. If first, setup for second and loop. Else, finish the function.

            test    edx,80000000h
            jz      FinishedBoth    // Fall through if the flag is still set

//(Finished first block summation)
            // Store our accumulated sums of A,R,G,B to two DWORDs
            movq        [rgMMXOutputs],mm5
            movq        [rgMMXOutputs+8],mm6

            // Clear flag, set source pointer and stride, and loop to top
            and     edx,7fffffffh
            mov     ebx,pSrcEnd2
            mov     edi,cbStride2

            jmp StartOfBlock

FinishedBoth:
            // Store our accumulated sums of A,R,G,B to two DWORDs
            movq        [rgMMXOutputs+16],mm5
            movq        [rgMMXOutputs+24],mm6

            EMMS    // Das Ende

        } // End of __asm block
    }

    ULONG   cSamps = (ULONG)(nBoxHeight * nBoxWidth);

    DXPMSAMPLE  color1((BYTE)(rgMMXOutputs[0].Alpha / cSamps),
                       (BYTE)(rgMMXOutputs[0].Red / cSamps),
                       (BYTE)(rgMMXOutputs[0].Green / cSamps),
                       (BYTE)(rgMMXOutputs[0].Blue / cSamps));

    DXPMSAMPLE  color2((BYTE)(rgMMXOutputs[1].Alpha / cSamps),
                       (BYTE)(rgMMXOutputs[1].Red / cSamps),
                       (BYTE)(rgMMXOutputs[1].Green / cSamps),
                       (BYTE)(rgMMXOutputs[1].Blue / cSamps));

    return DXScaleSample(color1, (BYTE)DXInvertAlpha((BYTE)uOtherWeight)) +
           DXScaleSample(color2, (BYTE)uOtherWeight);

#else // !defined(_X86_)

    // This function should only be called on X86 platforms that might have MMX
    _ASSERT(false);
    return DXPMSAMPLE(0,0,0,0);

#endif // !defined(_X86_)

} // _DoPixelateBlockMMX_TwoInputs

////////////////////////////////////////////////////////////////////////////////////////////
//
//
static DXPMSAMPLE
_DoPixelateBlockMMX_OneInput(DXPMSAMPLE * pSrc, int nBoxWidth, int nBoxHeight, int cbStride)
{
#if defined(_X86_)        // (In other words, use MMX)

    // We should only have setup the function pointer to call this function if MMX is available
    _ASSERT(g_MMXDetector.MinMMXOverCount() != 0xFFFFFFFF);

    // Calculate pointers that are at the beginning of the last row so we can move backwards
    // through the block of memory.
    DXPMSAMPLE  *pSrcEnd = (DXPMSAMPLE *)((BYTE *)pSrc + ((nBoxHeight-1) * cbStride));

    PIXELATE_MMX_VALS   MMXOutput;

    if (nBoxWidth > 0 && nBoxHeight > 0)
    {
        __asm
        {
            // Setup our pointers into memory for building the first image's average
            mov     ebx,pSrcEnd         // Read pointer base

            mov     eax,nBoxHeight      // Number of rows (height)
            mov     esi,nBoxWidth       // Store width here for quick access in the future

            mov     edi,cbStride        // Number of bytes to back up the base pointer in ebx

            ///////////////////////////////////////////////////////
            // Register Layout
            //
            // eax  Count of rows remaining
            // ebx  Base pointer to current row start
            // ecx  Count of 8-pixel blocks per row
            // edx  Count of leftover pixels per row (0 <= edx <= 8)
            // esi  Extra copy of nBoxWidth to use in refreshing counters
            // edi  Row stride -- amount to subtract from ebx to move up one row
            //
            // mm0  Zero (constant)
            // mm1  Temp storage
            // mm2  Temp storage
            // mm3  Temp storage
            // mm4  Temp storage
            // mm5  Stores high-order DWORD's of running total (AAAA AAAA  RRRR RRRR)
            // mm6  Stores low-order DWORD's of running total  (BBBB BBBB  GGGG GGGG)
            // mm7  Accumulator for running total within a row

            pxor        mm0,mm0         // 0000 0000  0000 0000
            pxor        mm5,mm5         // AAAA AAAA  RRRR RRRR
            pxor        mm6,mm6         // BBBB BBBB  GGGG GGGG

StartOfRow:
            // Setup these counters which get destroyed in the processing of the row
            mov     ecx,esi
            mov     edx,esi
            and     edx,7               // Number of extra pixels beyond nearest multiple of 8
            and     ecx,0fffffff8h      // Number of pixels rounded down to mult of 8

            shl     ecx,2               // Multiply by four to turn into a pointer offset

            pxor        mm7,mm7         // Running total for this row

// Do the first straggler pixels
            push    ebx
            add     ebx,ecx
            shl     edx,2               // Turn nStragglers into a byte count

StragglerLoop:
            cmp     edx,4
            jle     StragglerSingle

            movq        mm1,[ebx+edx-8]
            sub     edx,8

            movq        mm2,mm1
            punpcklbw   mm1,mm0
            punpckhbw   mm2,mm0
            paddusw     mm7,mm1
            paddusw     mm7,mm2

            jmp StragglerLoop

StragglerSingle:
            cmp     edx,0
            je      StragglerEnd

            mov     ebx,dword ptr [ebx]

            movd        mm1,ebx
            punpcklbw   mm1,mm0
            paddusw     mm7,mm1

StragglerEnd:
            pop     ebx
            cmp     ecx,0                   // Check to see if there are any 8-pixel blocks to do
            jle     FinishedRow             // If not, jump past the "GoLikeCrazy" loop

GoLikeCrazy:
            movq        mm1,[ebx+ecx-8]     // 1.01
            sub     ecx,32                  // Setup ecx for loop invariant below

            movq        mm2,mm1             // 1.02
            punpcklbw   mm1,mm0             // 1.03
            punpckhbw   mm2,mm0             // 1.04
            movq        mm3,[ebx+ecx+16]    // 2.01
            paddusw     mm7,mm1             // 1.05
            paddusw     mm7,mm2             // 1.06

            movq        mm4,mm3             // 2.02
            punpcklbw   mm3,mm0             // 2.03
            punpckhbw   mm4,mm0             // 2.04
            movq        mm1,[ebx+ecx+8]     // 3.01
            paddusw     mm7,mm3             // 2.05
            paddusw     mm7,mm4             // 2.06

            movq        mm2,mm1             // 3.02
            punpcklbw   mm1,mm0             // 3.03
            punpckhbw   mm2,mm0             // 3.04
            movq        mm3,[ebx+ecx]       // 4.01
            paddusw     mm7,mm1             // 3.05
            paddusw     mm7,mm2             // 3.06

            movq        mm4,mm3             // 4.02
            punpcklbw   mm3,mm0             // 4.03
            punpckhbw   mm4,mm0             // 4.04
            paddusw     mm7,mm3             // 4.05
            paddusw     mm7,mm4             // 4.06

            jnz GoLikeCrazy     // Zero flag state comes from "sub ecx,32" above

FinishedRow:
            // Pack two low-order WORD's into DWORD temp storage in mm5
            // Pack two high-order WORD's into DWORD temp storage in mm6

            movq        mm3,mm7
            punpckhwd   mm3,mm0
            punpcklwd   mm7,mm0

            // Accumulate those DWORD's to the running total in mm3 and mm4

            paddd       mm5,mm3     // High
            paddd       mm6,mm7     // Low

            sub     ebx,edi
            dec     eax
            jnz     StartOfRow

//FinishedBlock:

            // Store our accumulated sums of A,R,G,B to two DWORDs
            movq        [MMXOutput],mm5
            movq        [MMXOutput+8],mm6

            EMMS    // Das Ende

        } // End of __asm block
    }

    ULONG   cSamps = (ULONG)(nBoxHeight * nBoxWidth);

    DXPMSAMPLE  color((BYTE)(MMXOutput.Alpha / cSamps),
                      (BYTE)(MMXOutput.Red / cSamps),
                      (BYTE)(MMXOutput.Green / cSamps),
                      (BYTE)(MMXOutput.Blue / cSamps));

    return color;

#else // !defined(_X86_)

    // This function should only be called when we're on X86 platforms.
    _ASSERT(false);
    return DXPMSAMPLE(0, 0, 0, 0);

#endif // !defined(_X86_)

} // _DoPixelateBlockMMX_OneInput

//////////////////////////////////////////////////////////////////////////////////
//
//
static DXPMSAMPLE
_DoPixelateBlock_OneInput(DXPMSAMPLE *pSrc, int nBoxWidth, int nBoxHeight, int cbStride)
{
    int cSamps = nBoxWidth * nBoxHeight;

    ULONG Alpha = 0;
    ULONG Red = 0;
    ULONG Green = 0;
    ULONG Blue = 0;

    DXPMSAMPLE *    pRead = pSrc;

    // It works out that to be padded to QWords means that if the number of samples
    // is odd, then 4 padding bytes (1 sample) are added.  If it's even, none are added.
    int     cPadding = nBoxWidth & 1;
    int     nPaddedWidth = nBoxWidth + cPadding;

    for (int i = 0; i < nBoxHeight; i++)
    {
        for (int j = 0; j < nBoxWidth; j++)
        {
            DWORD val = *pRead++;

            Alpha += (val >> 24);
            Red += (BYTE)(val >> 16);
            Green += (BYTE)(val >> 8);
            Blue += (BYTE)(val);
        }
        pRead += cPadding;
    }

    return DXPMSAMPLE((BYTE)(Alpha / cSamps),
                      (BYTE)(Red / cSamps),
                      (BYTE)(Green / cSamps),
                      (BYTE)(Blue / cSamps));
}

//////////////////////////////////////////////////////////////////////////////////
//
//
static DXPMSAMPLE
_DoPixelateBlock_TwoInputs(DXPMSAMPLE *pSrc1, DXPMSAMPLE *pSrc2, int nBoxWidth, int nBoxHeight,
                           ULONG uOtherWeight, int cbStride1, int cbStride2)
{
    int cSamps = nBoxWidth * nBoxHeight;

    ULONG Alpha = 0;
    ULONG Red = 0;
    ULONG Green = 0;
    ULONG Blue = 0;

    DXPMSAMPLE *    pRead = pSrc1;

    // It works out that to be padded to QWords means that if the number of samples
    // is odd, then 4 padding bytes (1 sample) are added.  If it's even, none are added.
    int     cPadding = nBoxWidth & 1;
    int     nPaddedWidth = nBoxWidth + cPadding;
    int     i,j;

    for (i = 0; i < nBoxHeight; i++)
    {
        for (j = 0; j < nBoxWidth; j++)
        {
            DWORD val = *pRead++;

            Alpha += (val >> 24);
            Red += (BYTE)(val >> 16);
            Green += (BYTE)(val >> 8);
            Blue += (BYTE)(val);
        }
        pRead += cPadding;
    }

    DXPMSAMPLE color1((BYTE)(Alpha / cSamps),
                      (BYTE)(Red / cSamps),
                      (BYTE)(Green / cSamps),
                      (BYTE)(Blue / cSamps));

    pRead = pSrc2;
    Alpha = Red = Green = Blue = 0;

    for (i = 0; i < nBoxHeight; i++)
    {
        for (j = 0; j < nBoxWidth; j++)
        {
            DWORD val = *pRead++;

            Alpha += (val >> 24);
            Red += (BYTE)(val >> 16);
            Green += (BYTE)(val >> 8);
            Blue += (BYTE)(val);
        }
        pRead += cPadding;
    }

    DXPMSAMPLE color2((BYTE)(Alpha / cSamps),
                      (BYTE)(Red / cSamps),
                      (BYTE)(Green / cSamps),
                      (BYTE)(Blue / cSamps));

    return DXScaleSample(color1, (BYTE)DXInvertAlpha((BYTE)uOtherWeight)) +
           DXScaleSample(color2, (BYTE)uOtherWeight);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\pixelate.h ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//  Filename:   pixelate.h
//
//  Overview:   Declaration of a pixelate DXTransform.
//
//  Change History:
//  2000/04/13  mcalkins    Code cleanup, NoOp optimization fix.
//  2000/05/10  mcalkins    Support IObjectSafety appropriately, add marshaler.
//
//------------------------------------------------------------------------------
#ifndef __PIXELATE_H_
#define __PIXELATE_H_

#include "resource.h"

typedef DXPMSAMPLE (* PONEINPUTFUNC)(DXPMSAMPLE *, int, int, int);
typedef DXPMSAMPLE (* PTWOINPUTFUNC)(DXPMSAMPLE *, DXPMSAMPLE *, int, int, ULONG, int, int);

/////////////////////////////////////////////////////////////////////////////
// CPixelate
class ATL_NO_VTABLE CPixelate :
    public CDXBaseNTo1,
    public CComCoClass<CPixelate, &CLSID_Pixelate>,
    public IDispatchImpl<IDXPixelate, &IID_IDXPixelate, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CPixelate>,
    public IObjectSafetyImpl2<CPixelate>,
    public IPersistStorageImpl<CPixelate>,
    public ISpecifyPropertyPagesImpl<CPixelate>,
    public IPersistPropertyBagImpl<CPixelate>
{
private:

    unsigned            m_fNoOp                 : 1;
    unsigned            m_fOptimizationPossible : 1;

    long                m_nMaxSquare;
    long                m_nPrevSquareSize;

    PONEINPUTFUNC       m_pfnOneInputFunc;
    PTWOINPUTFUNC       m_pfnTwoInputFunc;

    SIZE                m_sizeInput;

    CComPtr<IUnknown>   m_spUnkMarshaler;

public:

    CPixelate();

    DECLARE_POLY_AGGREGATABLE(CPixelate)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_PIXELATE)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CPixelate)
        COM_INTERFACE_ENTRY(IDXPixelate)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CPixelate>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CImage)
        PROP_ENTRY("MaxSquare", 1, CLSID_PixelatePP)
        PROP_PAGE(CLSID_PixelatePP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WorkInfo, 
                     BOOL * pbContinueProcessing);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);
    void    OnGetSurfacePickOrder(const CDXDBnds & /*BndsPoint*/, 
                                  ULONG & ulInToTest, ULONG aInIndex[],
                                  BYTE aWeight[]);

    // IDXEffect methods.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH);

    // IDXPixelate properties.

    STDMETHOD(put_MaxSquare)(int newVal);
    STDMETHOD(get_MaxSquare)(int * pVal);
};


#endif //__PIXELATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\randomdissolve.h ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  Filename:   randomdissolve.h
//
//  Overview:   A random dissolve transform.
//
//  Change History:
//  1999/09/26  a-matcal    Created.
//
//------------------------------------------------------------------------------

#ifndef __RANDOMDISSOLVE_H_
#define __RANDOMDISSOLVE_H_

#include "resource.h"   




class ATL_NO_VTABLE CDXTRandomDissolve : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTRandomDissolve, &CLSID_DXTRandomDissolve>,
    public IDispatchImpl<IDXEffect, &IID_IDXEffect, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTRandomDissolve>,
    public IObjectSafetyImpl2<CDXTRandomDissolve>,
    public IPersistStorageImpl<CDXTRandomDissolve>,
    public IPersistPropertyBagImpl<CDXTRandomDissolve>
{
private:

    DWORD * m_pdwBitBuffer;
    DWORD   m_dwRandMask;
    UINT    m_cdwPitch;
    UINT    m_cPixelsMax;
    SIZE    m_sizeInput;

    CComPtr<IUnknown> m_spUnkMarshaler;

    // Helper methods.

    UINT _BitWidth(UINT n);

public:

    CDXTRandomDissolve();
    virtual ~CDXTRandomDissolve();

    DECLARE_POLY_AGGREGATABLE(CDXTRandomDissolve)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTRANDOMDISSOLVE)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTRandomDissolve)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTRandomDissolve>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTRandomDissolve)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, 
                                  ULONG & ulInToTest,
                                  ULONG aInIndex[], BYTE aWeight[]);

    // IDXEffect properties.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};

#endif //__RANDOMDISSOLVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\randombars.h ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  Filename:   randombars.h
//
//  Overview:   One pixel thick horizontal or vertical bars from input B are 
//              randomly placed over input A until only input B is showing.
//
//  Change History:
//  1999/09/26  a-matcal    Created.
//  1999/10/06  a-matcal    Removed _WorkProcVertical and _WorkProcHorizontal
//                          Added m_fNoOp, m_cCurPixelsmax, and m_cPrevPixelsMax 
//                          members to enable simple optimization.
//
//------------------------------------------------------------------------------

#ifndef __RANDOMBARS_H_
#define __RANDOMBARS_H_

#include "resource.h"   




class ATL_NO_VTABLE CDXTRandomBars : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTRandomBars, &CLSID_DXTRandomBars>,
    public IDispatchImpl<IDXTRandomBars, &IID_IDXTRandomBars, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTRandomBars>,
    public IObjectSafetyImpl2<CDXTRandomBars>,
    public IPersistStorageImpl<CDXTRandomBars>,
    public IPersistPropertyBagImpl<CDXTRandomBars>
{
private:

    typedef enum {
        ORIENTATION_HORIZONTAL = 0,
        ORIENTATION_VERTICAL,
        ORIENTATION_MAX
    } ORIENTATION;

    ORIENTATION             m_eOrientation;
    static const WCHAR *    s_astrOrientation[ORIENTATION_MAX];

    UINT        m_cbBufferSize;
    UINT        m_cPixelsMax;
    UINT        m_cCurPixelsMax;
    UINT        m_cPrevPixelsMax;
    BYTE *      m_pbBitBuffer;
    DWORD       m_dwRandMask;
    SIZE        m_sizeInput;

    CComPtr<IUnknown> m_spUnkMarshaler;

    unsigned    m_fNoOp                 : 1;
    unsigned    m_fOptimizationPossible : 1;

    // Helper methods.

    UINT    _BitWidth(UINT n);
    HRESULT _CreateNewBitBuffer(SIZE & sizeNew, ORIENTATION eOrientation);

public:

    CDXTRandomBars();
    virtual ~CDXTRandomBars();

    DECLARE_POLY_AGGREGATABLE(CDXTRandomBars)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTRANDOMBARS)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTRandomBars)
        COM_INTERFACE_ENTRY(IDXTRandomBars)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTRandomBars>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTRandomBars)
        PROP_ENTRY("orientation",   DISPID_DXTRANDOMBARS_ORIENTATION,   CLSID_DXTRandomBarsPP)
        PROP_PAGE(CLSID_DXTRandomBarsPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);

    // IDXTRandomBars properties.

    STDMETHOD(get_Orientation)(BSTR * pbstrOrientation);
    STDMETHOD(put_Orientation)(BSTR bstrOrientation);

    // IDXEffect properties.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};

#endif //__RANDOMBARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\randombars.cpp ===
//+-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  Filename:   randombars.cpp
//
//  Overview:   One pixel thick horizontal or vertical bars from input B are 
//              randomly placed over input A until only input B is showing.
//
//  Change History:
//  1999/09/26  a-matcal    Created.
//  1999/10/06  a-matcal    Combined WorkProcs into one general WorkProc.
//                          Implemented surface picking.
//                          Fixed bug where vertical bars leaving off right side
//                          of output.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "randombars.h"

extern DWORD g_adwRandMask[];




//+-----------------------------------------------------------------------------
//
//  CDXTRandomBars static variables initialization
//
//------------------------------------------------------------------------------

const WCHAR * CDXTRandomBars::s_astrOrientation[] = {
    L"horizontal",
    L"vertical"
};


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::CDXTRandomBars
//
//------------------------------------------------------------------------------
CDXTRandomBars::CDXTRandomBars() :
    m_eOrientation(ORIENTATION_HORIZONTAL),
    m_cbBufferSize(0),
    m_cPixelsMax(0),
    m_cPrevPixelsMax(0),
    m_pbBitBuffer(NULL),
    m_dwRandMask(0),
    m_fNoOp(false),
    m_fOptimizationPossible(false)
{
    m_sizeInput.cx      = 0;
    m_sizeInput.cy      = 0;

    // Base class members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  Method: CDXTRandomBars::CDXTRandomBars


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::~CDXTRandomBars
//
//------------------------------------------------------------------------------
CDXTRandomBars::~CDXTRandomBars()
{
    if (m_pbBitBuffer)
    {
        delete [] m_pbBitBuffer;
    }
}
//  Method: CDXTRandomBars::~CDXTRandomBars


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRandomBars::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  Method: CDXTRandomBars::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::OnSetup, CDXBaseNTo1
//
//  Overview:   This function will create a bit buffer where each bit represents
//              a row or column of the output, depending on whether the 
//              transform is set for vertical or horizontal action.
//
//              The bit buffer will be sized in whole bytes with one extra byte
//              at the beginning because the zero bit will never be set using
//              this random number generator.  This extra byte will be ignored.
//              
//------------------------------------------------------------------------------
HRESULT 
CDXTRandomBars::OnSetup(DWORD dwFlags)
{
    HRESULT hr      = S_OK;
    UINT    cbPitch = 0;

    SIZE        sizeNew;
    CDXDBnds    bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsInput.GetXYSize(sizeNew);

    // If the input size hasn't changed, we don't have to do any work here.

    if ((sizeNew.cx == m_sizeInput.cx) && (sizeNew.cy == m_sizeInput.cy))
    {
        goto done;
    }

    // Allocate new bit buffer if needed.

    hr = _CreateNewBitBuffer(sizeNew, m_eOrientation);

    if (FAILED(hr))
    {
        goto done;
    }

done:

    return hr;
} 
//  Method: CDXTRandomBars::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTRandomBars::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                      ULONG & ulInToTest,  ULONG aInIndex[],
                                      BYTE aWeight[])
{
    long    nMinBound   = (ORIENTATION_VERTICAL == m_eOrientation) ? 
                          OutPoint.Left() : OutPoint.Top();
    ULONG   nCurByte    = (nMinBound / 8) + 1;
    BYTE    bCurBit     = 0x80 >> (nMinBound % 8);

    ulInToTest  = 1;
    aWeight[0]  = 255;
    aInIndex[0] = (m_pbBitBuffer[nCurByte] & bCurBit) ? 1 : 0;
}
//  Method: CDXTRandomBars::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::OnInitInstData, CDXBaseNTo1
//
//  Overview:   This method is responsible for updating the bitmask representing
//              the output of the transform.  Lit bits represent pixels of input
//              B and 0 bits represent pixels of input A.
//
//              Keep in mind that what we consider a "row" in this function is
//              8 bits.  This has no relation to the number of pixels in a row
//              of the output surface.  
//
//------------------------------------------------------------------------------
HRESULT
CDXTRandomBars::OnInitInstData(CDXTWorkInfoNTo1 & WI, 
                               ULONG & ulNumBandsToDo)
{
    DWORD   dwElement   = 1;
    UINT    nRow        = 0;
    UINT    cPixelsCur  = 0;

    m_cCurPixelsMax = (UINT)(((float)m_cPixelsMax + 0.5F) * m_Progress);

    // Simple optimization so that we won't do the same thing twice in a row.

    if ((m_cPrevPixelsMax == m_cCurPixelsMax) && !IsInputDirty(0)
        && !IsInputDirty(1) && !IsOutputDirty() && !IsTransformDirty()
        && m_fOptimizationPossible)
    {
        m_fNoOp = true;

        goto done;
    }

    // TODO:  We can optimize better if nothing is dirty and we're not blending
    //        with the output.  Keep track of the last execute's dwElement and 
    //        cPixelsCur and take if from there.  (Don't zero memory.)

    ZeroMemory(m_pbBitBuffer, m_cPixelsMax / 8);

    while (cPixelsCur < m_cCurPixelsMax)
    {
        // The random number generator will generate number our of our range
        // so we need to make sure this number is in our range before we set
        // a value in our bit buffer.

        if (dwElement < m_cPixelsMax)
        {
            // For the purpose of this function, our rows are 8 bits wide so we
            // get the row number by dividing by 8.

            nRow = dwElement >> 3;   // row = dwElement / 8

            // Once in the row, we have to set the appropriate bit, which is the
            // remainder after dividing by 8.

            m_pbBitBuffer[nRow] |= (0x80 >> (dwElement & 7)); 
                                                 // ^^ dwElement % 8

            // We've set a pixel, increment the pixel count.

            cPixelsCur++;
        }

        // Get next random value.  See Graphics Gems I for explanation.

        if (dwElement & 1)
        {
            dwElement = (dwElement >> 1) ^ m_dwRandMask;
        }
        else
        {
            dwElement = (dwElement >> 1);
        }

        // (1 == dwElement) should only happen when m_cCurPixelsMax == m_cPixelsMax.

        // SamBent:  Not quite.  When m_cCurPixelsMax == m_cPixelsMax - 1,
        // dwElement will need to cycle through all 2^n-1 values before finding 
        // the last good one (at dwElement == 1).  The comment a few lines
        // below (about "zero is never selected") should have been a tipoff.

        if (1 == dwElement)
        {
            _ASSERT(m_cCurPixelsMax >= m_cPixelsMax - 1);

            break;
        }
    }

    // At this point, cPixelsCur should be equal to m_cCurPixelsMax except when 
    // m_cCurPixelsMax == m_cPixelsMax (m_Progress == 1.0) where cPixelsCur will
    // equal m_cCurPixelsMax - 1 because zero is never selected.

    _ASSERT((cPixelsCur == m_cCurPixelsMax) || ((cPixelsCur == m_cCurPixelsMax - 1) && (m_cCurPixelsMax == m_cPixelsMax)));

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    return S_OK;
}
//  Method: CDXTRandomBars::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::WorkProc, CDXBaseNTo1
//
//  Overview:   WorkProc takes the bit buffer updated in OnInitInstData and
//              updates the output surface using it.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRandomBars::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr              = S_OK;
    DWORD   dwFlags         = 0;
    ULONG   nCurInputIndex  = 0;
    ULONG   nNextInputIndex = 0;
    ULONG   nCurByte        = 0;
    BYTE    bCurBit         = 0;

    long    nDoMin          = 0;
    long    nDoMax          = 0;

    long *  pnSrcMin        = NULL;
    long *  pnSrcMax        = NULL;

    CDXDVec     vecDo2OutputOffset;
    CDXDBnds    bndsSrc(WI.DoBnds);
    CDXDBnds    bndsDest;

    // Leave if no work is needed.

    if (m_fNoOp)
    {
        goto done;
    }

    // This vector is the difference between the upper left corner of the "do"
    // bounds and where the do bounds should be placed on the output surface.

    vecDo2OutputOffset.u.D[DXB_X] = WI.OutputBnds.Left() - WI.DoBnds.Left();
    vecDo2OutputOffset.u.D[DXB_Y] = WI.OutputBnds.Top() - WI.DoBnds.Top();

    // Set up max and min variables for vertical or horizontal case.

    if (ORIENTATION_VERTICAL == m_eOrientation)
    {
        nDoMin = WI.DoBnds.Left();
        nDoMax = WI.DoBnds.Right();

        pnSrcMin = &bndsSrc.u.D[DXB_X].Min;
        pnSrcMax = &bndsSrc.u.D[DXB_X].Max;
    }
    else
    {
        nDoMin = WI.DoBnds.Top();
        nDoMax = WI.DoBnds.Bottom();

        pnSrcMin = &bndsSrc.u.D[DXB_Y].Min;
        pnSrcMax = &bndsSrc.u.D[DXB_Y].Max;
    }

    // The source bounds start of as empty at the left or top side of the "do" 
    // bounds.

    *pnSrcMax = *pnSrcMin;

    // nCurByte is the first byte that we care about.  Add one byte because
    // the first byte is discarded since the first bit will never be selected
    // by the random number generator.
    
    nCurByte    = (nDoMin / 8) + 1;

    // bCurBit is the first bit in that byte that we care about.

    bCurBit     = 0x80 >> (nDoMin % 8);

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    nCurInputIndex  = (m_pbBitBuffer[nCurByte] & bCurBit) ? 1 : 0;
    nNextInputIndex = nCurInputIndex;

    while ((*pnSrcMax < nDoMax) && *pbContinue)
    {
        *pnSrcMin = *pnSrcMax;

        // While the input needed to draw the row/column stays the same, expand 
        // the rectangle to paint.

        while((*pnSrcMax < nDoMax) && (nNextInputIndex == nCurInputIndex))
        {
            // Rectangle to paint gets one pixel wider.

            (*pnSrcMax)++;

            // Go to next bit.

            bCurBit >>= 1;

            if (!bCurBit)
            {
                // We've used up the bits in this byte, go to next byte and 
                // reset the bit.

                nCurByte++;

                bCurBit = 0x80;
            }

            nNextInputIndex = (m_pbBitBuffer[nCurByte] & bCurBit) ? 1 : 0;
        }

        // Set destination bounds.

        bndsDest = bndsSrc;
        bndsDest.Offset(vecDo2OutputOffset);

        // Paint this rectangle.

        hr = DXBitBlt(OutputSurface(), bndsDest,
                      InputSurface(nCurInputIndex), bndsSrc,
                      dwFlags, m_ulLockTimeOut);

        if (FAILED(hr))
        {
            goto done;
        }

        nCurInputIndex = nNextInputIndex;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTRandomBars::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTRandomBars::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    m_cPrevPixelsMax    = m_cCurPixelsMax;
    m_fNoOp             = false;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  Method: CDXTRandomBars::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::get_Orientation, IDXTRandomBars
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRandomBars::get_Orientation(BSTR * pbstrOrientation)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrOrientation)
    {
        return E_POINTER;
    }

    if (*pbstrOrientation != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrOrientation = SysAllocString(s_astrOrientation[m_eOrientation]);

    if (NULL == *pbstrOrientation)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  Method: CDXTRandomBars::get_Orientation, IDXTRandomBars


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::put_Orientation, IDXTRandomBars
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRandomBars::put_Orientation(BSTR bstrOrientation)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;
    
    if (NULL == bstrOrientation)
    {
        return E_POINTER;
    }

    for ( ; i < (int)ORIENTATION_MAX ; i++)
    {
        if (!_wcsicmp(bstrOrientation, s_astrOrientation[i]))
        {
            break;
        }
    }

    if ((int)ORIENTATION_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eOrientation != i)
    {
        HRESULT hr = _CreateNewBitBuffer(m_sizeInput, (ORIENTATION)i);

        if (FAILED(hr))
        {
            return hr;
        }

        m_eOrientation = (ORIENTATION)i;

        SetDirty();
    }

    return S_OK;
}
//  Method: CDXTRandomBars::put_Orientation, IDXTRandomBars


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::_BitWidth
//
//------------------------------------------------------------------------------
UINT
CDXTRandomBars::_BitWidth(UINT n)
{
    UINT nWidth = 0;

    while (n)
    {
        n >>= 1;

        nWidth++;
    }

    return nWidth;
}
//  Method: CDXTRandomBars::_BitWidth


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRandomBars::_CreateNewBitBuffer
//
//------------------------------------------------------------------------------
HRESULT
CDXTRandomBars::_CreateNewBitBuffer(SIZE & sizeNew, ORIENTATION eOrientation)
{
    HRESULT hr              = S_OK;
    UINT    cbBufferSize    = 0;

    // How many bytes would be needed to hold a bit for each row/column.

    if (ORIENTATION_VERTICAL == eOrientation)
    {
        cbBufferSize = sizeNew.cx / 8;

        if (sizeNew.cx % 8)
        {
            cbBufferSize++;  // Add one if division truncated.
        }    
    }
    else
    {
        cbBufferSize = sizeNew.cy / 8;

        if (sizeNew.cy % 8)
        {
            cbBufferSize++;  // Add one if division truncated.
        }    
    }

    // Add 1 byte so the first byte can be ignored since the zero bit will never
    // be set.

    cbBufferSize++;

    // Do we need to allocate a new buffer?

    if ((cbBufferSize == m_cbBufferSize) && m_pbBitBuffer)
    {
        // Our bit buffer is already the correct size, so just change the input
        // size and return.

        m_sizeInput.cx = sizeNew.cx;
        m_sizeInput.cy = sizeNew.cy;
    }
    else // We need to allocate a new bit buffer.
    {
        BYTE *  pbBitsTemp      = NULL;

        pbBitsTemp = new BYTE[cbBufferSize];

        if (NULL == pbBitsTemp)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        m_sizeInput.cx  = sizeNew.cx;
        m_sizeInput.cy  = sizeNew.cy;
        m_cbBufferSize  = cbBufferSize;

        // What is the maximum pixel represented by our buffer?  (This will be
        // different than the maximum pixel of the input surfaces.)

        m_cPixelsMax    = cbBufferSize * 8;

        // The maximum number we need our random number generator to create is
        // m_cPixelsMax - 1.  So we get the bit width of that number and then
        // get the appropriate random number generating mask from the global 
        // array.

        m_dwRandMask    = g_adwRandMask[_BitWidth(m_cPixelsMax -1)];

        // Even if the inputs are 1x1 pixel, the bit mask will be at
        // least 16-bits (representing 16 pixels) and it will be impossible
        // for us to get a 0 rand mask.  But we'll assert, just to be sure.

        _ASSERT(m_dwRandMask);

        // Replace the bit buffer.

        if (m_pbBitBuffer)
        {
            delete [] m_pbBitBuffer;
        }

        m_pbBitBuffer = pbBitsTemp;
    }

done:

    return hr;
}
//  Method: CDXTRandomBars::_CreateNewBitBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\redirect.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:            redirect.cpp
//
//  Discription:         The redirect transform.
//
//  Change History:
//  1999/09/20  a-matcal    Created.
//  1999/11/09  a-matcal    Handle OnSetup to create a buffer surface if the
//                          output surface doesn't have 32-bit color depth.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "redirect.h"




//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::CDXTRedirect
//
//------------------------------------------------------------------------------
CDXTRedirect::CDXTRedirect() :
    m_fDetached(false),
    m_dwChromaColor(0)
{
    m_ulMaxImageBands   = 1; // disable banding
    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;
}
//  CDXTRedirect::CDXTRedirect


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRedirect::FinalConstruct()
{
    HRESULT hr = S_OK;

    CComPtr<IDAImage> spDAImage;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_cpUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = CoCreateInstance(CLSID_DAStatics, NULL, CLSCTX_INPROC_SERVER,
                          __uuidof(IDAStatics), (void **)&m_spDAStatics);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spDAStatics->get_EmptyImage(&spDAImage);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spDAStatics->ModifiableBehavior(spDAImage, (IDABehavior **)&m_spDAImage);

    if (FAILED(hr))
    {
        goto done;
    }

done:

    return hr;
}
//  CDXTRedirect::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTRedirect::OnSetup(DWORD dwFlags)
{
    HRESULT         hr      = S_OK;
    HDC             hdc     = NULL;
    HBITMAP         hbm     = NULL;
    DDSURFACEDESC   ddsd;
    DDCOLORKEY      ddck;

    CComPtr<IServiceProvider>       spServiceProvider;
    CComPtr<IDXSurfaceFactory>      spDXSurfaceFactory;
    CComPtr<IDirectDraw>            spDirectDraw;

    // Ask our site for a service provider.

    hr = GetSite(__uuidof(IServiceProvider), (void **)&spServiceProvider);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get a pointer to a surface factory.

    hr = spServiceProvider->QueryService(SID_SDXSurfaceFactory,
                                         __uuidof(IDXSurfaceFactory),
                                         (void **)&spDXSurfaceFactory);

    if (FAILED(hr))
    {
        goto done;
    }

    // Query transform factory for DirectDraw object.

    hr = spServiceProvider->QueryService(SID_SDirectDraw, IID_IDirectDraw,
                                         (void **)&spDirectDraw);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get display mode.

    ZeroMemory(&ddsd, sizeof(DDSURFACEDESC));

    ddsd.dwSize = sizeof(DDSURFACEDESC);

    hr = spDirectDraw->GetDisplayMode(&ddsd);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get input surface size.  Our buffer surface will need to be this size.

    hr = InputSurface()->GetBounds(&m_bndsInput);

    if (FAILED(hr))
    {
        goto done;
    }

    // Stuff from old filters code that will hopefully help us to create the
    // a surface in the exact surface format we need.  In a better world, it 
    // shouldn't matter, but it does.

    ddsd.dwFlags           &= ~DDSD_PITCH;
    ddsd.lPitch             = 0;
    ddsd.lpSurface          = NULL;
    ddsd.dwBackBufferCount  = 0;
    ddsd.dwReserved         = 0;
    ddsd.dwHeight           = m_bndsInput.Height();
    ddsd.dwWidth            = m_bndsInput.Width();

    // Do some corrections for 16-bit mode to make sure we choose correctly
    // between 555 and 565.  This code is taken out of offscrn.cxx in Trident
    // from the PixelFormat() function.

    if (16 == ddsd.ddpfPixelFormat.dwRGBBitCount)
    {
        struct
        {
            BITMAPINFOHEADER bih;
            DWORD            bf[3];
        } bi;

        hdc = ::GetDC(NULL);

        if (NULL == hdc)
        {
            hr = E_FAIL;

            goto done;
        }

        hbm = ::CreateCompatibleBitmap(hdc, 1, 1);

        if (NULL == hbm)
        {
            hr = E_FAIL;

            goto done;
        }

        ZeroMemory(&bi, sizeof(bi));

        bi.bih.biSize = sizeof(BITMAPINFOHEADER);

        // The first call will fill in the optimal biBitCount.

        GetDIBits(hdc, hbm, 0, 1, NULL, (BITMAPINFO*)&bi, DIB_RGB_COLORS);

        if (bi.bih.biBitCount == 16)
        {
            // The second call will get the optimal bitfields.

            GetDIBits(hdc, hbm, 0, 1, NULL, (BITMAPINFO*)&bi, DIB_RGB_COLORS);

            ddsd.ddpfPixelFormat.dwRBitMask = bi.bf[0]; // red mask
            ddsd.ddpfPixelFormat.dwGBitMask = bi.bf[1]; // green mask
            ddsd.ddpfPixelFormat.dwBBitMask = bi.bf[2]; // blue mask
        }
        else
        {
            _ASSERT(false);
        }
    }

    // Release references to the old buffer surface.

    m_spDXSurfBuffer.Release();
    m_spDDSurfBuffer.Release();

    // Create the buffer surface.  For DATime to work properly, buffer surfaces
    // must be created in the display mode pixel format, except when the display
    // mode is 256 colors in which case it should be anything _but_ the display
    // mode pixel format.  We make it 32-bit for faster blits from the filter
    // buffer surfaces.

    hr = spDXSurfaceFactory->CreateSurface(NULL, &ddsd, NULL,
                                           &m_bndsInput, 0, NULL,
                                           __uuidof(IDXSurface), 
                                           (void **)&m_spDXSurfBuffer);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spDXSurfBuffer->GetDirectDrawSurface(IID_IDirectDrawSurface, 
                                                (void **)&m_spDDSurfBuffer);

    if (FAILED(hr))
    {
        goto done;
    }

    // Decide upon a color key to use depending on the surface description.

    if (   (0x00FF0000 == ddsd.ddpfPixelFormat.dwRBitMask)
        && (0x0000FF00 == ddsd.ddpfPixelFormat.dwGBitMask)
        && (0x000000FF == ddsd.ddpfPixelFormat.dwBBitMask))
    {
        // 32-bit or 24-bit.

        m_dwChromaColor = 0x0004FFF4;
    }
    else if (   (0x0000F800 == ddsd.ddpfPixelFormat.dwRBitMask)
             && (0x000007E0 == ddsd.ddpfPixelFormat.dwGBitMask)
             && (0x0000001F == ddsd.ddpfPixelFormat.dwBBitMask))
    {
        // 16-bit 5:6:5.

        m_dwChromaColor = 0x00000FFE;
    }
    else if (   (0x00007C00 == ddsd.ddpfPixelFormat.dwRBitMask)
             && (0x000003E0 == ddsd.ddpfPixelFormat.dwGBitMask)
             && (0x0000001F == ddsd.ddpfPixelFormat.dwBBitMask))
    {
        // 16-bit 5:5:5.

        m_dwChromaColor = 0x000007FE;
    }
    else
    {
        // 256 color surface or unknown pixel format, set to something.

        m_dwChromaColor = 0x00000021;
    }

    // Set the color key to our newly decided color key.

    ddck.dwColorSpaceHighValue  = m_dwChromaColor;
    ddck.dwColorSpaceLowValue   = m_dwChromaColor;

    hr = m_spDDSurfBuffer->SetColorKey(DDCKEY_SRCBLT, &ddck);

done:

    if (hdc)
    {
        ::ReleaseDC(NULL, hdc);
    }

    if (hbm)
    {
        ::DeleteObject(hbm);
    }

    return hr;
}
//  CDXTRedirect::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRedirect::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr  = S_OK;

    CComPtr<IDAImage>           spDAImage;
    CComPtr<IDirectDrawSurface> spDDSurface;

    _ASSERT(!!m_spDAStatics);
    _ASSERT(!!m_spDAImage);

    // Put input surface into image.

    if (IsInputDirty(0))
    {
        DDBLTFX ddbltfx;
        RECT    rc;

        // Set up blit effects structure and source RECT.

        ZeroMemory(&ddbltfx, sizeof(DDBLTFX));

        ddbltfx.dwSize      = sizeof(DDBLTFX);
        ddbltfx.dwFillColor = m_dwChromaColor;
        
        m_bndsInput.GetXYRect(rc);

        // Fill buffer surface with color key.

        hr = m_spDDSurfBuffer->Blt(&rc, NULL, NULL, DDBLT_COLORFILL, &ddbltfx);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = DXBitBlt(m_spDXSurfBuffer, m_bndsInput,
                      InputSurface(), m_bndsInput,
                      DXBOF_DO_OVER, INFINITE);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = m_spDAStatics->ImportDirectDrawSurface(m_spDDSurfBuffer, NULL,
                                                    &spDAImage);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = m_spDAImage->SwitchTo(spDAImage);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    if (m_spTIMEDAElementRender)
    {
        HDC         hdc     = NULL;
        RECT        rc;
        POINT       pt;

        CComPtr<IDirectDrawSurface> spDDSurfaceOut;

        hr = OutputSurface()->GetDirectDrawSurface(IID_IDirectDrawSurface,
                                                   (void **)&spDDSurfaceOut);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDDSurfaceOut->GetDC(&hdc);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = m_spTIMEDAElementRender->Tick();

        if (FAILED(hr))
        {
            goto done;
        }

        // This size of the rect passed to ITIMEDAElementRender::Draw should
        // always be the same size as the element.  Since this transform doesn't
        // change the size, that's the same size as the input surface.

        m_bndsInput.GetXYRect(rc);

        // The offset rect should be the element's rect offset to it's upper
        // left coordinate with regard to coordinate 0,0 of the HTML page.  This
        // only comes into use when the element is only partially drawn.
        
        OffsetRect(&rc, -WI.DoBnds.Left(), -WI.DoBnds.Top());

        // Set the viewport origin.

        if (!::SetViewportOrgEx(hdc, WI.OutputBnds.Left(), WI.OutputBnds.Top(), 
                                &pt))
        {
            hr = E_FAIL;

            goto done;
        }

        // DA will now draw the element to the page for us.

        hr = m_spTIMEDAElementRender->Draw(hdc, &rc);

        // Even if this fails we still need to reset the viewport origin.

        if (!::SetViewportOrgEx(hdc, pt.x, pt.y, NULL)) 
        {
            DASSERT(false);

            goto done;
        }

        if (FAILED(hr))
        {
            DASSERT(false);

            goto done;
        }
    }

    // This transform doesn't actually do any drawing in the way that transforms
    // usually do (writing bits to the output surface.)  If it did, it would
    // draw over the top of the DA stuff going on.

done:

    return hr;
} 
//  CDXTRedirect::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::SetHTMLPaintSite, IDXTRedirectFilterInit
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRedirect::SetHTMLPaintSite(void * pvHTMLPaintSite)
{
   if (NULL == pvHTMLPaintSite)
    {
        // This method should only be called with NULL when the a filter 
        // is being detached from an element.  And then only once.

        _ASSERT(!m_fDetached);

        m_fDetached = true;
    }

    m_spHTMLPaintSite = (IHTMLPaintSite *)pvHTMLPaintSite;

    return S_OK;
}
//  CDXTRedirect::SetHTMLPaintSite, IDXTRedirectFilterInit


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::Invalidate, ITIMEDAElementRenderSite
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRedirect::Invalidate(LPRECT prc)
{
    // DATime may call us from a timer tick after we've been detached and 
    // m_spHTMLPaintSite will be NULL.  If so, return E_UNEXPECTED.

    if (!m_fDetached)
    {
        return m_spHTMLPaintSite->InvalidateRect(prc);
    }
    else
    {
        // We're detached from the element, we can't really invalidate anyting.

        return E_UNEXPECTED;
    }
}
//  CDXTRedirect::Invalidate, ITIMEDAElementRenderSite


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::ElementImage, IDXTRedirect
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRedirect::ElementImage(VARIANT * pvarImage)
{
    HRESULT hr = S_OK;

    if (NULL == pvarImage)
    {
        hr = E_POINTER;

        goto done;
    }

    pvarImage->vt       = VT_DISPATCH;
    pvarImage->pdispVal = m_spDAImage;

    m_spDAImage->AddRef();

done:

    return hr;
}
//  CDXTRedirect::ElementImage, IDXTRedirect


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::SetDAViewHandler, IDXTRedirect
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRedirect::SetDAViewHandler(IDispatch * pDispViewHandler)
{
    HRESULT hr = S_OK;

    WCHAR *     pstrProperty    = L"renderObject";
    DISPID      dispid          = 0;

    DISPPARAMS  dispparams;
    VARIANT     varResult;
    VARIANT     varUnknown;

    VariantInit(&varResult);
    VariantInit(&varUnknown);

    if (m_spTIMEDAElementRender)
    {
        m_spTIMEDAElementRender->put_RenderSite(NULL);
        m_spTIMEDAElementRender.Release();
    }

    if (NULL == pDispViewHandler)
    {
        goto done;
    }

    dispparams.rgvarg               = NULL;
    dispparams.rgdispidNamedArgs    = NULL;
    dispparams.cArgs                = 0;
    dispparams.cNamedArgs           = 0;

    hr = pDispViewHandler->GetIDsOfNames(IID_NULL, &pstrProperty, 1,
                                         LOCALE_SYSTEM_DEFAULT, &dispid);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = pDispViewHandler->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT,
                                  DISPATCH_PROPERTYGET, &dispparams, &varResult,
                                  NULL, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = VariantChangeType(&varUnknown, &varResult, 0, VT_UNKNOWN);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = varUnknown.punkVal->QueryInterface(IID_ITIMEDAElementRender,
                                            (void **)&m_spTIMEDAElementRender);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spTIMEDAElementRender->put_RenderSite(
                                            (ITIMEDAElementRenderSite *)this);
                                  
done:

    VariantClear(&varResult);
    VariantClear(&varUnknown);

    return hr;
}
//  CDXTRedirect::SetDAViewHandler, IDXTRedirect


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::HasImageBeenAllocated, IDXTRedirect
//
//  I don't think this function is ever used by anyone.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRedirect::HasImageBeenAllocated(BOOL * pfAllocated)
{
    HRESULT hr = S_OK;

    if (NULL == pfAllocated)
    {
        hr = E_POINTER;

        goto done;
    }

    if (m_spDAImage)
    {
        *pfAllocated = FALSE;
    }
    else
    {
        *pfAllocated = TRUE;
    }

done:

    return hr;
}
//  CDXTRedirect::HasImageBeenAllocated, IDXTRedirect


//+-----------------------------------------------------------------------------
//
//  CDXTRedirect::DoRedirection, IDXTRedirect
//
//  I think this function was only called by the old filters code and
//  isn't needed any more.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRedirect::DoRedirection(IUnknown * pInputSurface,
                            HDC hdcOutput,
                            RECT * pDrawRect)
{
    return E_NOTIMPL;
}
//  CDXTRedirect::DoRedirection, IDXTRedirect
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\rwipe.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:            rwipe.h
//
// Created:             06/24/98
//
// Author:              phillu
//
// Discription:         This is the header file for the CrRadialWipe transformation
//
// Change History:
// 06/24/98 PhilLu      Developed 1.0 version for Chromeffects
// 11/04/98 PaulNash    Moved from DT 1.0 codebase to IE5/NT5 DXTMSFT.DLL
// 05/09/99 a-matcal    Optimizations.
// 10/22/99 a-matcal    Changed CRadialWipe class to CDXTRadialWipeBase and
//                      created two new classes CDXTRadialWipe and 
//                      CDXTRadialWipeOpt to represent non-optimized and 
//                      optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRRADIALWIPE_H_
#define __CRRADIALWIPE_H_

#include "resource.h"       // main symbols

#define MAX_DIRTY_BOUNDS 100

typedef enum CRRWIPESTYLE
{
    CRRWS_CLOCK,
    CRRWS_WEDGE,
    CRRWS_RADIAL
} CRRWIPESTYLE;




class ATL_NO_VTABLE CDXTRadialWipeBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrRadialWipe, &IID_ICrRadialWipe, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTRadialWipeBase>,
    public IObjectSafetyImpl2<CDXTRadialWipeBase>,
    public ISpecifyPropertyPagesImpl<CDXTRadialWipeBase>
{
private:

    SIZE            m_sizeInput;
    CRRWIPESTYLE    m_eWipeStyle;
    CDXDBnds        m_abndsDirty[MAX_DIRTY_BOUNDS];
    long            m_alInputIndex[MAX_DIRTY_BOUNDS];
    ULONG           m_cbndsDirty;
    POINT           m_ptCurEdge;
    POINT           m_ptPrevEdge;
    int             m_iCurQuadrant;
    int             m_iPrevQuadrant;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

private:

    // The _CalcBounds... functions calculate sets of optimized bounds
    // structures to improve the performance of the transform.

    HRESULT _CalcFullBoundsClock();
    HRESULT _CalcFullBoundsWedge();
    HRESULT _CalcFullBoundsRadial();

    HRESULT _CalcOptBoundsClock();
    HRESULT _CalcOptBoundsWedge();
    HRESULT _CalcOptBoundsRadial();

    HRESULT _DrawRect(const CDXDBnds & bndsDest, const CDXDBnds & bndsSrc, 
                      BOOL * pfContinue);
    void    _IntersectRect(long width, long height, long x0, long y0, 
                           double dx, double dy, long & xi, long & yi);
    void    _ScanlineIntervals(long width, long height, long xedge, long yedge, 
                               float fProgress, long YScanline, long * XBounds);
    void    _ClipBounds(long offset, long width, long * XBounds);

public:

    CDXTRadialWipeBase();
    HRESULT FinalConstruct();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTRadialWipeBase)
        COM_INTERFACE_ENTRY(ICrRadialWipe)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTRadialWipeBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTRadialWipeBase)
        PROP_ENTRY("wipeStyle", 1, CLSID_CrRadialWipePP)
        PROP_PAGE(CLSID_CrRadialWipePP)
    END_PROPERTY_MAP()

    // CDXBaseNTo1 overrides

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);

    void OnGetSurfacePickOrder(const CDXDBnds & TestPoint, ULONG & ulInToTest, 
                               ULONG aInIndex[], BYTE aWeight[]);

    // ICrRadialWipe

    STDMETHOD(get_wipeStyle)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_wipeStyle)(/*[in]*/ BSTR newVal);

    // IDXEffect

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTRadialWipe :
    public CDXTRadialWipeBase,
    public CComCoClass<CDXTRadialWipe, &CLSID_CrRadialWipe>,
    public IPersistStorageImpl<CDXTRadialWipe>,
    public IPersistPropertyBagImpl<CDXTRadialWipe>
{
public:

    CDXTRadialWipe()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTRADIALWIPE)
    DECLARE_POLY_AGGREGATABLE(CDXTRadialWipe)

    BEGIN_COM_MAP(CDXTRadialWipe)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTRadialWipeBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTRadialWipeOpt :
    public CDXTRadialWipeBase,
    public CComCoClass<CDXTRadialWipeOpt, &CLSID_DXTRadialWipe>,
    public IPersistStorageImpl<CDXTRadialWipeOpt>,
    public IPersistPropertyBagImpl<CDXTRadialWipeOpt>
{
public:

    CDXTRadialWipeOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTRADIALWIPEOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTRadialWipeOpt)

    BEGIN_COM_MAP(CDXTRadialWipeOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTRadialWipeBase)
    END_COM_MAP()
};


#endif //__CRRADIALWIPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\revealtrans.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       revealtrans.h
//
//  Overview:       The RevealTrans transform simply wraps other transforms to 
//                  ensure backward compatibility for the revealtrans filter.
//
//  Change History:
//  1999/09/18  a-matcal    Created.
//
//------------------------------------------------------------------------------

#ifndef __REVEALTRANS_H_
#define __REVEALTRANS_H_

#include "resource.h"




class ATL_NO_VTABLE CDXTRevealTrans : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDXTRevealTrans, &CLSID_DXTRevealTrans>,
    public IDispatchImpl<IDXTRevealTrans, &IID_IDXTRevealTrans, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTRevealTrans>,
    public IObjectSafetyImpl2<CDXTRevealTrans>,
    public IPersistStorageImpl<CDXTRevealTrans>,
    public ISpecifyPropertyPagesImpl<CDXTRevealTrans>,
    public IPersistPropertyBagImpl<CDXTRevealTrans>,
    public IDXTransform,
    public IDXSurfacePick,
    public IObjectWithSite
{
private:

    int     m_nTransition;
    int     m_cInputs;
    int     m_cOutputs;
    float   m_flProgress;
    float   m_flDuration;

    IUnknown * m_apunkInputs[2];
    IUnknown * m_apunkOutputs[1];

    CComPtr<IDXTransformFactory>    m_spDXTransformFactory;
    CComPtr<IDXTransform>           m_spDXTransform;
    CComPtr<IDXEffect>              m_spDXEffect;
    CComPtr<IDXSurfacePick>         m_spDXSurfacePick;

    CComPtr<IUnknown> m_spUnkMarshaler;
    CComPtr<IUnknown> m_spUnkSite;

    // Helpers.

    STDMETHOD(_InitializeNewTransform)(int nTransition, 
                                       IDXTransform * pDXTransform);
                                       
    void _FreeSurfacePointers();

public:

    CDXTRevealTrans();
    virtual ~CDXTRevealTrans();

    DECLARE_POLY_AGGREGATABLE(CDXTRevealTrans)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTREVEALTRANS)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTRevealTrans)
        COM_INTERFACE_ENTRY(IDXTRevealTrans)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDXTransform)
        COM_INTERFACE_ENTRY(IDXSurfacePick)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal,     m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTRevealTrans>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTRevealTrans)
        PROP_ENTRY("transition" , 1, CLSID_NULL)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // IDXTRevealTrans methods.

    STDMETHOD(get_Transition)(/*[out, retval]*/ int * pnTransition);
    STDMETHOD(put_Transition)(/*[in]*/ int nTransition);

    // IDXEffect methods.

    STDMETHOD(get_Capabilities)(long * plCapabilities);
    STDMETHOD(get_Duration)(float * pflDuration);
    STDMETHOD(put_Duration)(float flDuration);
    STDMETHOD(get_Progress)(float * pflProgress);
    STDMETHOD(put_Progress)(float flProgress);
    STDMETHOD(get_StepResolution)(float * pflStepResolution);

    // IDXTransform methods.

    STDMETHOD(Execute)(const GUID * pRequestID, const DXBNDS * pPortionBnds,
                       const DXVEC * pPlacement);
    STDMETHOD(GetInOutInfo)(BOOL bIsOutput, ULONG ulIndex, DWORD * pdwFlags,
                            GUID * pIDs, ULONG * pcIDs, 
                            IUnknown ** ppUnkCurrentObject);
    STDMETHOD(GetMiscFlags)(DWORD * pdwMiscFlags);
    STDMETHOD(GetQuality)(float * pfQuality);
    STDMETHOD(MapBoundsIn2Out)(const DXBNDS * pInBounds, ULONG ulNumInBnds,
                               ULONG ulOutIndex, DXBNDS * pOutBounds);
    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                               ULONG ulInIndex, DXBNDS * pInBounds);
    STDMETHOD(SetMiscFlags)(DWORD dwMiscFlags);
    STDMETHOD(SetQuality)(float fQuality);
    STDMETHOD(Setup)(IUnknown * const * punkInputs, ULONG ulNumInputs,
	             IUnknown * const * punkOutputs, ULONG ulNumOutputs,	
                     DWORD dwFlags);

    // IDXSurfacePick methods.

    STDMETHOD(PointPick)(const DXVEC * pvecOutputPoint, 
                         ULONG * pnInputSurfaceIndex,
                         DXVEC * pvecInputPoint);

    // IDXBaseObject methods.

    STDMETHOD(GetGenerationId)(ULONG * pnID);
    STDMETHOD(GetObjectSize)(ULONG * pcbSize);
    STDMETHOD(IncrementGenerationId)(BOOL fRefresh);

    // IObjectWithSite methods.

    STDMETHOD(SetSite)(IUnknown * pUnkSite);
    STDMETHOD(GetSite)(REFIID riid, void ** ppvSite);
};

#endif //__REVEALTRANS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\shadow.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    shodow.cpp
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	Implementation of CShadow, the Shadow transform
//
// Change History:
//
// 05/20/99 PhilLu      Move code from dtcss to dxtmsft. New implementation of
//                      shadow algorithm.
// 09/04/99 a-matcal    Fixed memory overrun issues.
// 12/03/99 a-matcal    Implement IDXTClipOrigin interface.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "Shadow.h"
#include "dxclrhlp.h"

DeclareTag(tagFilterShadow,  "Filter: Shadow",   "Shadow DXTransform info.");

                      //  0     45    90    135   180    225    270    315
SIZE g_Direction[8] = {{0,-1},{1,-1},{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1}};


//+-----------------------------------------------------------------------------
//
//  CShadow::CShadow
//
//------------------------------------------------------------------------------
CShadow::CShadow() :
    m_lStrength(8),
    m_lDirection(5),    // 225 degrees
    m_bstrColor(NULL)
{
    m_rgbColor          = DXSAMPLE(255,0,0,0);
    
    // Base class members.

    m_ulMaxImageBands   = 1; // disable banding
    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;
}
//  CShadow::CShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::~CShadow
//
//------------------------------------------------------------------------------
CShadow::~CShadow()
{
    if (m_bstrColor)
    {
        SysFreeString(m_bstrColor);
    }
}
//  CShadow::~CShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CShadow::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_cpUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    m_bstrColor = SysAllocString(L"black");

    if (NULL == m_bstrColor)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CShadow::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CShadow::put_Color, IDXTShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CShadow::put_Color(BSTR bstrColor)
{
    HRESULT hr          = S_OK;
    BSTR    bstrTemp    = NULL;
    DWORD   dwColor     = 0x00000000;

    DXSAMPLE rgbTemp;

    hr = DXColorFromBSTR(bstrColor, &dwColor);

    if (SUCCEEDED(hr))
    {
        bstrTemp = SysAllocString(bstrColor);

        if (NULL == bstrTemp)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }
    }
    else if (FAILED(hr) && (6 == SysStringLen(bstrColor)))
    {
        // Nasty back compat issue.  If the color conversion failed, let's
        // try putting a # in front of it because _someone_ decided when
        // they made the original filters not to require it.  grrrr....

        bstrTemp = SysAllocString(L"#RRGGBB");

        if (NULL == bstrTemp)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        wcsncpy(&bstrTemp[1], bstrColor, 6);

        hr = DXColorFromBSTR(bstrTemp, &dwColor);

        if (FAILED(hr))
        {
            goto done;
        }
    }
    else
    {
        goto done;
    }

    rgbTemp = (DXSAMPLE)dwColor;

    // Lock and change color.

    Lock();

    if (m_rgbColor != rgbTemp)
    {
        m_rgbColor = (DXSAMPLE)dwColor;
        SetDirty();
    }

    // Replace color string with new color string regardless of whether the
    // actual color changed or not.

    Assert(bstrTemp);

    SysFreeString(m_bstrColor);

    m_bstrColor = bstrTemp;

    Unlock();

done:

    if (FAILED(hr) && bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    return hr;
}
//  CShadow::put_Color, IDXTShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::get_Color, IDXTShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CShadow::get_Color(BSTR * pbstrColor)
{
    HRESULT hr = S_OK;

    if (NULL == pbstrColor)
    {
        hr = E_POINTER;

        goto done;
    }

    if (*pbstrColor != NULL)
    {
        hr = E_INVALIDARG;

        goto done;
    }

    *pbstrColor = SysAllocString(m_bstrColor);

    if (NULL == *pbstrColor)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

done:

    return hr;
}
//  CShadow::get_Color, IDXTShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::get_Strength, IDXTShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CShadow::get_Strength(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    *pVal = m_lStrength;
    return S_OK;
}
//  CShadow::get_Strength, IDXTShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::put_Strength, IDXTShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CShadow::put_Strength(long lStrength)
{
    long Strength = min(max(lStrength, 1), 255);

    if (Strength != m_lStrength)
    {
        Lock();
        m_lStrength = Strength;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CShadow::put_Strength, IDXTShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::get_Direction, IDXTShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CShadow::get_Direction(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    // angle from direction code
    *pVal = m_lDirection*45;
    return S_OK;
}
//  CShadow::get_Direction, IDXTShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::put_Direction, IDXTShadow
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CShadow::put_Direction(long newVal)
{
    int iDirection;

    Lock();
    if (newVal < 0)
    {
        // add enough multiples of 360 to make the angle positive
        newVal += ((-newVal-1)/360 + 1)*360;
    }

    // discretize the angle into a direction code 0 .. 7
    iDirection = (newVal + 22)%360 / 45;
    
    if (m_lDirection != iDirection)
    {
        m_lDirection = iDirection;
        SetDirty();
    }
    Unlock();

    return S_OK;
}
//  CShadow::get_Direction, IDXTShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CShadow::OnSetup(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CDXDBnds bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (SUCCEEDED(hr))
    {
        m_bndsInput = bndsInput;
    }

    return hr;

}
//  CShadow::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CShadow::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CShadow::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                       CDXDVec & InVec)
{
    HRESULT         hr                  = S_OK;
    DXSAMPLE        sample              = 0;
    POINT           pt                  = {0, 0};
    int             nShadowPixels       = 0;
    int             nInputPixelsToCheck = 0;
    int             i                   = 0;
    int             nAlphaStep          = 255 / (m_lStrength + 1);
    int             nAlpha              = 0;
    bool            fDiagonal           = true;

    CDXDBnds        bndsShadowInput;
    CDXDBnds        bndsActualInput;

    CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

    // This DXTransform only has one index so we know if an input is hit it will
    // be input 0.

    ulInputIndex = 0;

    // Is the shadow really diagonal?

    if (   (0 == g_Direction[m_lDirection].cx)
        || (0 == g_Direction[m_lDirection].cy))
    {
        fDiagonal = false;
    }

    // If the output point is not in the shadow area or the input area, it's in
    // one of the empty corners so just return that nothing was hit.

    if (   fDiagonal
        && _IsOutputPointInEmptyCorner(OutPoint))
    {
        hr = S_FALSE;

        goto done;
    }

    // What are the bounds of the input surface pixels we need to look at to
    // determine if the hit point is on a shadow.

    hr = MapBoundsOut2In(0, &OutPoint, 0, &bndsShadowInput);

    if (FAILED(hr))
    {
        goto done;
    }

    // Which input surface pixel if any directly relates to the output pixel to
    // be tested.

    hr = _GetActualInputBndsFromOutputBnds(OutPoint, bndsActualInput);

    if (FAILED(hr))
    {
        goto done;
    }

    // How many pixels do we need to test to caculate the alpha value of a
    // potential shadow pixel?

    if (fDiagonal)
    {
        nShadowPixels = min(bndsShadowInput.Width(), bndsShadowInput.Height());
    }
    else
    {
        nShadowPixels = max(bndsShadowInput.Width(), bndsShadowInput.Height());
    }

    // If there is an input point that directly relates to the output pixel to
    // be tested, we don't need to check that pixel, so reduce the number of
    // pixels to check by one.

    if (!bndsActualInput.BoundsAreEmpty())
    {
        nInputPixelsToCheck = nShadowPixels - 1;
    }
    else
    {
        nInputPixelsToCheck = nShadowPixels;
    }

    // Calculate nAlpha.
    // nAlpha is the alpha value of the shadow pixel if this output pixel
    // correclates to a shadow pixel.

    if (nInputPixelsToCheck)
    {
        // Initialize pt.

        if (g_Direction[m_lDirection].cx < 0)
        {
            pt.x = bndsShadowInput.Width() - 1;
        }

        if (g_Direction[m_lDirection].cy < 0)
        {
            pt.y = bndsShadowInput.Height() - 1;
        }

        // Lock surface to get access to pixels that need to be checked.

        hr = InputSurface(0)->LockSurface(&bndsShadowInput, m_ulLockTimeOut,
                                          DXLOCKF_READ, 
                                          __uuidof(IDXARGBReadPtr), 
                                          (void **)&spDXARGBReadPtr, NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        // Check input pixels

        for (i = 0; i < nInputPixelsToCheck; i++)
        {
            // Check pixel

            spDXARGBReadPtr->MoveToXY(pt.x, pt.y);

            spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

            if (   (sample.Alpha != 0)
                && (nAlpha < sample.Alpha))
            {
                nAlpha = sample.Alpha - nAlphaStep;
            }
            else
            {
                nAlpha -= nAlphaStep;
            }

            // Move point.

            pt.x += g_Direction[m_lDirection].cx;
            pt.y += g_Direction[m_lDirection].cy;
        }

        spDXARGBReadPtr.Release();
    }

    // See if an input pixel directly is being displayed by this output pixel.

    if (!bndsActualInput.BoundsAreEmpty())
    {
        // An input pixel does correlate to this output point.  Check to see if
        // its alpha value is greater than the the alpha value of the shadow
        // pixel that would like to be rendered at this point.  The one with the
        // greater alpha value will be rendered.

        hr = InputSurface(0)->LockSurface(&bndsActualInput, m_ulLockTimeOut,
                                          DXLOCKF_READ,
                                          __uuidof(IDXARGBReadPtr), 
                                          (void **)&spDXARGBReadPtr, NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

        if (   (sample.Alpha != 0)
            && (sample.Alpha > nAlpha))
        {
            // An input pixel will be drawn to this output pixel.  Set the 
            // input point to return and we're done.

            bndsActualInput.GetMinVector(InVec);

            hr = S_OK;

            goto done;
        }
    }
    else if (nInputPixelsToCheck < m_lStrength)
    {
        // If the hit pixel is in the shadow only part of the output, make sure
        // the alpha value of the shadow hass been decreased adequately.

        nAlpha -= (nAlphaStep * (m_lStrength - nInputPixelsToCheck));
    }

    // At this point it's certain that no input surface point was hit.
    
    // If nAlpha is positive it means that a shadow was hit so this method
    // should return DXT_S_HITOUTPUT.  Otherwise return S_FALSE since no point
    // was hit.

    if (nAlpha > 0)
    {
        hr = DXT_S_HITOUTPUT;
    }
    else
    {
        hr = S_FALSE;
    }

done:

    if (IsTagEnabled(tagFilterShadow))
    {
        TraceTag((tagFilterShadow, 
                  "Output was hit at point x:%lu, y:%lu", 
                  OutPoint[DXB_X].Min, OutPoint[DXB_Y].Min));

        if (S_OK == hr)
        {
            TraceTag((tagFilterShadow, 
                      "Input was hit at point x:%lu, y:%lu", 
                      InVec[DXB_X], InVec[DXB_Y]));
        }
        else if (DXT_S_HITOUTPUT == hr)
        {
            TraceTag((tagFilterShadow,
                      "No input point hit, but the shadow area of the output"
                      " was hit."));
        }
        else if (S_FALSE == hr)
        {
            TraceTag((tagFilterShadow,
                      "No input point hit."));
        }
    }

    RRETURN2(hr, DXT_S_HITOUTPUT, S_FALSE);
}
//  CShadow::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CShadow::DetermineBnds, CDXBaseNTo1
//
//  This overrides the base function so as to map to an output surface larger
//  than the input surface.
//
//------------------------------------------------------------------------------
HRESULT 
CShadow::DetermineBnds(CDXDBnds & Bnds)
{
    SIZE size;

    Bnds.GetXYSize(size);

    // enlarge the surface by m_lStrength along the shadow direction
    if (g_Direction[m_lDirection].cx != 0)
    {
        size.cx += m_lStrength;
    }

    if (g_Direction[m_lDirection].cy != 0)
    {
        size.cy += m_lStrength;
    }

    Bnds.SetXYSize(size);
    return S_OK;
} /* CShadow::DetermineBnds */


//+-----------------------------------------------------------------------------
//
//  CShadow::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CShadow::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing)
{
    HRESULT         hr      = S_OK;
    unsigned int    y       = 0;

    DXSAMPLE *      pOperationBuffer    = NULL;
    DXSAMPLE *      pRowInBuffer        = NULL;
    DXPMSAMPLE *    pOutBuff            = NULL;
    DXPMSAMPLE *    pPMBuff             = NULL;

    SIZE            sizeOperationBuffer = {0, 0};

    CComPtr<IDXARGBReadWritePtr>    pDest;
    CComPtr<IDXARGBReadPtr>         pSrc;

    DXDITHERDESC dxdd;

    const unsigned int nDoWidth     = WI.DoBnds.Width();
    const unsigned int nDoHeight    = WI.DoBnds.Height();

    const int nXExpansion   = g_Direction[m_lDirection].cx != 0 ? m_lStrength : 0;
    const int nYExpansion   = g_Direction[m_lDirection].cy != 0 ? m_lStrength : 0;
    const int nOffsetX      = g_Direction[m_lDirection].cx < 0  ? m_lStrength : 0;
    const int nOffsetY      = g_Direction[m_lDirection].cy < 0  ? m_lStrength : 0;

    // Calculate operation buffer size.

    sizeOperationBuffer.cx = m_bndsInput.Width()  + nXExpansion;
    sizeOperationBuffer.cy = m_bndsInput.Height() + nYExpansion;

    // Lock output surface.

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE, 
                                      IID_IDXARGBReadWritePtr, 
                                      (void**)&pDest, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    // Lock entire input surface.

    hr = InputSurface()->LockSurface(NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    if (DoOver() && OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(nDoWidth);
    }

    //
    //  Set up the dither structure
    //
    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = NULL;                     // to be filled
        dxdd.cSamples       = nDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    // The output buffer is a copy of input surface with an offset

    // TODO:    It's crazy to buffer the entire surface, stop it.

    pOperationBuffer = new DXSAMPLE[sizeOperationBuffer.cx
                                    * sizeOperationBuffer.cy];

    if (!pOperationBuffer) 
    {
        return E_OUTOFMEMORY;
    }

    memset(pOperationBuffer, 0, 
           sizeOperationBuffer.cx * sizeOperationBuffer.cy * sizeof(DXSAMPLE));

    // skip OffsetY rows, as well as OffsetX pixels on the current row

    pRowInBuffer = &pOperationBuffer[
                                (sizeOperationBuffer.cx * nOffsetY) // Row
                                + nOffsetX                          // + Column
                                ];

    for (y = 0; y < m_bndsInput.Height(); y++)
    {
        pSrc->MoveToRow(y);
        pSrc->Unpack(pRowInBuffer, m_bndsInput.Width(), FALSE);

        pRowInBuffer += sizeOperationBuffer.cx;
    }

    // create shadow effect in the buffer

    _PropagateShadow(pOperationBuffer, sizeOperationBuffer.cx, 
                     sizeOperationBuffer.cy);

    // copy the result to output surface

    pRowInBuffer = &pOperationBuffer[
                        (sizeOperationBuffer.cx * WI.DoBnds.Top())  // Row
                        + WI.DoBnds.Left()                          // + Column
                        ];

    for (y = 0; y < nDoHeight; y++)
    {
        // Move to the appropriate row of the output surface.

        pDest->MoveToRow(y);

        if (DoDither())
        {
            dxdd.pSamples = pRowInBuffer;
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            pPMBuff = DXPreMultArray(pRowInBuffer, nDoWidth);
            pDest->OverArrayAndMove(pOutBuff, pPMBuff, nDoWidth);
        }
        else
        {
            pDest->PackAndMove(pRowInBuffer, nDoWidth);
        }

        pRowInBuffer += sizeOperationBuffer.cx;
    }

    delete [] pOperationBuffer;

    return hr;
}
//  CShadow::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CShadow::MapBoundsOut2In, IDXTransform
//
//  Overview:
//      To implement this function, we convert all coordinates to what they 
//      would be if the x shadow and y shadow were both cast in the positive
//      direction (to the right or down.)  Then we find the required bounds.
//      Then, after finding the smallest bounds required, we mirror them back
//      if we've converted the x or y coordinates.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CShadow::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                         ULONG ulInIndex, DXBNDS * pInBounds)
{
    bool        fDiagonal   =    g_Direction[m_lDirection].cx 
                              && g_Direction[m_lDirection].cy;

    CDXDBnds    bndsMirroredOutputRequired(*pOutBounds);
    
    if (ulOutIndex || ulInIndex)
    {
        return E_INVALIDARG;
    }

    if (!pOutBounds || !pInBounds)
    {
        return E_POINTER;
    }

    if (NULL == InputSurface())
    {
        return E_UNEXPECTED;
    }

    // Mirror coordinates as if shadow is being cast down and/or to the right.

    if (g_Direction[m_lDirection].cx < 0)
    {
        long n = bndsMirroredOutputRequired[DXB_X].Min;

        bndsMirroredOutputRequired[DXB_X].Min = (m_bndsInput.Width() + m_lStrength) 
                                                - bndsMirroredOutputRequired[DXB_X].Max;
        bndsMirroredOutputRequired[DXB_X].Max = (m_bndsInput.Width() + m_lStrength) - n;
    }

    if (g_Direction[m_lDirection].cy < 0)
    {
        long n = bndsMirroredOutputRequired[DXB_Y].Min;

        bndsMirroredOutputRequired[DXB_Y].Min = (m_bndsInput.Height() + m_lStrength) 
                                                - bndsMirroredOutputRequired[DXB_Y].Max;
        bndsMirroredOutputRequired[DXB_Y].Max = (m_bndsInput.Height() + m_lStrength) - n;
    }

    // Find minimum required input bounds needed to produce output bounds.

    *pInBounds = bndsMirroredOutputRequired;

    // Find the miniumum x input bound required if there is a shadow to the left
    // or right.

    if (g_Direction[m_lDirection].cx)
    {
        // If the shadow is diagonal, we may be able to minimize the bounds even
        // further.

        if (   fDiagonal
            && (bndsMirroredOutputRequired[DXB_Y].Max <= m_lStrength))
        {
            pInBounds->u.D[DXB_X].Min -= (bndsMirroredOutputRequired[DXB_Y].Max - 1);
        }
        else
        {
            pInBounds->u.D[DXB_X].Min -= m_lStrength;
        }
    }

    if (g_Direction[m_lDirection].cy)
    {
        // If the shadow is diagonal, we may be able to minimize the bounds even
        // further.

        if (   fDiagonal
            && (bndsMirroredOutputRequired[DXB_X].Max <= m_lStrength))
        {
            pInBounds->u.D[DXB_Y].Min -= (bndsMirroredOutputRequired[DXB_X].Max - 1);
        }
        else
        {
            pInBounds->u.D[DXB_Y].Min -= m_lStrength;
        }
    }

    // This part is tricky, if one of the minimum output bounds is outside the
    // input area and the shadow is diagonal, we can reduce the required input 
    // bounds even further.

    if (fDiagonal)
    {
        int nXDist = bndsMirroredOutputRequired[DXB_X].Min - m_bndsInput.Width();

        int nYDist = bndsMirroredOutputRequired[DXB_Y].Min - m_bndsInput.Height();

        if (   (nXDist > 0) 
            || (nYDist > 0))
        {
            if (nXDist > nYDist)
            {
                pInBounds->u.D[DXB_Y].Max -= nXDist;
            }
            else
            {
                pInBounds->u.D[DXB_X].Max -= nYDist;
            }
        }
    }

    // Clip bounds to input surface bounds.

    ((CDXDBnds *)pInBounds)->IntersectBounds(m_bndsInput);

    // Mirror required input coordinates if we mirrored the required output
    // coordinates.

    if (g_Direction[m_lDirection].cx < 0)
    {
        long n = pInBounds->u.D[DXB_X].Min;

        pInBounds->u.D[DXB_X].Min = m_bndsInput.Width() 
                                    - pInBounds->u.D[DXB_X].Max;
        pInBounds->u.D[DXB_X].Max = m_bndsInput.Width() - n;
    }

    if (g_Direction[m_lDirection].cy < 0)
    {
        long n = pInBounds->u.D[DXB_Y].Min;

        pInBounds->u.D[DXB_Y].Min = m_bndsInput.Height() 
                                    - pInBounds->u.D[DXB_Y].Max;
        pInBounds->u.D[DXB_Y].Max = m_bndsInput.Height() - n;
    }

    return S_OK;
}
//  CShadow::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  CShadow::GetClipOrigin, IDXTClipOrigin
//
//------------------------------------------------------------------------------
STDMETHODIMP
CShadow::GetClipOrigin(DXVEC * pvecClipOrigin)
{
    if (NULL == pvecClipOrigin)
    {
        return E_POINTER;
    }

    if (g_Direction[m_lDirection].cx < 0)
    {
        pvecClipOrigin->u.D[DXB_X] = m_lStrength;
    }
    else
    {
        pvecClipOrigin->u.D[DXB_X] = 0;
    }

    if (g_Direction[m_lDirection].cy < 0)
    {
        pvecClipOrigin->u.D[DXB_Y] = m_lStrength;
    }
    else
    {
        pvecClipOrigin->u.D[DXB_Y] = 0;
    }

    return S_OK;
}
//  CShadow::GetClipOrigin, IDXTClipOrigin


//+-----------------------------------------------------------------------------
//
//  CShadow::_GetActualInputBndsFromOutputBnds
//
//  Overview:   This takes a set of output bounds and gives the input surface
//              bounds needed to generate the actual input (non-shadow) portion
//              for that are of the output.
//
//  Returns:    
//      S_FALSE If no input bounds are needed to generate the actual input 
//              (non-shadow) portion for that area of the output.
//
//------------------------------------------------------------------------------
STDMETHODIMP
CShadow::_GetActualInputBndsFromOutputBnds(const CDXDBnds & bndsOutput,
                                           CDXDBnds & bndsActualInput)
{
    CDXDVec     vecActualInputOffset;

    if (g_Direction[m_lDirection].cx < 0)
    {
        vecActualInputOffset[DXB_X] -= m_lStrength;
    }

    if (g_Direction[m_lDirection].cy < 0)
    {
        vecActualInputOffset[DXB_Y] -= m_lStrength;
    }

    bndsActualInput = bndsOutput;

    bndsActualInput.Offset(vecActualInputOffset);
    bndsActualInput.IntersectBounds(m_bndsInput);

    if (bndsActualInput.BoundsAreEmpty())
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}
//  CShadow::_GetActualInputBndsFromOutputBnds


//+-----------------------------------------------------------------------------
//
//  CShadow::_PropagateShadow
//
//  Overview:
//
//      Propagate the Alpha value of the opague pixels to transparent pixels
//      along the shadow direction, to create a shadow effect.
//
//  Parameters:
//
//      pOperationBuffer    An array of DXSAMPLES that is the size of the output
//                          surface of this DXTransform.  When this function is
//                          called the pixels of the input surface will have
//                          been unpacked into the appropriate place in this
//                          array.
//      nWidth              Size of the width of the array and the final output
//                          of this DXTransform.
//      nHeight             Size of the height of the array and the final output
//                          of this DXTransform.
//
//------------------------------------------------------------------------------
void 
CShadow::_PropagateShadow(DXSAMPLE *pOperationBuffer, int nWidth, int nHeight)
{
    int     iCol    = 0;
    int     iRow    = 0;
    int     iAlpha  = 0;

    DXSAMPLE * pBufRow = NULL;
    DXSAMPLE * pBufPix = NULL;

    // Scan the image either in forward direction (top-down, left-right) or 
    // backward direction (bottom-up, right to left), depending on the shadow 
    // direction. The idea is to scan a source pixel before a shadow pixel.
    // Add shadow effect to the current pixel if a neighbour along the revers 
    // shadow direction has sufficiently larger alpha value than the alpha of 
    // the current pixel. Every generation of propagation decreases the alpha 
    // value by iAlphaStep = 255/(m_lStrength+1). Thus there is a maximum of 
    // m_lStrength steps to propapage a solid color to transparent ones.

    int iAlphaStep  = 255 / (m_lStrength + 1);
    int offset      = (g_Direction[m_lDirection].cy * nWidth) 
                      + g_Direction[m_lDirection].cx;
    
    if (offset > 0)
    {
        // For directions 2, 3, 4, and 5 scan forward.

        // Initialize pBufRow to point to the second row of the operation
        // buffer.

        pBufRow = pOperationBuffer + nWidth;

        // Loop to the last row.

        for (iRow = 1; iRow < nHeight; iRow++, pBufRow += nWidth)
        {
            // Initialize pBufPix to point to the second pixel in this row.

            pBufPix = pBufRow + 1;

            // Loop to the last pixel.

            for (iCol = 1; iCol < nWidth; iCol++, pBufPix++)
            {
                iAlpha = (pBufPix-offset)->Alpha - iAlphaStep;

                if (iAlpha > 0 && pBufPix->Alpha < iAlpha)
                {
                    // [2000/12/27 mcakins]
                    // This is a less than perfect solution because the pixel
                    // pointed to by pBufPix should be blended over the top of
                    // the shadow.

                    // Add shadow effect: change to shadow color.
                    // The alpha value is gradually decreasing.

                    *pBufPix        = m_rgbColor;
                    pBufPix->Alpha  = (BYTE)iAlpha;
                }
            }
        }
    }
    else // (offset < 0)
    {
        // For directions 0, 1, 6, and 7 scan backward.

        // Initialize pBufRow to point to the second to the last row of the
        // operation buffer.

        pBufRow = pOperationBuffer + (nWidth * (nHeight - 2));

        // Loop back to the first row.

        for (iRow = nHeight - 2; iRow >= 0; iRow--, pBufRow -= nWidth)
        {
            // Initialize pBufPix to point to the second to the last pixel in 
            // this row.

            pBufPix = pBufRow + nWidth - 2;

            // Loop back to the first pixel.

            for (iCol = nWidth-2; iCol >= 0; iCol--, pBufPix--)
            {
                iAlpha = (pBufPix-offset)->Alpha - iAlphaStep;

                if (iAlpha > 0 && pBufPix->Alpha < iAlpha)
                {
                    // [2000/12/27 mcakins]
                    // This is a less than perfect solution because the pixel
                    // pointed to by pBufPix should be blended over the top of
                    // the shadow.

                    // Add shadow effect: change to shadow color.
                    // The alpha value is gradually decreasing.

                    *pBufPix        = m_rgbColor;
                    pBufPix->Alpha  = (BYTE)iAlpha;
                }
            }
        }
    }
}
//  CShadow::_PropagateShadow


//+-----------------------------------------------------------------------------
//
//  CShadow::_IsOutputPointInEmptyCorner
//
//  Overview:
//
//      If the shadow is diagonal, there will be two empty corners on the output
//      surface.  This method checks to see if an output point is on one of 
//      those empty corners.
//
//      Points on the lines used to define the corners for this method are NOT 
//      considered to be in the corners.
//
//  Notes:
//
//      Remember that down in the sense of a bitmap's coordinate system means
//      up on the screen when viewing these equations.  Therefore I when I use
//      the word "below" it means "above" when looking at the screen.
// 
//------------------------------------------------------------------------------
BOOL
CShadow::_IsOutputPointInEmptyCorner(const CDXDBnds & OutPoint)
{
    Assert(!OutPoint.BoundsAreEmpty());
    Assert(g_Direction[m_lDirection].cx != 0);
    Assert(g_Direction[m_lDirection].cy != 0);

    const int   x           = OutPoint[DXB_X].Min;
    const int   y           = OutPoint[DXB_Y].Min;
    int         yIntercept  = 0;

    if (g_Direction[m_lDirection].cx == g_Direction[m_lDirection].cy)
    {
        // Empty corners are top-right and bottom-left.
        //
        // In this case the slope of the lines is 1 so we use the following
        // general equation for both lines:
        //
        // y = x + b

        // Top-right corner.
        //
        // The y intercept for the line that defines this corner is:
        //
        //  - (m_bndsInput.Width() - 1)

        yIntercept = - ((int)m_bndsInput.Width() - 1);

        // y = x + yIntercept
        //
        // The definition of all points below this line is:
        //
        // y < x + yIntercept
        //
        // Solve for x:
        //
        // x > y - yIntercept

        if (x > (y - yIntercept))
        {
            return TRUE;
        }

        // Bottom-left corner.
        //
        // The y intercept for the line that defines this corner is:
        //
        // m_bndsInput.Height() - 1

        yIntercept = m_bndsInput.Height() - 1;

        // y = x + yIntercept
        // 
        // The definition of all points above this line is:
        //
        // y > x + yIntercept
        //
        // Solve for x:
        //
        // x < y - yIntercept

        if (x < (y - yIntercept))
        {
            return TRUE;
        }
    }
    else
    {
        // Empty corners are top-left and bottom-right.
        //
        // In this case the slope of the lines is -1 so we use the following
        // general equation for both lines:
        //
        // y = -x + b


        // Top-left corner.
        //
        // The y intercept for the line that defines this corner is m_lStrength.
        
        yIntercept = m_lStrength;

        // y = -x + yIntercept
        // 
        // The definition of all points below this line is:
        //
        // y < -x + yIntercept
        //
        // Rearrange:
        //
        // -x > y - yIntercept
        //
        // Multiply by -1:
        //
        // x < yIntercept - y

        if (x < (yIntercept - y))
        {
            return TRUE;
        }

        // Bottom-right corner.
        //
        // The y intercept for the line that defines this corner is:
        //
        //              m_lStrength 
        //  +  m_bndsInput.Height() 
        //  +   m_bndsInput.Width()
        //  -                     2

        yIntercept = m_lStrength + m_bndsInput.Height() + m_bndsInput.Width() 
                     - 2;

        // y = -x + yIntercept
        //
        // The definition of all points above this line is:
        //
        // y > -x + yIntercept
        //
        // Rearrange:
        //
        // -x < y - yIntercept
        //
        // Multiply by -1:
        // 
        // x > yIntercept - y

        if (x > (yIntercept - y))
        {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\revealtrans.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       revealtrans.cpp
//
//  Overview:       The RevealTrans transform simply wraps other transforms to 
//                  ensure backward compatibility for the revealtrans filter.
//
//  Change History:
//  1999/09/18  a-matcal    Created.
//  1999/10/06  a-matcal    Fix bug where setup was saving the input and ouput
//                          surface pointers, but not saving the number of 
//                          inputs and outputs.
//  2000/01/16  mcalkins    Change Box in/out to use "rectangle" setting instead
//                          of "square".
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "revealtrans.h"
#include "time.h"

#define SafeRelease(pointer) if (pointer) { pointer->Release(); } pointer = NULL

static const CLSID * g_apclsidTransition[] = {
    &CLSID_DXTIris,             //  0 Box in
    &CLSID_DXTIris,             //  1 Box out
    &CLSID_DXTIris,             //  2 Circle in
    &CLSID_DXTIris,             //  3 Circle out
    &CLSID_DXTGradientWipe,     //  4 Wipe up
    &CLSID_DXTGradientWipe,     //  5 Wipe down
    &CLSID_DXTGradientWipe,     //  6 Wipe right
    &CLSID_DXTGradientWipe,     //  7 Wipe left
    &CLSID_DXTBlinds,           //  8 Vertical blinds
    &CLSID_DXTBlinds,           //  9 Horizontal blinds
    &CLSID_DXTCheckerBoard,     // 10 Checkerboard across
    &CLSID_DXTCheckerBoard,     // 11 Checkerboard down
    &CLSID_DXTRandomDissolve,   // 12 Random dissolve
    &CLSID_DXTBarn,             // 13 Split vertical in
    &CLSID_DXTBarn,             // 14 Split vertical out
    &CLSID_DXTBarn,             // 15 Split horizontal in
    &CLSID_DXTBarn,             // 16 Split horizontal out
    &CLSID_DXTStrips,           // 17 Strips left down
    &CLSID_DXTStrips,           // 18 Strips left up
    &CLSID_DXTStrips,           // 19 Strips right down
    &CLSID_DXTStrips,           // 20 Strips right up
    &CLSID_DXTRandomBars,       // 21 Random bars horizontal
    &CLSID_DXTRandomBars,       // 22 Random bars vertical
    &CLSID_NULL                 // 23 Random
};

static const int g_cTransitions = sizeof(g_apclsidTransition) / 
                                  sizeof(g_apclsidTransition[0]);




//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans
//
//------------------------------------------------------------------------------
CDXTRevealTrans::CDXTRevealTrans() :
    m_nTransition(23),
    m_cInputs(0),
    m_cOutputs(0),
    m_flProgress(0.0F),
    m_flDuration(1.0F)
{
    m_apunkInputs[0]   = NULL;
    m_apunkInputs[1]   = NULL;
    m_apunkOutputs[0]  = NULL;

    srand((unsigned int)time(NULL));
}
//  Method: CDXTRevealTrans


//+-----------------------------------------------------------------------------
//
//  Method: ~CDXTRevealTrans
//
//------------------------------------------------------------------------------
CDXTRevealTrans::~CDXTRevealTrans()
{
    _FreeSurfacePointers();
}
//  Method: ~CDXTRevealTrans


//+-----------------------------------------------------------------------------
//
//  Method: _FreeSurfacePointers
//
//------------------------------------------------------------------------------
void
CDXTRevealTrans::_FreeSurfacePointers()
{
    SafeRelease(m_apunkInputs[0]);
    SafeRelease(m_apunkInputs[1]);
    SafeRelease(m_apunkOutputs[0]);
}
//  Method: _FreeSurfacePointers


//+-----------------------------------------------------------------------------
//
//  Method: FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT
CDXTRevealTrans::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  Method: FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::Execute, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::Execute(const GUID * pRequestID, const DXBNDS * pPortionBnds,
                         const DXVEC * pPlacement)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->Execute(pRequestID, pPortionBnds, pPlacement);
}
//  Method: CDXTRevealTrans::Execute, IDXTransform



//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::GetInOutInfo, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::GetInOutInfo(BOOL bIsOutput, ULONG ulIndex, DWORD * pdwFlags,
                              GUID * pIDs, ULONG * pcIDs, 
                              IUnknown ** ppUnkCurrentObject)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->GetInOutInfo(bIsOutput, ulIndex, pdwFlags, pIDs, 
                                         pcIDs, ppUnkCurrentObject);
}
//  Method: CDXTRevealTrans::GetInOutInfo, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::GetMiscFlags, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::GetMiscFlags(DWORD * pdwMiscFlags)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->GetMiscFlags(pdwMiscFlags);
}
//  Method: CDXTRevealTrans::GetMiscFlags, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::GetQuality, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::GetQuality(float * pfQuality)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->GetQuality(pfQuality);
}
//  Method: CDXTRevealTrans::GetQuality, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::MapBoundsIn2Out, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::MapBoundsIn2Out(const DXBNDS * pInBounds, ULONG ulNumInBnds,
                                 ULONG ulOutIndex, DXBNDS * pOutBounds)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->MapBoundsIn2Out(pInBounds, ulNumInBnds, ulOutIndex,
                                            pOutBounds);
}
//  Method: CDXTRevealTrans::MapBoundsIn2Out, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::MapBoundsOut2In, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                                 ULONG ulInIndex, DXBNDS * pInBounds)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->MapBoundsOut2In(ulOutIndex, pOutBounds, ulInIndex,
                                            pInBounds);
}
//  Method: CDXTRevealTrans::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::SetMiscFlags, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::SetMiscFlags(DWORD dwMiscFlags)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->SetMiscFlags(dwMiscFlags);
}
//  Method: CDXTRevealTrans::SetMiscFlags, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::SetQuality, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::SetQuality(float fQuality)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->SetQuality(fQuality);
}
//  Method: CDXTRevealTrans::SetQuality, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::Setup, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::Setup(IUnknown * const * punkInputs, ULONG ulNumInputs,
	               IUnknown * const * punkOutputs, ULONG ulNumOutputs,	
                       DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (!m_spDXTransform)
    {
        hr = DXTERR_UNINITIALIZED;

        goto done;
    }

    hr = m_spDXTransform->Setup(punkInputs, ulNumInputs, punkOutputs, 
                                ulNumOutputs, dwFlags);

    if (FAILED(hr))
    {
        goto done;
    }

    _ASSERT(2 == ulNumInputs);
    _ASSERT(1 == ulNumOutputs);

    _FreeSurfacePointers();

    m_apunkInputs[0]   = punkInputs[0];
    m_apunkInputs[1]   = punkInputs[1];
    m_apunkOutputs[0]  = punkOutputs[0];

    m_apunkInputs[0]->AddRef();
    m_apunkInputs[1]->AddRef();
    m_apunkOutputs[0]->AddRef();

    m_cInputs   = ulNumInputs;
    m_cOutputs  = ulNumOutputs;
    
done:

    return hr;
}
//  Method: CDXTRevealTrans::Setup, IDXTransform


//+-----------------------------------------------------------------------------
//
//  Method: get_Transition, IDXTRevealTrans
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::get_Transition(int * pnTransition)
{
    HRESULT hr = S_OK;

    if (NULL == pnTransition)
    {
        hr = E_POINTER;

        goto done;
    }

    *pnTransition = m_nTransition;

done:

    return hr;
}
//  Method: get_Transition, IDXTRevealTrans


//+-----------------------------------------------------------------------------
//
//  Method: put_Transition, IDXTRevealTrans
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::put_Transition(int nTransition)
{
    HRESULT hr      = S_OK;
    int     nIndex  = 0;
    
    CComPtr<IDXTransform>   spDXTransform;
    CComPtr<IDXEffect>      spDXEffect;
    CComPtr<IDXSurfacePick> spDXSurfacePick;

    // This is not the usual parameter checking we would do in a transform, but
    // to old filter code behaves this way so we do it for compatibility.

    if (nTransition < 0)
    {
        nTransition = 0;
    }
    else if (nTransition >= g_cTransitions)
    {
        nTransition = g_cTransitions - 1;
    }

    if (23 == nTransition)
    {
        // Choose random transition excluding 23.

        nIndex = rand() % (g_cTransitions - 1);
    }
    else
    {
        nIndex = nTransition;
    }

    // nIndex can't be 23 at this point, so sometimes m_nTransition will be set
    // to 23 outside of this function to make sure that the DXTransform is 
    // recreated when needed, for instance, when the DXTransformFactory changes.

    if ((nIndex == m_nTransition) && !!m_spDXTransform)
    {
        // We already have this transition, no need to re-create.

        goto done;
    }

    hr = m_spDXTransformFactory->CreateTransform(m_apunkInputs, m_cInputs,
                                                 m_apunkOutputs, m_cOutputs,
                                                 NULL, NULL,
                                                 *g_apclsidTransition[nIndex],
                                                 __uuidof(IDXTransform),
                                                 (void **)&spDXTransform);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = _InitializeNewTransform(nIndex, spDXTransform);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDXTransform->QueryInterface(__uuidof(IDXEffect), 
                                       (void **)&spDXEffect);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDXEffect->put_Progress(m_flProgress);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDXEffect->put_Duration(m_flDuration);

    if (FAILED(hr))
    {
        goto done;
    }

    // Although filters in general are not required to support the 
    // IDXSurfacePick interface, all of the filters represented by revealtrans
    // are.

    hr = spDXTransform->QueryInterface(__uuidof(IDXSurfacePick),
                                       (void **)&spDXSurfacePick);

    if (FAILED(hr))
    {
        goto done;
    }

    m_spDXTransform.Release();
    m_spDXTransform = spDXTransform;

    m_spDXEffect.Release();
    m_spDXEffect = spDXEffect;

    m_spDXSurfacePick.Release();
    m_spDXSurfacePick = spDXSurfacePick;

    m_nTransition = nTransition;

done:

    return hr;
}
//  Method: put_Transition, IDXTRevealTrans


//+-----------------------------------------------------------------------------
//
//  Method: CDXTRevealTrans::_InitializeNewTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::_InitializeNewTransform(int nTransition, 
                                         IDXTransform * pDXTransform)
{
    HRESULT hr  = S_OK;

    DISPID      dispid          = DISPID_PROPERTYPUT;
    VARIANT     avarArg[3];   
    DISPID      adispid[3]      = {0, 0, 0};
    DISPPARAMS  aDispParams[3]  = {{&avarArg[0], &dispid, 1, 1}, 
                                   {&avarArg[1], &dispid, 1, 1},
                                   {&avarArg[2], &dispid, 1, 1}};

    CComPtr<IDispatch> spDispatch;

    _ASSERT(nTransition < g_cTransitions);

    VariantInit(&avarArg[0]);
    VariantInit(&avarArg[1]);
    VariantInit(&avarArg[2]);

    // Get dispatch interface.

    hr = pDXTransform->QueryInterface(__uuidof(IDispatch), 
                                      (void **)&spDispatch);

    if (FAILED(hr))
    {
        goto done;
    }

    // Setup.

    switch(nTransition)
    {
    case  0:    //  0 Box in
    case  1:    //  1 Box out
        
        // Iris style.

        adispid[0]          = DISPID_CRIRIS_IRISSTYLE;
        avarArg[0].vt       = VT_BSTR;
        avarArg[0].bstrVal  = SysAllocString(L"rectangle");

        if (NULL == avarArg[0].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        // Reverse

        adispid[1]          = DISPID_CRIRIS_MOTION;
        avarArg[1].vt       = VT_BSTR;

        avarArg[1].bstrVal  = SysAllocString((0 == nTransition) ? 
                                             L"in" : L"out");

        if (NULL == avarArg[1].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case  2:    //  2 Circle in
    case  3:    //  3 Circle out

        adispid[0]          = DISPID_CRIRIS_IRISSTYLE;
        avarArg[0].vt       = VT_BSTR;
        avarArg[0].bstrVal  = SysAllocString(L"circle");

        if (NULL == avarArg[0].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        // Reverse

        adispid[1]          = DISPID_CRIRIS_MOTION;
        avarArg[1].vt       = VT_BSTR;
        avarArg[1].bstrVal  = SysAllocString((2 == nTransition) ? 
                                             L"in" : L"out");

        if (NULL == avarArg[1].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case  4:    //  4 Wipe up
    case  5:    //  5 Wipe down
    case  6:    //  6 Wipe right
    case  7:    //  7 Wipe left

        // Gradient size.

        adispid[0]          = DISPID_DXW_GradientSize;
        avarArg[0].vt       = VT_R4;
        avarArg[0].fltVal   = 0.0F;

        // Wipe style.

        adispid[1]          = DISPID_DXW_WipeStyle;
        avarArg[1].vt       = VT_I4;

        if ((4 == nTransition) || (5 == nTransition))
        {
            avarArg[1].lVal     = DXWD_VERTICAL;
        }
        else
        {
            avarArg[1].lVal     = DXWD_HORIZONTAL;
        }

        // Reverse.

        adispid[2]          = DISPID_DXW_Motion;
        avarArg[2].vt       = VT_BSTR;

        if ((4 == nTransition) || (7 == nTransition))
        {
            avarArg[2].bstrVal  = SysAllocString(L"reverse");
        }
        else
        {
            avarArg[2].bstrVal  = SysAllocString(L"forward");
        }
            
        if (NULL == avarArg[2].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case  8:    //  8 Vertical blinds
    case  9:    //  9 Horizontal blinds

        // Bands.

        adispid[0]          = DISPID_CRBLINDS_BANDS;
        avarArg[0].vt       = VT_I4;
        avarArg[0].lVal     = 6;

        // Direction.

        adispid[1]          = DISPID_CRBLINDS_DIRECTION;
        avarArg[1].vt       = VT_BSTR;

        if (8 == nTransition)
        {
            avarArg[1].bstrVal = SysAllocString(L"right");
        }
        else
        {
            avarArg[1].bstrVal = SysAllocString(L"down");
        }

        if (NULL == avarArg[1].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case 10:    // 10 Checkerboard across
    case 11:    // 11 Checkerboard down

        // Direction.

        adispid[0]          = DISPID_DXTCHECKERBOARD_DIRECTION;
        avarArg[0].vt       = VT_BSTR;

        if (10 == nTransition)
        {
            avarArg[0].bstrVal = SysAllocString(L"right");
        }
        else
        {
            avarArg[0].bstrVal = SysAllocString(L"down");
        }

        if (NULL == avarArg[0].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case 12:    // 12 Random dissolve

        // No properties.

        break;

    case 13:    // 13 Split vertical in
    case 14:    // 14 Split vertical out
    case 15:    // 15 Split horizontal in
    case 16:    // 16 Split horizontal out

        // Doors opening?

        adispid[0]      = DISPID_CRBARN_MOTION;
        avarArg[0].vt   = VT_BSTR;

        if ((14 == nTransition) || (16 == nTransition))
        {
            avarArg[0].bstrVal = SysAllocString(L"out");
        }
        else
        {
            avarArg[0].bstrVal = SysAllocString(L"in");
        }

        if (NULL == avarArg[0].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        // Vertical doors?

        adispid[1]      = DISPID_CRBARN_ORIENTATION;
        avarArg[1].vt   = VT_BSTR;

        if ((13 == nTransition) || (14 == nTransition))
        {
            avarArg[1].bstrVal = SysAllocString(L"vertical");
        }
        else
        {
            avarArg[1].bstrVal = SysAllocString(L"horizontal");
        }

        if (NULL == avarArg[1].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case 17:    // 17 Strips left down
    case 18:    // 18 Strips left up
    case 19:    // 19 Strips right down
    case 20:    // 20 Strips right up

        // Movement.

        adispid[0]          = DISPID_DXTSTRIPS_MOTION;
        avarArg[0].vt       = VT_BSTR;

        if (17 == nTransition)
        {
            avarArg[0].bstrVal = SysAllocString(L"leftdown");
        }
        else if (18 == nTransition)
        {
            avarArg[0].bstrVal = SysAllocString(L"leftup");
        }
        else if (19 == nTransition)
        {
            avarArg[0].bstrVal = SysAllocString(L"rightdown");
        }
        else // 20 == nTransition
        {
            avarArg[0].bstrVal = SysAllocString(L"rightup");
        }

        if (NULL == avarArg[0].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    case 21:    // 21 Random bars horizontal
    case 22:    // 22 Random bars vertical

        // Vertical ?

        adispid[0]      = DISPID_DXTRANDOMBARS_ORIENTATION;
        avarArg[0].vt   = VT_BSTR;

        avarArg[0].bstrVal = SysAllocString((22 == nTransition) ? 
                                            L"vertical" : L"horizontal");

        if (NULL == avarArg[0].bstrVal)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }

        break;

    default:
        
        _ASSERT(false);
    }

    if (avarArg[0].vt != VT_EMPTY)
    {
        hr = spDispatch->Invoke(adispid[0], IID_NULL, LOCALE_USER_DEFAULT,
                                DISPATCH_PROPERTYPUT, &aDispParams[0], NULL,
                                NULL, NULL);
    }

    if (avarArg[1].vt != VT_EMPTY)
    {
        hr = spDispatch->Invoke(adispid[1], IID_NULL, LOCALE_USER_DEFAULT,
                                DISPATCH_PROPERTYPUT, &aDispParams[1], NULL,
                                NULL, NULL);
    }

    if (avarArg[2].vt != VT_EMPTY)
    {
        hr = spDispatch->Invoke(adispid[2], IID_NULL, LOCALE_USER_DEFAULT,
                                DISPATCH_PROPERTYPUT, &aDispParams[2], NULL,
                                NULL, NULL);
    }

done:

    VariantClear(&avarArg[0]);
    VariantClear(&avarArg[1]);
    VariantClear(&avarArg[2]);

    return hr;
}



//+-----------------------------------------------------------------------------
//
//  IDXEffect wrappers
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::get_Capabilities(long * plCapabilities)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXEffect->get_Capabilities(plCapabilities);
}

STDMETHODIMP
CDXTRevealTrans::get_Duration(float * pflDuration)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXEffect->get_Duration(pflDuration);
}

STDMETHODIMP
CDXTRevealTrans::put_Duration(float flDuration)
{
    HRESULT hr = S_OK;

    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    if (!!m_spDXEffect)
    {
        hr = m_spDXEffect->put_Duration(flDuration);
    }
    else if (flDuration <= 0.0F)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        m_flDuration = flDuration;
    }

    return hr;
}

STDMETHODIMP
CDXTRevealTrans::get_Progress(float * pflProgress)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXEffect->get_Progress(pflProgress);
}

STDMETHODIMP
CDXTRevealTrans::put_Progress(float flProgress)
{
    HRESULT hr = S_OK;

    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    if (!!m_spDXEffect)
    {
        hr = m_spDXEffect->put_Progress(flProgress);
    }
    else if ((flProgress < 0.0F) || (flProgress > 1.0F))
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        m_flProgress = flProgress;
    }

    return hr;
}

STDMETHODIMP
CDXTRevealTrans::get_StepResolution(float * pflStepResolution)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXEffect->get_StepResolution(pflStepResolution);
}
//  IDXEffect wrappers


//+-----------------------------------------------------------------------------
//
//  IDXSurfacePick wrappers
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::PointPick(const DXVEC * pvecOutputPoint, 
                           ULONG * pnInputSurfaceIndex,
                           DXVEC * pvecInputPoint)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    // All the DXTransforms hosted by revealtrans are required to support 
    // surface picking.

    _ASSERT(!!m_spDXSurfacePick);

    return m_spDXSurfacePick->PointPick(pvecOutputPoint, pnInputSurfaceIndex,
                                        pvecInputPoint);
}
//  IDXSurfacePick wrappers


//+-----------------------------------------------------------------------------
//
//  IDXBaseObject wrappers
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::GetGenerationId(ULONG * pnID)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->GetGenerationId(pnID);
}

STDMETHODIMP
CDXTRevealTrans::GetObjectSize(ULONG * pcbSize)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->GetObjectSize(pcbSize);
}

STDMETHODIMP
CDXTRevealTrans::IncrementGenerationId(BOOL fRefresh)
{
    if (!m_spDXTransform)
    {
        return DXTERR_UNINITIALIZED;
    }

    return m_spDXTransform->IncrementGenerationId(fRefresh);
}
//  IDXBaseObject wrappers


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTRevealTrans::SetSite, IObjectWithSite
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::SetSite(IUnknown * pUnkSite)
{
    m_spUnkSite = pUnkSite;

    if (pUnkSite)
    {
        HRESULT hr  = S_OK;

        CComPtr<IDXTransformFactory> spDXTransformFactory;

        hr = pUnkSite->QueryInterface(__uuidof(IDXTransformFactory),
                                      (void **)&spDXTransformFactory);

        if (SUCCEEDED(hr))
        {
            int nTransition         = m_nTransition;
            m_spDXTransformFactory  = spDXTransformFactory;

            // Setting m_nTransition to 23 makes sure put_Transition will
            // create a new DXTransform object.

            m_nTransition = 23;

            // Recreate transition with the new DXTransformFactory

            hr = put_Transition(nTransition);

            // put_Transition will set m_nTransition if it succeeds, but we need
            // to make sure it's set properly if it fails as well.

            m_nTransition = nTransition;
        }
    }

    return S_OK;
}
//  Method:  CDXTRevealTrans::SetSite, IObjectWithSite


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTRevealTrans::GetSite, IObjectWithSite
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTRevealTrans::GetSite(REFIID riid, void ** ppvSite)
{
    if (!m_spUnkSite)
    {
        return E_FAIL;
    }
    else
    {
        return m_spUnkSite->QueryInterface(riid, ppvSite);
    }
}
//  Method:  CDXTRevealTrans::GetSite, IObjectWithSite
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

// Since there are multiple directories that need to have stdafx.h, we put all
// the stuff in stdafx_common.h to have the actual code in only one place.

#include "stdafx_common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\slide.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:            slide.h
//
// Created:             06/24/98
//
// Author:              phillu
//
// Discription:         This is the header file for the CrSlide transformation
//
// Change History:
// 06/24/98 PhilLu      Developed 1.0 version for Chromeffects
// 11/04/98 PaulNash    Moved from DT 1.0 codebase to IE5/NT5 DXTMSFT.DLL
// 01/25/99 a-matcal    Fixed property map entries.
// 05/10/99 a-matcal    Optimization.
// 10/24/99 a-matcal    Changed CSlide class to CDXTSlideBase and created two
//                      new classes CDXTSlide and CDXTSlideOpt to represent  
//                      non-optimized and optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRSLIDE_H_
#define __CRSLIDE_H_

#include "resource.h"

#define MAX_BOUNDS 2

typedef enum CRSLIDESTYLE
{
    CRSS_HIDE,
    CRSS_PUSH,
    CRSS_SWAP,
} CRSLIDESTYLE;




class ATL_NO_VTABLE CDXTSlideBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrSlide, &IID_ICrSlide, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTSlideBase>,
    public IObjectSafetyImpl2<CDXTSlideBase>,
    public ISpecifyPropertyPagesImpl<CDXTSlideBase>
{
private:

    SIZE            m_sizeInput;
    short           m_cBands;	
    CRSLIDESTYLE    m_eSlideStyle;

    // m_lCurSlideDist  This member variable is basically m_Progress multiplied
    //                  by the input surface width.  It's calculated once in 
    //                  OnInitInstData and then used throughout the Bounds 
    //                  Calculation functions.  
    // m_lPrevSlideDist The value of m_lCurSlideDist that was calculated for the
    //                  previous execute.

    long            m_lCurSlideDist;
    long            m_lPrevSlideDist;

    long            m_alInputIndex[MAX_BOUNDS];

    // m_aptOffset      This member variable holds the input offset for each 
    //                  set of bounds generated by the Bounds Calculation
    //                  functions.  The bounds generated represent areas of
    //                  the output surface.  This offset is used to specify the 
    //                  point on the input surface that corresponds to the
    //                  top-left point of the bounds.

    POINT           m_aptOffset[MAX_BOUNDS];

    CDXDBnds        m_abndsDirty[MAX_BOUNDS];
    ULONG           m_cbndsDirty;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

private:

    // Functions to calculate optimized bounds when blending with output and
    // using only one band.

    HRESULT _CalcFullBoundsHide();
    HRESULT _CalcFullBoundsPush();
    HRESULT _CalcFullBoundsSwap();

    // Functions to calculate optimized bounds when blending is off and using
    // only one band.  (Push and Swap are not specially optimizable for this 
    // situation because every pixel on the output is changing.)

    HRESULT _CalcOptBoundsHide();

    // This function is used for surface picking and when using greater than
    // one band.

    void    _CalcBounds(long & offsetA, long & offsetB, long & widthA, 
                        long & widthB);

    // Functions to generate/update output surface.  _WorkProc_Optimized is 
    // used for the 1 band cases, and _WorkProc_Multiband is used for the 
    // cases where then number of bands is greater than 1.

    HRESULT _WorkProc_Optimized(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT _WorkProc_Multiband(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
  
public:

    CDXTSlideBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTSlideBase)
        COM_INTERFACE_ENTRY(ICrSlide)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTSlideBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTSlideBase)
        PROP_ENTRY("bands"            , 1, CLSID_CrSlidePP)
        PROP_ENTRY("slideStyle"       , 2, CLSID_CrSlidePP)
        PROP_PAGE(CLSID_CrSlidePP)
    END_PROPERTY_MAP()

    // CComObjecRootEx overrides

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides

    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WorkInfo, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WorkInfo);

    // ICrSlide methods

    STDMETHOD(get_slideStyle)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_slideStyle)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_bands)(/*[out, retval]*/ short *pVal);
    STDMETHOD(put_bands)(/*[in]*/ short newVal);

    // IDXEffect methods

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTSlide :
    public CDXTSlideBase,
    public CComCoClass<CDXTSlide, &CLSID_CrSlide>,
    public IPersistStorageImpl<CDXTSlide>,
    public IPersistPropertyBagImpl<CDXTSlide>
{
public:

    CDXTSlide()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTSLIDE)
    DECLARE_POLY_AGGREGATABLE(CDXTSlide)

    BEGIN_COM_MAP(CDXTSlide)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTSlideBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTSlideOpt :
    public CDXTSlideBase,
    public CComCoClass<CDXTSlideOpt, &CLSID_DXTSlide>,
    public IPersistStorageImpl<CDXTSlideOpt>,
    public IPersistPropertyBagImpl<CDXTSlideOpt>
{
public:

    CDXTSlideOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTSLIDEOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTSlideOpt)

    BEGIN_COM_MAP(CDXTSlideOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTSlideBase)
    END_COM_MAP()
};

#endif //__CRSLIDE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\shadow.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    shadow.h
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	header file for shadow transform implementation CGlow
//
// Change History:
//
// 05/20/99 PhilLu      Move code from dtcss to dxtmsft. New algorithm.
// 12/03/99 a-matcal    Added support for IDXTClipOrigin interface.
//
//------------------------------------------------------------------------------

#ifndef __SHADOW_H_
#define __SHADOW_H_

#include "resource.h"       // main symbols




class ATL_NO_VTABLE CShadow : 
    public CDXBaseNTo1,
    public CComCoClass<CShadow, &CLSID_DXTShadow>,
    public CComPropertySupport<CShadow>,
    public IDispatchImpl<IDXTShadow, &IID_IDXTShadow, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IPersistStorageImpl<CShadow>,
    public ISpecifyPropertyPagesImpl<CShadow>,
    public IPersistPropertyBagImpl<CShadow>,
    public IObjectSafetyImpl2<CShadow>,
    public IDXTClipOrigin
{
private:

    BSTR        m_bstrColor;
    DXSAMPLE    m_rgbColor;
    long        m_lStrength;
    long        m_lDirection;
    CDXDBnds    m_bndsInput;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    // Helpers 

    STDMETHOD(_GetActualInputBndsFromOutputBnds)(const CDXDBnds & bndsOutput,
                                                 CDXDBnds & bndsActualInput);

    void    _PropagateShadow(DXSAMPLE * pBuffer, int nWidth, int nHeight);
    BOOL    _IsOutputPointInEmptyCorner(const CDXDBnds & OutPoint);

public:

    CShadow();
    virtual ~CShadow();

    DECLARE_POLY_AGGREGATABLE(CShadow)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_SHADOW)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CShadow)
        COM_INTERFACE_ENTRY(IDXTShadow)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTClipOrigin)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CShadow>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CShadow)
        PROP_ENTRY("Color"    , 1, CLSID_DXTShadowPP)
        PROP_ENTRY("Direction", 2, CLSID_DXTShadowPP)
        PROP_ENTRY("Strength",  3, CLSID_DXTShadowPP)
        PROP_PAGE(CLSID_DXTShadowPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides

    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing);
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);
    HRESULT DetermineBnds(CDXDBnds & Bnds);

    // IDXTClipOrigin methods.

    STDMETHOD(GetClipOrigin)(DXVEC * pvecClipOrigin);

    // IDXTransform methods.

    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds, 
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTShadow methods

    STDMETHOD(get_Color)(/*[out, retval]*/ BSTR * pbstrColor);
    STDMETHOD(put_Color)(/*[in]*/ BSTR bstrColor);
    STDMETHOD(get_Strength)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_Strength)(/*[in]*/ long lStrength);
    STDMETHOD(get_Direction)(/*[out, retval]*/ long * pval);
    STDMETHOD(put_Direction)(/*[in]*/ long newVal);
};

#endif //__SHADOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\rwipe.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:                rwipe.cpp
//
// Created:                 06/22/98
//
// Author:                  PhilLu
//
// Discription:             This file implements the Raidal Wipe transform.
//
// History
//
// 06/22/98 phillu      initial creation
// 07/02/98 phillu      return E_INVALIDARG rather than an error string; check
//                      for E_POINTER
// 07/10/98 phillu      implement OnSetSurfacePickOrder().
// 07/23/98 phillu      implement clipping
// 05/09/99 a-matcal    Optimization.
// 05/19/99 a-matcal    Check for out of memory in get_ functions allocating
//                      BSTRs.
// 10/22/99 a-matcal    Changed CRadialWipe class to CDXTRadialWipeBase base 
//                      class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "rwipe.h"

#define DRAWRECT            0xFFFFFFFFL
#define MIN_PIXELS_PER_ROW  10

const double    gc_PI       = 3.14159265358979323846;
const int       MAXBOUNDS   = 10;



//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::CDXTRadialWipeBase
//
//------------------------------------------------------------------------------
CDXTRadialWipeBase::CDXTRadialWipeBase() :
    m_eWipeStyle(CRRWS_CLOCK),
    m_cbndsDirty(0),
    m_iCurQuadrant(1),
    m_iPrevQuadrant(1),
    m_fOptimizationPossible(false),
    m_fOptimize(false)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // CDXBaseNTo1 members

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}   
//  CDXTRadialWipeBase::CDXTRadialWipeBase


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::FinalConstruct
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTRadialWipeBase::FinalConstruct


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::OnSetup(DWORD dwFlags)
{
    HRESULT hr;

    CDXDBnds InBounds(InputSurface(0), hr);
    if (SUCCEEDED(hr))
    {
        InBounds.GetXYSize(m_sizeInput);
    }
    return hr;

} 
//  CDXTRadialWipeBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTRadialWipeBase::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, 
                                          ULONG & ulInToTest, ULONG aInIndex[], 
                                          BYTE aWeight[])
{
    long    pickX   = OutPoint.Left();
    long    pickY   = OutPoint.Top();
    long    XEdge   = 0;
    long    YEdge   = 0;        // intersection of ray with image boundary
    long    XBounds[MAXBOUNDS]; // to hold the X bounds of A/B image sections on 
                                // a scanline
    double  dAngle  = 0.0;

    // compute the intersection of a ray with the image boundary

    switch (m_eWipeStyle)
    {
        case CRRWS_CLOCK:
            dAngle = (2.0 * m_Progress - 0.5) * gc_PI;

            _IntersectRect(m_sizeInput.cx, m_sizeInput.cy, 
                           m_sizeInput.cx/2, m_sizeInput.cy/2,
                           cos(dAngle), sin(dAngle), XEdge, YEdge);

            break;

        case CRRWS_WEDGE:
            dAngle = (1.0 * m_Progress - 0.5) * gc_PI;

            _IntersectRect(m_sizeInput.cx, m_sizeInput.cy, 
                           m_sizeInput.cx/2, m_sizeInput.cy/2,
                           cos(dAngle), sin(dAngle), XEdge, YEdge);

            break;

        case CRRWS_RADIAL: // (wipe centered at the top-left corner)
            dAngle = (0.5 * m_Progress) * gc_PI;

            _IntersectRect(m_sizeInput.cx, m_sizeInput.cy, 0, 0, 
                           cos(dAngle), sin(dAngle), XEdge, YEdge);

            break;

        default:
            _ASSERT(0);

            break;

    }

    aInIndex[0] = 0;

    if ((pickX >= 0) && (pickX < m_sizeInput.cx) && (pickY >= 0) 
        && (pickY < m_sizeInput.cy))
    {
        long i = 0;

        _ScanlineIntervals(m_sizeInput.cx, m_sizeInput.cy, XEdge, YEdge, m_Progress,
                           pickY, XBounds);
    
        for (i = 0; XBounds[i] < pickX; i++)
        {
            aInIndex[0] = 1 - aInIndex[0];
        }
    }

    ulInToTest = 1;
    aWeight[0] = 255;
}
//  CDXTRadialWipeBase::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_IntersectRect
//
// A helper method that calculates the intersection of a ray with image boundary
// rectangle.
//
// Parameters:
//
//   width, height: image width and height in pixels
//   x0, y0:        origin of ray in image coordinates
//   dbldx, dbldy:  direction vector of ray, not necessarily normalized,
//                  but must be non-zero.
//   xi, yi:        computed intersection point rounded into image coordinates.
//
// Created by: PhilLu    06/22/98
// 
//------------------------------------------------------------------------------
void 
CDXTRadialWipeBase::_IntersectRect(long width, long height, long x0, long y0, 
                                   double dbldx, double dbldy, long & xi, 
                                   long & yi)
{
    double dblD;
    double dblDmin = (double)(width+height); // larger than the distance from (x0,y0) to rect boundary

    // (dbldx, dbldy) gives the direction vector, it must not be (0,0)

    _ASSERT(dbldx != 0.0 || dbldy != 0.0);

    // check intersection with top and bottom edge

    if(dbldy != 0.0)
    {
        dblD = -y0/dbldy;
        if (dblD > 0 && dblD < dblDmin)
            dblDmin = dblD;

        dblD = (height-1 - y0)/dbldy;
        if (dblD > 0 && dblD < dblDmin)
            dblDmin = dblD;
    }

    // check intersection with left and right edges

    if(dbldx != 0.0)
    {
        dblD = -x0/dbldx;
        if (dblD > 0 && dblD < dblDmin)
            dblDmin = dblD;

        dblD = (width-1 - x0)/dbldx;
        if (dblD > 0 && dblD < dblDmin)
            dblDmin = dblD;
    }

    xi = (long)(x0 + dblDmin*dbldx + 0.5);
    yi = (long)(y0 + dblDmin*dbldy + 0.5);

    _ASSERT(xi >= 0 && xi < width && yi >= 0 && yi < height);
}
//  CDXTRadialWipeBase::_IntersectRect


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_ScanlineIntervals
//
// A helper method that calculates the transition boundaries between the
// two image regions on a scanline. Based on the type of transform, the scanline
// consists of a series of alternating A and B image sections. The upper X
// bound of each section is calculated and saved in array XBounds. The number
// of useful entries in XBounds is variable. The end of array is determined
// when one entry equals to the scanline (image) width. It is assumed that
// XBounds[0] is the upper bound of the first A section. So if the scanline
// starts with a B section, XBounds[0] will be 0.
//
// Example 1: scanline length = 16, first section is from A image
//
//    AAAABBBBBAAABBAA      XBounds should contain {4, 9, 12, 14, 16}.
//
// Example 2: scanline length = 16, first section is from B image
//
//    BBBAAAAAABBBBBBB      XBounds should contain {0, 3, 9, 16}.
//
//
// Note: It is possible that some section has length 0 (i.e. two adjacent
//       bounds equal). {3, 9, 9, 16} is equivalent to {3, 16}.
//
// Parameters:
//
// width, height: width and height of both images.
// XEdge, YEdge: coordinates of the intersection point of a ray with the image boundary
// fProg: progress value from 0.0 to 1.0
// YScanline: Y cooridnate (height) of the current scanline
// XBounds: array to hold the computed X bounds on return.
//
//
// Created by: PhilLu    06/22/98
// 
//------------------------------------------------------------------------------
void 
CDXTRadialWipeBase::_ScanlineIntervals(long width, long height, 
                                       long XEdge, long YEdge, float fProg,
                                       long YScanline, long *XBounds)
{
    long CenterX, CenterY;

    // Center of image
    CenterX = width/2;
    CenterY = height/2;

    switch(m_eWipeStyle)
    {
    case CRRWS_CLOCK:
        if (YEdge >= CenterY)
        {
            // bottom half

            if (YScanline <= CenterY)
            {
                XBounds[0] = CenterX;
                XBounds[1] = width;
            }
            else if (YScanline <= YEdge)
            {
                // note YEdge-CenterY != 0 when we reach here, won't divide by 0
                XBounds[0] = CenterX + (XEdge-CenterX)*(YScanline-CenterY)/(YEdge-CenterY);
                XBounds[1] = width;
            }
            else if (XEdge < CenterX)
            {
                XBounds[0] = 0;
                XBounds[1] = width;
            }
            else
            {
                XBounds[0] = width;
            }
        }
        else if (XEdge < CenterX)
        {
            // top left quarter
            if (YScanline < YEdge)
            {
                XBounds[0] = CenterX;
                XBounds[1] = width;
            }
            else if (YScanline <= CenterY)
            {
                XBounds[0] = 0;
                XBounds[1] = CenterX + (XEdge-CenterX)*(YScanline-CenterY)/(YEdge-CenterY);
                XBounds[2] = CenterX;
                XBounds[3] = width;
            }
            else
            {
                XBounds[0] = 0;
                XBounds[1] = width;
            }
        }
        else // top right quarter: YEdge < CenterY && XEdge >= CenterX
        {
            if (YScanline < YEdge)
            {
                XBounds[0] = CenterX;
                XBounds[1] = width;
            }
            else if (YScanline <= CenterY)
            {
                XBounds[0] = CenterX;
                XBounds[1] = CenterX + (XEdge-CenterX)*(YScanline-CenterY)/(YEdge-CenterY);
                XBounds[2] = width;
            }
            else
            {
                XBounds[0] = width;
            }
        }

        // check a special case when progress is 0 or 1. The ray direction is not sufficient
        // for determining it is the beginning or end of sequence.
        if (fProg == 0.0)
        {
            XBounds[0] = width;
        }
        else if(fProg == 1.0)
        {
            XBounds[0] = 0;
            XBounds[1] = width;
        }

        break;

    case CRRWS_WEDGE:
        if (YEdge >= CenterY)
        {
            // bottom half

            if (YScanline <= CenterY)
            {
                XBounds[0] = 0;
                XBounds[1] = width;
            }
            else if (YScanline <= YEdge)
            {
                // note YEdge-CenterY != 0 when we reach here, won't divide by 0
                long deltaX = (XEdge-CenterX)*(YScanline-CenterY)/(YEdge-CenterY);
                XBounds[0] = 0;
                XBounds[1] = CenterX - deltaX;
                XBounds[2] = CenterX + deltaX;
                XBounds[3] = width;
            }
            else
            {
                XBounds[0] = width;
            }
        }
        else // YEdge < CenterY
        {
            if (YScanline < YEdge)
            {
                XBounds[0] = 0;
                XBounds[1] = width;
            }
            else if (YScanline <= CenterY)
            {
                long deltaX = (XEdge-CenterX)*(YScanline-CenterY)/(YEdge-CenterY);
                XBounds[0] = CenterX - deltaX;
                XBounds[1] = CenterX + deltaX;
                XBounds[2] = width;
            }
            else
            {
                XBounds[0] = width;
            }
        }

        break;

    case CRRWS_RADIAL:
        if (YScanline <= YEdge && YEdge > 0)
        {
            XBounds[0] = YScanline*XEdge/YEdge;
            XBounds[1] = width;
        }
        else
        {
            XBounds[0] = width;
        }

        break;

   default:
        _ASSERT(0);

        break;
    }
}
//  CDXTRadialWipeBase::_ScanlineIntervals


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_ClipBounds
//
//  Description:
//  Initially the X-bounds are specified relative to the entire image. After clipping,
//  the bounds should be transformed to be relative to the clipping region.
//
//  Parameters;
//  offset, width: offset and width of the clipping region (along X)
//  XBounds: array of X-bounds
//
//  Created by: PhilLu    07/21/98
//
//------------------------------------------------------------------------------
void 
CDXTRadialWipeBase::_ClipBounds(long offset, long width, long *XBounds)
{
    int i;

    for(i=0; XBounds[i] < offset+width; i++)
    {
        if (XBounds[i] < offset)
            XBounds[i] = 0;
        else
            XBounds[i] -= offset;
    }

    XBounds[i] = width;
}
//  CDXTRadialWipeBase::_ClipBounds


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_CalcFullBoundsClock
//
//------------------------------------------------------------------------------
HRESULT
CDXTRadialWipeBase::_CalcFullBoundsClock()
{
    POINT   ptCenter;
    RECT    rcRay;
    RECT    rcBar;
    RECT    rc;

    ptCenter.x = m_sizeInput.cx / 2;
    ptCenter.y = m_sizeInput.cy / 2;

    // Rect enclosing the vertical bar between quadrants 1 and 4.

    rcBar.left      = max(ptCenter.x - 2, 0);
    rcBar.top       = 0;
    rcBar.right     = min(ptCenter.x + 2, m_sizeInput.cx);
    rcBar.bottom    = max(ptCenter.y - 2, 0);

    switch (m_iCurQuadrant)
    {
    case 1:
 
        // Rect enclosing current quadrant (1).

        rcRay.left      = max(ptCenter.x - 2, 0);
        rcRay.top       = 0;
        rcRay.right     = m_sizeInput.cx;
        rcRay.bottom    = min(ptCenter.y + 2, m_sizeInput.cy);

        m_abndsDirty[m_cbndsDirty].SetXYRect(rcRay);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;

        // Rect enclosing quadrants 2 and 3.

        rc.left     = 0;
        rc.top      = rcRay.bottom;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;

        // Rect enclosing quadrant 4.

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = rcRay.left;
        rc.bottom   = rcRay.bottom;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;

        break;

    case 2:

        // Use rcBar.

        m_abndsDirty[m_cbndsDirty].SetXYRect(rcBar);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;

        // Rect enclosing current quadrant (2).

        rcRay.left      = rcBar.left;
        rcRay.top       = rcBar.bottom;
        rcRay.right     = m_sizeInput.cx;
        rcRay.bottom    = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rcRay);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;

        // Rect enclosing quadrant 1.

        rc.left     = rcBar.right;
        rc.top      = 0;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = rcBar.bottom;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 1;
        m_cbndsDirty++;

        // Rect enclosing quadrants 3 and 4.

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = rcBar.left;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;

        break;

    case 3:

        // Use rcBar.

        m_abndsDirty[m_cbndsDirty].SetXYRect(rcBar);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;

        // Rect enclosing current quadrant (3).

        rcRay.left      = 0;
        rcRay.top       = rcBar.bottom;
        rcRay.right     = rcBar.right;
        rcRay.bottom    = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rcRay);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;

        // Rect encloseing quadrants 1 and 2.

        rc.left     = rcBar.right;
        rc.top      = 0;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 1;
        m_cbndsDirty++;

        // Rect enclosing quadrant 4.

        rc.left     = 0;
        rc.top      = 0;
        rc.right    = rcBar.left;
        rc.bottom   = rcBar.bottom;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;

        break;

    case 4:

        // Rect enclosing current quadrant (4).

        rcRay.left      = 0;
        rcRay.top       = 0;
        rcRay.right     = min(ptCenter.x + 2, m_sizeInput.cx);
        rcRay.bottom    = max(ptCenter.y + 2, 0);

        m_abndsDirty[m_cbndsDirty].SetXYRect(rcRay);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;

        // Rect enclosing quadrant 1.

        rc.left     = rcRay.right;
        rc.top      = 0;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = rcRay.bottom;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 1;
        m_cbndsDirty++;

        // Rect enclosing quadrants 2 and 3.

        rc.left     = 0;
        rc.top      = rcRay.bottom;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 1;
        m_cbndsDirty++;

        break;

    default:

        _ASSERT(0);
    }

    return S_OK;
}
//  CDXTRadialWipeBase::_CalcFullBoundsClock


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_CalcFullBoundsWedge
//
//------------------------------------------------------------------------------
HRESULT
CDXTRadialWipeBase::_CalcFullBoundsWedge()
{
    POINT   ptCenter;
    RECT    rcRay;
    RECT    rc;

    ptCenter.x = m_sizeInput.cx / 2;
    ptCenter.y = m_sizeInput.cy / 2;

    // Calculate rect enclosing all both rays.

    rcRay.right     = m_ptCurEdge.x + 1;
    rcRay.left      = m_sizeInput.cx - rcRay.right;

    rcRay.top       = max(min(m_ptCurEdge.y, ptCenter.y - 1), 0);
    rcRay.bottom    = max(m_ptCurEdge.y, ptCenter.y) + 1;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rcRay);
    m_alInputIndex[m_cbndsDirty] = DRAWRECT;
    m_cbndsDirty++;

    // Do we need to fill above the top of rcRay?

    if (rcRay.top > 0)
    {
        rc.left     = 0;
        rc.top      = 0;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = rcRay.top;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 1;
        m_cbndsDirty++;
    }

    // Do we need to fill below the bottom of rcRay?

    if (rcRay.bottom < m_sizeInput.cy)
    {
        rc.left     = 0;
        rc.top      = rcRay.bottom;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;
    }

    // Do we need to fill to the right of rcRay?

    if (rcRay.right < m_sizeInput.cx)
    {
        rc.left     = rcRay.right;
        rc.top      = rcRay.top;
        rc.right    = m_sizeInput.cx;
        rc.bottom   = rcRay.bottom;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = (m_Progress > 0.5F) ? 1 : 0;
        m_cbndsDirty++;
    }

    // Do we need to fill to the left of rcRay?

    if (rcRay.left > 0)
    {
        rc.left     = 0;
        rc.top      = rcRay.top;
        rc.right    = rcRay.left;
        rc.bottom   = rcRay.bottom;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = (m_Progress > 0.5F) ? 1 : 0;
        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTRadialWipeBase::_CalcFullBoundsWedge


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_CalcFullBoundsRadial
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::_CalcFullBoundsRadial()
{
    SIZE    szMax;
    RECT    rcRemaining;

    szMax.cx    = m_sizeInput.cx - 1;
    szMax.cy    = m_sizeInput.cy - 1;

    rcRemaining.left    = 0;
    rcRemaining.right   = m_sizeInput.cx;
    rcRemaining.top     = 0;
    rcRemaining.bottom  = m_sizeInput.cy;

    m_cbndsDirty = 0;

    if (!((m_ptCurEdge.x == szMax.cx) && (m_ptCurEdge.y == szMax.cy)))
    {
        RECT rc;

        rc.right    = m_sizeInput.cx;
        rc.bottom   = m_sizeInput.cy;

        if (m_ptCurEdge.x == szMax.cx)
        {
            // Fill rect on bottom part of output with input A.

            rc.left = 0;
            rc.top  = m_ptCurEdge.y + 1;

            m_alInputIndex[m_cbndsDirty] = 0;

            rcRemaining.bottom = m_ptCurEdge.y + 1;
        }
        else
        {
            // Fill rect on right part of output with input B.

            rc.left = m_ptCurEdge.x + 1;
            rc.top  = 0;

            m_alInputIndex[m_cbndsDirty] = 1;

            rcRemaining.right = m_ptCurEdge.x + 1;
        }

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_cbndsDirty++;
    }

    m_abndsDirty[m_cbndsDirty].SetXYRect(rcRemaining);
    m_alInputIndex[m_cbndsDirty] = DRAWRECT;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTRadialWipeBase::_CalcFullBoundsRadial


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_CalcOptBoundsClock
//
//------------------------------------------------------------------------------
HRESULT
CDXTRadialWipeBase::_CalcOptBoundsClock()
{
    POINT   ptCenter;
    RECT    rcCenter;   // Center DRAWRECT bounds.
    RECT    rcCur;      // Current ray's bounds if needed outside center bnds.
    RECT    rcPrev;     // Previous ray's bounds if needed outside center bnds.
    POINT   ptCRI;      // Current ray intercept with center bounds.
    POINT   ptPRI;      // Previous ray intercept with center bounds.

    bool    fCurUsed    = false;    // rcCur used?
    bool    fPrevUsed   = false;    // rcPrev used?

    long    lInput      = 0;

    int     iMaxQuadrant = max(m_iCurQuadrant, m_iPrevQuadrant);
    int     iMinQuadrant = min(m_iCurQuadrant, m_iPrevQuadrant);

    RECT *  prcMin = NULL;
    RECT *  prcMax = NULL;

    ptCenter.x = m_sizeInput.cx / 2;
    ptCenter.y = m_sizeInput.cy / 2;

    if (m_sizeInput.cx < 25)
    {
        rcCenter.left   = 0;
        rcCenter.right  = m_sizeInput.cx;
    }
    else
    {
        rcCenter.left   = ptCenter.x - 10;
        rcCenter.right  = ptCenter.x + 10;
    }

    if (m_sizeInput.cy < 25)
    {
        rcCenter.top    = 0;
        rcCenter.bottom = m_sizeInput.cy;
    }
    else
    {
        rcCenter.top    = ptCenter.y - 10;
        rcCenter.bottom = ptCenter.y + 10;
    }

    // Find new ray intercept.

    if (m_ptCurEdge.y >= rcCenter.top && m_ptCurEdge.y < rcCenter.bottom)
    {
        ptCRI.x = m_ptCurEdge.x;
        ptCRI.y = m_ptCurEdge.y;
    }
    else
    {
        double dly  = 0.0;
        double dlx  = 0.0;
        double dlim = 0.0;  // inverse slope of ray.

        // We'll be using rcCur.

        fCurUsed = true;

        if (1 == m_iCurQuadrant || 4 == m_iCurQuadrant)
        {
            dly             = 10.0;
            ptCRI.y         = rcCenter.top;
            rcCur.top       = max(m_ptCurEdge.y - 2, 0);
            rcCur.bottom    = rcCenter.top;
        }
        else
        {
            dly             = -10.0;
            ptCRI.y         = rcCenter.bottom;
            rcCur.top       = rcCenter.bottom;
            rcCur.bottom    = min(m_ptCurEdge.y + 2, m_sizeInput.cy);
        }

        dlim = (double)(m_ptCurEdge.x - ptCenter.x) 
               / (double)(ptCenter.y - m_ptCurEdge.y);
        
        dlx = dly * dlim;

        ptCRI.x = (long)dlx + ptCenter.x;

        // Calculate horizontal bounds of rcCur;

        rcCur.left  = max(min(m_ptCurEdge.x - 2, ptCRI.x - 2), 0);
        rcCur.right = min(max(m_ptCurEdge.x + 2, ptCRI.x + 2), m_sizeInput.cx);
    }

    // Expand center bounds horizontally to include the new ray intercept.

    if (rcCenter.right <= ptCRI.x)
    {
        rcCenter.right = ptCRI.x + 1;
    }
    else if (rcCenter.left > ptCRI.x)
    {
        rcCenter.left = ptCRI.x;
    }

    // Find old ray intercept.

    if (m_ptPrevEdge.y >= rcCenter.top && m_ptPrevEdge.y < rcCenter.bottom)
    {
        ptPRI.x = m_ptPrevEdge.x;
        ptPRI.y = m_ptPrevEdge.y;
    }
    else
    {
        double dly  = 0.0;
        double dlx  = 0.0;
        double dlim = 0.0;  // inverse slope of ray.

        // We'll be using rcPrev.

        fPrevUsed = true;

        if (1 == m_iPrevQuadrant || 4 == m_iPrevQuadrant)
        {
            dly             = 10.0;
            ptPRI.y         = rcCenter.top;
            rcPrev.top      = max(m_ptPrevEdge.y - 2, 0);
            rcPrev.bottom   = rcCenter.top;
        }
        else
        {
            dly             = -10.0;
            ptPRI.y         = rcCenter.bottom;
            rcPrev.top      = rcCenter.bottom;
            rcPrev.bottom   = min(m_ptPrevEdge.y + 2, m_sizeInput.cy);
        }

        dlim = (double)(m_ptPrevEdge.x - ptCenter.x) 
               / (double)(ptCenter.y - m_ptPrevEdge.y);
        
        dlx = dly * dlim;

        ptPRI.x = (long)dlx + ptCenter.x;

        rcPrev.left  = max(min(m_ptPrevEdge.x - 2, ptPRI.x - 2), 0);
        rcPrev.right = min(max(m_ptPrevEdge.x + 2, ptPRI.x + 2), m_sizeInput.cx);
    }

    // Expand center bounds horizontally to include the previous ray intercept.

    if (rcCenter.right <= ptPRI.x)
    {
        rcCenter.right = ptPRI.x + 1;
    }
    else if (rcCenter.left > ptPRI.x)
    {
        rcCenter.left = ptPRI.x;
    }

    if (m_iCurQuadrant == m_iPrevQuadrant)
    {
        RECT *  prc = NULL;
        RECT    rc;

        // If both RECTs are used, union bounds manually and unset used flags.

        if (fCurUsed && fPrevUsed)
        {
            rc.top      = min(rcCur.top,    rcPrev.top);
            rc.bottom   = max(rcCur.bottom, rcPrev.bottom);
            rc.left     = min(rcCur.left,   rcPrev.left);
            rc.right    = max(rcCur.right,  rcPrev.right);

            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = DRAWRECT;
            m_cbndsDirty++;

            fCurUsed    = false;
            fPrevUsed   = false;

            goto done;
        }

        // If neither RECT is used, both rays are entirely in the center
        // band and all needed areas will be covered.

        if (!fCurUsed && !fPrevUsed)
        {
            goto done;
        }

        // In the case of only one RECT being used and the other being in
        // the center, it is possible for some areas to be missed.

        if (fCurUsed)
        {
            prc = &rcCur;
        }
        else
        {
            _ASSERT(fPrevUsed);
            prc = &rcPrev;
        }

        // Grow the right or left edge of the rectangle to the edge of
        // the work area to make sure we got all the pixels.

        switch (m_iCurQuadrant)
        {
        case 1:

            if (prc->right == m_sizeInput.cx)
            {
                goto done;
            }

            if (fPrevUsed)
            {
                lInput = 1;
            }

            rc.top      = prc->top;
            rc.bottom   = prc->bottom;
            rc.left     = prc->right;
            rc.right    = m_sizeInput.cx;
            
            break;

        case 2:

            if (prc->right == m_sizeInput.cx)
            {
                goto done;
            }

            if (fCurUsed)
            {
                lInput = 1;
            }

            rc.top      = prc->top;
            rc.bottom   = prc->bottom;
            rc.left     = prc->right;
            rc.right    = m_sizeInput.cx;
        
            break;

        case 3:

            if (prc->left == 0)
            {
                goto done;
            }

            if (fPrevUsed)
            {
                lInput = 1;
            }

            rc.top      = prc->top;
            rc.bottom   = prc->bottom;
            rc.left     = 0;
            rc.right    = prc->left;

            break;

        case 4:

            if (prc->left == 0)
            {
                goto done;
            }

            if (fCurUsed)
            {
                lInput = 1;
            }

            rc.top      = prc->top;
            rc.bottom   = prc->bottom;
            rc.left     = 0;
            rc.right    = prc->left;

            break;

        default:

            _ASSERT(0);
        }

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = lInput;
        m_cbndsDirty++;

        goto done;
    }

    // If current quadrant is greater than the previous quadrant, fill with
    // input B instead of A.

    if (m_iCurQuadrant > m_iPrevQuadrant)
    {
        lInput = 1;
        
        if (fCurUsed)
        {
            prcMax = &rcCur;
        }

        if (fPrevUsed)
        {
            prcMin = &rcPrev;
        }
    }
    else
    {
        // lInput = 0; (by default, commented on purpose)

        if (fCurUsed)
        {
            prcMin = &rcCur;
        }

        if (fPrevUsed)
        {
            prcMax = &rcPrev;
        }
    }

    // If we're moving from or to quadrant 1, make sure center bounds
    // go all the way to the right edge.

    if (1 == m_iCurQuadrant || 1 == m_iPrevQuadrant)
    {
        rcCenter.right = m_sizeInput.cx;
    }

    // If we're moving from or to quadrant 4, make sure center bounds
    // go all the way to the left edge.

    if (4 == m_iCurQuadrant || 4 == m_iPrevQuadrant)
    {
        rcCenter.left = 0;
    }

    // If the minium quadrant is quadrant 1, make sure the quadrant is filled
    // all the way to the right side of the output.

    if (1 == iMinQuadrant && prcMin)
    {
        RECT rc;

        if (prcMin->right < m_sizeInput.cx)
        {
            rc.top      = 0;
            rc.bottom   = rcCenter.top;
            rc.left     = prcMin->right;
            rc.right    = m_sizeInput.cx;
        
            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = lInput;
            m_cbndsDirty++;
        }
    }

    // If the maximum quadrant is quadrant 2, make sure the quadrant is filled
    // all the way to the right side of the output.

    if (2 == iMaxQuadrant && prcMax)
    {
        RECT rc;

        if (prcMax->right < m_sizeInput.cx)
        {
            rc.top      = rcCenter.bottom;
            rc.bottom   = m_sizeInput.cy;
            rc.left     = prcMax->right;
            rc.right    = m_sizeInput.cx;

            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = lInput;
            m_cbndsDirty++;
        }
    }

    if (3 == iMinQuadrant && prcMin)
    {
        RECT rc;

        if (prcMin->left > 0)
        {
            rc.top      = rcCenter.bottom;
            rc.bottom   = m_sizeInput.cy;
            rc.left     = 0;
            rc.right    = prcMin->left;

            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = lInput;
            m_cbndsDirty++;
        }
    }

    if (4 == iMaxQuadrant && prcMax)
    {
        RECT rc;

        if (prcMax->left > 0)
        {
            rc.top      = 0;
            rc.bottom   = rcCenter.top;
            rc.left     = 0;
            rc.right    = prcMax->left;

            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = lInput;
            m_cbndsDirty++;
        }
    }

    if (iMaxQuadrant >= 3 && iMinQuadrant < 3)
    {
        if ((1 == iMinQuadrant) || !prcMin)
        {
            RECT rcBottom;  // Represets a rectangle that runs the full width of
                            // the output and touches the bottom of the output.

            if (prcMax && (3 == iMaxQuadrant))
            {
                RECT rcRight;   // Represents a rectangle to the right of the
                                // rectangle used to enclose the ray in
                                // quadrant 3.

                rcRight.top     = prcMax->top;
                rcRight.bottom  = prcMax->bottom;
                rcRight.left    = prcMax->right;
                rcRight.right   = m_sizeInput.cx;

                m_abndsDirty[m_cbndsDirty].SetXYRect(rcRight);
                m_alInputIndex[m_cbndsDirty] = lInput;
                m_cbndsDirty++;

                rcBottom.top    = prcMax->bottom;
            }
            else // if (!prcMax || (3 != iMaxQuadrant))
            {
                rcBottom.top    = rcCenter.bottom;
            }

            rcBottom.bottom = m_sizeInput.cy;
            rcBottom.left   = 0;
            rcBottom.right  = m_sizeInput.cx;

            m_abndsDirty[m_cbndsDirty].SetXYRect(rcBottom);
            m_alInputIndex[m_cbndsDirty] = lInput;
            m_cbndsDirty++;
        }
        else // if ((1 != iMinQuadrant) && prcMin))
        {
            RECT rcBottom;

            if (prcMax && (3 == iMaxQuadrant))
            {
                RECT rcCombo;

                // Combine both ray rectangles.

                rcCombo.top     = rcCenter.bottom;
                rcCombo.bottom  = max(prcMax->bottom, prcMin->bottom);
                rcCombo.left    = prcMax->left;
                rcCombo.right   = prcMin->right;

                m_abndsDirty[m_cbndsDirty].SetXYRect(rcCombo);
                m_alInputIndex[m_cbndsDirty] = DRAWRECT;
                m_cbndsDirty++;
                
                fCurUsed    = false;
                fPrevUsed   = false;

                if (rcCombo.bottom < m_sizeInput.cy)
                {
                    // Combo rectangle doesn't go all the way to the 
                    // bottom.

                    rcBottom.top    = rcCombo.bottom;
                    rcBottom.bottom = m_sizeInput.cy;
                    rcBottom.left   = rcCombo.left;
                    rcBottom.right  = rcCombo.right;

                    m_abndsDirty[m_cbndsDirty].SetXYRect(rcBottom);
                    m_alInputIndex[m_cbndsDirty] = lInput;
                    m_cbndsDirty++;
                }
            }
            else // if (!prcMax || (3 != iMaxQuadrant))
            {
                RECT rcLeft;

                rcLeft.left     = 0;
                rcLeft.right    = prcMin->left;
                rcLeft.top      = rcCenter.bottom;
                rcLeft.bottom   = prcMin->bottom;

                m_abndsDirty[m_cbndsDirty].SetXYRect(rcLeft);
                m_alInputIndex[m_cbndsDirty] = lInput;
                m_cbndsDirty++;

                if (rcLeft.bottom < m_sizeInput.cy)
                {
                    rcBottom.top    = rcLeft.bottom;
                    rcBottom.bottom = m_sizeInput.cy;
                    rcBottom.left   = 0;
                    rcBottom.right  = m_sizeInput.cx;

                    m_abndsDirty[m_cbndsDirty].SetXYRect(rcBottom);
                    m_alInputIndex[m_cbndsDirty] = lInput;
                    m_cbndsDirty++;
                }
            } // if (!prcMax || (3 != iMaxQuadrant))

        } // if ((1 != iMinQuadrant) && prcMin))

    } // if (3 == iMaxQuadrant)

done:

    m_abndsDirty[m_cbndsDirty].SetXYRect(rcCenter);
    m_alInputIndex[m_cbndsDirty] = DRAWRECT;
    m_cbndsDirty++;

    if (fCurUsed)
    {
        m_abndsDirty[m_cbndsDirty].SetXYRect(rcCur);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;
    }

    if (fPrevUsed)
    {
        m_abndsDirty[m_cbndsDirty].SetXYRect(rcPrev);
        m_alInputIndex[m_cbndsDirty] = DRAWRECT;
        m_cbndsDirty++;
    }

    if (fCurUsed && fPrevUsed &&
        m_abndsDirty[m_cbndsDirty - 2].TestIntersect(m_abndsDirty[m_cbndsDirty -1]))
    {
        m_abndsDirty[m_cbndsDirty - 2].UnionBounds(
            m_abndsDirty[m_cbndsDirty - 2], m_abndsDirty[m_cbndsDirty - 1]);

        m_cbndsDirty--;
    }

    return S_OK;
}
//  CDXTRadialWipeBase::_CalcOptBoundsClock


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_CalcOptBoundsWedge
//
//------------------------------------------------------------------------------
HRESULT
CDXTRadialWipeBase::_CalcOptBoundsWedge()
{
    POINT   ptCenter;
    RECT    rcRemaining;

    ptCenter.x = m_sizeInput.cx / 2;
    ptCenter.y = m_sizeInput.cy / 2;

    rcRemaining.left    = 0;
    rcRemaining.right   = m_sizeInput.cx;
    rcRemaining.top     = 0;
    rcRemaining.bottom  = m_sizeInput.cy;

    // Can bounds be clipped on the sides?

    if ((m_ptCurEdge.x < (m_sizeInput.cx - 1)) 
        && (m_ptPrevEdge.x < (m_sizeInput.cx - 1)))
    {
        rcRemaining.right   = max(m_ptCurEdge.x, m_ptPrevEdge.x) + 1;
        rcRemaining.left    = m_sizeInput.cx - rcRemaining.right;

        // If the y edge is the same we can further clip off the top or the 
        // bottom half.  Otherwise we'll need to fill the sides with either
        // input A or input B.

        if (m_ptCurEdge.y == m_ptPrevEdge.y)
        {
            rcRemaining.top     = min(m_ptCurEdge.y, (ptCenter.y - 1));
            rcRemaining.bottom  = max(ptCenter.y, m_ptCurEdge.y) + 1;
        }
        else
        {
            RECT    rc;
            long    lInputIndex = (m_ptCurEdge.y > m_ptPrevEdge.y) ? 1 : 0;

            // Left side.

            rc.left     = 0;
            rc.top      = 0;
            rc.right    = rcRemaining.left;
            rc.bottom   = m_sizeInput.cy;

            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = lInputIndex;
            m_cbndsDirty++;

            // Right side.

            rc.left     = rcRemaining.right;
            rc.right    = m_sizeInput.cx;

            m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
            m_alInputIndex[m_cbndsDirty] = lInputIndex;
            m_cbndsDirty++;
        }
    }

    // Can bounds be clipped on the top and bottom?

    if ((m_ptCurEdge.x == (m_sizeInput.cx - 1)) && (m_ptPrevEdge.x == (m_sizeInput.cx - 1)))
    {
        rcRemaining.top     = min(min(m_ptCurEdge.y, m_ptPrevEdge.y), ptCenter.y) - 1;
        rcRemaining.top     = max(rcRemaining.top, 0);
        rcRemaining.bottom  = max(max(m_ptCurEdge.y, m_ptPrevEdge.y), ptCenter.y) + 1;
    }

    m_abndsDirty[m_cbndsDirty].SetXYRect(rcRemaining);
    m_alInputIndex[m_cbndsDirty] = DRAWRECT;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTRadialWipeBase::_CalcOptBoundsWedge


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_CalcOptBoundsRadial
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::_CalcOptBoundsRadial()
{
    // ppt1, ptt2   ppt2 points to the intersection POINT that is "further along
    //              in progress."  If progress has risen since the last execute
    //              then ppt2 will point to the current intersection POINT.  If
    //              progress has decreased since the last execute ppt2 will
    //              point to the previous intersection POINT.
    //              ppt1 points to the other point.  

    POINT * ppt1;       // The point closest to the point at m_Progress = 0.0.
    POINT * ppt2;       // The point closest to the point at m_Progress = 1.0.

    RECT    rcRemaining;    // Bounding rectangle of dirty areas.
    RECT    rc;             // Temporary bounds rectangle.

    float   flInvSlope1 = 0.0F;
    float   flInvSlope2 = 0.0F;
    float   flRowHeight = 0.0F;
    ULONG   i           = 0;

    // Initialize rcRemaining to the entire surface size.  This will be reduced
    // as optimizations can be made.

    rcRemaining.left    = 0;
    rcRemaining.right   = m_sizeInput.cx;
    rcRemaining.top     = 0;
    rcRemaining.bottom  = m_sizeInput.cy;

    // Reduce the size of the bounding rectangle of all dirty areas 
    // (rcRemaining) by eliminating rectangles that don't contain any areas
    // that aren't dirty.  This reduction will leave rcRemaining as a rectangle
    // that just contains both the current and the previous rays.

    if (!((m_ptCurEdge.x == (m_sizeInput.cx - 1)) && (m_ptCurEdge.y == (m_sizeInput.cy - 1))))
    {
        if (m_ptCurEdge.x == (m_sizeInput.cx - 1))
        {
            // There may be an area on the bottom of rcRemaining that isn't
            // dirty.  If so, reduce the size of rcRemaining.

            rcRemaining.bottom = max(m_ptCurEdge.y, m_ptPrevEdge.y) + 1;
        }
        else
        {
            // There may be an area on the right side of rcRemaining that isn't
            // dirty.  If so, reduce the size of rcRemaining.

            rcRemaining.right = max(m_ptCurEdge.x, m_ptPrevEdge.x) + 1;
        }
    }

    // Determine which ray intersection point is "further along in progress" and
    // set ppt1 and ppt2 accordingly.

    if ((m_ptCurEdge.x < m_ptPrevEdge.x) || (m_ptCurEdge.y > m_ptPrevEdge.y))
    {
        // Progress has increased since the last execute.

        ppt1 = &m_ptPrevEdge;
        ppt2 = &m_ptCurEdge;
    }
    else
    {
        // Progress has decreased since the last execute.

        ppt1 = &m_ptCurEdge;
        ppt2 = &m_ptPrevEdge;
    }

    // Calculate the number of dirty bounds we would desire based on the 
    // size of rcRemaining.  

    m_cbndsDirty = min(rcRemaining.bottom / MIN_PIXELS_PER_ROW, 
                         rcRemaining.right / MIN_PIXELS_PER_ROW) + 1;

    // If rcRemaining is particularly large, reduce the number of dirty bounds
    // we will create.  (While creating a certain number of smaller dirty bounds
    // structures will improve performance, too many structures will actually
    // decrease performance.)

    if (m_cbndsDirty > MAX_DIRTY_BOUNDS)
    {
        m_cbndsDirty = MAX_DIRTY_BOUNDS;
    }

    // Calculate 1 / (slope of the line from {0, 0} to ppt1)

    if (ppt1->y != 0)
    {
        flInvSlope1 = (float)ppt1->x / (float)ppt1->y;
    }

    // Calculate 1 / (slope of the line from {0, 0} to ppt2)

    if (ppt2->y != 0)
    {
        flInvSlope2 = (float)ppt2->x / (float)ppt2->y;
    }

    // Calculate the desired height of each bounds structure.  (Calculated as
    // a float so rounding won't cause problems.)

    if (m_cbndsDirty > 1)
    {
        flRowHeight = (float)(ppt2->y + 1) / (float)m_cbndsDirty;
    }

    // Calculate the bounds structures.

    for (i = 0; i < m_cbndsDirty; i++)
    {
        // Calculate the top-left corner of this set of dirty bounds.

        if (0 == i)
        {
            rc.top  = 0;
            rc.left = 0;
        }
        else
        {
            rc.top  = rc.bottom;
            rc.left = (long)(((float)rc.top * flInvSlope2) - 1.0F);
            rc.left = max(rc.left, 0);
        }

        // Calculate the bottom-right corner of this set of dirty bounds.

        if ((m_cbndsDirty - 1) == i)
        {
            rc.bottom = rcRemaining.bottom;
            rc.right  = rcRemaining.right;
        }
        else
        {
            rc.bottom = (long)((float)(i + 1) * flRowHeight);

            if (0.0F == flInvSlope1)
            {
                rc.right = rcRemaining.right;
            }
            else
            {
                rc.right  = (long)(((float)rc.bottom * flInvSlope1) + 1.0F);
                rc.right  = min(rc.right, rcRemaining.right);
            }
        }

        // Set the next set of bounds in the m_abndsDirty array to our
        // calculated bounds and specify that this set of bounds should be
        // drawn using the _DrawRect() method instead of being filled 
        // with an input.

        m_abndsDirty[i].SetXYRect(rc);
        m_alInputIndex[i] = DRAWRECT;
    }

    return S_OK;
}
//  CDXTRadialWipeBase::_CalcOptBoundsRadial


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::OnInitInstData(CDXTWorkInfoNTo1 & WI, 
                                   ULONG & ulNumBandsToDo)
{
    HRESULT hr      = S_OK;
    double  dlAngle = 0.0;

    // Reset number of dirty bounds to zero.

    m_cbndsDirty = 0;

    // Calculate current edge point.

    switch (m_eWipeStyle)
    {
        case CRRWS_CLOCK:

            // Calculate quadrant of current execute.

            if (1.0F == m_Progress)
            {
                m_iCurQuadrant = 4;
            }
            else
            {
                m_iCurQuadrant = (int)(m_Progress / 0.25F) + 1;
            }

            dlAngle = (2.0 * m_Progress - 0.5) * gc_PI;

            _IntersectRect(m_sizeInput.cx, m_sizeInput.cy, 
                           m_sizeInput.cx/2, m_sizeInput.cy/2,
                           cos(dlAngle), sin(dlAngle),
                           m_ptCurEdge.x, m_ptCurEdge.y);

            break;

        case CRRWS_WEDGE:
            dlAngle = (1.0 * m_Progress - 0.5) * gc_PI;

            _IntersectRect(m_sizeInput.cx, m_sizeInput.cy, 
                           m_sizeInput.cx/2, m_sizeInput.cy/2,
                           cos(dlAngle), sin(dlAngle),
                           m_ptCurEdge.x, m_ptCurEdge.y);

            break;

        case CRRWS_RADIAL:
            dlAngle = (0.5 * m_Progress) * gc_PI;

            _IntersectRect(m_sizeInput.cx, m_sizeInput.cy, 
                           0, 0, 
                           cos(dlAngle), sin(dlAngle), 
                           m_ptCurEdge.x, m_ptCurEdge.y);

            break;

        default:
            _ASSERT(0);
            break;
    } 

    // If the inputs, output, or transform is dirty, or if we can't optimize we 
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize
        || !m_fOptimizationPossible)
    {
        switch (m_eWipeStyle)
        {
            case CRRWS_CLOCK:
                hr = _CalcFullBoundsClock();

                break;

            case CRRWS_WEDGE:
                hr = _CalcFullBoundsWedge();

                break;

            case CRRWS_RADIAL:
                hr = _CalcFullBoundsRadial();

                break;
        } 
    }
    else
    {
        if ((m_ptCurEdge.x == m_ptPrevEdge.x) && (m_ptCurEdge.y == m_ptPrevEdge.y))
        {
            if (CRRWS_CLOCK == m_eWipeStyle)
            {
                // Clock can have duplicate edge points at different progress
                // levels so we also have to check to make sure the quadrants
                // are the same.

                if (m_iCurQuadrant == m_iPrevQuadrant)
                {
                    // Nothing needs to be updated.
                    goto done;
                }
            }
            else
            {
                // Nothing needs to be updated.
                goto done;
            }
        }

        switch (m_eWipeStyle)
        {
            case CRRWS_CLOCK:
                hr = _CalcOptBoundsClock();
                break;

            case CRRWS_WEDGE:
                hr = _CalcOptBoundsWedge();
                break;

            case CRRWS_RADIAL:
                hr = _CalcOptBoundsRadial();

                break;
        } 
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the 
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }
    
done:

    if (FAILED(hr))
    {
        return hr;
    }
    
    return S_OK;
}
//  CDXTRadialWipeBase::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::WorkProc, CDXBaseNTo1
//
//  Description:
//      This function is used to calculate the transformed image based on the 
//  specified bounds and the current effect progress.
//
//  Created by: PhilLu    06/22/98
//  
//  05/09/99    a-matcal    Created new WorkProc.  Old WorkProc modified to
//                          become new _DrawRect method.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr      = S_OK;
    DWORD   dwFlags = 0;
    ULONG   i       = 0;

    long    lInOutOffsetX = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }


    for (i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;

        if (bndsSrc.IntersectBounds(WI.DoBnds, m_abndsDirty[i]))
        {
            bndsDest = bndsSrc;
            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            if (m_alInputIndex[i] == DRAWRECT)
            {
                hr = _DrawRect(bndsDest, bndsSrc, pbContinue);
            }
            else
            {
                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(m_alInputIndex[i]), bndsSrc,
                              dwFlags, INFINITE);
            }

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTRadialWipeBase::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::_DrawRect
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::_DrawRect(const CDXDBnds & bndsDest, 
                              const CDXDBnds & bndsSrc, BOOL * pfContinue)
{
    HRESULT hr = S_OK;

    SIZE            szSrc;
    DXDITHERDESC    dxdd;
    DXPMSAMPLE *    pRowBuff = NULL;
    DXPMSAMPLE *    pOutBuff = NULL;

    CComPtr<IDXARGBReadPtr>         pInA;
    CComPtr<IDXARGBReadPtr>         pInB;
    CComPtr<IDXARGBReadWritePtr>    pOut;

    long    lOutY   = 0;

    double  dAngle  = 0.0F;
    long    XEdge   = 0;        // intersection of ray with image boundary
    long    YEdge   = 0;          
    long    XBounds[MAXBOUNDS]; // to hold the X bounds of A/B image sections on 
                                // a scanline

    bndsSrc.GetXYSize(szSrc);

    // Get read access to needed area of input A.

    hr = InputSurface(0)->LockSurface(&bndsSrc, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, (void**)&pInA, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get read access to needed area of input B.

    hr = InputSurface(1)->LockSurface(&bndsSrc, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, (void**)&pInB, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Get write access to needed area of output.

    hr = OutputSurface()->LockSurface(&bndsDest, m_ulLockTimeOut, DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, (void**)&pOut, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    pRowBuff = DXPMSAMPLE_Alloca(szSrc.cx);

    // Allocate output buffer if needed

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(szSrc.cx);
    }

    //  Set up the dither structure

    if (DoDither())
    {
        dxdd.x              = bndsDest.Left();
        dxdd.y              = bndsDest.Top();
        dxdd.pSamples       = pRowBuff;
        dxdd.cSamples       = szSrc.cx;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    // Row loop.

    for (lOutY = 0; *pfContinue && (lOutY < szSrc.cy); lOutY++)
    {
        long lScanLength = 0;  // cumulative scan length on the current scanline
        long i           = 0;

        // Compute the A/B image section bounds

        _ScanlineIntervals(m_sizeInput.cx, m_sizeInput.cy, 
                           m_ptCurEdge.x, m_ptCurEdge.y, 
                           m_Progress, lOutY + bndsSrc.Top(), XBounds);

        _ClipBounds(bndsSrc.Left(), szSrc.cx, XBounds);

        while (lScanLength < szSrc.cx)
        {
            // copy a section of A image to output buffer

            if(XBounds[i] - lScanLength > 0)
            {
                pInA->MoveToXY(lScanLength, lOutY);
                pInA->UnpackPremult(pRowBuff + lScanLength, 
                                    XBounds[i] - lScanLength, FALSE);
            }

            lScanLength = XBounds[i++];

            if (lScanLength >= szSrc.cx)
            {
                break;
            }

            // copy a section of B image to output buffer

            if (XBounds[i] - lScanLength > 0)
            {
                pInB->MoveToXY(lScanLength, lOutY);
                pInB->UnpackPremult(pRowBuff + lScanLength, 
                                    XBounds[i] - lScanLength, FALSE);
            }

            lScanLength = XBounds[i++];
        }


        // Get the output row

        pOut->MoveToRow(lOutY);

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            pOut->OverArrayAndMove(pOutBuff, pRowBuff, szSrc.cx);
        }
        else
        {
            pOut->PackPremultAndMove(pRowBuff, szSrc.cx);
        }
    } // Row loop.

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTRadialWipeBase::_DrawRect


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTRadialWipeBase::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    m_iPrevQuadrant = m_iCurQuadrant;
    m_ptPrevEdge    = m_ptCurEdge;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTRadialWipeBase::OnFreeInstData, CDXBaseNTo1


//
// ICrRadialWipe methods
//


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::get_wipeStyle, ICrRadialWipe
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTRadialWipeBase::get_wipeStyle(BSTR * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    switch (m_eWipeStyle)
    {
    case CRRWS_CLOCK:
        *pVal = SysAllocString (L"CLOCK");
        break;

    case CRRWS_WEDGE:
        *pVal = SysAllocString (L"WEDGE");
        break;

    case CRRWS_RADIAL:
        *pVal = SysAllocString (L"RADIAL");
        break;

    default:
        _ASSERT(0);
        break;
    }

    if (NULL == *pVal)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTRadialWipeBase::get_wipeStyle, ICrRadialWipe


//+-----------------------------------------------------------------------------
//
//  CDXTRadialWipeBase::put_wipeStyle, ICrRadialWipe
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTRadialWipeBase::put_wipeStyle(BSTR newVal)
{
    CRRWIPESTYLE eNewStyle = m_eWipeStyle;

    if (!newVal)
    {
        return E_POINTER;
    }

    if(!_wcsicmp(newVal, L"CLOCK"))
    {
        eNewStyle = CRRWS_CLOCK;
    }
    else if(!_wcsicmp(newVal, L"WEDGE"))
    {
        eNewStyle = CRRWS_WEDGE;
    }
    else if(!_wcsicmp(newVal, L"RADIAL"))
    {
        eNewStyle = CRRWS_RADIAL;
    }
    else
    {
        return E_INVALIDARG;
    }

    if (eNewStyle != m_eWipeStyle)
    {
        Lock();
        m_eWipeStyle = eNewStyle;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CDXTRadialWipeBase::put_wipeStyle, ICrRadialWipe
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\slide.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:		slide.cpp
//
// Created:		06/24/98
//
// Author:		phillu
//
// Discription:		This is the implementation of the CrSlide transformation
//
// History
//
// 06/24/98 phillu      initial creation
// 07/02/98 phillu      return E_INVALIDARG rather than an error string; check 
//                      for E_POINTER
// 07/12/98 kipo        revert to previous checkin to fix crashing error when 
//                      bound rect specified
// 07/13/98 leonro      removed CSlide::OnGetSurfacePickOrder function and added 
//                      CSlide::OnSurfacePick to override picking correctly
// 07/22/98 phillu      implement clipping
// 05/10/99 a-matcal    Optimization.
// 05/19/99 a-matcal    Check for out of memory in get_ functions allocating
//                      BSTRs.
// 10/24/99 a-matcal    Changed CSlide class to CDXTSlideBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "slide.h"





//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::CDXTSlideBase
//
//------------------------------------------------------------------------------
CDXTSlideBase::CDXTSlideBase() :
    m_cBands(1),
    m_eSlideStyle(CRSS_HIDE),
    m_cbndsDirty(0),
    m_lCurSlideDist(0),
    m_lPrevSlideDist(0),
    m_fOptimizationPossible(false),
    m_fOptimize(false)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // Base class members

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTSlideBase::CDXTSlideBase


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSlideBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTSlideBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_CalcFullBoundsHide
//
//  Overview:   This method calculates two sets of bounds that represent the 
//              output at the current progress.
//
//              If the progress is such that the output is composed entirely
//              of pixels from only one input, the bounds representing the other
//              input will have no area and will be skipped by the WorkProc 
//              method.
//
//              lBarLocation: When this transform is in hide mode, Input A moves
//              from right to left over the top of input B.  Since the 
//              m_lCurSlideDist moves from left to right, the method calculates
//              lBarLocation to represent the right edge of Input A at the
//              current progress.  
//
//              AAABBBBBBBB
//              AAABBBBBBBB
//              AAABBBBBBBB
//              AAABBBBBBBB
//                 ^   ^
//                 |   |-- m_lCurSlideDist (--> as progress increases)
//                 |
//                 |---- lBarLocation      (<-- as progress increases)
//
//
//              Note:  All coordinates are calculated in output space coordinates
//              assuming that 1) the output surface is the same size as the input
//              surface(s), 2) the output is placed at {0, 0} and 3) the ouput is
//              not clipped. Bounds will be transformed to input space, clipped,
//              or offset to support placement by the WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTSlideBase::_CalcFullBoundsHide()
{
    long    lBarLocation = m_sizeInput.cx - m_lCurSlideDist; 
    RECT    rc;

    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    // Input A bounds and offset.

    rc.left     = 0;
    rc.right    = lBarLocation;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].x   = m_lCurSlideDist;
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 0;
    m_cbndsDirty++;

    // Input B bounds and offset.

    rc.left     = lBarLocation;
    rc.right    = m_sizeInput.cx;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].x   = 0;
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 1;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTSlideBase::_CalcFullBoundsHide


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_CalcFullBoundsPush
//
//  Overview:   This method calculates two sets of bounds that represent the 
//              output at the current progress.
//
//              If the progress is such that the output is composed entirely
//              of samples from one input, the bounds representing the other
//              input will have no area and will be skipped by the WorkProc 
//              method.
//
//              lBarLocation: When this transform is in push mode, both Inputs A
//              and B move from right to left.  Since the m_lCurSlideDist 
//              member moves from left to right, the method calculates
//              lBarLocation to represent the right edge of Input A and the left
//              edge of Input B at the current progress.
//
//
//              Note:  All coordinates are calculated in output space coordinates
//              assuming that 1) the output surface is the same size as the input
//              surface(s), 2) the output is placed at {0, 0} and 3) the ouput is
//              not clipped. Bounds will be transformed to input space, clipped,
//              or offset to support placement by the WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTSlideBase::_CalcFullBoundsPush()
{
    long    lBarLocation = m_sizeInput.cx - m_lCurSlideDist;
    RECT    rc;

    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    // Input A bounds and offset.

    rc.left     = 0;
    rc.right    = lBarLocation;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].x   = m_lCurSlideDist;
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 0;
    m_cbndsDirty++;

    // Input B bounds and offset.

    rc.left     = lBarLocation;
    rc.right    = m_sizeInput.cx;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].x   = -lBarLocation;
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 1;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTSlideBase::_CalcFullBoundsPush


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_CalcFullBoundsSwap
//
//------------------------------------------------------------------------------
HRESULT
CDXTSlideBase::_CalcFullBoundsSwap()
{
    long    lInvSlideDist   = m_sizeInput.cx - m_lCurSlideDist;
    RECT    rc;

    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    // Input A bounds and offset.

    rc.left     = 0;
    rc.right    = lInvSlideDist;

    if (m_lCurSlideDist < lInvSlideDist)
    {
        m_aptOffset[m_cbndsDirty].x = m_lCurSlideDist;
    }
    else
    {
        m_aptOffset[m_cbndsDirty].x = lInvSlideDist;
    }

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 0;
    m_cbndsDirty++;

    // Input B bounds and offset.

    rc.left     = lInvSlideDist;
    rc.right    = m_sizeInput.cx;

    if (m_lCurSlideDist < lInvSlideDist)
    {
        m_aptOffset[m_cbndsDirty].x = -m_lCurSlideDist; 
    }
    else
    {
        m_aptOffset[m_cbndsDirty].x = -lInvSlideDist;
    }

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 1;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTSlideBase::_CalcFullBoundsSwap


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_CalcOptBoundsHide
//
//  Overview:   This method calculates one or two sets of bounds that represent 
//              the changes that need to be made to the previous output to bring
//              it up to the current progress.
//
//              The area represting the sliding portion of Input A will always
//              be generated along with it's new offset.  
//
//              If progress has decreased, a set of bounds will be generated
//              to update only the portion that has been newly uncovered which
//              is possible because the Input B portion is stationary during 
//              the duration of the effect.
//
//              lBarLocation: When this transform is in hide mode, Input A moves
//              from right to left over the top of input B.  Since the 
//              m_lCurSlideDist moves from left to right, the method calculates
//              lBarLocation to represent the right edge of Input A at the
//              current progress.  
//
//              Progress decreased:             Progress Increased:
//
//              AAABBBB----                     AAAAAAA----
//              AAABBBB----                     AAAAAAA----
//              AAABBBB----                     AAAAAAA----
//              AAABBBB----                     AAAAAAA----
//                 ^   ^                           ^   ^
//                 |   |-- lPrevBarLocation        |   |-- lBarLocation
//                 |                               |
//                 |---- lBarLocation              |---- lPrevBarLocation    
//
//              - = Pixels that don't need to be updated.
//
//
//              Note:  All coordinates are calculated in output space coordinates
//              assuming that 1) the output surface is the same size as the input
//              surface(s), 2) the output is placed at {0, 0} and 3) the ouput is
//              not clipped. Bounds will be transformed to input space, clipped,
//              or offset to support placement by the WorkProc method.
//
//------------------------------------------------------------------------------
HRESULT
CDXTSlideBase::_CalcOptBoundsHide()
{
    long    lBarLocation        = m_sizeInput.cx - m_lCurSlideDist;
    long    lPrevBarLocation    = m_sizeInput.cx - m_lPrevSlideDist;
    RECT    rc;

    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    // Input A bounds and offset.

    rc.left     = 0;
    rc.right    = lBarLocation;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_aptOffset[m_cbndsDirty].x   = m_lCurSlideDist;
    m_aptOffset[m_cbndsDirty].y   = 0;
    m_alInputIndex[m_cbndsDirty]  = 0;
    m_cbndsDirty++;

    // Input B bounds and offset.

    if (lBarLocation < lPrevBarLocation)
    {
        rc.left     = lBarLocation;
        rc.right    = lPrevBarLocation;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_aptOffset[m_cbndsDirty].x   = 0;
        m_aptOffset[m_cbndsDirty].y   = 0;
        m_alInputIndex[m_cbndsDirty]  = 1;
        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTSlideBase::_CalcOptBoundsHide


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_CalcBounds
//
//  Arguments:  offset  the first visible pixel of an image in the output 
//                      buffer, from the start of image.
//
//              width   number of pixels of an image visible in the output 
//                      buffer.
//
//------------------------------------------------------------------------------
void 
CDXTSlideBase::_CalcBounds(long & offsetA, long & offsetB, long & widthA, 
                           long & widthB)
{
    long lInvSlideDist = m_sizeInput.cx - m_lCurSlideDist;

    //long slideDist = (long)(m_sizeInput.cx * m_Progress + 0.5F);

    switch(m_eSlideStyle)
    {
    case CRSS_HIDE:
        offsetA = m_lCurSlideDist;
        widthA  = lInvSlideDist;
        offsetB = lInvSlideDist;
        widthB  = m_lCurSlideDist;

        break;

    case CRSS_PUSH:
        offsetA = m_lCurSlideDist;
        widthA  = lInvSlideDist;
        offsetB = 0;
        widthB  = m_lCurSlideDist;

        break;

    case CRSS_SWAP:
        if(m_lCurSlideDist < lInvSlideDist)
        {
            offsetA = m_lCurSlideDist;
            widthA  = lInvSlideDist;
            offsetB = lInvSlideDist - m_lCurSlideDist;
        // same as: = m_sizeInput.cx - (2 * m_lCurSlideDist);
            widthB  = m_lCurSlideDist;
        }
        else
        {
            offsetA = lInvSlideDist;
            widthA  = lInvSlideDist;
            offsetB = 0;
            widthB  = m_lCurSlideDist;            
        }

        break;

    default:
        _ASSERT(0);

        break;
    }
}
//  CDXTSlideBase::_CalcBounds


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSlideBase::OnSetup(DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    CDXDBnds    bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsIn.GetXYSize(m_sizeInput);

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTSlideBase::OnSetup


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSlideBase::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                             CDXDVec & InVec)
{
    HRESULT     hr          = S_OK;
    BOOL        bFoundIt    = FALSE;
    long        pickX       = OutPoint.Left();
    long        pickY       = OutPoint.Top();
    long        offsetA     = 0;
    long        offsetB     = 0;
    long        widthA      = 0;
    long        widthB      = 0;
    long        iBand       = 0;
    
    if ((OutPoint.Left() < 0) || (OutPoint.Left() >= m_sizeInput.cx))
    {
        return S_FALSE;
    }

    _CalcBounds(offsetA, offsetB, widthA, widthB);

    iBand = pickY * m_cBands / m_sizeInput.cy;

    // Create an adjusted output point to be used for
    // the rest of the calculations.
    CDXDBnds    AdjustedOutPoint(OutPoint);
    POINT       pt={OutPoint.Left(), OutPoint.Top()};

    if (iBand&1) // odd bands
    {
        offsetA = m_sizeInput.cx - offsetA - widthA;
        offsetB = m_sizeInput.cx - offsetB - widthB;

        if (pickX < widthB)
        {
            ulInputIndex = 1;
            pt.x += offsetB;
        }
        else
        {
            ulInputIndex = 0;
            pt.x -= (widthB - offsetA);
        }
    }
    else // even bands (including the case of a single band)
    {
        if (pickX < widthA)
        {
            ulInputIndex = 0;
            pt.x += offsetA;
        }
        else
        {
            ulInputIndex = 1;
            pt.x -= (widthA - offsetB);
        }
    }
    
    AdjustedOutPoint.SetXYPoint(pt);
    
    // The following code was copied from the base class and 
    // modified to use AdjustedOutPoint and the appropriate
    // variable names for this function.

    if (HaveInput(ulInputIndex))
    {
        CDXDBnds Out2InBnds(false);
        hr = MapBoundsOut2In(0, &AdjustedOutPoint, ulInputIndex, &Out2InBnds);
        if (SUCCEEDED(hr))
        {
            CDXDBnds InSurfBnds(InputSurface(ulInputIndex), hr);
            if (SUCCEEDED(hr) && InSurfBnds.IntersectBounds(Out2InBnds))
            {
                IDXARGBReadPtr * pPtr;
                hr = InputSurface(ulInputIndex)->LockSurface(&InSurfBnds, m_ulLockTimeOut, DXLOCKF_READ, 
                                                        IID_IDXARGBReadPtr, (void **)&pPtr, NULL);
                if( SUCCEEDED(hr) )
                {
                    DXPMSAMPLE val;
                    pPtr->UnpackPremult(&val, 1, FALSE);
                    pPtr->Release();
                    if ( val.Alpha )
                    {
                        InSurfBnds.GetMinVector(InVec);
                        bFoundIt = TRUE;
                    }
                }
            }   
        }
    }
    if (SUCCEEDED(hr) & (!bFoundIt))
    {
        hr = S_FALSE;
    }

    return hr;
} 
//  CDXTSlideBase::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTSlideBase::OnInitInstData(CDXTWorkInfoNTo1 & WorkInfo, 
                              ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;

    // Reset number of dirty bounds.

    m_cbndsDirty = 0;

    // Calculate m_lCurBarLoc.

    m_lCurSlideDist = (long)(m_sizeInput.cx * m_Progress + 0.5);

    // If only one band is used, we can optimize the transform using the
    // bounds functions.

    if (1 == m_cBands)
    {
        // If the inputs, output, or transform is dirty, or if we can't optimize we 
        // have to entirely redraw the output surface.  Otherwise we can create 
        // optimized dirty bounds.

        if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
            || IsTransformDirty() || DoOver() || !m_fOptimize
            || !m_fOptimizationPossible)
        {
            // If something is dirty, calculate bounds that will cover the 
            // full output area of the transform.  If "blend with output" is
            // set, this will always be the case.  (As long as the caller
            // has dirtied the output appropriately.)

            switch (m_eSlideStyle)
            {
            case CRSS_HIDE:
                hr = _CalcFullBoundsHide();

                break;

            case CRSS_PUSH:
                hr = _CalcFullBoundsPush();

                break;

            case CRSS_SWAP:
                hr = _CalcFullBoundsSwap();

                break;

            default:
                _ASSERT(0);

                break;
            } // switch (m_eSlideStyle)
        }
        else // We can create optimized bounds.
        {
            // If the slide distance hasn't changed, nothing needs to be 
            // updated.

            if (m_lCurSlideDist == m_lPrevSlideDist)
            {
                goto done;
            }

            switch (m_eSlideStyle)
            {
            case CRSS_HIDE:
                hr = _CalcOptBoundsHide();

                break;

            case CRSS_PUSH:
                hr = _CalcFullBoundsPush();

                break;

            case CRSS_SWAP:
                hr = _CalcFullBoundsSwap();

                break;

            default:
                _ASSERT(0);

                break;
            } // switch (m_eSlideStyle)
        } // We can create optimized bounds.
    } // if (1 == m_cBands)

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the
    // DoBnds to that of the input(s).

    if (((LONG)WorkInfo.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WorkInfo.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::WorkProc, CDXBaseNTo1
//
//  Description:    This function is used to calculate the result based on the 
//                  specified bounds and the current effect progress.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSlideBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    if (1 == m_cBands)
    {
        hr = _WorkProc_Optimized(WI, pbContinue);
    }
    else
    {
        hr = _WorkProc_Multiband(WI, pbContinue);
    }

    return hr;
}
//  CDXTSlideBase::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_WorkProc_Optimized
//
//  Description:    This function is used to calculate the result based on the 
//                  specified bounds and the current effect progress.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSlideBase::_WorkProc_Optimized(const CDXTWorkInfoNTo1 & WI, 
                                   BOOL * pbContinue)
{
    HRESULT hr      = S_OK;
    DWORD   dwFlags = 0;
    ULONG   i       = 0;

    long    lInOutOffsetX = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }


    for (i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;

        if (bndsSrc.IntersectBounds(WI.DoBnds, m_abndsDirty[i]))
        {
            bndsDest = bndsSrc;

            bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

            bndsSrc.Offset(m_aptOffset[i].x, m_aptOffset[i].y, 0, 0);

            hr = DXBitBlt(OutputSurface(), bndsDest,
                          InputSurface(m_alInputIndex[i]), bndsSrc,
                          dwFlags, INFINITE);

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTSlideBase::_WorkProc_Optimized


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::_WorkProc_Multiband
//
//  Description:    This function is used to calculate the result based on the 
//                  specified bounds and the current effect progress.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSlideBase::_WorkProc_Multiband(const CDXTWorkInfoNTo1 & WI, 
                                   BOOL * pbContinue)
{
    HRESULT hr          = S_OK;

    long    y           = 0;
    long    lOffsetA    = 0;
    long    lOffsetB    = 0;
    long    lWidthA     = 0;
    long    lWidthB     = 0;
    long    lDoWidth    = WI.DoBnds.Width();
    long    lDoHeight   = WI.DoBnds.Height();

    DXPMSAMPLE *    pRowBuff    = NULL;
    DXPMSAMPLE *    pOutBuff    = NULL;

    DXDITHERDESC    dxdd;

    CComPtr<IDXARGBReadPtr> pInA;
    CComPtr<IDXARGBReadPtr> pInB;
    CComPtr<IDXARGBReadWritePtr> pOut;

    // Lock input 0. Need to lock the whole surface instead of only within 
    // DoBnds.

    hr = InputSurface(0)->LockSurface(NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, (void**)&pInA, 
                                      NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Lock input 1.  Need to lock the whole surface instead of only within 
    // DoBnds.

    hr = InputSurface(1)->LockSurface(NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, (void**)&pInB, 
                                      NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Lock output surface.

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, 
                                      (void**)&pOut, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Allocate buffer for a row of the entire image (not just within the 
    // clip bounds.)

    pRowBuff = DXPMSAMPLE_Alloca(m_sizeInput.cx);

    // Allocate output buffer if needed.

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca( lDoWidth );
    }

    //  Set up the dither structure.

    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = pRowBuff;
        dxdd.cSamples       = lDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    _CalcBounds(lOffsetA, lOffsetB, lWidthA, lWidthB);

    for (y = 0; *pbContinue && (y < lDoHeight); y++)
    {
        long iBand = (y + WI.DoBnds.Top()) * m_cBands / m_sizeInput.cy;

        if (iBand & 1)
        {
            // If there are multiple bands, the odd bands slide in the opposite
            // direction as the even bands.

            // Get the B samples.

            if (lWidthB > 0)
            {
                pInB->MoveToXY(m_sizeInput.cx - lOffsetB - lWidthB, 
                               y + WI.DoBnds.Top());
                pInB->UnpackPremult(pRowBuff, lWidthB, FALSE);
            }

            // Get the A samples.

            if (lWidthA > 0)
            {
                pInA->MoveToXY(m_sizeInput.cx - lOffsetA - lWidthA, 
                               y + WI.DoBnds.Top());
                pInA->UnpackPremult(pRowBuff + lWidthB, lWidthA, FALSE);
            }
        }
        else
        {
            // Even bands (including the case of a single band.)

            // get the A samples
            if (lWidthA > 0)
            {
                pInA->MoveToXY(lOffsetA, y + WI.DoBnds.Top());
                pInA->UnpackPremult(pRowBuff, lWidthA, FALSE);
            }

            // get the B samples
            if (lWidthB > 0)
            {
                pInB->MoveToXY(lOffsetB, y + WI.DoBnds.Top());
                pInB->UnpackPremult(pRowBuff + lWidthA, lWidthB, FALSE);
            }

        }

        // Truncate the row of output image to the portion within the clip 
        // bound.

        if (lDoWidth < m_sizeInput.cx)
        {
            long i = 0;

            for (; i < lDoWidth; i++)
            {
                pRowBuff[i] = pRowBuff[i + WI.DoBnds.Left()];
            }
        }

        // Move to the correct output row.

        pOut->MoveToRow(y);

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            pOut->OverArrayAndMove(pOutBuff, pRowBuff, lDoWidth);
        }
        else
        {
            pOut->PackPremultAndMove(pRowBuff, lDoWidth);
        }
    } // End for

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTSlideBase::_WorkProc_Multiband


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTSlideBase::OnFreeInstData(CDXTWorkInfoNTo1 & WorkInfo)
{
    m_lPrevSlideDist = m_lCurSlideDist;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTSlideBase::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::get_bands, ICrSlide
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTSlideBase::get_bands(short * pVal)
{
    HRESULT hr = S_OK;

    if (!pVal)
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_cBands;
    }

    return hr;
}
//  CDXTSlideBase::get_bands, ICrSlide


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::put_bands, ICrSlide
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTSlideBase::put_bands(short newVal)
{
    if (newVal > 0 && newVal < 101)
    {
        if (m_cBands != newVal)
        {
            Lock();
            m_cBands = newVal;
            SetDirty();
            Unlock();
        }
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}
//  CDXTSlideBase::put_bands, ICrSlide


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::get_slideStyle, ICrSlide
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTSlideBase::get_slideStyle(BSTR * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    switch (m_eSlideStyle)
    {
    case CRSS_HIDE:
        *pVal = SysAllocString(L"HIDE");

        break;

    case CRSS_PUSH:
        *pVal = SysAllocString(L"PUSH");

        break;

    case CRSS_SWAP:
        *pVal = SysAllocString(L"SWAP");

        break;

    default:
        _ASSERT(0);

        break;
    }

    if (NULL == pVal)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTSlideBase::get_slideStyle, ICrSlide


//+-----------------------------------------------------------------------------
//
//  CDXTSlideBase::put_slideStyle, ICrSlide
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTSlideBase::put_slideStyle(BSTR newVal)
{
    CRSLIDESTYLE    eNewStyle;

    if (!newVal)
    {
        return E_POINTER;
    }


    if(!_wcsicmp(newVal, L"HIDE"))
    {
        eNewStyle = CRSS_HIDE;
    }
    else if(!_wcsicmp(newVal, L"PUSH"))
    {
        eNewStyle = CRSS_PUSH;
    }
    else if(!_wcsicmp(newVal, L"SWAP"))
    {
        eNewStyle = CRSS_SWAP;
    }
    else
    {
        return E_INVALIDARG;
    }

    if (eNewStyle != m_eSlideStyle)
    {
        Lock();
        m_eSlideStyle = eNewStyle;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CDXTSlideBase::put_slideStyle, ICrSlide
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\spiral.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:		spiral.h
//
// Created:		06/25/98
//
// Author:		phillu
//
// Discription:		This is the header file for the CrSpiral transform.
//
// 05/01/99 a-matcal    Optimized.  Derived from CGridBase.
// 10/24/99 a-matcal    Changed CSpiral class to CDXTSpiralBase and created two
//                      new classes CDXTSpiral and CDXTSpiralOpt to represent  
//                      non-optimized and optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRSPIRAL_H_
#define __CRSPIRAL_H_

#include "resource.h"
#include "gridbase.h"




class ATL_NO_VTABLE CDXTSpiralBase : 
    public CGridBase,
    public IDispatchImpl<ICrSpiral, &IID_ICrSpiral, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTSpiralBase>,
    public IObjectSafetyImpl2<CDXTSpiralBase>,
    public ISpecifyPropertyPagesImpl<CDXTSpiralBase>
{
private:

    CComPtr<IUnknown> m_cpUnkMarshaler;

    // CGridBase overrides

    HRESULT OnDefineGridTraversalPath();

public:

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTSpiralBase)
        COM_INTERFACE_ENTRY(ICrSpiral)
        COM_INTERFACE_ENTRY(IDXTGridSize)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTSpiralBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTSpiralBase)
        PROP_ENTRY("gridSizeX"       , 1, CLSID_CrSpiralPP)
        PROP_ENTRY("gridSizeY"       , 2, CLSID_CrSpiralPP)
        PROP_PAGE(CLSID_CrSpiralPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // IDXTGridSize, ICrSpiral

    DECLARE_IDXTGRIDSIZE_METHODS()

    // IDXEffect

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTSpiral :
    public CDXTSpiralBase,
    public CComCoClass<CDXTSpiral, &CLSID_CrSpiral>,
    public IPersistStorageImpl<CDXTSpiral>,
    public IPersistPropertyBagImpl<CDXTSpiral>
{
public:

    CDXTSpiral()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTSPIRAL)
    DECLARE_POLY_AGGREGATABLE(CDXTSpiral)

    BEGIN_COM_MAP(CDXTSpiral)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTSpiralBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTSpiralOpt :
    public CDXTSpiralBase,
    public CComCoClass<CDXTSpiralOpt, &CLSID_DXTSpiral>,
    public IPersistStorageImpl<CDXTSpiralOpt>,
    public IPersistPropertyBagImpl<CDXTSpiralOpt>
{
public:

    CDXTSpiralOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTSPIRALOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTSpiralOpt)

    BEGIN_COM_MAP(CDXTSpiralOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTSpiralBase)
    END_COM_MAP()
};


#endif //__CRSPIRAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\stretch.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:                stretch.cpp
//
// Created:                 06/23/98
//
// Author:                  PhilLu
//
// Discription:             This file implements the Stretch transform.
//
// History
//
// 06/23/98 phillu      initial creation.
// 07/02/98 phillu      return E_INVALIDARG rather than an error string; check 
//                      for E_POINTER.
// 07/09/98 phillu      implement OnSetSurfacePickOrder().
// 07/13/98 a-matcal    replaced OnSetSurfacePickOrder with OnSurfacePick so 
//                      that the x values of the picked point will be calculated
//                      correctly.
// 07/22/98 phillu      implement clipping.
// 05/10/99 a-matcal    Optimization.
// 05/19/99 a-matcal    Check for out of memory in get_ functions allocating
//                      BSTRs.
// 10/24/99 a-matcal    Changed CStretch class to CDXTStretchBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "stretch.h"

#define DO_STRETCH  0x00010000L




//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::CDXTStretchBase
//
//------------------------------------------------------------------------------
CDXTStretchBase::CDXTStretchBase() :
    m_eStretchStyle(CRSTS_SPIN),
    m_cbndsDirty(0),
    m_lCurStretchWidth(0),
    m_lPrevStretchWidth(0),
    m_fOptimizationPossible(false),
    m_fOptimize(false)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // CDXBaseNTo1 members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTStretchBase::CDXTStretchBase


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTStretchBase::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::_CalcFullBoundsHide
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::_CalcFullBoundsHide()
{
    RECT rc;

    // Bounds for stretched input B area.

    rc.left     = 0;
    rc.top      = 0;
    rc.right    = m_lCurStretchWidth;
    rc.bottom   = m_sizeInput.cy;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

    // If bounds take up entire output, no need to do stretch, just copy all of
    // input B to the output.

    if (m_lCurStretchWidth == m_sizeInput.cx)
    {
        m_alInputIndex[m_cbndsDirty] = 1;
    }
    else // Do stretch.
    {
        m_alInputIndex[m_cbndsDirty] = DO_STRETCH | 1;
    }

    m_cbndsDirty++;

    // Bounds for input A area.

    rc.left     = rc.right;
    rc.right    = m_sizeInput.cx;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_alInputIndex[m_cbndsDirty] = 0;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTStretchBase::_CalcFullBoundsHide


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::_CalcFullBoundsPush
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::_CalcFullBoundsPush()
{
    RECT rc;

    // Bounds for stretched input B area.

    rc.left     = 0;
    rc.top      = 0;
    rc.right    = m_lCurStretchWidth;
    rc.bottom   = m_sizeInput.cy;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

    // If bounds take up entire output, no need to do stretch, just copy all of
    // input B to the output.

    if (m_lCurStretchWidth == m_sizeInput.cx)
    {
        m_alInputIndex[m_cbndsDirty] = 1;
    }
    else // Do stretch.
    {
        m_alInputIndex[m_cbndsDirty] = DO_STRETCH | 1;
    }

    m_cbndsDirty++;

    // Bounds for input A area.

    rc.left     = m_lCurStretchWidth;
    rc.right    = m_sizeInput.cx;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

    // If bounds take up entire output, no need to do stretch, just copy all of
    // input A to the output.

    if (m_lCurStretchWidth == 0)
    {
        m_alInputIndex[m_cbndsDirty] = 0;
    }
    else // Do stretch.
    {
        m_alInputIndex[m_cbndsDirty] = DO_STRETCH;
    }

    m_cbndsDirty++;

    return S_OK;
}
//  CDXTStretchBase::_CalcFullBoundsPush


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::_CalcFullBoundsSpin
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::_CalcFullBoundsSpin()
{
    RECT rc;

    rc.left     = 0;
    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    // If at 0% progress, just copy all of input A to the output.

    if (0 == m_lCurStretchWidth)
    {
        rc.right    = m_sizeInput.cx;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;

        goto done;
    }

    // If at 100% progress, just copy all of input B to the output.

    if (m_sizeInput.cx == m_lCurStretchWidth)
    {
        rc.right    = m_sizeInput.cx;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 1;
        m_cbndsDirty++;

        goto done;
    }

    // Left side solid A.

    rc.right = (m_sizeInput.cx - m_lCurStretchWidth) / 2;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_alInputIndex[m_cbndsDirty] = 0;
    m_cbndsDirty++;

    // Center stretch B.

    rc.left     = rc.right;
    rc.right    = rc.left + m_lCurStretchWidth;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_alInputIndex[m_cbndsDirty] = DO_STRETCH | 1;
    m_cbndsDirty++;

    // Right side solid A.

    rc.left     = rc.right;
    rc.right    = m_sizeInput.cx;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_alInputIndex[m_cbndsDirty] = 0;
    m_cbndsDirty++;

done:

    return S_OK;
}
//  CDXTStretchBase::_CalcFullBoundsSpin


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::_CalcOptBoundsHide
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::_CalcOptBoundsHide()
{
    RECT rc;

    // Bounds for stretched input B area.

    rc.left     = 0;
    rc.top      = 0;
    rc.right    = m_lCurStretchWidth;
    rc.bottom   = m_sizeInput.cy;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

    // If bounds take up entire output, no need to do stretch, just copy all of
    // input B to the output.

    if (m_lCurStretchWidth == m_sizeInput.cx)
    {
        m_alInputIndex[m_cbndsDirty] = 1;
    }
    else // Do stretch.
    {
        m_alInputIndex[m_cbndsDirty] = DO_STRETCH | 1;
    }

    m_cbndsDirty++;

    if (m_lCurStretchWidth < m_lPrevStretchWidth)
    {
        // Bounds for dirty input A area.

        rc.left     = m_lCurStretchWidth;
        rc.right    = m_lPrevStretchWidth;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTStretchBase::_CalcOptBoundsHide


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::_CalcOptBoundsSpin
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::_CalcOptBoundsSpin()
{
    RECT rc;

    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    if (m_lCurStretchWidth < m_lPrevStretchWidth)
    {
        long    lTemp = 0;

        // Left side solid A.

        rc.left     = (m_sizeInput.cx - m_lPrevStretchWidth) / 2;
        rc.right    = (m_sizeInput.cx - m_lCurStretchWidth) / 2;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;

        // Right side solid A.

        lTemp = rc.left;

        rc.left     = rc.right + m_lCurStretchWidth;
        rc.right    = lTemp + m_lPrevStretchWidth;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;
    }

    // Center stretch B.

    rc.left     = (m_sizeInput.cx - m_lCurStretchWidth) / 2;
    rc.right    = rc.left + m_lCurStretchWidth;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_alInputIndex[m_cbndsDirty] = DO_STRETCH | 1;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTStretchBase::_CalcOptBoundsSpin


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::_HorizontalSquish
//
//  Arguments:  bndsSquish  Area on output surface to squish bndsSrc of input 
//                          into.
//              bndsDo      Portion of bndsSquish to actually draw relative to
//                          bndsSquish, must be same height as bndsSquish.
//              pSurfIn     Pointer to input surface.
//              bndsSrc     Portion of input to squish in to bndsSquish area.
//
//              dwFlags     dwFlags for DXBitBlt.
//              ulTimeout   Timeout for DXBitBlt.
//              pfContinue  Let's function know when to abort.
//
//------------------------------------------------------------------------------
HRESULT
CDXTStretchBase::_HorizontalSquish(const CDXDBnds & bndsSquish, const CDXDBnds & bndsDo,
                            IDXSurface * pSurfIn, const CDXDBnds & bndsSrc, 
                            DWORD dwFlags, ULONG ulTimeout, BOOL * pfContinue)
{
    HRESULT hr              = S_OK;
    double  dblSquish2Src   = 0.0;
    ULONG   x               = 0;
    ULONG   y               = 0;
    ULONG   ulHeight        = (ULONG)bndsDo.Height();
    ULONG   ulWidth         = (ULONG)bndsDo.Width();

    DXPMSAMPLE *    pSrcBuffer          = NULL;
    DXPMSAMPLE *    pDestBuffer         = NULL;
    DXPMSAMPLE *    pScratchBuffer      = NULL;
    ULONG *         pulSquish2SrcIndex  = NULL;

    DXDITHERDESC    dxdd;
    CDXDBnds        bndsOutLock;

    CComPtr<IDXARGBReadPtr>         cpIn;
    CComPtr<IDXARGBReadWritePtr>    cpOut;

    // Vertical scaling not supported.  

    _ASSERT(bndsSquish.Height() == bndsSrc.Height());

    // Squishing only, no expanding.

    _ASSERT(bndsSquish.Width() <= bndsSrc.Width());

    // Make sure bndsDo fits in bndsSquish.

    _ASSERT(bndsDo.Left()   >= 0);
    _ASSERT(bndsDo.Top()    == 0);
    _ASSERT(bndsDo.Right()  <= (long)bndsSquish.Width());
    _ASSERT(bndsDo.Bottom() == (long)bndsSquish.Height());

    // Make sure we have an input pointer.

    _ASSERT(pSurfIn != NULL);

    // Get pointer to input surface.

    hr = pSurfIn->LockSurface(&bndsSrc, ulTimeout, DXLOCKF_READ, 
                              IID_IDXARGBReadPtr, (void **)&cpIn, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Calculate output lock bounds.

    bndsOutLock[DXB_X].Min = bndsSquish[DXB_X].Min + bndsDo[DXB_X].Min;
    bndsOutLock[DXB_X].Max = bndsSquish[DXB_X].Min + bndsDo[DXB_X].Max;
    bndsOutLock[DXB_Y].Min = bndsSquish[DXB_Y].Min + bndsDo[DXB_Y].Min;
    bndsOutLock[DXB_Y].Max = bndsSquish[DXB_Y].Min + bndsDo[DXB_Y].Max;

    // Get pointer to output surface.

    hr = OutputSurface()->LockSurface(&bndsOutLock, ulTimeout,
                                      DXLOCKF_READWRITE, 
                                      IID_IDXARGBReadWritePtr, (void **)&cpOut,
                                      NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Allocate source buffer.

    pSrcBuffer = DXPMSAMPLE_Alloca(m_sizeInput.cx);

    if (NULL == pSrcBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Allocate destination buffer.

    pDestBuffer = DXPMSAMPLE_Alloca(ulWidth);

    if (NULL == pDestBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Allocate scratch buffer if needed.

    if ((OutputSampleFormat() != DXPF_PMARGB32) && (dwFlags & DXBOF_DO_OVER))
    {
        pScratchBuffer = DXPMSAMPLE_Alloca(ulWidth);
    }

    // Allocate space for squish to source row index.
    // pulSquish2SrcIndex[SquishedColumn] = SourceColumn

    pulSquish2SrcIndex = new ULONG[ulWidth];

    if (NULL == pulSquish2SrcIndex)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Set up dither structure if needed.

    if (dwFlags & DXBOF_DITHER)
    {
        dxdd.x              = bndsSquish.Left() + bndsDo.Left();
        dxdd.y              = bndsSquish.Top() + bndsDo.Top();
        dxdd.pSamples       = pDestBuffer;
        dxdd.cSamples       = ulWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    // Calculate squish ratio.

    dblSquish2Src = (double)bndsSrc.Width() / (double)bndsSquish.Width();

    // Build squish to source row index.

    for (x = bndsDo.Left(); x < (ULONG)bndsDo.Right(); x++)
    {
        pulSquish2SrcIndex[x - bndsDo.Left()] = (ULONG)((double)x * dblSquish2Src);
    }

    // Loop through rows.

    for (y = 0; y < ulHeight; y++)
    {
        cpIn->MoveToRow(y);

        cpIn->UnpackPremult(pSrcBuffer, m_sizeInput.cx, FALSE);

        for (x = 0; x < ulWidth; x++)
        {
            pDestBuffer[x] = pSrcBuffer[pulSquish2SrcIndex[x]];
        }

        cpOut->MoveToRow(y);

        // Dither

        if (dwFlags & DXBOF_DITHER)
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (dwFlags & DXBOF_DO_OVER)
        {
            cpOut->OverArrayAndMove(pScratchBuffer, pDestBuffer, ulWidth);
        }
        else
        {
            cpOut->PackPremultAndMove(pDestBuffer, ulWidth);
        }
    }

done:

    if (pulSquish2SrcIndex)
    {
        delete [] pulSquish2SrcIndex;
    }

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTStretchBase::_HorizontalSquish


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::OnSetup(DWORD dwFlags)
{
    HRESULT hr;

    CDXDBnds InBounds(InputSurface(0), hr);
    if (SUCCEEDED(hr))
    {
        InBounds.GetXYSize(m_sizeInput);
    }
    return hr;

}
//  CDXTStretchBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                        CDXDVec & InVec) 
{
    HRESULT hr = S_OK;

    long lOutX = OutPoint.Left();
    long lOutY = OutPoint.Top();

    //
    // Calculate input surface picked
    //

    long lOffset        = (m_sizeInput.cx - m_lCurStretchWidth) / 2;

    if ( m_eStretchStyle == CRSTS_SPIN )
    {
        if (lOutX >= lOffset && lOutX < m_sizeInput.cx - lOffset)
        {
            ulInputIndex = 1;
        }
        else
        {
            ulInputIndex = 0;
        }
    }
    else
    {
        if (lOutX < m_lCurStretchWidth)
        {
            ulInputIndex = 1;
        }
        else
        {
            ulInputIndex = 0;
        }
    }

    //
    // Calculate input point picked
    //

    IDXARGBReadPtr*         pPtr;
    BOOL                    bFoundIt = FALSE;

    // Recalculate output point if needed

    POINT pt = {lOutX, lOutY};

    if ( 1 == ulInputIndex || m_eStretchStyle == CRSTS_PUSH )
    {
        if ( m_eStretchStyle == CRSTS_SPIN )
        {
            // If in spin mode, reduce output point value
            // by the distance between the left edge and
            // the beginning of input B.

            pt.x -= lOffset;
        }

        if ( 1 == ulInputIndex )
        {
            // If picked on input B, multiply the x coordinate by
            // the ratio of the original width of input B to the
            // currently displayed width of input B

            pt.x = (long)((float)pt.x * ((float)m_sizeInput.cx / (float)m_lCurStretchWidth));
        }
        else
        {
            // If picked on input A and in push mode, reduce the output
            // x value by the distance between the left edge and the beginning
            // of input A.  Then multiply the x coordinate by the ratio
            // of the original width of input A to the currently displayed
            // width of input A.

            pt.x -= m_lCurStretchWidth;
            pt.x =  (long)((float)pt.x * ((float)m_sizeInput.cx / (float)(m_sizeInput.cx - m_lCurStretchWidth)));
        }
    }

    // Create an adjusted output point to be used for
    // the rest of the calculations.

    CDXDBnds AdjustedOutPoint(OutPoint);

    AdjustedOutPoint.SetXYPoint(pt);

    // The following code was copied from the base class and 
    // modified to use AdjustedOutPoint and the appropriate
    // variable names for this function.

    if ( SUCCEEDED(hr) )
    {
        if ( HaveInput(ulInputIndex) )
        {
            CDXDBnds Out2InBnds(false);
            hr = MapBoundsOut2In(0, &AdjustedOutPoint, ulInputIndex, &Out2InBnds);
            if ( SUCCEEDED(hr) )
            {
                CDXDBnds InSurfBnds(InputSurface(ulInputIndex), hr);
                if ( SUCCEEDED(hr) && InSurfBnds.IntersectBounds(Out2InBnds) )
                {
                    IDXARGBReadPtr * pPtr;
                    hr = InputSurface(ulInputIndex)->LockSurface(&InSurfBnds, 
                                                                 m_ulLockTimeOut, 
                                                                 DXLOCKF_READ, 
                                                                 IID_IDXARGBReadPtr, 
                                                                 (void **)&pPtr, 
                                                                 NULL);
                    if( SUCCEEDED(hr) )
                    {
                        DXPMSAMPLE val;
                        pPtr->UnpackPremult(&val, 1, FALSE);
                        pPtr->Release();
                        if ( val.Alpha )
                        {
                            InSurfBnds.GetMinVector(InVec);
                            bFoundIt = TRUE;
                        }
                    }
                }   
            }
        }
    }
    if (SUCCEEDED(hr) & (!bFoundIt))
    {
        hr = S_FALSE;
    }

    return hr;
}
//  CDXTStretchBase::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTStretchBase::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;

    // Reset number of dirty bounds.

    m_cbndsDirty = 0;

    // Calculate current stretch width.

    m_lCurStretchWidth = (long)(m_Progress * m_sizeInput.cx + 0.5);

    // If the inputs, output, or transform is dirty, or if we can't optimize we 
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize
        || !m_fOptimizationPossible)
    {
        switch (m_eStretchStyle)
        {
        case CRSTS_HIDE:
            hr = _CalcFullBoundsHide();

            break;

        case CRSTS_PUSH:
            hr = _CalcFullBoundsPush();

            break;

        case CRSTS_SPIN:
            hr = _CalcFullBoundsSpin();

            break;

        default:
            _ASSERT(0);

            break;
        } // switch (m_eStretchStyle)
    }
    else
    {
        // We can call the functions that will generate bounds that only cover 
        // the dirty areas of the output surface.

        // If the stretch width hasn't changed, nothing needs to be updated.

        if (m_lCurStretchWidth == m_lPrevStretchWidth)
        {
            goto done;
        }

        switch (m_eStretchStyle)
        {
        case CRSTS_HIDE:
            hr = _CalcOptBoundsHide();

            break;

        case CRSTS_PUSH:
            hr = _CalcFullBoundsPush();

            break;

        case CRSTS_SPIN:
            hr = _CalcOptBoundsSpin();

            break;

        default:
            _ASSERT(0);

            break;
        } // switch (m_eStretchStyle)
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTStretchBase::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::WorkProc, CDXBaseNTo1
//
//  Description:    This function is used to calculate the transformed image 
//                  based on the specified bounds and the current effect 
//                  progress.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr      = S_OK;
    DWORD   dwFlags = 0;
    ULONG   i       = 0;

    long    lInOutOffsetX = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }


    for (i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;

        if (bndsSrc.IntersectBounds(WI.DoBnds, m_abndsDirty[i]))
        {
            if (m_alInputIndex[i] & DO_STRETCH)
            {
                long        lInputIndex = m_alInputIndex[i] & (~DO_STRETCH);
                CDXDBnds    bndsDo;

                // Destination bounds.

                bndsDest = bndsSrc;

                bndsDest[DXB_X].Min  = m_abndsDirty[i].Left();
                bndsDest[DXB_X].Max  = m_abndsDirty[i].Right();

                bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

                // Do bounds.

                bndsDo = bndsSrc;
                bndsDo.Offset(-m_abndsDirty[i].Left(), -bndsDo.Top(), 0, 0);

                // Source bounds.

                bndsSrc[DXB_X].Min  = 0;
                bndsSrc[DXB_X].Max  = m_sizeInput.cx;

                hr = _HorizontalSquish(bndsDest, bndsDo, 
                                       InputSurface(lInputIndex), 
                                       bndsSrc, dwFlags, INFINITE, pbContinue);
            }
            else
            {
                bndsDest = bndsSrc;
                bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(m_alInputIndex[i]), bndsSrc,
                              dwFlags, INFINITE);
            }

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTStretchBase::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTStretchBase::OnFreeInstData(CDXTWorkInfoNTo1 & WorkInfo)
{
    m_lPrevStretchWidth = m_lCurStretchWidth;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTStretchBase::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::get_stretchStyle, ICrStretch
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTStretchBase::get_stretchStyle(BSTR * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    switch (m_eStretchStyle)
    {
    case CRSTS_HIDE:
        *pVal = SysAllocString (L"HIDE");
        break;

    case CRSTS_PUSH:
        *pVal = SysAllocString (L"PUSH");
        break;

    case CRSTS_SPIN:
        *pVal = SysAllocString (L"SPIN");
        break;

    default:
        _ASSERT(0);
        break;
    }

    if (NULL == *pVal)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTStretchBase::get_stretchStyle, ICrStretch


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::put_stretchStyle, ICrStretch
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTStretchBase::put_stretchStyle(BSTR newVal)
{
    CRSTRETCHSTYLE eNewStyle = m_eStretchStyle;

    if (!newVal)
    {
        return E_POINTER;
    }

    if (!_wcsicmp(newVal, L"HIDE"))
    {
        eNewStyle = CRSTS_HIDE;
    }
    else if(!_wcsicmp(newVal, L"PUSH"))
    {
        eNewStyle = CRSTS_PUSH;
    }
    else if(!_wcsicmp(newVal, L"SPIN"))
    {
        eNewStyle = CRSTS_SPIN;
    }
    else
    {
        return E_INVALIDARG;
    }

    if (eNewStyle != m_eStretchStyle)
    {
        Lock();
        m_eStretchStyle = eNewStyle;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CDXTStretchBase::put_stretchStyle, ICrStretch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\spiral.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:		spiral.cpp
//
// Created:		06/25/98
//
// Author:		phillu
//
// Discription:		This is the implementation of the CrSpiral transform.
//
// History:
//
// 06/25/98     phillu  initial creation
// 07/01/98     phillu  change CellsPerRow to CellsPerCol in array dim to fix 
//                      overflow bug.
// 07/02/98     phillu  return E_INVALIDARG rather than an error string
// 07/09/98     phillu  implement OnSetSurfacePickOrder().
// 07/23/98     phillu  implement clipping
// 01/25/99     a-matcal    Moved cellsPerCol and cellsPerRow default settings
//                          to FinalConstruct.
// 05/01/99 a-matcal    Optimized.  Derived from CGridBase.
// 10/24/99 a-matcal    Changed CSpiral class to CDXTSpiralBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "spiral.h"




//+-----------------------------------------------------------------------------
//
//  CDXTSpiralBase::FinalConstruct
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSpiralBase::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CGridBase::FinalConstruct();

    if (FAILED(hr))
    {
        return hr;
    }

    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTSpiralBase::FinalConstruct


//+-----------------------------------------------------------------------------
//
//  CDXTSpiralBase::OnDefineGridTraversalPath, CGridBase
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSpiralBase::OnDefineGridTraversalPath()
{
    ULONG   ulCell      = 0;
    ULONG   ulDir       = 0;
    ULONG   ulMax       = m_sizeGrid.cx * m_sizeGrid.cy;
    RECT    rcBnd;

    // Starting x and y coordinates.

    int     x = 0;
    int     y = 0;

    // rcBnd represents the bounds that are not yet covered as the 
    // spiral moves around the matrix.

    rcBnd.left      = 0;
    rcBnd.right     = m_sizeGrid.cx;
    rcBnd.top       = 0;
    rcBnd.bottom    = m_sizeGrid.cy;

    // Traverse matrix and create index.

    while (ulCell < ulMax)
    {
        switch (ulDir)
        {
        case 0: // right

            y = rcBnd.top; // clockwise

            for (x = rcBnd.left; x < rcBnd.right; x++)
            {
                m_paulIndex[ulCell] = (y * m_sizeGrid.cx) + x;
                ulCell++;
            }

            rcBnd.top++;

            break;

        case 1: // down

            x = rcBnd.right - 1; // clockwise

            for (y = rcBnd.top; y < rcBnd.bottom; y++)
            {
                m_paulIndex[ulCell] = (y * m_sizeGrid.cx) + x;
                ulCell++;
            }

            rcBnd.right--;
            
            break;

        case 2: // left

            y = rcBnd.bottom - 1; // clockwise

            for (x = (rcBnd.right - 1); x >= rcBnd.left; x--)
            {
                m_paulIndex[ulCell] = (y * m_sizeGrid.cx) + x;
                ulCell++;
            }

            rcBnd.bottom--;

            break;

        case 3: // up

            x = rcBnd.left; // clockwise

            for (y = (rcBnd.bottom - 1); y >= rcBnd.top; y--)
            {
                m_paulIndex[ulCell] = (y * m_sizeGrid.cx) + x;
                ulCell++;
            }

            rcBnd.left++;

            break;

        default:

            _ASSERT(0);
        }

        // Change to next direction (clockwise).

        ulDir = (ulDir + 1) % 4;

    } // while (ulCell < ulEnd)

    return S_OK;
}
//  CDXTSpiralBase::OnDefineGridTraversalPath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\strips.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  Filename:   strips.cpp
//
//  Overview:   The strips transform.
//
//  Change History:
//  1999/10/01  a-matcal    Created.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "strips.h"




//+-----------------------------------------------------------------------------
//
//  CDXTStrips static variables initialization.
//
//------------------------------------------------------------------------------

const WCHAR * CDXTStrips::s_astrMotion[] = {
    L"leftdown",
    L"leftup",
    L"rightdown",
    L"rightup"
};


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::CDXTStrips
//
//------------------------------------------------------------------------------
CDXTStrips::CDXTStrips() :
    m_eMotion(LEFT_DOWN),
    m_nStripSize(7),
    m_cStripsY(0),
    m_flPrevProgress(0.0F),
    m_flMaxProgress(0.0F),
    m_fNoOp(false),
    m_fOptimizationPossible(false)
{
    long nCurBnds   = 0;

    m_sizeInput.cx  = 0;
    m_sizeInput.cy  = 0;

    // Although they aren't used, the Z and T bounds need to have some area for
    // intersections to work properly.

    for ( ; nCurBnds < (long)BNDSID_MAX; nCurBnds++)
    {
        m_abndsBase[nCurBnds].u.C[DXB_Z].Max = 1.0F;
        m_abndsBase[nCurBnds].u.C[DXB_T].Max = 1.0F;
    }

    // Base class members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTStrips::CDXTStrips


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStrips::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  CDXTStrips::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStrips::OnSetup(DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    CDXDBnds    bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsInput.GetXYSize(m_sizeInput);

    m_cStripsY = (m_sizeInput.cy / m_nStripSize) + 1;

    _CalcStripInfo();

done:

    return hr;
} 
//  CDXTStrips::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTStrips::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest,
                                  ULONG aInIndex[], BYTE aWeight[])
{
    HRESULT hr              = S_OK;
    float   flCurProgress   = m_flMaxProgress * m_Progress;

    long    nCurStrip       = 0;
    long    nCurBnds        = 0;

    CDXDBnds    bndsSrc;
    CDXCBnds    abnds[BNDSID_MAX];

    ulInToTest  = 0;    // No input yet found that corresponds to point.
    aWeight[0]  = 255;  // If found, it should be weighted at 100%.

    for ( ; nCurBnds < BNDSID_MAX ; nCurBnds++)
    {
        abnds[nCurBnds] = m_abndsBase[nCurBnds];

        abnds[nCurBnds].Offset(flCurProgress, 0.0F, 0.0F, 0.0F);
    }

    for ( ; (nCurStrip < m_cStripsY) && !ulInToTest ; nCurStrip++)
    {
        for (nCurBnds = 0 ; (nCurBnds < (long)BNDSID_MAX) && !ulInToTest 
             ; nCurBnds++)
        {
            bndsSrc.Copy(abnds[nCurBnds]);

            if (bndsSrc.IntersectBounds(OutPoint))
            {
                ulInToTest  = 1;
                aInIndex[0] = m_anInputIndex[nCurBnds];
            }
            
            abnds[nCurBnds].Offset(m_vecNextStripOffset);
        }
    }
}
//  CDXTStrips::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTStrips::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    if (IsTransformDirty())
    {
        _CalcStripInfo();
    }
    else if ((m_Progress == m_flPrevProgress) && !IsInputDirty(0) 
             && !IsInputDirty(1) && !IsOutputDirty() && !DoOver()
             && m_fOptimizationPossible)
    {
        // The simplest optimization, make sure we don't do the same thing twice
        // in a row.

        m_fNoOp = true;
    }

    // TODO:  More complex optimization to only update pixels that need it.

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

    return S_OK;
}
//  CDXTStrips::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStrips::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr              = S_OK;
    float   flCurProgress   = m_flMaxProgress * m_Progress;

    DWORD   dwFlags         = 0;
    long    nCurStrip       = 0;
    long    nCurBnds        = 0;

    CDXDVec     vecDo2OutputOffset(WI.OutputBnds.Left() - WI.DoBnds.Left(),
                                   WI.OutputBnds.Top() - WI.DoBnds.Top(), 0, 0);

    CDXDBnds    bndsSrc;
    CDXDBnds    bndsDest;
    CDXCBnds    abnds[BNDSID_MAX];

    // If this has been optimized out, leave function.

    if (m_fNoOp)
    {
        goto done;
    }

    // Copy base bounds to working bounds structures.

    for ( ; nCurBnds < BNDSID_MAX; nCurBnds++)
    {
        abnds[nCurBnds] = m_abndsBase[nCurBnds];

        abnds[nCurBnds].Offset(flCurProgress, 0.0F, 0.0F, 0.0F);
    }

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    // Draw left and right strips then transform the working bounds structures
    // to the next strip row.

    for ( ; nCurStrip < m_cStripsY; nCurStrip++)
    {
        for (nCurBnds = 0 ; nCurBnds < (long)BNDSID_MAX ; nCurBnds++)
        {
            bndsSrc.Copy(abnds[nCurBnds]);

            if (bndsSrc.IntersectBounds(WI.DoBnds))
            {
                bndsDest = bndsSrc;

                bndsDest.Offset(vecDo2OutputOffset);
        
                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(m_anInputIndex[nCurBnds]), bndsSrc,
                              dwFlags, INFINITE);

                if (FAILED(hr))
                {
                    goto done;
                }
            }
            
            abnds[nCurBnds].Offset(m_vecNextStripOffset);
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTStrips::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTStrips::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    m_flPrevProgress    = m_Progress;
    m_fNoOp             = false;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTStrips::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::get_Motion, IDXTStrips
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTStrips::get_Motion(BSTR * pbstrMotion)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrMotion)
    {
        return E_POINTER;
    }

    if (*pbstrMotion != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrMotion = SysAllocString(s_astrMotion[m_eMotion]);

    if (NULL == *pbstrMotion)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTStrips::get_Motion, IDXTStrips


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::put_Motion, IDXTStrips
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTStrips::put_Motion(BSTR bstrMotion)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrMotion)
    {
        return E_POINTER;
    }

    for ( ; i < (int)MOTION_MAX ; i++)
    {
        if (!_wcsicmp(bstrMotion, s_astrMotion[i]))
        {
            break;
        }
    }

    if ((int)MOTION_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eMotion != i)
    {
        m_eMotion = (MOTION)i;

        SetDirty();
    }

    return S_OK;
}
//  CDXTStrips::put_Motion, IDXTStrips


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::_CalcStripInfo
//
//------------------------------------------------------------------------------
void
CDXTStrips::_CalcStripInfo()
{
    float   flStripHeight   = (float)m_sizeInput.cy / (float)m_cStripsY;
    float   flStripPad      = flStripHeight * (float)(m_cStripsY - 1);

    if ((0 == m_sizeInput.cx) || (0 == m_sizeInput.cy))
    {
        goto done;
    }

    //
    // Left portion of strip.
    //

    // Left

    switch(m_eMotion)
    {
    case LEFT_UP:

        m_abndsBase[LEFT].u.C[DXB_X].Min = 0.0F;
        break;

    case LEFT_DOWN:

        m_abndsBase[LEFT].u.C[DXB_X].Min = -flStripPad;
        break;
    
    case RIGHT_UP:

        m_abndsBase[LEFT].u.C[DXB_X].Min = -((float)m_sizeInput.cx 
                                             + (flStripPad * 2.0F));
        break;

    case RIGHT_DOWN:

        m_abndsBase[LEFT].u.C[DXB_X].Min = -((float)m_sizeInput.cx 
                                             + flStripPad);
        break;

    default:

        _ASSERT(false);
    }

    // Top

    m_abndsBase[LEFT].u.C[DXB_Y].Min = 0.0F;

    // Right

    m_abndsBase[LEFT].u.C[DXB_X].Max = m_abndsBase[LEFT].Left() 
                                       + (float)m_sizeInput.cx + flStripPad;

    // Bottom

    m_abndsBase[LEFT].u.C[DXB_Y].Max = flStripHeight;

    //
    // Right portion of strip.
    //

    // Left.

    m_abndsBase[RIGHT].u.C[DXB_X].Min = m_abndsBase[LEFT].Right();

    // Top.

    m_abndsBase[RIGHT].u.C[DXB_Y].Min = 0.0F;

    // Right.

    m_abndsBase[RIGHT].u.C[DXB_X].Max = m_abndsBase[LEFT].Right()
                                        + m_abndsBase[LEFT].Width();

    // Bottom.

    m_abndsBase[RIGHT].u.C[DXB_Y].Max = m_abndsBase[LEFT].Bottom();

    //
    // Input indices related to the left and right bounds and max progress.
    //

    if ((LEFT_DOWN == m_eMotion) || (LEFT_UP == m_eMotion))
    {
        m_anInputIndex[LEFT]    = 0;
        m_anInputIndex[RIGHT]   = 1;
        m_flMaxProgress         = -m_abndsBase[LEFT].Width();
    }
    else
    {
        m_anInputIndex[LEFT]    = 1;
        m_anInputIndex[RIGHT]   = 0;
        m_flMaxProgress         = m_abndsBase[LEFT].Width();
    }

    // Vector to translate bounds for next strip down.

    m_vecNextStripOffset.u.C[DXB_Y] = m_abndsBase[LEFT].Bottom();

    if ((LEFT_DOWN == m_eMotion) || (RIGHT_UP == m_eMotion))
    {
        m_vecNextStripOffset.u.C[DXB_X] = m_abndsBase[LEFT].Bottom();
    }
    else
    {
        m_vecNextStripOffset.u.C[DXB_X] = -m_abndsBase[LEFT].Bottom();
    }

done:

    return;
}
//  CDXTStrips::_CalcStripInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\wave.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    wave.h
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	header file for wave transform implementation CWave
//
// Change History:
//
// 1999/05/20   PhilLu      Move code from dtcss to dxtmsft. New algorithm.
// 1999/12/10   mcalkins    Added support for IDXTClipOrigin interface.
// 2000/02/04   mcalkins    Implement OnSurfacePick method.
// 2000/05/10   mcalkins    Support IObjectSafety appropriately.
//
//------------------------------------------------------------------------------

#ifndef __WAVE_H_
#define __WAVE_H_

#include "resource.h"




class ATL_NO_VTABLE CWave : 
    public CDXBaseNTo1,
    public CComCoClass<CWave, &CLSID_DXTWave>,
    public CComPropertySupport<CWave>,
    public IDispatchImpl<IDXTWave, &IID_IDXTWave, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CWave>,
    public IPersistStorageImpl<CWave>,
    public ISpecifyPropertyPagesImpl<CWave>,
    public IPersistPropertyBagImpl<CWave>,
    public IDXTClipOrigin
{
private:
    long    m_lStrength;
    long    m_cWaves;
    float   m_flPhase;
    float   m_flLightStrength;
    bool    m_fAdd;
    SIZE    m_sizeInput;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    // Helpers
    inline BYTE NClamp(int i)
    {
        return (i < 0 ? 0 : (i > 255 ? 255 : i));
    }

    void _TransformRow(DXSAMPLE *pBuffer, int nWidth, int nHeight, int nRow);

public:

    CWave();

    DECLARE_POLY_AGGREGATABLE(CWave)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_WAVE)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CWave)
        COM_INTERFACE_ENTRY(IDXTWave)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTClipOrigin)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CWave>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CWave)
        PROP_ENTRY("Add",           DISPID_DXTWAVE_ADD,             CLSID_DXTWavePP)
        PROP_ENTRY("Freq",          DISPID_DXTWAVE_FREQ,            CLSID_DXTWavePP)
        PROP_ENTRY("LightStrength", DISPID_DXTWAVE_LIGHTSTRENGTH,   CLSID_DXTWavePP)
        PROP_ENTRY("Phase",         DISPID_DXTWAVE_PHASE,           CLSID_DXTWavePP)
        PROP_ENTRY("Strength",      DISPID_DXTWAVE_STRENGTH,        CLSID_DXTWavePP)
        PROP_PAGE(CLSID_DXTWavePP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides

    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinueProcessing);
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);
    HRESULT DetermineBnds(CDXDBnds & Bnds);

    // IDXTransform methods.

    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTClipOrigin methods.

    STDMETHOD(GetClipOrigin)(DXVEC * pvecClipOrigin);

    // IDXTWave methods

    STDMETHOD(get_Add)(VARIANT_BOOL * pVal);
    STDMETHOD(put_Add)(VARIANT_BOOL newVal);
    STDMETHOD(get_Freq)(long * pval);
    STDMETHOD(put_Freq)(long newVal);
    STDMETHOD(get_LightStrength)(int * pval);
    STDMETHOD(put_LightStrength)(int newVal);
    STDMETHOD(get_Phase)(int * pval);
    STDMETHOD(put_Phase)(int newVal);
    STDMETHOD(get_Strength)(long * pval);
    STDMETHOD(put_Strength)(long newVal);
};

#endif //__WAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\stretch.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:                stretch.h
//
// Created:                 06/23/98
//
// Author:                  PhilLu
//
// Discription:             This file declares CStretch (Stretch Transforms)
//
// 07/13/98 a-matcal    replaced OnSetSurfacePickOrder with OnSurfacePick so 
//                      that the x values of the picked point will be calculated 
//                      correctly.
// 05/10/99 a-matcal    Optimization.
// 10/24/99 a-matcal    Changed CStretch class to CDXTStretchBase and created two
//                      new classes CDXTStretch and CDXTStretchOpt to represent  
//                      non-optimized and optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRSTRETCH_H_
#define __CRSTRETCH_H_

#include "resource.h"

#define MAX_STRETCH_BOUNDS 3

typedef enum CRSTRETCHSTYLE
{
    CRSTS_HIDE,
    CRSTS_PUSH,
    CRSTS_SPIN
} CRSTRETCHSTYLE;




class ATL_NO_VTABLE CDXTStretchBase : 
    public CDXBaseNTo1,
    public IDispatchImpl<ICrStretch, &IID_ICrStretch, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTStretchBase>,
    public IObjectSafetyImpl2<CDXTStretchBase>,
    public ISpecifyPropertyPagesImpl<CDXTStretchBase>
{
private:

    SIZE            m_sizeInput;
    CRSTRETCHSTYLE  m_eStretchStyle;
    long            m_lCurStretchWidth;
    long            m_lPrevStretchWidth;

    CDXDBnds        m_abndsDirty[MAX_STRETCH_BOUNDS];
    long            m_alInputIndex[MAX_STRETCH_BOUNDS];
    ULONG           m_cbndsDirty;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    unsigned    m_fOptimizationPossible : 1;

protected:

    unsigned    m_fOptimize             : 1;

private:

    // Functions to calculate optimized bounds when the entire output needs to
    // be redrawn.

    HRESULT _CalcFullBoundsHide();
    HRESULT _CalcFullBoundsPush();
    HRESULT _CalcFullBoundsSpin();

    // Functions to calculate optimized bounds when only the dirty parts of the
    // output need to be redrawn.  (Push can't be optimized in this way.)

    HRESULT _CalcOptBoundsHide();
    HRESULT _CalcOptBoundsSpin();

    // This function basically does a sort of a crapola horizontal scale where
    // you can only scale smaller, not larger.  It looks fine in action, though.

    HRESULT _HorizontalSquish(const CDXDBnds & bndsSquish, 
                              const CDXDBnds & bndsDo, IDXSurface * pSurfIn, 
                              const CDXDBnds & bndsSrc, DWORD dwFlags, 
                              ULONG ulTimeout, BOOL * pfContinue);

public:

    CDXTStretchBase();

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTStretchBase)
        COM_INTERFACE_ENTRY(ICrStretch)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTStretchBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTStretchBase)
        PROP_ENTRY("stretchStyle"   , 1, CLSID_CrStretchPP)
        PROP_PAGE(CLSID_CrStretchPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides
    
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec); 
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WorkInfo, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WorkInfo);

    // ICrStretch methods

    STDMETHOD(get_stretchStyle)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_stretchStyle)(/*[in]*/ BSTR newVal);

    // IDXEffect methods

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTStretch :
    public CDXTStretchBase,
    public CComCoClass<CDXTStretch, &CLSID_CrStretch>,
    public IPersistStorageImpl<CDXTStretch>,
    public IPersistPropertyBagImpl<CDXTStretch>
{
public:

    CDXTStretch()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTSTRETCH)
    DECLARE_POLY_AGGREGATABLE(CDXTStretch)

    BEGIN_COM_MAP(CDXTStretch)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTStretchBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTStretchOpt :
    public CDXTStretchBase,
    public CComCoClass<CDXTStretchOpt, &CLSID_DXTStretch>,
    public IPersistStorageImpl<CDXTStretchOpt>,
    public IPersistPropertyBagImpl<CDXTStretchOpt>
{
public:

    CDXTStretchOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTSTRETCHOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTStretchOpt)

    BEGIN_COM_MAP(CDXTStretchOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTStretchBase)
    END_COM_MAP()
};


#endif //__CRSTRETCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\wave.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    wave.cpp
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	Implementation the wave transform CWave
//
// Change History:
//
// 1999/05/20   PhilLu      Move code from dtcss to dxtmsft. New implementation
//                          of wave generation algorithm.
// 1999/09/28   mcalkins    Changed property put_ functions to stop checking 
//                          parameters so they'll work like the old version's. 
// 2000/02/04   mcalkins    Implement OnSurfacePick method.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include <math.h>
#include "dxtmsft.h"
#include "Wave.h"

const float gc_PI = 3.14159265359f;


//+-----------------------------------------------------------------------------
//
//  CWave::CWave
//
//------------------------------------------------------------------------------
CWave::CWave():
    m_lStrength(1),
    m_cWaves(3),
    m_flPhase(0.0f),
    m_flLightStrength(1.0f),
    m_fAdd(false)
{
    m_ulMaxImageBands   = 1;
    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;
}
//  CWave::CWave


//+-----------------------------------------------------------------------------
//
//  CWave::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CWave::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CWave::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CWave::get_Add, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::get_Add(VARIANT_BOOL * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    if (m_fAdd)
    {
        *pVal = VARIANT_TRUE;
    }
    else 
    {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}
//  CWave::get_Add, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::put_Add, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::put_Add(VARIANT_BOOL newVal)
{
    if (newVal != VARIANT_TRUE && newVal != VARIANT_FALSE)
    {
        return E_INVALIDARG;
    }

    Lock();
    bool fAdd = false;
    if (newVal == VARIANT_TRUE)
    {
        fAdd = true;
    }

    if (fAdd != m_fAdd)
    {
        m_fAdd = fAdd;
        SetDirty();
    }

    Unlock();
    return S_OK;
}
//  CWave::put_Add, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::get_Freq, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::get_Freq(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }
    *pVal = m_cWaves;
    return S_OK;
}
//  CWave::get_Freq, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::put_Freq, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::put_Freq(long newVal)
{
    if (newVal < 1)
    {
        newVal = 1;
    }

    if (newVal != m_cWaves)
    {
        Lock();
        m_cWaves = newVal;
        SetDirty();
        Unlock();
    }
    return S_OK;
}
//  CWave::put_Freq, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::get_LightStrength, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::get_LightStrength(int * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }
    *pVal = (int)(m_flLightStrength * 100.0f);
    return S_OK;
}
//  CWave::get_LightStrength, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::put_LightStrength, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::put_LightStrength(int newVal)
{
    // This is bad because instead of letting the user know their value is out
    // of range, you just change it for them.  They may or may not get what they
    // expect with a value of 505.  This mimics the behavior of the old filter.

    if (newVal < 0)
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }

    float fVal = (float)newVal * 0.01f;
    if (fVal != m_flLightStrength)
    {
        Lock();
        m_flLightStrength = fVal;
        SetDirty();
        Unlock();
    }
    return S_OK;
}
//  CWave::put_LightStrength, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::get_Phase, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::get_Phase(int * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }
    *pVal = (int)(m_flPhase * 100.0f);
    return S_OK;
}
//  CWave::get_Phase, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::put_Phase, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::put_Phase(int newVal)
{
    // This is how the old filter would parameter check for this particular 
    // property.  It's not necessarily the same as how it checks the other 
    // properties.

    newVal = newVal % 100;

    float fVal = (float)newVal * 0.01f;

    if (fVal != m_flPhase)
    {
        Lock();
        m_flPhase = fVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CWave::put_Phase, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::get_Strength, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::get_Strength(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }
    *pVal = m_lStrength;
    return S_OK;
}
//  CWave::get_Strength, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::put_Strength, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::put_Strength(long newVal)
{
    if (newVal < 0)
    {
        return E_INVALIDARG;
    }

    if (newVal != m_lStrength)
    {
        Lock();
        m_lStrength = newVal;
        SetDirty();
        Unlock();
    }
    return S_OK;
}
//  CWave::put_Strength, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CWave::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                     CDXDVec & InVec)
{
    HRESULT hr = S_OK;

    // compute the sine pattern which controls both the shift and lighting
    // note phase is given in fraction of cycles.
    
    float flCycle   = (float)(m_cWaves * OutPoint.Top()) 
                      / (float)m_sizeInput.cy;
    float flSine    = (float)sin(2.0f * gc_PI * (flCycle + m_flPhase));

    // horizontal offset (left or right)
    
    int nOffset = (int)(flSine * m_lStrength);


    if ((OutPoint.Left() < 0) 
        || (OutPoint.Left() >= (m_sizeInput.cx + (m_lStrength * 2)))
        || (OutPoint.Top() < 0) || (OutPoint.Top() >= m_sizeInput.cy))
    {
        hr = E_INVALIDARG;

        goto done;
    }
    
    OutPoint.GetMinVector(InVec);

    if (((InVec.u.D[DXB_X] - nOffset) < 0) 
        || ((InVec.u.D[DXB_X] - nOffset) >= m_sizeInput.cx))
    {
        hr = DXT_S_HITOUTPUT;
    }
    else
    {
        InVec.u.D[DXB_X] -= nOffset;

        DXSAMPLE                sample;
        CDXDBnds                bndsLock(InVec);
        CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

        hr = InputSurface()->LockSurface(&bndsLock, m_ulLockTimeOut, 
                                         DXLOCKF_READ, __uuidof(IDXARGBReadPtr),
                                         (void **)&spDXARGBReadPtr,
                                         NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

        if (0 == sample.Alpha)
        {
            hr = S_FALSE;
        }
    }
    
done:

    return hr;
}
//  CWave::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CWave::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CWave::OnSetup(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CDXDBnds bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (SUCCEEDED(hr))
    {
        bndsIn.GetXYSize(m_sizeInput);
    }

    return hr;

}
//  CWave::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CWave::DetermineBnds, CDXBaseNTo1
//
//  This overrides the base function so as to map to an output surface larger
//  than the input surface.
//
//------------------------------------------------------------------------------
HRESULT 
CWave::DetermineBnds(CDXDBnds & Bnds)
{
    SIZE size;

    Bnds.GetXYSize(size);
    size.cx += (m_lStrength*2);
    Bnds.SetXYSize(size);
    return S_OK;
} /* CWave::DetermineBnds */


//+-----------------------------------------------------------------------------
//
//  Method: CWave::MapBoundsOut2In, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CWave::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                       ULONG ulInIndex, DXBNDS * pInBounds)
{
    CDXDBnds    bndsInput;

    if ((NULL == pOutBounds) || (NULL == pInBounds))
    {
        return E_POINTER;
    }

    if (ulOutIndex || ulInIndex)
    {
        return E_INVALIDARG;
    }

    if (NULL == InputSurface())
    {
        return E_UNEXPECTED;
    }

    // What we do is expand the bounds to the left and right by half of the
    // strength of the wave and then intersect
    // those bounds with the original input bounds.  This will give us the
    // input bounds needed to calculate the output area.

    *pInBounds = *pOutBounds;

    if (m_lStrength)
    {
        pInBounds->u.D[DXB_X].Min -= m_lStrength;
        pInBounds->u.D[DXB_X].Max += m_lStrength;
    }

    bndsInput.SetXYSize(m_sizeInput);

    ((CDXDBnds *)pInBounds)->IntersectBounds(bndsInput);

    return S_OK;
}
//  Method: CWave::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  CWave::WorkProc, CDXBaseNTo1
//
//  The Wave transform creates a horizontal sine pattern of lighting strength 
//  as well as a sine-patterned shift on each line. Optionally the original 
//  image is added to the transformed image.
//
//------------------------------------------------------------------------------
HRESULT 
CWave::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing)
{
    HRESULT hr      = S_OK;
    int     y       = 0;

    DXSAMPLE *      pOperationBuffer = NULL;
    DXSAMPLE *      pRowInBuffer     = NULL;
    DXPMSAMPLE *    pOutBuff         = NULL;
    DXPMSAMPLE *    pPMBuff          = NULL;

    DXDITHERDESC    dxdd;

    CComPtr<IDXARGBReadWritePtr>    pDest;
    CComPtr<IDXARGBReadPtr>         pSrc;

    const int nOperationBufferWidth = m_sizeInput.cx + (m_lStrength * 2);
    const int nDoWidth              = WI.DoBnds.Width();
    const int nDoHeight             = WI.DoBnds.Height();

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr,
                                      (void**)&pDest, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = InputSurface()->LockSurface(NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);
    if (FAILED(hr)) 
    {
        return hr;
    }

    if (DoOver() && OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(nDoWidth);
    }

    pOperationBuffer = DXSAMPLE_Alloca(nOperationBufferWidth);

    //
    //  Set up the dither structure
    //
    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = &pOperationBuffer[WI.DoBnds.Left()];
        dxdd.cSamples       = nDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    for (y = 0; y < nDoHeight; y++)
    {
        // Move to the correct input row.
        
        pSrc->MoveToRow(WI.DoBnds.Top() + y);
        
        // Read an input line to the operation buffer.     
        
        pSrc->Unpack(&pOperationBuffer[m_lStrength], m_sizeInput.cx, FALSE);

        // Transform this row of pixels.
        
        _TransformRow(pOperationBuffer, nOperationBufferWidth, m_sizeInput.cy, 
                      WI.DoBnds.Top() + y);

        // Move to appropriate output row.
        
        pDest->MoveToRow(y);

        // Dither if requested.
        
        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        // Blit row to output.
        
        if (DoOver())
        {
            pPMBuff = DXPreMultArray(&pOperationBuffer[WI.DoBnds.Left()], 
                                     nDoWidth);
                                     
            pDest->OverArrayAndMove(pOutBuff, pPMBuff, nDoWidth);
        }
        else
        {
            pDest->PackAndMove(&pOperationBuffer[WI.DoBnds.Left()], nDoWidth);
        }

    }

    return hr;
}
//  CWave::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method:  CWave::GetClipOrigin, IDXTClipOrigin
//
//------------------------------------------------------------------------------
STDMETHODIMP
CWave::GetClipOrigin(DXVEC * pvecClipOrigin)
{
    if (NULL == pvecClipOrigin)
    {
        return E_POINTER;
    }

    pvecClipOrigin->u.D[DXB_X] = m_lStrength;
    pvecClipOrigin->u.D[DXB_Y] = 0;

    return S_OK;
}
//  Method:  CWave::GetClipOrigin, IDXTClipOrigin


//+-----------------------------------------------------------------------------
//
//  CWave::_TransformRow
//
//  On entry, pBuffer contains a row of input pixels (placed at the middle of 
//  the array, with an offset of m_Strength from the start of array). The
//  first and last m_Strength elements of pBuffer are unspecified.
//
//  On return, pBuffer will contain a row of transformed image which is the 
//  input row shifted horizontally and modulated with a sine lighting pattern. 
//  Optionally the original input row is added to the transformed row.
//
//------------------------------------------------------------------------------
void 
CWave::_TransformRow(DXSAMPLE *pBuffer, int nWidth, int nHeight, int nRow)
{
    // compute the sine pattern which controls both the shift and lighting
    // note phase is given in fraction of cycles.
    
    float flCycle   = (float)(m_cWaves * nRow) / (float)nHeight;
    float flSine    = (float)sin(2.0f * gc_PI * (flCycle + m_flPhase));

    // horizontal offset (left or right)
    
    int nOffset = (int)(flSine * m_lStrength);
    
    // lighting weight: always in [0,1], maximum 1
    
    float flWeight = 1.0f - 0.5f * m_flLightStrength * (1.0f - flSine);

    int         nCount, nIndex, nInc, i;
    DXSAMPLE    pix;

    // shift and add the pixels to the original array. Either go forwards
    // or backwards to ensure a source pixel is not ovewritten before used.
    
    if (nOffset <= 0)
    {
        nIndex = -nOffset;
        nInc = 1;
        nCount = nWidth+nOffset;
    }
    else
    {
        nIndex = nWidth-1-nOffset;
        nInc = -1;
        nCount = nWidth-nOffset;
    }

    // The first and last m_lStrength elements of pBuffer are unspecified.
    // Fill in 0 values
    
    for (i=0; i<m_lStrength; i++)
    {
        pBuffer[i] = 0;
        pBuffer[nWidth-1-i] = 0;
    }

    while (nCount > 0)
    {
        DXSAMPLE pix = pBuffer[nIndex];
        if (m_fAdd)
        {
            DXSAMPLE srcPix = pBuffer[nIndex + nOffset];
            pix.Red = NClamp((int)(pix.Red * flWeight) + srcPix.Red);
            pix.Green = NClamp((int)(pix.Green * flWeight) + srcPix.Green);
            pix.Blue = NClamp((int)(pix.Blue * flWeight) + srcPix.Blue);
            pix.Alpha = max(pix.Alpha, srcPix.Alpha);
        }
        else
        {
            pix.Red = (BYTE)(pix.Red * flWeight);
            pix.Green = (BYTE)(pix.Green * flWeight);
            pix.Blue = (BYTE)(pix.Blue * flWeight);
        }

        pBuffer[nIndex+nOffset] = pix;
        nIndex += nInc;
        nCount--;
    }
}
//  CWave::_TransformRow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\strips.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  Filename:   strips.h
//
//  Overview:   The strips transform.
//
//  Change History:
//  1999/10/01  a-matcal    Created.
//
//------------------------------------------------------------------------------

#ifndef __DXTSTRIPS_H_
#define __DXTSTRIPS_H_

#include "resource.h"   




class ATL_NO_VTABLE CDXTStrips : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTStrips, &CLSID_DXTStrips>,
    public IDispatchImpl<IDXTStrips, &IID_IDXTStrips, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTStrips>,
    public IObjectSafetyImpl2<CDXTStrips>,
    public IPersistStorageImpl<CDXTStrips>,
    public IPersistPropertyBagImpl<CDXTStrips>
{
private:

    typedef enum {
        LEFT_DOWN = 0,
        LEFT_UP,
        RIGHT_DOWN,
        RIGHT_UP,
        MOTION_MAX
    } MOTION;

    MOTION                  m_eMotion;
    static const WCHAR *    s_astrMotion[MOTION_MAX];

    typedef enum {
        LEFT = 0,
        RIGHT,
        BNDSID_MAX
    } BNDSID;

    ULONG                   m_anInputIndex[BNDSID_MAX];
    CDXCBnds                m_abndsBase[BNDSID_MAX];

    long                    m_nStripSize;
    long                    m_cStripsY;
    float                   m_flPrevProgress;
    float                   m_flMaxProgress;
    SIZE                    m_sizeInput;
    CDXCVec                 m_vecNextStripOffset;

    CComPtr<IUnknown>       m_spUnkMarshaler;

    unsigned                m_fNoOp                 : 1;
    unsigned                m_fOptimizationPossible : 1;

    // Helper methods.

    void _CalcStripInfo();

public:

    CDXTStrips();

    DECLARE_POLY_AGGREGATABLE(CDXTStrips)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTSTRIPS)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTStrips)
        COM_INTERFACE_ENTRY(IDXTStrips)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTStrips>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTStrips)
        PROP_ENTRY("motion",    DISPID_DXTSTRIPS_MOTION,    CLSID_DXTStripsPP)
        PROP_PAGE(CLSID_DXTStripsPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);

    // IDXTStrips properties.

    STDMETHOD(get_Motion)(BSTR * pbstrMotion);
    STDMETHOD(put_Motion)(BSTR bstrMotion);

    // IDXEffect properties.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};

#endif //__DXTSTRIPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\zigzag.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:		zigzag.h
//
// Created:		06/25/98
//
// Author:		phillu
//
// Discription:		This is the header file for the CrZigzag transformation
//
// History:
//
// 05/01/99 a-matcal    Reimplemented transform to use the CGridBase class.
// 10/24/99 a-matcal    Changed CZigzag class to CDXTZigZagBase and created two
//                      new classes CDXTZigZag and CDXTZigZagOpt to represent  
//                      non-optimized and optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRZIGZAG_H_
#define __CRZIGZAG_H_

#include "resource.h"      
#include "gridbase.h"




class ATL_NO_VTABLE CDXTZigZagBase : 
    public CGridBase,
    public IDispatchImpl<ICrZigzag, &IID_ICrZigzag, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTZigZagBase>,
    public IObjectSafetyImpl2<CDXTZigZagBase>,
    public ISpecifyPropertyPagesImpl<CDXTZigZagBase>
{
private:

    CComPtr<IUnknown> m_cpUnkMarshaler;

    // CGridBase overrides

    HRESULT OnDefineGridTraversalPath();

public:

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTZigZagBase)
        COM_INTERFACE_ENTRY(ICrZigzag)
        COM_INTERFACE_ENTRY(IDXTGridSize)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTZigZagBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTZigZagBase)
        PROP_ENTRY("gridSizeX"       , 1, CLSID_CrZigzagPP)
        PROP_ENTRY("gridSizeY"       , 2, CLSID_CrZigzagPP)
        PROP_PAGE(CLSID_CrZigzagPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // IDXTGridSize, ICrZigzag

    DECLARE_IDXTGRIDSIZE_METHODS()

    // IDXEffect

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTZigZag :
    public CDXTZigZagBase,
    public CComCoClass<CDXTZigZag, &CLSID_CrZigzag>,
    public IPersistStorageImpl<CDXTZigZag>,
    public IPersistPropertyBagImpl<CDXTZigZag>
{
public:

    CDXTZigZag()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTZIGZAG)
    DECLARE_POLY_AGGREGATABLE(CDXTZigZag)

    BEGIN_COM_MAP(CDXTZigZag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTZigZagBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTZigZagOpt :
    public CDXTZigZagBase,
    public CComCoClass<CDXTZigZagOpt, &CLSID_DXTZigzag>,
    public IPersistStorageImpl<CDXTZigZagOpt>,
    public IPersistPropertyBagImpl<CDXTZigZagOpt>
{
public:

    CDXTZigZagOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTZIGZAGOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTZigZagOpt)

    BEGIN_COM_MAP(CDXTZigZagOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTZigZagBase)
    END_COM_MAP()
};


#endif //__CRZIGZAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by proctexe.rc
//
#define IDS_PROJNAME                    100
#define IDR_DXTADDITIVE                 101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\zigzag.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:		zigzag.cpp
//
// Created:		06/25/98
//
// Author:		phillu
//
// Discription:		This is the implementation of the CrZigzag transform.
//
// History:
//
// 06/25/98     phillu      initial creation
// 07/01/98     phillu      change CellsPerRow to CellsPerCol in array dim to 
//                          fix overflow bug.
// 07/02/98     phillu      return E_INVALIDARG rather than an error string
// 07/19/98     kipo        fixed off-by-one bug in _GridBounds by increasing 
//                          size of stack-allocated array by one. Also checked 
//                          for invalid Y values to avoid wallking off the ends 
//                          of the array.
// 07/23/98     phillu      implement clipping
// 01/25/99     a-matcal    Moved default cellsPerCol and cellsPerRow settings
//                          to FinalConstruct and removed from OnSetup so that
//                          saved property bag settings will not be ignored.
// 05/01/99     a-matcal    Reimplemented transform to use the CGridBase class.
// 10/24/99     a-matcal    Changed CZigzag class to CDXTZigZagBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "zigzag.h"




//+-----------------------------------------------------------------------------
//
//  CDXTZigZagBase::FinalConstruct
//
//------------------------------------------------------------------------------
HRESULT CDXTZigZagBase::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CGridBase::FinalConstruct();

    if (FAILED(hr))
    {
        return hr;
    }

    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTZigZagBase::FinalConstruct


//+-----------------------------------------------------------------------------
//
//  CDXTZigZagBase::OnDefineGridTraversalPath, CGridBase
//
//------------------------------------------------------------------------------
HRESULT 
CDXTZigZagBase::OnDefineGridTraversalPath()
{
    ULONG   ulCell      = 0;
    ULONG   ulDir       = 0;
    ULONG   ulMax       = m_sizeGrid.cx * m_sizeGrid.cy;

    // Starting x and y coordinates.

    int     x = 0;
    int     y = 0;

    // Traverse matrix and create index.

    for (y = 0; y < m_sizeGrid.cy; y++)
    {
        ULONG ulRowStart = y * m_sizeGrid.cx;

        switch (ulDir)
        {
        case 0: // right

            for (x = 0; x < m_sizeGrid.cx; x++)
            {
                m_paulIndex[ulCell] = ulRowStart + x;
                ulCell++;
            }

            break;

        case 1: // left

            for (x = m_sizeGrid.cx - 1; x >= 0; x--)
            {
                m_paulIndex[ulCell] = ulRowStart + x;
                ulCell++;
            }

            break;

        default:

            _ASSERT(0);
        }

        // Change to next direction (clockwise).

        ulDir = (ulDir + 1) % 2;

    } // while (ulCell < ulEnd)

    return S_OK;
}
//  CDXTZigZagBase::OnDefineGridTraversalPath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\inc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <dtbase.cpp>
#include <dxtguid.c>
#include <atlctl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\wheel.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:		wheel.h
//
// Created:		07/06/98
//
// Author:		phillu
//
// Discription:		This is the header file for the CrWheel transformation
//
// 05/20/99 a-matcal    Code scrub.
//
//------------------------------------------------------------------------------

#ifndef __CRWHEEL_H_
#define __CRWHEEL_H_

#include "resource.h"




class ATL_NO_VTABLE CWheel : 
    public CDXBaseNTo1,
    public CComCoClass<CWheel, &CLSID_CrWheel>,
    public IDispatchImpl<ICrWheel, &IID_ICrWheel, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CWheel>,
    public IObjectSafetyImpl2<CWheel>,
    public IPersistStorageImpl<CWheel>,
    public ISpecifyPropertyPagesImpl<CWheel>,
    public IPersistPropertyBagImpl<CWheel>
{
private:

    SIZE    m_sizeInput;
    short   m_sSpokes;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    void _ComputeTrigTables(float fProgress, double *sinAngle, double *cosAngle);
    void _ScanlineIntervals(long width, long height, double *sinAngle,
                            double *cosAngle, long YScanline, long *XBounds);
    void _ClipBounds(long offset, long width, long *XBounds);

public:

    CWheel();

    DECLARE_POLY_AGGREGATABLE(CWheel)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_WHEEL)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CWheel)
        COM_INTERFACE_ENTRY(ICrWheel)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CWheel>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CWheel)
        PROP_ENTRY("spokes"       , 1, CLSID_CrWheelPP)
        PROP_PAGE(CLSID_CrWheelPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, 
                                  ULONG & ulInToTest, ULONG aInIndex[], 
                                  BYTE aWeight[]);

    HRESULT WorkProc(const CDXTWorkInfoNTo1& WI, BOOL * pbContinue);
    HRESULT OnSetup(DWORD dwFlags);

    // ICrWheel methods.

    STDMETHOD(get_spokes)(/*[out, retval]*/ short *pVal);
    STDMETHOD(put_spokes)(/*[in]*/ short newVal);

    // IDXEffect methods.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};

#endif //__CRWHEEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\msft\src\wheel.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:                wheel.cpp
//
// Created:                 07/01/98
//
// Author:                  PhilLu
//
// Discription:             This file implements the Wheel transform.
//
// 07/01/98 phillu      initial creation
// 07/09/98 phillu      implement OnSetSurfacePickOrder().
// 07/23/98 phillu      implement clipping
// 05/20/98 a-matcal    Code scrub.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "wheel.h"

const int MAXBOUNDS = 30;
const int MAXANGLES = 60;
const double gc_PI = 3.14159265358979323846;




//+-----------------------------------------------------------------------------
//
// CWheel::CWheel
//
//------------------------------------------------------------------------------
CWheel::CWheel() :
    m_sSpokes(4)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // CDXBaseNTo1 members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
// CWheel::CWheel


//+-----------------------------------------------------------------------------
//
// CWheel::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT CWheel::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
// CWheel::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
// CWheel::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT CWheel::OnSetup(DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    CDXDBnds    bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsIn.GetXYSize(m_sizeInput);

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
// CWheel::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
// CWheel::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CWheel::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                              ULONG aInIndex[], BYTE aWeight[])
{
    long    alXBounds[MAXBOUNDS];
    double  adblSinAngle[MAXANGLES];
    double  adblCosAngle[MAXANGLES];
    long    i = 0;

    if (m_Progress == 0.0)
    {
        aInIndex[0] = 0;
    }
    else if (m_Progress == 1.0)
    {
        aInIndex[0] = 1;
    }
    else
    {
        // prepare a list of cos and sin of angles

        _ComputeTrigTables(m_Progress, adblSinAngle, adblCosAngle);

        aInIndex[0] = 0;

        if ((OutPoint.Left() >= 0) && (OutPoint.Left() < m_sizeInput.cx) 
            && (OutPoint.Top() >= 0) && (OutPoint.Top() < m_sizeInput.cy))
        {
            _ScanlineIntervals(m_sizeInput.cx, m_sizeInput.cy, adblSinAngle, 
                               adblCosAngle, OutPoint.Top(), alXBounds);
    
            for (i = 0; alXBounds[i] < OutPoint.Left(); i++)
            {
                aInIndex[0] = 1 - aInIndex[0];
            }
        }
    }

    ulInToTest = 1;
    aWeight[0] = 255;
}
// CWheel::OnGetSurfacePickOrder, CDXBaseNTo1

//+-----------------------------------------------------------------------------
//
// CWheel::get_spokes, ICrWheel
//
//------------------------------------------------------------------------------
STDMETHODIMP CWheel::get_spokes(short * pVal)
{
   HRESULT hr = S_OK;

    if (!pVal)
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_sSpokes;
    }

    return hr;
}
// CWheel::get_spokes, ICrWheel


//+-----------------------------------------------------------------------------
//
// CWheel::put_spokes, ICrWheel
//
//------------------------------------------------------------------------------
STDMETHODIMP CWheel::put_spokes(short newVal)
{
    if ((newVal >= 2) && (newVal < 21))
    {
        if (m_sSpokes != newVal)
        {
            m_sSpokes = newVal;
            SetDirty();
        }
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}
// CWheel::put_spokes, ICrWheel


//+-----------------------------------------------------------------------------
//
// CWheel::_ScanlineIntervals
//
// A helper method that calculates the transition boundaries between the
// two image regions on a scanline. Based on the type of transform, the scanline
// consists of a series of alternating A and B image sections. The upper X
// bound of each section is calculated and saved in array XBounds. The number
// of useful entries in XBounds is variable. The end of array is determined
// when one entry equals to the scanline (image) width. It is assumed that
// XBounds[0] is the upper bound of the first A section. So if the scanline
// starts with a B section, XBounds[0] will be 0.
//
// Example 1: scanline length = 16, first section is from A image
//
//    AAAABBBBBAAABBAA      XBounds should contain {4, 9, 12, 14, 16}.
//
// Example 2: scanline length = 16, first section is from B image
//
//    BBBAAAAAABBBBBBB      XBounds should contain {0, 3, 9, 16}.
//
//
// Note: It is possible that some section has length 0 (i.e. two adjacent
//       bounds equal). {3, 9, 9, 16} is equivalent to {3, 16}.
//
// Parameters:
//
// width, height: width and height of both images.
// sinAngle, cosAngle: arrays of sin and cos of radial angles
// YScanline: Y cooridnate (height) of the current scanline
// XBounds: array to hold the computed X bounds on return.
//
//
// Created by: PhilLu    07/06/98
// 
//------------------------------------------------------------------------------
void 
CWheel::_ScanlineIntervals(long width, long height, 
                           double *sinAngle, double *cosAngle,
                           long YScanline, long *XBounds)
{
    long CenterX, CenterY, intercX, i;
    long index = 0;
    double deltaY;
    const double eps = 0.0001;

    // Center of image
    CenterX = width/2;
    CenterY = height/2;

    // plus 0.5 is to make the center in between two lines rather than on a grid.
    // that way the shape will be symmetric
    deltaY = YScanline - CenterY + 0.5;

    if (deltaY < 0)
    {
        XBounds[index++] = 0;
        for(i=1; i<2*m_sSpokes && sinAngle[i] >= 0; ++i)
        {
            if (sinAngle[i] > eps)
            {
                intercX = (long)(CenterX + deltaY*cosAngle[i]/sinAngle[i] + 0.5);
                intercX = min(max(intercX, 0), width);
            }
            else if (cosAngle[i] > 0)
            {
                intercX = 0;
            }
            else
            {
                intercX = width;
            }

            XBounds[index++] = intercX;
        }

        XBounds[index++] = width;
    }
    else // deltaY > 0
    {
        for(i=2*m_sSpokes-1; i>=0 && sinAngle[i] <= 0; --i)
        {
            if (sinAngle[i] < -eps)
            {
                intercX = (long)(CenterX + deltaY*cosAngle[i]/sinAngle[i] + 0.5);
                intercX = min(max(intercX, 0), width);
            }
            else if (cosAngle[i] > 0)
            {
                intercX = 0;
            }
            else
            {
                intercX = width;
            }
            
            XBounds[index++] = intercX;
        }

        XBounds[index++] = width;
    }		
}
// CWheel::_ScanlineIntervals


//+-----------------------------------------------------------------------------
//
// CWheel::_ComputeTrigTables
//
// Overview:    Compute the a list of sin and cos values of the angles. The 
//              arrays should be allocated before calling this function. Their 
//              bounds should be 2 * m_sSpokes.
//
//------------------------------------------------------------------------------
void CWheel::_ComputeTrigTables(float fProgress, double *sinAngle, double *cosAngle)
{
    for(long i=0; i<m_sSpokes; ++i)
    {
        // these angles are measured from 9 o'clock, clockwise
        double startAngle   = (double)i / (double)m_sSpokes * 2 * gc_PI;
        double endAngle     = startAngle + (double)fProgress * 2 * gc_PI / m_sSpokes;
   
        sinAngle[2 * i]     = sin(startAngle);
        cosAngle[2 * i]     = cos(startAngle);
        sinAngle[2 * i + 1] = sin(endAngle);
        cosAngle[2 * i + 1] = cos(endAngle);
    }
}
// CWheel::_ComputeTrigTables


//+-----------------------------------------------------------------------------
//
// CWheel::_ClipBounds
//
//  Overview:   Initially the X-bounds are specified relative to the entire 
//              image. After clipping, the bounds should be transformed to be 
//              relative to the clipping region.
//
//  Arguments:  offset:
//              width:      offset and width of the clipping region (along X)
//              XBounds:    array of X-bounds
//
//  Created by: PhilLu    07/21/98
//
//------------------------------------------------------------------------------
void 
CWheel::_ClipBounds(long offset, long width, long * XBounds)
{
    int i;

    for(i=0; XBounds[i] < offset+width; i++)
    {
        if (XBounds[i] < offset)
            XBounds[i] = 0;
        else
            XBounds[i] -= offset;
    }

    XBounds[i] = width;
}
// CWheel::_ClipBounds


//+-----------------------------------------------------------------------------
//
// CWheel::WorkProc, CDXBaseNTo1
//
//  OverView:   This function is used to calculate the transformed image based 
//              on the specified bounds and the current effect progress.
//
//  Created by: PhilLu    06/22/98
//
//------------------------------------------------------------------------------
HRESULT 
CWheel::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    long    lDoWidth    = WI.DoBnds.Width();
    long    lDoHeight   = WI.DoBnds.Height();
    long    lOutY       = 0;

    long    alXBounds[MAXBOUNDS];   // to hold the X bounds of A/B image sections on a scanline
    double  adblSinAngle[MAXANGLES];
    double  adblCosAngle[MAXANGLES];

    DXPMSAMPLE *    pRowBuff = NULL;
    DXPMSAMPLE *    pOutBuff = NULL;

    DXDITHERDESC dxdd;

    CComPtr<IDXARGBReadPtr>         cpInA;
    CComPtr<IDXARGBReadPtr>         cpInB;
    CComPtr<IDXARGBReadWritePtr>    cpOut;

    hr = InputSurface(0)->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, 
                                      (void **)&cpInA, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = InputSurface(1)->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, 
                                      (void **)&cpInB, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, 
                                      (void **)&cpOut, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    pRowBuff = DXPMSAMPLE_Alloca(lDoWidth);

    // Allocate output buffer if needed.

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(lDoWidth);
    }

    //  Set up the dither structure.

    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = pRowBuff;
        dxdd.cSamples       = lDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    // Prepare a list of cos and sin of angles.

    _ComputeTrigTables(m_Progress, adblSinAngle, adblCosAngle);
  
    for(lOutY = 0; *pbContinue && (lOutY < lDoHeight); lOutY++)
    {
        long lScanLength    = 0;    // Cumulative scan length on the current 
                                    // scanline.
        long i              = 0;

        // Compute the A/B image section bounds.

        if (m_Progress == 0.0F)
        {
            // special case: entire image is from A

            alXBounds[0] = lDoWidth;
        }
        else if (m_Progress == 1.0F)
        {
            // special case: entire image is from B

            alXBounds[0] = 0;
            alXBounds[1] = lDoWidth;
        }
        else
        {
            _ScanlineIntervals(m_sizeInput.cx, m_sizeInput.cy, 
                               adblSinAngle, adblCosAngle,
                               lOutY + WI.DoBnds.Top(), alXBounds);
            _ClipBounds(WI.DoBnds.Left(), lDoWidth, alXBounds);
        }

        // Compose the image.

        while(lScanLength < lDoWidth)
        {
            // Copy a section of A image to output buffer.

            if (alXBounds[i] - lScanLength > 0)
            {
                cpInA->MoveToXY(lScanLength, lOutY);
                cpInA->UnpackPremult(pRowBuff + lScanLength, 
                                     alXBounds[i] - lScanLength, FALSE);
            }

            lScanLength = alXBounds[i++];

            if (lScanLength >= lDoWidth)
            {
                break;
            }

            // Copy a section of B image to output buffer.

            if (alXBounds[i] - lScanLength > 0)
            {
                cpInB->MoveToXY(lScanLength, lOutY);
                cpInB->UnpackPremult(pRowBuff + lScanLength, 
                                     alXBounds[i] - lScanLength, FALSE);
            }

            lScanLength = alXBounds[i++];
        }

        cpOut->MoveToRow(lOutY);

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            cpOut->OverArrayAndMove(pOutBuff, pRowBuff, lDoWidth);
        }
        else
        {
            cpOut->PackPremultAndMove(pRowBuff, lDoWidth);
        }
    } 

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
// CWheel::WorkProc, CDXBaseNTo1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\proctexe.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

!ENDIF

DXTROOT = $(SUBPROJROOT:\proctexe=)
ROOT    = $(SUBPROJROOT:\src\dxt\proctexe=)

# Trident's common.inc says to treat level 4 warnings as errors.  We wish.

WARNING_LEVEL       = W3

PRIVATE_LIB_PATH    = $(_NTBINDIR)\private\lib

!include $(ROOT)\common.inc


USE_ATL=1
ATL_VER=21

!undef USE_MSVCRT

INCLUDES = \
    $(INCLUDES);                \
    $(DXTROOT)\idl\$(O);        \
    $(SUBPROJROOT)\inc;         \
    $(SUBPROJROOT)\src;         \
    $(ROOT)\src\core\include;   \
    $(SHELL_INC_PATH)   \

#C_DEFINES=$(C_DEFINES) -D_DXTRANSIMPL -D_WINDOWS -D_WINDLL

CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
    atlbase.h       \
    atlcom.h        \
    atlctl.h        \
    atlctl.cpp      \
    atlimpl.cpp     \
    macapi.h        \
    macnam1.h       \
    macname2.h      \
    macocidl.h      \
    macpub.h        \
    new             \
    rpcerr.h        \
    rpcmac.h        \
    statreg.cpp     \
    statreg.h       \
    thunk.h         \
    winwlm.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\src\guids.c ===
#include <objbase.h>
#include <initguid.h>

#include <ddraw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\dll\proctexe.cpp ===
// proctexe.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f proctexeps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
//#include <initguid.h>
#include "proctexe.h"

#include "additive.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_DispAdditive, CDXTAdditive)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}

/////////////////////////////////////////////////////////////////////////////
// DllEnumClassObjects

STDAPI DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    if (i >= (sizeof(ObjectMap)/sizeof(ObjectMap[0])) - 1)
    {
        return S_FALSE;
    }

    *pclsid = *(ObjectMap[i].pclsid);
    return _Module.GetClassObject(*pclsid, IID_IUnknown, (LPVOID*)ppUnk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\inc\stdafx.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       stdafx.h
//
//  Overview:       Include file for standard system include files, or project 
//                  specific include files that are used frequently, but are 
//                  changed infrequently.
//
//  Change History:
//  2000/03/15  mcalkins    Added include of w95wraps.h to support unicode on 
//                          Win9x.
//
//------------------------------------------------------------------------------

#if !defined(AFX_STDAFX_H__70E6C6ED_2F0A_4FC6_BAE2_8DFAFA858CE8__INCLUDED_)
#define AFX_STDAFX_H__70E6C6ED_2F0A_4FC6_BAE2_8DFAFA858CE8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _ATL_APARTMENT_THREADED

#include <w95wraps.h>
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <dxtrans.h>
#include <dtbase.h>
#include <dxatlpb.h>

// TODO:  We could probably just change the code and remove these macros.

#define New new
#define Delete delete

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__70E6C6ED_2F0A_4FC6_BAE2_8DFAFA858CE8__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\src\defines.h ===
#define TABSIZE          256
#define TABMASK          (TABSIZE-1)
#define PERM(x)          gPerm[(x)&TABMASK]
#define INDEX(ix,iy,iz)  PERM((ix)+PERM((iy)+PERM(iz)))

#define PROCTEX_LATTICENOISE_LERP               0x01
#define PROCTEX_LATTICENOISE_SMOOTHSTEP         0x02
#define PROCTEX_LATTICENOISE_SPLINE             0x03

#define PROCTEX_LATTICETURBULENCE_LERP          0x11
#define PROCTEX_LATTICETURBULENCE_SMOOTHSTEP    0x12
#define PROCTEX_LATTICETURBULENCE_SPLINE        0x13

#define PROCTEX_MASKMODE_NONE                   0x00
#define PROCTEX_MASKMODE_CHROMAKEY              0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\rsrc\makefile.inc ===
#
# makefile.inc
#
#     Makefile dependency rules for special files not
# automagically processed by BUILD.EXE.
#

proctexe.rc :                        \
    $(DXTROOT)\idl\$(O)\proctexe.tlb \
    additive.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\src\mmx.h ===
#ifndef _INC_MMX_H
#define _INC_MMX_H

		// IsMMXCpu() returns TRUE if the CPU
		// has Intel's MMX technology.
		// Link to the IHammer utils library
		// 
	__declspec(dllexport) BOOL IsMMXCpu( void );
	

#endif // _INC_MMX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\src\iutility.cpp ===
/*
//   IUTILITY.CPP
//
//              INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//
//      Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
//  PVCS:
//      $Workfile$
//      $Revision$
//      $Modtime$
//
//  PURPOSE:
//                                  
//              
//
//  CONTENTS:
*/
#include "stdafx.h"
#include "utility.h"

CProceduralTextureUtility::CProceduralTextureUtility() :
    m_nScaleX(0),
    m_nScaleY(0),
    m_nScaleTime(0),
    m_nHarmonics(0)
{
    ZeroMemory(m_adwValueTable, sizeof(DWORD) * TABSIZE);
}


void CProceduralTextureUtility::_ValueTableInit(int seed)
{
    DWORD *table = m_adwValueTable;
    int i;

    srand(seed);
    for(i = 0; i < TABSIZE; i++) {
		*table++ = (rand()*rand()) & 0xffff;
	}
		
}

STDMETHODIMP
CProceduralTextureUtility::MyInitialize(DWORD dwSeed, DWORD dwFunctionType, 
                                        void *pInitInfo) 
{
    _ValueTableInit(dwSeed);

    switch (dwFunctionType) 
    {
    case PROCTEX_LATTICENOISE_LERP:
    case PROCTEX_LATTICETURBULENCE_LERP:
    case PROCTEX_LATTICENOISE_SMOOTHSTEP:
    case PROCTEX_LATTICETURBULENCE_SMOOTHSTEP:

        m_dwFunctionType = dwFunctionType;
        return S_OK;
        break;

    default:

        m_dwFunctionType = 0;
        return E_INVALIDARG;
        break;
    }

    return E_FAIL;
}


STDMETHODIMP
CProceduralTextureUtility::SetScaling(int nSX, int nSY, int nST) {
	m_nScaleX = nSX;
	m_nScaleY = nSY;
	m_nScaleTime = nST;
	return S_OK;
}

STDMETHODIMP
CProceduralTextureUtility::SetHarmonics(int nHarmonics) {
	m_nHarmonics= nHarmonics;
	return(S_OK);
}

// lerp() expects that x be the fractional 16 bits of a signed 15:16 value
STDMETHODIMP_(DWORD)
CProceduralTextureUtility::Lerp(DWORD a, DWORD b, DWORD x) {
	DWORD ix;
	DWORD rval;

	ix = 0xffff - x;
	rval = x * b  + a * ix;
	return rval;
}

// smoothstep() expects that x be the fractional 16 bits of a signed 15:16 value
STDMETHODIMP_(DWORD)
CProceduralTextureUtility::SmoothStep(DWORD a, DWORD b, DWORD x) {
	DWORD ix;
	DWORD rval;

	x = x >> 8;			// get the high 8 bits for our table lookup
	x = gdwSmoothTable[x];
	ix = 0xffff - x;
	rval = x*b + a*ix;
	return rval;
}

// x, y and t are integer values to start. They are converted to
// signed 15.16 format, and then divided by 2^scale. 
// the value returned by lerpnoise is signed 0.31
STDMETHODIMP_(DWORD)
CProceduralTextureUtility::Noise(DWORD x, DWORD y, DWORD t) {
	DWORD fx, fy, ft;
	DWORD ix, iy, it;
	DWORD v[8];
	DWORD rval;

	x = (x & 0x0ffff) << 16;
	y = (y & 0x0ffff) << 16;
	t = (t & 0x0ffff) << 16;
	
	x = x >> m_nScaleX;	
	y = y >> m_nScaleY;	
	t = t >> m_nScaleTime;	

	fx = x & 0x0ffff;
	fy = y & 0x0ffff;
	ft = t & 0x0ffff;

	ix = (x >> 16);
	iy = (y >> 16);
	it = (t >> 16);

	v[0] = vlattice(ix + 0, iy + 0, it + 0);
	v[1] = vlattice(ix + 1, iy + 0, it + 0);
	v[2] = vlattice(ix + 1, iy + 1, it + 0);
	v[3] = vlattice(ix + 0, iy + 1, it + 0);
	v[4] = vlattice(ix + 0, iy + 0, it + 1);
	v[5] = vlattice(ix + 1, iy + 0, it + 1);
	v[6] = vlattice(ix + 1, iy + 1, it + 1);
	v[7] = vlattice(ix + 0, iy + 1, it + 1);

	switch(m_dwFunctionType) {
		case PROCTEX_LATTICENOISE_LERP:
		case PROCTEX_LATTICETURBULENCE_LERP:
			v[0] = Lerp(v[0], v[4], ft) >> 16;
			v[1] = Lerp(v[1], v[5], ft) >> 16;
			v[2] = Lerp(v[2], v[6], ft) >> 16;
			v[3] = Lerp(v[3], v[7], ft) >> 16;

			v[0] = Lerp(v[0], v[3], fy) >> 16;
			v[1] = Lerp(v[1], v[2], fy) >> 16;

			rval = Lerp(v[0], v[1], fx);
			break;
		case PROCTEX_LATTICENOISE_SMOOTHSTEP:
		case PROCTEX_LATTICETURBULENCE_SMOOTHSTEP:
			v[0] = SmoothStep(v[0], v[4], ft) >> 16;
			v[1] = SmoothStep(v[1], v[5], ft) >> 16;
			v[2] = SmoothStep(v[2], v[6], ft) >> 16;
			v[3] = SmoothStep(v[3], v[7], ft) >> 16;

			v[0] = SmoothStep(v[0], v[3], fy) >> 16;
			v[1] = SmoothStep(v[1], v[2], fy) >> 16;

			rval = SmoothStep(v[0], v[1], fx);
			break;

	}
	return rval;
}

STDMETHODIMP_(int)
CProceduralTextureUtility::Turbulence(DWORD x, DWORD y, DWORD t) {
	int rval = 0;
	int i;
	DWORD	noiseval;
	int		signednoiseval;
	int xscale, yscale, tscale;

	xscale = m_nScaleX;
	yscale = m_nScaleY;
	tscale = m_nScaleTime;

	xscale += m_nHarmonics;
	yscale += m_nHarmonics;
	tscale += m_nHarmonics;

	for (i=0; i<m_nHarmonics; i++) {
		noiseval = Noise(x, y, t);
		xscale--; 
		yscale--; 
		tscale--;
		noiseval = noiseval >> 1;
		signednoiseval = noiseval;
		signednoiseval -= 0x3fffffff;
		signednoiseval = signednoiseval/(i+1);
		rval += signednoiseval;
	}
	return rval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\src\mmx.cpp ===
#include "stdafx.h"
#include "mmx.h"

// Define or undef the following to allow
// HKCU\Software\Microsoft\Internet Explorer  "TestMMX"=DWORD
// We logical AND this reg value with fIsMMX.

#define TEST_MMX

const  int  s_mmxvaruninit = 0xabcd;
static BOOL s_fIsMMX       = s_mmxvaruninit;

// ----------------------------------------------------------------------------------------

__declspec(dllexport)  BOOL    IsMMXCpu( void )
{

    if( s_mmxvaruninit == s_fIsMMX )
    {
		BOOL   fIsMMX = FALSE;

#if _M_IX86 >= 300  // INTEL TARGET
        __try               // THIS REQUIRES THE CRT
        {        
                // The 0x0fA2 opcode was a late addtion to the 486
                // Some 486 and all 386 chips will not have it.
                // Doubt it's emulated.  Execution on these chips will 
                // raise (and handle) EXCEPTION_ILLEGAL_INSTRUCTION.
		    #define _cpuid _emit 0x0f _asm _emit 0xa2
		    _asm {
			    mov eax,1
			    _cpuid
			    and edx, 00800000h
			    mov fIsMMX, edx
		    } // end asm
        }

        __except( EXCEPTION_EXECUTE_HANDLER )
        {            
            fIsMMX = FALSE;  // No 0x0fA2 opcode?  No MMX either!
        }
#endif // END _M_IX86 INTEL TARGET


#ifdef TEST_MMX
		HKEY  hkeyIE;
		if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER,
				   TEXT("Software\\Microsoft\\Internet Explorer"),
				   0u, KEY_READ, &hkeyIE ) )
		{
			DWORD  dwVal = TRUE;
			DWORD  dwType = REG_DWORD;
			DWORD  dwSize = sizeof(dwVal);

			if ( ERROR_SUCCESS == 
				 RegQueryValueEx( hkeyIE, 
								  TEXT("TestMMX"), 
								  NULL, 
								  &dwType, 
								  reinterpret_cast<BYTE*>(&dwVal),
								  &dwSize ) )
			{
				fIsMMX = fIsMMX && dwVal;
			}
		}
#endif // TEST_MMX

        s_fIsMMX = fIsMMX;
    }

    return s_fIsMMX;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\src\additive.h ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       additive.h
//
//  Description:    Intel's additive procedural texture.
//
//  Change History:
//  1999/12/07  a-matcal    Created.
//
//------------------------------------------------------------------------------
#ifndef __ADDITIVE_H_
#define __ADDITIVE_H_

#include "resource.h"

extern DWORD gdwSmoothTable[];
extern DWORD gPerm[];

#include "utility.h"       



class ATL_NO_VTABLE CDXTAdditive : 
    public CProceduralTextureUtility,
    public CDXBaseNTo1,
    public CComCoClass<CDXTAdditive, &CLSID_DispAdditive>,
    public IDispatchImpl<IDispAdditive, &IID_IDispAdditive, &LIBID_PROCTEXELib>,
    public CComPropertySupport<CDXTAdditive>,
    public IObjectSafetyImpl2<CDXTAdditive>,
    public IPersistStorageImpl<CDXTAdditive>,
    public IPersistPropertyBagImpl<CDXTAdditive>,
    public IHTMLDXTransform
{
private:

    CComPtr<IUnknown>       m_spUnkMarshaler;
    CComPtr<IDXSurface>     m_spDXSurfBuffer;

    CDXDBnds                m_bndsInput;

    BSTR                    m_bstrHostUrl;

    //CPROCTEX *m_pObj;
    DWORD * m_valueTab;
    int     m_nSrcWidth;
    int     m_nSrcHeight;
    int     m_nSrcBPP;
    int     m_nDestWidth;
    int     m_nDestHeight;
    int     m_nDestBPP;
    int     m_nNoiseScale;
    int     m_nNoiseOffset;
    int     m_nTimeAnimateX;
    int     m_nTimeAnimateY;
    int     m_nScaleX;
    int     m_nScaleY;
    int     m_nScaleTime;
    int     m_nHarmonics;
    int     m_alphaActive;
    RECT    m_rActiveRect;
    DWORD   m_dwFunctionType;

    DWORD   m_ColorKey;
    DWORD   m_MaskMode;
    void *  m_pMask;
    int     m_nMaskPitch;

    int     m_nMaskHeight;
    int     m_nMaskWidth;
    int     m_nMaskBPP;

    int	    m_nIsMMX;			
    int     m_nPaletteSize;
    void *  m_pPalette;

    DWORD * m_pdwScanArray;
    DWORD   m_dwScanArraySize;

    unsigned char * m_pInitialBuffer;
    int             m_nBufferSize;
    int             m_GenerateSeed;

    void (CDXTAdditive::*m_pGenerateFunction)(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void (CDXTAdditive::*m_pCopyFunction)(void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);

    // CProceduralTextureUtility overrides.

    STDMETHOD(MyInitialize)(DWORD dwSeed, DWORD dwFunctionType, 
                            void * pInitInfo);

    // Helpers.

    void valueTabInit(int seed);
    DWORD vlattice(int ix, int iy, int iz)
    {
	    return m_valueTab[INDEX(ix,iy,iz)];
    }
    DWORD smoothstep(DWORD a, DWORD b, DWORD x) {
	    DWORD ix;
	    DWORD rval;

	    x = x >> 8;			// get the high 8 bits for our table lookup
	    x = gdwSmoothTable[x];
	    ix = 0xffff - x;
	    rval = x*b + a*ix;
	    return rval;
    }

    __inline DWORD smoothnoise      (int x, int y, int nTime, int scalex, int scaley, int scalet);
    __inline DWORD smoothturbulence (int x, int y, int nTime);

    // Generate methods.

    void addsmoothnoise8            (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothnoise8mmx         (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb8             (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb8mmx          (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothnoise16           (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb16            (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb32            (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb8to32mask     (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb8to32mmx      (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb8to32mmxmask  (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);

    // Copy methods.

    void blit8to8                   (void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void blit8to32                  (void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void blit8to32mask              (void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);

    // Old filter base class stuff.

    void setCopyFunction(void);
    void setGenerateFunction(void);

    STDMETHOD(DoEffect)(IDirectDrawSurface* pddsIn, 
                        IDirectDrawSurface* pbsOut, 
                        RECT * prectBounds, RECT * prcInvalid);
    STDMETHOD(SetSource)(int nSrcWidth, int nSrcHeight, int nSrcBPP);
    STDMETHOD(SetTarget)(int nDestWidth, int nDestHeight, int nDestBPP);
    STDMETHOD(SetActiveRect)(LPRECT lprActiveRect);
    STDMETHOD(Generate)(int nTime, void * pDest, int nDestPitch, void * pSrc, 
                        int nSrcPitch); 

public:

    CDXTAdditive();
    virtual ~CDXTAdditive();

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTADDITIVE)
    DECLARE_POLY_AGGREGATABLE(CDXTAdditive)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CDXTAdditive)
	    COM_INTERFACE_ENTRY(IDispAdditive)
	    COM_INTERFACE_ENTRY(IDispatch)
            COM_INTERFACE_ENTRY(IHTMLDXTransform)
	    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
            COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTAdditive>)
            COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
            COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
            COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTAdditive)
        PROP_ENTRY("harmonics",     DISPID_DISPADDITIVE_HARMONICS, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("noisescale",    DISPID_DISPADDITIVE_NOISESCALE, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("noiseoffset",   DISPID_DISPADDITIVE_NOISEOFFSET, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("timex",         DISPID_DISPADDITIVE_TIMEX, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("timey",         DISPID_DISPADDITIVE_TIMEY, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("scalex",        DISPID_DISPADDITIVE_SCALEX,
                   CLSID_DispAdditivePP)
        PROP_ENTRY("scaley",        DISPID_DISPADDITIVE_SCALEY, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("scalet",        DISPID_DISPADDITIVE_SCALET, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("alpha",         DISPID_DISPADDITIVE_ALPHA, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("colorkey",      DISPID_DISPADDITIVE_COLORKEY, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("maskmode",      DISPID_DISPADDITIVE_MASKMODE, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("generateseed",  DISPID_DISPADDITIVE_GENERATESEED, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("bitmapseed",    DISPID_DISPADDITIVE_BITMAPSEED, 
                   CLSID_DispAdditivePP)
        PROP_PAGE(CLSID_DispAdditivePP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);

    // IHTMLDXTransform methods.

    STDMETHOD(SetHostUrl)(BSTR bstrHostUrl);

    // IDispAdditive properties.

    STDMETHOD(get_Harmonics)(int * pnHarmonics);
    STDMETHOD(put_Harmonics)(int nHarmonics);
    STDMETHOD(get_NoiseScale)(int * pnNoiseScale);
    STDMETHOD(put_NoiseScale)(int nNoiseScale);
    STDMETHOD(get_NoiseOffset)(int * pnNoiseOffset);
    STDMETHOD(put_NoiseOffset)(int nNoiseOffset);
    STDMETHOD(get_TimeX)(int * pnTimeX);
    STDMETHOD(put_TimeX)(int nTimeX);
    STDMETHOD(get_TimeY)(int * pnTimeY);
    STDMETHOD(put_TimeY)(int nTimeY);
    STDMETHOD(get_ScaleX)(int * pnScaleX);
    STDMETHOD(put_ScaleX)(int nScaleX);
    STDMETHOD(get_ScaleY)(int * pnScaleY);
    STDMETHOD(put_ScaleY)(int nScaleY);
    STDMETHOD(get_ScaleT)(int * pnScaleT);
    STDMETHOD(put_ScaleT)(int nScaleT);
    STDMETHOD(get_Alpha)(int * pnAlpha);
    STDMETHOD(put_Alpha)(int nAlpha);
    STDMETHOD(get_ColorKey)(int * pnColorKey);
    STDMETHOD(put_ColorKey)(int nColorKey);
    STDMETHOD(get_MaskMode)(int * pnMaskMode);
    STDMETHOD(put_MaskMode)(int nMaskMode);
    STDMETHOD(get_GenerateSeed)(int * pnSeed);
    STDMETHOD(put_GenerateSeed)(int nSeed);
    STDMETHOD(get_BitmapSeed)(BSTR * pbstrBitmapSeed);
    STDMETHOD(put_BitmapSeed)(BSTR bstrBitmapSeed);
};

#endif //__ADDITIVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\src\tables.cpp ===
/*
//   TABLES.CPP
//
//              INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//
//      Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
//  PVCS:
//      $Workfile$
//      $Revision$
//      $Modtime$
//
//  PURPOSE:
//		this file contains global tables read by everyone, modified by none.                                  
//              
//
//  CONTENTS:
*/
#include "stdafx.h"
//#include "tables.h"
//#include <windows.h>
#include "defines.h"

DWORD gdwSmoothTable[256] = {
	    0,     2,    11,    26,    47,    74,   106,   144,   188,   237,   292,   352,   418,   489,   566,   648,
	  736,   828,   926,  1029,  1137,  1250,  1368,  1491,  1620,  1752,  1890,  2033,  2180,  2332,  2489,  2650,
	 2816,  2986,  3160,  3340,  3523,  3711,  3903,  4099,  4300,  4504,  4713,  4925,  5142,  5363,  5587,  5815,
	 6048,  6283,  6523,  6766,  7013,  7263,  7517,  7775,  8036,  8300,  8567,  8838,  9112,  9389,  9670,  9953,
	10240, 10529, 10821, 11117, 11415, 11716, 12020, 12326, 12636, 12947, 13262, 13579, 13898, 14220, 14544, 14871,
	15200, 15531, 15864, 16199, 16537, 16877, 17218, 17562, 17908, 18255, 18604, 18955, 19308, 19662, 20019, 20376,
	20736, 21096, 21458, 21822, 22187, 22553, 22921, 23290, 23660, 24031, 24403, 24776, 25150, 25525, 25901, 26278,
	26656, 27034, 27413, 27793, 28173, 28554, 28935, 29317, 29700, 30082, 30465, 30848, 31232, 31616, 32000, 32384,
	32768, 33151, 33535, 33919, 34303, 34687, 35070, 35453, 35836, 36218, 36600, 36981, 37362, 37742, 38122, 38501,
	38880, 39257, 39634, 40010, 40385, 40759, 41132, 41504, 41876, 42245, 42614, 42982, 43348, 43713, 44077, 44439,
	44800, 45159, 45516, 45873, 46227, 46580, 46931, 47280, 47628, 47973, 48317, 48658, 48998, 49336, 49671, 50004,
	50336, 50664, 50991, 51315, 51637, 51956, 52273, 52588, 52900, 53209, 53515, 53819, 54120, 54418, 54714, 55006,
	55296, 55582, 55865, 56146, 56423, 56697, 56968, 57235, 57500, 57760, 58018, 58272, 58522, 58769, 59012, 59252,
	59488, 59720, 59948, 60172, 60393, 60610, 60822, 61031, 61236, 61436, 61632, 61824, 62012, 62195, 62375, 62549,
	62720, 62885, 63046, 63203, 63355, 63502, 63645, 63783, 63916, 64044, 64167, 64285, 64398, 64506, 64609, 64707,
	64800, 64887, 64969, 65046, 65117, 65183, 65243, 65298, 65348, 65391, 65429, 65461, 65488, 65509, 65524, 65533};

DWORD gPerm[TABSIZE] = {
        225,155,210,108,175,199,221,144,203,116, 70,213, 69,158, 33,252,
          5, 82,173,133,222,139,174, 27,  9, 71, 90,246, 75,130, 91,191,
        169,138,  2,151,194,235, 81,  7, 25,113,228,159,205,253,134,142,
        248, 65,224,217, 22,121,229, 63, 89,103, 96,104,156, 17,201,129,
         36,  8,165,110,237,117,231, 56,132,211,152, 20,181,111,239,218,
        170,163, 51,172,157, 47, 80,212,176,250, 87, 49, 99,242,136,189,
        162,115, 44, 43,124, 94,150, 16,141,247, 32, 10,198,223,255, 72,
         53,131, 84, 57,220,197, 58, 50,208, 11,241, 28,  3,192, 62,202,
         18,215,153, 24, 76, 41, 15,179, 39, 46, 55,  6,128,167, 23,188,
        106, 34,187,140,164, 73,112,182,244,195,227, 13, 35, 77,196,185,
         26,200,226,119, 31,123,168,125,249, 68,183,230,177,135,160,180,
         12,  1,243,148,102,166, 38,238,251, 37,240,126, 64, 74,161, 40,
        184,149,171,178,101, 66, 29, 59,146, 61,254,107, 42, 86,154,  4,
        236,232,120, 21,233,209, 45, 98,193,114, 78, 19,206, 14,118,127,
         48, 79,147, 85, 30,207,219, 54, 88,234,190,122, 95, 67,143,109,
        137,214,145, 93, 92,100,245,  0,216,186, 60, 83,105, 97,204, 52
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\src\additive.cpp ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       additive.cpp
//
//  Description:    Intel's additive procedural texture.
//
//  Change History:
//  1999/12/07  a-matcal    Created.
//
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "proctexe.h"
#include "defines.h"
#include "additive.h"
#include "mmx.h"
#include "urlarchv.h"
#include <mshtml.h>
#include <shlwapi.h>

#ifdef _DEBUG
void * showme(IUnknown * pUnk);
#endif // _DEBUG




//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::CDXTAdditive
//
//------------------------------------------------------------------------------
CDXTAdditive::CDXTAdditive() :
    m_bstrHostUrl(NULL),
    m_nSrcWidth(0),
    m_nSrcHeight(0),
    m_nSrcBPP(0),
    m_nDestWidth(0),
    m_nDestHeight(0),
    m_nDestBPP(0),
    m_nNoiseScale(32),
    m_nNoiseOffset(0),
    m_nTimeAnimateX(0),
    m_nTimeAnimateY(0),
    m_nScaleX(0),
    m_nScaleY(0),
    m_nScaleTime(0),
    m_nHarmonics(1),
    m_dwFunctionType(0),
    m_nPaletteSize(0),
    m_pPalette(NULL),
    m_alphaActive(0),
    m_pInitialBuffer(NULL),
    m_nBufferSize(0),
    m_dwScanArraySize(0),
    m_pdwScanArray(0),
    m_pGenerateFunction(0),
    m_pCopyFunction(0),
    m_ColorKey(0),
    m_MaskMode(0),          // 0 no mask, other TBD
    m_pMask(0),
    m_nMaskPitch(0),
    m_GenerateSeed(0),      // 0 no seed, 1 flame, 2 water, 3 clouds, other TDB
    m_nMaskHeight(0),
    m_nMaskWidth(0),
    m_nMaskBPP(0),
    m_valueTab(NULL)
{
    memset(&m_rActiveRect, 0, sizeof(RECT));

    if (m_nIsMMX)
    {
        m_pGenerateFunction = addsmoothturb8to32mmx;
    }
    else
    {
        m_pGenerateFunction = addsmoothturb32;
    }

    // Base class members.

    m_ulNumInRequired   = 1;
    m_ulMaxInputs       = 1;

    // Don't bother supporting multi-threaded execution.

    m_ulMaxImageBands   = 1;

#ifdef _DEBUG
    showme(NULL);
#endif // _DEBUG
} 
//  Method:  CDXTAdditive::CDXTAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::~CDXTAdditive
//
//------------------------------------------------------------------------------
CDXTAdditive::~CDXTAdditive() 
{
    delete [] m_valueTab;
    delete [] m_pPalette;
    delete [] m_pdwScanArray;
    delete [] m_pInitialBuffer;
    
    SysFreeString(m_bstrHostUrl);
}
//  Method:  CDXTAdditive::~CDXTAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAdditive::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_spUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    m_valueTab = new DWORD[TABSIZE];

    if (NULL == m_valueTab)
    {
        hr = E_OUTOFMEMORY;
    }

    MyInitialize(0, PROCTEX_LATTICETURBULENCE_SMOOTHSTEP, NULL);

done:

    return hr;
}
//  Method:  CDXTAdditive::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::SetHostUrl, IHTMLDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAdditive::SetHostUrl(BSTR bstrHostUrl)
{
    HRESULT hr = S_OK;

    SysFreeString(m_bstrHostUrl);

    m_bstrHostUrl = NULL;

    if (bstrHostUrl)
    {
        m_bstrHostUrl = SysAllocString(bstrHostUrl);

        if (NULL == m_bstrHostUrl)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }
    }

done:

    return hr;
}
//  Method:  CDXTAdditive::SetHostUrl, IHTMLDXTransform

        
void
CDXTAdditive::valueTabInit(int seed)
{
    DWORD * table = m_valueTab;
    int     i;

    srand(seed);

    if (m_nIsMMX)
    {
	for(i = 0; i < TABSIZE; i++) 
        {
            *table++ = ((rand()*rand()) & 0xffff) >> 1;
	}
    }
    else 
    {
	for(i = 0; i < TABSIZE; i++) 
        {
            *table++ = (rand()*rand()) & 0xffff;
	}
    }
}


STDMETHODIMP
CDXTAdditive::MyInitialize(
	DWORD dwSeed, 
	DWORD dwFunctionType, 
	void *pInitInfo) 
{
    HRESULT hr = S_OK;

    m_nIsMMX = IsMMXCpu();

    valueTabInit(dwSeed);

    switch (dwFunctionType) 
    {
        case PROCTEX_LATTICENOISE_SMOOTHSTEP:
        case PROCTEX_LATTICENOISE_LERP:
            m_nHarmonics = 1;
        case PROCTEX_LATTICETURBULENCE_SMOOTHSTEP:
        case PROCTEX_LATTICETURBULENCE_LERP:
            m_dwFunctionType = dwFunctionType;
            hr = S_OK;
            break;
        default:
            hr = E_INVALIDARG;
            break;
    }

    return hr;
}


/*
STDMETHODIMP
CDXTAdditive::GetSource(
	int *pnSrcWidth, 
	int *pnSrcHeight, 
	int *pnSrcBPP) 
{
    if (pnSrcWidth != NULL) *pnSrcWidth   = m_nSrcWidth;
    if (pnSrcHeight != NULL) *pnSrcHeight = m_nSrcHeight;
    if (pnSrcBPP != NULL) *pnSrcBPP       = m_nSrcBPP;

    return S_OK;
}
*/


/*
STDMETHODIMP
CDXTAdditive::GetTarget(
	int *pnDestWidth, 
	int *pnDestHeight, 
	int *pnDestBPP) 
{
    if (pnDestWidth != NULL) *pnDestWidth   = m_nDestWidth;
    if (pnDestHeight != NULL) *pnDestHeight = m_nDestHeight;
    if (pnDestBPP != NULL) *pnDestBPP       = m_nDestBPP;

    return S_OK;
}
*/

//TODO:: Use get_TimeX and get_TimeY instead.

/*
STDMETHODIMP
CDXTAdditive::GetScaling(
	int *pnScaleX, 
	int *pnScaleY, 
	int *pnScaleTime) 
{
    if (pnScaleX != NULL) *pnScaleX = m_nScaleX;
    if (pnScaleY != NULL) *pnScaleY = m_nScaleY;
    if (pnScaleTime != NULL) *pnScaleTime = m_nScaleTime;

    return S_OK;
}
*/


/*
STDMETHODIMP
CDXTAdditive::GetActiveRect(LPRECT lprActiveRect) 
{
    if (lprActiveRect != NULL) 
    {
        memcpy(lprActiveRect, &m_rActiveRect, sizeof(RECT));

        return S_OK;
    }

    return E_INVALIDARG;
}
*/



STDMETHODIMP
CDXTAdditive::SetSource(
	int nSrcWidth, 
	int nSrcHeight, 
	int nSrcBPP) 
{
    if ((nSrcBPP != 8) && (nSrcBPP != 16))
    {
        return E_INVALIDARG;
    }

    m_nSrcWidth  = nSrcWidth;
    m_nSrcHeight = nSrcHeight;
    m_nSrcBPP    = nSrcBPP;

    return S_OK;
}



/*
STDMETHODIMP
CDXTAdditive::SetMaskBitmap(void * lpBits, int nMaskWidth, int nMaskHeight, 
                            int nMaskBPP) 
{
    int memsize = 0;

    if (nMaskWidth < 0) return E_INVALIDARG;
    if (nMaskHeight < 0) return E_INVALIDARG;

    if ((nMaskBPP != 1) && (nMaskBPP != 8) && (nMaskBPP != 16)
        && (nMaskBPP != 24) && (nMaskBPP != 32))
    {
        return E_INVALIDARG;
    }

    if (NULL == lpBits) return E_INVALIDARG;

    m_nMaskWidth  = nMaskWidth;
    m_nMaskPitch  = nMaskWidth * 4;
    m_nMaskHeight = nMaskHeight;
    m_nMaskBPP    = nMaskBPP;

    memsize = (m_nMaskWidth * m_nMaskHeight * m_nMaskBPP) / 8;

    m_pMask = (void *) new unsigned char[memsize];

    memcpy(m_pMask, lpBits, memsize);

    return S_OK;
}
*/



STDMETHODIMP
CDXTAdditive::SetTarget(
	int nDestWidth, 
	int nDestHeight, 
	int nDestBPP) 
{
    HRESULT hr              = S_OK;
    DWORD   dwFunctionField = 0;
    RECT    rect;

    if (   (nDestBPP != 8) 
        && (nDestBPP != 16) 
        && (nDestBPP != 24) 
        && (nDestBPP != 32)) 
    {
        hr = E_INVALIDARG;

        goto done;
    }

    m_nDestWidth    = nDestWidth;
    m_nDestHeight   = nDestHeight;
    m_nDestBPP      = nDestBPP;

    rect.top        = 0;
    rect.left       = 0;
    rect.right      = nDestWidth;
    rect.bottom     = nDestHeight;

    SetActiveRect(&rect);

    setGenerateFunction();
    setCopyFunction();

    if ((DWORD) m_nDestWidth > m_dwScanArraySize) 
    {
        delete [] m_pdwScanArray;

        m_pdwScanArray = NULL;

        switch (m_dwFunctionType) 
        {
            case PROCTEX_LATTICENOISE_SMOOTHSTEP:
            case PROCTEX_LATTICENOISE_LERP:
            case PROCTEX_LATTICETURBULENCE_SMOOTHSTEP:
            case PROCTEX_LATTICETURBULENCE_LERP:

                m_pdwScanArray      = new DWORD[m_nDestWidth];

                if (NULL == m_pdwScanArray)
                {
                    hr = E_OUTOFMEMORY;

                    goto done;
                }

                m_dwScanArraySize   = m_nDestWidth;

                break;
        }
    }

done:

    return hr;
}



/*
STDMETHODIMP
CDXTAdditive::SetScaling(int nScaleX, int nScaleY, int nScaleTime) 
{
    if ((nScaleX < 0) || (nScaleY < 0) || (nScaleTime < 0)) 
    {
        return E_INVALIDARG;
    }

    m_nScaleX = nScaleX;
    m_nScaleY = nScaleY;
    m_nScaleTime = nScaleTime;

    return S_OK;
}
*/



STDMETHODIMP
CDXTAdditive::SetActiveRect(LPRECT lprActiveRect) 
{
    if (lprActiveRect != NULL) 
    {
        if (lprActiveRect->left < 0)                    return E_INVALIDARG;
        if (lprActiveRect->right > m_nDestWidth)        return E_INVALIDARG;
        if (lprActiveRect->top < 0)                     return E_INVALIDARG;
        if (lprActiveRect->bottom > m_nDestHeight)      return E_INVALIDARG;
        if (lprActiveRect->left > lprActiveRect->right) return E_INVALIDARG;
        if (lprActiveRect->top > lprActiveRect->bottom) return E_INVALIDARG;

        memcpy(&m_rActiveRect, lprActiveRect, sizeof(RECT));

        return S_OK;
    } 

    return E_INVALIDARG;
}



/*
STDMETHODIMP
CDXTAdditive::SetPalette(int nSize, WORD *pPalette) 
{
    if (m_pPalette) delete [] m_pPalette;

    m_nPaletteSize  = nSize;
    m_pPalette      = (void *)(new unsigned char[nSize]);

    if (m_pPalette == NULL) 
    {
        m_nPaletteSize = 0;

        return E_OUTOFMEMORY;
    }

    memcpy(m_pPalette, pPalette, nSize * sizeof(unsigned char));

    return S_OK;
}
*/


//+-----------------------------------------------------------------------------
//
//  Method: CDXTAdditive::OnSetup, CDXBaseNTo1
//
//  Overview:   All the mmx functions in this class were written to assume the
//              output surface is the same size as the input surface.  Rather
//              than muck with them, I've decided to just have an extra buffer
//              that is the same size as the input and then blit to the output.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAdditive::OnSetup(DWORD dwFlags)
{
    HRESULT     hr              = S_OK;
    DXSAMPLE    sampleColorKey  = 0;

    CComPtr<IServiceProvider>   spServiceProvider;
    CComPtr<IDXSurfaceFactory>  spDXSurfaceFactory;

    m_spDXSurfBuffer.Release();

    hr = GetSite(__uuidof(IServiceProvider), (void **)&spServiceProvider);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spServiceProvider->QueryService(SID_SDXSurfaceFactory,
                                         __uuidof(IDXSurfaceFactory),
                                         (void **)&spDXSurfaceFactory);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = InputSurface()->GetBounds(&m_bndsInput);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDXSurfaceFactory->CreateSurface(NULL, NULL, &DDPF_RGB32,
                                           &m_bndsInput, 0, NULL,
                                           __uuidof(IDXSurface),
                                           (void **)&m_spDXSurfBuffer);
    
    if (FAILED(hr))
    {
        goto done;
    }

    hr = InputSurface()->GetColorKey(&sampleColorKey);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spDXSurfBuffer->SetColorKey(sampleColorKey);

done:

    return hr;
}
//  Method: CDXTAdditive::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTAdditive::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAdditive::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr      = S_OK;
    DWORD   dwFlags = 0;
    RECT    rcBounds;

    CComPtr<IDirectDrawSurface> spDDSurface;

    hr = m_spDXSurfBuffer->GetDirectDrawSurface(IID_IDirectDrawSurface,
                                                (void **)&spDDSurface);

    if (FAILED(hr))
    {
        goto done;
    }

    // TODO:    In theory, we should be able to process just part of the image,
    //          but the mmx routines don't like that.  I don't the the old style
    //          filters ever dealt with that situation.
    //
    // WI.DoBnds.GetXYRect(rcBounds);

    m_bndsInput.GetXYRect(rcBounds);

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    hr = DXBitBlt(m_spDXSurfBuffer, WI.DoBnds,
                  InputSurface(), WI.DoBnds,
                  0, INFINITE);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = DoEffect(spDDSurface, NULL, &rcBounds, &rcBounds);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = DXBitBlt(OutputSurface(), WI.OutputBnds,
                  m_spDXSurfBuffer, WI.DoBnds,
                  dwFlags, INFINITE);

done:

    return hr;
}
//  Method: CDXTAdditive::WorkProc, CDXBaseNTo1


STDMETHODIMP 
CDXTAdditive::DoEffect(IDirectDrawSurface * pddsIn, 
                        IDirectDrawSurface * /* pbsOut */, 
                        RECT *prectBounds, 
                        RECT* prcInvalid)
{
    HRESULT         hr;
    DDSURFACEDESC   ddsDesc;
    int             nMemSize;
    DWORD           i;
    static int      count = 0;	

    long            nWidth  = prectBounds->right - prectBounds->left;
    long            nHeight = prectBounds->bottom - prectBounds->top;

    count++;

    ZeroMemory(&ddsDesc, sizeof(ddsDesc));

    ddsDesc.dwSize = sizeof(ddsDesc);

    hr = pddsIn->Lock(prectBounds, &ddsDesc, 0, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    if (m_GenerateSeed) 
    {
        // SetSource(ddsDesc.dwWidth, ddsDesc.dwHeight, 8);
        SetSource(nWidth, nHeight, 8);
        //nMemSize = ddsDesc.dwWidth * ddsDesc.dwHeight * sizeof(DWORD);
        nMemSize = nWidth * nHeight * sizeof(DWORD);

        // Delete the buffer if it isn't large enough.

        if (m_pInitialBuffer && (nMemSize > m_nBufferSize))
        {
            delete [] m_pInitialBuffer;
            m_pInitialBuffer    = NULL;
            m_nBufferSize       = nMemSize;
        }

        if (!m_pInitialBuffer)
        {
            m_nBufferSize       = nMemSize;
            m_pInitialBuffer    = new unsigned char[m_nBufferSize];

            if (NULL == m_pInitialBuffer) 
            {
                m_nBufferSize   = 0;
                hr              = E_OUTOFMEMORY;

                goto done;
            }

            // This is a new buffer, initialize it.
            switch (m_GenerateSeed) 
            {
            case 1: // flame

                for (i = 0; i < ddsDesc.dwHeight ; i++) 
                {
                    memset(m_pInitialBuffer + i * ddsDesc.dwWidth, 
                           (255 * i)/ddsDesc.dwHeight, ddsDesc.dwWidth);
                }
                break;

            case 2: // water

                memset(m_pInitialBuffer, 0x80, nMemSize);
                break;

            case 3: // hey, you, get outta my cloud (<-- Intel comment)

                memset(m_pInitialBuffer, 0x40, nMemSize);
                break;
            }
        } // if (!m_pInitialBuffer)
    } // if (m_GenerateSeed)

    // If we aren't using generated buffer, use the output surface. ?

    if (!m_pInitialBuffer)
    {
        SetSource(ddsDesc.dwWidth, ddsDesc.dwHeight, 8);
    }

    // Old
    // SetTarget(ddsDesc.dwWidth, ddsDesc.dwHeight, 32);
    // New (takes into account that only invalid rect will be drawn)
    // TODO:  Will this always be 32BPP?

    hr = SetTarget(nWidth, nHeight, 32);

    if (FAILED(hr))
    {
        goto done;
    }
    
    SetActiveRect(prectBounds);

    memcpy(&m_rActiveRect, prectBounds, sizeof(RECT));

    if (PROCTEX_MASKMODE_CHROMAKEY == m_MaskMode) 
    {
        // The only way this should be non-NULL is if SetMaskBitmap is called.
        // And it isn't ever called from anywhere.  Look into removing.

        if (m_pMask) 
        {
            delete [] m_pMask;
        }

        m_pMask         = ddsDesc.lpSurface;
        m_nMaskPitch    = ddsDesc.lPitch;
    }

    Generate(count, ddsDesc.lpSurface, ddsDesc.lPitch, m_pInitialBuffer, 
             m_nSrcWidth);

    if (PROCTEX_MASKMODE_CHROMAKEY == m_MaskMode) 
    {
        m_pMask         = 0;
        m_nMaskPitch    = 0;
    }

done:

    pddsIn->Unlock(ddsDesc.lpSurface);

    return hr;
}


STDMETHODIMP
CDXTAdditive::Generate(int nTime, void * pDest, int nDestPitch, void * pSrc, 
                       int nSrcPitch) 
{
    if ((pDest == NULL) || ((pSrc == NULL) && (m_nDestBPP == 8))) return E_INVALIDARG;
    if (nDestPitch < m_nDestWidth) return E_INVALIDARG;
    if (nSrcPitch < m_nSrcWidth) return E_INVALIDARG;

    if (m_nNoiseScale != 32) 
    {
        if (NULL == m_pGenerateFunction) 
        {
            return E_FAIL;
        }

        (this->*m_pGenerateFunction)(nTime, pDest, nDestPitch, pSrc, nSrcPitch, 
                                     m_pMask, m_nMaskPitch);
    } 
    else 
    {
        if (NULL == m_pCopyFunction) 
        {
            return E_FAIL;
        }

        (this->*m_pCopyFunction)(pDest, nDestPitch, pSrc, nSrcPitch, m_pMask, 
                                 m_nMaskPitch);
    }

    return S_OK;
}


/*
STDMETHODIMP
CDXTAdditive::GenerateXY(int x, int y, int nTime, void * pSrc, int nSrcPitch,
                         DWORD * returnvalue)
{
    int     value   = 0;
    DWORD   noise   = 0;
    int	    signednoise;

    if (pSrc == NULL) return E_INVALIDARG;
    if (nSrcPitch < m_nSrcWidth) return E_INVALIDARG;

    if (m_nSrcBPP == 8) 
    {
        unsigned char * pPtr;

        pPtr    = (unsigned char *)pSrc;
        value   = pPtr[x+y*nSrcPitch];
    } 
    else if (m_nSrcBPP == 16) 
    {
        WORD * pPtr;

        pPtr    = (WORD *) pSrc;
        value   = pPtr[x + y*nSrcPitch];
    }

    switch(m_dwFunctionType) 
    {
    case PROCTEX_LATTICENOISE_LERP:
    case PROCTEX_LATTICENOISE_SMOOTHSTEP:

        if (m_nNoiseScale != 32) 
        {
            noise       = smoothnoise(x+nTime * m_nTimeAnimateX,
                                      y+nTime * m_nTimeAnimateY,
                                      nTime,
                                      m_nScaleX,
                                      m_nScaleY,
                                      m_nScaleTime);

            noise       = noise >> m_nNoiseScale;
            signednoise = noise;
            signednoise = signednoise - (1 << (31 - m_nNoiseScale));
            signednoise += m_nNoiseOffset;
            value       += signednoise;
        }

        break;

    case PROCTEX_LATTICETURBULENCE_LERP:
    case PROCTEX_LATTICETURBULENCE_SMOOTHSTEP:

        if (m_nNoiseScale != 32) 
        {
            signednoise = smoothturbulence(x+nTime * m_nTimeAnimateX,
                                           y+nTime * m_nTimeAnimateY,
                                           nTime);

            signednoise = signednoise >> m_nNoiseScale;
            signednoise += m_nNoiseOffset;
            value       += signednoise;
        }

        break;

    default:

        return E_FAIL;

        break;
    }


    if (m_nSrcBPP == 8) 
    {
        // clamp
        if (value < 0) value = 0;
        if (value > 255) value = 255;
    } 
    else if (m_nSrcBPP == 16) 
    {
        value = ((WORD *)m_pPalette)[value];
    }

    *returnvalue = value;

    return S_OK;
}
*/



void 
CDXTAdditive::setGenerateFunction(void) 
{
    #define FF_MMX      0x00000001
    #define FF_LNL      0x00000002
    #define FF_LTL      0x00000004
    #define FF_LNS      0x00000008
    #define FF_LTS      0x00000010
    #define FF_D8       0x00000020
    #define FF_D16      0x00000040
    #define FF_D24      0x00000080
    #define FF_D32      0x00000100
    #define FF_MASK_C   0x00000200

    DWORD dwFunctionField = 0;

    if (m_nIsMMX)
    {
        dwFunctionField |= FF_MMX;
    }

    if (PROCTEX_LATTICENOISE_LERP == m_dwFunctionType)              dwFunctionField |= FF_LNL;
    if (PROCTEX_LATTICETURBULENCE_LERP == m_dwFunctionType)         dwFunctionField |= FF_LTL;

    // This is the hardcoded value in the constructor.
    if (PROCTEX_LATTICENOISE_SMOOTHSTEP == m_dwFunctionType)        dwFunctionField |= FF_LNS;

    if (PROCTEX_LATTICETURBULENCE_SMOOTHSTEP == m_dwFunctionType)   dwFunctionField |= FF_LTS;
    if (8  == m_nDestBPP) dwFunctionField |= FF_D8;
    if (16 == m_nDestBPP) dwFunctionField |= FF_D16;
    if (24 == m_nDestBPP) dwFunctionField |= FF_D24;

    // This always be the case for a transform.  (and I think for this filter as well)

    if (32 == m_nDestBPP) dwFunctionField |= FF_D32;

    if (PROCTEX_MASKMODE_CHROMAKEY == m_MaskMode) dwFunctionField |= FF_MASK_C;

    switch (dwFunctionField) 
    {
    case (FF_LNL | FF_D8):
    case (FF_LNS | FF_D8):
        m_pGenerateFunction = addsmoothnoise8;
        break;
    case (FF_LTL | FF_D8):
    case (FF_LTS | FF_D8):
        m_pGenerateFunction = addsmoothturb8;
        break;
    case (FF_LNL | FF_D16):
    case (FF_LNS | FF_D16):
        m_pGenerateFunction = addsmoothnoise16;
        break;
    case (FF_LTL | FF_D16):
    case (FF_LTS | FF_D16):
        m_pGenerateFunction = addsmoothturb16;
        break;
    case (FF_LNL | FF_D24):
    case (FF_LNS | FF_D24):
	    break;
    case (FF_LTL | FF_D24):
    case (FF_LTS | FF_D24):
	    break;
    case (FF_LNL | FF_D32):
    case (FF_LNS | FF_D32):
        m_pGenerateFunction = addsmoothturb32;
        break;
    case (FF_LTL | FF_D32):
    case (FF_LTS | FF_D32):
        m_pGenerateFunction = addsmoothturb32; // <-- Possible w/ transform.
        break;

    case (FF_LNL | FF_D8 | FF_MMX):
    case (FF_LNS | FF_D8 | FF_MMX):
        m_pGenerateFunction = addsmoothturb8mmx;
        break;
    case (FF_LTL | FF_D8 | FF_MMX):
    case (FF_LTS | FF_D8 | FF_MMX):
        m_pGenerateFunction = addsmoothturb8mmx;
        break;
    case (FF_LNL | FF_D16 | FF_MMX):
    case (FF_LNS | FF_D16 | FF_MMX):
        m_pGenerateFunction = addsmoothnoise16;
        break;
    case (FF_LTL | FF_D16 | FF_MMX):
    case (FF_LTS | FF_D16 | FF_MMX):
        m_pGenerateFunction = addsmoothturb16;
        break;
    case (FF_LNL | FF_D24 | FF_MMX):
    case (FF_LNS | FF_D24 | FF_MMX):
        break;
    case (FF_LTL | FF_D24 | FF_MMX):
    case (FF_LTS | FF_D24 | FF_MMX):
        break;
    case (FF_LNL | FF_D32 | FF_MMX):
    case (FF_LNS | FF_D32 | FF_MMX):
        m_pGenerateFunction = addsmoothturb8to32mmx; // <-- Possible w/ transform.
        break;
    case (FF_LTL | FF_D32 | FF_MMX):
    case (FF_LTS | FF_D32 | FF_MMX):
        m_pGenerateFunction = addsmoothturb8to32mmx;
        break;
    case (FF_LTL | FF_D32 | FF_MASK_C):
    case (FF_LTS | FF_D32 | FF_MASK_C):
        m_pGenerateFunction = addsmoothturb8to32mask;
        break;
    case (FF_LTL | FF_D32 | FF_MMX | FF_MASK_C):
    case (FF_LTS | FF_D32 | FF_MMX | FF_MASK_C):
        m_pGenerateFunction = addsmoothturb8to32mmxmask;
        break;
    default:
        break;
    }
}



// This copy function takes into account the mask, we'll have to figure that out.


void 
CDXTAdditive::setCopyFunction(void) 
{
	#define FF_MMX		0x00000001
	#define FF_D8		0x00000020
	#define FF_D16		0x00000040
	#define FF_D24		0x00000080
	#define FF_D32		0x00000100
	#define FF_MASK_C	0x00000200

	DWORD dwFunctionField = 0;

//	if (m_nIsMMX)													dwFunctionField |= FF_MMX;
	if (8  == m_nDestBPP)											dwFunctionField |= FF_D8;
	if (16 == m_nDestBPP)											dwFunctionField |= FF_D16;
	if (24 == m_nDestBPP)											dwFunctionField |= FF_D24;
	if (32 == m_nDestBPP)											dwFunctionField |= FF_D32;
	if (PROCTEX_MASKMODE_CHROMAKEY == m_MaskMode)					dwFunctionField |= FF_MASK_C;

	switch (dwFunctionField) {
		case (FF_D8):
			m_pCopyFunction = blit8to8;
			break;
		case (FF_D16):
			m_pCopyFunction = 0;
			break;
		case (FF_D24):
			m_pCopyFunction = 0;
			break;
		case (FF_D32):
			m_pCopyFunction = blit8to32;
			break;

		case (FF_D32 | FF_MASK_C):
			m_pCopyFunction = blit8to32mask;
			break;
		default:
			break;
	}
}


void CDXTAdditive::blit8to8(void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
	int y;
	unsigned char *pDestLine, *pSrcLine;

	if (pSrc) 
		for (y=0; y<m_nDestHeight; y++) {
			pDestLine = ((unsigned char *) pDest) + y*nDestPitch;
			pSrcLine = ((unsigned char *) pSrc) + y*nSrcPitch;
			memcpy(pDest, pSrc, nDestPitch);
		}
}

void CDXTAdditive::blit8to32(void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
	int x, y;
	DWORD alphamask;
	unsigned char *pSrcLine;
	DWORD *pDestLine;

	nDestPitch /=4;

	if (m_alphaActive == 1) 
		alphamask = 0x80000000;
	else 
		alphamask = 0xff000000;

	if (pSrc) {
		for (y=0; y<m_nDestHeight; y++) {
			pDestLine = ((DWORD *) pDest) + y*nDestPitch;
			pSrcLine = ((unsigned char *) pSrc) + y*nSrcPitch;
			for (x=0; x<nDestPitch; x++) {
				pDestLine[x] = ((DWORD *)m_pPalette)[pSrcLine[x]] | alphamask;
			}
		}
	} else {
		for (y=0; y<m_nDestHeight; y++) {
			pDestLine = ((DWORD *) pDest) + y*nDestPitch;
			for (x=0; x<nDestPitch; x++) {
				pDestLine[x] = 0x00808080 | alphamask;
			}
		}
	}
}

void CDXTAdditive::blit8to32mask(void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
	int x, y;
	DWORD alphamask;
	unsigned char *pSrcLine;
	DWORD *pDestLine, *pMaskLine;

	nDestPitch /=4;
	nMaskPitch /=4;

	if (m_alphaActive == 1) 
		alphamask = 0x80000000;
	else 
		alphamask = 0xff000000;

	if (pSrc) {
		for (y=0; y<m_nDestHeight; y++) {
			pDestLine = ((DWORD *) pDest) + y*nDestPitch;
			pMaskLine = ((DWORD *) pMask) + y*nMaskPitch;
			pSrcLine = ((unsigned char *) pSrc) + y*nSrcPitch;
			for (x=0; x<nDestPitch; x++) {
				if ((pMaskLine[x] & 0x00ffffff) == (m_ColorKey & 0x00ffffff))
					pDestLine[x] = ((DWORD *)m_pPalette)[pSrcLine[x]] | alphamask;
				else
					pDestLine[x] = pMaskLine[x] | 0xff000000;
			}
		}
	} else {
		for (y=0; y<m_nDestHeight; y++) {
			pDestLine = ((DWORD *) pDest) + y*nDestPitch;
			pMaskLine = ((DWORD *) pMask) + y*nMaskPitch;
			for (x=0; x<nDestPitch; x++) {
				if ((pMaskLine[x] & 0x00ffffff) == (m_ColorKey & 0x00ffffff))
					pDestLine[x] = 0x00808080 | alphamask;
				else
					pDestLine[x] = pMaskLine[x] | 0xff000000;
			}
		}
	}
}

__inline DWORD 
CDXTAdditive::smoothnoise(int x, int y, int t, int xscale, int yscale, 
                          int tscale)
{
    DWORD fx, fy, ft;
    DWORD ix, iy, it;
    DWORD v[8];

    x = (x & 0x0ffff) << 16;
    y = (y & 0x0ffff) << 16;
    t = (t & 0x0ffff) << 16;
    
    x = x >> xscale;	
    y = y >> yscale;	
    t = t >> tscale;	

    fx = x & 0x0ffff;
    fy = y & 0x0ffff;
    ft = t & 0x0ffff;

    ix = (x >> 16);
    iy = (y >> 16);
    it = (t >> 16);

    v[0] = vlattice(ix + 0, iy + 0, it + 0);
    v[1] = vlattice(ix + 1, iy + 0, it + 0);
    v[2] = vlattice(ix + 1, iy + 1, it + 0);
    v[3] = vlattice(ix + 0, iy + 1, it + 0);
    v[4] = vlattice(ix + 0, iy + 0, it + 1);
    v[5] = vlattice(ix + 1, iy + 0, it + 1);
    v[6] = vlattice(ix + 1, iy + 1, it + 1);
    v[7] = vlattice(ix + 0, iy + 1, it + 1);

    v[0] = smoothstep(v[0], v[4], ft) >> 16;
    v[1] = smoothstep(v[1], v[5], ft) >> 16;
    v[2] = smoothstep(v[2], v[6], ft) >> 16;
    v[3] = smoothstep(v[3], v[7], ft) >> 16;

    v[0] = smoothstep(v[0], v[3], fy) >> 16;
    v[1] = smoothstep(v[1], v[2], fy) >> 16;

    return (smoothstep(v[0], v[1], fx));
}


__inline DWORD 
CDXTAdditive::smoothturbulence(int x, int y, int t) 
{
    int     rval = 0;
    int     i;
    DWORD   noiseval;
    int     signednoiseval;
    int     xscale, yscale, tscale;

    xscale = m_nScaleX;
    yscale = m_nScaleY;
    tscale = m_nScaleTime;

    xscale += m_nHarmonics;
    yscale += m_nHarmonics;
    tscale += m_nHarmonics;

    for (i = 0 ; i < m_nHarmonics ; i++) 
    {
        noiseval = smoothnoise(x, y, t, xscale, yscale, tscale);
        xscale--; 
        yscale--; 
        tscale--;
        noiseval = noiseval >> 1;
        signednoiseval = noiseval;
        signednoiseval -= 0x3fffffff;
        signednoiseval = signednoiseval/(i+1);
        rval += signednoiseval;
    }

    return rval;
}


void 
CDXTAdditive::addsmoothnoise8(int nTime, void * pDest, int nDestPitch, 
                              void * pSrc, int nSrcPitch, void * pMask,
                              int nMaskPitch) 
{
    int value = 0;
	DWORD noise = 0;

	int x, y, y_loop, x_loop;
	unsigned char *pDestLine, *pSrcLine;
	int timexanimatex, timexanimatey;
	DWORD ft, ift, t;
	DWORD iy, it;
	DWORD fy, ify;
	DWORD ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	DWORD left, right;
	DWORD scalex, noiseoffset, *pValueTab, noisescale, normalize;
	DWORD allone = 0xff;
	DWORD x_base, x_inc;
	DWORD lastix;
	DWORD vpp0;

	nTime = nTime & 0x0ffff;		// keep things as expected...

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	// copy some member variables into locals, since the inline assembler
	// can't access them... unless it would be through the this pointer, maybe
	scalex = m_nScaleX;
	noiseoffset = m_nNoiseOffset;
	pValueTab = m_valueTab;
	normalize = 1 << (31 - m_nNoiseScale);
	noisescale = m_nNoiseScale;

	left = m_rActiveRect.left;
	right = m_rActiveRect.right - 1;

	// setup the x_base -> prescaled x value at the left of every scan line
	x_base = ((left + timexanimatex) & 0xffff) << 16;
	x_base = x_base >> m_nScaleX;

	// the scaled x value (starting at x_base) gets incremented this much 
	// at each texel
	x_inc = (1 << 16) >> m_nScaleX;

	// Time doesn't change at all in this function, so pre-cal all of it
	t = ((nTime) << 16) >> m_nScaleTime;
	it = t >> 16;
	ft = gdwSmoothTable[(t & 0xffff) >> 8];
	ift = 0xffff - ft;

	for (y_loop=m_rActiveRect.top; y_loop<m_rActiveRect.bottom;y_loop++) {
		pDestLine = ((unsigned char *)pDest) + nDestPitch*y_loop;
		pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;

		y = y_loop + timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;

		iy = y >> 16;
		fy = gdwSmoothTable[(y & 0xffff) >> 8];
		ify = 0xffff - fy;

		ytPerm00 = PERM(iy+0 + PERM(it+0));
		ytPerm01 = PERM(iy+0 + PERM(it+1));
		ytPerm10 = PERM(iy+1 + PERM(it+0));
		ytPerm11 = PERM(iy+1 + PERM(it+1));

		x = x_base;
		x_loop = left;

		__asm {
			; first, calc v[0], v[4], v[3] and v[7]
			lea		edx, gPerm
			  mov	eax, x
			mov		edi, edx
			  mov	ebx, ytPerm01	; for v[4]
			shr		eax, 16
			  mov	ecx, ytPerm10	; for v[3]
			mov		esi, eax		; esi = ix
			  mov	eax, ytPerm00	; for v[0]
			add		eax, esi		; eax = ix + ytPerm00, for v[0]
			  add	ebx, esi		; ebx = ix + ytPerm01, for v[4]
			and		eax, TABMASK	; still generating v[0]
			  and	ebx, TABMASK	; still generating v[4]
			mov		edx, ytPerm11	; for v[7]
			  add	ecx, esi		; ecx = ix + ytPerm10, for v[3]
			add		edx, esi		; edx = ix + ytPerm11, for v[7]
			  mov	esi, pValueTab	; point esi to valuetable
			mov		eax, [edi + 4*eax] ; eax = PERM(ix + PERM(iy+0 + PERM(it+0)))
			  and	ecx, TABMASK	; still generating v[3]
			mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix + PERM(iy+0 + PERM(it+1)))
			  and	edx, TABMASK	; still generating v[7]
			mov		eax, [esi + 4*eax] ; eax = v[0]
			  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix + PERM(iy+1 + PERM(it+0)))
			mov		ebx, [esi + 4*ebx] ; ebx = v[4]
			  mov	edx, [edi + 4*edx] ; edx = PERM(ix + PERM(iy+1 + PERM(it+1)))
			mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
			  mov	ecx, [esi + 4*ecx] ; ecx = v[3]
			mov		edx, [esi + 4*edx] ; edx = v[7]
			  mov	esi, ift		; prepare to multiply with esi
			imul	ebx, edi		; ebx = v[4] * ft
			  ; wait 10 cycles
			imul	eax, esi		; eax = v[0] * ift
			  ; wait another 10 cycles
			imul	edx, edi		; edx = v[7] * ft
			  ; wait yet another 10 cycles
			imul	ecx, esi		; ecx = v[3] * ift
			  ; wait even yet another 10 cycles
			add		eax, ebx		; eax = smoothstep(v[0], v[4], ft)
			  mov	ebx, fy			; ebx = fy....
			shr		eax, 16			; eax = vp[0]
			  add	ecx, edx		; ecx = smoothstep(v[3], v[7], ft)
			shr		ecx, 16			; ecx = vp[3]
			  mov	edx, ify		; edx = ify
			imul	eax, edx		; eax = vp[0] * ify
			  ; wait more cycles
			imul	ecx, ebx		; ecx = vp[3] * fy
			  ; another 10 cycle hit
			add		eax, ecx		; eax = smoothstep(vp[0], vp[3], fy)
			  ;
			shr		eax, 16			; eax = vpp[0]
			  ;
			mov		vpp0, eax		; save off vpp[0] for later
		x_loop_calc:
			; assumptions:
			lea		edx, gPerm
			  mov	eax, x
			mov		edi, edx
			  mov	ebx, ytPerm01	; for v[5]
			shr		eax, 16
			  mov	ecx, ytPerm10	; for v[2]
			mov		lastix, eax		; save off this ix value to look at next time
			  inc	eax
			mov		esi, eax		; esi = ix + 1
			  mov	eax, ytPerm00	; for v[1]
			add		eax, esi		; eax = ix + ytPerm00, for v[1]
			  add	ebx, esi		; ebx = ix + ytPerm01, for v[5]
			and		eax, TABMASK	; still generating v[1]
			  and	ebx, TABMASK	; still generating v[5]
			mov		edx, ytPerm11	; for v[6]
			  add	ecx, esi		; ecx = ix + ytPerm10, for v[2]
			add		edx, esi		; edx = ix + ytPerm11, for v[6]
			  mov	esi, pValueTab	; point esi to valuetable
			mov		eax, [edi + 4*eax] ; eax = PERM(ix+1 + PERM(iy+0 + PERM(it+0)))
			  and	ecx, TABMASK	; still generating v[2]
			mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix+1 + PERM(iy+0 + PERM(it+1)))
			  and	edx, TABMASK	; still generating v[6]
			mov		eax, [esi + 4*eax] ; eax = v[1]
			  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix+1 + PERM(iy+1 + PERM(it+0)))
			mov		ebx, [esi + 4*ebx] ; ebx = v[5]
			  mov	edx, [edi + 4*edx] ; edx = PERM(ix+1 + PERM(iy+1 + PERM(it+1)))
			mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
			  mov	ecx, [esi + 4*ecx] ; ecx = v[2]
			mov		edx, [esi + 4*edx] ; edx = v[6]
			  mov	esi, ift		; prepare to multiply with esi
			imul	ebx, edi		; ebx = v[5] * ft
			  ; wait 10 cycles
			imul	eax, esi		; eax = v[1] * ift
			  ; wait another 10 cycles
			imul	edx, edi		; edx = v[6] * ft
			  ; wait yet another 10 cycles
			imul	ecx, esi		; ecx = v[2] * ift
			  ; wait even yet another 10 cycles
			add		eax, ebx		; eax = smoothstep(v[1], v[5], ft)
			  mov	ebx, fy			; ebx = fy....
			shr		eax, 16			; eax = vp[1]
			  add	ecx, edx		; ecx = smoothstep(v[2], v[6], ft)
			shr		ecx, 16			; ecx = vp[2]
			  mov	edx, ify		; edx = ify
			imul	eax, edx		; eax = vp[1] * ify
			  ; wait more cycles
			imul	ecx, ebx		; ecx = vp[2] * fy
			  ; another 10 cycle hit
			add		eax, ecx		; eax = smoothstep(vp[1], vp[2], fy)
			  ;
			shr		eax, 16			; eax = vpp[1]
		x_loop_nocalc:			
			mov		edx, x			; get the prescaled x
			  mov	ebx, x_inc		; get scaled x increment
		    add		ebx, edx		; ebx = x + x_inc -> new scaled x
			  lea	esi, gdwSmoothTable
			and		edx, 0xffff		; edx = fx
			  mov	x, ebx			; save off new x
			shr		edx, 8			; get upper 8 bits of fx
			  mov	ecx, vpp0		; get vpp[0]
			mov		ebx, 0xffff		; prepare to calc ifx
			  ; AGI
			  mov	edx, [esi + 4*edx]	; edx = smooth fx
			sub		ebx, edx		; ebx = ifx
			  ; imul is U pipe only
			imul	edx, eax		; edx = vpp[1] * fx
			  ; imul, besides being 10 cycles, is also not pairable
			imul	ecx, ebx		; ecx = vpp[0] * ifx
			  ; sigh
			mov		esi, pSrcLine	; prepare to read in 
			  mov	ebx, x_loop		; prepare to read in a value
			add		edx, ecx		; edx = smoothstep(vpp[0], vpp[1], fx)
			  mov	ecx, noisescale	; prepare to do scaling shift
			mov		bl, [esi + ebx]	; get the pixel value from the buffer
			  ; shr, below, is U-pipe only. get bl here to avoid partial register stall later
			shr		edx, cl			; scale the noise
			  ; shr dest, cl is a 4 clock, non-pairable 
			mov		ecx, normalize	; prepare to normalize the noise value
			  mov	edi, pDestLine	; for writing pixel value
			sub		edx, ecx		; normalize noise around 0
			  mov	ecx, noiseoffset	; prepare to normalize around non-zero
			add		edx, ecx		; noise is now normalized around m_nNoiseOffset
			  and	ebx, 0x0ff		; make sure we've only the lower 8 bits
			add		edx, ebx		; edx = new pixel value, but we gotta clamp it
			  mov	ebx, x_loop		; get x_loop again to write out pixel value 
			sets	cl				; if (value < 0) cl = 1, else cl = 0 
			  ; setcc doesn't pair
			dec		cl				; if (value < 0) cl = 0, else cl = 0x0ff
			  add	edi, ebx		; free up ebx
			cmp		edx, 0xff		; test to see if bigger than 255
			  ;						;
			setle	bl				; if (value > 255) bl = 0 else bl = 1
			  ; setcc still doesn't pair, darn it
			and		dl, cl			; if (value < 0) dl = 0 (clamp to 0)
			  dec	bl				; if (value > 255) bl = 0xff else bl = 0
			or		dl, bl			; clamp to 255
			  mov	ecx, x_loop		; get x_loop AGAIN!
			mov		[edi], dl		; write out new pixel value
			  mov	ebx, right		; get right edge
			cmp		ecx, ebx		; check if at right edge of scan line
			  jge	x_loop_done		; if so, goto done code
			mov		edx, x			; get already-incremented x value
			  mov	ebx, lastix		; get last ix value
			shr		edx, 16			; get new ix value
			  inc	ecx				; x_loop++
			mov		x_loop, ecx		; save off x_loop
			  cmp	edx, ebx		; is lastix == ix?
			je		x_loop_nocalc	; if so, we only need to recalc a few things
			  mov	vpp0, eax		; save off this vpp[1] to be the next vpp[0]
			jmp		x_loop_calc		; go make more noise
		x_loop_done:
		}
	}


}

void CDXTAdditive::addsmoothnoise8mmx(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) 
{
	int x, y, y_loop, x_loop, xinc;
	unsigned char *pDestLine, *pSrcLine;
	int timexanimatex, timexanimatey;
	DWORD ft;
	DWORD ift;
	DWORD iy, it;
	DWORD ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	DWORD left, right;
	DWORD scalex, noiseoffset, *pvaluetab, noisescale, scratch;
	DWORD allone = 0xff;

	nTime = nTime & 0x0ffff;		// keep things as expected...

	scalex = m_nScaleX;
	noiseoffset = m_nNoiseOffset;
	pvaluetab = m_valueTab;
	scratch = 1 << (30 - m_nNoiseScale);
	noisescale = m_nNoiseScale;

	__asm {
		mov		eax, noisescale
		mov		ebx, scratch
		movd	mm4, eax
		movd	mm0, scratch
		psllq	mm0, 32
		por		mm4, mm0		; mm4 = 1 << (31 - m_nNoiseScale):m_nNoiseScale
	}

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	// Do the time mangling
	nTime = (nTime & 0xffff) << 16;
	nTime = nTime >> m_nScaleTime;
	ft = nTime & 0xffff;
	ift = 0xffff - ft;
	it = nTime >> 16;

	left = m_rActiveRect.left + timexanimatex;
	right = m_rActiveRect.right + timexanimatex;

	// put ft:ift:ft:ift into mm7
	__asm {
		mov 	eax, ft
		  mov 	ebx, ift
		movd 	mm7, ebx
		movd 	mm1, eax
		  psllq	mm7, 16
		por 	mm7, mm1
		movq 	mm1, mm7
		psllq 	mm7, 32
		por 	mm7, mm1
		psrlw	mm7, 1		; mm7 has ift:ft:ift:ft, 15 bits each (unsign -> sign)
	}
	// no emms necessary, since we've more MMX fun coming right up!
		
	xinc = (1 << 16) >> m_nScaleX;

	for (y_loop = m_rActiveRect.top; y_loop < m_rActiveRect.bottom; y_loop++) {
		pDestLine = ((unsigned char *) pDest) + nDestPitch*y_loop;
		pSrcLine  = ((unsigned char *) pSrc ) + nSrcPitch *y_loop;
		y = y_loop;
		y += timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;
		iy = y >> 16;
		ytPerm00 = PERM(iy + 0 + PERM(it + 0));
		ytPerm01 = PERM(iy + 0 + PERM(it + 1));
		ytPerm10 = PERM(iy + 1 + PERM(it + 0));
		ytPerm11 = PERM(iy + 1 + PERM(it + 1));

		__asm {
			mov 	eax, left
			  lea 	ebx, gPerm
			mov		esi, ebx
			mov 	edi, pvaluetab
			  mov 	x_loop, eax
			shl		eax, 16
			  mov	ecx, scalex
			shr		eax, cl				; scale x
			mov		ebx, eax			; ebx has copy of scaled x
			  mov	edx, ytPerm00		; prepare to generate v[0]
			shr		ebx, 16				; ebx has ix
			  mov	ecx, ytPerm01		; prepare to generate v[4]
			add		edx, ebx			; edx = ix + PERM(iy + PERM(iz))
			  mov	x, eax				; free up eax
			and		edx, TABMASK		; still generating v[0]
			  mov	eax, ytPerm10		; prepare to generate v[3]
			add		ecx, ebx			; ix + ytPerm01, still for v[4]
			  add	eax, ebx			; ix + ytPerm10, still for v[3]
			mov		 dl, [esi + edx]	; edx = PERM(ix + PERM(iy + PERM(iz)))
			  and	ecx, TABMASK		; still generating v[4]
			and		eax, TABMASK		; still generating v[3]
			  ;
			mov		edx, [edi + 4*edx]	; edx = vlattice(ix, iy, iz) = v[0]
			  mov	 cl, [esi + ecx]	; ecx = PERM(ix + PERM(iy + PERM(iz + 1)))
			movd	mm1, edx			; load mm1 with v[0]
			  ; must pair with an mmx instruction
			mov		ecx, [edi + 4*ecx]	; ecx = vlattice(ix, iy, iz+1) = v[4]
			  mov	 al, [esi + eax]	; eax = PERM(ix + PERM(iy + 1 + PERM(iz)))
			movd	mm0, ecx			; load mm0 with v[4]
			  psllq	mm1, 16				; mm1 has 0:0:v[0]:0
			mov		eax, [edi + 4*eax]	; eax = vlattice(ix, iy+1, iz) = v[3]
			  mov	edx, ytPerm11		; prepare to generate v[7]
			add		edx, ebx			; edx = ix + ytPerm11, for v[7]
			  mov	ecx, x				; prepare to generate fx, ifx
			movd	mm2, eax			; load mm2 with v[3]
			  por	mm1, mm0			; mm1 has 0:0:v[0]:v[4]
			and		edx, TABMASK		; still generating v[7]
			  and	ecx, 0xffff			; generate fx
			movd	mm3, ecx			; load mm3 with fx
			  psllq	mm1, 32				; mm1 has v[0]:v[4]:0:0
			mov		 dl, [esi + edx]	; edx = PERM(ix + PERM(iy+1 + PERM(iz+1)))
			  mov	eax, 0x0ffff		; prepare to generate ifx
			sub		eax, ecx			; eax = 0xffff - fx = ifx
			  inc	ebx					; ebx = ix + 1
			mov		edx, [edi + 4*edx]	; edx = vlattice(ix, iy+1, iz+1) = v[7]
			  ;
			movd	mm0, edx			; mm0 has 0:0:0:v[7]
			  psllq	mm2, 16				; mm2 has 0:0:v[3]:0
			movd	mm5, eax			; mm5 has 0:0:0:ifx
			  por	mm0, mm2			; mm0 has 0:0:v[3]:v[7]
			por		mm1, mm0			; mm1 has v[0]:v[4]:v[3]:v[7]
			  psllq	mm5, 16				; mm5 has 0:0:ifx:0
			pmaddwd	mm1, mm7			; mm1 has lerp(v[0], v[4], ft):lerp(v[3], v[7], ft)
			  mov	eax, y				; prepare to generate fy, ify
			mov		edx, 0xffff			; prepare to generate ify
			  and 	eax, 0xffff			; eax = fy
			sub 	edx, eax			; edx = ify
			  ;
			movd	mm0, eax			; mm0 has 0:0:0:fy
			  psrld	mm1, 15				; mm1 has vp[0]:vp[3], now signed 16 bits
			movd	mm6, edx			; mm6 has 0:0:0:ify
			  psllq	mm6, 16				; mm0 has 0:0:ify:0
			por		mm6, mm0			; mm6 has 0:0:ify:fy
			  packssdw mm1, mm1			; mm1 has vp[0]:vp[3]:vp[0]:vp[3]  
			psrlw	mm6, 1				; mm6 has 0:0:ify:fy, 15 bits (unsign -> sign)
			  por	mm5, mm3			; mm5 has 0:0:ifx:fx
			pmaddwd mm1, mm6			; mm1 has 0:lerp(vp[0], vp[3], fy)
			  psrlw	mm5, 1				; mm5 has 0:0:ifx:fx, 15 bits (unsign -> sign)
			  ;
			;
			  ;
			psrld	mm1, 15				; mm1 has vpp[0], now signed 16 bits 

			; at this point, the following registers have interesting things within:
;				ebx:		ix + 1
;				esi:		gPerm
;				edi:		pvaluetab
;				mm1:		0:vpp[0]
;				mm5:		0:0:fx:ifx
;				mm6:		0:0:fy:ify
;				mm7:		ft:ift:ft:ift
		
			; generate v[1], v[2], v[5] and v[6]
			; generate vp[1], vp[2]
			; generate vpp[1]
xloop_calc_vpp1:
			movq	mm0, mm1			; move vpp[0] to mm0
			  mov	eax, ytPerm00		; prepare to generate v[1]
			mov		ecx, ytPerm01		; prepare to generate v[5]
			  add	eax, ebx			; ix + 1 + ytPerm00 (v[1])
			add		ecx, ebx			; ix + 1 + ytPerm01 (v[5])
			  and	eax, TABMASK		; still generating v[1]
			and		ecx, TABMASK		; still generating v[5]
			  mov	edx, ytPerm10		; prepare to generate v[2]
			mov		 al, [esi + eax]	; eax = PERM(ix+1 + PERM(iy + PERM(iz)))
			  add	edx, ebx			; ix + 1 + ytPerm10 (v[2])
			mov		 cl, [esi + ecx]	; ecx = PERM(ix+1 + PERM(iy + PERM(iz+1)))
			  and	edx, TABMASK		; still generating v[2] 
			mov		eax, [edi + 4*eax]	; eax = vlattice(ix+1, iy, iz) = v[1]
			  ;	AGI
			mov		ecx, [edi + 4*ecx]	; ecx = vlattice(ix+1, iy, iz+1) = v[5]
			  mov	 dl, [esi + edx]	; edx = PERM(ix+1 + PERM(iy+1 + PERM(iz)))
			movd	mm1, eax			; mm1 = 0:0:0:v[1]
			  psllq	mm0, 32				; mm1 = vpp[0]:0 still signed 16 bits
			movd	mm2, ecx			; mm2 = 0:0:0:v[5]
			  psllq	mm1, 16				; mm1 = 0:0:v[1]:0
			mov		edx, [edi + 4*edx]	; edx = vlattice(ix+1, iy+1, iz) = v[2]
			  mov	eax, ytPerm11		; prepare to generate v[6]
			add		eax, ebx			; ix + 1 + ytPerm11 (v[6])
			  por	mm1, mm2			; mm1 = 0:0:v[1]:v[5]
			and		eax, TABMASK		; still generating v[6]
			  psllq	mm1, 32				; mm1 = v[1]:v[5]:0:0
			movd	mm3, edx			; mm3 = 0:0:0:v[2]
			  ;
			mov		 al, [esi + eax]	; eax = PERM(ix+1 + PERM(iy+1 + PERM(iz+1)))
			  psllq mm3, 16				; mm3 = 0:0:v[2]:0
			por		mm1, mm3			; mm1 = v[1]:v[5]:v[2]:0
			  ; AGI
			mov		eax, [edi + 4*eax]	; eax = vlattice(ix + 1, iy + 1, iz + 1)
			  ;
			movd	mm3, eax			; mm3 = 0:0:0:v[6]
			  ;
			por		mm1, mm3			; mm1 = v[1]:v[5]:v[2]:v[6]
			  ;
			pmaddwd	mm1, mm7			; mm1 = lerp(v[1], v[5], ft):lerp(v[2], v[6], ft)
			  ;
			;
			  ;
			; 
			  ;
			psrld	mm1, 15				; mm1 = vp[1]:vp[2], now signed 16 bits
			  ;
			packssdw	mm1, mm1		; mm1 = vp[1]:vp[2]:vp[1]:vp[2]
			  ;
			pmaddwd	mm1, mm6			; mm1 = 0:lerp(vp[1], vp[2], fy)
			  ;
			;
			  ;
			;
			  ;
			psrld	mm1, 15				; mm1 = 0:vpp[1]
			  ;
			por		mm0, mm1			; mm0 = vpp[0]:vpp[1]
			  ;
			packssdw	mm0, mm0		; mm0 = vpp[0]:vpp[1]:vpp[0]:vpp[1]
			  ;
		xloop_nocalc_vpp1:
			movq	mm2, mm0			; copy mm0 so we can use it again sometime
			  mov	eax, xinc			; prepare to increment pre-scaled x
			movq	mm3, mm4			; get noisescale
			  pmaddwd	mm2, mm5	   	; mm2 = lerp(vpp[0], vpp[1], fx) = noise
		    mov 	edx, x				; prepare to increment pre-scaled x
			  psllq	mm3, 32				; clear out high 32 bits...
			psrlq	mm3, 32				; finish clearing bits
			  add 	edx, eax			; generate (x + 1) >> m_nScaleX
			mov		eax, ebx			; save off last ix + 1
			  mov	ebx, edx			; prepare to make new ix
			pslld	mm2, 1				; make back into unsigned 32 bit
			  mov	ecx, edx			; prepare to make fx
			shr		ebx, 16				; ebx = ix
			  and	ecx, 0xffff			; ecx = fx
			mov		x, edx				; save x
			  mov 	edx, 0xffff			; prepare to make ifx
			movq	mm1, mm4			; prepare to get 1 << (31 - m_nNoiseScale)
			  inc	ebx					; ebx = ix + 1
			mov		esi, pSrcLine		; get pointer to source data
			  movd	mm5, ecx			; mm5 = 0:0:0:fx
		    psrlq	mm2, mm3			; noise = noise >> m_nNoiseScale
		      sub 	edx, ecx			; new ifx
			mov		ecx, 0				; clear ecx, so we can load just the low 8 bits
			  psrlq	mm1, 32				; mm1 = 0:1 << (31 - m_nNoiseScale)
			mov		cl, [esi]			; ecx = value = pSrcLine[x]
			  movd	mm3, ecx			; mm3 = 0:value
			psubd	mm2, mm1			; mm2 = 0:signednoise - (1 << (31 - m_nNoiseScale))
			  movd	mm1, edx			; mm1 = 0:0:0:ifx
			paddd	mm2, noiseoffset	; 
			  psllq	mm1, 16				; mm1 = 0:0:ifx:0
			paddd	mm3, mm2			; mm3 = value += signednoise
			  por	mm5, mm1			; mm5 = 0:0:ifx:fx
			movd	mm2, allone			; mm1 = 0:ffffffff
			  pxor	mm1, mm1			; mm1 = 0
			pcmpgtd	mm1, mm3			; if mm3 < 0, mm1 is x:ffffffff
			  packssdw mm3, mm3			; mm3 = value:value:value:value (clamped)
			pandn	mm1, mm2			; mm1 = !(mm1)
			  packuswb	mm3, mm3		; mm3 = value:value:value:value:value:value:value:value
			pand	mm1, mm3			; clamps to zero
			  mov	ecx, x_loop			; get the all-important loop variable
			mov		edx, right			; get the loop limit
			  inc	esi
			mov		pSrcLine, esi		; save off new source data pointer
			  mov	edi, pDestLine		; get the dest pointer
			inc 	ecx					; x_loop++
			  psrlw	mm5, 1				; convert to signed 16 bits
			cmp		ecx, edx			; are we quite done yet?
			  jge	xloop_done			; all done.. write out last value and get on with outer loop
			movd	edx, mm1			; edx = value
			  ;
			mov		[edi], dl			; write out new value
			  ;
			inc		edi
			  mov	x_loop, ecx			; save off the loop variable
			mov		pDestLine, edi		; save off new dest pointer
			  lea 	ecx, gPerm
			mov		esi, ecx
			  mov 	edi, pvaluetab
			cmp 	eax, ebx			; is lastix == ix
			  je	xloop_nocalc_vpp1	; if so, all we have to do is the last lerp
			movq	mm1, mm0			; mm1 = vpp[0]:vpp[1]:vpp[0]:vpp[1]
			  ;
			psllq	mm1, 48				; mm1 = vpp[1]:0:0:0
				psrlq	mm1, 48			; mm1 = 0:0:0:vpp[1]
			jmp		xloop_calc_vpp1		; if not, there be more calculating to do

		xloop_done:
			movd	edx, mm1			; edx = value
			  ;
			mov		[edi], dl			; write out new value
		}  
	}

	__asm {
		emms
	}

}


void CDXTAdditive::addsmoothturb8(int nTime, void *pDest, 
												int nDestPitch, void *pSrc, 
												int nSrcPitch, void *pMask, 
												int nMaskPitch) {
    int value = 0;
	DWORD noise = 0;

	int x, y, y_loop, x_loop, h_loop;
	unsigned char *pDestLine, *pSrcLine;
	int timexanimatex, timexanimatey;
	DWORD ft, ift, t;
	DWORD iy, it;
	DWORD fy, ify;
	DWORD ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	DWORD left, right;
	DWORD scalex, noiseoffset, *pValueTab, noisescale, normalize, *pScan;
	DWORD allone = 0xff;
	DWORD x_base, x_inc, x_base_save, x_inc_save;
	DWORD lastix;
	DWORD vpp0, vpp1;
#ifdef MEASURE_TIME
	FILE *fpOut;
	DWORD time, timeloop;
	static int lastxscale = -1;
	static int lastharmonics = -1;

	fpOut = fopen("c:\\inttime.txt", "a");
	if ((lastxscale != m_nScaleX) || (lastharmonics != m_nHarmonics)) {
		fprintf(fpOut, "X Scale = %d,  Harmonics = %d\n", m_nScaleX, m_nHarmonics);
		lastxscale = m_nScaleX;
		lastharmonics = m_nHarmonics;
	}
	time = timeGetTime();

	for (timeloop=0;timeloop<100;timeloop++) {
#endif

	nTime = nTime & 0x0ffff;		// keep things as expected...

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	// copy some member variables into locals, since the inline assembler
	// can't access them... unless it would be through the this pointer, maybe
	scalex = m_nScaleX;
	noiseoffset = m_nNoiseOffset;
	pValueTab = m_valueTab;
	pScan = m_pdwScanArray;
	normalize = 1 << (31 - m_nNoiseScale);
	noisescale = m_nNoiseScale;

	x_base_save = (((m_rActiveRect.left+timexanimatex) & 0xffff) << 16) >> m_nScaleX;
	left = m_rActiveRect.left;
	right = m_rActiveRect.right - 1;

	// setup the x_base -> prescaled x value at the left of every scan line

	// the scaled x value (starting at x_base) gets incremented this much 
	// at each texel
	x_inc_save = (1 << 16) >> m_nScaleX;

	// Time doesn't change at all in this function, so pre-cal all of it

	for (y_loop=m_rActiveRect.top; y_loop<m_rActiveRect.bottom;y_loop++) {
		// Setup the time vars
		t = (nTime) << 16;
		t = t >> m_nScaleTime;


		y = y_loop + timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;

		
		x_base = x_base_save;
		x_inc = x_inc_save;

		for (h_loop = m_nHarmonics - 1; h_loop >= 0; h_loop--) {
			x_loop = m_rActiveRect.left;
			x = x_base;

			iy = y >> 16;
			it = t >> 16;

			ft = gdwSmoothTable[(t & 0xffff) >> 8];
			ift = 0xffff - ft;

			fy = gdwSmoothTable[(y & 0xffff) >> 8];
			ify = 0xffff - fy;

			ytPerm00 = PERM(iy+0 + PERM(it+0));
			ytPerm01 = PERM(iy+0 + PERM(it+1));
			ytPerm10 = PERM(iy+1 + PERM(it+0));
			ytPerm11 = PERM(iy+1 + PERM(it+1));
			__asm {
				; first, calc v[0], v[4], v[3] and v[7]
				lea		edx, gPerm
				  mov	eax, x
				mov		edi, edx
				  mov	ebx, ytPerm01	; for v[4]
				shr		eax, 16
				  mov	ecx, ytPerm10	; for v[3]
				mov		esi, eax		; esi = ix
				  mov	eax, ytPerm00	; for v[0]
				add		eax, esi		; eax = ix + ytPerm00, for v[0]
				  add	ebx, esi		; ebx = ix + ytPerm01, for v[4]
				and		eax, TABMASK	; still generating v[0]
				  and	ebx, TABMASK	; still generating v[4]
				mov		edx, ytPerm11	; for v[7]
				  add	ecx, esi		; ecx = ix + ytPerm10, for v[3]
				add		edx, esi		; edx = ix + ytPerm11, for v[7]
				  mov	esi, pValueTab	; point esi to valuetable
				mov		eax, [edi + 4*eax] ; eax = PERM(ix + PERM(iy+0 + PERM(it+0)))
				  and	ecx, TABMASK	; still generating v[3]
				mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix + PERM(iy+0 + PERM(it+1)))
				  and	edx, TABMASK	; still generating v[7]
				mov		eax, [esi + 4*eax] ; eax = v[0]
				  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix + PERM(iy+1 + PERM(it+0)))
				mov		ebx, [esi + 4*ebx] ; ebx = v[4]
				  mov	edx, [edi + 4*edx] ; edx = PERM(ix + PERM(iy+1 + PERM(it+1)))
				mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
				  mov	ecx, [esi + 4*ecx] ; ecx = v[3]
				mov		edx, [esi + 4*edx] ; edx = v[7]
				  mov	esi, ift		; prepare to multiply with esi
				imul	ebx, edi		; ebx = v[4] * ft
				  ; wait 10 cycles
				imul	eax, esi		; eax = v[0] * ift
				  ; wait another 10 cycles
				imul	edx, edi		; edx = v[7] * ft
				  ; wait yet another 10 cycles
				imul	ecx, esi		; ecx = v[3] * ift
				  ; wait even yet another 10 cycles
				add		eax, ebx		; eax = smoothstep(v[0], v[4], ft)
				  mov	ebx, fy			; ebx = fy....
				shr		eax, 16			; eax = vp[0]
				  add	ecx, edx		; ecx = smoothstep(v[3], v[7], ft)
				shr		ecx, 16			; ecx = vp[3]
				  mov	edx, ify		; edx = ify
				imul	eax, edx		; eax = vp[0] * ify
				  ; wait more cycles
				imul	ecx, ebx		; ecx = vp[3] * fy
				  ; another 10 cycle hit
				add		eax, ecx		; eax = smoothstep(vp[0], vp[3], fy)
				  ;
				shr		eax, 16			; eax = vpp[0]
				  ;
				mov		vpp0, eax		; save off vpp[0] for later
			x_loop_calc:
				; assumptions:
				lea		edx, gPerm
				  mov	eax, x
				mov		edi, edx
				  mov	ebx, ytPerm01	; for v[5]
				shr		eax, 16
				  mov	ecx, ytPerm10	; for v[2]
				mov		lastix, eax		; save off this ix value to look at next time
				  inc	eax
				mov		esi, eax		; esi = ix + 1
				  mov	eax, ytPerm00	; for v[1]
				add		eax, esi		; eax = ix + ytPerm00, for v[1]
				  add	ebx, esi		; ebx = ix + ytPerm01, for v[5]
				and		eax, TABMASK	; still generating v[1]
				  and	ebx, TABMASK	; still generating v[5]
				mov		edx, ytPerm11	; for v[6]
				  add	ecx, esi		; ecx = ix + ytPerm10, for v[2]
				add		edx, esi		; edx = ix + ytPerm11, for v[6]
				  mov	esi, pValueTab	; point esi to valuetable
				mov		eax, [edi + 4*eax] ; eax = PERM(ix+1 + PERM(iy+0 + PERM(it+0)))
				  and	ecx, TABMASK	; still generating v[2]
				mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix+1 + PERM(iy+0 + PERM(it+1)))
				  and	edx, TABMASK	; still generating v[6]
				mov		eax, [esi + 4*eax] ; eax = v[1]
				  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix+1 + PERM(iy+1 + PERM(it+0)))
				mov		ebx, [esi + 4*ebx] ; ebx = v[5]
				  mov	edx, [edi + 4*edx] ; edx = PERM(ix+1 + PERM(iy+1 + PERM(it+1)))
				mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
				  mov	ecx, [esi + 4*ecx] ; ecx = v[2]
				mov		edx, [esi + 4*edx] ; edx = v[6]
				  mov	esi, ift		; prepare to multiply with esi
				imul	ebx, edi		; ebx = v[5] * ft
				  ; wait 10 cycles
				imul	eax, esi		; eax = v[1] * ift
				  ; wait another 10 cycles
				imul	edx, edi		; edx = v[6] * ft
				  ; wait yet another 10 cycles
				imul	ecx, esi		; ecx = v[2] * ift
				  ; wait even yet another 10 cycles
				add		eax, ebx		; eax = smoothstep(v[1], v[5], ft)
				  mov	ebx, fy			; ebx = fy....
				shr		eax, 16			; eax = vp[1]
				  add	ecx, edx		; ecx = smoothstep(v[2], v[6], ft)
				shr		ecx, 16			; ecx = vp[2]
				  mov	edx, ify		; edx = ify
				imul	eax, edx		; eax = vp[1] * ify
				  ; wait more cycles
				imul	ecx, ebx		; ecx = vp[2] * fy
				  ; another 10 cycle hit
				add		eax, ecx		; eax = smoothstep(vp[1], vp[2], fy)
				  ;
				shr		eax, 16			; eax = vpp[1]
				  ;
				mov		vpp1, eax
			x_loop_nocalc:			
				mov		edx, x			; get the prescaled x
				  mov	ebx, x_inc		; get scaled x increment
				add		ebx, edx		; ebx = x + x_inc -> new scaled x
				  lea	esi, gdwSmoothTable
				and		edx, 0xffff		; edx = fx
				  mov	x, ebx			; save off new x
				shr		edx, 8			; get upper 8 bits of fx
				  mov	ecx, vpp0		; get vpp[0]
				mov		ebx, 0xffff		; prepare to calc ifx
				  mov	edi, pScan		; prepare to write out to scan array
				mov		edx, [esi + 4*edx]	; edx = smooth fx
				  sub	ebx, edx		; ebx = ifx
				imul	edx, eax		; edx = vpp[1] * fx
				  ; imul, besides being 10 cycles, is also not pairable
				imul	ecx, ebx		; ecx = vpp[0] * ifx
				  ; sigh
				add		edx, ecx		; edx = smoothstep(vpp[0], vpp[1], fx)
				  mov	eax, x_loop		; prepare to write out to scan array
				shr		edx, 1			; prepare to normalize around 0
				  mov	ecx, h_loop		; prepare to scale noisevalue as a function of harmonics
				sub		edx, 0x3fffffff	; normalize about 0
				  mov	ebx, [edi+4*eax]; get scan array value
				sar		edx, cl			; "divide" by harmonics value
				  ;	shift by cl doesn't pair
				add		edx, ebx		; edx = new scan array value
				  mov	ebx, right		; get right edge
				mov		[edi+4*eax], edx	; save off new scan array value
				  cmp	eax, ebx		; check if at right edge of scan line
				jge		x_loop_done		; if so, goto done code
				  mov	edx, x			; get already-incremented x value
				mov		ebx, lastix		; get last ix value
				  inc	eax				; x_loop++
				shr		edx, 16			; get new ix value
				  mov	x_loop, eax		; save off x_loop
				mov		eax, vpp1		; get back vpp[1]
				  cmp	edx, ebx		; is lastix == ix?
				je		x_loop_nocalc	; if so, we only need to recalc a few things
				  mov	vpp0, eax		; save off this vpp[1] to be the next vpp[0]
				jmp		x_loop_calc		; go make more noise
			x_loop_done:
			} // end asm block (and x loop)
			t = t >> 1;
			y = y >> 1;		
			x_base = x_base >> 1;
			x_inc = x_inc >> 1;
		} // end harmonics loop

		pDestLine = ((unsigned char *)pDest) + nDestPitch*y_loop;
		pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;

		__asm {
			mov		eax, left		; get left side of scan line
			  mov	edi, pScan		; get pointer to noise array
			mov		esi, pSrcLine	; get pointer to source data
			  mov	ecx, noisescale	; get noise scale into cl

		noise_loop:
			mov		edx, [edi+4*eax]; edx = pScan[x_loop]
			  xor	ebx, ebx		; zero out ebx
			mov		bl, [esi+eax]	; get source pixel value
			  mov	esi, pDestLine	; get pointer to dest data
			mov		dword ptr [edi+4*eax], 0x0000000	; zero out pScan[x_loop]
			  add	esi, eax		; free up eax
			sar		edx, cl			; scale the noise value
			  ; doesn't pair - 4 clocks
			mov		ecx, noiseoffset; get noiseoffset value
			  inc	eax				; x_loop++
			add		edx, ecx		; noise += noiseoffset
			  mov	ecx, right		; 
			add		ebx, edx		; value += noise
			  mov	edi, eax		; save x_loop++ for a little while 
			sets	dl				; if (value < 0) dl = 1, else dl = 0 
			  ; setcc doesn't pair
			dec		dl				; if (value < 0) dl = 0, else dl = 0x0ff
			  cmp	ebx, 0xff		; test to see if bigger than 255
			setle	al				; if (value > 255) al = 0 else al = 1
			  ; setcc still doesn't pair, darn it
			and		bl, dl			; if (value < 0) dl = 0 (clamp to 0)
			  dec	al				; if (value > 255) bl = 0xff else bl = 0
			or		bl, al			; clamp to 255
			  mov	[esi], bl		; write new pixel value to dest
			mov		eax, edi		; get back x_loop++
			  mov	edi, pScan		; get pointer back
			cmp		eax, ecx		; see if we're done yet
			  mov	esi, pSrcLine	; get pointer to source buffer
			mov		ecx, noisescale	; get noise scale into cl
			  jle	noise_loop		; jump if not done with all the noise values
		} // end asm block
	} // end y loop
#ifdef MEASURE_TIME
	}
	fprintf(fpOut, "%d ms\n", timeGetTime() - time);
	fclose(fpOut);
#endif
}



void CDXTAdditive::addsmoothturb8mmx(int nTime, void *pDest, 
													int nDestPitch, void *pSrc, 
													int nSrcPitch, void *pMask, 
													int nMaskPitch) {
 
	DWORD x, y, t;
	DWORD	ft, fy, ift, ify, fx, ifx;
	DWORD iy, it, ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	int y_loop, h_loop, x_loop;
	DWORD x_base, x_inc;
	int right, left;
	DWORD *pScan;
	DWORD timexanimatex, timexanimatey;
	DWORD *pValueTab, noiseoffset, noisescale;
	DWORD lastix;

	unsigned char *pSrcLine, *pDestLine;
#ifdef MEASURE_TIME
	FILE *fpOut;
	DWORD time, timeloop;
	static int lastxscale = -1;
	static int lastharmonics = -1;

	fpOut = fopen("c:\\mmxtime.txt", "a");
	if ((lastxscale != m_nScaleX) || (lastharmonics != m_nHarmonics)) {
		fprintf(fpOut, "X Scale = %d,  Harmonics = %d\n", m_nScaleX, m_nHarmonics);
		lastxscale = m_nScaleX;
		lastharmonics = m_nHarmonics;
	}
	time = timeGetTime();

	for (timeloop=0;timeloop<100;timeloop++) {
#endif

	nTime = nTime & 0xffff;		// keep things as expected...

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	left = m_rActiveRect.left;
	right = m_rActiveRect.right - 1;

	pValueTab = m_valueTab;
	pScan = m_pdwScanArray;

	noiseoffset = m_nNoiseOffset;
	noisescale = m_nNoiseScale;

	for (y_loop = m_rActiveRect.top; y_loop < m_rActiveRect.bottom; y_loop++) {
		t = (nTime) << 16;
		t = t >> m_nScaleTime;

		y = y_loop + timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;

		
		x_base = ((left+timexanimatex) & 0xffff) << 16;
		x_base = x_base >> m_nScaleX;

		x_inc = (1 << 16) >> m_nScaleX;

		for (h_loop = m_nHarmonics - 1; h_loop >= 0; h_loop--) {
			x_loop = m_rActiveRect.left;
			x = x_base;

			iy = y >> 16;
			it = t >> 16;

			ft = gdwSmoothTable[(t & 0xffff) >> 8];
			ft = ft >> 1;			// cvt to signed
			ift = 0x7fff - ft;

			fy = gdwSmoothTable[(y & 0xffff) >> 8];
			fy = fy >> 1;			// cvt to signed
			ify = 0x7fff - fy;

			fx = gdwSmoothTable[(x & 0xffff) >> 8];
			fx = fx >> 1;			// cvt to signed
			ifx = 0x7fff - fx;

			ytPerm00 = PERM(iy+0 + PERM(it+0));
			ytPerm01 = PERM(iy+0 + PERM(it+1));
			ytPerm10 = PERM(iy+1 + PERM(it+0));
			ytPerm11 = PERM(iy+1 + PERM(it+1));
			__asm {
				lea		edi, gPerm			; load edi with pointer to perm table
				  mov	eax, ift			; preparing to load mm7 with ift:ft:ift:ft
				movd	mm7, eax			; mm7 = 0:ift
				  ; must pair with an mmx inst.
				mov		eax, ft				; preparing to load mm7 with ift:ft:ift:ft
				  mov	esi, x				; preparing to get ix
				shr		esi, 16				; esi = ix
				  mov	ebx, ytPerm01		; for v[4]
				movd	mm4, eax			; mm4 = 0:ft
				  psllq	mm7, 32				; mm7 = ift:0
				mov		eax, ytPerm00		; for v[0]
				  add	ebx, esi			; ebx = ix + ytPerm01, for v[4]
				mov		ecx, ytPerm10		; for v[3]
				  add	eax, esi			; eax = ix + ytPerm00, for v[0]
				mov		edx, ytPerm11		; for v[7]
				  and	eax, TABMASK		; clamp to (0,255), for v[0]
				and		ebx, TABMASK		; clamp to (0,255), for v[4]
				  add	ecx, esi			; ecx = ix + ytPerm10, for v[3]
				add		edx, esi			; edx = ix + ytPerm11, for v[7]
				  mov	esi, pValueTab		; load esi with pointer to random value table
				mov		eax, [edi+4*eax]	; get hash value from table
				  and	ecx, TABMASK		; clamp to (0, 255), for v[3]
				mov		ebx, [edi+4*ebx]	; get hash value from table
				  and	edx, TABMASK		; clamp to (0, 255), for v[7]
				mov		ecx, [edi+4*ecx]	; get hash value from table
				  mov	eax, [esi+4*eax]	; eax = v[0]
				movd	mm0, eax			; mm0 = 0:v[0]
				  por	mm7, mm4			; mm7 = ift:ft
				mov		ebx, [esi+4*ebx]	; ebx = v[4]
				  mov	edx, [edi+4*edx]	; get hash value from table
				mov		ecx, [esi+4*ecx]	; ecx = v[3]
				  packssdw	mm7, mm7		; mm7 = ift:ft:ift:ft
				mov		eax, ify			; preparing to load mm6 with 0:0:ify:fy
				  mov	edx, [esi+4*edx]	; edx = v[7]
				movd	mm4, ebx			; mm4 = 0:v[4]
				  psllq	mm0, 32				; mm0 = v[0]:0
				movd	mm3, ecx			; mm3 = 0:v[3]
				  por	mm0, mm4			; mm0 = v[0]:v[4]
				movd	mm4, edx			; mm4 = 0:v[7]
				  psllq	mm3, 32				; mm3 = v[3]:0
				movd	mm6, eax			; mm2 = 0:ify
				  por	mm3, mm4			; mm3 = v[3]:v[7]
				packssdw	mm3, mm0		; mm3 = v[0]:v[4]:v[3]:v[7]
				  mov	eax, fy				; preparing to load mm6 with 0:0:ify:fy
				movd	mm2, eax			; mm2 = 0:fy
				pmaddwd	mm3, mm7			; mm3 = lerp(v[0], v[4], ft):lerp(v[3], v[7], ft)
				  mov	ebx, x				; prepare to get ix again
				shr		ebx, 16				; ebx = ix
				  psllq	mm6, 16				; mm6 = 0:0:ify:0
				por	mm6, mm2			; mm6 = 0:0:ify:fy
				  mov	eax, ifx			; prepare to setup mm5 with 0:0:ifx:fx
				psrld	mm3, 15				; mm3 has 0:vp[0]:0:vp[3], signed
				packssdw	mm3, mm3		; mm3 = vp[0]:vp[3]:vp[0]:vp[3]
				  mov	ecx, h_loop			; prepare to setup mm4 with h_loop (for shifting)
				movd	mm5, eax			; mm5 = 0:ifx
				  pmaddwd	mm3, mm6		; mm3 = 0:lerp(vp[0], vp[3], fy)
				mov		edx, fx				; prepare to setup mm5 with 0:0:ifx:fx
				  inc	ecx					; ecx = h_loop + 1 (gets rid of a shift by one later)
				movd	mm2, edx			; mm2 = 0:fx
				  psllq	mm5, 16				; mm5 = 0:0:ifx:0
				movd	mm4, ecx			; mm4 = h_loop+1
				  por	mm5, mm2			; mm5 = 0:0:ifx:fx
				inc		ebx					; ebx = ix + 1
				  psrld	mm3, 15				; mm3 = 0:vpp[0]

				; at this point, the following registers have interesting things contained within:
				; 
				; ebx		ix + 1
				; esi		pValueTab
				; edi		gPerm
				; mm3		vpp[0]
				; mm4		h_loop
				; mm5		0:0:ifx:fx
				; mm6		0:0:ify:fy
				; mm7		ift:ft:ift:ft
		x_calc_loop:
				mov			eax, ytPerm00	; prepare to calc v[1]
				  mov		ecx, ytPerm01	; prepare to calc v[5]
				add			eax, ebx		; eax = ix + 1 + ytPerm00, for v[1]
				  mov		edx, ytPerm10	; prepare to calc v[2]
				add			ecx, ebx		; ecx = ix + 1 + ytPerm01, for v[5]
				  and		eax, TABMASK	; clamp to (0, 255)
				and			ecx, TABMASK	; clamp to (0, 255)
				  add		edx, ebx		; edx = ix + 1 + ytPerm10, for v[2]
				and			edx, TABMASK	; clamp to (0, 255)
				  mov		eax, [edi + 4*eax]	; get hash value from table
				mov			ecx, [edi + 4*ecx]	; get hash value from table
				  mov		edx, [edi + 4*edx]	; get hash value from table (might be a bank conflict)
				mov			eax, [esi + 4*eax]	; eax = v[1]
				  ; movd, below, is U pipe only
				movd		mm0, eax			; mm0 = 0:v[1]
				  ; must pair with mmx instruction
				mov			eax, ytPerm11		; prepare to calc v[6]
				  mov		ecx, [esi + 4*ecx]	; ecx = v[5]
				add			eax, ebx			; eax = ix + 1 + ytPerm11, for v[6]
				  mov		edx, [esi + 4*edx]	; edx = v[2]
				and			eax, TABMASK		; clamp to (0, 255)
				  mov		lastix, ebx			; save off last ix+1 value
				movd		mm1, ecx			; mm1 = 0:v[5]
				  psllq		mm0, 32				; mm0 = v[1]:0
				mov			eax, [edi + 4*eax]	; get hash value from table for v[6]
				  mov		ecx, x				; prepare to calc fx
				movd		mm2, edx			; mm2 = 0:v[2]
				  por		mm0, mm1			; mm0 = v[1]:v[5]
				mov			eax, [esi + 4*eax]	; eax = v[6]
				  and		ecx, 0xffff			; ecx = fx
				movd		mm1, eax			; mm1 = 0:v[6]
				  psllq		mm2, 32				; mm2 = v[2]:0
				shr			ecx, 8				; ecx = upper 8 bits of fx
				  por		mm1, mm2			; mm1 = v[2]:v[6]
				packssdw	mm1, mm0			; mm1 = v[1]:v[5]:v[2]:v[6]
				  lea		edi, gdwSmoothTable	; load edi with pointer to smoothing table
				pmaddwd		mm1, mm7			; mm1 = lerp(v[1], v[5], ft):lerp(v[2], v[6], ft)
				  mov		eax, 0xffff			; prepare eax to get smooth ifx
				mov			ecx, [edi + 4*ecx]	; load up ecx with smooth fx
				  mov		esi, pScan			; load up esi with pointer to scan array
				sub			eax, ecx			; eax = smoothed ifx
				  mov		edx, x_loop			; load up edx with current x_loop
				movd		mm5, eax			; mm5 = 0:ifx
				  psrld		mm1, 15				; mm1 = vp[1]:vp[2]
				movd		mm0, ecx			; mm0 = 0:fx
				  packssdw	mm1, mm1			; mm1 = vp[1]:vp[2]:vp[1]:vp[2]
				pmaddwd		mm1, mm6			; mm1 = 0:lerp(vp[1], vp[2], fy)
				  psllq		mm5, 16				; mm5 = 0:0:ifx:0
				por			mm5, mm0			; mm5 = 0:0:ifx:fx
				  lea		esi, [esi + 4*edx]	; load up esi with pointer to THIS VERY NOISE VALUE LOCATION!
				psrlw		mm5, 1				; mm5 = 0:0:ifx:fx, signed
				  ;
				psrld		mm1, 15				; mm1 = vpp[1]
				  psllq		mm3, 16				; mm3 = 0:0:vpp[0]:0
				por			mm3, mm1			; mm3 = 0:0:vpp[0]:vpp[1]
				; at this point, the following registers have interesting things contained within:
				;
				; ebx		ix + 1
				; edx		x_loop
				; esi		pScan + 4*x_loop
				; edi		gdwSmoothTable
				; mm1		vpp[1]
				; mm3		0:0:vpp[0]:vpp[1]
				; mm4		h_loop
				; mm5		0:0:ifx:fx
				; mm6		0:0:ify:fy
				; mm7		ift:ft:ift:ft
			x_nocalc_loop:
				pmaddwd		mm5, mm3			; mm5 = 0:lerp(vpp[0], vpp[1], fx)
				  mov		eax, [esi]			; eax = old noise value at this location
				mov			ecx, right			; load up the right edge
				  pcmpeqd	mm0, mm0			; load up mm0 with all ones
				psrlq		mm0, 35				; mm0 = 0:0x1fffffff
				  cmp		edx, ecx			; are we quite done yet?
				psubd		mm5, mm0			; mm5 = normalized about 0 noise
				  jge		x_loop_done			; if so, finish & bail
				inc			edx					; edx = x_loop++
				  psrad		mm5, mm4			; 'divide' by # of harmonics
				mov			x_loop, edx			; save off x_loop value
				  mov		ecx, x				; get last x value
				mov			edx, x_inc			; get x increment
				  ;
				add			ecx, edx			; generate new x
				  mov		ebx, ecx			; get copy of new x to calc new ix + 1
				mov			x, ecx				; save off new x
				shr			ebx, 16				; ebx = new ix
			      mov		edx, 0xffff			; to calc new ifx, new fx
				and			ecx, edx			; ecx = new fx
				  shr		ecx, 8				; ecx = upper 8 bits new fx
				; AGI
				mov			ecx, [edi + 4*ecx]	; ecx = smooth fx
				  inc		ebx					; ebx = new ix + 1
				sub			edx, ecx			; edx = new ifx
				  ;
				movd		mm0, edx			; mm0 = 0:0:0:ifx
				  ;
				movd		mm2, ecx			; mm2 = 0:0:0:fx
				  pslld		mm0, 16				; mm0 = 0:0:ifx:0
				movd		edx, mm5			; edx = new noise value to be added
			  	  por		mm0, mm2			; mm0 = 0:0:ifx:fx
				add			eax, edx			; eax = new noise value
				  movq		mm5, mm0			; mm5 = 0:0:ifx:fx
				mov			[esi], eax			; write out new noise value
				  add		esi, 4				; move pointer one DWORD
				mov			eax, lastix			; get lastix+1
				  mov		edx, x_loop			; get x_loop value back into edx
				cmp			eax, ebx			; does lastix+1 == new ix+1?
				psrlw		mm5, 1				; mm5 = 0:0:ifx:fx, signed
				  je		x_nocalc_loop		; if so, go do this again

				movq		mm1, mm3			; mm3 = new vpp[0] (old vpp[1])
				  mov		esi, pValueTab
				lea			edi, gPerm
				jmp			x_calc_loop
			x_loop_done:
				psrad		mm5, mm4			; 'divide' by # of harmonics
				  ; STALLOLA - should insert the c code below here.
				movd		edx, mm5			; edx = new noise value to be added
				  ;
				add			eax, edx			; eax = new noise value
				  ;
				mov			[esi], eax			; write out last noise value
			} // asm block (and x loop)

			t = t >> 1;
			y = y >> 1;		
			x_base = x_base >> 1;
			x_inc = x_inc >> 1;

		} // harmonics loop


		pDestLine = ((unsigned char *)pDest) + nDestPitch*y_loop;
		pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;

		__asm {
			mov		eax, left		; get left side of scan line
			  mov	edi, pScan		; get pointer to noise array
			mov		esi, pSrcLine	; get pointer to source data
			  mov	ecx, noisescale	; get noise scale into cl

		noise_loop:
			mov		edx, [edi+4*eax]; edx = pScan[x_loop]
			  xor	ebx, ebx		; zero out ebx
			mov		bl, [esi+eax]	; get source pixel value
			  mov	esi, pDestLine	; get pointer to dest data
			mov		dword ptr [edi+4*eax], 0x0000000	; zero out pScan[x_loop]
			  add	esi, eax		; free up eax
			sar		edx, cl			; scale the noise value
			  ; doesn't pair - 4 clocks
			mov		ecx, noiseoffset; get noiseoffset value
			  inc	eax				; x_loop++
			add		edx, ecx		; noise += noiseoffset
			  mov	ecx, right		; 
			add		ebx, edx		; value += noise
			  mov	edi, eax		; save x_loop++ for a little while 
			sets	dl				; if (value < 0) dl = 1, else dl = 0 
			  ; setcc doesn't pair
			dec		dl				; if (value < 0) dl = 0, else dl = 0x0ff
			  cmp	ebx, 0xff		; test to see if bigger than 255
			setle	al				; if (value > 255) al = 0 else al = 1
			  ; setcc still doesn't pair, darn it
			and		bl, dl			; if (value < 0) dl = 0 (clamp to 0)
			  dec	al				; if (value > 255) bl = 0xff else bl = 0
			or		bl, al			; clamp to 255
			  mov	[esi], bl		; write new pixel value to dest
			mov		eax, edi		; get back x_loop++
			  mov	edi, pScan		; get pointer back
			cmp		eax, ecx		; see if we're done yet
			  mov	esi, pSrcLine	; get pointer to source buffer
			mov		ecx, noisescale	; get noise scale into cl
			  jle	noise_loop		; jump if not done with all the noise values
		} // end asm block
	}

	__asm {
		emms
	}
#ifdef MEASURE_TIME
	}
	fprintf(fpOut, "%d ms\n", timeGetTime() - time);
	fclose(fpOut);
#endif

}


void CDXTAdditive::addsmoothnoise16(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
	int x, y;
	WORD *pDestLine, *pSrcLine;
    int value = 0;
	DWORD noise = 0;
	int	signednoise;
	int timexanimatex, timexanimatey;
	WORD *pwPalette;
						    
	pwPalette = (WORD *) m_pPalette;

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	for (y=m_rActiveRect.top; y<m_rActiveRect.bottom;y++) {
		pDestLine = ((WORD *)pDest) + nDestPitch*y;
		pSrcLine  = ((WORD *)pSrc)  + nSrcPitch *y;
		for (x=m_rActiveRect.left; x<m_rActiveRect.right; x++) {
			value = pSrcLine[x];
			if (m_nNoiseScale != 32) {
				noise = smoothnoise(x+timexanimatex, y+timexanimatey, nTime, m_nScaleX, m_nScaleY, m_nScaleTime);
				noise = noise >> m_nNoiseScale;
				signednoise = noise;
				signednoise = signednoise - (1 << (31 - m_nNoiseScale));

				signednoise += m_nNoiseOffset;
				value += signednoise;
				// clamp
				if (value < 0) value = 0;
				if (value > m_nPaletteSize) value = m_nPaletteSize;
			}
			pDestLine[x] = pwPalette[value];
		}
	}
}

void CDXTAdditive::addsmoothturb16(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
	int x, y;
	WORD *pDestLine, *pSrcLine;
    int value = 0;
	DWORD noise = 0;
	int	signednoise;
	int timexanimatex, timexanimatey;
	WORD *pwPalette;
						    
	pwPalette = (WORD *) m_pPalette;

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	for (y=m_rActiveRect.top; y<m_rActiveRect.bottom;y++) {
		pDestLine = ((WORD *)pDest) + nDestPitch*y;
		pSrcLine  = ((WORD *)pSrc)  + nSrcPitch *y;
		for (x=m_rActiveRect.left; x<m_rActiveRect.right; x++) {
			value = pSrcLine[x];
			if (m_nNoiseScale != 32) {
				signednoise = smoothturbulence(x+timexanimatex, y+timexanimatey, nTime);
				signednoise = signednoise >> m_nNoiseScale;

				signednoise += m_nNoiseOffset;
				value += signednoise;
				if (value < 0) value = 0;
				if (value > m_nPaletteSize) value = m_nPaletteSize;
			}
			pDestLine[x] = pwPalette[value];
		}
	}
}

void CDXTAdditive::addsmoothturb32(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
    int value = 0;
	DWORD noise = 0;

	int x, y, y_loop, x_loop, h_loop;
	unsigned char *pSrcLine;
	DWORD *pDestLine;
	int timexanimatex, timexanimatey;
	DWORD ft, ift, t;
	DWORD iy, it;
	DWORD fy, ify;
	DWORD ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	DWORD left, right;
	DWORD scalex, noiseoffset, *pValueTab, noisescale, normalize, *pScan;
	DWORD allone = 0xff;
	DWORD x_base, x_inc, x_base_save, x_inc_save;
	DWORD lastix;
	DWORD vpp0, vpp1;
	DWORD *pPalette;
	DWORD	alphamask;




#ifdef MEASURE_TIME
	DWORD time, timeloop;
	char buf[80];

	time = timeGetTime();

	for (timeloop=0;timeloop<100;timeloop++) {
#endif
	if (m_alphaActive == 1) 
		alphamask = 0x80000000;
	else 
		alphamask = 0xff000000;

	nDestPitch = nDestPitch >> 2;

	nTime = nTime & 0x0ffff;		// keep things as expected...

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	// copy some member variables into locals, since the inline assembler
	// can't access them... unless it would be through the this pointer, maybe
	scalex = m_nScaleX;
	noiseoffset = m_nNoiseOffset;
	pValueTab = m_valueTab;
	pScan = m_pdwScanArray;
	normalize = 1 << (31 - m_nNoiseScale);
	noisescale = m_nNoiseScale;
	pPalette = 	(DWORD *) m_pPalette;


	x_base_save = (((m_rActiveRect.left+timexanimatex) & 0xffff) << 16) >> m_nScaleX;
	left = m_rActiveRect.left;
	right = m_rActiveRect.right - 1;

	// setup the x_base -> prescaled x value at the left of every scan line

	// the scaled x value (starting at x_base) gets incremented this much 
	// at each texel
	x_inc_save = (1 << 16) >> m_nScaleX;

	// Time doesn't change at all in this function, so pre-cal all of it

	for (y_loop=m_rActiveRect.top; y_loop<m_rActiveRect.bottom;y_loop++) {
		// Setup the time vars
		t = (nTime) << 16;
		t = t >> m_nScaleTime;


		y = y_loop + timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;

		
		x_base = x_base_save;
		x_inc = x_inc_save;

		for (h_loop = m_nHarmonics - 1; h_loop >= 0; h_loop--) {
			x_loop = m_rActiveRect.left;
			x = x_base;

			iy = y >> 16;
			it = t >> 16;

			ft = gdwSmoothTable[(t & 0xffff) >> 8];
			ift = 0xffff - ft;

			fy = gdwSmoothTable[(y & 0xffff) >> 8];
			ify = 0xffff - fy;

			ytPerm00 = PERM(iy+0 + PERM(it+0));
			ytPerm01 = PERM(iy+0 + PERM(it+1));
			ytPerm10 = PERM(iy+1 + PERM(it+0));
			ytPerm11 = PERM(iy+1 + PERM(it+1));
			__asm {
				; first, calc v[0], v[4], v[3] and v[7]
				lea		edx, gPerm
				  mov	eax, x
				mov		edi, edx
				  mov	ebx, ytPerm01	; for v[4]
				shr		eax, 16
				  mov	ecx, ytPerm10	; for v[3]
				mov		esi, eax		; esi = ix
				  mov	eax, ytPerm00	; for v[0]
				add		eax, esi		; eax = ix + ytPerm00, for v[0]
				  add	ebx, esi		; ebx = ix + ytPerm01, for v[4]
				and		eax, TABMASK	; still generating v[0]
				  and	ebx, TABMASK	; still generating v[4]
				mov		edx, ytPerm11	; for v[7]
				  add	ecx, esi		; ecx = ix + ytPerm10, for v[3]
				add		edx, esi		; edx = ix + ytPerm11, for v[7]
				  mov	esi, pValueTab	; point esi to valuetable
				mov		eax, [edi + 4*eax] ; eax = PERM(ix + PERM(iy+0 + PERM(it+0)))
				  and	ecx, TABMASK	; still generating v[3]
				mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix + PERM(iy+0 + PERM(it+1)))
				  and	edx, TABMASK	; still generating v[7]
				mov		eax, [esi + 4*eax] ; eax = v[0]
				  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix + PERM(iy+1 + PERM(it+0)))
				mov		ebx, [esi + 4*ebx] ; ebx = v[4]
				  mov	edx, [edi + 4*edx] ; edx = PERM(ix + PERM(iy+1 + PERM(it+1)))
				mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
				  mov	ecx, [esi + 4*ecx] ; ecx = v[3]
				mov		edx, [esi + 4*edx] ; edx = v[7]
				  mov	esi, ift		; prepare to multiply with esi
				imul	ebx, edi		; ebx = v[4] * ft
				  ; wait 10 cycles
				imul	eax, esi		; eax = v[0] * ift
				  ; wait another 10 cycles
				imul	edx, edi		; edx = v[7] * ft
				  ; wait yet another 10 cycles
				imul	ecx, esi		; ecx = v[3] * ift
				  ; wait even yet another 10 cycles
				add		eax, ebx		; eax = smoothstep(v[0], v[4], ft)
				  mov	ebx, fy			; ebx = fy....
				shr		eax, 16			; eax = vp[0]
				  add	ecx, edx		; ecx = smoothstep(v[3], v[7], ft)
				shr		ecx, 16			; ecx = vp[3]
				  mov	edx, ify		; edx = ify
				imul	eax, edx		; eax = vp[0] * ify
				  ; wait more cycles
				imul	ecx, ebx		; ecx = vp[3] * fy
				  ; another 10 cycle hit
				add		eax, ecx		; eax = smoothstep(vp[0], vp[3], fy)
				  ;
				shr		eax, 16			; eax = vpp[0]
				  ;
				mov		vpp0, eax		; save off vpp[0] for later
			x_loop_calc:
				; assumptions:
				lea		edx, gPerm
				  mov	eax, x
				mov		edi, edx
				  mov	ebx, ytPerm01	; for v[5]
				shr		eax, 16
				  mov	ecx, ytPerm10	; for v[2]
				mov		lastix, eax		; save off this ix value to look at next time
				  inc	eax
				mov		esi, eax		; esi = ix + 1
				  mov	eax, ytPerm00	; for v[1]
				add		eax, esi		; eax = ix + ytPerm00, for v[1]
				  add	ebx, esi		; ebx = ix + ytPerm01, for v[5]
				and		eax, TABMASK	; still generating v[1]
				  and	ebx, TABMASK	; still generating v[5]
				mov		edx, ytPerm11	; for v[6]
				  add	ecx, esi		; ecx = ix + ytPerm10, for v[2]
				add		edx, esi		; edx = ix + ytPerm11, for v[6]
				  mov	esi, pValueTab	; point esi to valuetable
				mov		eax, [edi + 4*eax] ; eax = PERM(ix+1 + PERM(iy+0 + PERM(it+0)))
				  and	ecx, TABMASK	; still generating v[2]
				mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix+1 + PERM(iy+0 + PERM(it+1)))
				  and	edx, TABMASK	; still generating v[6]
				mov		eax, [esi + 4*eax] ; eax = v[1]
				  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix+1 + PERM(iy+1 + PERM(it+0)))
				mov		ebx, [esi + 4*ebx] ; ebx = v[5]
				  mov	edx, [edi + 4*edx] ; edx = PERM(ix+1 + PERM(iy+1 + PERM(it+1)))
				mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
				  mov	ecx, [esi + 4*ecx] ; ecx = v[2]
				mov		edx, [esi + 4*edx] ; edx = v[6]
				  mov	esi, ift		; prepare to multiply with esi
				imul	ebx, edi		; ebx = v[5] * ft
				  ; wait 10 cycles
				imul	eax, esi		; eax = v[1] * ift
				  ; wait another 10 cycles
				imul	edx, edi		; edx = v[6] * ft
				  ; wait yet another 10 cycles
				imul	ecx, esi		; ecx = v[2] * ift
				  ; wait even yet another 10 cycles
				add		eax, ebx		; eax = smoothstep(v[1], v[5], ft)
				  mov	ebx, fy			; ebx = fy....
				shr		eax, 16			; eax = vp[1]
				  add	ecx, edx		; ecx = smoothstep(v[2], v[6], ft)
				shr		ecx, 16			; ecx = vp[2]
				  mov	edx, ify		; edx = ify
				imul	eax, edx		; eax = vp[1] * ify
				  ; wait more cycles
				imul	ecx, ebx		; ecx = vp[2] * fy
				  ; another 10 cycle hit
				add		eax, ecx		; eax = smoothstep(vp[1], vp[2], fy)
				  ;
				shr		eax, 16			; eax = vpp[1]
				  ;
				mov		vpp1, eax
			x_loop_nocalc:			
				mov		edx, x			; get the prescaled x
				  mov	ebx, x_inc		; get scaled x increment
				add		ebx, edx		; ebx = x + x_inc -> new scaled x
				  lea	esi, gdwSmoothTable
				and		edx, 0xffff		; edx = fx
				  mov	x, ebx			; save off new x
				shr		edx, 8			; get upper 8 bits of fx
				  mov	ecx, vpp0		; get vpp[0]
				mov		ebx, 0xffff		; prepare to calc ifx
				  mov	edi, pScan		; prepare to write out to scan array
				mov		edx, [esi + 4*edx]	; edx = smooth fx
				  sub	ebx, edx		; ebx = ifx
				imul	edx, eax		; edx = vpp[1] * fx
				  ; imul, besides being 10 cycles, is also not pairable
				imul	ecx, ebx		; ecx = vpp[0] * ifx
				  ; sigh
				add		edx, ecx		; edx = smoothstep(vpp[0], vpp[1], fx)
				  mov	eax, x_loop		; prepare to write out to scan array
				shr		edx, 1			; prepare to normalize around 0
				  mov	ecx, h_loop		; prepare to scale noisevalue as a function of harmonics
				sub		edx, 0x3fffffff	; normalize about 0
				  mov	ebx, [edi+4*eax]; get scan array value
				sar		edx, cl			; "divide" by harmonics value
				  ;	shift by cl doesn't pair
				add		edx, ebx		; edx = new scan array value
				  mov	ebx, right		; get right edge
				mov		[edi+4*eax], edx	; save off new scan array value
				  cmp	eax, ebx		; check if at right edge of scan line
				jge		x_loop_done		; if so, goto done code
				  mov	edx, x			; get already-incremented x value
				mov		ebx, lastix		; get last ix value
				  inc	eax				; x_loop++
				shr		edx, 16			; get new ix value
				  mov	x_loop, eax		; save off x_loop
				mov		eax, vpp1		; get back vpp[1]
				  cmp	edx, ebx		; is lastix == ix?
				je		x_loop_nocalc	; if so, we only need to recalc a few things
				  mov	vpp0, eax		; save off this vpp[1] to be the next vpp[0]
				jmp		x_loop_calc		; go make more noise
			x_loop_done:
			} // end asm block (and x loop)
			t = t >> 1;
			y = y >> 1;		
			x_base = x_base >> 1;
			x_inc = x_inc >> 1;
		} // end harmonics loop

		
		
		if (pSrc) {
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;

			__asm {
				mov		eax, left			
				  mov	edi, pScan
				mov		esi, pSrcLine
				  mov	ecx, noisescale
			noise_loop:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		bl, [esi + eax]		; ebx = src pixel index 
				  mov	esi, pPalette		; get pointer to palette table
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				  ;
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				  mov	edi, pDestLine		; get pointer to dest buffer
				and		ebx, 0xff			; finish clamping to (0, 255)
				  mov	ecx, right			; prepare to see if we're done
				mov		ebx, [esi + 4*ebx]	; ebx = noisy RGBA
				  ;
				or		ebx, alphamask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				mov		esi, pSrcLine		; still getting them back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jle		noise_loop
			}
		} else {
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			__asm {
				mov		eax, left			
				  mov	edi, pScan
				  mov	ecx, noisescale
			noise_loop_nosrc:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		ebx, 80				; ebx = src pixel index 
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				and		ebx, 0xff			; finish clamping to (0, 255)
				mov		esi, ebx			; save off value
				  ;
				shl		ebx, 8
				  or	ebx, esi
				shl		ebx, 8
				  or	ebx, esi
				
				mov		edi, pDestLine		; get pointer to dest buffer
				  mov	ecx, right			; prepare to see if we're done
				or		ebx, alphamask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jle		noise_loop_nosrc
			} 
		}

	} // end y loop
#ifdef MEASURE_TIME
	}
	wsprintf(buf, "%d ms\n", timeGetTime() - time);
	OutputDebugString(buf);
#endif
}



void CDXTAdditive::addsmoothturb8to32mask(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
    int value = 0;
	DWORD noise = 0;

	int x, y, y_loop, x_loop, h_loop;
	unsigned char *pSrcLine;
	DWORD *pDestLine;
	DWORD *pMaskLine;
	int timexanimatex, timexanimatey;
	DWORD ft, ift, t;
	DWORD iy, it;
	DWORD fy, ify;
	DWORD ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	DWORD left, right;
	DWORD scalex, noiseoffset, *pValueTab, noisescale, normalize, *pScan;
	DWORD allone = 0xff;
	DWORD x_base, x_inc, x_base_save, x_inc_save;
	DWORD lastix;
	DWORD vpp0, vpp1;
	DWORD *pPalette;
	DWORD chromakey;
	DWORD alphamask;

#ifdef MEASURE_TIME
	DWORD time, timeloop;
	char buf[80];

	time = timeGetTime();

	for (timeloop=0;timeloop<100;timeloop++) {
#endif
	if (m_alphaActive == 1) 
		alphamask = 0x80000000;
	else 
		alphamask = 0xff000000;

	nDestPitch = nDestPitch >> 2;
	nMaskPitch = nMaskPitch >> 2;

	nTime = nTime & 0x0ffff;		// keep things as expected...

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	// copy some member variables into locals, since the inline assembler
	// can't access them... unless it would be through the this pointer, maybe
	scalex = m_nScaleX;
	noiseoffset = m_nNoiseOffset;
	pValueTab = m_valueTab;
	pScan = m_pdwScanArray;
	normalize = 1 << (31 - m_nNoiseScale);
	noisescale = m_nNoiseScale;
	pPalette = 	(DWORD *) m_pPalette;
	chromakey = m_ColorKey;


	x_base_save = (((m_rActiveRect.left+timexanimatex) & 0xffff) << 16) >> m_nScaleX;
	left = m_rActiveRect.left;
	right = m_rActiveRect.right - 1;

	// setup the x_base -> prescaled x value at the left of every scan line

	// the scaled x value (starting at x_base) gets incremented this much 
	// at each texel
	x_inc_save = (1 << 16) >> m_nScaleX;

	// Time doesn't change at all in this function, so pre-cal all of it

	for (y_loop=m_rActiveRect.top; y_loop<m_rActiveRect.bottom;y_loop++) {
		// Setup the time vars
		t = (nTime) << 16;
		t = t >> m_nScaleTime;


		y = y_loop + timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;

		
		x_base = x_base_save;
		x_inc = x_inc_save;

		for (h_loop = m_nHarmonics - 1; h_loop >= 0; h_loop--) {
			x_loop = m_rActiveRect.left;
			x = x_base;

			iy = y >> 16;
			it = t >> 16;

			ft = gdwSmoothTable[(t & 0xffff) >> 8];
			ift = 0xffff - ft;

			fy = gdwSmoothTable[(y & 0xffff) >> 8];
			ify = 0xffff - fy;

			ytPerm00 = PERM(iy+0 + PERM(it+0));
			ytPerm01 = PERM(iy+0 + PERM(it+1));
			ytPerm10 = PERM(iy+1 + PERM(it+0));
			ytPerm11 = PERM(iy+1 + PERM(it+1));
			__asm {
				; first, calc v[0], v[4], v[3] and v[7]
				lea		edx, gPerm
				  mov	eax, x
				mov		edi, edx
				  mov	ebx, ytPerm01	; for v[4]
				shr		eax, 16
				  mov	ecx, ytPerm10	; for v[3]
				mov		esi, eax		; esi = ix
				  mov	eax, ytPerm00	; for v[0]
				add		eax, esi		; eax = ix + ytPerm00, for v[0]
				  add	ebx, esi		; ebx = ix + ytPerm01, for v[4]
				and		eax, TABMASK	; still generating v[0]
				  and	ebx, TABMASK	; still generating v[4]
				mov		edx, ytPerm11	; for v[7]
				  add	ecx, esi		; ecx = ix + ytPerm10, for v[3]
				add		edx, esi		; edx = ix + ytPerm11, for v[7]
				  mov	esi, pValueTab	; point esi to valuetable
				mov		eax, [edi + 4*eax] ; eax = PERM(ix + PERM(iy+0 + PERM(it+0)))
				  and	ecx, TABMASK	; still generating v[3]
				mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix + PERM(iy+0 + PERM(it+1)))
				  and	edx, TABMASK	; still generating v[7]
				mov		eax, [esi + 4*eax] ; eax = v[0]
				  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix + PERM(iy+1 + PERM(it+0)))
				mov		ebx, [esi + 4*ebx] ; ebx = v[4]
				  mov	edx, [edi + 4*edx] ; edx = PERM(ix + PERM(iy+1 + PERM(it+1)))
				mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
				  mov	ecx, [esi + 4*ecx] ; ecx = v[3]
				mov		edx, [esi + 4*edx] ; edx = v[7]
				  mov	esi, ift		; prepare to multiply with esi
				imul	ebx, edi		; ebx = v[4] * ft
				  ; wait 10 cycles
				imul	eax, esi		; eax = v[0] * ift
				  ; wait another 10 cycles
				imul	edx, edi		; edx = v[7] * ft
				  ; wait yet another 10 cycles
				imul	ecx, esi		; ecx = v[3] * ift
				  ; wait even yet another 10 cycles
				add		eax, ebx		; eax = smoothstep(v[0], v[4], ft)
				  mov	ebx, fy			; ebx = fy....
				shr		eax, 16			; eax = vp[0]
				  add	ecx, edx		; ecx = smoothstep(v[3], v[7], ft)
				shr		ecx, 16			; ecx = vp[3]
				  mov	edx, ify		; edx = ify
				imul	eax, edx		; eax = vp[0] * ify
				  ; wait more cycles
				imul	ecx, ebx		; ecx = vp[3] * fy
				  ; another 10 cycle hit
				add		eax, ecx		; eax = smoothstep(vp[0], vp[3], fy)
				  ;
				shr		eax, 16			; eax = vpp[0]
				  ;
				mov		vpp0, eax		; save off vpp[0] for later
			x_loop_calc:
				; assumptions:
				lea		edx, gPerm
				  mov	eax, x
				mov		edi, edx
				  mov	ebx, ytPerm01	; for v[5]
				shr		eax, 16
				  mov	ecx, ytPerm10	; for v[2]
				mov		lastix, eax		; save off this ix value to look at next time
				  inc	eax
				mov		esi, eax		; esi = ix + 1
				  mov	eax, ytPerm00	; for v[1]
				add		eax, esi		; eax = ix + ytPerm00, for v[1]
				  add	ebx, esi		; ebx = ix + ytPerm01, for v[5]
				and		eax, TABMASK	; still generating v[1]
				  and	ebx, TABMASK	; still generating v[5]
				mov		edx, ytPerm11	; for v[6]
				  add	ecx, esi		; ecx = ix + ytPerm10, for v[2]
				add		edx, esi		; edx = ix + ytPerm11, for v[6]
				  mov	esi, pValueTab	; point esi to valuetable
				mov		eax, [edi + 4*eax] ; eax = PERM(ix+1 + PERM(iy+0 + PERM(it+0)))
				  and	ecx, TABMASK	; still generating v[2]
				mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix+1 + PERM(iy+0 + PERM(it+1)))
				  and	edx, TABMASK	; still generating v[6]
				mov		eax, [esi + 4*eax] ; eax = v[1]
				  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix+1 + PERM(iy+1 + PERM(it+0)))
				mov		ebx, [esi + 4*ebx] ; ebx = v[5]
				  mov	edx, [edi + 4*edx] ; edx = PERM(ix+1 + PERM(iy+1 + PERM(it+1)))
				mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
				  mov	ecx, [esi + 4*ecx] ; ecx = v[2]
				mov		edx, [esi + 4*edx] ; edx = v[6]
				  mov	esi, ift		; prepare to multiply with esi
				imul	ebx, edi		; ebx = v[5] * ft
				  ; wait 10 cycles
				imul	eax, esi		; eax = v[1] * ift
				  ; wait another 10 cycles
				imul	edx, edi		; edx = v[6] * ft
				  ; wait yet another 10 cycles
				imul	ecx, esi		; ecx = v[2] * ift
				  ; wait even yet another 10 cycles
				add		eax, ebx		; eax = smoothstep(v[1], v[5], ft)
				  mov	ebx, fy			; ebx = fy....
				shr		eax, 16			; eax = vp[1]
				  add	ecx, edx		; ecx = smoothstep(v[2], v[6], ft)
				shr		ecx, 16			; ecx = vp[2]
				  mov	edx, ify		; edx = ify
				imul	eax, edx		; eax = vp[1] * ify
				  ; wait more cycles
				imul	ecx, ebx		; ecx = vp[2] * fy
				  ; another 10 cycle hit
				add		eax, ecx		; eax = smoothstep(vp[1], vp[2], fy)
				  ;
				shr		eax, 16			; eax = vpp[1]
				  ;
				mov		vpp1, eax
			x_loop_nocalc:			
				mov		edx, x			; get the prescaled x
				  mov	ebx, x_inc		; get scaled x increment
				add		ebx, edx		; ebx = x + x_inc -> new scaled x
				  lea	esi, gdwSmoothTable
				and		edx, 0xffff		; edx = fx
				  mov	x, ebx			; save off new x
				shr		edx, 8			; get upper 8 bits of fx
				  mov	ecx, vpp0		; get vpp[0]
				mov		ebx, 0xffff		; prepare to calc ifx
				  mov	edi, pScan		; prepare to write out to scan array
				mov		edx, [esi + 4*edx]	; edx = smooth fx
				  sub	ebx, edx		; ebx = ifx
				imul	edx, eax		; edx = vpp[1] * fx
				  ; imul, besides being 10 cycles, is also not pairable
				imul	ecx, ebx		; ecx = vpp[0] * ifx
				  ; sigh
				add		edx, ecx		; edx = smoothstep(vpp[0], vpp[1], fx)
				  mov	eax, x_loop		; prepare to write out to scan array
				shr		edx, 1			; prepare to normalize around 0
				  mov	ecx, h_loop		; prepare to scale noisevalue as a function of harmonics
				sub		edx, 0x3fffffff	; normalize about 0
				  mov	ebx, [edi+4*eax]; get scan array value
				sar		edx, cl			; "divide" by harmonics value
				  ;	shift by cl doesn't pair
				add		edx, ebx		; edx = new scan array value
				  mov	ebx, right		; get right edge
				mov		[edi+4*eax], edx	; save off new scan array value
				  cmp	eax, ebx		; check if at right edge of scan line
				jge		x_loop_done		; if so, goto done code
				  mov	edx, x			; get already-incremented x value
				mov		ebx, lastix		; get last ix value
				  inc	eax				; x_loop++
				shr		edx, 16			; get new ix value
				  mov	x_loop, eax		; save off x_loop
				mov		eax, vpp1		; get back vpp[1]
				  cmp	edx, ebx		; is lastix == ix?
				je		x_loop_nocalc	; if so, we only need to recalc a few things
				  mov	vpp0, eax		; save off this vpp[1] to be the next vpp[0]
				jmp		x_loop_calc		; go make more noise
			x_loop_done:
			} // end asm block (and x loop)
			t = t >> 1;
			y = y >> 1;		
			x_base = x_base >> 1;
			x_inc = x_inc >> 1;
		} // end harmonics loop

		
		
		if (pSrc) {
			// the following loop screams to be optimized. 
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;
			pMaskLine = ((DWORD *)pMask) + nMaskPitch*y_loop;

			__asm {
				mov		eax, left			
				  mov	edi, pScan
				mov		esi, pSrcLine
				  mov	ecx, noisescale
			noise_loop:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		bl, [esi + eax]		; ebx = src pixel index 
				  mov	esi, pPalette		; get pointer to palette table
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				  mov	edi, pMaskLine		; get pointer to this scanline of mask pixels
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				  mov	edx, [edi + 4*eax - 4] ; get value from mask buffer 
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				  mov	edi, edx			; save mask value with alpha info
				and		ebx, 0xff			; finish clamping to (0, 255)
				  and	edx, 0x00ffffff		; use just lower 24 bits
				mov		ecx, chromakey		; get chromakey value
				  or	edi, 0xff000000
				mov		ebx, [esi + 4*ebx]	; ebx = noisy RGBA
				  xor	esi, esi			; zero out esi
				or		ebx, alphamask
				  cmp	ecx, edx			; generate mask for chromakeying
				adc		esi, 0				; if key != mask, esi might be 1
				  cmp	edx, ecx			; still generating mask
				adc		esi, 0				; if key != mask, esi is now 1
				  mov	ecx, right			; prepare to see if we're done
				dec		esi					; if key == mask, esi = 0xffffffff, else 0
				  mov	edx, edi			; get back mask with alpha
				and		ebx, esi			; if key == mask, ebx = noisy RGBA else 0
				  not	esi					; uhhhhhh...
				and		edx, esi			; if key != mask, edx = mask else 0
				  mov	edi, pDestLine		; get pointer to dest buffer
				or		ebx, edx			; ebx = noisy RGBA or mask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				mov		esi, pSrcLine		; still getting them back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jle		noise_loop
			}
		} else {
			// the following loop screams to be optimized. 
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			pMaskLine = ((DWORD *)pMask) + nMaskPitch*y_loop;

			__asm {
				mov		eax, left			
				  mov	edi, pScan
				  mov	ecx, noisescale
			noise_loop_nosrc:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		ebx, 80				; ebx = src pixel index 
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				  mov	edi, pMaskLine		; get pointer to this scanline of mask pixels
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				  mov	edx, [edi + 4*eax - 4] ; get value from mask buffer 
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				  mov	edi, edx			; save mask value with alpha info
				and		ebx, 0xff			; finish clamping to (0, 255)
				  and	edx, 0x00ffffff		; use just lower 24 bits
				mov		ecx, chromakey		; get chromakey value
				  or	edi, 0xff000000
				mov		esi, ebx			; save off value
				  ;
				shl		ebx, 8
				  or	ebx, esi
				shl		ebx, 8
				  or	ebx, esi
				
				  xor	esi, esi			; zero out esi
				or		ebx, alphamask
				  cmp	ecx, edx			; generate mask for chromakeying
				adc		esi, 0				; if key != mask, esi might be 1
				  cmp	edx, ecx			; still generating mask
				adc		esi, 0				; if key != mask, esi is now 1
				  mov	ecx, right			; prepare to see if we're done
				dec		esi					; if key == mask, esi = 0xffffffff, else 0
				  mov	edx, edi			; get back mask with alpha
				and		ebx, esi			; if key == mask, ebx = noisy RGBA else 0
				  not	esi					; uhhhhhh...
				and		edx, esi			; if key != mask, edx = mask else 0
				  mov	edi, pDestLine		; get pointer to dest buffer
				or		ebx, edx			; ebx = noisy RGBA or mask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				mov		esi, pSrcLine		; still getting them back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jle		noise_loop_nosrc
			}
		}
	} // end y loop
#ifdef MEASURE_TIME
	}
	wsprintf(buf, "%d ms\n", timeGetTime() - time);
	OutputDebugString(buf);
#endif
}

void 
CDXTAdditive::addsmoothturb8to32mmx(int nTime, void *pDest, int nDestPitch, 
                                    void *pSrc, int nSrcPitch, void *pMask, 
                                    int nMaskPitch) 
{
    DWORD   x, y, t;
    DWORD   ft, ift, fy, ify, fx, ifx;
    DWORD   iy, it, ytPerm00, ytPerm01, ytPerm10, ytPerm11;
    int     y_loop, h_loop, x_loop;
    DWORD   x_base, x_inc, lastix;
    int     right, left;
    DWORD * pScan;
    DWORD   timexanimatex, timexanimatey;
    DWORD * pValueTab;
    DWORD * pPalette = (DWORD *) m_pPalette;
    DWORD   noisescale, noiseoffset;
    unsigned char *pSrcLine;
    DWORD * pDestLine;
    DWORD   alphamask;

    if (m_alphaActive == 1) 
	    alphamask = 0x80000000;
    else 
	    alphamask = 0xff000000;

    nDestPitch /= 4;


    nTime = nTime & 0xffff;		// keep things as expected...

    timexanimatex = nTime * m_nTimeAnimateX;
    timexanimatey = nTime * m_nTimeAnimateY;

    left = m_rActiveRect.left;
    right = m_rActiveRect.right - 1;

    pValueTab = m_valueTab;
    pScan = m_pdwScanArray;

    noiseoffset = m_nNoiseOffset;
    noisescale = m_nNoiseScale - 2;

    for (y_loop = m_rActiveRect.top; y_loop < m_rActiveRect.bottom; y_loop++) 
    {
        t = (nTime) << 16;
        t = t >> m_nScaleTime;

        y = y_loop + timexanimatey;
        y = (y & 0xffff) << 16;
        y = y >> m_nScaleY;


        x_base = ((left+timexanimatex) & 0xffff) << 16;
        x_base = x_base >> m_nScaleX;

        x_inc = (1 << 16) >> m_nScaleX;

        for (h_loop = m_nHarmonics - 1; h_loop >= 0; h_loop--) 
        {
            x_loop = m_rActiveRect.left;
            x = x_base;

            iy = y >> 16;
            it = t >> 16;

            ft = gdwSmoothTable[(t & 0xffff) >> 8];
            ft = ft >> 1;			// cvt to signed
            ift = 0x7fff - ft;

            fy = gdwSmoothTable[(y & 0xffff) >> 8];
            fy = fy >> 1;			// cvt to signed
            ify = 0x7fff - fy;

            fx = gdwSmoothTable[(x & 0xffff) >> 8];
            fx = fx >> 1;			// cvt to signed
            ifx = 0x7fff - fx;

            ytPerm00 = PERM(iy+0 + PERM(it+0));
            ytPerm01 = PERM(iy+0 + PERM(it+1));
            ytPerm10 = PERM(iy+1 + PERM(it+0));
            ytPerm11 = PERM(iy+1 + PERM(it+1));

            __asm {
                lea     edi, gPerm                      ; load edi with pointer to perm table
                    mov     eax, ift                    ; preparing to load mm7 with ift:ft:ift:ft
                movd    mm7, eax                        ; mm7 = 0:ift
                                                        ; must pair with an mmx inst.
                mov     eax, ft                         ; preparing to load mm7 with ift:ft:ift:ft
                    mov     esi, x                      ; preparing to get ix
                shr     esi, 16                         ; esi = ix
                  mov	ebx, ytPerm01		; for v[4]
                movd	mm4, eax			; mm4 = 0:ft
                  psllq	mm7, 32				; mm7 = ift:0
                mov		eax, ytPerm00		; for v[0]
                  add	ebx, esi			; ebx = ix + ytPerm01, for v[4]
                mov		ecx, ytPerm10		; for v[3]
                  add	eax, esi			; eax = ix + ytPerm00, for v[0]
                mov		edx, ytPerm11		; for v[7]
                  and	eax, TABMASK		; clamp to (0,255), for v[0]
                and		ebx, TABMASK		; clamp to (0,255), for v[4]
                  add	ecx, esi			; ecx = ix + ytPerm10, for v[3]
                add		edx, esi			; edx = ix + ytPerm11, for v[7]
                  mov	esi, pValueTab		; load esi with pointer to random value table
                mov		eax, [edi+4*eax]	; get hash value from table
                  and	ecx, TABMASK		; clamp to (0, 255), for v[3]
                mov		ebx, [edi+4*ebx]	; get hash value from table
                  and	edx, TABMASK		; clamp to (0, 255), for v[7]
                mov		ecx, [edi+4*ecx]	; get hash value from table
                  mov	eax, [esi+4*eax]	; eax = v[0]
                movd	mm0, eax			; mm0 = 0:v[0]
                  por	mm7, mm4			; mm7 = ift:ft
                mov		ebx, [esi+4*ebx]	; ebx = v[4]
                  mov	edx, [edi+4*edx]	; get hash value from table
                mov		ecx, [esi+4*ecx]	; ecx = v[3]
                  packssdw	mm7, mm7		; mm7 = ift:ft:ift:ft
                mov		eax, ify			; preparing to load mm6 with 0:0:ify:fy
                  mov	edx, [esi+4*edx]	; edx = v[7]
                movd	mm4, ebx			; mm4 = 0:v[4]
                  psllq	mm0, 32				; mm0 = v[0]:0
                movd	mm3, ecx			; mm3 = 0:v[3]
                  por	mm0, mm4			; mm0 = v[0]:v[4]
                movd	mm4, edx			; mm4 = 0:v[7]
                  psllq	mm3, 32				; mm3 = v[3]:0
                movd	mm6, eax			; mm2 = 0:ify
                  por	mm3, mm4			; mm3 = v[3]:v[7]
                packssdw	mm3, mm0		; mm3 = v[0]:v[4]:v[3]:v[7]
                  mov	eax, fy				; preparing to load mm6 with 0:0:ify:fy
                movd	mm2, eax			; mm2 = 0:fy
                pmaddwd	mm3, mm7			; mm3 = lerp(v[0], v[4], ft):lerp(v[3], v[7], ft)
                  mov	ebx, x				; prepare to get ix again
                shr		ebx, 16				; ebx = ix
                  psllq	mm6, 16				; mm6 = 0:0:ify:0
                por	mm6, mm2			; mm6 = 0:0:ify:fy
                  mov	eax, ifx			; prepare to setup mm5 with 0:0:ifx:fx
                psrld	mm3, 15				; mm3 has 0:vp[0]:0:vp[3], signed
                packssdw	mm3, mm3		; mm3 = vp[0]:vp[3]:vp[0]:vp[3]
                  mov	ecx, h_loop			; prepare to setup mm4 with h_loop (for shifting)
                movd	mm5, eax			; mm5 = 0:ifx
                  pmaddwd	mm3, mm6		; mm3 = 0:lerp(vp[0], vp[3], fy)
                mov		edx, fx				; prepare to setup mm5 with 0:0:ifx:fx
                  inc	ecx					; ecx = h_loop + 1 (gets rid of a shift by one later)
                movd	mm2, edx			; mm2 = 0:fx
                  psllq	mm5, 16				; mm5 = 0:0:ifx:0
                movd	mm4, ecx			; mm4 = h_loop+1
                  por	mm5, mm2			; mm5 = 0:0:ifx:fx
                inc		ebx					; ebx = ix + 1
                  psrld	mm3, 15				; mm3 = 0:vpp[0]

                ; at this point, the following registers have interesting things contained within:
                ; 
                ; ebx		ix + 1
                ; esi		pValueTab
                ; edi		gPerm
                ; mm3		vpp[0]
                ; mm4		h_loop
                ; mm5		0:0:ifx:fx
                ; mm6		0:0:ify:fy
                ; mm7		ift:ft:ift:ft
                x_calc_loop:
                mov			eax, ytPerm00	; prepare to calc v[1]
                  mov		ecx, ytPerm01	; prepare to calc v[5]
                add			eax, ebx		; eax = ix + 1 + ytPerm00, for v[1]
                  mov		edx, ytPerm10	; prepare to calc v[2]
                add			ecx, ebx		; ecx = ix + 1 + ytPerm01, for v[5]
                  and		eax, TABMASK	; clamp to (0, 255)
                and			ecx, TABMASK	; clamp to (0, 255)
                  add		edx, ebx		; edx = ix + 1 + ytPerm10, for v[2]
                and			edx, TABMASK	; clamp to (0, 255)
                  mov		eax, [edi + 4*eax]	; get hash value from table
                mov			ecx, [edi + 4*ecx]	; get hash value from table
                  mov		edx, [edi + 4*edx]	; get hash value from table (might be a bank conflict)
                mov			eax, [esi + 4*eax]	; eax = v[1]
                  ; movd, below, is U pipe only
                movd		mm0, eax			; mm0 = 0:v[1]
                  ; must pair with mmx instruction
                mov			eax, ytPerm11		; prepare to calc v[6]
                  mov		ecx, [esi + 4*ecx]	; ecx = v[5]
                add			eax, ebx			; eax = ix + 1 + ytPerm11, for v[6]
                  mov		edx, [esi + 4*edx]	; edx = v[2]
                and			eax, TABMASK		; clamp to (0, 255)
                  mov		lastix, ebx			; save off last ix+1 value
                movd		mm1, ecx			; mm1 = 0:v[5]
                  psllq		mm0, 32				; mm0 = v[1]:0
                mov			eax, [edi + 4*eax]	; get hash value from table for v[6]
                  mov		ecx, x				; prepare to calc fx
                movd		mm2, edx			; mm2 = 0:v[2]
                  por		mm0, mm1			; mm0 = v[1]:v[5]
                mov			eax, [esi + 4*eax]	; eax = v[6]
                  and		ecx, 0xffff			; ecx = fx
                movd		mm1, eax			; mm1 = 0:v[6]
                  psllq		mm2, 32				; mm2 = v[2]:0
                shr			ecx, 8				; ecx = upper 8 bits of fx
                  por		mm1, mm2			; mm1 = v[2]:v[6]
                packssdw	mm1, mm0			; mm1 = v[1]:v[5]:v[2]:v[6]
                  lea		edi, gdwSmoothTable	; load edi with pointer to smoothing table
                pmaddwd		mm1, mm7			; mm1 = lerp(v[1], v[5], ft):lerp(v[2], v[6], ft)
                  mov		eax, 0xffff			; prepare eax to get smooth ifx
                mov			ecx, [edi + 4*ecx]	; load up ecx with smooth fx
                  mov		esi, pScan			; load up esi with pointer to scan array
                sub			eax, ecx			; eax = smoothed ifx
                  mov		edx, x_loop			; load up edx with current x_loop
                movd		mm5, eax			; mm5 = 0:ifx
                  psrld		mm1, 15				; mm1 = vp[1]:vp[2]
                movd		mm0, ecx			; mm0 = 0:fx
                  packssdw	mm1, mm1			; mm1 = vp[1]:vp[2]:vp[1]:vp[2]
                pmaddwd		mm1, mm6			; mm1 = 0:lerp(vp[1], vp[2], fy)
                  psllq		mm5, 16				; mm5 = 0:0:ifx:0
                por			mm5, mm0			; mm5 = 0:0:ifx:fx
                  lea		esi, [esi + 4*edx]	; load up esi with pointer to THIS VERY NOISE VALUE LOCATION!
                psrlw		mm5, 1				; mm5 = 0:0:ifx:fx, signed
                  ;
                psrld		mm1, 15				; mm1 = vpp[1]
                  psllq		mm3, 16				; mm3 = 0:0:vpp[0]:0
                por			mm3, mm1			; mm3 = 0:0:vpp[0]:vpp[1]
                ; at this point, the following registers have interesting things contained within:
                ;
                ; ebx		ix + 1
                ; edx		x_loop
                ; esi		pScan + 4*x_loop
                ; edi		gdwSmoothTable
                ; mm1		vpp[1]
                ; mm3		0:0:vpp[0]:vpp[1]
                ; mm4		h_loop
                ; mm5		0:0:ifx:fx
                ; mm6		0:0:ify:fy
                ; mm7		ift:ft:ift:ft
                x_nocalc_loop:
                pmaddwd		mm5, mm3			; mm5 = 0:lerp(vpp[0], vpp[1], fx)
                  mov		eax, [esi]			; eax = old noise value at this location
                mov			ecx, right			; load up the right edge
                  pcmpeqd	mm0, mm0			; load up mm0 with all ones
                psrlq		mm0, 35				; mm0 = 0:0x1fffffff
                  cmp		edx, ecx			; are we quite done yet?
                psubd		mm5, mm0			; mm5 = normalized about 0 noise
                  jge		x_loop_done			; if so, finish & bail
                inc			edx					; edx = x_loop++
                  psrad		mm5, mm4			; 'divide' by # of harmonics
                mov			x_loop, edx			; save off x_loop value
                  mov		ecx, x				; get last x value
                mov			edx, x_inc			; get x increment
                  ;
                add			ecx, edx			; generate new x
                  mov		ebx, ecx			; get copy of new x to calc new ix + 1
                mov			x, ecx				; save off new x
                shr			ebx, 16				; ebx = new ix
                mov		edx, 0xffff			; to calc new ifx, new fx
                and			ecx, edx			; ecx = new fx
                  shr		ecx, 8				; ecx = upper 8 bits new fx
                ; AGI
                mov			ecx, [edi + 4*ecx]	; ecx = smooth fx
                  inc		ebx					; ebx = new ix + 1
                sub			edx, ecx			; edx = new ifx
                  ;
                movd		mm0, edx			; mm0 = 0:0:0:ifx
                  ;
                movd		mm2, ecx			; mm2 = 0:0:0:fx
                  pslld		mm0, 16				; mm0 = 0:0:ifx:0
                movd		edx, mm5			; edx = new noise value to be added
                  por		mm0, mm2			; mm0 = 0:0:ifx:fx
                add			eax, edx			; eax = new noise value
                  movq		mm5, mm0			; mm5 = 0:0:ifx:fx
                mov			[esi], eax			; write out new noise value
                  add		esi, 4				; move pointer one DWORD
                mov			eax, lastix			; get lastix+1
                  mov		edx, x_loop			; get x_loop value back into edx
                cmp			eax, ebx			; does lastix+1 == new ix+1?
                psrlw		mm5, 1				; mm5 = 0:0:ifx:fx, signed
                  je		x_nocalc_loop		; if so, go do this again

                movq		mm1, mm3			; mm3 = new vpp[0] (old vpp[1])
                  mov		esi, pValueTab
                lea			edi, gPerm
                jmp			x_calc_loop
                x_loop_done:
                psrad		mm5, mm4			; 'divide' by # of harmonics
                  ; STALLOLA - should insert the c code below here.
                movd		edx, mm5			; edx = new noise value to be added
                  ;
                add			eax, edx			; eax = new noise value
                  ;
                mov			[esi], eax			; write out last noise value
                } // asm block (and x loop)

                t = t >> 1;
                y = y >> 1;		
                x_base = x_base >> 1;
                x_inc = x_inc >> 1;
            } // harmonics loop


		
		if (pSrc) {
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;

			__asm {
				mov		eax, left			
				  mov	edi, pScan
				mov		esi, pSrcLine
				  mov	ecx, noisescale
			noise_loop:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		bl, [esi + eax]		; ebx = src pixel index 
				  mov	esi, pPalette		; get pointer to palette table
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				  ;
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				  mov	edi, pDestLine		; get pointer to dest buffer
				and		ebx, 0xff			; finish clamping to (0, 255)
				  mov	ecx, right			; prepare to see if we're done
				mov		ebx, [esi + 4*ebx]	; ebx = noisy RGBA
				  ;
				or		ebx, alphamask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				mov		esi, pSrcLine		; still getting them back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jle		noise_loop
			}
		} else {
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			__asm {
				mov		eax, left			
				  mov	edi, pScan
				  mov	ecx, noisescale
			noise_loop_nosrc:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		ebx, 80				; ebx = src pixel index 
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				and		ebx, 0xff			; finish clamping to (0, 255)
				mov		esi, ebx			; save off value
				  ;
				shl		ebx, 8
				  or	ebx, esi
				shl		ebx, 8
				  or	ebx, esi
				
				mov		edi, pDestLine		; get pointer to dest buffer
				  or	ebx, alphamask
				mov		ecx, right			; prepare to see if we're done
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jle		noise_loop_nosrc
			} 
		}
	}

	__asm {
		emms
	}
}

void CDXTAdditive::addsmoothturb8to32mmxmask(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
	DWORD x, y, t;
	DWORD iy, it, ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	int y_loop, h_loop, x_loop;
	DWORD x_base, x_inc, chromakey;
	int right, left;
	DWORD *pScan;
	DWORD timexanimatex, timexanimatey, noiseoffset, noisescale;
	DWORD *pValueTab;
	DWORD *pPalette = (DWORD *) m_pPalette;

	unsigned char *pSrcLine;
	DWORD *pDestLine, *pMaskLine;
	DWORD alphamask;

	if (m_alphaActive == 1) 
		alphamask = 0x80000000;
	else 
		alphamask = 0xff000000;

	nDestPitch /= 4;
	nMaskPitch /= 4;
	nTime = nTime & 0xffff;		// keep things as expected...

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	left = m_rActiveRect.left;
	right = m_rActiveRect.right;

	noiseoffset = m_nNoiseOffset;
	noisescale = m_nNoiseScale - 1;
	pValueTab = m_valueTab;
	pScan = m_pdwScanArray;
	chromakey = m_ColorKey;

	for (y_loop = m_rActiveRect.top; y_loop < m_rActiveRect.bottom; y_loop++) {
		t = (nTime) << 16;
		t = t >> m_nScaleTime;

		y = y_loop + timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;

		
		x_base = ((left + timexanimatex)& 0xffff) << 16;
		x_base = x_base >> m_nScaleX;

		x_inc = (1 << 16) >> m_nScaleX;

		for (h_loop = m_nHarmonics - 1; h_loop >= 0; h_loop--) {
			x_loop = m_rActiveRect.left;
			x = x_base;

			iy = y >> 16;
			it = t >> 16;

			ytPerm00 = PERM(iy+0 + PERM(it+0));
			ytPerm01 = PERM(iy+0 + PERM(it+1));
			ytPerm10 = PERM(iy+1 + PERM(it+0));
			ytPerm11 = PERM(iy+1 + PERM(it+1));

			__asm {
				lea		ecx, gdwSmoothTable	; get the smoothstep table
				  mov	eax, t			; prepare to get ft
				mov		esi, ecx		; load table pointer into esi
				  and	eax, 0xffff		; eax = ft
				shr		eax, 8			; eax = upper 8 bits of ft
				  mov	edx, 0xffff		; prepare to get ift
				mov		ebx, y			; prepare to get fy
				  mov	ecx, 0xffff		; prepare to get ify
				mov		eax, [esi + 4*eax]	; eax = smoothstep ft
				  and	ebx, 0xffff		; ebx = fy
				sub		edx, eax		; edx = ift
				  shr	ebx, 8			; ebx = upper 8 bits of fy
				movd	mm7, edx		; mm7 = 0:0:0:ift
				  ; must pair with an mmx instruction
				movd	mm4, eax		; mm4 = 0:0:0:ft
				  psllq	mm7, 32			; mm7 = 0:ift:0:0
				mov		ebx, [esi + 4*ebx] ; ebx = smoothstep fy
				  por	mm7, mm4		; mm7 = 0:ift:0:ft
				sub		ecx, ebx		; ecx = ify
				  psrld	mm7, 1			; mm7 = 0:ift:0:ft, signed (but positive)
				movd	mm6, ecx		; mm6 = 0:0:0:ify
				  packssdw mm7, mm7		; mm7 = ift:ft:ift:ft
				movd	mm4, ebx		; mm4 = 0:0:0:fy
				  psllq	mm6, 32			; mm6 = 0:ify:0:0
				mov		ebx, x			; prepare to get ix
				  por	mm6, mm4		; mm6 = 0:ify:0:fy
				shr		ebx, 16			; ebx = ix
				  psrld mm6, 1			; mm6 = 0:ify:0:fy, signed (but positive)
				packssdw mm6, mm6		; mm6 = ify:fy:ify:fy
				  
			 	x_loop_start:
					; assumed:
					; 		ebx = ix 
					;		mm6 = fy:ify:fy:ify 
					;		mm7 = ft:ift:ft:ift
					lea		eax, gPerm
					  mov	edx, pValueTab
					mov		esi, eax
					  mov	edi, edx
					mov		eax, ytPerm00
					  mov	ecx, ytPerm01
					add		eax, ebx		; eax = ix + ytPerm00, for v[0]
					  add	ecx, ebx		; ecx = ix + ytPerm01, for v[4]
					mov		edx, eax		; edx = ix + ytPerm00, for v[1]
					  and	eax, TABMASK	; still generating v[0]
					inc		edx				; edx = ix + 1 + ytPerm00, for v[1]
					  and	ecx, TABMASK	; still generating v[4]
					and		edx, TABMASK	; still generating v[1]
					  mov	eax, [esi+4*eax] ; eax = PERM(ix + PERM(iy + PERM(it)))
					mov		ecx, [esi+4*ecx] ; ecx = PERM(ix + PERM(iy + PERM(it+1)))
					  ; AGI on edx
					mov		edx, [esi+4*edx] ; edx = PERM(ix+1 + PERM(iy + PERM(it)))
					  mov	eax, [edi+4*eax] ; eax = v[0]
					mov		ecx, [edi+4*ecx] ; ecx = v[4]
					  ; movd, below, must be in the u pipe
					movd	mm0, eax		; mm0 = 0:0:0:v[0]
					  ; must pair with an mmx instruction
					movd	mm1, ecx		; mm1 = 0:0:0:v[4]
					  psllq	mm0, 48			; mm0 = v[0]:0:0:0
					mov		edx, [edi+4*edx] ; edx = v[1]
					  mov	eax, ytPerm10	; for v[3]
					movd	mm4, edx		; mm4 = 0:0:0:v[1]
					  psllq	mm1, 32			; mm1 = 0:v[4]:0:0
					add		eax, ebx		; eax = ix + ytPerm10, for v[3]
					  mov	ecx, ytPerm11	; for v[7]
					mov		edx, eax		; edx = ix + ytPerm10, for v[2]
					  and	eax, TABMASK	; still generating v[3]
					add		ecx, ebx		; ecx = ix + ytPerm11, for v[7]
					and		ecx, TABMASK	; still generating v[7]
					  inc	edx				; edx = ix + 1 + ytPerm10, for v[2]
					and		edx, TABMASK	; still generating v[2]
					por		mm0, mm1		; mm0 = v[0]:v[4]:0:0
					  mov	eax, [esi+4*eax] ; eax = PERM(ix + PERM(iy+1 + PERM(it))), for v[3]
					mov		ecx, [esi+4*ecx] ; ecx = PERM(ix + PERM(iy+1 + PERM(it+1))), for v[7]
					  mov	edx, [esi+4*edx] ; edx = PERM(ix+1 + PERM(iy+1 + PERM(it))), for v[2]
					mov		eax, [edi+4*eax] ; eax = v[3]
					  psllq mm4, 48			; mm4 = v[1]:0:0:0
					movd	mm1, eax		; mm1 = 0:0:0:v[3]
					  ; must pair with mmx instruction
					mov		ecx, [edi+4*ecx] ; ecx = v[7]
					  mov	edx, [edi+4*edx] ; edx = v[2]
					movd	mm2, ecx		; mm2 = 0:0:0:v[7]
					  psllq mm1, 16			; mm1 = 0:0:v[3]:0
					movd	mm3, edx		; mm3 = 0:0:0:v[2]
					  por	mm0, mm1		; mm0 = v[0]:v[4]:v[3]:0
					mov		eax, ytPerm01	; for v[5]
					  mov	ecx, ytPerm11	; for v[6]
					add		eax, ebx		; eax = ix + ytPerm01, for v[5]
					  inc	ebx				; ebx = ix + 1
					add		ecx, ebx		; ecx = ix + 1 + ytPerm11, for v[6]
					  inc	eax				; eax = ix + 1 + ytPerm01, for v[5]
					and		ecx, TABMASK	; still generating v[6]
					  and	eax, TABMASK	; still generating v[5]
					por		mm0, mm2		; mm0 = v[0]:v[4]:v[3]:v[7]
					  psllq	mm3, 16			; mm3 = 0:0:v[2]:0
					mov		ecx, [esi+4*ecx] ; ecx = PERM(ix+1 + PERM(iy+1 + PERM(it+1)))
					  mov	eax, [esi+4*eax] ; eax = PERM(ix+1 + PERM(iy + PERM(it+1)))
					pmaddwd mm0, mm7		; mm0 = smooth(v[0], v[4], ft):smooth(v[3], v[7], ft)
					  mov	edx, x			; get the current prescaled x
					mov		eax, [edi+4*eax] ; eax = v[5]
					  mov	ecx, [edi+4*ecx] ; ecx = v[6]
					movd	mm1, eax		; mm1 = 0:0:0:v[5]
					  por	mm4, mm3		; mm4 = v[1]:0:v[2]:0
					movd	mm2, ecx		; mm2 = 0:0:0:v[6]
					  psllq	mm1, 32			; mm1 = 0:v[5]:0:0
					psrld	mm0, 15			; mm0 has 0:vp[0]:0:vp[3], signed
					  por	mm4, mm1		; mm4 = v[1]:v[5]:v[2]:0
					por		mm4, mm2		; mm4 = v[1]:v[5]:v[2]:v[6]
					  mov	ebx, edx		; ebx = x
					pmaddwd	mm4, mm7		; mm4 = smooth(v[1], v[5], ft):smooth(v[2], v[6], ft)
					  lea	esi, gdwSmoothTable
					mov		eax, 0xffff		; prepare eax to get ifx
					  and	edx, 0xffff		; edx = fx
					shr		edx, 8			; edx = upper 8 bits fx
					  mov	ecx, x_inc		; prepare to calculate new x
					add		ebx, ecx		; ebx = new x, prescaled
					  ; AGI
					mov		edx, [esi + 4*edx] ; edx = smoothstep fx
					  ; register dependency
					sub	eax, edx			; eax = ifx
					  ; movd must be in U pipe
					movd	mm5, edx		; mm5 = 0:0:0:fx
					  psrld	mm4, 15			; mm4 = 0:vp[1]:0:vp[2]
					movd	mm3, eax		; mm3 = 0:0:0:ifx
					  packssdw mm4, mm0		; mm0 = vp[0]:vp[3]:vp[1]:vp[2]
					pmaddwd	mm4, mm6		; mm4 = smooth(vp[0], vp[3], fy):smooth(vp[1],vp[2], fy)
					  psllq	mm3, 16			; mm3 = 0:0:ifx:0
					por		mm5, mm3		; mm5 = 0:0:ifx:fx
					  mov	eax, pScan		; get the base address of the scanline noise array
					psrlw	mm5, 1			; mm5 = 0:0:ifx:fx, signed 
					psrld	mm4, 15			; mm4 = 0:vpp[0]:0:vpp[1]
					  mov	edx, x_loop		; get the scan-line index
					packssdw mm4, mm4		; mm4 = vpp[0]:vpp[1]:vpp[0]:vpp[1]
					  inc	edx				; x_loop++
					pmaddwd	mm4, mm5		; mm4 = 0:smooth(vpp[0], vpp[1], fx)
					  mov	ecx, right		; 
					lea		esi, [eax+4*edx-4]; esi -> scanarray
					  mov	x_loop, edx		; save off new x_loop
					sub		edx, ecx		; if edx == 0, we're done with the loop.. test later
					  mov	ecx, 0x1fffffff	; used to normalize the noise value
					movd	eax, mm4		; eax = new noisevalue
					  ; gotta pair with an mmx instruction
					sub		eax, ecx		; normalize eax around 0
					  mov	ecx, h_loop		; ecx = current harmonic (starting at 0)
					sar		eax, cl			; scale the noise as a function of the harmonic
					  ; shr is an icky instruction
					mov		ecx, [esi]
					  mov	x, ebx			; save off new x 
					add		eax, ecx		; eax = new noisevalue for this pixel
					  shr	ebx, 16			; ebx = new ix
					mov		[esi], eax		; save off new noisevalue
					  test	edx, edx 
					jnz		x_loop_start	; if edx is not zero, x_loop
			} // asm block (and x loop)

			t = t >> 1;
			y = y >> 1;		
			x_base = x_base >> 1;
			x_inc = x_inc >> 1;

		} // harmonics loop


		if (pSrc) {
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;
			pMaskLine = ((DWORD *)pMask) + nMaskPitch*y_loop;

			__asm {
				mov		eax, left			
				  mov	edi, pScan
				mov		esi, pSrcLine
				  mov	ecx, noisescale
			noise_loop:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		bl, [esi + eax]		; ebx = src pixel index 
				  mov	esi, pPalette		; get pointer to palette table
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				  mov	edi, pMaskLine		; get pointer to this scanline of mask pixels
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				  mov	edx, [edi + 4*eax - 4] ; get value from mask buffer 
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				  mov	edi, edx			; save mask value with alpha info
				and		ebx, 0xff			; finish clamping to (0, 255)
				  and	edx, 0x00ffffff		; use just lower 24 bits
				mov		ecx, chromakey		; get chromakey value
				  or	edi, 0xff000000
				mov		ebx, [esi + 4*ebx]	; ebx = noisy RGBA
				  xor	esi, esi			; zero out esi
				or		ebx, alphamask
				  cmp	ecx, edx			; generate mask for chromakeying
				adc		esi, 0				; if key != mask, esi might be 1
				  cmp	edx, ecx			; still generating mask
				adc		esi, 0				; if key != mask, esi is now 1
				  mov	ecx, right			; prepare to see if we're done
				dec		esi					; if key == mask, esi = 0xffffffff, else 0
				  mov	edx, edi			; get back mask with alpha
				and		ebx, esi			; if key == mask, ebx = noisy RGBA else 0
				  not	esi					; uhhhhhh...
				and		edx, esi			; if key != mask, edx = mask else 0
				  mov	edi, pDestLine		; get pointer to dest buffer
				or		ebx, edx			; ebx = noisy RGBA or mask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				mov		esi, pSrcLine		; still getting them back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jl		noise_loop
			}
		} else {
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			pMaskLine = ((DWORD *)pMask) + nMaskPitch*y_loop;

			__asm {
				mov		eax, left			
				  mov	edi, pScan
				  mov	ecx, noisescale
			noise_loop_nosrc:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		ebx, 80				; ebx = src pixel index 
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				  mov	edi, pMaskLine		; get pointer to this scanline of mask pixels
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				  mov	edx, [edi + 4*eax - 4] ; get value from mask buffer 
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				  mov	edi, edx			; save mask value with alpha info
				and		ebx, 0xff			; finish clamping to (0, 255)
				  and	edx, 0x00ffffff		; use just lower 24 bits
				mov		ecx, chromakey		; get chromakey value
				  or	edi, 0xff000000
				mov		esi, ebx			; save off value
				  ;
				shl		ebx, 8
				  or	ebx, esi
				shl		ebx, 8
				  or	ebx, esi
				
				  xor	esi, esi			; zero out esi
				or		ebx, alphamask
				  cmp	ecx, edx			; generate mask for chromakeying
				adc		esi, 0				; if key != mask, esi might be 1
				  cmp	edx, ecx			; still generating mask
				adc		esi, 0				; if key != mask, esi is now 1
				  mov	ecx, right			; prepare to see if we're done
				dec		esi					; if key == mask, esi = 0xffffffff, else 0
				  mov	edx, edi			; get back mask with alpha
				and		ebx, esi			; if key == mask, ebx = noisy RGBA else 0
				  not	esi					; uhhhhhh...
				and		edx, esi			; if key != mask, edx = mask else 0
				  mov	edi, pDestLine		; get pointer to dest buffer
				or		ebx, edx			; ebx = noisy RGBA or mask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				mov		esi, pSrcLine		; still getting them back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jl		noise_loop_nosrc
			}
		}
	}

	__asm {
		emms
	}
}


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_Harmonics, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_Harmonics(int * pnHarmonics)
{ 
    DXAUTO_OBJ_LOCK;

    if (pnHarmonics != NULL) 
    {
        *pnHarmonics = m_nHarmonics;

        return S_OK;
    }

    return E_INVALIDARG;
}
//  Method:  CDXTAdditive::get_Harmonics, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_Harmonics, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_Harmonics(int nHarmonics)
{ 
    DXAUTO_OBJ_LOCK;

    if (nHarmonics < 1) 
    {
        return E_INVALIDARG;
    }

    if ((nHarmonics != 1)
        && (m_dwFunctionType != PROCTEX_LATTICETURBULENCE_SMOOTHSTEP)
        && (m_dwFunctionType != PROCTEX_LATTICETURBULENCE_LERP)) 
    {
        m_nHarmonics = 1;

        return E_INVALIDARG;
    }

    m_nHarmonics = nHarmonics;

    SetDirty();

    return S_OK;
}
//  Method:  CDXTAdditive::put_Harmonics, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_NoiseScale, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_NoiseScale(int * pnNoiseScale)
{ 
    DXAUTO_OBJ_LOCK;

    if (pnNoiseScale != NULL) 
    {
        *pnNoiseScale = (32 - m_nNoiseScale);

        return S_OK;
    } 

    return E_INVALIDARG;
}
//  Method:  CDXTAdditive::get_NoiseScale, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_NoiseScale, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_NoiseScale(int nNoiseScale)
{ 
    DXAUTO_OBJ_LOCK;

    if ((nNoiseScale > 32) || (nNoiseScale < 0)) 
    {
        return E_INVALIDARG;
    }

    m_nNoiseScale = (32 - nNoiseScale);

    SetDirty();

    return S_OK;
}
//  Method:  CDXTAdditive::put_NoiseScale, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_NoiseOffset, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_NoiseOffset(int * pnNoiseOffset)
{ 
    DXAUTO_OBJ_LOCK;

    if (pnNoiseOffset != NULL) 
    {
        *pnNoiseOffset = m_nNoiseOffset;

        return S_OK;
    }

    return E_INVALIDARG;
}
//  Method:  CDXTAdditive::get_NoiseOffset, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_NoiseOffset, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_NoiseOffset(int nNoiseOffset)
{ 
    DXAUTO_OBJ_LOCK;

    m_nNoiseOffset = nNoiseOffset;

    SetDirty();

    return S_OK;
}
//  Method:  CDXTAdditive::put_NoiseOffset, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_TimeX, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_TimeX(int * pnTimeX)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnTimeX)
    {
        return E_POINTER;
    }

    *pnTimeX = m_nTimeAnimateX;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_TimeX, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_TimeX, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_TimeX(int nTimeX)
{ 
    DXAUTO_OBJ_LOCK;

    m_nTimeAnimateX = nTimeX;

    SetDirty();

    return S_OK; 
}
//  Method:  CDXTAdditive::put_TimeX, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_TimeY, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_TimeY(int * pnTimeY)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnTimeY)
    {
        return E_POINTER;
    }

    *pnTimeY = m_nTimeAnimateY;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_TimeY, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_TimeY, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_TimeY(int nTimeY)
{ 
    DXAUTO_OBJ_LOCK;

    m_nTimeAnimateY = nTimeY;

    SetDirty();

    return S_OK; 
}
//  Method:  CDXTAdditive::put_TimeY, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_ScaleX, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_ScaleX(int * pnScaleX)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnScaleX)
    {
        return E_POINTER;
    }

    *pnScaleX = m_nScaleX;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_ScaleX, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_ScaleX, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_ScaleX(int nScaleX)
{ 
    DXAUTO_OBJ_LOCK;

    if (nScaleX < 0)
    {
        return E_INVALIDARG;
    }

    m_nScaleX = nScaleX;

    SetDirty();

    return S_OK; 
}
//  Method:  CDXTAdditive::put_ScaleX, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_ScaleY, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_ScaleY(int * pnScaleY)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnScaleY)
    {
        return E_POINTER;
    }

    *pnScaleY = m_nScaleY;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_ScaleY, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_ScaleY, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_ScaleY(int nScaleY)
{ 
    DXAUTO_OBJ_LOCK;

    if (nScaleY < 0)
    {
        return E_INVALIDARG;
    }

    m_nScaleY = nScaleY;

    SetDirty();

    return S_OK; 
}
//  Method:  CDXTAdditive::put_ScaleY, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_ScaleT, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_ScaleT(int * pnScaleT)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnScaleT)
    {
        return E_POINTER;
    }

    *pnScaleT = m_nScaleTime;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_ScaleT, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_ScaleT, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_ScaleT(int nScaleT)
{ 
    DXAUTO_OBJ_LOCK;

    if (nScaleT < 0)
    {
        return E_INVALIDARG;
    }

    m_nScaleTime = nScaleT;

    SetDirty();

    return S_OK; 
}
//  Method:  CDXTAdditive::put_ScaleT, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_Alpha, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_Alpha(int * pnAlpha)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnAlpha) 
    {
        return E_INVALIDARG;
    }

    *pnAlpha = m_alphaActive;

    return S_OK;
}
//  Method:  CDXTAdditive::get_Alpha, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_Alpha, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_Alpha(int nAlpha)
{ 
    DXAUTO_OBJ_LOCK;

    if ((nAlpha < 0) || (nAlpha > 1))
    {
        return E_INVALIDARG;
    }

    m_alphaActive = nAlpha;

    SetDirty();

    return S_OK;
}
//  Method:  CDXTAdditive::put_Alpha, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_ColorKey, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_ColorKey(int * pnColorKey)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnColorKey) 
    {
        return E_INVALIDARG;
    }

    *pnColorKey = m_ColorKey;

    return S_OK;
}
//  Method:  CDXTAdditive::get_ColorKey, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_ColorKey, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_ColorKey(int nColorKey)
{ 
    DXAUTO_OBJ_LOCK;

    m_ColorKey = nColorKey;

    SetDirty();

    return S_OK;
}
//  Method:  CDXTAdditive::put_ColorKey, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_MaskMode, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_MaskMode(int * pnMaskMode)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnMaskMode) 
    {
        return E_INVALIDARG;
    }

    *pnMaskMode = m_MaskMode;

    return S_OK;
}
//  Method:  CDXTAdditive::get_MaskMode, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_MaskMode, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_MaskMode(int nMaskMode)
{ 
    DXAUTO_OBJ_LOCK;

    if ((nMaskMode < 0) || (nMaskMode > 1))
    {
        return E_INVALIDARG;
    }

    m_MaskMode = nMaskMode;

    // TODO:  there used to be a specific copy function to do the masking,
    // this will need to be done some other way.

    // setCopyFunction();

    SetDirty();

    return S_OK;
}
//  Method:  CDXTAdditive::put_MaskMode, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_GenerateSeed, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_GenerateSeed(int * pnSeed)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnSeed)
    {
        return E_POINTER;
    }

    *pnSeed = m_GenerateSeed;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_GenerateSeed, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_GenerateSeed, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_GenerateSeed(int nSeed)
{ 
    DXAUTO_OBJ_LOCK;

    HRESULT hr      = S_OK;
    int     i       = 0;
    DWORD * pdwPal  = NULL;

    if ((nSeed < 0) || (nSeed > 3))
    {
        hr = E_INVALIDARG;

        goto done;
    }

    pdwPal = new DWORD[256];

    if (NULL == pdwPal)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    switch (nSeed)
    {
        case 0:

            // No auto effect.
            // TODO:  Will this cause a NULL pointer access?

            break;

        case 1:

            // Flame (black red yellow white blue.)

            m_nNoiseOffset  = -45;
            m_nNoiseScale   = 7;
            m_nHarmonics    = 3;
            m_nScaleX       = 1;
            m_nScaleY       = 1;
            m_nScaleTime    = 2;
            m_nTimeAnimateX = 0;
            m_nTimeAnimateY = 1;

            // Set palette.

            for(i = 0 ; i < 64 ; i++) 
            {
                pdwPal[i]       = (i*4) << 16;
                pdwPal[i+64]    = 0x00ff0000 | ((i*4) << 8);
                pdwPal[i+128]   = 0x00ffff00 | (i*4);
                pdwPal[i+192]   = 0x000000ff | ((255 - i*1) << 16) | ((255 - i*1) << 8);
            }

            break;

        case 2:

            // Water (blue white.)

            m_nNoiseOffset  = 0;
            m_nNoiseScale   = 11;
            m_nHarmonics    = 5;
            m_nScaleX       = 1;
            m_nScaleY       = 1;
            m_nScaleTime    = 1;
            m_nTimeAnimateX = 1;
            m_nTimeAnimateY = 1;

            // Set water palette.

            for(i =0 ; i < 64 ; i++) 
            {
                pdwPal[i]     = 0x000000ff | ((i*4) << 16) | ((i*4) << 8);
                pdwPal[i+64]  = 0x000000ff | (((63-i)*4) << 16) | (((63-i)*4) << 8);
                pdwPal[i+128] = 0x000000ff | ((i*4) << 16) | ((i*4) << 8);
                pdwPal[i+192] = 0x000000ff | (((63-i)*4) << 16) | (((63-i)*4) << 8);
            }

            break;

        case 3:

            // Clouds (blue white gray.)

            m_nNoiseOffset  = 0;
            m_nNoiseScale   = 0;
            m_nHarmonics    = 7;
            m_nScaleX       = 1;
            m_nScaleY       = 1;
            m_nScaleTime    = 2;
            m_nTimeAnimateX = 1;
            m_nTimeAnimateY = 0;

            // Set clouds palette.

            for(i = 0; i < 128 ; i++) 
            {
                pdwPal[i]     = 0x000000ff | ((i*2) << 16) | ((i*2) << 8);
                pdwPal[i+128] = ((255 - i) << 16) | ((255 - i) << 8) | (255 - i);
            }

        break;
    } // switch (nSeed)

    delete [] m_pInitialBuffer;
    delete [] m_pPalette;

    m_pInitialBuffer    = NULL;
    m_pPalette          = (void *)pdwPal;
    m_GenerateSeed      = nSeed;

    SetDirty();

done:

    if (FAILED(hr) && pdwPal)
    {
        delete [] pdwPal;
    }

    return hr; 
}
//  Method:  CDXTAdditive::put_GenerateSeed, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_BitmapSeed, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_BitmapSeed(BSTR * pbstrBitmapSeed)
{ 
    DXAUTO_OBJ_LOCK;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_BitmapSeed, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_BitmapSeed, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_BitmapSeed(BSTR bstrBitmapSeed)
{ 
    DXAUTO_OBJ_LOCK;

    HRESULT     hr              = S_OK;
    WCHAR       strURL[2048]    = L"";
    WCHAR *     pchBitmapSeed   = (WCHAR *)bstrBitmapSeed;
    DWORD       cchURL          = 2048;
    LONG        lFileSize       = 0;
    IUnknown *  pUnk            = GetControllingUnknown();
    BOOL        fAllow          = FALSE;

    CURLArchive urlArchive(pUnk);

    CComPtr<IServiceProvider>   spServiceProvider;
    CComPtr<ISecureUrlHost>     spSecureUrlHost;

    // If we're being hosted by a web page, allow relative URLs.

    if (m_bstrHostUrl)
    {
        HRESULT hrNonBlocking = ::UrlCombine(m_bstrHostUrl, bstrBitmapSeed, 
                                             strURL, &cchURL, URL_UNESCAPE );

        if (SUCCEEDED(hrNonBlocking))
        {
            pchBitmapSeed = strURL;
        }
    }

    hr = GetSite(__uuidof(IServiceProvider), (void **)&spServiceProvider);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spServiceProvider->QueryService(__uuidof(IElementBehaviorSite),
                                         __uuidof(ISecureUrlHost),
                                         (void **)&spSecureUrlHost);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spSecureUrlHost->ValidateSecureUrl(&fAllow, pchBitmapSeed, 0);

    if (FAILED(hr))
    {
        goto done;
    }
    else if (!fAllow)
    {
        hr = E_FAIL;
        goto done;
    }
      
    hr = urlArchive.Create(pchBitmapSeed);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = urlArchive.GetFileSize(lFileSize);

    if (FAILED(hr))
    {
        goto done;
    }

    BITMAPFILEHEADER bmfh;
    BITMAPINFOHEADER bmih;
    int i;
    RGBQUAD *pRGBQuad;
    DWORD dwColor;
    DWORD *pdwPalette;
    DWORD dwBytesRead;

    dwBytesRead = urlArchive.Read((unsigned char *)&bmfh, 
                                  sizeof(BITMAPFILEHEADER)); 

    if (dwBytesRead == sizeof(BITMAPFILEHEADER))
    {
        dwBytesRead = urlArchive.Read((unsigned char *)&bmih, 
                                      sizeof(BITMAPINFOHEADER)); 

        if (dwBytesRead == sizeof(BITMAPINFOHEADER))
        {
            BOOL bFlip = TRUE;

            if (bmih.biBitCount != 8) 
            {
                urlArchive.Close();
                hr = E_FAIL;

                goto done;
            }

            if (bmih.biCompression != BI_RGB) 
            {
                urlArchive.Close();
                hr = E_FAIL;

                goto done;
            } 


            if (bmih.biHeight < 0)
            {
                bFlip = FALSE;
                bmih.biHeight = -bmih.biHeight;
            }

            delete [] m_pPalette;

            m_pPalette = new unsigned char[sizeof(RGBQUAD) * 256];

            if (NULL == m_pPalette) 
            {
                urlArchive.Close();
                hr = E_OUTOFMEMORY;

                goto done;
            }

            dwBytesRead = urlArchive.Read((unsigned char *)m_pPalette, 
                                          sizeof(RGBQUAD) * 256 ); 

            if(dwBytesRead == sizeof(RGBQUAD) * 256)
            {
                pRGBQuad = (RGBQUAD *) m_pPalette;
                pdwPalette = (DWORD *) m_pPalette;

                for (i = 0 ; i < 256 ; i++) 
                {
                    dwColor = ((pRGBQuad->rgbRed) << 16) | ((pRGBQuad->rgbGreen) << 8) | (pRGBQuad->rgbBlue);
                    *pdwPalette = dwColor;
                    pdwPalette++;
                    pRGBQuad++;
                }
                
                // Allocate the source buffer for procedural texture mapping, 
                // and load the image data into it.

                delete [] m_pInitialBuffer;

                m_pInitialBuffer = new unsigned char[sizeof(unsigned char) * bmih.biHeight * bmih.biWidth];

                if (NULL == m_pInitialBuffer) 
                {
                    urlArchive.Close();
                    delete [] m_pPalette;
                    m_pPalette  = NULL;
                    hr          = E_OUTOFMEMORY;

                    goto done;
                }

                m_nSrcWidth     = bmih.biWidth;
                m_nSrcHeight    = bmih.biHeight;
                m_nSrcBPP       = 8;

                if ((bmih.biWidth % 4) != 0) 
                {
                    unsigned char aJunk[3];

                    dwBytesRead = 0;

                    for (i = 0 ; i < bmih.biHeight ; i++) 
                    {
                        dwBytesRead += urlArchive.Read(((unsigned char *)m_pInitialBuffer) + bmih.biWidth*i, 
                                                       sizeof(unsigned char) * bmih.biWidth); 
                        urlArchive.Read(aJunk, 4 - bmih.biWidth % 4);
                    }

                } 
                else 
                {
                    dwBytesRead = urlArchive.Read((unsigned char *)m_pInitialBuffer, 
                                                  sizeof(unsigned char) * bmih.biHeight * bmih.biWidth); 
                }

                if (dwBytesRead == sizeof(unsigned char) * bmih.biHeight * bmih.biWidth)
                {
                    if (bFlip)
                    {
                        unsigned char * temp1;
                        unsigned char * temp2;
                        unsigned char * save;

                        save = new unsigned char[m_nSrcWidth];

                        if (save) 
                        {
                            temp1 = m_pInitialBuffer + m_nSrcWidth*(m_nSrcHeight-1);
                            temp2 = m_pInitialBuffer;

                            for(int i = 0 ; i < (m_nSrcHeight) >> 1 ; i++)
                            {
                                memcpy(save, temp1, m_nSrcWidth);
                                memcpy(temp1, temp2, m_nSrcWidth);
                                memcpy(temp2, save, m_nSrcWidth);
                                temp1 -= m_nSrcWidth;
                                temp2 += m_nSrcWidth;
                            }
                        }

                        delete [] save;
                    }
                }
            }
        }
    } 

    urlArchive.Close();

    m_GenerateSeed = 0;

    SetDirty();

done:

    return hr; 
}
//  Method:  CDXTAdditive::put_BitmapSeed, IDispAdditive


#ifdef _DEBUG

void showme2(IDirectDrawSurface * surf, RECT * prc)
{
    HRESULT hr      = S_OK;
    HDC     srcDC;
    HDC     destDC  = GetDC(NULL);
    RECT    dr;
    RECT    sr;
    RECT    rcFrame;

    HBRUSH          hbrRed;
    HBRUSH          hbrGreen;
    LOGBRUSH        logbrush;
    DDSURFACEDESC   ddsd;

    hr = surf->GetDC(&srcDC);

    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;

    hr = surf->GetSurfaceDesc(&ddsd);

    SetRect(&sr, 0, 0, ddsd.dwWidth, ddsd.dwHeight);
    SetRect(&dr, 1, 1, ddsd.dwWidth + 1, ddsd.dwHeight + 1);
    SetRect(&rcFrame, 0, 0, ddsd.dwWidth + 2, ddsd.dwHeight + 2);
    
    StretchBlt(destDC,
               dr.left,
               dr.top,
               dr.right - dr.left,
               dr.bottom - dr.top,
               srcDC,
               sr.left,
               sr.top,
               sr.right - sr.left,
               sr.bottom - sr.top,
               SRCCOPY);

    logbrush.lbStyle    = BS_SOLID;
    logbrush.lbColor    = 0x000000FF;   // Red

    hbrRed = CreateBrushIndirect(&logbrush);

    logbrush.lbColor    = 0x0000FF00;   // Green

    hbrGreen = CreateBrushIndirect(&logbrush);

    FrameRect(destDC, &rcFrame, hbrRed);

    if (prc != NULL)
    {
        RECT    rcBounds = *prc;

        rcBounds.right += 2;
        rcBounds.bottom += 2;

        FrameRect(destDC, &rcBounds, hbrGreen);
    }

    hr = surf->ReleaseDC(srcDC);
    
    DeleteObject(hbrRed);
    DeleteObject(hbrGreen);
    ReleaseDC(NULL, destDC);    
}


void * showme(IUnknown * pUnk)
{
    HRESULT hr = S_OK;
    //RECT    rc;

    CComPtr<IDirectDrawSurface> spDDSurf;
    CComPtr<IDXSurface>         spDXSurf;

    if (NULL == pUnk)
    {
        goto done;
    }

    hr = pUnk->QueryInterface(IID_IDirectDrawSurface, (void **)&spDDSurf);

    if (FAILED(hr))
    {
        hr = pUnk->QueryInterface(IID_IDXSurface, (void **)&spDXSurf);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDXSurf->GetDirectDrawSurface(IID_IDirectDrawSurface,
                                            (void **)&spDDSurf);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    /*
    if (pbnds)
    {
        pbnds->GetXYRect(rc);
    }
    */

    showme2(spDDSurf, NULL);

done:

    return pUnk;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\src\urlarchv.cpp ===
#include "stdafx.h"
#include <windows.h>
#include <stdlib.h>
#include <minmax.h>

#include "urlarchv.h"

#define MAX_URL  2060

#ifndef ARRAYDIM
  #define ARRAYDIM(a)   (sizeof(a) / sizeof(a[0]))
#endif // ARRAYDIM

#ifndef LOOPFOREVER
  #define LOOPFOREVER  for(;;)
#endif // LOOPFOREVER


// --------------------------------


EXPORT CURLArchive::CURLArchive( IUnknown * pUnk ) :
    m_pStream(NULL), m_pUnk(pUnk)
{
    if (m_pUnk)
    	m_pUnk->AddRef();
}


    // These are private methods; 
    // no one, even CURLArchive, should be calling them
CURLArchive::CURLArchive( const CURLArchive & )
{ NULL; }


CURLArchive & CURLArchive::operator=( const CURLArchive & )
{ return *this; }


EXPORT CURLArchive::~CURLArchive()
{
    Close( );
    if( m_pUnk )
        m_pUnk->Release();
}


EXPORT HRESULT CURLArchive::Close( )
{    
    if( m_pStream )
    {
        m_pStream->Release( );
        m_pStream = NULL;
    }
    return S_OK;
}


        
EXPORT HRESULT CURLArchive::CopyLocal( LPSTR szLocalFile, int ctChars )
{
    return E_NOTIMPL;
}



EXPORT HRESULT CURLArchive::CopyLocal( LPWSTR szwLocalFile, int ctChars )
{
    return E_NOTIMPL;
}



EXPORT HRESULT CURLArchive::Create( LPCSTR szURL )
{
    HRESULT  hr = E_FAIL;

    if( m_pStream )
        return E_ACCESSDENIED;

    if( !szURL )
        return E_INVALIDARG;

    hr = URLOpenBlockingStreamA( m_pUnk,
        szURL,
        &m_pStream,
        0u,
        NULL );

    return hr;
}


EXPORT HRESULT CURLArchive::Create( LPCWSTR szwURL )
{
    HRESULT  hr = E_FAIL;

    if( m_pStream )
        return E_ACCESSDENIED;

    if( !szwURL )
        return E_INVALIDARG;

    hr = URLOpenBlockingStreamW( m_pUnk,
        szwURL,
        &m_pStream,
        0u,
        NULL );

    return hr;
}



EXPORT HRESULT    CURLArchive::GetFileSize( long & lSize )
{
    lSize = -1;
    if( m_pStream )
    {
        HRESULT  hr;
        STATSTG  statStg;

        hr = m_pStream->Stat( &statStg, STATFLAG_NONAME );
        if( SUCCEEDED(hr) )
        {
            if( 0u == statStg.cbSize.HighPart )
            {
                lSize = statStg.cbSize.LowPart;
            }
            else
            {
                lSize = -1;
            }            
        }
        return hr;
    }
    return E_ACCESSDENIED;    
}


EXPORT IStream * CURLArchive::GetStreamInterface( void ) const
{
    return m_pStream;
}


EXPORT DWORD     CURLArchive::Read( LPBYTE lpb,
                             DWORD ctBytes )
{
    DWORD  ctBytesRead = 0u;

    if( m_pStream )
    {
        HRESULT hr;

        hr = m_pStream->Read( lpb, ctBytes, &ctBytesRead );
        if( FAILED(hr) )
            ctBytesRead = 0u;    
    }
    return ctBytesRead;
}


EXPORT DWORD     CURLArchive::ReadLine( LPSTR lpstr,
                                        DWORD ctBytes )
{
    if( !m_pStream || (ctBytes < 1) || !lpstr )
        return 0u;

    DWORD   ctBytesRead      = 0u;
    LPSTR   lpstrXfer        = lpstr;
    DWORD   ctBytesRemaining = ctBytes - 1u;
    char    chTemp[ 512 + 1 ];
    
    lpstr[0] = '\0';
    ZeroMemory( chTemp, sizeof(chTemp) );
    LOOPFOREVER
    {
        HRESULT hr;
        DWORD   ctBytesToRead;
        DWORD   ctBytesJustRead;

        ctBytesToRead = min( (DWORD) ctBytesRemaining, 
                             sizeof(chTemp) - 1u );
        hr = m_pStream->Read( chTemp, 
                              ctBytesToRead,
                              &ctBytesJustRead );

        for( DWORD i=0u; i<ctBytesJustRead; ++i )
        {
                // Is there a CRLF in here?
            if( ('\r' == chTemp[i]) || ('\n' == chTemp[i]) )
            {
                LARGE_INTEGER  li;

                    // Skip past any other line-breaks
                while( (++i < ctBytesJustRead) && 
                       (('\r' == chTemp[i]) || ('\n' == chTemp[i])) )
                {
                    NULL;  // increment i in while eval
                }
                       
                    // Rewind stream to the next non-empty line
                if( i < ctBytesJustRead )
                {
                    li.HighPart = -1L;
                    li.LowPart  = (DWORD)((long) i - 
                                          (long) ctBytesJustRead);
                    m_pStream->Seek( li, current, NULL );
                }

                *lpstrXfer = '\0';
                return ctBytesRead;
            }

            *lpstrXfer++ = chTemp[i];
            --ctBytesRemaining;
            ++ctBytesRead;
        }

           // IStream docs say EOF may or may not return S_ hr
           // Review(normb): What does failed hr mean given this?           
        if( FAILED(hr) || 
            (ctBytesJustRead != ctBytesToRead) || 
            (ctBytesRemaining < 1) )
        {
            break;
        }
    }

    return ctBytesRead;
}


EXPORT DWORD     CURLArchive::ReadLine( LPWSTR lpstrw,
                                        DWORD  ctChars )
{
    return 0u;
}




EXPORT long CURLArchive::Seek( long ctBytes, origin orig )
{
    long  lNewPos = -1L;

    if( m_pStream )
    {
        ULARGE_INTEGER  uli;
        LARGE_INTEGER   li;
        HRESULT         hr = E_FAIL;

        li.LowPart = ctBytes;
        if( ctBytes < 0 )
            li.HighPart = -1L;

        hr = m_pStream->Seek( li, orig, &uli );
        if( FAILED(hr) || uli.HighPart )
            return -1L;

        lNewPos = (long) uli.LowPart;
    }
    return lNewPos;
}


EXPORT DWORD     CURLArchive::Write( LPBYTE lpb,
                              DWORD ctBytes )
{   
    DWORD  ctBytesWritten = 0u;

    if( m_pStream )
    {
        HRESULT hr;

        hr = m_pStream->Read( lpb, ctBytes, &ctBytesWritten );
        if( FAILED(hr) )
            ctBytesWritten = 0u;
    }
    return ctBytesWritten;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\src\urlarchv.h ===
#ifndef _INC_URLARCHV_H
#define _INC_URLARCHV_H

#ifndef __urlmon_h__
  #include <urlmon.h>
#endif // __urlmon_h__

#ifndef EXPORT
  #define EXPORT __declspec( dllexport )
#endif // EXPORT

// -----------------------------
    
class CURLArchive
{
public:
    enum origin { start   = STREAM_SEEK_SET,
                  current = STREAM_SEEK_CUR,
                  end     = STREAM_SEEK_END };

public:
    EXPORT CURLArchive( IUnknown * pUnk = NULL );
    EXPORT virtual ~CURLArchive();

        // Opens or creates the file szURL
    EXPORT virtual HRESULT Create( LPCSTR szURL );

    EXPORT virtual HRESULT Create( LPCWSTR szwURL );    

        // Closes the file
    EXPORT virtual HRESULT Close( );

    EXPORT virtual HRESULT GetFileSize( long & lSize );

        // For folks that just can't resist...
    EXPORT virtual IStream * GetStreamInterface( void ) const;

        // Reads bytes from the file.
        // 
    EXPORT virtual DWORD     Read( LPBYTE lpb,
                                   DWORD    ctBytes );

    EXPORT virtual DWORD     ReadLine( LPSTR lpstr,
                                       DWORD ctBytes );

    EXPORT virtual DWORD     ReadLine( LPWSTR lpstrw,
                                       DWORD  ctChars );

    EXPORT virtual long    Seek( long ctBytes, origin orig );

        // Writes bytes to the file.
        //
    EXPORT virtual DWORD     Write( LPBYTE lpb,
                           DWORD ctBytes );    

        // Make a local copy of the file
    EXPORT virtual HRESULT CopyLocal( LPSTR szLocalFile, int ctChars );
    EXPORT virtual HRESULT CopyLocal( LPWSTR szwLocalFile, int ctChars );    

private:
    CURLArchive( const CURLArchive & );
    CURLArchive & operator=( const CURLArchive & );

private:    
    IStream *   m_pStream;
    IUnknown *  m_pUnk;
};

#endif // _INC_URLARCHV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\uuid\makefile.inc ===
#
# Explicit rules for copying generated *_i.c files from ..\idl\$(O) to $(O)
#

$(O)\proctexe_i.c : ..\idl\$(O)\proctexe_i.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\autourl.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       autourl.cxx
//
//  Contents:   Implementation of url autodetector object
//
//  History:    05-11-99 - ashrafm - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_EDCMD_HXX_
#define X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef X_EDTRACK_HXX_
#define X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef X_AUTOURL_HXX_
#define X_AUTOURL_HXX_
#include "autourl.hxx"
#endif

#ifndef _X_ANCHOR_H_
#define _X_ANCHOR_H_
#include "anchor.h"
#endif

#ifndef X_VRSSCAN_H_
#define X_VRSSCAN_H_
#include "vrsscan.h"
#endif

// TODO: consider creating scratch pointers for url autodetector [ashrafm]

using namespace EdUtil;

DeclareTag( tagDisableAutodetector, "UrlAutodetector", "Disable URL Autodetector" );

//
// AutoUrl Land
//

// TODO (t-johnh, 8/5/98): The following structs/tables/etc. are 
//  copied from src\site\text\text.cxx.  These either need to be 
//  kept in sync or merged into a single, easily accessible table

#define AUTOURL_WILDCARD_CHAR   _T('\b')

//
// TODO: use in CTxtPtr::IsInsideUrl [ashrafm]
//
// TODO: (tomfakes) This needs to be in-step with the same table in TEXT.CXX

#define MAX_URL_PREFIX_LEN 20

AUTOURL_TAG const s_urlTags[] = {
    { FALSE, 7,  1,  {_T("www."),         _T("http://www.")}},
    { FALSE, 7,  1,  {_T("http://"),      _T("http://")}},
    { FALSE, 8,  2,  {_T("https://"),     _T("https://")}},
    { FALSE, 6,  3,  {_T("ftp."),         _T("ftp://ftp.")}},
    { FALSE, 6,  3,  {_T("ftp://"),       _T("ftp://")}},
    { FALSE, 9,  4,  {_T("gopher."),      _T("gopher://gopher.")}},
    { FALSE, 9,  4,  {_T("gopher://"),    _T("gopher://")}},
    { FALSE, 7,  5,  {_T("mailto:"),      _T("mailto:")}},
    { FALSE, 5,  6,  {_T("news:"),        _T("news:")}},
    { FALSE, 6,  7,  {_T("snews:"),       _T("snews:")}},
    { FALSE, 7,  8,  {_T("telnet:"),      _T("telnet:")}},
    { FALSE, 5,  9,  {_T("wais:"),        _T("wais:")}},
    { FALSE, 7,  10, {_T("file://"),      _T("file://")}},
    { FALSE, 10, 10, {_T("file:\\\\"),    _T("file:///\\\\")}},
    { FALSE, 7,  11, {_T("nntp://"),      _T("nntp://")}},
    { FALSE, 7,  12, {_T("newsrc:"),      _T("newsrc:")}},
    { FALSE, 7,  13, {_T("ldap://"),      _T("ldap://")}},
    { FALSE, 8,  14, {_T("ldaps://"),     _T("ldaps://")}},
    { FALSE, 8,  15, {_T("outlook:"),     _T("outlook:")}},
    { FALSE, 6,  16, {_T("mic://"),       _T("mic://")}},
    { FALSE, 0,  17, {_T("url:"),         _T("")}}, 

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // N.B. The following have wildcard characters.
    // If you change \b to something else make sure you also change
    // the AUTOURL_WILDCARD_CHAR macro defined above.
    //
    // Note that there should be the same number of wildcards in the left and right strings.
    // Also, all characters in in both strings must be identical after the FIRST wildcard.
    // For example: LEGAL:   {_T("\b@\b"),   _T("mailto:\b@\b")},     [since @\b == @\b]
    //              ILLEGAL: {_T("\b@hi\b"), _T("mailto:\b@there\b")} [since @hi != @there]

    { TRUE,  0, 10, {_T("\\\\\b"),         _T("file://\\\\\b")}},
#if 0 // to be consistent with word2k
    { TRUE,  0, 10, {_T("//\b"),           _T("file://\b")}},
#endif
    { TRUE,  0, 5, {_T("\b@\b"),       _T("mailto:\b@\b")}},

};


//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::CAutoUrlDetector
//
//  Synopsis:   ctor
//
//  Arguments:  [pEd]           CHTMLEditor pointer
//
//-----------------------------------------------------------------------------
CAutoUrlDetector::CAutoUrlDetector(CHTMLEditor *pEd)
{
    Assert(pEd);

    _pEd = pEd;
    _fEnabled = TRUE;
    _fCanUpdateText = TRUE;
    _lLastContentVersion = 0;
    _dwLastSelectionVersion = 0;    
    _pLastMarkup = NULL;
}

//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::CAutoUrlDetector
//
//  Synopsis:   dtor
//
//+----------------------------------------------------------------------------

CAutoUrlDetector::~CAutoUrlDetector()
{
    ReleaseInterface(_pLastMarkup);
}

//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::ShouldPerformAutoDetection
//
//  Synopsis:   Helper function for URL Autodetection.
//      Determines whether autodetection should be performed, based
//      upon the context of the given markup pointer.
//
//  Arguments:  [pmp]           MarkupPointer at which to autodetect
//              [pfAutoDetect]  Filled with TRUE if autodetection should happen
//
//  Returns:    HRESULT         S_OK if all is well, otherwise error
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::ShouldPerformAutoDetection(
    IMarkupPointer      *   pmp,
    BOOL                *   pfAutoDetect )
{
    HRESULT                 hr              = S_OK;
    IHTMLElement        *   pFlowElement    = NULL;
    VARIANT_BOOL            fMultiLine;
    VARIANT_BOOL            fEditable;
    ELEMENT_TAG_ID          tagFlowElement;
    VARIANT_BOOL            fHTML           = VARIANT_FALSE;
    SP_IHTMLElement3        spElement3;

    Assert( pmp && pfAutoDetect );

    *pfAutoDetect = FALSE;
   
    hr = THR( GetEditor()->GetFlowElement( pmp, &pFlowElement ) );
    if( FAILED(hr) )
        goto Cleanup;

    hr = S_OK;

    if( !pFlowElement )
        goto Cleanup;    

    IFC(pFlowElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    hr = THR(spElement3->get_isMultiLine(&fMultiLine));
    if( hr )
        goto Cleanup;

    if( fMultiLine )
    {
        // Check if it's a container
        hr = THR(spElement3->get_canHaveHTML(&fHTML));
        if( hr )
            goto Cleanup;

        hr = THR(spElement3->get_isContentEditable(&fEditable));
        if( hr )
            goto Cleanup;

        hr = THR( GetMarkupServices()->GetElementTagId( pFlowElement, &tagFlowElement ) );
        if( hr )
            goto Cleanup;

        // Buttons are a no-no as well
        fHTML = fHTML && fEditable && tagFlowElement != TAGID_BUTTON;
    }

    *pfAutoDetect = fHTML;

Cleanup:
    ReleaseInterface( pFlowElement );

    RRETURN( hr );
}
        
//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::CreateAnchorElement
//
//  Synopsis:   Helper function for URL Autodetection.
//      Creates an anchor element and inserts it over the range
//      bounded by pStart and pEnd.  This does not set the href or any other
//      properties.
//
//  Arguments:  [pMS]       MarkupServices to work in
//              [pStart]    Start of range over which to insert the anchor
//              [pEnd]      End of range over which to insert the anchor
//              [ppAnchor]  Filled with the anchor element inserted.
//
//  Returns:    HRESULT     S_OK if successful, otherwise an error.
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::CreateAnchorElement(
    IMarkupPointer      *   pStart,
    IMarkupPointer      *   pEnd,
    IHTMLAnchorElement  **  ppAnchorElement)
{
    HRESULT hr;
    IHTMLElement *pElement = NULL;

    // Check our arguments
    Assert( pStart && pEnd && ppAnchorElement );

    // Create the anchor
    hr = THR( GetMarkupServices()->CreateElement(TAGID_A, NULL, &pElement ) );
    if( hr )
        goto Cleanup;

    // Slam it into the tree
    hr = THR( InsertElement(GetMarkupServices(), pElement, pStart, pEnd ) );
    if( hr )
        goto Cleanup;

    // Get a nice parting gift for our caller - a real live anchor!
    hr = THR( pElement->QueryInterface( IID_IHTMLAnchorElement, (void **)ppAnchorElement ) );
    if( hr )
        goto Cleanup;

Cleanup:
    ReleaseInterface( pElement );
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::GetPlainText
//
//  Synopsis:   Helper function for URL Autodetection.
//      Retrieves the plain text between the start and end pointers
//      of the URL
//
//
//  Arguments:  [pMS]       MarkupServices
//              [pUrlStart] Beginning of text
//              [pUrlEnd]   End of text
//              [achText]   Buffer to fill with text
//
//  Returns:    HRESULT     S_OK if successful, otherwise error
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::GetPlainText(
    IMarkupPointer  * pUrlStart,
    IMarkupPointer  * pUrlEnd,
    TCHAR             achText[MAX_URL_LENGTH + 1] )
{
    IMarkupPointer *    pCurr       = NULL;
    int                 iComparison;
    HRESULT             hr;
    long                cchBuffer   = 0;
    MARKUP_CONTEXT_TYPE context;

    Assert( pUrlStart && pUrlEnd );

    //
    // Create and position a pointer for text scanning
    //
    hr = THR( GetEditor()->CreateMarkupPointer( &pCurr ) );
    if( hr )
        goto Cleanup;

    hr = THR( pCurr->MoveToPointer( pUrlStart ) );
    if( hr )
        goto Cleanup;

    hr = THR( OldCompare( pCurr, pUrlEnd, &iComparison ) );
    if( hr )
        goto Cleanup;

    //
    // Keep getting characters until we've scooted up to the end
    //
    while( iComparison == RIGHT && cchBuffer < MAX_URL_LENGTH)
    {
        long cchOne = 1;

        // Get a character
        hr = THR( pCurr->Right( FALSE, &context, NULL, &cchOne, achText + cchBuffer ) );
        if( hr ) 
            goto Cleanup;
        if( context == CONTEXT_TYPE_Text )
        {
            ++cchBuffer;
        }

        // It's just a jump to the left... and then a step to the right...
        hr = THR( pCurr->MoveUnit( MOVEUNIT_NEXTCHAR ) );
        if( hr )
            goto Cleanup;

        hr = THR( OldCompare( pCurr, pUrlEnd, &iComparison ) );
        if( hr )
            goto Cleanup;
    }

    // Terminate.
    achText[cchBuffer] = 0;

Cleanup:
    ReleaseInterface( pCurr );

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::FindPattern
//
//  Synopsis:   Helper function for URL Autodetection.
//      Determines which URL pattern was matched, so that we know
//      how to translate it into an HREF string for the anchor
//
//  Arguments:  [pstrText]      The text of the URL
//              [ppTag]         Filled with a pointer to the pattern tag
//
//  Returns:    BOOL            TRUE if found a pattern
//
//-----------------------------------------------------------------------------
BOOL
CAutoUrlDetector::FindPattern( LPTSTR pstrText, const AUTOURL_TAG ** ppTag )
{
    int i;

    // Scan through the table
    for( i = 0; i < ARRAY_SIZE( s_urlTags ); i++ )
    {
        BOOL    fMatch = FALSE;
        const TCHAR * pszPattern = s_urlTags[i].pszPattern[AUTOURL_TEXT_PREFIX];

        if( !s_urlTags[i].fWildcard )
        {
            long cchLen = _tcslen( pszPattern );
#ifdef UNIX
            //IEUNIX: We need a correct count for UNIX version.
            long iStrLen = _tcslen( pstrText );
            if ((iStrLen > cchLen) && !_tcsnicmp(pszPattern, cchLen, pstrText, cchLen))
#else
            if (!StrCmpNIC(pszPattern, pstrText, cchLen) && pstrText[cchLen])
#endif
                fMatch = TRUE;
        }
        else
        {
            const TCHAR* pSource = pstrText;
            const TCHAR* pMatch  = pszPattern;

            while( *pSource )
            {
                if( *pMatch == AUTOURL_WILDCARD_CHAR )
                {
                    // N.B. (johnv) Never detect a slash at the
                    //  start of a wildcard (so \\\ won't autodetect).
                    if (*pSource == _T('\\') || *pSource == _T('/'))
                        break;

                    if( pMatch[1] == 0 )
                        // simple optimization: wildcard at end we just need to
                        //  match one character
                        fMatch = TRUE;
                    else
                    {
                        while( *pSource && *(++pSource) != pMatch[1] )
                            ;
                        if( *pSource )
                            pMatch++;       // we skipped wildcard here
                        else
                            continue;   // no match
                    }
                }
                else if( *pSource != *pMatch )
                    break;

                if( *(++pMatch) == 0 )
                    fMatch = TRUE;

                pSource++;
            }
        }
        
        if( fMatch )
        {
            *ppTag = &s_urlTags[i];
            return TRUE;
        }
    }        

    *ppTag = NULL;
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CAutoUrlDetector::ApplyPattern
//
//  Synopsis:   Helper function for URL Autodetection.
//              This function creates a destination string corresponding to
//              the 'pattern' of a source string.  For example, given the
//              ptag {_T("\b@"),_T("mailto:\b@")}, and the source string
//              x@y.com, this function can generate mailto:x@y.com.  Similarly,
//              given mailto:x@y.com, it can generate x@y.com.
//
//
//  Arguments:  pstrDest            where we should allocate memory to hold the
//                                  destination string.
//
//              iIndexDest          the ptag pattern index for the destination
//
//              pszSourceText       the source string (which must have been matched
//                                  via the CAutoUrlDetector::IsAutodetectable function).
//
//              iIndexSrc           the ptag pattern index for the source
//
//              ptag                the ptag (returned via the CAutoUrlDetector::IsAutodetectable
//                                  function).
//
//----------------------------------------------------------------------------
void
CAutoUrlDetector::ApplyPattern( 
    LPTSTR          pstrDest, 
    int             iIndexDest,
    LPTSTR          pstrSource,
    int             iIndexSrc,
    const AUTOURL_TAG * ptag )
{
    if( ptag->fWildcard )
    {
        const TCHAR *   pszPrefixEndSrc;
        const TCHAR *   pszPrefixEndDest;
        int             iPrefixLengthSrc, iPrefixLengthDest;

        // Note: There MUST be a wildcard in both the source and destination
        //  patterns, or we will overflow into infinity.
        pszPrefixEndSrc = ptag->pszPattern[iIndexSrc];
        while( *pszPrefixEndSrc != AUTOURL_WILDCARD_CHAR )
            ++pszPrefixEndSrc;

        pszPrefixEndDest = ptag->pszPattern[iIndexDest];
        while( *pszPrefixEndDest != AUTOURL_WILDCARD_CHAR )
            ++pszPrefixEndDest;

        iPrefixLengthDest= pszPrefixEndDest - ptag->pszPattern[iIndexDest];
        iPrefixLengthSrc=  pszPrefixEndSrc  - ptag->pszPattern[iIndexSrc];

        memcpy( pstrDest, ptag->pszPattern[iIndexDest], iPrefixLengthDest*sizeof(TCHAR) );
        _tcsncpy( pstrDest + iPrefixLengthDest, pstrSource + iPrefixLengthSrc,
        			MAX_URL_LENGTH - iPrefixLengthDest);
    }
    else
    {
#if DBG==1
        int iTotalLength = _tcslen(ptag->pszPattern[iIndexDest]) +
                           _tcslen(pstrSource + _tcslen(ptag->pszPattern[iIndexSrc]));
        Assert( iTotalLength <= 1024 );
#endif
        _tcscpy( pstrDest, ptag->pszPattern[iIndexDest]);
        _tcsncat( pstrDest, pstrSource + _tcslen(ptag->pszPattern[iIndexSrc]), 
        			MAX_URL_LENGTH - _tcslen(ptag->pszPattern[iIndexDest]));
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::RemoveQuotes
//
//  Synopsis:   Helper function for URL Autodetection.
//      When a user closes a quoted URL, we remove the opening and
//      closing quotes.
//              We only consider the URL quoted if there is on opening quote
//      character (quote or less-than) just in front of the range, and a
//      matching close quote character (quote or greater-than) just inside the
//      end of the range.
//  
//
//  Arguments:
//      IMarkupServices * pMS         - Markup Services
//      IMarkupPointer  * pOpenQuote  - Points to open quote
//      IMarkupPointer  * pCloseQuote - Points to close quote
//
//  Returns:    HRESULT     S_OK if all is well, otherwise error
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::RemoveQuotes( 
    IMarkupPointer  *   pOpenQuote,
    IMarkupPointer  *   pCloseQuote)
{
    HRESULT             hr;
    IMarkupPointer  *   pQuoteKiller    = NULL;
    LONG                cch;
    OLECHAR             chOpen;
    OLECHAR             chClose;
    MARKUP_CONTEXT_TYPE context;

    // Create a pointer to look at the left side
    IFC( GetEditor()->CreateMarkupPointer( &pQuoteKiller ) );

    // Position it
    IFC( pQuoteKiller->MoveToPointer( pOpenQuote ) );

    // And read the open quote char
    cch = 1;
    IFC( pQuoteKiller->Right(TRUE, &context, NULL, &cch, &chOpen) );
    
    // If it wasn't text, or we got more than one char or a non-quote char, bail
    if (context != CONTEXT_TYPE_Text || cch != 1 || (chOpen != _T('"') && chOpen != _T('<')))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Rip out the open quote.
    IFC( GetMarkupServices()->Move( pOpenQuote, pQuoteKiller, NULL ) );   

    // Now do the same for the right side
    IFC( pQuoteKiller->MoveToPointer( pCloseQuote ) );

    cch = 1;
    IFC( pQuoteKiller->Right( TRUE, &context, NULL, &cch, &chClose ) );

    // Same deal for bailing
    if (context != CONTEXT_TYPE_Text || cch != 1 || (chClose != _T('"') && chClose != _T('>')))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Rip out the close quote.
    IFC( GetMarkupServices()->Move( pCloseQuote, pQuoteKiller, NULL ) );

    AssertSz( ( chOpen == _T('"') && chClose == _T('"') ) || ( chOpen == _T('<') && chClose == _T('>') ),
              "CAutoUrlDetector::RemoveQuotes called when it shouldn't have been" );
    
Cleanup:
    ReleaseInterface( pQuoteKiller );

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::SetUrl
//
//  Synopsis:   Helper function for URL Autodetection.
//      Given a range of text that is known to be a URL, will create
//      and wire up an anchor element around it, as well as take all
//      appropriate actions (cleaning up quotes, figuring out the caret
//      position, etc.)
//      May also constrain the boundaries if detection was typing-triggered
//      and not in an existing link.  In this case, detection should
//      terminate at the position of the typed character.
//
//  Arguments:  [pEd]       Editor
//              [pUrlStart] Begin of range
//              [pUrlEnd]   End of range
//              [pOldCaret] Position of the caret prior to detection
//              [pChar]     Character that triggered detection or NULL
//              [fHandleQuotes] TRUE if caller wants us to handle quotes.
//              [pfRepos]   Enumeration stating how to reposition the caret, if at all
//
//  Returns:    HRESULT     S_OK if successful, otherwise error
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::SetUrl(
    IMarkupPointer          * pUrlStart,
    IMarkupPointer          * pUrlEnd,
    IMarkupPointer          * pOldCaretPos,
    OLECHAR                 * pChar,
    BOOL                      fUIAutoDetect,
    AUTOURL_REPOSITION      * pfRepos )
{
    HRESULT                 hr;
    TCHAR                   achText[MAX_URL_LENGTH + 1];
    TCHAR                   achHref[MAX_URL_LENGTH + 1];
    TCHAR                   chBeforeBegin = 0;          // For quote checking
    TCHAR                   chAfterEnd;                 // For quote checking
    const AUTOURL_TAG   *   pTag;
    BSTR                    bstrHref        = NULL;
    IHTMLElement        *   pElement        = NULL;
    IHTMLAnchorElement  *   pAnchorElement  = NULL;
    CEditPointer            epOpenQuote( GetEditor() );         // For checking quotes
    CEditPointer            epCloseQuote( GetEditor() );        // For checking quotes
    IMarkupPointer      *   pAfterAnchorEnd = NULL;     // For adjusting anchor
    BOOL                    fCreatedAnchor  = FALSE;    // Did we create an anchor?
    BOOL                    fOpenQuote      = FALSE;    // Was there an open quote?
    BOOL                    fFullyQuoted    = FALSE;    // Are there matching open/close quotes?
    SP_IHTMLElement         spAnchorElement;
    SP_IHTMLElement3        spElement3;
    VARIANT_BOOL            fAcceptsHtml;
    CEdUndoHelper               undoUnit(GetEditor());
    CSelectionManager       *pManager = GetEditor()->GetSelectionManager();
    BOOL                    &fHandleQuotes = fUIAutoDetect;
    BOOL                    fCanUpdateText;
    SP_IMarkupContainer2    spMarkup2;

    Assert( GetMarkupServices() && pUrlStart && pUrlEnd );

    //
    // Make sure our container is editable
    //

    IFC( pUrlStart->CurrentScope(&spAnchorElement) );
    if (spAnchorElement == NULL)
    {
        hr = S_OK; // nothing to do if we can't get to scope
        goto Cleanup;
    }
        
    // TODO: with the check in ShouldAutoDetect, we shouldn't need this [ashrafm]

    //
    // TODO - marka - convert this into an assert if it's redundant, or remove the above comment
    //
    IFC(spAnchorElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) )
    IFC(spElement3->get_canHaveHTML(&fAcceptsHtml));
    if (!fAcceptsHtml)
    {
        hr = S_OK; // nothing to do if container can't accept html
        goto Cleanup;
    }
    
    //
    // If our caller cares about quoting, we'll determine the information
    // they [and we] need.
    //
    if( fHandleQuotes )
    {
        DWORD eBreakConditionOut;

        // Check the character before the beginning of the URL
        IFC( epOpenQuote.MoveToPointer( pUrlStart ) );
        IFC( epOpenQuote.Scan( LEFT, BREAK_CONDITION_OMIT_PHRASE & ~BREAK_CONDITION_Anchor, &eBreakConditionOut, NULL, NULL, &chBeforeBegin ) );

        if( eBreakConditionOut & BREAK_CONDITION_Text &&
            chBeforeBegin == _T('"') || chBeforeBegin == _T('<') )
            fOpenQuote = TRUE;
    }

    //
    // The only anchor we would care about is one IMMEDIATELY surrounding us,
    // as that's what we'll get from FindUrl.
    //
    
    // Check the context at the beginning of the URL
    hr = THR( pUrlStart->CurrentScope( &pElement ) );
    if( hr )
        goto Cleanup;

    // See if it's an anchor
    if (pElement)
        THR_NOTRACE( pElement->QueryInterface( IID_IHTMLAnchorElement, (void **) &pAnchorElement ) );

    // If no anchor, then check the end.
    if( NULL == pAnchorElement )
    {
        ReleaseInterface( pElement );

        hr = THR( pUrlEnd->CurrentScope( &pElement ) );
        if( hr )
            goto Cleanup;

        if( pElement )
            THR_NOTRACE( pElement->QueryInterface( IID_IHTMLAnchorElement, (void **) &pAnchorElement ) );
    }

    // Nope - we'll have to make one.    
    if( NULL == pAnchorElement )
    {
        // Check if there is another anchor above as an indirect parent.  If so, don't create a new one.
        IFC( FindTagAbove(GetMarkupServices(), pElement, TAGID_A, &spAnchorElement) );
        if (spAnchorElement != NULL)
            goto Cleanup; // done;

        // If there was an open quote and we're making a new anchor,
        // check to see if we're closing the quotes at the same time.
        if( fHandleQuotes && fOpenQuote ) 
        {
            DWORD eBreakConditionOut;

            IFC( epCloseQuote.SetGravity( POINTER_GRAVITY_Right ) );
            IFC( epCloseQuote.MoveToPointer( pUrlEnd ) );

            IFC( epCloseQuote.Scan( RIGHT, BREAK_CONDITION_OMIT_PHRASE, &eBreakConditionOut, NULL, NULL, &chAfterEnd ) );

            fFullyQuoted = ( eBreakConditionOut & BREAK_CONDITION_Text ) &&
                           ( chBeforeBegin == _T('"') && chAfterEnd == _T('"') ) ||
                           ( chBeforeBegin == _T('<') && chAfterEnd == _T('>') );

            // If we're fully quoted, go back and remember where the close quote was.
            if( fFullyQuoted )
            {
                IFC( epCloseQuote.Scan( LEFT, BREAK_CONDITION_Text ) );
            }
        }

        
        // If typing-triggered and quoted, but not completed with the typed char,
        // include the typed character in the quoted link
        //
        // TODO (JHarding): This isn't always correct if we trimmed characters
        // off the end of the URL.  This should be more intelligent about including
        // up to and including the typed character.
        // 
        //  This seems to be bogus: if not fully quoted, we will not honor this 
        //  as URL. In fact, Trident seems to return NOT IsInsideURL if this is
        //  the case. So the code below seems to be superfluous. 
        //  [zhenbinx]
        //
        if( pChar && fHandleQuotes && fOpenQuote && !fFullyQuoted )
        {
            MARKUP_CONTEXT_TYPE *   pContext = NULL;
            long                    cch = 1;

            AssertSz(FALSE, "Harmless assertion! If this happens, the code below is not redudant");
            
            WHEN_DBG(MARKUP_CONTEXT_TYPE     context);
            WHEN_DBG(pContext = &context);

            hr = pUrlEnd->Right(TRUE, pContext, NULL, &cch, NULL);
            if (hr)
                goto Cleanup;

            Assert(CONTEXT_TYPE_Text == *pContext);
            Assert(1 == cch);
        }

        IFC( undoUnit.Begin(IDS_EDUNDOTYPING) );

        // Wire up the anchor around the appropriate text
        hr = THR( CreateAnchorElement( pUrlStart, pUrlEnd, &pAnchorElement ) );
        if( hr )
            goto Cleanup;
            
        fCreatedAnchor = TRUE;

        // Update seleciton version
        _dwLastSelectionVersion = GetEditor()->GetSelectionVersion();

        // Update markup
        ClearInterface(&_pLastMarkup);
        IFC( pUrlStart->GetContainer(&_pLastMarkup) );
        IFC( _pLastMarkup->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spMarkup2) );

        // Update content version
        _lLastContentVersion = spMarkup2->GetVersionNumber();
    }
    else
    {
        //
        // If we are updating an existing anchor, add the undo unit
        // to the current typing batch
        //
        if (pManager->GetTrackerType() == TRACKER_TYPE_Caret && pManager->GetActiveTracker())
        {
            CCaretTracker *pCaretTracker = DYNCAST(CCaretTracker, pManager->GetActiveTracker());

            IFC( pCaretTracker->BeginTypingUndo(&undoUnit, IDS_EDUNDOTYPING) )
        }
        else
        {
            IFC( undoUnit.Begin(IDS_EDUNDOTYPING) );
        }
        
        //
        // We found an existing anchor
        //
        BOOL fEndLeftOf;

        if( fHandleQuotes )
        {
            DWORD eBreakConditionOut;

            IFC( epCloseQuote.SetGravity( POINTER_GRAVITY_Right ) );
            IFC( epCloseQuote.MoveToPointer( pUrlEnd ) );

            IFC( epCloseQuote.Scan( LEFT, BREAK_CONDITION_OMIT_PHRASE & ~BREAK_CONDITION_Anchor, &eBreakConditionOut, NULL, NULL, &chAfterEnd ) );

            fFullyQuoted = (eBreakConditionOut & BREAK_CONDITION_Text) &&
                           ( chBeforeBegin == _T('"') && chAfterEnd == _T('"') ) ||
                           ( chBeforeBegin == _T('<') && chAfterEnd == _T('>') );
        }

        //
        // If the anchor doesn't match the new anchor text, we may have to adjust it.
        //
        IFC( GetEditor()->CreateMarkupPointer( &pAfterAnchorEnd ) );

        IFC( pAfterAnchorEnd->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterEnd ) );

        // Check if the anchor ends before the new url text
        IFC( pAfterAnchorEnd->IsLeftOf( pUrlEnd, &fEndLeftOf ) );

        if( fEndLeftOf )
        {
            // Pull the anchor out and re-insert over the appropriate range
            IFC( GetMarkupServices()->RemoveElement( pElement ) );
            IFC( GetMarkupServices()->InsertElement( pElement, pUrlStart, pUrlEnd ) );
        }
    }

    // If typing-triggered, quoted, and the quote chars match, we go outside    
    if( fFullyQuoted && fHandleQuotes )
    {
        hr = THR( RemoveQuotes( epOpenQuote, epCloseQuote ) );
        if( hr )
            goto Cleanup;

        if( pfRepos )
            *pfRepos = AUTOURL_REPOSITION_Outside;
    }
    else if( fCreatedAnchor && fOpenQuote && fHandleQuotes )
    {
        if( pfRepos )
            *pfRepos = AUTOURL_REPOSITION_Inside;
    }
        

    //
    // Translate from plain text to href string:
    // 1) Get the plain text
    // 2) Figure out what pattern it is
    // 3) Apply the translation pattern
    //
    hr = THR( GetPlainText( pUrlStart, pUrlEnd, achText ) );
    if( hr )
        goto Cleanup;

    if (!FindPattern( achText, &pTag))
        goto Cleanup;

    ApplyPattern( achHref, AUTOURL_HREF_PREFIX,
                          achText, AUTOURL_TEXT_PREFIX,
                          pTag );

    // Allocate the href string
    bstrHref = SysAllocString( achHref );
    if( !bstrHref )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // HACKHACK: put_href causes the text contained in the URL to be
    // updated.  This behavior is done for ie401 compat.  So, force
    // no update here.

    fCanUpdateText = _fCanUpdateText;
    _fCanUpdateText = FALSE;

    hr = THR( pAnchorElement->put_href( bstrHref ) );
    if( hr )
        goto Cleanup;

    _fCanUpdateText = fCanUpdateText;

Cleanup:
    ReleaseInterface( pElement );
    ReleaseInterface( pAnchorElement );
    ReleaseInterface( pAfterAnchorEnd );
    SysFreeString( bstrHref );

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::DetectRange
//
//  Synopsis:   Performs URL autodetection on the given range.  Note that URLs
//      that are autodetected may need be wholly contained within the range, as
//      URLs can straddle the boundaries of the range.
//
//  Arguments:  [pEd]           The Editor in which to work.
//              [pRangeStart]   Begin of range to autodetect
//              [pRangeEnd]     End of range to autodetect
//
//  Returns:    HRESULT         S_OK if no problems, otherwise error.
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::DetectRange(
    IMarkupPointer  *   pRangeStart,
    IMarkupPointer  *   pRangeEnd,
    BOOL                fValidate /* = TRUE */,
    IMarkupPointer  *   pLimit /* = NULL */)
{
    IMarkupPointer  *   pUrlStart   = NULL;
    IMarkupPointer  *   pUrlEnd     = NULL;
    IMarkupPointer  *   pCurr       = NULL;
    IMarkupPointer2 *   pmp2        = NULL;
    BOOL                fDetect     = FALSE;
    HRESULT             hr          = S_OK;
    BOOL                fFound      = FALSE;
    BOOL                fLeftOf;

    if (!_fEnabled)
        return S_OK;

    // Check validity of everything
    #if DBG==1
    INT iComparison;
    Assert( pRangeStart && pRangeEnd );
    Assert( !OldCompare( pRangeStart, pRangeEnd, &iComparison ) && iComparison != LEFT );
    WHEN_DBG( if( IsTagEnabled( tagDisableAutodetector ) ) goto Cleanup );
    #endif

    // See if we should even bother
    if ( fValidate )
    {
        hr = THR( ShouldPerformAutoDetection( pRangeStart, &fDetect ) );
        if( hr || !fDetect )
            goto Cleanup;
    }

    //
    // Create pointers for us to play with.
    //
    hr = THR( GetEditor()->CreateMarkupPointer( &pUrlStart ) );    
    if( hr )
        goto Cleanup;

    hr = THR( pUrlStart->SetGravity(POINTER_GRAVITY_Left) );
    if( hr )
        goto Cleanup;        

    hr = THR( GetEditor()->CreateMarkupPointer( &pUrlEnd ) );
    if( hr )
        goto Cleanup;

    hr = THR( pUrlEnd->SetGravity(POINTER_GRAVITY_Right) );
    if( hr )
        goto Cleanup;        

    hr = THR( GetEditor()->CreateMarkupPointer( &pCurr ) );
    if( hr )
        goto Cleanup;

    IFC( pCurr->QueryInterface( IID_IMarkupPointer2, (void **)&pmp2 ) );

    hr = THR( pmp2->MoveToPointer( pRangeStart ) );
    if( hr )
        goto Cleanup;

    // Check for a URL at start
    hr = THR( pmp2->IsInsideURL( pUrlEnd, &fFound ) );
    if( hr )
        goto Cleanup;

    if (fFound)
    {
        // Link it up
        fLeftOf = FALSE;
        if (pLimit)
            IFC( pLimit->IsLeftOf(pUrlEnd, &fLeftOf) );
                
        hr = THR( SetUrl( pmp2, fLeftOf ? pLimit : pUrlEnd, NULL, NULL, FALSE, NULL ) );
        if( hr )
            goto Cleanup;

        hr = THR( pmp2->MoveToPointer( pUrlEnd ) );
        if( hr )
            goto Cleanup;
    }

    for (;;)
    {
        // hr = THR(GetViewServices()->FindUrl(pCurr, pRangeEnd, pUrlStart, pUrlEnd));
        hr = THR(pmp2->MoveUnitBounded( MOVEUNIT_NEXTURLBEGIN, pRangeEnd ) );
        if (hr != S_OK)
        {
            hr = (hr == S_FALSE) ? S_OK : hr;
            goto Cleanup;
        }
        IFC( pUrlStart->MoveToPointer( pmp2 ) );
        IFC( pUrlEnd->MoveToPointer( pUrlStart ) );
        IFC( pUrlEnd->MoveUnit( MOVEUNIT_NEXTURLEND ) );
        
        // Link it up
        fLeftOf = FALSE;
        if (pLimit)
            IFC( pLimit->IsLeftOf(pUrlEnd, &fLeftOf) );
        
        hr = THR( SetUrl( pUrlStart, fLeftOf ? pLimit : pUrlEnd, NULL, NULL, FALSE, NULL ) );
        if( hr )
            goto Cleanup;

        // Start from the end of this one for the next earch
        hr = THR( pmp2->MoveToPointer( pUrlEnd ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface( pUrlStart );
    ReleaseInterface( pUrlEnd );
    ReleaseInterface( pCurr );
    ReleaseInterface( pmp2 );

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::DetectCurrentWord
//
//  Synopsis:   Performs URL autodetection just on the current/previous word.
//      This is mainly to be used during editing where the only way that
//      there is a new URL is at the word currently being edited.
//
//  Arguments:  [pWord]     Pointer to the current word to detect
//              [pChar]     The character entered which triggered autodetection
//              [pfInside]  Filled with TRUE if caller should go left into link
//              [pLimit]    Right limit on detection
//              [pLeft]     If given, will be set to left end of URL if there is one
//
//  Returns:    HRESULT     S_OK if no problems, otherwise an error
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::DetectCurrentWord( 
    IMarkupPointer      *   pWord,
    OLECHAR             *   pChar,
    AUTOURL_REPOSITION  *   pfRepos,
    IMarkupPointer      *   pLimit /* = NULL */,
    IMarkupPointer      *   pLeft /* = NULL */,
    BOOL                *   pfFound /* = NULL */ )
{
    IMarkupPointer  *   pStart      = NULL;
    IMarkupPointer  *   pEnd        = NULL;
    IMarkupPointer2 *   pmp2        = NULL;
    BOOL                fDetect;
    BOOL                fFound;
    HRESULT             hr          = S_OK;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    if( pfRepos )
    {
        *pfRepos = AUTOURL_REPOSITION_No;
    }

    if (!_fEnabled)
    {
        goto Cleanup;
    }

    // Check argument validity
    Assert( GetMarkupServices() && pWord );
    WHEN_DBG( if( IsTagEnabled( tagDisableAutodetector ) ) goto Cleanup );

    // Don't waste time if we can't autodetect
    hr = THR( ShouldPerformAutoDetection( pWord, &fDetect ) );
    if( hr || !fDetect )
        goto Cleanup;

    //
    // Set everything up
    //

    hr = THR( GetEditor()->CreateMarkupPointer( &pStart ) );
    if( hr )
        goto Cleanup;

    hr = THR( pStart->SetGravity(POINTER_GRAVITY_Left) );
    if( hr )
        goto Cleanup;

    hr = THR( GetEditor()->CreateMarkupPointer( &pEnd ) );
    if( hr )
        goto Cleanup;

    hr = THR( pEnd->SetGravity(POINTER_GRAVITY_Right) );
    if( hr )
        goto Cleanup;

    hr = THR( pStart->MoveToPointer( pWord ) );
    if( hr )
        goto Cleanup;

    // Check for a URL
    IFC( pStart->QueryInterface( IID_IMarkupPointer2, (void **)&pmp2 ) );
    hr = THR( pmp2->IsInsideURL( pEnd, &fFound ) );
    if( hr )
        goto Cleanup;

    if( pfFound )
    {
        *pfFound = fFound;
    }

    if( fFound )
    {
        BOOL                fLeftOf = FALSE;

        // Check if we need to restrict the anchor
        if( pLimit )
            IFC( pLimit->IsLeftOf( pEnd, &fLeftOf ) );
            
        // Hook it up
        IFC( SetUrl( pStart, fLeftOf ? pLimit : pEnd, pWord, pChar, TRUE, pfRepos ) );

        if( pLeft )
            IFC( pLeft->MoveToPointer( pStart ) );
    }


Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);

    ReleaseInterface( pStart );
    ReleaseInterface( pEnd );
    ReleaseInterface( pmp2 );

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::ShouldUpdateAnchorText
//
//  Synopsis:   Determine whether the passed in Href and Anchore Text are
//              autodetectable with the same autodetection pattern.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoUrlDetector::ShouldUpdateAnchorText (
        OLECHAR * pstrHref,
        OLECHAR * pstrAnchorText,
        BOOL    * pfResult )
{
    const AUTOURL_TAG * pTagHref;
    const AUTOURL_TAG * pTagText;

    if (! pfResult)
        goto Cleanup;

    *pfResult = FALSE;

    if (!pstrHref || !pstrAnchorText || !_fCanUpdateText)
        goto Cleanup;

    if ( !FindPattern( pstrAnchorText, &pTagText ) )      
        goto Cleanup;

    if ( !FindPattern( pstrHref, &pTagHref ) )       
        goto Cleanup;

    //
    // If the href and the text don't match using the same pattern, don't update
    //
    if ( pTagText != pTagHref && pTagText->uiProtocolId == pTagHref->uiProtocolId)
    {
        const TCHAR *szText = pTagText->pszPattern[AUTOURL_HREF_PREFIX];
        const TCHAR *szHref = pTagHref->pszPattern[AUTOURL_HREF_PREFIX];        

        // Chcek if the prefix is the same for both patterns
        if (StrNCmpI(szText, szHref, max(pTagText->iSignificantLength, pTagHref->iSignificantLength)))
            goto Cleanup;            

        // If the strings are the same, nothing to do
        if (!StrCmpI(pstrAnchorText, pstrHref + _tcslen(pTagHref->pszPattern[AUTOURL_TEXT_PREFIX])))
            goto Cleanup;
    }

    *pfResult = TRUE;

Cleanup:
    return S_OK;
}

//+====================================================================================
//
// Method: UserActionSinceLastDetection
//
// Synopsis: Has selection changed or the document changed since we lasted inserted
//           an anchor.
//
//------------------------------------------------------------------------------------
BOOL 
CAutoUrlDetector::UserActionSinceLastDetection()
{
    HRESULT                 hr;
    SP_IMarkupContainer     spMarkup;
    SP_IMarkupContainer2    spMarkup2;
    IMarkupPointer          *pStartEditContext;

    //
    // Check selection version
    //
    
    if (GetEditor()->GetSelectionVersion() != _dwLastSelectionVersion)
        goto Cleanup;

    //
    // Check markup containers
    //

    pStartEditContext = GetEditor()->GetSelectionManager()->GetStartEditContext();
    if (!pStartEditContext)
        goto Cleanup;

    IFC( pStartEditContext->GetContainer(&spMarkup) );

    if (!_pLastMarkup
        || spMarkup == NULL
        || !IsEqual(_pLastMarkup, spMarkup))
    {
        goto Cleanup;
    }


    //
    // Check document versions
    //

    IFC( spMarkup->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spMarkup2) );
    
    if (spMarkup2->GetVersionNumber() != _lLastContentVersion)
        goto Cleanup;

    //
    // Everything equal, so no user interaction
    //
    
    return FALSE;
    
Cleanup:
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\dxt\proctexe\src\utility.h ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       additive.cpp
//
//  Description:    Intel's additive procedural texture.
//
//  Change History:
//  1999/12/07  a-matcal    Created.
//
//------------------------------------------------------------------------------

#ifndef _UTILITY_H__
#define _UTILITY_H__

#include "defines.h"

extern DWORD gdwSmoothTable[];
extern DWORD gPerm[];




class CProceduralTextureUtility
{
public:

    CProceduralTextureUtility();

    // Utility functions.

    STDMETHOD(MyInitialize)(DWORD dwSeed, DWORD dwFunctionType, void *pInitInfo);
    STDMETHOD(SetScaling)(int nSX, int nSY, int nSTime);
    STDMETHOD(SetHarmonics)(int nHarmonics);
    STDMETHOD_(DWORD, Lerp)(DWORD dwLeft, DWORD dwRight, DWORD dwX);
    STDMETHOD_(DWORD, SmoothStep)(DWORD dwLeft, DWORD dwRight, DWORD dwX);
    STDMETHOD_(DWORD, Noise)(DWORD x, DWORD y, DWORD nTime);
    STDMETHOD_(int, Turbulence)(DWORD x, DWORD y, DWORD nTime);

private:

    DWORD       m_adwValueTable[TABSIZE];
    int         m_nScaleX;
    int         m_nScaleY;
    int         m_nScaleTime;
    int         m_nHarmonics;
    DWORD       m_dwFunctionType;

    DWORD       vlattice(int ix, int iy, int iz) 
                {
                    return m_adwValueTable[INDEX(ix, iy, iz)];
                }

    void        _ValueTableInit(int seed);
};

#endif // _UTILITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\charcmd.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       CHARCMD.CXX
//
//  Contents:   Implementation of character command classes.
//
//  History:    07-14-98 - ashrafm - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_CHARCMD_HXX_
#define _X_CHARCMD_HXX_
#include "charcmd.hxx"
#endif

#ifndef _X_RESOURCE_H_
#define _X_RESOURCE_H_
#include "resource.h"
#endif

#ifndef _X_ANCHOR_H_
#define _X_ANCHOR_H_
#include "anchor.h"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SELTRACK_HXX_
#define X_SELTRACK_HXX_
#include "seltrack.hxx"
#endif

using namespace EdUtil;

MtDefine(CCharCommand, EditCommand, "CCharCommand");
MtDefine(CTriStateCommand, EditCommand, "CTriStateCommand");
MtDefine(CFontCommand, EditCommand, "CFontCommand");
MtDefine(CForeColorCommand, EditCommand, "CForeColorCommand");
MtDefine(CBackColorCommand, EditCommand, "CBackColorCommand");
MtDefine(CFontNameCommand, EditCommand, "CFontNameCommand");
MtDefine(CFontSizeCommand, EditCommand, "CFontSizeCommand");
MtDefine(CAnchorCommand, EditCommand, "CAnchorCommand");
MtDefine(CRemoveFormatBaseCommand, EditCommand, "CRemoveFormatBaseCommand");
MtDefine(CRemoveFormatCommand, EditCommand, "CRemoveFormatCommand");
MtDefine(CUnlinkCommand, EditCommand, "CUnlinkCommand");

DefineSmartPointer(IHTMLAnchorElement);

//=========================================================================
//
// CBaseCharCommand: constructor
//
//-------------------------------------------------------------------------
CBaseCharCommand::CBaseCharCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, CHTMLEditor * pEd )
: CCommand(cmdId, pEd)
{
    _tagId = tagId;
}

//=========================================================================
//
// CBaseCharCommand: Apply
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::Apply( 
    CMshtmlEd       *pCmdTarget,
    IMarkupPointer  *pStart, 
    IMarkupPointer  *pEnd,
    VARIANT         *pvarargIn,
    BOOL            fGenerateEmptyTags)
{
    HRESULT            hr;
    SP_IMarkupPointer  spStartCopy;
    SP_IMarkupPointer  spEndCopy;

    IFC( CopyMarkupPointer(GetEditor(), pStart, &spStartCopy) );
    IFC( CopyMarkupPointer(GetEditor(), pEnd, &spEndCopy) );

    IFC( GetEditor()->PushCommandTarget(pCmdTarget) );

    IGNORE_HR( PrivateApply(spStartCopy, spEndCopy, pvarargIn, fGenerateEmptyTags) );

    IFC( GetEditor()->PopCommandTarget(WHEN_DBG(pCmdTarget)) );

Cleanup:
    RRETURN(hr);
}

//=========================================================================
//
// CBaseCharCommand: GetNormalizedTagId
//
// Synopsis: Converts any synomyms to a normal form
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::GetNormalizedTagId(IHTMLElement *pElement, ELEMENT_TAG_ID *ptagId)
{
    HRESULT hr;

    IFR( GetMarkupServices()->GetElementTagId(pElement, ptagId) );

    switch (*ptagId)
    {
        case TAGID_B:
            *ptagId = TAGID_STRONG;
            break;

        case TAGID_I:
            *ptagId = TAGID_EM;
            break;
    }

    return S_OK;    
}

//=========================================================================
//
// CBaseCharCommand: RemoveSimilarTags
//
// Synopsis: Removes all similar tags contained within
//
//-------------------------------------------------------------------------
HRESULT
CBaseCharCommand::RemoveSimilarTags(IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    HRESULT             hr;
    SP_IMarkupPointer   spCurrent;
    SP_IMarkupPointer   spLimit;
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagId;
    MARKUP_CONTEXT_TYPE context;
    INT                 iPosition;
    BOOL                fBlock, fLayout;
        
    IFC( CopyMarkupPointer(GetEditor(), pStart, &spCurrent) );
    IFC( GetEditor()->CreateMarkupPointer(&spLimit) );

    do
    {
        IFC( Move(spCurrent, RIGHT, TRUE, &context, &spElement) );

        if (spElement)
        {
            IFC( IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout, NULL) );
        
            if (!fBlock && !fLayout)
            {
                switch (context)
                {
                    case CONTEXT_TYPE_EnterScope:
                    case CONTEXT_TYPE_ExitScope:
                        IFC( GetNormalizedTagId(spElement, &tagId) );
                        if (tagId == _tagId)
                        {   
                            if (context == CONTEXT_TYPE_EnterScope)
                            {
                                IFC( spLimit->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeEnd) );
                                IFC( OldCompare( spLimit, pEnd, &iPosition) );                    
                            }
                            else
                            {
                                IFC( spLimit->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterBegin) );
                                IFC( OldCompare( pStart, spLimit, &iPosition) );
                            }

                            if (iPosition == RIGHT)
                            {
                                IFC( RemoveTag(spElement, pvarargIn) );
                            }
                        }
                }
            }
        }

        IFC( OldCompare( spCurrent, pEnd, &iPosition) );
    } 
    while (iPosition == RIGHT);

Cleanup:
    RRETURN(hr);
}

BOOL
CBaseCharCommand::IsBlockOrLayout(IHTMLElement *pElement)
{
    HRESULT hr;
    BOOL fLayout, fBlock;

    Assert(pElement);
    
    IFC(IsBlockOrLayoutOrScrollable(pElement, &fBlock, &fLayout));
    
    if (!fBlock && !fLayout)
    {
        ELEMENT_TAG_ID  tagId;

        IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
        return (tagId == TAGID_RT);
    }

Cleanup:    
    return (fBlock || fLayout);
}

//=========================================================================
//
// CBaseCharCommand: ExpandCommandSegment
//
// Synopsis: Expands the segment to contain the maximum bolded segment
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::ExpandCommandSegment(IMarkupPointer *pStart, Direction direction, VARIANT *pvarargIn)
{
    HRESULT             hr;
    SP_IMarkupPointer   spCurrent;
    SP_IHTMLElement     spElement;
    MARKUP_CONTEXT_TYPE context;
    ELEMENT_ADJACENCY   elemAdj;
    ELEMENT_TAG_ID      tagId;
    BOOL                fMustCheckEachPosition = FALSE;
    BOOL                fExitSite = FALSE;
    
    Assert(direction == LEFT || direction == RIGHT);

    // TODO: maybe we can be smarter with character influence that is not from
    // formatting tags [ashrafm]

    IFR( CopyMarkupPointer(GetEditor(), pStart, &spCurrent) );

    for (;;)
    {
        IFR( Move(spCurrent, direction, TRUE, &context, &spElement) );
        
        switch (context)
        {
            case CONTEXT_TYPE_Text:
            case CONTEXT_TYPE_NoScope:
                if (!IsCmdInFormatCache(spCurrent, pvarargIn))
                    goto Cleanup;

                break;

            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_ExitScope:
                if (context == CONTEXT_TYPE_ExitScope && spElement != NULL)
                {                    
                    // Make sure we can't expand out of an instrinsic control
                    if (IsIntrinsic(GetMarkupServices(), spElement))
                    {
                        // We just exited an instrinsic, we don't continue
                        goto Cleanup;
                    }                    
                }
                
                if (fMustCheckEachPosition)
                {                     
                    IFC( pStart->MoveToPointer(spCurrent) );
                    
                    if (!IsCmdInFormatCache(spCurrent, pvarargIn))
                        goto Cleanup;
                }
                else
                {
                    IFC(GetNormalizedTagId(spElement, &tagId));

                    if (tagId == _tagId)
                    {
                        if (context == CONTEXT_TYPE_EnterScope)
                        {
                            // Check to see if the font tags match
                            if (tagId == TAGID_FONT)
                            {
                                if (!IsCmdInFormatCache(spCurrent, pvarargIn))
                                    goto Cleanup;
                            }

                            // There is no point of terminating our new tag here, since the
                            // element we just located is under the same influence.  Extend the
                            // end of our new tag to the end of the current element.
                            elemAdj = (direction == LEFT) ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd;
                            IFC( spCurrent->MoveAdjacentToElement(spElement, elemAdj) );
                        }

                        IFC( pStart->MoveToPointer(spCurrent) );
                    }
                    else if (IsBlockOrLayout(spElement))
                    {
                        if (!IsCmdInFormatCache(spCurrent, pvarargIn))
                           goto Cleanup;

                        fMustCheckEachPosition = TRUE;
                    }
                }

                if( fExitSite == FALSE )
                {
                    IFC( pStart->MoveToPointer(spCurrent) );
                    fExitSite = TRUE;
                }

                break;
                
            case CONTEXT_TYPE_None:
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);    
}

//=========================================================================
//
// CBaseCharCommand: CreateAndInsert
//
// Synopsis: Creates and inserts the specified element
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::CreateAndInsert(ELEMENT_TAG_ID tagId, IMarkupPointer *pStart, IMarkupPointer *pEnd, IHTMLElement **ppElement)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;

    IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );
    IFR( GetEditor()->InsertElement(spElement, pStart, pEnd) );

    if (ppElement)
    {
        *ppElement = spElement;
        (*ppElement)->AddRef();
    }

    RRETURN(hr);    
}

//=========================================================================
//
// CBaseCharCommand: InsertTags
//
// Synopsis: Inserts the commands tags
//
//-------------------------------------------------------------------------

HRESULT
CBaseCharCommand::InsertTags(IMarkupPointer *pStart, IMarkupPointer *pEnd, IMarkupPointer *pLimit, VARIANT *pvarargIn, BOOL fGenerateEmptyTags)
{
    HRESULT             hr;
    SP_IMarkupPointer   spCurrentStart;
    SP_IMarkupPointer   spCurrentEnd;
    SP_IMarkupPointer   spCurrentSearch;
    INT                 iPosition;
    BOOL                bEqual;

    //
    // Optimize for springloader case
    //
    
    IFC( pStart->IsEqualTo(pEnd, &bEqual) );
    if (bEqual)
    {
        if (fGenerateEmptyTags)
            IFC( InsertTag(pStart, pStart, pvarargIn) );

        return S_OK; // done
    }

    //
    // General case
    //
    
    IFC( CopyMarkupPointer(GetEditor(), pStart, &spCurrentStart) );
    IFC( spCurrentStart->SetGravity(POINTER_GRAVITY_Right) );

    IFC( CopyMarkupPointer(GetEditor(), pStart, &spCurrentSearch) );
    IFC( spCurrentSearch->SetGravity(POINTER_GRAVITY_Left) );

    IFC( CopyMarkupPointer(GetEditor(), pStart, &spCurrentEnd) );
    IFC( spCurrentEnd->SetGravity(POINTER_GRAVITY_Left) );
    
    for (;;)
    {
        //
        // Find start of command
        //

        IFC( FindTagStart(spCurrentStart, pvarargIn, pEnd) );
        if (hr == S_FALSE)  
        {
            hr = S_OK;
            goto Cleanup; // we're done
        }
 
        //
        // Find end of command
        //

        IFC( spCurrentEnd->MoveToPointer(spCurrentStart) );
        IFC( FindTagEnd(spCurrentStart, spCurrentEnd, spCurrentSearch, pLimit) );
        
        //
        // Check for empty tags
        //

        IFC( OldCompare( spCurrentStart, spCurrentEnd, &iPosition) );

        if (iPosition != RIGHT)
        {
            if (iPosition == SAME && fGenerateEmptyTags)
            {
                IFC( InsertTag(spCurrentStart, spCurrentEnd, pvarargIn) );
            }
            continue; // done
        }

        //
        // Insert the tag
        //
        IFC( InsertTag(spCurrentStart, spCurrentEnd, pvarargIn) );
        IFC( spCurrentStart->MoveToPointer(spCurrentSearch) );
    }

Cleanup:
    RRETURN(hr);
}

//=========================================================================
//
// CBaseCharCommand: FindTagStart
//
// Synopsis: finds the start of the command
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::FindTagStart(IMarkupPointer *pCurrent, VARIANT *pvarargIn, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    CEditPointer        ep(GetEditor());
    DWORD               dwFound;
    DWORD               dwSearch;
    
    IFR( ep->MoveToPointer(pCurrent) );
    IFR( ep.SetBoundary(NULL, pEnd) );

    dwSearch =  BREAK_CONDITION_Text        |
                BREAK_CONDITION_NoScopeSite |
                BREAK_CONDITION_EnterSite   |
                BREAK_CONDITION_EnterBlock;

    for (;;)
    {
        IFR( ep.Scan(RIGHT, dwSearch, &dwFound, NULL, NULL, NULL, 
                        SCAN_OPTION_SkipControls | SCAN_OPTION_TablesNotBlocks) );

        if( ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary) ||
            ep.CheckFlag(dwFound, BREAK_CONDITION_Error) )
        {
            // Done
            return S_FALSE;
        }
        else if(    (ep.CheckFlag( dwFound, BREAK_CONDITION_EnterBlock )) || 
                    (ep.CheckFlag( dwFound, BREAK_CONDITION_EnterSite ) ) )
        {                           
            DWORD dwCond = ( ep.CheckFlag( dwFound, BREAK_CONDITION_EnterBlock ) ) ? 
                                BREAK_CONDITION_ExitBlock : BREAK_CONDITION_ExitSite;

            DWORD dwFind =  dwSearch | dwCond;
                                                              
            CEditPointer epTest(GetEditor());

            // We found a begin block, search to determine if this block is truly
            // empty
            IFR( epTest.SetBoundary(NULL, pEnd) );
            IFR( epTest->MoveToPointer(ep) );

            IFR( epTest.Scan( RIGHT, dwFind, &dwFound, NULL, NULL, NULL, 
                                SCAN_OPTION_SkipControls | SCAN_OPTION_TablesNotBlocks) );

            // If we find an exit block, we have an empty block.
            if( !epTest.CheckFlag( dwFound, BREAK_CONDITION_Boundary ) &&
                epTest.CheckFlag( dwFound, dwCond ) && 
                !IsCmdInFormatCache( ep, pvarargIn ) )
            {
                // Find the innermost phrase element, insert the new tag start there
                dwFind |= BREAK_CONDITION_ExitPhrase;

                IFR( epTest->MoveToPointer(ep) );
                IFR( epTest.Scan( RIGHT, dwFind, &dwFound, NULL, NULL, NULL, SCAN_OPTION_SkipControls ) );

                if( epTest.CheckFlag( dwFound, BREAK_CONDITION_ExitPhrase ) )
                {
                    IFR( epTest.Scan( LEFT, BREAK_CONDITION_EnterPhrase, &dwFound, NULL, NULL, NULL, 
                                        SCAN_OPTION_None ) );
                                        
                    IFR( pCurrent->MoveToPointer( epTest ) );
                }
                else
                {
                    IFR( pCurrent->MoveToPointer( ep ) );
                }

                break;
            }
        }
        // If we found text or a noscope site, then check the cache
        else if (!IsCmdInFormatCache(ep, pvarargIn))
        {
            IFR( ep.Scan(LEFT, dwSearch, &dwFound, NULL, NULL, NULL, SCAN_OPTION_SkipControls) );
            IFR( pCurrent->MoveToPointer(ep) );
            break;
        }        
    }

    return S_OK;
}
    
//=========================================================================
//
// CBaseCharCommand: FindTagEnd
//
// Synopsis: finds the end of the command
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::FindTagEnd(   IMarkupPointer *pStart, 
                                IMarkupPointer *pCurrent, 
                                IMarkupPointer *pSearch,
                                IMarkupPointer *pEnd)
{
    HRESULT             hr;                     // Result code
    SP_IHTMLElement     spElement;              // Element coming into scope on right
    SP_IMarkupPointer   spPointer;      
    SP_IMarkupPointer   spTemp;
    SP_IObjectIdentity  spIdent;
    INT                 iPosition;
    MARKUP_CONTEXT_TYPE context;
    CEditPointer        epTest(GetEditor());
    DWORD               dwFound;
    BOOL                fCommit = TRUE;         // Should we commit our changes
    SP_IMarkupPointer   spStartSave;            // Candidate start position
    SP_IMarkupPointer   spCurrentSave;          // Candidate end of tag position    

    IFR( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFR( GetEditor()->CreateMarkupPointer(&spTemp) );

    IFR( GetEditor()->CreateMarkupPointer(&spStartSave) );
    IFR( GetEditor()->CreateMarkupPointer(&spCurrentSave) );

    for(;;)
    {
        //
        // Check for termination (have we gone past the end)
        //
        
        IFR( OldCompare( pCurrent, pEnd, &iPosition) );
        if( iPosition != RIGHT )
        {
            if (iPosition == LEFT)
            {
                // Somehow we ended up to the right of our end markup.  If we skipped over
                // text, fixup the mistake
                IFR( pCurrent->Left( FALSE, &context, NULL, NULL, NULL) );
                
                if (context == CONTEXT_TYPE_Text)
                {
                    IFR( pCurrent->MoveToPointer(pEnd) );
                }
            }
            
            IFR( pSearch->MoveToPointer(pCurrent) );

            goto Cleanup;
        }
        
        //
        // Try extending the tag some more to the right
        // The search pointer is the output parameter which tells
        // the calling function where to begin the next search.  Normally,
        // this is wherever pCurrent is terminated.
        //
        IFR( Move(pCurrent, RIGHT, TRUE, &context, &spElement) );
        
        switch (context)
        {
            case CONTEXT_TYPE_EnterScope:
                if (IsBlockOrLayout(spElement))
                {
                    // We are entering a block or layout.  We must
                    // terminate the tag before the block or layout begins.
                    // In addition, we must begin searching for any new tags
                    // after the block or layout
                    IFR( pSearch->MoveToPointer( pCurrent ) );
                    IFR( Move(pCurrent, LEFT, TRUE, NULL, NULL) );

                    goto Cleanup;
                }
                else
                {
                    ELEMENT_TAG_ID tagId;

                    IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

                    if (tagId == TAGID_A)
                    {
                        // Must end on anchors
                        IFR( Move(pCurrent, LEFT, TRUE, NULL, NULL) );
                        IFR( pSearch->MoveToPointer( pCurrent ) );
                        goto Cleanup;
                    }
                }

                //
                // For font tags, try pushing the tag end back
                //

                if( CanPushFontTagBack(spElement) )
                {                   
                    BOOL fEqual;

                    IFR( spTemp->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                    IFR( GetMarkupServices()->RemoveElement(spElement) );

                    //
                    // Reinsert only if not empty
                    //

                    IFR( pEnd->IsEqualTo(spTemp, &fEqual) );
                    if (!fEqual)
                    {
                        IFR( GetEditor()->InsertElement(spElement, pEnd, spTemp) );
                        fCommit = TRUE;
                    }

                    continue;
                }

                //
                // Jump over the element and cling to any text encompassed
                // by the element
                
                IFR( spPointer->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                IFR( ClingToText(spPointer, LEFT, NULL) );

                // If we jumped past the end of our limit, we must terminate the current
                // tag before the start of the element we jumped over
                IFR( OldCompare( spPointer, pEnd, &iPosition) );
                if (iPosition == LEFT)
                {
                    // We have to end the tag
                    IFR( Move(pCurrent, LEFT, TRUE, NULL, NULL) );
                    IFR( pSearch->MoveToPointer( pCurrent ) );
                    goto Cleanup;
                }

                // 
                // Before we jump over an element, make sure that it contains no block/layout
                //

                IFR( epTest->MoveToPointer(pCurrent) );
                IFR( epTest.SetBoundary(pCurrent, spPointer) );
                IFR( epTest.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_TEXT, &dwFound, 
                                 NULL, NULL, NULL, SCAN_OPTION_SkipControls) );

                if (!epTest.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
                {
                    // Terminate the current tag
                    IFR( pCurrent->Left(TRUE, NULL, NULL, NULL, NULL) );
                    IFR( pSearch->MoveToPointer( pCurrent ) );
                    goto Cleanup;
                }

                
                // We can jump over this tag.  We haven't reached the end of our
                // limit, and the new tag doesn't contain any block or layout           
                IFR( pCurrent->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                fCommit = TRUE;
                break;
                
            case CONTEXT_TYPE_ExitScope:
                if (IsBlockOrLayout(spElement))
                {
                    // Exiting scope or layout.  We must terminate the current
                    // tag before the exit tag, and resume our search OUTSIDE
                    // of this scope / layout
                    IFR( pSearch->MoveToPointer( pCurrent ) );                   
                    IFR( Move(pCurrent, LEFT, TRUE, NULL, NULL) );
                    goto Cleanup;
                }
                else
                {
                    ELEMENT_TAG_ID tagId;

                    IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

                    if (tagId == TAGID_A)
                    {
                        // Terminate the tag before the end of the anchor
                        IFR( Move(pCurrent, LEFT, TRUE, NULL, NULL) );
                        IFR( pSearch->MoveToPointer( pCurrent ) );
                        goto Cleanup;
                    }
                }

                //
                // For font tags, try pushing the tag end back
                //
                if( CanPushFontTagBack(spElement) )
                {
                    BOOL fEqual;

                    IFR( spTemp->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
                    IFR( GetMarkupServices()->RemoveElement(spElement) );

                    //
                    // Reinsert only if not empty
                    //

                    IFR( pStart->IsEqualTo(spTemp, &fEqual) );
                    if (!fEqual)
                    {
                        IFR( GetEditor()->InsertElement(spElement, spTemp, pStart) );
                        fCommit = TRUE;

                        //
                        // Make sure we make some progress after push back.
                        // For example {pCurrent}{spTemp}</X>
                        //
                        IFR( spTemp->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeEnd) );
                        IFR( spTemp->IsEqualTo(pCurrent, &fEqual) );
                        if (fEqual)
                        {
                            IFR( pCurrent->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                        }

                    }
                    continue;
                }

                //
                // Try to extend the left of the command segment to avoid overlap
                //
                
                IFR( spPointer->MoveToPointer(pStart) );
                IFR( spPointer->Left( TRUE, &context, NULL, NULL, NULL) );
                
                if (context == CONTEXT_TYPE_ExitScope)
                {                   
                    // We have a begin TAG right before our current 'start' tag position.  Instead
                    // of creating an overlapped tag, see if it will be possible to 'encompass' the
                    // other tag with the tag we are creating.
                    
                    IFR( pCurrent->CurrentScope(&spElement) );

                    if (spElement != NULL)
                    {                   
                        // Get the type of the element at the start, and compare to the element
                        // we want to move past.  Make sure they are the same or we might 
                        // make overlapping tags
                        
                        IFR( spElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&spIdent) );
                        IFR( spPointer->CurrentScope(&spElement) );
                        
                        IFR( spIdent->IsEqualObject(spElement) );
                        if( hr == S_OK )
                        {
                            // We want to save the current position.  We are about
                            // to move the current tag around another tag set. We 
                            // may not want to commit this action if it doesn't bring
                            // about a savings in the number of tags we generate.
                            if( fCommit == TRUE )
                            {
                                IFR( spStartSave->MoveToPointer( pStart ) );
                                IFR( spCurrentSave->MoveToPointer( pCurrent ) );
                                IFR( Move( spCurrentSave, LEFT, TRUE, NULL, NULL ) );
                            }
                            
                            IFR( pStart->MoveToPointer( spPointer ) );

                            fCommit = FALSE;
                            continue;
                        }
                    }
                }

                IFR( Move(pCurrent, LEFT, TRUE, NULL, NULL) );
                IFR( pSearch->MoveToPointer( pCurrent ) );                   
                goto Cleanup;
                                   
            case CONTEXT_TYPE_NoScope:
            case CONTEXT_TYPE_Text:

                fCommit = TRUE;
                continue;
        }
    }

Cleanup:

    if( fCommit == FALSE )
    {
        IFR( pStart->MoveToPointer( spStartSave ) );
        IFR( pCurrent->MoveToPointer( spCurrentSave ) );
    }
    
    return S_OK;
}

BOOL 
CBaseCharCommand::CanPushFontTagBack(IHTMLElement *pElement)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;
    UINT            iCount;
    CVariant        var;
    
    if (_tagId != TAGID_FONT)
        goto Cleanup;

    IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    if (tagId != TAGID_FONT)
        goto Cleanup;

    IFC( GetEditor()->GetElementAttributeCount(pElement, &iCount) );
    if (iCount > 1)
        goto Cleanup;

    switch (_cmdId)
    {
        case IDM_FORECOLOR:
            IFR( pElement->getAttribute(_T("color"), 0, &var) )
            break;

        case IDM_BACKCOLOR:
            {
                SP_IHTMLStyle spStyle;

                IFR( pElement->get_style(&spStyle) );
                IFR( spStyle->getAttribute(_T("backgroundColor"), 0, &var) )
            }
            break;
            
        case IDM_FONTSIZE:
            IFR( pElement->getAttribute(_T("size"), 0, &var) )
            break;
            
        case IDM_FONTNAME:
            IFR( pElement->getAttribute(_T("face"), 0, &var) )
            break;
    }
    if (!var.IsEmpty() && !(V_VT(&var) == VT_BSTR && V_BSTR(&var) == NULL))
        return TRUE;
    

Cleanup:
    return FALSE;
}


HRESULT
CBaseCharCommand::ApplyCommandToWord(VARIANT      * pvarargIn,
                                     VARIANT      * pvarargOut,
                                     ISegmentList * pSegmentList,
                                     BOOL           fApply)
{
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    IMarkupPointer    * pmpStart = NULL;
    IMarkupPointer    * pmpEnd = NULL;
    CSegmentListIter    iter;
    BOOL                fInWord = FALSE;
    HRESULT             hr = S_FALSE;
    BOOL                fEmpty = FALSE;

    Assert(pSegmentList);

    if (pvarargOut)
        goto Cleanup;

    IFC( pSegmentList->IsEmpty( &fEmpty ) );
    if (fEmpty)
        goto Cleanup;

    IFC( iter.Init(GetEditor(), pSegmentList) );

    IFC( iter.Next(&pmpStart, &pmpEnd) );
    Assert(pmpStart && pmpEnd);

    // Check to see if we are inside a word, and if so expand markup pointers.
    hr = THR(ExpandToWord(pMarkupServices, pmpStart, pmpEnd));
    if (hr)
        goto Cleanup;

    // We now know we are inside a word.
    if (fApply)
        hr = THR(Apply(GetCommandTarget(), pmpStart, pmpEnd, pvarargIn));
    else
    {
        Assert(_tagId != TAGID_FONT);
        hr = THR(((CCharCommand *)this)->Remove(GetCommandTarget(), pmpStart, pmpEnd));
    }

    fInWord = TRUE;

Cleanup:

    if (!hr && !fInWord)
        hr = S_FALSE;

    RRETURN1(hr, S_FALSE);
}


//=========================================================================
//
// CBaseCharCommand: AdjustEndPointer
//
// Synopsis: Adjusts the segment end pointer
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::AdjustEndPointer(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT hr = S_OK;

    //
    // If word selection mode, trim off trailing space
    //

    if (!GetCommandTarget()->IsRange())
    {
        SP_ISegmentList     spSegmentList;
        SELECTION_TYPE      eSelectionType;

        IFC( GetSegmentList(&spSegmentList) );
        IFC( spSegmentList->GetType(&eSelectionType) );
        
        if (eSelectionType == SELECTION_TYPE_Text)
        {
            CSelectionManager *pSelMan = GetEditor()->GetSelectionManager();        
            
            if (pSelMan->GetActiveTracker() && pSelMan->GetSelectionType() == SELECTION_TYPE_Text)
            {
                CSelectTracker *pSelectTracker = DYNCAST(CSelectTracker, pSelMan->GetActiveTracker());

                if (pSelectTracker->IsWordSelectionMode())
                {
                    CEditPointer epEnd(GetEditor());
                    DWORD        dwBreak = BREAK_CONDITION_OMIT_PHRASE;
                    DWORD        dwFound;
                    BOOL         fEqual;

                    //
                    // Trim trailing whitespace
                    //
                    
                    IFC( epEnd->MoveToPointer(pEnd) );
                    IFC( epEnd.Scan(LEFT, dwBreak, &dwFound, NULL, NULL, NULL, 
                                    SCAN_OPTION_SkipWhitespace | SCAN_OPTION_SkipNBSP) );
                                    
                    IFC( epEnd.Scan(RIGHT, dwBreak, &dwFound) );

                    //
                    // If there is no trailing whitespace, don't adjust the selection
                    //
                    
                    IFC( epEnd.IsEqualTo(pEnd, BREAK_CONDITION_ANYTHING - dwBreak, &fEqual) );

                    if (!fEqual)
                    {
                        //
                        // Make sure we have not generated an empty segment
                        //
                        
                        IFC( epEnd.IsEqualTo(pStart, BREAK_CONDITION_ANYTHING - dwBreak, &fEqual) );

                        if (!fEqual)
                        {
                            IFC( pEnd->MoveToPointer(epEnd) );
                        }
                    }                                        
                }
            }                       
        }
    }

Cleanup:
    RRETURN(hr);
}

//=========================================================================
//
// CBaseCharCommand: PrivateApply
//
// Synopsis: Applies the command
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::PrivateApply( 
    IMarkupPointer    *pStart, 
    IMarkupPointer    *pEnd,
    VARIANT           *pvarargIn,
    BOOL              fGenerateEmptyTags)
{
    HRESULT             hr;
    BOOL                bEqual;
    SP_IHTMLElement     spElement;

    if (fGenerateEmptyTags)
    {
        IFC( pStart->IsEqualTo(pEnd, &bEqual) );

        if (bEqual)
        {
            IFC( InsertTag(pStart, pStart, pvarargIn) );

            hr = S_OK; // done
            goto Cleanup;
        }
        else
        {
            //
            // HACKHACK:
            // If there is no text in between we should simply generate an
            // empty tag here. This is workaround for #112374
            // In the future, we should consider a more intelligent way to
            // apply format to caret/empty line. 
            //
            IFC( EdUtil::EqualPointers(GetMarkupServices(), pStart, pEnd, &bEqual, TRUE) );
            if (bEqual)
            {
                IFC( InsertTag(pStart, pEnd, pvarargIn) );

                hr = S_OK; // done
                goto Cleanup;
            }
        }
    }

    //
    // Adjust the end pointer.  For example, if we're in word selection mode, we want to 
    // trim trailing whitespace.
    //
    
    IGNORE_HR( AdjustEndPointer(pStart, pEnd) );
    
    //
    // First expand to the find the maximum segment that will be under the influence of
    // this type of command.  
    //

    IFC( ExpandCommandSegment(pStart, LEFT, pvarargIn) );
    IFC( ExpandCommandSegment(pEnd, RIGHT, pvarargIn) );

    //
    // Remove all similar tags contained within the segment
    //


    IFC( RemoveSimilarTags(pStart, pEnd, pvarargIn) );
    
    //
    // Insert tags in current segment
    //

    IFC( InsertTags(pStart, pEnd, pEnd, pvarargIn, fGenerateEmptyTags) );


Cleanup:    
    RRETURN(hr);
}
                          

//=========================================================================
//
// CCharCommand: constructor
//
//-------------------------------------------------------------------------
CCharCommand::CCharCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, CHTMLEditor * pEd )
: CBaseCharCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//=========================================================================
//
// CCharCommand: PrivateExec
//
//-------------------------------------------------------------------------

HRESULT
CCharCommand::PrivateExec( 
        DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    HRESULT             hr;
    OLECMD              cmd;
    SP_ISegmentList     spSegmentList;
    CSegmentListIter    iter;
    IMarkupPointer      *pStart;
    IMarkupPointer      *pEnd;
    CSpringLoader       *psl = GetSpringLoader();
    CEdUndoHelper       undoUnit(GetEditor());
    BOOL                fEmptyTags;                 // Do we generate empty tags?
    BOOL                fEmpty = FALSE;
    
    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );

    if( fEmpty ) /// nothing to do
    {
        hr = S_OK;
        goto Cleanup;
    }


    IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
                           
    IFC( PrivateQueryStatus(&cmd, NULL ));
    if (cmd.cmdf == MSOCMDSTATE_DISABLED)
        return E_FAIL;

    // Give the current word a chance to intercept the command.
    hr = THR(ApplyCommandToWord(pvarargIn, pvarargOut, spSegmentList, cmd.cmdf == MSOCMDSTATE_UP));
    if (hr != S_FALSE)
        goto Cleanup;

    // Give the spring loader a chance to intercept the command.
    hr = THR(psl->PrivateExec(_cmdId, pvarargIn, pvarargOut, spSegmentList));
    if (hr != S_FALSE)
        goto Cleanup;

    // We don't allow empty hyperlinks.  For all other formatting commands,
    // we allow empty tags to be inserted.  This allows empty blocks to 
    // have tags inserted correctly.
    fEmptyTags = (_cmdId == IDM_HYPERLINK) ? FALSE : TRUE;
    
    hr = S_OK;
    
    IFC( iter.Init(GetEditor(), spSegmentList) );

    for (;;)
    {
        IFC( iter.Next(&pStart, &pEnd) );

        if (hr == S_FALSE)
        {
            hr = S_OK; // proper termination
            break;
        }

        if (cmd.cmdf == MSOCMDSTATE_UP)
            IFC( PrivateApply(pStart, pEnd, NULL, fEmptyTags) )
        else
            IFC( PrivateRemove(pStart, pEnd) );
    }
    

Cleanup:

    RRETURN(hr);
}

//=========================================================================
// CCharCommand: PrivateQueryStatus
//
//  Synopsis: Returns the format data for the first character in the segment
//            list.  NOTE: this is the same behavior as Word97 and IE401.
//
//-------------------------------------------------------------------------
HRESULT
CCharCommand::PrivateQueryStatus( 
                    OLECMD * pCmd,
                    OLECMDTEXT * pcmdtext )

{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    SP_ISegmentList     spSegmentList;
    CSpringLoader       *psl = GetSpringLoader();
    SELECTION_TYPE      eSelectionType;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup ;
    }
#endif

    IFC( GetSegmentList( &spSegmentList ));

    // Give the spring loader a chance to intercept the query.
    hr = THR(psl->PrivateQueryStatus(_cmdId, pCmd));
    if (hr != S_FALSE)
        goto Cleanup;

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE)
        goto Cleanup;
        
    //
    // Retrieve the first segment's pointers.  We have at least
    // one segment because CommonQuerySTatus was successful.
    //
    IFC( GetFirstSegmentPointers(spSegmentList, &spStart, &spEnd) );

    IFC( spSegmentList->GetType(&eSelectionType) );

    if (eSelectionType == SELECTION_TYPE_Text ||
        GetCommandTarget()->IsRange() )
    {
        DWORD           dwFound;
        CEditPointer    ep( GetEditor() );

        IFC( ep.MoveToPointer( spStart ) );

        // We don't want to break if we enter or exit an anchor. (bug 89089)
        IFC( ep.Scan( RIGHT, BREAK_CONDITION_OMIT_PHRASE & ~BREAK_CONDITION_Anchor, &dwFound ) );

        if( !ep.CheckFlag( dwFound, BREAK_CONDITION_TEXT) )
        {
            SP_IDisplayPointer spDispPointer;
            
            // $TODO - For now, we just hard code the fNotAtBol parameter to FALSE,
            // In the future, this needs to use a display pointer to get the BOLness

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
            IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            IFC( spDispPointer->MoveToMarkupPointer(spStart, NULL) )

            IFC( GetEditor()->AdjustPointerForInsert( spDispPointer, TRUE, NULL, NULL ) );
            IFC( spDispPointer->PositionMarkupPointer(spStart) );
        }
        else
        {
            IFC( spStart->MoveToPointer( ep ) );
        }
    }

    if (IsCmdInFormatCache(spStart, NULL))
        pCmd->cmdf = MSOCMDSTATE_DOWN;
    else
        pCmd->cmdf = MSOCMDSTATE_UP;

Cleanup:
    RRETURN(hr);
}

//=========================================================================
//
// CCharCommand: Remove
//
//-------------------------------------------------------------------------
HRESULT 
CCharCommand::Remove( 
    CMshtmlEd       *pCmdTarget,
    IMarkupPointer  *pStart, 
    IMarkupPointer  *pEnd)
{
    HRESULT             hr, hrResult;
    SP_IMarkupPointer   spStartCopy;
    SP_IMarkupPointer   spEndCopy;

    IFC( CopyMarkupPointer(GetEditor(), pStart, &spStartCopy) );
    IFC( spStartCopy->SetGravity(POINTER_GRAVITY_Right) );

    IFC( CopyMarkupPointer(GetEditor(), pEnd, &spEndCopy) );     
    IFC( spEndCopy->SetGravity(POINTER_GRAVITY_Left) );

    IFC( GetEditor()->PushCommandTarget(pCmdTarget) );

    hrResult = THR( PrivateRemove(spStartCopy, spEndCopy) );
    
    IFC( GetEditor()->PopCommandTarget(WHEN_DBG(pCmdTarget)) );

    hr = hrResult;

Cleanup:
    RRETURN(hr);
}


//=========================================================================
//
// CBaseCharCommand: PrivateRemove
//
// Synopsis: Removes the command
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::PrivateRemove( 
    IMarkupPointer    *pStart, 
    IMarkupPointer    *pEnd,
    VARIANT           *pvarargIn)
{
    HRESULT             hr;
    SP_IMarkupPointer   spStartCopy;
    SP_IMarkupPointer   spEndCopy;
    BOOL                bEqual;

    IFR( CopyMarkupPointer(GetEditor(), pStart, &spStartCopy) );
    IFR( CopyMarkupPointer(GetEditor(), pEnd, &spEndCopy) );
    
    //
    // First expand to the find the maximum segment that will be under the influence of
    // this type of command.  
    //
    
    IFR( ExpandCommandSegment(spStartCopy, LEFT, pvarargIn) );
    IFR( ExpandCommandSegment(spEndCopy, RIGHT, pvarargIn) );

    //
    // Remove all similar tags contained within the segment
    //

    IFR( RemoveSimilarTags(spStartCopy, spEndCopy, pvarargIn) );

    //
    // Next, re-insert segments outside selection   
    //

    IFR(pStart->IsEqualTo(spStartCopy, &bEqual) );
    if (!bEqual)
        IFR( PrivateApply(spStartCopy, pStart, pvarargIn, FALSE) );
 
    IFR(pEnd->IsEqualTo(spEndCopy, &bEqual) );
    if (!bEqual)
        IFR( PrivateApply(pEnd, spEndCopy, pvarargIn, FALSE) );
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:       AreAttributesEqual
//
//  Synopsis:     Returns true if attributes of both tags are equal
//
//----------------------------------------------------------------------------
BOOL 
CCharCommand::AreAttributesEqual(IHTMLElement *pElementLeft, IHTMLElement *pElementRight)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagIdLeft, tagIdRight;

    // TODO: check attributes as well
    IFC( GetMarkupServices()->GetElementTagId(pElementLeft, &tagIdLeft) );
    IFC( GetMarkupServices()->GetElementTagId(pElementRight, &tagIdRight) );

    return (tagIdLeft == tagIdRight && tagIdLeft != TAGID_FONT);
    
Cleanup:
    return FALSE;
}

//=========================================================================
//
// CBaseCharCommand: TryTagMerge
//
//-------------------------------------------------------------------------

HRESULT 
CBaseCharCommand::TryTagMerge(
    IMarkupPointer *pCurrent)
{
    HRESULT                 hr;
    SP_IHTMLElement         spElementLeft;
    SP_IHTMLElement         spElementRight;
    MARKUP_CONTEXT_TYPE     context;
    ELEMENT_TAG_ID          tagId;
    
    IFR( pCurrent->Right( FALSE, &context, &spElementRight, NULL, NULL) );
    if (context == CONTEXT_TYPE_EnterScope)
    {
        IFR( pCurrent->Left( FALSE, &context, &spElementLeft, NULL, NULL ) );
        if (context == CONTEXT_TYPE_EnterScope) 
        {
            // TODO: check attributes as well. [ashrafm]            
            
            if (AreAttributesEqual(spElementLeft, spElementRight))
            {
                SP_IMarkupPointer spStart, spEnd;

                // Merge tags
    
                IFR( GetEditor()->CreateMarkupPointer(&spStart) );
                IFR( GetEditor()->CreateMarkupPointer(&spEnd) );

                IFR( spStart->MoveAdjacentToElement(spElementLeft, ELEM_ADJ_BeforeBegin) );
                IFR( spEnd->MoveAdjacentToElement(spElementRight, ELEM_ADJ_AfterEnd) );

                // TODO: this call needs to change when font tag merging is added
                IFR( GetMarkupServices()->GetElementTagId(spElementLeft, &tagId) );
                IFR( CreateAndInsert(tagId, spStart, spEnd, NULL) );

                IFR( GetMarkupServices()->RemoveElement(spElementLeft) );
                IFR( GetMarkupServices()->RemoveElement(spElementRight) );
            }
        }
        
    }
    

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:       IsCmdInFormatChache
//
//  Synopsis:     Returns S_OK if the command is in the format cache
//                data.  Otherwise, S_FALSE is returned.
//
//----------------------------------------------------------------------------

BOOL
CCharCommand::IsCmdInFormatCache(IMarkupPointer  *pMarkupPointer,
                                 VARIANT         *pvarargIn)
{
    HRESULT               hr;
    VARIANT_BOOL          bResult = VB_FALSE;
    SP_IHTMLComputedStyle spComputedStyle;

    IFC(GetDisplayServices()->GetComputedStyle(pMarkupPointer, &spComputedStyle));

    switch (_cmdId)
    {
        case IDM_BOLD:
        case IDM_TRISTATEBOLD:
            IFC(spComputedStyle->get_bold(&bResult));
            break;

        case IDM_ITALIC:
        case IDM_TRISTATEITALIC:
            IFC(spComputedStyle->get_italic(&bResult));
            break;

        case IDM_UNDERLINE:
        case IDM_TRISTATEUNDERLINE:
            IFC(spComputedStyle->get_underline(&bResult));
            break;

        case IDM_STRIKETHROUGH:
            IFC(spComputedStyle->get_strikeOut(&bResult));
            break;

        case IDM_SUBSCRIPT:
            IFC(spComputedStyle->get_subScript(&bResult));
            break;

        case IDM_SUPERSCRIPT:
            IFC(spComputedStyle->get_superScript(&bResult));
            break;

        default:
            Assert(0); // unsupported cmdId
    }

Cleanup:
    return !!bResult;
}

//+---------------------------------------------------------------------------
//
//  CCharCommand: ConvertFormatDataToVariant
//
//----------------------------------------------------------------------------
HRESULT 
CCharCommand::ConvertFormatDataToVariant(
    IHTMLComputedStyle      *pComputedStyle,
    VARIANT                 *pvarargOut )
{
    AssertSz(0, "CCharCommand::ConvertFormatDataToVariant not implemented");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  CCharCommand: IsFormatDataEqual
//
//----------------------------------------------------------------------------

BOOL
CCharCommand::IsFormatDataEqual(IHTMLComputedStyle *, IHTMLComputedStyle *)
{
    AssertSz(0, "CCharCommand::IsFormatDataEqual not implemented");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  CCharCommand: IsVariantEqual
//
//----------------------------------------------------------------------------
BOOL 
CCharCommand::IsVariantEqual(VARIANT *pvarA, VARIANT *pvarB)
{
    AssertSz(0, "CCharCommand::IsVariantEqual not implemented");
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  CCharCommand: InsertTag
//
//----------------------------------------------------------------------------
HRESULT 
CCharCommand::InsertTag(IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    RRETURN( CreateAndInsert(_tagId, pStart, pEnd, NULL) );
}

//+---------------------------------------------------------------------------
//
//  CCharCommand: RemoveTag
//
//----------------------------------------------------------------------------

HRESULT 
CCharCommand::RemoveTag(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT           hr;
    SP_IMarkupPointer spLeft, spRight;

    // TODO: check if it has attributes and convert to span if it does not

    IFR( GetEditor()->CreateMarkupPointer(&spLeft) );
    IFR( GetEditor()->CreateMarkupPointer(&spRight) );

    IFR( spLeft->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin) );
    IFR( spRight->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );

    IFR( GetMarkupServices()->RemoveElement(pElement) );

    IFR( TryTagMerge(spLeft) );
    IFR( TryTagMerge(spRight) );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CCharCommand: InsertTag
//
//----------------------------------------------------------------------------
HRESULT 
CCharCommand::InsertStyleAttribute(IHTMLElement *pElement)
{
    HRESULT         hr;
    SP_IHTMLStyle   spStyle;

    IFR( pElement->get_style(&spStyle) );
    switch (_cmdId)
    {
        case IDM_BOLD:
        case IDM_TRISTATEBOLD:
            IFR( spStyle->put_fontWeight(_T("bold")) );
            break;
            
        case IDM_ITALIC:
        case IDM_TRISTATEITALIC:
            VARIANT var;

            V_VT(&var) = VT_BSTR;
            V_BSTR(&var) = _T("italic");
            
            IFR( spStyle->setAttribute(_T("fontStyle"), var, 0) );
            break;

        case IDM_UNDERLINE:
        case IDM_TRISTATEUNDERLINE:
            IFR( spStyle->put_textDecorationUnderline(VB_TRUE) );
            break;
    }

    return S_OK;
}

HRESULT 
CCharCommand::RemoveStyleAttribute(IHTMLElement *pElement)
{
    HRESULT         hr;
    SP_IHTMLStyle   spStyle;

    IFR( pElement->get_style(&spStyle) );
    switch (_cmdId)
    {
        case IDM_BOLD:
        case IDM_TRISTATEBOLD:
            IFR( spStyle->put_fontWeight(_T("normal")) );
            break;
            
        case IDM_ITALIC:
        case IDM_TRISTATEITALIC:
            IFR( spStyle->removeAttribute(_T("fontStyle"), 0, NULL) );
            break;

        case IDM_UNDERLINE:
        case IDM_TRISTATEUNDERLINE:
            IFR( spStyle->put_textDecorationUnderline(VB_FALSE) );
            break;
    }

    return S_OK;
}

//=========================================================================
//
// CTriStateCommand: constructor
//
//=========================================================================
CTriStateCommand::CTriStateCommand ( DWORD cmdId, ELEMENT_TAG_ID tagId, CHTMLEditor *pEd )
: CCharCommand(cmdId, tagId, pEd)
{
    // do nothing
}

//=========================================================================
//
// CTriStateCommand: PrivateExec
//
//-------------------------------------------------------------------------

HRESULT
CTriStateCommand::PrivateExec( 
        DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    HRESULT             hr;
    OLECMD              cmd;
    SP_ISegmentList     spSegmentList;
    CSegmentListIter    iter;
    IMarkupPointer      *pStart;
    IMarkupPointer      *pEnd;
    CSpringLoader       *psl = GetSpringLoader();
    CEdUndoHelper       undoUnit(GetEditor());
    BOOL                fEmpty = FALSE;
    
    IFR( GetSegmentList(&spSegmentList) );
    IFR( spSegmentList->IsEmpty( &fEmpty ) );

    if( fEmpty ) /// nothing to do
    {
        hr = S_OK;
        goto Cleanup;
    }

    IFR( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
                           
    IFR( CCharCommand::PrivateQueryStatus(&cmd, NULL ));
    if (cmd.cmdf == MSOCMDSTATE_DISABLED)
        return E_FAIL;

    // Give the current word a chance to intercept the command.
    hr = THR(ApplyCommandToWord(pvarargIn, pvarargOut, spSegmentList, cmd.cmdf == MSOCMDSTATE_UP));
    if (hr != S_FALSE)
        goto Cleanup;

    // Give the spring loader a chance to intercept the command.
    hr = THR(psl->PrivateExec(_cmdId, pvarargIn, pvarargOut, spSegmentList));
    if (hr != S_FALSE)
        goto Cleanup;

    hr = S_OK;
    
    IFC( iter.Init(GetEditor(), spSegmentList) );

    for (;;)
    {
        IFC( iter.Next(&pStart, &pEnd) );

        if (hr == S_FALSE)
        {
            hr = S_OK; // proper termination
            break;
        }

        if (cmd.cmdf == MSOCMDSTATE_UP)
            IFC( PrivateApply(pStart, pEnd, NULL, TRUE) )
        else
            IFC( PrivateRemove(pStart, pEnd) );
    }
    
Cleanup:

    RRETURN(hr);
}

//=========================================================================
// CTriStateCommand: PrivateQueryStatus
//
//  Synopsis: Similar to CCharCommand::PrivateQueryStatus, but 
//  searches the markup to check for tristatedness. 
//  NOTE: This is the same behavior as Word 2000.
//
//-------------------------------------------------------------------------
HRESULT
CTriStateCommand::PrivateQueryStatus( 
        OLECMD     * pCmd,
        OLECMDTEXT * pcmdtext )

{
    HRESULT                 hr = S_OK;
    IMarkupPointer          *pStart;
    IMarkupPointer          *pEnd;
    SP_ISegmentList         spSegmentList;
    CSegmentListIter        iter;
    CSpringLoader           *psl = GetSpringLoader();
    DWORD                   dwFound;
    CEditPointer            ep( GetEditor() );
    SELECTION_TYPE          eSelectionType;
    BOOL                    fInitialState;
    BOOL                    fCurrentState;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif

    IFC( GetSegmentList( &spSegmentList ));

    // Give the spring loader a chance to intercept the query.
    hr = THR(psl->PrivateQueryStatus(_cmdId, pCmd));
    if (hr != S_FALSE)
        goto Cleanup;

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE)
        goto Cleanup;

    IFC( iter.Init(GetEditor(), spSegmentList) );
    IFC( iter.Next(&pStart, &pEnd) ); // We should have at least one segment, since CommonQueryStatus was successful

    IFC( ep.MoveToPointer( pStart ) );
    IFC( ep.SetBoundaryForDirection(RIGHT, pEnd) );

    IFR( spSegmentList->GetType(&eSelectionType) );

    if (eSelectionType == SELECTION_TYPE_Text ||
        GetCommandTarget()->IsRange() )
    {
        IFC( ep.Scan( RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound ) );

        if( !ep.CheckFlag( dwFound, BREAK_CONDITION_TEXT) )
        {
            SP_IDisplayPointer spDispPointer;
        
            // $TODO - For now, we just hard code the fNotAtBol parameter to FALSE,
            // In the future, this needs to use a display pointer to get the BOLness

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
            IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            IFC( spDispPointer->MoveToMarkupPointer(pStart, NULL) )

            IFC( GetEditor()->AdjustPointerForInsert( spDispPointer, TRUE, NULL, NULL ) );
            IFC( spDispPointer->PositionMarkupPointer(pStart) );
        }
        else
        {
            IFC( pStart->MoveToPointer( ep ) );
        }
    }

    //
    // Now check to see if there are different formats exist 
    // inside the first segment
    //
    fInitialState = IsCmdInFormatCache(pStart, NULL);
    do 
    {
        IFC( ep.Scan(RIGHT, BREAK_CONDITION_Text, &dwFound) );
        if (ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
            break;
            
        fCurrentState = IsCmdInFormatCache(ep, NULL);
        if (fCurrentState != fInitialState)
        {
            pCmd->cmdf = MSOCMDSTATE_NINCHED;
            goto Cleanup;
        }
        
    } while (TRUE);
    
    if (fInitialState)
        pCmd->cmdf = MSOCMDSTATE_DOWN;
    else
        pCmd->cmdf = MSOCMDSTATE_UP;

Cleanup:
    RRETURN(hr);
}

//=========================================================================
//
// CFontCommand: constructor
//
//-------------------------------------------------------------------------
CFontCommand::CFontCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, CHTMLEditor *pEd )
: CBaseCharCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//+---------------------------------------------------------------------------
//
//  Method:       IsCmdInFormatChache
//
//  Synopsis:     Returns S_OK if the command is in the format cache
//                data.  Otherwise, S_FALSE is returned.
//
//----------------------------------------------------------------------------

BOOL 
CFontCommand::IsCmdInFormatCache(IMarkupPointer  *pCurrent,
                                 VARIANT         *pvarargIn)
{
    HRESULT                 hr;
    SP_IHTMLComputedStyle   spComputedStyle;
    BOOL                    bResult = FALSE;
    VARIANT                 var;

    VariantInit(&var);

    IFC( GetDisplayServices()->GetComputedStyle(pCurrent, &spComputedStyle) );
    IFC( ConvertFormatDataToVariant(spComputedStyle, &var) );

    bResult = IsVariantEqual(&var, pvarargIn);
    VariantClear(&var);

Cleanup:
    return bResult;
}

//=========================================================================
// CFontCommand: GetCommandRange
//
// Synopsis: Get the range of the font command (usually for dropdowns)
//
//-------------------------------------------------------------------------
HRESULT 
CFontCommand::GetCommandRange(VARIANTARG *pvarargOut)
{
    HRESULT hr = S_OK;

    Assert(pvarargOut && V_VT(pvarargOut) == VT_ARRAY);

    switch (_cmdId)
    {
    case IDM_FONTSIZE:
    {
        // IDM_FONTSIZE command is from form toolbar (font size combobox)
        // * V_VT(pvarargIn)  = VT_I4/VT_BSTR   : set font size
        // * V_VT(pvarargOut) = VT_I4           : request current font size setting
        // * V_VT(pvarargOut) = VT_ARRAY        : request all possible font sizes

        SAFEARRAYBOUND sabound;
        SAFEARRAY * psa;
        long l, lZoom;

        sabound.cElements = FONTMAX - FONTMIN + 1;
        sabound.lLbound = 0;
        psa = SafeArrayCreate(VT_I4, 1, &sabound);

        for (l = 0, hr = S_OK, lZoom = FONTMIN;
             l < (FONTMAX - FONTMIN + 1) && SUCCEEDED(hr);
             l++, lZoom++)
        {
            hr = THR_NOTRACE(SafeArrayPutElement(psa, &l, &lZoom));
        }

        V_ARRAY(pvarargOut) = psa;
    }
        break;

    default:
        Assert(!"CFontCommand::Exec VT_ARRAY-out mode only supported for IDM_FONTSIZE");
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}


//=========================================================================
// CFontCommand: GetFirstSegmentFontValue
//
// Synopsis: Returns the font value for the first segment in a segment list
//
//-------------------------------------------------------------------------
HRESULT
CFontCommand::GetFirstSegmentFontValue(
    ISegmentList    *pSegmentList,
    VARIANT         *pvarargOut
    )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_IHTMLComputedStyle   spComputedStyle;
    SP_IHTMLComputedStyle   spComputedStyle2;
    SELECTION_TYPE          eSelType;
    BOOL                    fEmpty = FALSE;
    MARKUP_CONTEXT_TYPE     context;
    INT                     iPosition;
    BOOL                    fEqual;
    
    Assert(pSegmentList);
    Assert(pvarargOut);

    if (pvarargOut)
    {
        V_VT(pvarargOut)    = VT_NULL;
        V_BSTR(pvarargOut)  = NULL;
    }

    IFC( pSegmentList->GetType(&eSelType) );
    IFC( pSegmentList->IsEmpty(&fEmpty) );
    if (fEmpty) 
    {
        return S_OK;
    }

    //
    // Get Initial FontValue
    //
    IFC( GetFirstSegmentPointers(pSegmentList, &spStart, &spEnd) );
    
    //
    // HACKHACK: we often get an empty selection when the user clicks, so check for this
    // case and assume we have a caret
    //
    if (eSelType == SELECTION_TYPE_Text)
    {
        IFC( spStart->IsEqualTo(spEnd, &fEqual) );
        if (fEqual)
        {
            eSelType = SELECTION_TYPE_Caret;
        }
    }

    //
    // Get the computed style
    //

    if (SELECTION_TYPE_Text == eSelType || GetCommandTarget()->IsRange() )
    {
        CEditPointer epStart(GetEditor());
        CEditPointer ep(GetEditor());
        DWORD        dwFound;

        IFC( epStart->MoveToPointer(spStart) );
        IFC( ClingToText(epStart, RIGHT, NULL) );

        //
        // If we're not adjacent to text, check if we're at EOP.  In this case, 
        // formatting is taken from the text to the left.       
        //

        IFC( ep->MoveToPointer(epStart) );
        IFC( ep.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );

        if (!ep.CheckFlag(dwFound, BREAK_CONDITION_Block))
        {
            IFC( spStart->MoveToPointer(epStart) );
        }

    }
    IFC( GetDisplayServices()->GetComputedStyle(spStart, &spComputedStyle) );

    //
    // Check to see if there are inconsistent FontValues
    //
    if (eSelType == SELECTION_TYPE_Text ||
        GetCommandTarget()->IsRange() )
    {
        IFC( ClingToText(spStart, RIGHT, NULL, FALSE, TRUE) );
        IFC( ClingToText(spEnd, LEFT, NULL, FALSE, TRUE) );
    }
    
    do 
    {
        IFC( OldCompare(spStart, spEnd, &iPosition) );
        if (RIGHT != iPosition) 
            break;
        

        IFC( Move(spStart, RIGHT, TRUE, &context, NULL) );
        if (CONTEXT_TYPE_Text == context)
        {
            IFC( GetDisplayServices()->GetComputedStyle(spStart, &spComputedStyle2) );
            if (!IsFormatDataEqual(spComputedStyle, spComputedStyle2))
            {
                V_VT(pvarargOut)    = VT_NULL;
                V_BSTR(pvarargOut)  = NULL;
                goto Cleanup;
            }
            
        }
    } while (TRUE);
    
    IFC( ConvertFormatDataToVariant(spComputedStyle, pvarargOut) );
    
Cleanup:
    RRETURN(hr);
}





//=========================================================================
// CFontCommand: PrivateExec
//
// Synopsis: Exec for font commands
//
//-------------------------------------------------------------------------

HRESULT
CFontCommand::PrivateExec( 
        DWORD             nCmdexecopt,
    VARIANTARG *      pvarargIn,
    VARIANTARG *      pvarargOut )
{
    HRESULT             hr;
    IMarkupPointer      *pStart = NULL;
    IMarkupPointer      *pEnd = NULL;
    CSegmentListIter    iter;
    SP_IMarkupPointer   spSegmentLimit;
    CSpringLoader       * psl = GetSpringLoader();
    SP_ISegmentList     spSegmentList;
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spPointer;
    CEdUndoHelper       undoUnit(GetEditor());
    BOOL                fEmpty = FALSE;
    SP_IHTMLComputedStyle spComputedStyle;
    
    // Handle VT_ARRAY range requests first.
    if (pvarargOut && V_VT(pvarargOut) == VT_ARRAY)
    {
        hr = THR(GetCommandRange(pvarargOut));
        if (!hr)
        {
            // Out part successfully handled.
            pvarargOut = NULL;

            // Done?
            if (!pvarargIn)
                goto Cleanup;
        }
    }

    IFC( CommonPrivateExec(nCmdexecopt, pvarargIn, pvarargOut) );
    if (hr != S_FALSE)
        RRETURN(hr);

    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->IsEmpty(&fEmpty) );

    if (fEmpty) /// nothing to do
    {
        hr = S_OK;
        if (pvarargOut)
        {
            VariantInit(pvarargOut);
            
            if (SUCCEEDED(GetActiveElemSegment(GetMarkupServices(), &spPointer, NULL)))
            {
                if (SUCCEEDED(GetDisplayServices()->GetComputedStyle(spPointer, &spComputedStyle)))
                {
                    IGNORE_HR(ConvertFormatDataToVariant(spComputedStyle, pvarargOut));
                }
            }
        }

        goto Cleanup;
    }

    if (pvarargIn)
    {
        IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );

        // Give the current word a chance to intercept the command.
        hr = THR(ApplyCommandToWord(pvarargIn, pvarargOut, spSegmentList, TRUE));
        if (hr != S_FALSE)
            goto Cleanup;
    }

    // Give the spring loader a chance to intercept the command.
    hr = THR(psl->PrivateExec(_cmdId, pvarargIn, pvarargOut, spSegmentList));
    if (hr != S_FALSE)
        goto Cleanup;
        
    hr = S_OK;
    
    if (pvarargIn)
    {
        // Set the font property
        IFC( iter.Init(GetEditor(), spSegmentList) );

        for (;;)
        {
            IFC( iter.Next(&pStart, &pEnd) );
            if (hr ==  S_FALSE)
                break;

            //
            // For site selected controls that are color commands, apply the attribute directly.
            //
            if (_cmdId == IDM_FORECOLOR )
            {
                SELECTION_TYPE      eSelectionType;
                MARKUP_CONTEXT_TYPE context;
                
                IFC( spSegmentList->GetType(&eSelectionType) );

                if (eSelectionType == SELECTION_TYPE_Control)
                {                
                    IFC( pStart->Right( FALSE, & context, & spElement, NULL, NULL ));
                    Assert( (context == CONTEXT_TYPE_EnterScope) || (context == CONTEXT_TYPE_NoScope));
                    IFC( DYNCAST( CForeColorCommand, this )->InsertTagAttribute(spElement, pvarargIn));
                }
                else
                {
                    IFC( PrivateApply(pStart, pEnd, pvarargIn, TRUE) );
                }
            }
            else
            {
                IFC( PrivateApply(pStart, pEnd, pvarargIn, TRUE) );
            }
        }
        hr = S_OK;
    }

    // Get the font property
    if (pvarargOut)
    {
        IFC( GetFirstSegmentFontValue(spSegmentList, pvarargOut) );
    }

Cleanup:        
    RRETURN(hr);
}
//=========================================================================
//
// CFontCommand: PrivateQueryStatus
//
//-------------------------------------------------------------------------

HRESULT
CFontCommand::PrivateQueryStatus( 
        OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )

{
    HRESULT             hr = S_OK;
    CSpringLoader       *psl = GetSpringLoader();
    SP_ISegmentList     spSegmentList;
    CVariant            var;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }

#endif

    if (!GetEditor()->GetCssEditingLevel() && _cmdId == IDM_BACKCOLOR)
    {
        // We can't do background color without css editing level of 1

        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;        
    }

    //
    // This is where the spring loader gets to intercept a command.
    //

    IFC( GetSegmentList(&spSegmentList) );
    
    IFC( psl->PrivateQueryStatus(_cmdId, pCmd) );
    if (hr != S_FALSE)
        goto Cleanup;

    //
    // Return the character format
    //

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE)
        goto Cleanup;
    

    IFC( GetFirstSegmentFontValue(spSegmentList, &var) );
    if (var.IsEmpty())
        pCmd->cmdf = MSOCMDSTATE_NINCHED;
    else
        pCmd->cmdf = MSOCMDSTATE_UP;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  CFontCommand: InsertTag
//
//----------------------------------------------------------------------------
HRESULT CFontCommand::InsertTag(IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    HRESULT         hr;
    SP_IHTMLElement spElement;

    IFR( FindReuseableTag(pStart, pEnd, &spElement) );
    if (!spElement)
    {
        IFR( GetMarkupServices()->CreateElement(_tagId, NULL, &spElement) );            
        IFR( InsertTagAttribute(spElement, pvarargIn) );
        IFR( GetEditor()->InsertElement(spElement, pStart, pEnd) );
    }
    else
    {
        IFR( InsertTagAttribute(spElement, pvarargIn) );
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CFontCommand: FindReuseableTag
//
//----------------------------------------------------------------------------
HRESULT 
CFontCommand::FindReuseableTag(IMarkupPointer *pStart, IMarkupPointer *pEnd, IHTMLElement **ppElement)
{
    HRESULT             hr;
    SP_IMarkupPointer   spStart, spEnd, spTemp;
    SP_IHTMLElement     spScope, spParentScope;
    MARKUP_CONTEXT_TYPE context;
    BOOL                bEqual;
    ELEMENT_TAG_ID      tagId;

    *ppElement = NULL;

    IFR( GetEditor()->CreateMarkupPointer(&spStart) );
    IFR( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFR( GetEditor()->CreateMarkupPointer(&spTemp) );
    
    IFR( spStart->MoveToPointer(pStart) );
    IFR( ClingToText(spStart, RIGHT, pEnd) );    
    IFR( spEnd->MoveToPointer(pEnd) );
    IFR( ClingToText(spEnd, LEFT, pStart) );    
    
    IFR( spStart->CurrentScope(&spScope) );

    while (spScope != NULL)
    {
        IFR( spTemp->MoveAdjacentToElement(spScope, ELEM_ADJ_AfterBegin) );
        IFR( spStart->IsEqualTo(spTemp, &bEqual) );
        if (!bEqual)
            return S_OK;
        
        IFR( spTemp->MoveAdjacentToElement(spScope, ELEM_ADJ_BeforeEnd) );
        IFR( spEnd->IsEqualTo(spTemp, &bEqual) );
        if (!bEqual)
            return S_OK;

        IFR( GetMarkupServices()->GetElementTagId(spScope, &tagId) );
        if (tagId == TAGID_FONT)
        {
            *ppElement = spScope;
            (*ppElement)->AddRef();
            return S_OK;
        }
        
        IFR( Move(spStart, LEFT, TRUE, &context, NULL) );
        if (context != CONTEXT_TYPE_ExitScope)
            return S_OK;
            
        IFR( Move(spEnd, RIGHT, TRUE, &context, NULL) );
        if (context != CONTEXT_TYPE_ExitScope)
            return S_OK;

        IFR( GetEditor()->GetParentElement( spScope, &spParentScope) );
        spScope = spParentScope;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CFontCommand: RemoveTag
//
//----------------------------------------------------------------------------
HRESULT CFontCommand::RemoveTag(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT             hr;
    SP_IMarkupPointer   spLeft, spRight;
    CVariant            var;
    UINT                iCount;

    if (!pvarargIn)
        return S_OK;

    switch (_cmdId)
    {
        case IDM_FORECOLOR:
            IFR( pElement->removeAttribute(_T("color"), 0, NULL) )
            break;

        case IDM_BACKCOLOR:
            {
                SP_IHTMLStyle spStyle;

                IFR( pElement->get_style(&spStyle) );
                IFR( spStyle->removeAttribute(_T("backgroundColor"), 0, NULL) )
            }
            break;
            
        case IDM_FONTSIZE:
            IFR( pElement->removeAttribute(_T("size"), 0, NULL) )
            break;
            
        case IDM_FONTNAME:
            IFR( pElement->removeAttribute(_T("face"), 0, NULL) )
            break;
    }

    IFR( GetEditor()->GetElementAttributeCount(pElement, &iCount) );
    if (iCount > 0)
        return S_OK; 

    // TODO: check if it has attributes and convert to span if it does not

    //
    // Remove the tag
    //

    IFR( GetEditor()->CreateMarkupPointer(&spLeft) );
        IFR( GetEditor()->CreateMarkupPointer(&spRight) );

    IFR( spLeft->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin) );
    IFR( spRight->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );

    IFR( GetMarkupServices()->RemoveElement(pElement) );

    IFR( TryTagMerge(spLeft) );
    IFR( TryTagMerge(spRight) );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CFontCommand: IsValidOnControl
//
//----------------------------------------------------------------------------
BOOL 
CFontCommand::IsValidOnControl()
{
    HRESULT                 hr;
    SP_ISegmentList         spSegmentList;
    SP_IHTMLElement         spElement;
    ELEMENT_TAG_ID          tagId;
    BOOL                    fValid = FALSE;
    BOOL                    fEmpty = FALSE;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;

    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->IsEmpty(&fEmpty) );
    if (fEmpty)
        goto Cleanup;

    IFC( spSegmentList->CreateIterator( &spIter ) );

    while( spIter->IsDone() == S_FALSE )
    {
        IFC( spIter->Current( &spSegment ) );
        IFC( GetSegmentElement(spSegment, &spElement ) );
        IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

        fValid = (tagId == TAGID_HR && _cmdId == IDM_FORECOLOR);
        if ( ! fValid )
            goto Cleanup;

        ClearInterface( & spElement );

        IFC( spIter->Advance() );
    }
    
Cleanup:    
    return fValid;
}
    

//=========================================================================
//
// CFontNameCommand: constructor
//
//-------------------------------------------------------------------------
CFontNameCommand::CFontNameCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, 
CHTMLEditor * pEd )
: CFontCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//=========================================================================
// CFontNameCommand: ConvertFormatDataToVariant
//
// Synopsis: returns a variant from the given format data
//-------------------------------------------------------------------------

HRESULT
CFontNameCommand::ConvertFormatDataToVariant(
    IHTMLComputedStyle *pComputedStyle,
    VARIANT            *pvar)
{
    HRESULT hr;
    TCHAR   szFont[LF_FACESIZE+1];

    IFC( pComputedStyle->get_fontName((TCHAR *)&szFont) );

    V_VT(pvar) = VT_BSTR;
    V_BSTR(pvar) = SysAllocString(szFont);
    if (V_BSTR(pvar) == NULL)
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN(hr);
}

//=========================================================================
// CFontNameCommand: IsFormatDataEqual
//
// Synopsis: Compares format data based on command type
//-------------------------------------------------------------------------

BOOL
CFontNameCommand::IsFormatDataEqual(IHTMLComputedStyle *pComputedStyleA, IHTMLComputedStyle *pComputedStyleB)
{
    HRESULT hr;
    TCHAR   szFontA[LF_FACESIZE+1];
    TCHAR   szFontB[LF_FACESIZE+1];

    IFC( pComputedStyleA->get_fontName((TCHAR *)&szFontA) );
    IFC( pComputedStyleB->get_fontName((TCHAR *)&szFontB) );
    
    return (StrCmp(szFontA, szFontB) == 0);

Cleanup:
    return FALSE;
}

//=========================================================================
// CFontNameCommand: IsVariantEqual
//
// Synopsis: Compares variants based on command type
//-------------------------------------------------------------------------

BOOL
CFontNameCommand::IsVariantEqual(VARIANT *pvarA, VARIANT *pvarB)
{
    return VariantCompareFontName(pvarA, pvarB);
}

//=========================================================================
// CFontNameCommand: InsertTagAttribute
//
// Synopsis: Inserts the font tag attribute
//-------------------------------------------------------------------------

HRESULT 
CFontNameCommand::InsertTagAttribute(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT hr = S_OK;

    // Set the property
    if (pvarargIn)
        hr = THR(pElement->setAttribute(_T("FACE"), *pvarargIn, 0));

    RRETURN(hr);
}

//=========================================================================
//
// CFontSizeCommand: constructor
//
//-------------------------------------------------------------------------
CFontSizeCommand::CFontSizeCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, 
CHTMLEditor * pEd )
: CFontCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//=========================================================================
// CFontSizeCommand: ConvertFormatDataToVariant
//
// Synopsis: returns a variant from the given format data
//-------------------------------------------------------------------------

HRESULT
CFontSizeCommand::ConvertFormatDataToVariant(
    IHTMLComputedStyle *pComputedStyle,
    VARIANT            *pvar)
{
    HRESULT hr;    
    LONG    lTwips;
    int     htmlSize;

    IFC( pComputedStyle->get_fontSize(&lTwips) );
    htmlSize = EdUtil::ConvertTwipsToHtmlSize(lTwips);

    if (EdUtil::ConvertHtmlSizeToTwips(htmlSize) == lTwips)
    {
        V_VT(pvar) = VT_I4;
        V_I4(pvar) = htmlSize;
    }
    else
        V_VT(pvar) = VT_NULL;

Cleanup:
    RRETURN(hr);
}

//=========================================================================
// CFontSizeCommand::IsFormatDataEqual
//
// Synopsis: Compares format data based on command type
//-------------------------------------------------------------------------

BOOL
CFontSizeCommand::IsFormatDataEqual(IHTMLComputedStyle *pComputedStyleA, IHTMLComputedStyle *pComputedStyleB)
{
    HRESULT hr;
    LONG    lFontSizeA, lFontSizeB;

    IFC( pComputedStyleA->get_fontSize(&lFontSizeA) );
    IFC( pComputedStyleB->get_fontSize(&lFontSizeB) );
    
    return (lFontSizeA == lFontSizeB);

Cleanup:
    return FALSE;
}

//=========================================================================
// CFontSizeCommand: IsVariantEqual
//
// Synopsis: Compares variants based on command type
//-------------------------------------------------------------------------

BOOL
CFontSizeCommand::IsVariantEqual(VARIANT *pvarA, VARIANT *pvarB)
{
    return VariantCompareFontSize(pvarA, pvarB);
}

//=========================================================================
// CFontSizeCommand: InsertTagAttribute
//
// Synopsis: Inserts the font tag attribute
//-------------------------------------------------------------------------

#define FONT_INDEX_SHIFT 3  // Font sizes on the toolbar are from -2 to 4, internally they are 1 to 7

HRESULT 
CFontSizeCommand::InsertTagAttribute(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT         hr = S_OK;
    CVariant        var;
 
    if (V_VT(pvarargIn) == VT_EMPTY)
    {
        // remove all attributes
        IFC( pElement->setAttribute(_T("SIZE"), *pvarargIn, 0) );
    }
    else
    {
        long offset = 0;

        Assert(pvarargIn);
        if (((CVariant *)pvarargIn)->IsEmpty())
            goto Cleanup;

        if (V_VT(pvarargIn) == VT_BSTR)
        {
            BSTR bstrIn = V_BSTR(pvarargIn);
            if (!bstrIn)
                goto Cleanup;

            if (*bstrIn == _T('+') || *bstrIn == _T('-'))
            {
                offset = FONT_INDEX_SHIFT;
            }
        }

        IFC(VariantChangeTypeSpecial(&var, pvarargIn, VT_I4));

        V_VT(&var) = VT_I4;
        V_I4(&var) += offset;

        if (V_I4(&var) < 1)
            V_I4(&var) = 1;
        else if (V_I4(&var) > 7)
            V_I4(&var) = 7;

        // use attribute on the element
        hr = THR(pElement->setAttribute(_T("SIZE"), var, 0));
    }

Cleanup:
    RRETURN(hr);
}

//=========================================================================
//
// CBackColorCommand: constructor
//
//-------------------------------------------------------------------------
CBackColorCommand::CBackColorCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, 
CHTMLEditor * pEd )
: CFontCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//=========================================================================
// CBackColorCommand: ConvertFormatDataToVariant
//
// Synopsis: returns a variant from the given format data
//-------------------------------------------------------------------------

HRESULT
CBackColorCommand::ConvertFormatDataToVariant(
    IHTMLComputedStyle *pComputedStyle,
    VARIANT            *pvar)
{
    HRESULT     hr;
    DWORD       dwBackColor;
    
    IFC( pComputedStyle->get_backgroundColor(&dwBackColor) );
    
    V_VT(pvar) = VT_I4;
    V_I4(pvar) = dwBackColor;

    IFC( ConvertRGBToOLEColor(pvar) );

Cleanup:
    RRETURN(hr);    
}

//=========================================================================
// CBackColorCommand: IsFormatDataEqual
//
// Synopsis: Compares format data based on command type
//-------------------------------------------------------------------------

BOOL
CBackColorCommand::IsFormatDataEqual(IHTMLComputedStyle *pComputedStyleA, IHTMLComputedStyle *pComputedStyleB)
{
    HRESULT      hr;
    VARIANT_BOOL fHasBgColorA, fHasBgColorB;
    BOOL         bResult;

    IFC( pComputedStyleA->get_hasBgColor(&fHasBgColorA) );
    IFC( pComputedStyleB->get_hasBgColor(&fHasBgColorB) );
    
    if (!fHasBgColorA)
    {
        bResult = !fHasBgColorB;
    }
    else
    {
        DWORD dwBackColorA, dwBackColorB;
        
        IFC( pComputedStyleA->get_backgroundColor(&dwBackColorA) );
        IFC( pComputedStyleB->get_backgroundColor(&dwBackColorB) );

        bResult = (dwBackColorA == dwBackColorB);
    }

    return bResult;

Cleanup:
    return FALSE;
}

//=========================================================================
// CBackColorCommand: IsVariantEqual
//
// Synopsis: Compares variants based on command type
//-------------------------------------------------------------------------

BOOL
CBackColorCommand::IsVariantEqual(VARIANT *pvarA, VARIANT *pvarB)
{
    return VariantCompareColor(pvarA, pvarB);
}

//=========================================================================
// CBackColorCommand: InsertTagAttribute
//
// Synopsis: Inserts the font tag attribute
//-------------------------------------------------------------------------

HRESULT 
CBackColorCommand::InsertTagAttribute(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT             hr;
    VARIANT             var;
    SP_IHTMLStyle       spStyle;

    IFC( pElement->get_style(&spStyle) );

    VariantInit(&var);
    if (V_VT(pvarargIn) != VT_EMPTY)
    {
        IFC( VariantCopy(&var, pvarargIn) );
        IFC( ConvertOLEColorToRGB(&var) );
        IFC( spStyle->put_backgroundColor(var) );
    }
    else
    {
        IFC( spStyle->removeAttribute(_T("backgroundColor"), 0, NULL) );
    }

Cleanup:
    VariantClear(&var);
    RRETURN(hr);
}

//=========================================================================
//
// CForeColorCommand: constructor
//
//-------------------------------------------------------------------------
CForeColorCommand::CForeColorCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, 
CHTMLEditor * pEd )
: CFontCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//=========================================================================
// CForeColorCommand: ConvertFormatDataToVariant
//
// Synopsis: returns a variant from the given format data
//-------------------------------------------------------------------------

HRESULT
CForeColorCommand::ConvertFormatDataToVariant(
    IHTMLComputedStyle *pComputedStyle,
    VARIANT            *pvar)
{
    HRESULT hr;
    DWORD   dwColor;

    IFC( pComputedStyle->get_textColor(&dwColor) );

    V_VT(pvar) = VT_I4;
    V_I4(pvar) = dwColor;

    IFC( ConvertRGBToOLEColor(pvar) );

Cleanup:
    RRETURN(hr);
}

//=========================================================================
// CForeColorCommand: IsFormatDataEqual
//
// Synopsis: Compares format data based on command type
//-------------------------------------------------------------------------

BOOL
CForeColorCommand::IsFormatDataEqual(IHTMLComputedStyle *pComputedStyleA, IHTMLComputedStyle *pComputedStyleB)
{   
    HRESULT hr;
    DWORD   dwColorA, dwColorB;
    
    IFC( pComputedStyleA->get_textColor(&dwColorA) );
    IFC( pComputedStyleB->get_textColor(&dwColorB) );
    
    return (dwColorA == dwColorB);

Cleanup:
    return FALSE;
}


//=========================================================================
// CForeColorCommand: IsVariantEqual
//
// Synopsis: Compares variants based on command type
//-------------------------------------------------------------------------

BOOL
CForeColorCommand::IsVariantEqual(VARIANT *pvarA, VARIANT *pvarB)
{
    return VariantCompareColor(pvarA, pvarB);
}

//=========================================================================
// CForeColorCommand: InsertTagAttribute
//
// Synopsis: Inserts the font tag attribute
//-------------------------------------------------------------------------

HRESULT 
CForeColorCommand::InsertTagAttribute(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT             hr;
    VARIANT             var;

    VariantInit(&var);
    if (V_VT(pvarargIn) != VT_EMPTY)
    {
        IFC( VariantCopy(&var, pvarargIn) );
        IFC( ConvertOLEColorToRGB(&var) );
    }

    // use attribute on the element
    IFC( pElement->setAttribute(_T("COLOR"), var, 0) );

Cleanup:
    VariantClear(&var);
    RRETURN(hr);
}


//=========================================================================
//
// CAnchorCommand: constructor
//
//-------------------------------------------------------------------------
CAnchorCommand::CAnchorCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, 
CHTMLEditor * pEd )
: CBaseCharCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//+---------------------------------------------------------------------------
//
//  CAnchorCommand: ConvertFormatDataToVariant
//
//----------------------------------------------------------------------------
HRESULT 
CAnchorCommand::ConvertFormatDataToVariant(
    IHTMLComputedStyle      *pComputedStyle,
    VARIANT                 *pvarargOut )
{
    AssertSz(0, "CCharCommand::ConvertFormatDataToVariant not implemented");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  CAnchorCommand: IsVariantEqual
//
//----------------------------------------------------------------------------
BOOL 
CAnchorCommand::IsVariantEqual(VARIANT *pvarA, VARIANT *pvarB)
{
    AssertSz(0, "CCharCommand::IsVariantEqual not implemented");
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  CAnchorCommand: IsVariantEqual
//
//----------------------------------------------------------------------------
BOOL
CAnchorCommand::IsFormatDataEqual(IHTMLComputedStyle *, IHTMLComputedStyle *)
{
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  CAnchorCommand: RemoveTag
//
//----------------------------------------------------------------------------
HRESULT
CAnchorCommand::RemoveTag(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    RRETURN(GetMarkupServices()->RemoveElement(pElement));
}

//+---------------------------------------------------------------------------
//
//  CAnchorCommand: RemoveTag
//
//----------------------------------------------------------------------------
HRESULT 
CAnchorCommand::InsertTag(IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    HRESULT                 hr;
    SP_IHTMLElement         spElement;
    SP_IHTMLAnchorElement   spAnchor;
    
    if (!pvarargIn || V_VT(pvarargIn) != VT_BSTR)
        return E_INVALIDARG;

    switch (_cmdId)
    {
        case IDM_BOOKMARK:
            IFR( InsertNamedAnchor(V_BSTR(pvarargIn), pStart, pEnd) ); 
            break;

        case IDM_HYPERLINK:
            IFR( CreateAndInsert(_tagId, pStart, pEnd, &spElement) );
            IFR( spElement->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&spAnchor) );
            IFR( spAnchor->put_href(V_BSTR(pvarargIn)) );
            break;

        default:
            AssertSz(0, "Unsupported anchor command");
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:       CAnchorCommand::IsCmdInFormatCache
//
//----------------------------------------------------------------------------
BOOL
CAnchorCommand::IsCmdInFormatCache(IMarkupPointer  *pMarkupPointer,
                                 VARIANT         *pvarargIn)
{
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:       CAnchorCommand::InsertNamedAnchor
//
//----------------------------------------------------------------------------
HRESULT
CAnchorCommand::InsertNamedAnchor(BSTR bstrName, IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    CStr                strAttr;
    SP_IHTMLElement     spElement;

    //
    // HACKHACK: If we try to set the name of an element in browse mode, the OM ignores the
    // request and sets the submit name instead.  So, we need to create another element with
    // the name set.
    //

    // Build the attribute string
    if (bstrName)
    {
        IFR( strAttr.Set(_T("name=\"")) );
        IFR( strAttr.Append(bstrName) );
        IFR( strAttr.Append(_T("\"")) );
    }

    // Insert the new anchor
    IFR( GetMarkupServices()->CreateElement(TAGID_A, strAttr, &spElement) );
    IFR( GetMarkupServices()->InsertElement(spElement, pStart, pEnd) );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:       CAnchorCommand::UpdateContainedAnchors
//
//----------------------------------------------------------------------------
HRESULT 
CAnchorCommand::UpdateContainedAnchors(IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    HRESULT                 hr;
    CEditPointer            epTest(GetEditor());
    DWORD                   dwSearch = BREAK_CONDITION_EnterAnchor;
    DWORD                   dwFound;
    BOOL                    fFoundAnchor = FALSE;
    MARKUP_CONTEXT_TYPE     context;
    SP_IHTMLElement         spElement;

    //
    // Scan for anchors and change attributes to pvarargIn
    //

    IFR( epTest->MoveToPointer(pStart) );
    IFR( epTest.SetBoundary(NULL, pEnd) );

    for (;;)
    {
        IFR( epTest.Scan(RIGHT, dwSearch, &dwFound) );
        if (epTest.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
            break;

        Assert(epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterAnchor));

        //
        // Update anchor
        //
        IFR( epTest->Left(FALSE, &context, &spElement, NULL, NULL) );

        Assert(context == CONTEXT_TYPE_ExitScope);
        if (context == CONTEXT_TYPE_ExitScope && spElement != NULL)
        {
            IFR( UpdateAnchor(spElement, pvarargIn) );            
            fFoundAnchor = TRUE;
        }
            
    }

    return (fFoundAnchor ? S_OK : S_FALSE);
}

HRESULT
CAnchorCommand::UpdateAnchor(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT                 hr;
    SP_IHTMLAnchorElement   spAnchor;

    if (!pvarargIn || V_VT(pvarargIn) != VT_BSTR)
        return E_INVALIDARG;
    
    switch (_cmdId)
    {
        case IDM_BOOKMARK:
            {
                SP_IMarkupPointer spLeft, spRight;

                IFR( GetEditor()->CreateMarkupPointer(&spLeft) )
                IFR( spLeft->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin) );
                
                IFR( GetEditor()->CreateMarkupPointer(&spRight) );
                IFR( spRight->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );
                
                IFR( InsertNamedAnchor(V_BSTR(pvarargIn), spLeft, spRight) );

                IFR( GetMarkupServices()->RemoveElement(pElement) );
            }
            break;

        case IDM_HYPERLINK:
            IFR( pElement->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&spAnchor) );
            IFR( spAnchor->put_href(V_BSTR(pvarargIn)) );
            break;

        default:
            AssertSz(0, "Unsupported anchor command");
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:       CAnchorCommand::PrivateExec
//
//----------------------------------------------------------------------------
HRESULT
CAnchorCommand::PrivateExec( 
        DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_IHTMLElement         spElement;
    CTagBitField            tagBitField;
    SP_ISegmentList         spSegmentList;
    BOOL                    fEqual;
    SELECTION_TYPE          eSelectionType;
    CEdUndoHelper           undoUnit(GetEditor());
        
    IFR( CommonPrivateExec(nCmdexecopt, pvarargIn, pvarargOut) );
    if (hr != S_FALSE)
        RRETURN(hr);

    // Make sure the edit context isn't a button
    if (!GetCommandTarget()->IsRange() && GetEditor())
    {
        CSelectionManager *pSelMan;

        pSelMan = GetEditor()->GetSelectionManager();
        if (pSelMan && pSelMan->IsEditContextSet() && pSelMan->GetEditableElement())
        {
            ELEMENT_TAG_ID tagId;

            IFC( GetMarkupServices()->GetElementTagId(pSelMan->GetEditableElement(), &tagId) );
            if (tagId == TAGID_BUTTON)
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }
    }

    IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
                            
    IFC( GetSegmentList( &spSegmentList ));
    IFC( GetFirstSegmentPointers(spSegmentList, &spStart, &spEnd) );

    if (pvarargIn == NULL || V_VT(pvarargIn) != VT_BSTR)
        return E_INVALIDARG;

    IFC( spSegmentList->GetType( &eSelectionType ) );
        
    tagBitField.Set(TAGID_A);
    if (IsCmdAbove(GetMarkupServices(), spStart, spEnd, &spElement, NULL, &tagBitField))
    {
        IFC( UpdateAnchor(spElement, pvarargIn) );

        if (eSelectionType != SELECTION_TYPE_Caret)
        {
            IGNORE_HR( UpdateContainedAnchors(spStart, spEnd, pvarargIn) );
        }
    }
    else
    {
        if (eSelectionType == SELECTION_TYPE_Caret)
            return E_FAIL;

        // First try to update any anchors contained in the selection.  If there are no anchors,
        // we create one below
        IFC( UpdateContainedAnchors(spStart, spEnd, pvarargIn) );
        if (hr != S_FALSE)
            goto Cleanup;

        // Create the anchor
        IFC( spStart->IsEqualTo(spEnd, &fEqual) );        

        if (fEqual)
        {
            CSpringLoader * psl = GetSpringLoader();

            IGNORE_HR(psl->SpringLoadComposeSettings(spStart));
            IGNORE_HR(psl->Fire(spStart, spEnd));
        }

        IFC( PrivateApply(spStart, spEnd, pvarargIn, fEqual) );
    }
        
Cleanup:
   RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:       CAnchorCommand::PrivateQueryStatus
//
//----------------------------------------------------------------------------
HRESULT 
CAnchorCommand::PrivateQueryStatus( 
    OLECMD *pCmd,
    OLECMDTEXT * pcmdtext )
{
    HRESULT             hr = S_OK;
    SP_ISegmentList     spSegmentList;
    SP_IMarkupPointer   spStart, spEnd;
    CTagBitField        tagBitField;
    SELECTION_TYPE      eSelectionType;
    ELEMENT_TAG_ID      tagId;
    CSelectionManager   *pSelMan;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE)
        goto Cleanup;

    // Make sure the edit context isn't a button
    if (GetEditor())
    {
        pSelMan = GetEditor()->GetSelectionManager();
        if (pSelMan && pSelMan->IsEditContextSet() && pSelMan->GetEditableElement())
        {
            IFC( GetMarkupServices()->GetElementTagId(pSelMan->GetEditableElement(), &tagId) );
            if (tagId == TAGID_BUTTON)
            {
                pCmd->cmdf = MSOCMDSTATE_DISABLED;                
                hr = S_OK;
                goto Cleanup;
            }
        }
    }

    // Check if we are under an anchor
    pCmd->cmdf = MSOCMDSTATE_UP; // up by default

    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->GetType( &eSelectionType) );
    if (eSelectionType == SELECTION_TYPE_Caret)
    {
        IFC( GetFirstSegmentPointers(spSegmentList, &spStart, &spEnd) );
            
        tagBitField.Set(TAGID_A);
        if (!IsCmdAbove(GetMarkupServices(), spStart, spEnd, NULL, NULL, &tagBitField))
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;    
        }
    }

    hr = S_OK;
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:       CRemoveFormatBaseCommand::CRemoveFormatBaseCommand
//
//----------------------------------------------------------------------------
CRemoveFormatBaseCommand::CRemoveFormatBaseCommand(DWORD cmdId, CHTMLEditor *
ped)
: CCommand(cmdId, ped)
{
}

//+---------------------------------------------------------------------------
//
//  Method:       CRemoveFormatBaseCommand::Exec
//
//----------------------------------------------------------------------------
HRESULT 
CRemoveFormatBaseCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT             hr = S_OK;
    IMarkupPointer      *pStart = NULL;
    IMarkupPointer      *pEnd = NULL;
    SP_ISegmentList     spSegmentList;
    CSegmentListIter    iter;
    CSpringLoader       *psl = GetSpringLoader();
    CEdUndoHelper       undoUnit(GetEditor());
    int                 iSegmentCount;

    IFC( CommonPrivateExec(nCmdexecopt, pvarargIn, pvarargOut) );
    if (hr != S_FALSE)
        RRETURN(hr);

    IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
    
    IFC( GetSegmentList(&spSegmentList) );
    IFC( GetSegmentCount( spSegmentList, &iSegmentCount ) );
    IFC( iter.Init(GetEditor(), spSegmentList) );

    for (;;)
    {
        IFC( iter.Next(&pStart, &pEnd) );

        if (hr == S_FALSE)
        {
            hr = S_OK; // proper termination
            break;
        }

        if (iSegmentCount == 1 && _cmdId == IDM_REMOVEFORMAT)
            IGNORE_HR(ExpandToWord(GetMarkupServices(), pStart, pEnd));

        IFC( Apply(pStart, pEnd) );

        // Apply compose font.
        if (psl && _cmdId == IDM_REMOVEFORMAT)
        {
            IFC( psl->SpringLoadComposeSettings(NULL, TRUE) );
            IFC( psl->Fire(pStart, pEnd) );
        }
    }

Cleanup:

    RRETURN(hr);
}


HRESULT
CRemoveFormatBaseCommand::Apply(
    IMarkupPointer  *pStart,
    IMarkupPointer  *pEnd,
    BOOL            fQueryMode)
{
    HRESULT             hr = S_OK;
    MARKUP_CONTEXT_TYPE context;
    INT                 iPosition;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spNewElement;
    SP_IMarkupPointer   spCurrent;
    ELEMENT_TAG_ID      tagId;
            
    //
    // Walk pStart/pEnd out so we can avoid overlapping tags
    //

    // TODO: can make this faster but be careful about pointer placement [ashrafm]
    for(;;)
    {
        IFR( pStart->Left(FALSE, &context, NULL, NULL, NULL) );
        if (context != CONTEXT_TYPE_ExitScope)
            break;
        IFR( pStart->Left(TRUE, NULL, NULL, NULL, NULL) );
    }

    for(;;)
    {
        IFR( pEnd->Right(FALSE, &context, NULL, NULL, NULL) );
        if (context != CONTEXT_TYPE_ExitScope)
            break;
        IFR( pEnd->Right(TRUE, NULL, NULL, NULL, NULL) );
    }

    //
    // Set gravity
    //
    IFR( pStart->SetGravity(POINTER_GRAVITY_Right) );
    IFR( pEnd->SetGravity(POINTER_GRAVITY_Left) );

    //
    // Walk from left to right removing any tags we see
    //

    IFR( GetEditor()->CreateMarkupPointer(&spCurrent) );
    IFR( spCurrent->MoveToPointer(pStart) );
    for (;;)
    {
        // Move right
        IFR( spCurrent->Right( TRUE, &context, &spElement, NULL, NULL) );        
        IFR( OldCompare( spCurrent, pEnd, &iPosition) );
        if (iPosition != RIGHT)
            break;

        // Check tagId
        if (context == CONTEXT_TYPE_EnterScope)
        {
            IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
            if (_tagsRemove.Test(tagId))
            {
                if (fQueryMode)
                    return S_OK; // found tag
                    
                IFR( RemoveElement(spElement, pStart, pEnd) );
            }
        }        
    }

    //
    // Walk up remove tags we see
    //

    IFR( pStart->CurrentScope(&spElement) );
    for (;;)
    {
        IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
        if (_tagsRemove.Test(tagId))
        {
            if (fQueryMode)
                return S_OK; // found tag

            // Move up the tree
            IFR( GetEditor()->GetParentElement( spElement, &spNewElement) );
        
            // Remove the element
            IFR( RemoveElement(spElement, pStart, pEnd) );
        }
        else
        {
            // Move up the tree
            IFR( GetEditor()->GetParentElement( spElement, &spNewElement) );
        
        }

        if (!spNewElement)
            break;            
        spElement = spNewElement;
    }

    if (fQueryMode)
        hr = S_FALSE; // not found
        
    RRETURN1(hr, S_FALSE);
}
    

//+---------------------------------------------------------------------------
//
//  CRemoveFormatCommand Class
//
//----------------------------------------------------------------------------

CRemoveFormatCommand::CRemoveFormatCommand(DWORD cmdId, CHTMLEditor *ped)
: CRemoveFormatBaseCommand(cmdId, ped)
{
    _tagsRemove.Set(TAGID_FONT);
    _tagsRemove.Set(TAGID_B);
    _tagsRemove.Set(TAGID_U);
    _tagsRemove.Set(TAGID_I);
    _tagsRemove.Set(TAGID_STRONG);
    _tagsRemove.Set(TAGID_EM);
    _tagsRemove.Set(TAGID_SUB);
    _tagsRemove.Set(TAGID_SUP);
    _tagsRemove.Set(TAGID_STRIKE);
    _tagsRemove.Set(TAGID_S);
    _tagsRemove.Set(TAGID_ACRONYM);
    _tagsRemove.Set(TAGID_BDO);    
    _tagsRemove.Set(TAGID_BIG);
    _tagsRemove.Set(TAGID_BLINK);
    _tagsRemove.Set(TAGID_CITE);
    _tagsRemove.Set(TAGID_SAMP);
    _tagsRemove.Set(TAGID_SMALL);
    _tagsRemove.Set(TAGID_CITE);
    _tagsRemove.Set(TAGID_TT);
    _tagsRemove.Set(TAGID_VAR);
    _tagsRemove.Set(TAGID_Q);
    _tagsRemove.Set(TAGID_NOBR);
    _tagsRemove.Set(TAGID_KBD);
    _tagsRemove.Set(TAGID_INS);
    _tagsRemove.Set(TAGID_DFN);
    _tagsRemove.Set(TAGID_CODE);
}

HRESULT 
CRemoveFormatCommand::PrivateQueryStatus( 
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    HRESULT         hr = S_OK ;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE) 
        goto Cleanup;

    pCmd->cmdf = MSOCMDSTATE_UP;

    hr = S_OK;
Cleanup:
    
    return hr;
}

HRESULT
CRemoveFormatCommand::RemoveElement(IHTMLElement *pElement, IMarkupPointer  *
pStart, IMarkupPointer  *pEnd)
{
    HRESULT         hr;
    elemInfluence   theInfluence;
    BOOL            fBlock, fLayout;

    //
    // Don't remove layout or block
    //
    IFC( IsBlockOrLayoutOrScrollable(pElement, &fBlock, &fLayout, NULL) );

    if (!fBlock && !fLayout)
    {
        // Check influence and split        
        theInfluence = GetElementInfluenceOverPointers(GetMarkupServices(), pStart, pEnd, pElement);
        hr = THR( SplitInfluenceElement(GetMarkupServices(), pStart, pEnd, pElement, theInfluence, NULL) ); 
    }

Cleanup:
    RRETURN(hr);
}   

//+---------------------------------------------------------------------------
//
//  CUnlinkCommand Class
//
//----------------------------------------------------------------------------

CUnlinkCommand::CUnlinkCommand(DWORD cmdId, CHTMLEditor *ped)
: CRemoveFormatBaseCommand(cmdId, ped)
{
    _tagsRemove.Set(TAGID_A);
}

HRESULT
CUnlinkCommand::RemoveElement(IHTMLElement *pElement, IMarkupPointer  *pStart
, IMarkupPointer  *pEnd)
{
    RRETURN( GetMarkupServices()->RemoveElement(pElement) );
}

HRESULT 
CUnlinkCommand::PrivateQueryStatus( 
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    HRESULT                 hr = S_OK;
    SP_ISegmentList         spSegmentList;
    CSegmentListIter        iter;
    IMarkupPointer          *pStart;
    IMarkupPointer          *pEnd;
    
#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE) 
        goto Cleanup;
             
    IFC( GetSegmentList(&spSegmentList) );

    IFC( iter.Init(GetEditor(), spSegmentList) );
    pCmd->cmdf = MSOCMDSTATE_DISABLED;
    for (;;)
    {
        IFC( iter.Next(&pStart, &pEnd) );
        if (hr ==  S_FALSE)
            break; // end of list
   
        IFC(Apply(pStart, pEnd, TRUE)); // query mode
        if (hr == S_OK)
        {
            pCmd->cmdf = MSOCMDSTATE_UP; // found link
            goto Cleanup;
        }
    }
    hr = S_OK;

Cleanup:
    RRETURN(hr);
}

BOOL 
CUnlinkCommand::IsValidOnControl()
{
    HRESULT         hr;
    BOOL            bResult = FALSE;
    SP_ISegmentList spSegmentList;
    INT             iSegmentCount;

    IFC( GetSegmentList(&spSegmentList) );
    IFC( GetSegmentCount(spSegmentList, &iSegmentCount ) );

    bResult = (iSegmentCount == 1);

Cleanup:
    return bResult;
}

BOOL
CAnchorCommand::IsCmdAbove(   IMarkupServices *pMarkupServices ,
                                IMarkupPointer* pStart,
                                IMarkupPointer* pEnd,
                                IHTMLElement**  ppFirstMatchElement,
                                elemInfluence * pInfluence ,
                                CTagBitField *  inSynonyms )
{
    BOOL match = FALSE;
    IHTMLElement *pCurrentElement = NULL ;
    IHTMLElement *pNextElement = NULL ;
    HRESULT hr = S_OK;
    ELEMENT_TAG_ID currentTag = TAGID_NULL ;

    Assert ( pStart && pEnd );

    //
    // First look to the left of the Start pointer - to see if that "leads up to" the tag
    //
    hr = pStart->CurrentScope( & pCurrentElement );
    if (  hr ) goto CleanUp;
    Assert( pCurrentElement );
     
    while ( ! match && pCurrentElement )
    {
        hr = pMarkupServices->GetElementTagId( pCurrentElement, &currentTag);
        if ( hr ) goto CleanUp;

        match = inSynonyms->Test( (USHORT) currentTag );
        if ( match ) break;

        GetEditor()->GetParentElement( pCurrentElement, & pNextElement );
        ReplaceInterface( &pCurrentElement, pNextElement );
        ClearInterface( & pNextElement );
    }

    if (match )
    {
        if( ppFirstMatchElement )
            *ppFirstMatchElement = pCurrentElement;
        if ( pInfluence )
            *pInfluence = GetElementInfluenceOverPointers( pMarkupServices, pStart, pEnd, pCurrentElement );
    }

CleanUp:

    if ( ( ! ppFirstMatchElement )  || ( ! match ) )
        ReleaseInterface( pCurrentElement );

    return match;
}


BOOL 
CAnchorCommand::IsValidOnControl()
{
    HRESULT                 hr;
    BOOL                    bResult = FALSE;
    SP_ISegmentList         spSegmentList;
    INT                     iSegmentCount;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    
    IFC( GetSegmentList(&spSegmentList) );
#if DBG==1
    SELECTION_TYPE  eSelectionType;
    IFC( spSegmentList->GetType(&eSelectionType) );
    Assert(eSelectionType == SELECTION_TYPE_Control);
#endif

    IFC( GetSegmentCount( spSegmentList, &iSegmentCount ) );    

    bResult = (iSegmentCount == 1);

    if (bResult && _cmdId == IDM_HYPERLINK)
    {
        SP_IHTMLElement spElement;
        ELEMENT_TAG_ID  tagId;
        
        bResult = FALSE; // just in case we fail below

        // Create an iterator for our segment list
        IFC( spSegmentList->CreateIterator( &spIter ) );

        while( spIter->IsDone() == S_FALSE )
        {
            IFC( spIter->Current( &spSegment ) );
            
            // Check that the element in the control range is an image
            IFC( GetSegmentElement(spSegment, &spElement) );
            IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

            bResult = (tagId == TAGID_IMG);
            if ( ! bResult )
            {
                goto Cleanup;
            }

            ClearInterface( & spElement );
            IFC( spIter->Advance() );
        }
    }

Cleanup:
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\copycmd.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_COPYCMD_HXX_
#define _X_COPYCMD_HXX_
#include "copycmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

using namespace EdUtil;

#define CREATE_FLAGS_NoIE4SelCompat 1

//
// Externs
//

MtDefine(CCopyCommand, EditCommand, "CCopyCommand");

HRESULT
CCopyCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT         hr = S_OK;
    ISegmentList    *pSegmentList = NULL;
    CHTMLEditor     *pEditor = GetEditor();
    IHTMLElement    *pElement = NULL;
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL    fRet;
    BOOL            fEmpty = FALSE;
    SELECTION_TYPE  eSelectionType;
    DWORD           dwOptions = 0;

    //
    // Do the prep work
    //
    ((IHTMLEditor *) pEditor)->AddRef();    // FireOnCancelableEvent can remove the whole doc

    IFC( GetSegmentList( &pSegmentList ));

    IFC( pSegmentList->IsEmpty( &fEmpty ) );
    // 
    // If there is no segments we're done, it's a nogo
    //
    if( fEmpty == TRUE )
        goto Cleanup;

    //  See if the segment list contains a password element
    if (SegmentListContainsPassword(pSegmentList))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }


    IFC( GetEditor()->FindCommonParentElement( pSegmentList, &pElement));

    if (! pElement)
        goto Cleanup;
        
    IFC(pElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->fireEvent(_T("oncopy"), NULL, &fRet));

    if (!fRet)
        goto Cleanup;

    //
    // Do the actual copy
    //

    IFC( pSegmentList->GetType(&eSelectionType) );
    if (eSelectionType == SELECTION_TYPE_Control)
    {
        dwOptions |= CREATE_FLAGS_NoIE4SelCompat;
    }

#ifndef UNIX
    IFC( GetMarkupServices()->SaveSegmentsToClipboard( pSegmentList, dwOptions ) );
#else
    IFC( GetMarkupServices()->SaveSegmentsToClipboard( pSegmentList, dwOptions, pvarargOut ) );
#endif

Cleanup:
    ReleaseInterface( pElement );
    ReleaseInterface((IHTMLEditor *) pEditor);
    ReleaseInterface(pSegmentList);

    RRETURN(hr);
}


HRESULT 
CCopyCommand::PrivateQueryStatus( OLECMD * pCmd,
                     OLECMDTEXT * pcmdtext )
{
    HRESULT                 hr = S_OK;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    SP_IHTMLElement         spElement;
    SP_IHTMLElement3        spElement3;
    VARIANT_BOOL            fRet = VB_TRUE;
    BOOL                    fEmpty = FALSE;
    ED_PTR                  ( edStart );
    ED_PTR                  ( edEnd );
    IHTMLEditor             *pEditor = GetEditor();
    SELECTION_TYPE          eSelectionType;
    
    pEditor->AddRef();
    
    //
    // Status is disabled by default
    //
    pCmd->cmdf = MSOCMDSTATE_DISABLED;

    // 
    // Get the segment list and selection type, and empty status
    //
    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->GetType( &eSelectionType ));
    IFC( spSegmentList->IsEmpty( &fEmpty ) );

    // 
    // If there is no segments we're done, it's a nogo
    //
    if( fEmpty )
        goto Cleanup;

    //  See if the segment list contains a password element
    if (SegmentListContainsPassword(spSegmentList))
        goto Cleanup;

    // No copying allowed while in the middle of an IME composition
    if( GetEditor()->GetSelectionManager()->IsIMEComposition() )
        goto Cleanup;

    IFC( GetEditor()->FindCommonParentElement( spSegmentList, &spElement));
   
    if (spElement)
    {
        IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        IFC(spElement3->fireEvent(_T("onbeforecopy"), NULL, &fRet));
    }

    if (!fRet)
    {
        pCmd->cmdf = MSOCMDSTATE_UP; 
        goto Cleanup;
    }

    //
    // If there is a selection, copy is enabled
    //
    if (SELECTION_TYPE_Caret != eSelectionType) 
    {
        if (GetCommandTarget()->IsRange())
        {
            IFC( spSegmentList->CreateIterator(&spIter) );
            Assert(S_FALSE == spIter->IsDone());

            BOOL  fEqual;
            IFC( spIter->Current(&spSegment) );
            IFC( spSegment->GetPointers(edStart, edEnd) );
            IFC( edStart->IsEqualTo(edEnd, &fEqual) );
            if (fEqual)
                goto Cleanup;
        }

        pCmd->cmdf = MSOCMDSTATE_UP;
    }

Cleanup:
    ReleaseInterface( pEditor );
    
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\blockcmd.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_RESOURCE_H_
#define _X_RESOURCE_H_
#include "resource.h"
#endif

#ifndef _X_CAPTION_H_
#define _X_CAPTION_H_
#include "caption.h"
#endif

#ifndef _X_DIV_H_
#define _X_DIV_H_
#include "div.h"
#endif

#ifndef _X_HEADER_H_
#define _X_HEADER_H_FC
#include "header.h"
#endif

#ifndef _X_HR_H_
#define _X_HR_H_
#include "hr.h"
#endif

#ifndef _X_IMG_H_
#define _X_IMG_H_
#include "img.h"
#endif

#ifndef _X_OBJECT_H_
#define _X_OBJECT_H_
#include "object.h"
#endif

#ifndef _X_PARA_H_
#define _X_PARA_H_
#include "para.h"
#endif

#ifndef _X_TABLE_H_
#define _X_TABLE_H_
#include "table.h"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_CHARCMD_HXX_
#define _X_CHARCMD_HXX_
#include "charcmd.hxx"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_EDTRACK_HXX_
#define X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

using namespace EdUtil;

MtDefine(CIndentCommand, EditCommand, "CIndentCommand");
MtDefine(COutdentCommand, EditCommand, "COutdentCommand");
MtDefine(CAlignCommand, EditCommand, "CAlignCommand");
MtDefine(CGetBlockFmtCommand, EditCommand, "CGetBlockFmtCommand");
MtDefine(CBlockFmtCommand, EditCommand, "CBlockFmtCommand");
MtDefine(CListCommand, EditCommand, "CListCommand");
MtDefine(CBlockFmtListCommand, EditCommand, "CBlockFmtListCommand");
MtDefine(CBlockDirCommand, EditCommand, "CBlockDirCommand");
MtDefine(CBlockCommand, EditCommand, "CBlockCommand");

#define MAX_BLOCKFMT_DISPLAYNAME_LENGTH 256

// ***** start CBlockDirCommand *****

//+---------------------------------------------------------------------------
//
//  CBlockDirCommand::AdjustElementMargin
//
//----------------------------------------------------------------------------
HRESULT CBlockDirCommand::AdjustElementMargin(IHTMLElement* pCurElement)
{
    HRESULT         hr = S_OK;
    SP_IHTMLStyle   spStyle;
    ELEMENT_TAG_ID  tagId = TAGID_NULL;
    
    THR(GetMarkupServices()->GetElementTagId(pCurElement, &tagId));

    switch(tagId)
    {
    case TAGID_BLOCKQUOTE:
        {
            // (paulnel) Here we need to make sure the margin of 0 is set to the trailing
            //           edge of the line
            if(_cmdId == IDM_BLOCKDIRLTR)
            {
                IFC( pCurElement->get_style(&spStyle) );
                
                if (GetEditor()->GetCssEditingLevel())
                {
                    IFC( spStyle->put_marginRight(CVariant(VT_I4)) );
                }
                
                IFC( spStyle->removeAttribute(_T("marginLeft"), 0, NULL) );
            }
            else if (_cmdId == IDM_BLOCKDIRRTL)
            {
                IFC( pCurElement->get_style(&spStyle) );

                if (GetEditor()->GetCssEditingLevel())
                {
                    IFC( spStyle->put_marginLeft(CVariant(VT_I4)) );
                }
                
                IFC( spStyle->removeAttribute(_T("marginRight"), 0, NULL) );
            }

        }
                hr = S_FALSE; // need to recurse in an change margins of all other elements
        break;
    }


Cleanup:

    RRETURN1(hr, S_FALSE);    
}

//+---------------------------------------------------------------------------
//
//  CBlockDirCommand::GetElementAlignment
//
//  Synopsis: Given an element, get the direction string
//----------------------------------------------------------------------------
HRESULT CBlockDirCommand::GetElementAlignment(
    IHTMLElement *pElement, 
    BSTR *pszDir)
{
    HRESULT                 hr = S_OK;
    SP_IHTMLComputedStyle   spComputedStyle;
    VARIANT_BOOL            fRtl;

    IFC( GetEditor()->GetComputedStyle(pElement, &spComputedStyle) );
    IFC( spComputedStyle->get_blockDirection(&fRtl) );

    *pszDir = fRtl ? SysAllocString(L"rtl") : SysAllocString(L"ltr");

Cleanup:
    RRETURN(hr);
}
    
//+---------------------------------------------------------------------------
//
//  CBlockDirCommand::SetElementAlignment
//
//----------------------------------------------------------------------------

HRESULT 
CBlockDirCommand::SetElementAlignment(IHTMLElement *pElement, BSTR szAlign, BOOL)
{
    HRESULT         hr;
    IHTMLElement*   pParent = NULL;
    IHTMLElement2*  pElem2 = NULL;
    BSTR            szDir = NULL;
    ELEMENT_TAG_ID  tagId = TAGID_NULL;
    
    // We will only add the dir tag if the element's parent is not in the
    // same direction. This gives us cleaner code.
    hr = THR(GetEditor()->GetParentElement( pElement, &pParent) );
    if (FAILED(hr))
        goto Cleanup;        

    hr = THR(FindAlignment(pParent, &szDir));
    if (FAILED(hr))
        goto Cleanup;        
    
    THR(GetMarkupServices()->GetElementTagId(pParent, &tagId));

    switch(tagId)
    {
        // If we have a list container parent we want to put the direction on 
        // that container
    case TAGID_OL:
    case TAGID_UL:
        hr = pParent->QueryInterface(IID_IHTMLElement2,(LPVOID*)&pElem2);
        break;
 
    default:
        hr = pElement->QueryInterface(IID_IHTMLElement2,(LPVOID*)&pElem2);
        break;
    }

    if(!pElem2) 
        goto Cleanup;
    
    hr = pElem2->put_dir(_szAlign);

    if (FAILED(hr))
        goto Cleanup;

        hr = THR(AdjustElementMargin(pElement));

Cleanup:
    if (pParent) pParent->Release();
    if (pElem2) pElem2->Release();
    SysFreeString(szDir);

    return hr;
}
        
//+---------------------------------------------------------------------------
//
//  CBlockDirCommand::FindAlignment
//
//  Synopsis: Walk up the tree until we find the direction
//
//----------------------------------------------------------------------------
HRESULT CBlockDirCommand::FindAlignment( 
    IHTMLElement     *pElement, 
    BSTR             *pszDir)
{
    HRESULT             hr = S_OK;
    IHTMLElement        *pOldElement = NULL;
    IHTMLElement        *pCurrent = NULL;

    *pszDir = NULL;

    ReplaceInterface(&pCurrent, pElement);
    do
    {
        hr = THR(GetElementAlignment(pCurrent, pszDir));
        if (SUCCEEDED(hr))
            break; // done
    
        ReplaceInterface(&pOldElement, pCurrent);
        ClearInterface(&pCurrent);
        hr = THR(GetEditor()->GetParentElement(pOldElement, &pCurrent) );
        if (FAILED(hr))
            goto Cleanup;        
    }
    while (pCurrent);

Cleanup:    
    ReleaseInterface(pCurrent);
    ReleaseInterface(pOldElement);
    RRETURN(hr);        
}


HRESULT 
CBlockDirCommand::ApplySiteAlignCommand(IHTMLElement *pElement)
{
    HRESULT             hr;
    SP_IMarkupPointer   spStart, spEnd;    

    IFR( GetEditor()->CreateMarkupPointer(&spStart) );
    IFR( spStart->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin) );
    
    IFR( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFR( spEnd->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );

    IFR( ApplyAlignCommand(spStart, spEnd) );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CGetBlockFmtCommand Class
//
//----------------------------------------------------------------------------

CRITICAL_SECTION CGetBlockFmtCommand::_csLoadTable;
BOOL             CGetBlockFmtCommand::_fLoaded = FALSE;
BOOL             CGetBlockFmtCommand::_fCSInited = FALSE;

// TODO: use a hash table here [ashrafm]
    
CGetBlockFmtCommand::BlockFmtRec 
       CGetBlockFmtCommand::_blockFmts[] = 
{
    // **** NOTE: TAGID_NULL MUST BE FIRST HERE!!! ****
    { TAGID_NULL,    IDS_BLOCKFMT_NORMAL }, // depends on the current default tag 
    { TAGID_PRE,     IDS_BLOCKFMT_PRE },
    { TAGID_ADDRESS, IDS_BLOCKFMT_ADDRESS },
    { TAGID_H1,      IDS_BLOCKFMT_H1 },
    { TAGID_H2,      IDS_BLOCKFMT_H2 },
    { TAGID_H3,      IDS_BLOCKFMT_H3 },
    { TAGID_H4,      IDS_BLOCKFMT_H4 },
    { TAGID_H5,      IDS_BLOCKFMT_H5 },
    { TAGID_H6,      IDS_BLOCKFMT_H6 },
    { TAGID_OL,      IDS_BLOCKFMT_OL },
    { TAGID_UL,      IDS_BLOCKFMT_UL },
    { TAGID_DIR,     IDS_BLOCKFMT_DIR },
    { TAGID_MENU,    IDS_BLOCKFMT_MENU },
    { TAGID_DT,      IDS_BLOCKFMT_DT },
    { TAGID_DD,      IDS_BLOCKFMT_DD },
    { TAGID_P,       IDS_BLOCKFMT_P }
};

CGetBlockFmtCommand::BlockFmtRec 
       CGetBlockFmtCommand::_tagBlockFmts[] = 
{
    { TAGID_PRE,     IDS_BLOCKFMT_PRE_TAG },
    { TAGID_ADDRESS, IDS_BLOCKFMT_ADDRESS_TAG },
    { TAGID_H1,      IDS_BLOCKFMT_H1_TAG },
    { TAGID_H2,      IDS_BLOCKFMT_H2_TAG },
    { TAGID_H3,      IDS_BLOCKFMT_H3_TAG },
    { TAGID_H4,      IDS_BLOCKFMT_H4_TAG },
    { TAGID_H5,      IDS_BLOCKFMT_H5_TAG },
    { TAGID_H6,      IDS_BLOCKFMT_H6_TAG },
    { TAGID_OL,      IDS_BLOCKFMT_OL_TAG },
    { TAGID_UL,      IDS_BLOCKFMT_UL_TAG },
    { TAGID_DIR,     IDS_BLOCKFMT_DIR_TAG },
    { TAGID_MENU,    IDS_BLOCKFMT_MENU_TAG },
    { TAGID_DT,      IDS_BLOCKFMT_DT_TAG },
    { TAGID_DD,      IDS_BLOCKFMT_DD_TAG },
    { TAGID_P,       IDS_BLOCKFMT_P_TAG },
    { TAGID_DIV,     IDS_BLOCKFMT_DIV_TAG }
};

HRESULT 
CGetBlockFmtCommand::PrivateQueryStatus(   OLECMD * pCmd,
                                    OLECMDTEXT * pcmdtext )
{
#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
    }
    else
#endif
    pCmd->cmdf = MSOCMDSTATE_UP; 
    return S_OK;
}

    
HRESULT 
CGetBlockFmtCommand::GetDefaultBlockTag( IMarkupServices *pMarkupServices, ELEMENT_TAG_ID *ptagId)
{
    HRESULT             hr;
    IOleCommandTarget   *pCommandTarget = NULL;
    VARIANT             var;

    *ptagId = TAGID_P; // default for most cases

    hr = THR(pMarkupServices->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCommandTarget));
    if (FAILED(hr))
        goto Cleanup;

    VariantInit(&var);        
    hr = THR(pCommandTarget->Exec((GUID *)&CGID_MSHTML,
                                  IDM_DEFAULTBLOCK,
                                  MSOCMDEXECOPT_DONTPROMPTUSER,
                                  NULL,
                                  &var));
    if (FAILED(hr))
        goto Cleanup;
                                  
    if (V_VT(&var) == VT_BSTR
        && (V_BSTR(&var) != NULL)
        && (StrCmpW(_T("DIV"), V_BSTR(&var)) == 0))
    {
        *ptagId = TAGID_DIV;
    }
    VariantClear(&var);
    
Cleanup:
    ReleaseInterface(pCommandTarget);
    RRETURN(hr);
}

HRESULT 
CGetBlockFmtCommand::LookupTagId(   IMarkupServices     *pMarkupServices,
                                    BSTR                bstrName,
                                    ELEMENT_TAG_ID      *ptagId )
{
    HRESULT             hr;
    INT                 i;

    hr = E_INVALIDARG; // if not found, this is the return value

    if (bstrName == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    // Check standard case
    for (i = 0; i < ARRAY_SIZE(_blockFmts); i++)
    {
        if (StrCmpIW(_blockFmts[i]._bstrName, bstrName) == 0)
        {
            // found element
            *ptagId = _blockFmts[i]._tagId;
            hr = S_OK;
            goto Cleanup;            
        }
    }

    // Check <tagId> case
    for (i = 0; i < ARRAY_SIZE(_tagBlockFmts); i++)
    {
        if (StrCmpIW(_tagBlockFmts[i]._bstrName, bstrName) == 0)
        {
            *ptagId = _tagBlockFmts[i]._tagId;
            hr = S_OK;
            goto Cleanup;            
        }
    }

Cleanup:
    RRETURN(hr);
}

HRESULT 
CGetBlockFmtCommand::PrivateExec(
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{  
    HRESULT        hr = S_OK;
    SAFEARRAYBOUND sabound;
    SAFEARRAY *    psa;
    LONG           i;

    Assert(pvarargIn == NULL || V_VT(pvarargIn) == VT_EMPTY || V_VT(pvarargIn) == VT_NULL);
      
    if (pvarargOut)
    {
        sabound.cElements = ARRAY_SIZE(_blockFmts);
        sabound.lLbound = 0;

        psa = SafeArrayCreate(VT_BSTR, 1, &sabound);

        for (i = 0; i < ARRAY_SIZE(_blockFmts); i++)
            IFC(SafeArrayPutElement(psa, &i, _blockFmts[i]._bstrName));

        V_ARRAY(pvarargOut) = psa;
        V_VT(pvarargOut) = VT_ARRAY;
    }    

Cleanup:
    RRETURN(hr);
}

HRESULT 
CGetBlockFmtCommand::Init()
{
    HRESULT hr;
    int     i;

    hr = HrInitializeCriticalSection(&_csLoadTable);
    if (hr)
        goto Cleanup;

    _fCSInited = TRUE;

    for (i = 0; i < ARRAY_SIZE(_blockFmts); i++)
        _blockFmts[i]._bstrName = NULL;

Cleanup:
    RRETURN(hr);
}

HRESULT
CGetBlockFmtCommand::LoadDisplayNames(HINSTANCE hinst)
{
    HRESULT hr;
    
    EnterCriticalSection(&_csLoadTable);

    Assert(_fLoaded);
    hr = THR(LoadDisplayNamesHelper(hinst));
    
    LeaveCriticalSection(&_csLoadTable);

    RRETURN(hr);
}

HRESULT
CGetBlockFmtCommand::LoadDisplayNamesHelper(HINSTANCE hinst)
{
    HRESULT hr = S_OK;
    INT     i, j;
    TCHAR   szBuffer[MAX_BLOCKFMT_DISPLAYNAME_LENGTH];    
    
    for (i = 0; i < ARRAY_SIZE(_blockFmts); i++)
    {
        if (!LoadString(hinst, _blockFmts[i]._idsName, szBuffer, ARRAY_SIZE(szBuffer)))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        
        if (_blockFmts[i]._bstrName)
            SysFreeString(_blockFmts[i]._bstrName);

        _blockFmts[i]._bstrName = SysAllocString(szBuffer);
        if (!_blockFmts[i]._bstrName)
        {
            hr = E_OUTOFMEMORY;
            for (j = 0; j < i; j++)
            {
                SysFreeString(_blockFmts[j]._bstrName); // free all this stuff we allocated
                _blockFmts[j]._bstrName = NULL;
            }
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CGetBlockFmtCommand::LoadStringTable(HINSTANCE hinst)
{
    HRESULT     hr = S_OK;
    INT         i, j;
    TCHAR       szBuffer[MAX_BLOCKFMT_DISPLAYNAME_LENGTH];    

    if (_fLoaded)
        return S_OK; // we're done

    EnterCriticalSection(&_csLoadTable);
    if (_fLoaded)
        goto Cleanup; // we're done
    
    //
    // Load English version of display names
    //

    IFC( LoadDisplayNamesHelper(hinst) );
    
    // 
    // Load blockfmt tag names
    //
    for (i = 0; i < ARRAY_SIZE(_tagBlockFmts); i++)
    {
        if (!LoadString(g_hInstance, _tagBlockFmts[i]._idsName, szBuffer, ARRAY_SIZE(szBuffer)))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        _tagBlockFmts[i]._bstrName = SysAllocString(szBuffer);
        if (!_tagBlockFmts[i]._bstrName)
        {
            hr = E_OUTOFMEMORY;
            for (j = 0; j < i; j++)
                SysFreeString(_tagBlockFmts[j]._bstrName); // free all this stuff we allocated
            goto Cleanup;
        }
    }

    _fLoaded = TRUE;

Cleanup:
    LeaveCriticalSection(&_csLoadTable);
    AssertSz(hr == S_OK, "Can't load string table");

    RRETURN(hr);
}

VOID CGetBlockFmtCommand::Deinit()
{
    INT i;

    // doesn't need to be protected because called from process detach
    if (_fLoaded)
    {
        for (i = 0; i < ARRAY_SIZE(_blockFmts); i++)
            SysFreeString(_blockFmts[i]._bstrName); // free all this stuff we allocated                        

        for (i = 0; i < ARRAY_SIZE(_tagBlockFmts); i++)
            SysFreeString(_tagBlockFmts[i]._bstrName); // free all this stuff we allocated                        
    }

    if (_fCSInited)
    {
        DeleteCriticalSection(&_csLoadTable);
        _fCSInited = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  CGetBlockFmtCommand::LookupFormatName
//
//----------------------------------------------------------------------------
BSTR CGetBlockFmtCommand::LookupFormatName(IMarkupServices *pMarkupServices, ELEMENT_TAG_ID tagId)
{
    HRESULT         hr;
    INT             i;
    BSTR            bstrResult;
    ELEMENT_TAG_ID  tagIdDefault;

    if (tagId == TAGID_UNKNOWN)
        return NULL;

    bstrResult = _blockFmts[0]._bstrName;     // Unknown tags default to "Normal"

    if (tagId == TAGID_DIV)
        return bstrResult;
        
    if (tagId == TAGID_P)
    {        
        IFC( GetDefaultBlockTag(pMarkupServices, &tagIdDefault) );
        if (tagIdDefault == TAGID_P)
            return bstrResult;

        // Otherwise, fall through to lookup below
    }

    for (i = 0; i < ARRAY_SIZE(_blockFmts); i++)
    {
        if (_blockFmts[i]._tagId == tagId)
        {
            bstrResult = _blockFmts[i]._bstrName;
            break;
        }
    }

Cleanup:
    return bstrResult;
}

//
// CBlockPointer implementation
//

#define  BREAK_CONDITION_BLOCKPOINTER   (BREAK_CONDITION_Text           |  \
                                         BREAK_CONDITION_NoScopeSite    |  \
                                         BREAK_CONDITION_NoScopeBlock   |  \
                                         BREAK_CONDITION_Site           |  \
                                         BREAK_CONDITION_Block          |  \
                                         BREAK_CONDITION_Control)

CBlockPointer::CBlockPointer(CHTMLEditor *pEd)
{
    _pEd = pEd;
    _type = NT_Undefined;
    _pElement = NULL;
    _pLeft = NULL;
    _pRight = NULL;
}

CBlockPointer::~CBlockPointer()
{
    ClearPointers();
}


NodeType 
CBlockPointer::GetType()
{
    Assert(_type != NT_Undefined);
    
    return _type;
}

HRESULT 
CBlockPointer::GetElement(IHTMLElement **ppElement)
{
    if (!IsElementType())
    {
        *ppElement = NULL;
        return S_OK;
    }
    
    Assert(_pElement);

    *ppElement = _pElement;
    _pElement->AddRef();

    return S_OK;        
}
    
IMarkupServices2* 
CBlockPointer::GetMarkupServices()
{
    return _pEd->GetMarkupServices();
}

HRESULT 
CBlockPointer::MoveTo(IMarkupPointer *pPointer, Direction dir)
{
    HRESULT hr;

    // The direction is just a hint.  If we don't find a node in one direction,
    // we check the other direction.
    
    IFR( PrivateMoveTo(pPointer, dir, MOVE_ALLOWEMPTYTEXTNODE) );
    if (hr == S_FALSE)
    {
        IFR( PrivateMoveTo(pPointer, Reverse(dir), MOVE_ALLOWEMPTYTEXTNODE) );
    }

    return S_OK;
}

HRESULT 
CBlockPointer::PrivateMoveTo(IMarkupPointer *pPointer, Direction dir, DWORD dwMoveOptions)
{
    HRESULT         hr = S_FALSE;
    CEditPointer    epPosition(_pEd);
    CEditPointer    epStart(_pEd), epEnd(_pEd);
    DWORD           eSearchCondition = BREAK_CONDITION_BLOCKPOINTER;
    DWORD           eFoundCondition;
    SP_IHTMLElement spElement;
    BOOL            fIgnoreGlyphs = FALSE;

    Assert(dir != SAME);

    fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    IFC( epPosition->MoveToPointer(pPointer) );
    IFC( epPosition.Scan(dir, eSearchCondition, &eFoundCondition, &spElement) );

    if (epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_Text))
    {
        // Expand to maximal text region
        
        if (dir == LEFT)
        {
            IFC( epStart->MoveToPointer(epPosition) );
            IFC( epEnd->MoveToPointer(pPointer) );
        }
        else
        {
            IFC( epStart->MoveToPointer(pPointer) );
            IFC( epEnd->MoveToPointer(epPosition) );
        }

        // Expand left
        IFC( epStart.Scan(LEFT, eSearchCondition - BREAK_CONDITION_Text, &eFoundCondition) );
        IFC( epStart.Scan(RIGHT, eSearchCondition, NULL) );

        // Expand right
        IFC( epEnd.Scan(RIGHT, eSearchCondition - BREAK_CONDITION_Text, &eFoundCondition) );
        IFC( epEnd.Scan(LEFT, eSearchCondition, NULL) );

        // Create text node
        ClearPointers();
        IFC( CopyMarkupPointer(GetEditor(), epStart, &_pLeft) );
        IFC( _pLeft->SetGravity(POINTER_GRAVITY_Right) );
        
        IFC( CopyMarkupPointer(GetEditor(), epEnd, &_pRight) );
        IFC( _pRight->SetGravity(POINTER_GRAVITY_Left) );
        _type = NT_Text;

        hr = S_OK;
        goto Cleanup;
    }
    else if (epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_NoScopeBlock)
             || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_ExitBlock)
             || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_ExitSite))
    {
        NodeType type = NT_Undefined;

        if (spElement != NULL)
            IFC( GetElementNodeType(spElement, &type) );

        if (dwMoveOptions & MOVE_ALLOWEMPTYTEXTNODE && type != NT_TextBreak)
        {
            // No node found - check for empty text node
            IFC( epPosition.MoveToPointer(pPointer) );
            IFC( epPosition.Scan(Reverse(dir), eSearchCondition, &eFoundCondition) );

            if (epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_NoScopeBlock)
                || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_ExitBlock)
                || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_ExitSite))
            {
                DWORD dwFound;
                
                // Create text node
                ClearPointers();
                IFC( CopyMarkupPointer(GetEditor(), pPointer, &_pLeft) );
                IFC( _pLeft->SetGravity(POINTER_GRAVITY_Right) );    
                
                IFC( CopyMarkupPointer(GetEditor(), pPointer, &_pRight) );
                IFC( _pRight->SetGravity(POINTER_GRAVITY_Left) );

                _type = NT_Text;
                
                // Position phrase elements
                CEditPointer epRight(_pEd, _pRight);
                CEditPointer epLeft(_pEd, _pLeft);

                IFC( epRight.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
                IFC( epRight.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );

                IFC( epLeft.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
                IFC( epLeft.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
                
                hr = S_OK;
                goto Cleanup;
            }
        }
        else if (type == NT_TextBreak)
        {
            ClearPointers();
            _pElement = spElement;
            _pElement->AddRef();
            _type = type;

            hr = S_OK;
            goto Cleanup;
        }

        hr = S_FALSE;
        goto Cleanup;
    }
    else if (epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_Control)
             || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_NoScopeSite)
             || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_EnterBlock)
             || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_EnterSite))
    {
        Assert(spElement != NULL);
        ClearPointers();
        _pElement = spElement;
        _pElement->AddRef();
        IFC( GetElementNodeType(_pElement, &_type) );

        // If the current element is a colgroup, we want to skip over it.
        // (bug 91352)
        if (hr == S_FALSE && IsColgroup())
        {
            SP_IMarkupPointer   spTemp;

            IFC( GetEditor()->CreateMarkupPointer(&spTemp) );    
            if ( dir == LEFT)
            {
                IFC( spTemp->MoveAdjacentToElement(_pElement, ELEM_ADJ_BeforeBegin) );
            }
            else
            {
                IFC( spTemp->MoveAdjacentToElement(_pElement, ELEM_ADJ_AfterEnd) );
            }
            IFC( PrivateMoveTo(spTemp, dir, MOVE_ALLOWEMPTYTEXTNODE) );
        }
        goto Cleanup;
    }

    hr = S_FALSE;

Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    RRETURN1(hr, S_FALSE);
}

HRESULT 
CBlockPointer::MoveTo(IHTMLElement *pElement)
{
    HRESULT                         hr;
    SP_IHTMLElement                 spNewElement;
    SP_IHTMLElement                 spCurrentElement;
    NodeType                        nodeType;


    Assert(pElement);
    
    ClearPointers();
    
    spCurrentElement = pElement;
    do
    {
        IFR( GetElementNodeType(spCurrentElement, &nodeType));

        if (nodeType != NT_Undefined)
        {
            Assert(!IsColgroup(spCurrentElement));
            _pElement = spCurrentElement;
            _pElement->AddRef();
            _type = nodeType;
            break;
        }
                
        IFR( GetEditor()->GetParentElement( spCurrentElement, &spNewElement) );
        spCurrentElement = spNewElement;
    }
    while (spCurrentElement != NULL);

    AssertSz(_pElement, "Can't find block element");

    RRETURN(hr);            
}

HRESULT
CBlockPointer::MoveTo(CBlockPointer *pNode)
{
    HRESULT hr;
    
    Assert(_pEd == pNode->_pEd);
    Assert(pNode->GetType() != NT_Undefined);

    ClearPointers();
    
    if (pNode->IsElementType())
    {
        IFR( pNode->GetElement(&_pElement) );
    }
    else
    {
        Assert(pNode->_pLeft && pNode->_pRight);
        
        IFR( CopyMarkupPointer(GetEditor(), pNode->_pLeft, &_pLeft) );
        IFR( _pLeft->SetGravity(POINTER_GRAVITY_Right) );
        
        IFR( CopyMarkupPointer(GetEditor(), pNode->_pRight, &_pRight) );
        IFR( _pRight->SetGravity(POINTER_GRAVITY_Left) );
    }

    _type = pNode->GetType();    
    
    return S_OK;
}


HRESULT 
CBlockPointer::MoveToParent()
{
    HRESULT         hr;
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID  tagId;
    
    Assert(_type != NT_Undefined);

    if (IsElementType())
    {
        IFR( GetMarkupServices()->GetElementTagId(_pElement, &tagId) );
        if (tagId == TAGID_BODY)
            return S_FALSE;
            
        IFR( GetEditor()->GetParentElement( _pElement, &spElement) )
        if (spElement == NULL)
            return S_FALSE;
    }
    else
    {
        IFR( _pLeft->CurrentScope( &spElement) );

        if( !spElement )
            return S_FALSE;
        
#if DBG==1
        //
        // Check that the parent of the left and right ends of the node are the same
        //
        SP_IHTMLElement     spDebugElement;
        CBlockPointer       bpDebugLeft(_pEd);
        CBlockPointer       bpDebugRight(_pEd);
    
        Assert( _pRight->CurrentScope(&spDebugElement) == S_OK );
        Assert( bpDebugRight.MoveTo(spDebugElement) == S_OK );
        Assert( bpDebugLeft.MoveTo(spElement) == S_OK );
        Assert( bpDebugLeft.IsEqual(&bpDebugRight) == S_OK );
#endif
    }
    IFR( MoveTo(spElement) );
            
    return S_OK;
}

HRESULT 
CBlockPointer::MoveToScope(CBlockPointer *pScope)
{
    HRESULT         hr;
    CBlockPointer   bpParent(_pEd);

    // 
    // Move up the tree until we find a node that is in the specified scope
    //

    IFR( bpParent.MoveTo(this) );
    for (;;)
    {        
        IFR( bpParent.MoveToParent() );
        
        Assert(hr != S_FALSE);        
        if (hr == S_FALSE)
            return S_FALSE;

        IFR( bpParent.IsEqual(pScope) );
        if (hr == S_OK)
            break;

        IFR( MoveToParent() );
    } 
    
    return S_OK;
}

HRESULT 
CBlockPointer::MoveToFirstChild()
{
    HRESULT             hr;
    SP_IMarkupPointer   spLeft;
    
    Assert(_type != NT_Undefined);
    
    switch (_type)
    {
        case NT_Text:
        case NT_Control:
        case NT_TextBreak:
            return S_FALSE; // done        
    }

    Assert(IsElementType());

    IFR( GetEditor()->CreateMarkupPointer(&spLeft) );    
    IFR( spLeft->MoveAdjacentToElement(_pElement, ELEM_ADJ_AfterBegin) );
    IFR( PrivateMoveTo(spLeft, RIGHT, MOVE_ALLOWEMPTYTEXTNODE) );

    return S_OK;
}

HRESULT 
CBlockPointer::MoveToLastChild()
{
    HRESULT             hr;
    SP_IMarkupPointer   spLeft;
    
    Assert(_type != NT_Undefined);
    
    switch (_type)
    {
        case NT_Text:
        case NT_Control:
        case NT_TextBreak:
            return S_FALSE; // done        
    }

    Assert(IsElementType());

    IFR( GetEditor()->CreateMarkupPointer(&spLeft) );    
    IFR( spLeft->MoveAdjacentToElement(_pElement, ELEM_ADJ_BeforeEnd) );
    IFR( PrivateMoveTo(spLeft, LEFT, MOVE_ALLOWEMPTYTEXTNODE) );

    return S_OK;
}

HRESULT 
CBlockPointer::MoveToSibling(Direction dir)
{
    HRESULT         hr;
    CEditPointer    epPointer(_pEd);
    BOOL            fIgnoreGlyphs = FALSE;

    Assert(dir != SAME);

    fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    IFC( MovePointerTo(epPointer, (dir==LEFT)?ELEM_ADJ_BeforeBegin:ELEM_ADJ_AfterEnd) );
    IFC( PrivateMoveTo(epPointer, dir, 0) );

Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    return hr;
}

BOOL 
CBlockPointer::IsLeafNode()
{
    HRESULT hr;

    switch (GetType())
    {
        case NT_Text:
        case NT_Control:
        case NT_TextBreak:
            return TRUE;

        case NT_BlockLayout:
        {
            ELEMENT_TAG_ID tagId;

            IFC( GetMarkupServices()->GetElementTagId(_pElement, &tagId) );
            return (tagId == TAGID_HR);
        }
    }

Cleanup:
    return FALSE;
}

HRESULT 
CBlockPointer::MoveToNextLeafNode()
{
    HRESULT hr;
    long i;
    
    //
    // It is common to do a MoveToLastNodeInBlock followed by
    // a MoveToNextLeafNode.  So, we can get NT_FlowLayout as well
    // as a leaf node.
    //
    Assert(IsLeafNode() || GetType() == NT_FlowLayout);

    for (i=0;;i++)
    {
        IFR( MoveToSibling(RIGHT) );
        if (hr == S_OK)
        {
            while (!IsLeafNode())
            {
                IFR( MoveToFirstChild() );
                Assert(hr != S_FALSE);
            }
            break; // done;
        }
        else
        {
            IFR( MoveToParent() );
            if (hr == S_FALSE)
                return S_FALSE; // can't find next leaf node                   
        }
    }

    return S_OK;
}

HRESULT
CBlockPointer::IsPointerInBlock(IMarkupPointer *pPointer)
{
    HRESULT             hr;
    SP_IMarkupPointer   spTest;
    BOOL                bOutside;

    IFR( GetEditor()->CreateMarkupPointer(&spTest) );
    
    IFR( MovePointerTo(spTest, ELEM_ADJ_BeforeEnd) );
    IFR( pPointer->IsRightOf(spTest, &bOutside) );
    if (bOutside)
        return S_FALSE; // not in block
        
    IFR( MovePointerTo(spTest, ELEM_ADJ_AfterBegin) );
    IFR( pPointer->IsLeftOf(spTest, &bOutside) );
    if (bOutside)
        return S_FALSE; // not in block

    return S_OK; // in block    
}

HRESULT 
CBlockPointer::MoveToNextLogicalBlock(IMarkupPointer *pControl, BOOL fFlatten)
{
    HRESULT             hr;
    SP_IMarkupPointer   spTest;
    BOOL                bLeftOf;
    CBlockPointer       bpParent(_pEd);
    
    IFR( GetEditor()->CreateMarkupPointer(&spTest) );
    
    for (;;)
    {
        IFR( MoveToSibling(RIGHT) );
        if (hr == S_FALSE && fFlatten)
        {
            // We might be able to flatten the parent and collapse the scope.
            IFR( bpParent.MoveTo(this) );
            IFR( bpParent.MoveToParent() );
            if (hr == S_OK && bpParent.GetType() == NT_Block)
            {
                IFR( bpParent.FlattenNode() );
                IFR( MoveToSibling(RIGHT) ); // try again                
            }
            else
            {
                hr = S_FALSE;
            }
        }
        
        if (hr == S_OK)
        {
            do 
            {
                if (fFlatten && GetType() == NT_Block)
                    IFR( FlattenNode() );
                        
                if (GetType() != NT_Container)
                {
                    //
                    // If block is entirely to the left of pControl, we return
                    // this block as the next logical block
                    //
                    IFR( MovePointerTo(spTest, ELEM_ADJ_AfterEnd) );
                    IFR( spTest->IsLeftOfOrEqualTo(pControl, &bLeftOf) );
                    if (bLeftOf)            
                        return S_OK; // done
                }

                //
                // Otherwise, check the first child
                //
                // NOTE: failure of MoveToFirstChild means no children in
                // which case we should return S_FALSE.
            
                hr = THR( MoveToFirstChild() );
            } while (hr == S_OK);

            return S_FALSE; // can't find next logical block
        }

        IFR( MoveToParent() );
        if (hr == S_FALSE)
            return S_FALSE; // can't find next logical block                                
    }
}

HRESULT 
CBlockPointer::MoveToLastNodeInBlock()
{
    HRESULT         hr;
    CBlockPointer   bpTest(_pEd);
    BOOL            fBlockBoundary;

    IFR( bpTest.MoveTo(this) );
    for (;;)
    {
        IFR(bpTest.MoveToSibling(RIGHT));
        if (hr == S_FALSE)
            break;
            
        fBlockBoundary = TRUE;

        switch (bpTest.GetType())
        {
            case NT_FlowLayout:
            case NT_Text:
            case NT_Control:
            case NT_TextBreak:
                fBlockBoundary = FALSE;
        }
        
        if (fBlockBoundary)
            break;

        IFR( MoveTo(&bpTest) );                
    }

    return S_OK;    
}

HRESULT 
CBlockPointer::MoveToFirstNodeInBlock()
{
    HRESULT         hr;
    CBlockPointer   bpTest(_pEd);
    BOOL            fBlockBoundary;

    IFR( bpTest.MoveTo(this) );

    for (;;)
    {
        IFR(bpTest.MoveToSibling(LEFT));
        if (hr == S_FALSE)
            break;

        fBlockBoundary = TRUE;

        switch (bpTest.GetType())
        {
            case NT_FlowLayout:
            case NT_Text:
            case NT_Control:
            case NT_TextBreak:
                fBlockBoundary = FALSE;
        }
        
        if (fBlockBoundary)
            break;

        IFR( MoveTo(&bpTest) );                
    }

    return S_OK;    
}

HRESULT 
CBlockPointer::MoveToBlockScope(CBlockPointer *pEnd)
{
    HRESULT             hr;
    CEditPointer        epInner(_pEd), epOuter(_pEd);
    BOOL                fEqual;
    CBlockPointer       bpParent(_pEd);
    DWORD               dwIgnore = BREAK_CONDITION_ANYTHING - BREAK_CONDITION_BLOCKPOINTER;

    if (!IsLeafNode() && GetType() != NT_FlowLayout)
        return S_OK; // done

    //
    // First check if there is a block directly above
    //

    IFR( bpParent.MoveTo(this) );
    IFR( bpParent.MoveToParent() );

    if (hr == S_FALSE || bpParent.GetType() != NT_Block && bpParent.GetType() != NT_ListItem)
        return S_FALSE;
    
    IFR( MovePointerTo(epInner, ELEM_ADJ_BeforeBegin) );
    IFR( bpParent.MovePointerTo(epOuter, ELEM_ADJ_AfterBegin) );

    IFR( epInner.IsEqualTo(epOuter, dwIgnore, &fEqual) );
    if (fEqual)
    {
        IFR( pEnd->MovePointerTo(epInner, ELEM_ADJ_AfterEnd) );
        IFR( bpParent.MovePointerTo(epOuter, ELEM_ADJ_BeforeEnd) );

        IFR( epInner.IsEqualTo(epOuter, dwIgnore, &fEqual) );
        if (fEqual)
        {
            IFR( MoveTo(&bpParent) );
            return S_OK; // found block
        }        
    }

    //
    // No block above, so flatten parent and go up if we can
    //

    if (bpParent.GetType() == NT_Block)
    {
        SP_IHTMLElement spElement;
        ELEMENT_TAG_ID  tagId;

        IFR( bpParent.GetElement(&spElement) );
        IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
        if (tagId == TAGID_BLOCKQUOTE)
            return S_FALSE; // can't get scope through flatten

        // TODO: flatten node needs to fail instead of return S_FALSE for blockquote's [ashrafm]
        IFR( bpParent.FlattenNode() );
        IFR( MoveToParent() );
        return S_OK;
    }

    return S_FALSE;
}

HRESULT
CBlockPointer::EnsureNoChildOverlap(CBlockPointer *pbpChild)
{
    HRESULT             hr;
    SP_IMarkupPointer   spChildRight;
    SP_IMarkupPointer   spNodeRight;
    CBlockPointer       &bpChild = *pbpChild; // just for convenience
    BOOL                fOverlap;
    BOOL                fEqual;

    if (GetType() != NT_Block || bpChild.GetType() != NT_Block)
        return S_FALSE;
    
    IFR( GetEditor()->CreateMarkupPointer(&spChildRight) );
    IFR( GetEditor()->CreateMarkupPointer(&spNodeRight) );

    IFR( bpChild.MovePointerTo(spChildRight, ELEM_ADJ_AfterEnd) );    
    IFR( MovePointerTo(spNodeRight, ELEM_ADJ_BeforeEnd) );

    IFR( spNodeRight->IsLeftOf(spChildRight, &fOverlap) );
    if (!fOverlap)
        return S_OK; // nothing to do

    if (fOverlap)
    {
        SP_IHTMLElement     spNewElement;
        SP_IHTMLElement     spElement;
        SP_IMarkupPointer   spLeft;

        //
        // Split the child tag
        //

        // Insert left side
        IFR( GetEditor()->CreateMarkupPointer(&spLeft) );
        IFR( bpChild.MovePointerTo(spLeft, ELEM_ADJ_AfterBegin) );
        IFR( bpChild.GetElement(&spElement) )
        IFR( GetMarkupServices()->RemoveElement(spElement) );
        IFR( GetMarkupServices()->InsertElement(spElement, spLeft, spNodeRight) );

        // Insert right side
        IFR( MovePointerTo(spLeft, ELEM_ADJ_AfterEnd) );
        IFR( spLeft->IsEqualTo(spChildRight, &fEqual) );
        if (!fEqual)
        {
            IFR( GetMarkupServices()->CloneElement(spElement, &spNewElement) );
            IFR( GetMarkupServices()->InsertElement(spNewElement, spLeft, spChildRight) );
        }
        
    }       
    
    return S_OK;
}

HRESULT 
CBlockPointer::MergeAttributes(IHTMLElement *pElementSource, IHTMLElement *pElementDest)
{
    HRESULT             hr;    
    SP_IHTMLElement     spElementClone;

    //
    // HACKHACK: we need to do this dance because CopyAttributes overwrites
    // properties in the destination that are in the source.  We want the destination
    // properties to be preserved so we merge in the other order 
    //
    // TODO: fix this hack when the OM supports this type of merge [ashrafm]
    //
    IFR( GetMarkupServices()->CloneElement(pElementSource, &spElementClone) );
    IFR( CopyAttributes(pElementDest, spElementClone, FALSE) );
    IFR( CopyAttributes(spElementClone, pElementDest, FALSE) );

    return S_OK;
}

HRESULT
CBlockPointer::PushToChild(CBlockPointer *pbpChild)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagIdParent, tagIdChild;
    CBlockPointer   &bpChild = *pbpChild; // just for convenience
    SP_IHTMLElement spElement;
    SP_IHTMLElement spChildElement;
    BOOL            fNeedToInsertAbove = FALSE;
        
    Assert(GetType() == NT_Block && bpChild.GetType() == NT_Block);

    // Get tagId's
    IFR( GetMarkupServices()->GetElementTagId(_pElement, &tagIdParent) );
    IFR( bpChild.GetElement(&spChildElement) );
    IFR( GetMarkupServices()->GetElementTagId(spChildElement, &tagIdChild) );

    if (tagIdParent == tagIdChild)
    {
        //
        // We are done - just copy attributes 
        //
        IFR( MergeAttributes(_pElement, spChildElement) );
        return S_OK;
    }

    switch (tagIdParent)
    {
        case TAGID_P:
        case TAGID_DIV:
            switch (tagIdChild)
            {
                case TAGID_ADDRESS:
                case TAGID_PRE:
                    fNeedToInsertAbove = HasAttributes();
                    break;

                case TAGID_DIV:
                    // If either the child or parent is a P, we make sure the flattened node is a 
                    // P so we can keep the same spacing
                    if (tagIdParent == TAGID_P)
                        IFR( bpChild.Morph(&bpChild, TAGID_P) );

                    // fall through

                default:
                    // Copy attributes to child
                    IFR( MergeAttributes(_pElement, spChildElement) );
            }
            break;

        case TAGID_BLOCKQUOTE:
            AssertSz(0, "Shouldn't flatten blockquotes");
            break;
            
        case TAGID_H1:
        case TAGID_H2:
        case TAGID_H3:
        case TAGID_H4:
        case TAGID_H5:
        case TAGID_H6:
        case TAGID_ADDRESS:
        case TAGID_PRE:
            switch (tagIdChild)
            {
                case TAGID_P:
                case TAGID_DIV:
                    IFR( bpChild.Morph(&bpChild, tagIdParent) );
                    break;

                case TAGID_ADDRESS:
                case TAGID_PRE:
                case TAGID_H1:
                case TAGID_H2:
                case TAGID_H3:
                case TAGID_H4:
                case TAGID_H5:
                case TAGID_H6:
                    IFR( MergeAttributes(_pElement, spChildElement) );
                    break; 

                default:
                    fNeedToInsertAbove = TRUE;
                
            }
            break;
            
        case TAGID_CENTER:
        {
            BSTR szAlign = NULL;
            
            switch (tagIdChild)
            {
                case TAGID_P:
                case TAGID_DIV:
                    if (tagIdChild == TAGID_DIV)
                        IFR( CAlignment<IHTMLDivElement>().Get(IID_IHTMLDivElement, spChildElement, &szAlign) )
                    else
                        IFR( CAlignment<IHTMLParaElement>().Get(IID_IHTMLParaElement, spChildElement, &szAlign) );        

                    if (szAlign == NULL || StrCmpIW(szAlign, _T("center")) == 0)
                        hr = THR( bpChild.Morph(&bpChild, tagIdParent) );
                    else
                        hr = THR( MergeAttributes(_pElement, spChildElement) );

                    SysFreeString(szAlign);
                    IFR(hr);
                        
                    break;
                    
                default:
                    fNeedToInsertAbove = TRUE;
            }        
            break;
        }
            
        default:
            AssertSz(0, "unexpected block type");
            fNeedToInsertAbove = TRUE;
    }

    if (fNeedToInsertAbove)
    {
        IFR( GetMarkupServices()->CreateElement(tagIdParent, NULL, &spElement) );
        IFR( bpChild.InsertAbove(spElement, &bpChild) );
        IFR( MergeAttributes(_pElement, spElement) );
        IFR( bpChild.MoveToParent() );
    }
    
    return S_OK;
}

HRESULT 
CBlockPointer::FlattenNode()
{
    HRESULT             hr;
    CBlockPointer       bpChild(_pEd);
    CBlockPointer       bpTest(_pEd);
    CBlockPointer       bpLastChild(_pEd);
    CBlockPointer       bpParent(_pEd);
    ELEMENT_TAG_ID      tagIdNode;
    SP_IHTMLElement     spElement;
    
    Assert(GetType() == NT_Block && _pElement);

    IFR( GetMarkupServices()->GetElementTagId(_pElement, &tagIdNode) );
    if (tagIdNode == TAGID_BLOCKQUOTE)
        return S_FALSE; // don't flatten a blockquote    

    // Make sure parent doesn't overlap current node
    IFR( bpParent.MoveTo(this) );
    IFR( bpParent.MoveToParent() );
    IFR( bpParent.EnsureNoChildOverlap(this) );

    // Move to first child
    IFR( bpChild.MoveTo(this) );
    IFR( bpChild.MoveToFirstChild() );

    // For make sure we don't have a single text node (for perf reasons)
    if (bpChild.GetType() == NT_Text)
    {
        IFR( bpTest.MoveTo(&bpChild) );
        IFR( bpTest.MoveToSibling(RIGHT) );
        if (hr == S_FALSE)
            return S_FALSE; // nothing to do
    }
    
    if (hr == S_FALSE)
    {
        // no children, so we're done
        return S_FALSE;
    }

    do
    {
        switch (bpChild.GetType())
        {
            case NT_ListContainer:
            case NT_ListItem:
            case NT_Container:
                if (tagIdNode == TAGID_CENTER || HasAttributes())
                {
                    IFR( GetMarkupServices()->CreateElement(tagIdNode, NULL, &spElement) );
                    IFR( CopyAttributes(_pElement, spElement, FALSE) );
                    IFR( bpChild.InsertAbove(spElement, &bpChild, TAGID_NULL, NULL, FALSE) );
                }
                break;

            case NT_BlockLayout:
            case NT_Text:
            case NT_Control:                
            case NT_FlowLayout:
            case NT_TextBreak:
                // Insert element above all text nodes                
                IFR( GetMarkupServices()->CreateElement(tagIdNode, NULL, &spElement) );
                IFR( CopyAttributes(_pElement, spElement, FALSE) );

                // Expand to all leaf nodes
                IFR( bpLastChild.MoveTo(&bpChild) );
                if (bpChild.GetType() != NT_BlockLayout)
                {
                    IFR( bpLastChild.MoveToLastNodeInBlock() );
                }
                IFR( bpChild.InsertAbove(spElement, &bpLastChild, TAGID_NULL, NULL, FALSE) );
                IFR( bpChild.MoveTo(spElement) );

                // Current node could have changed above
                IFR( MoveTo(&bpChild) );
                IFR( MoveToParent() );
                break;
            
            case NT_Block:
                IFR( EnsureNoChildOverlap(&bpChild) );
                IFR( PushToChild(&bpChild) );
                break;

            default:
                AssertSz(0, "Unexpected block type");
        }
        IFR( bpChild.MoveToSibling(RIGHT) );
    } 
    while (hr == S_OK);

    spElement = _pElement;
    IFR( MoveToFirstChild() );    
    IFR( GetMarkupServices()->RemoveElement(spElement) );
    
    return S_OK;    
}

HRESULT 
CBlockPointer::FloatUp(CBlockPointer *pEnd, BOOL fCanChangeType)
{
    HRESULT             hr;
    CBlockPointer       bpParent(_pEd);
    CBlockPointer       bpPointer(_pEd);
    CEditPointer        epLeft(_pEd);
    SP_IMarkupPointer   spRight;
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagId;
    BOOL                bEqual;

#ifndef _PREFIX_
    Assert(IsSameScope(pEnd));
#endif
    
    IFR( GetEditor()->CreateMarkupPointer(&spRight) );

    // Move block pointer to parent
    IFR( bpParent.MoveTo(this) );
    IFR( bpParent.MoveToParent() );

    Assert(bpParent.GetType() != NT_BlockLayout
           && bpParent.GetType() != NT_FlowLayout
           && bpParent.GetType() != NT_Container
           && !bpParent.IsLeafNode());
    Assert(IsElementType());

    // Split the element influence

    IFR( GetMarkupServices()->GetElementTagId(bpParent._pElement, &tagId) );

    // Add left side
    
    IFR( bpParent.MovePointerTo(epLeft, ELEM_ADJ_AfterBegin) );
    IFR( MovePointerTo(spRight, ELEM_ADJ_BeforeBegin) );     
    IFR( epLeft.IsEqualTo(spRight, BREAK_CONDITION_Phrase, &bEqual) );
    if (!bEqual)
    {
        IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );    
        IFR( CopyAttributes(bpParent._pElement, spElement, TRUE) );
        IFR( InsertElement(GetMarkupServices(), spElement, epLeft, spRight) );
    }
    
    // Add right side
    IFR( pEnd->MovePointerTo(epLeft, ELEM_ADJ_AfterEnd) );
    IFR( bpParent.MovePointerTo(spRight, ELEM_ADJ_BeforeEnd) );     
    IFR( epLeft.IsEqualTo(spRight, BREAK_CONDITION_Phrase, &bEqual) );
    if (!bEqual)
    {
        IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );    
        IFR( CopyAttributes(bpParent._pElement, spElement, FALSE) );
        IFR( InsertElement(GetMarkupServices(), spElement, epLeft, spRight) );
    }    

    // Copy the DIR=LTR/RTL from the parent to the current element
    IFR( CopyRTLAttr(bpParent._pElement, _pElement));

    // Move bpParent up to true parent    
    spElement = bpParent._pElement;
 
    // Remove element
    IFR( GetMarkupServices()->RemoveElement(spElement) );

    if (fCanChangeType)
    {
        BOOL fFirstMorph = TRUE;
        
        // Make sure containership is ok
        IFR( bpPointer.MoveTo(this) );
        do
        {
            IFR( bpPointer.IsEqual(pEnd) );
            bEqual = (hr == S_OK);
            
            IFR( bpPointer.EnsureCorrectTypeForContainer() );
            if (fFirstMorph)
            {
                IFR( MoveTo(&bpPointer) );
                fFirstMorph = FALSE;
            }
            
            if (bEqual)
                break;

            IFR( bpPointer.MoveToSibling(RIGHT) );
            Assert(hr != S_FALSE);            
        }
        while (hr == S_OK); // just in case (this, bpPointer) are not siblings
    }

    // Flatten parent scope
    IFR( bpParent.MoveTo(this) );
    IFR( bpParent.MoveToParent() );
    if (bpParent.GetType() == NT_Block)
        IFR( bpParent.FlattenNode() );

    return S_OK;   
}

HRESULT
CBlockPointer::EnsureCorrectTypeForContainer()
{
    HRESULT         hr;
    CBlockPointer   bpParent(_pEd);
    ELEMENT_TAG_ID  tagId, tagIdParent, tagIdGoal;
        
    IFR( bpParent.MoveTo(this) );
    IFR( bpParent.MoveToParent() );    

    // Make sure list containership is still ok
    IFR( GetMarkupServices()->GetElementTagId(_pElement, &tagId) );
    IFR( GetMarkupServices()->GetElementTagId(bpParent._pElement, &tagIdParent) );

    if (IsListItem(tagId))
    {
        if (IsListContainer(tagIdParent))
        {
            if (!IsListCompatible(tagId, tagIdParent))
            {
                tagIdGoal = GetListItemType(tagIdParent);
                IFR( Morph(this, tagIdGoal) );
            }
        }
        else
        {
            // Not a list container, so convert to the default block tag 
            IFR( CGetBlockFmtCommand::GetDefaultBlockTag( GetMarkupServices(), &tagIdGoal) );
            IFR( Morph(this, tagIdGoal) );
        }
    }    
    else if (IsListContainer(tagIdParent) && !IsListContainer(tagId))
    {
        // Not a list container, so convert to the default block tag 
        tagIdGoal = GetListItemType(tagIdParent);
        IFR( Morph(this, tagIdGoal, tagIdParent) );
    }

    return S_OK;
 }

HRESULT
CBlockPointer::PrivateMorph(
    ELEMENT_TAG_ID  tagId)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagIdCurrent;

    Assert(IsElementType());

    IFR( GetMarkupServices()->GetElementTagId(_pElement, &tagIdCurrent) );
    if (tagIdCurrent == tagId)
        return S_OK;
    
    IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );    
    IFR( ReplaceElement(_pEd, _pElement, spElement) );
    ClearInterface(&_pElement);
    _pElement = spElement;
    _pElement->AddRef();

    IFR( GetElementNodeType(spElement, &_type) );

    Assert(IsElementType());

    return S_OK;
}

HRESULT 
CBlockPointer::Morph(
    CBlockPointer   *pEnd,
    ELEMENT_TAG_ID  tagIdDestination,
    ELEMENT_TAG_ID  tagIdContainer)
{
    HRESULT             hr;
    CBlockPointer       bpPointer(_pEd);

#ifndef _PREFIX_
    Assert(IsSameScope(pEnd));
#endif
    Assert(!IsListItem(tagIdDestination) || IsListCompatible(tagIdDestination, tagIdContainer));
    Assert(IsListItem(tagIdDestination) || tagIdContainer == TAGID_NULL);
    Assert(IsElementType());

    //
    // Replace the elements
    //

    IFR( PrivateMorph(tagIdDestination) );
    if (pEnd != this)
    {
        IFR( bpPointer.MoveTo(this) );
        while (!bpPointer.IsEqual(pEnd))
        {
            IFR( bpPointer.MoveToSibling(RIGHT) );
            Assert(hr != S_FALSE);

            IFR( bpPointer.PrivateMorph(tagIdDestination) );
        }
    }
    
    //
    // Check that the container matches the element type
    //

    IFR( EnsureContainer(pEnd, tagIdContainer) );

    if (IsListContainer(tagIdDestination))
    {
        IFR( MergeListContainers(LEFT) );
        IFR( MergeListContainers(RIGHT) );
    }
        
    return S_OK;
}

HRESULT
CBlockPointer::EnsureContainer(
    CBlockPointer *pEnd,
    ELEMENT_TAG_ID tagIdContainer)
{
    HRESULT             hr;
    ELEMENT_TAG_ID      tagId, tagIdParent;
    CBlockPointer       bpParent(_pEd);
    SP_IMarkupPointer   spLeft, spRight;
    SP_IHTMLElement     spElement;

    Assert(IsElementType() && _pElement);

    IFR( GetMarkupServices()->GetElementTagId(_pElement, &tagId) );
    
    if (IsListItem(tagId))
    {
        BOOL fNeedContainer = TRUE;
        
        IFR( bpParent.MoveTo(this) );
        IFR( bpParent.MoveToParent() );

        if (bpParent.GetType() == NT_ListContainer)
        {
            IFR( bpParent.GetElement(&spElement) );
            IFR( GetMarkupServices()->GetElementTagId(spElement, &tagIdParent) );

            if (!IsListCompatible(tagId, tagIdContainer) || tagIdParent != tagIdContainer)
            {   
                IFR( FloatUp(pEnd, FALSE) );
                IFR( bpParent.MoveTo(this) );
                IFR( bpParent.MoveToParent() );
            }
            else
            {
                fNeedContainer = FALSE;
            }
        }

        if (fNeedContainer)
        {
            // Add the list container
            IFR( GetMarkupServices()->CreateElement(tagIdContainer, NULL, &spElement) );
            IFR( InsertAbove(spElement, pEnd, TAGID_NULL, NULL, FALSE) );

            // Try list merging
            IFR( bpParent.MoveTo(this) );
            IFR( bpParent.MoveToParent() );
            IFR( bpParent.MergeListContainers(RIGHT) );
            IFR( bpParent.MergeListContainers(LEFT) );
        }
        
    }
    else if (!IsListContainer(tagId))
    {
        for (;;)
        {
            IFR( bpParent.MoveTo(this) );
            IFR( bpParent.MoveToParent() );

            if (bpParent.GetType() != NT_ListContainer)
                break;

            IFR( FloatUp(this, TRUE) );
        }
    }
    
    return S_OK;
}    

HRESULT
CBlockPointer::FindInsertPosition(IMarkupPointer *pStart, Direction dir)
{
    HRESULT             hr;
    CEditPointer        epLimit(_pEd);
    DWORD               dwSearch = BREAK_CONDITION_BLOCKPOINTER;
    DWORD               dwFound;
    BOOL                fEqual, fLeftOf, fRightOf;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spElementParent;
    NodeType            nodeType;
    SP_IMarkupPointer   spTest;
    BOOL                fIgnoreGlyphs = FALSE;

    Assert(IsElementType() && (dir == LEFT || dir == RIGHT));

    fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    IFC( GetEditor()->CreateMarkupPointer(&spTest) );
    IFC( epLimit->MoveToPointer(pStart) );

    // Find limit of node
    IFC( epLimit.Scan(dir, dwSearch, &dwFound) );
    IFC( epLimit.Scan(Reverse(dir), dwSearch, &dwFound) );

    // Check for quick out
    IFC( epLimit->IsEqualTo(pStart, &fEqual) );
    if (fEqual)
    {
        hr = S_OK; // done;
        goto Cleanup;
    }

    // Walk up looking for containing elements
    Assert(_pElement);
    spElement = _pElement;        
    for (;;)
    {
        // Get Parent element
        IFC( GetEditor()->GetParentElement( spElement, &spElementParent) );
        if (spElementParent == NULL)
            break;
        spElement = spElementParent;

        // Make sure we didn't get the parent block tree node
        IFC( GetElementNodeType(spElement, &nodeType) );
        if (nodeType != NT_Undefined)
            break; // done

        // Check if we are within the limit
        if (dir == LEFT)
        {
            IFC( spTest->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
            IFC( spTest->IsLeftOf(epLimit, &fLeftOf) );
            if (fLeftOf)
                break;
        }
        else
        {
            IFC( spTest->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
            IFC( spTest->IsRightOf(epLimit, &fRightOf) );
            if (fRightOf)
                break;
        }

        // Adjust to current test point
        IFC( pStart->MoveToPointer(spTest) );               
    }
    
Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    return S_OK;
}

HRESULT 
CBlockPointer::InsertAbove(IHTMLElement *pElement, CBlockPointer *pEnd, ELEMENT_TAG_ID tagIdListContainer, CCommand *pCmd,  BOOL fValidate)
{
    HRESULT             hr;
    SP_IMarkupPointer   spLeft, spRight;
    CBlockPointer       bpParent(_pEd);
    ELEMENT_TAG_ID      tagId;

    //
    // Make sure parent isn't a <P> tag
    //
    if (fValidate) 
    {
        IFR( bpParent.MoveTo(this) );
        IFR( bpParent.MoveToParent() );
        if (bpParent.GetType() == NT_Block)
        {
            SP_IHTMLElement spElement;
            ELEMENT_TAG_ID  tagIdParent;

            IFR( bpParent.GetElement(&spElement) );
            IFR( GetMarkupServices()->GetElementTagId(spElement, &tagIdParent) );
            if (tagIdParent == TAGID_P)
                IFR( bpParent.Morph(&bpParent, TAGID_DIV) );
        }
    }

    //
    // Insert above
    //
    IFR( GetEditor()->CreateMarkupPointer(&spLeft) );
    IFR( GetEditor()->CreateMarkupPointer(&spRight) );

    IFR( MovePointerTo(spLeft, ELEM_ADJ_BeforeBegin) );
    if (GetType() == NT_Control)
        IFR( FindInsertPosition(spLeft, LEFT) );
    
    IFR( pEnd->MovePointerTo(spRight, ELEM_ADJ_AfterEnd) );
    if (pEnd->GetType() == NT_Control)
        IFR( pEnd->FindInsertPosition(spRight, RIGHT) );

    if (pCmd)
        IFR( pCmd->InsertBlockElement(pElement, spLeft, spRight) )
    else
        IFR( GetMarkupServices()->InsertElement(pElement, spLeft, spRight) );

    //
    // Ensure containership is of the right type
    //

    if (tagIdListContainer != TAGID_NULL)
    {
        IFR( bpParent.MoveTo(this) );
        IFR( bpParent.MoveToParent() );
        IFR( bpParent.EnsureContainer(&bpParent, tagIdListContainer) );
    }

    //
    // Check for list merge case
    //

    IFR( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    if (IsListContainer(tagId))
    {
        IFR( bpParent.MoveTo(pElement) );
        IFR( bpParent.MergeListContainers(LEFT) );
        IFR( bpParent.MergeListContainers(RIGHT) );
    }    

    return S_OK;
}

BOOL 
CBlockPointer::HasAttributes()
{
    HRESULT hr;
    UINT    uCount;
    
    Assert(IsElementType() && _pElement);

    IFC( _pEd->GetElementAttributeCount(_pElement, &uCount) );

    return (uCount != 0);

Cleanup:
    return TRUE;
}

HRESULT 
CBlockPointer::IsEqual(CBlockPointer *pOtherNode)
{
    HRESULT             hr;
    SP_IMarkupPointer   spThis;
    SP_IMarkupPointer   spOther;
    BOOL                bEqual;

    IFR( GetEditor()->CreateMarkupPointer(&spThis) );
    IFR( GetEditor()->CreateMarkupPointer(&spOther) );

    // Check left
    IFR( MovePointerTo(spThis, ELEM_ADJ_BeforeBegin) );
    IFR( pOtherNode->MovePointerTo(spOther, ELEM_ADJ_BeforeBegin) );

    IFR( spThis->IsEqualTo(spOther, &bEqual) );
    if (!bEqual)   
        return S_FALSE;

    // Check right        
    IFR( MovePointerTo(spThis, ELEM_ADJ_AfterEnd) );
    IFR( pOtherNode->MovePointerTo(spOther, ELEM_ADJ_AfterEnd) );

    IFR( spThis->IsEqualTo(spOther, &bEqual) );
    if (!bEqual)   
        return S_FALSE;
    
    return S_OK;
}

HRESULT     
CBlockPointer::GetElementNodeType(IHTMLElement *pElement, NodeType *pNodeType)
{
    HRESULT         hr;
    BOOL            fLayout;
    BOOL            fBlock;
    ELEMENT_TAG_ID  tagId;

    *pNodeType = NT_Undefined;

    IFR( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
        
    if (IsListContainer(tagId))
    {
        *pNodeType = NT_ListContainer;
        return S_OK;        
    }

    // TODO: clean this up and verify correctness [ashrafm]
    switch (tagId)
    {
            // For BRs, we use this special node type (bug 77466)
        case TAGID_BR:
            *pNodeType = NT_TextBreak;
            break;

        case TAGID_BUTTON:
        case TAGID_TEXTAREA:
//        case TAGID_HTMLAREA:
        case TAGID_FIELDSET:
        case TAGID_LEGEND:
        case TAGID_SELECT:
        case TAGID_APPLET:
        case TAGID_IMG:
        case TAGID_INPUT:
        case TAGID_OBJECT:
            // IFRAME should be treated as a control
        case TAGID_IFRAME:
            *pNodeType = NT_Control;
            break;

        case TAGID_ADDRESS:
        case TAGID_BLOCKQUOTE:
        case TAGID_CENTER:
        case TAGID_H1:
        case TAGID_H2:
        case TAGID_H3:
        case TAGID_H4:
        case TAGID_H5:
        case TAGID_H6:
        case TAGID_P:
        case TAGID_PRE:
        case TAGID_DIV:
            *pNodeType = NT_Block;
            break;

        case TAGID_CAPTION:
        case TAGID_FRAME:
        case TAGID_FRAMESET:
            // MARQUEE should be treated as a block layout
        case TAGID_MARQUEE:
        case TAGID_TABLE:
        case TAGID_FORM:
        case TAGID_HR:
            *pNodeType = NT_BlockLayout;
            break;

        case TAGID_TD:
        case TAGID_HTML:
        case TAGID_BODY:
        case TAGID_TR:
        case TAGID_TBODY:
            *pNodeType = NT_Container;
            break;

        case TAGID_LI:
        case TAGID_DD:
        case TAGID_DT:
            *pNodeType = NT_ListItem;
            break;

            //For colgroup, we want to return S_FALSE so we don't use it as a 
            //node.
        case TAGID_COLGROUP:
            *pNodeType = NT_Block;
            return S_FALSE;
    }

    // Check for layout in block case
    if (*pNodeType == NT_Block || *pNodeType == NT_Undefined)
    {
        IFR(IsBlockOrLayoutOrScrollable(pElement, &fBlock, &fLayout));

        if (fBlock && *pNodeType == NT_Undefined)
        {
            *pNodeType = NT_Block;
        }
        if (fLayout)
        {
            *pNodeType = (*pNodeType == NT_Block) ? NT_BlockLayout : NT_FlowLayout;
        }
        if (!fBlock && *pNodeType == NT_Block)
        {
            // We have an element that is normally block but 
            // has been set to inline (see bug 102219)
            *pNodeType = NT_Undefined;
        }
    }

    // TODO: we need to check for list items here [ashrafm]

    return S_OK;
}

void
CBlockPointer::ClearPointers()
{
    if (_type == NT_Undefined)
        return;
        
    if (IsElementType())
    {
        ClearInterface(&_pElement);
    }
    else
    {
        ClearInterface(&_pLeft);
        ClearInterface(&_pRight);
    }

    _type = NT_Undefined;
}

BOOL 
CBlockPointer::IsElementType()
{
    switch(_type)
    {
        case NT_Block:
        case NT_Control:
        case NT_ListContainer:
        case NT_BlockLayout:
        case NT_FlowLayout:
        case NT_ListItem:
        case NT_Container:
        case NT_TextBreak:
            return TRUE;
            
        case NT_Text:
            return FALSE;
    }

    AssertSz(0, "Invalid CBlockPointer type");
    return FALSE;
}

BOOL
CBlockPointer::IsColgroup()
{
    ELEMENT_TAG_ID  tagId;

    if (_type != NT_Block)
        return FALSE;

    GetMarkupServices()->GetElementTagId(_pElement, &tagId);
    
    return tagId == TAGID_COLGROUP;
}

BOOL
CBlockPointer::IsColgroup(IHTMLElement * pElement)
{
    ELEMENT_TAG_ID  tagId;

    GetMarkupServices()->GetElementTagId(pElement, &tagId);

    return tagId == TAGID_COLGROUP;
}

HRESULT     
CBlockPointer::MovePointerTo(IMarkupPointer *pPointer, ELEMENT_ADJACENCY elemAdj )
{
    HRESULT hr;
    
    if (IsElementType())
    {
        if (IsLeafNode())
        {
            switch (elemAdj)
            {   
                case ELEM_ADJ_AfterBegin:
                    elemAdj = ELEM_ADJ_BeforeBegin;
                    break;
                    
                case ELEM_ADJ_BeforeEnd:
                    elemAdj = ELEM_ADJ_AfterEnd;
                    break;
            }
        }
        IFR( pPointer->MoveAdjacentToElement(_pElement, elemAdj) );
    }
    else
    {
        switch (elemAdj)
        {   
            case ELEM_ADJ_BeforeBegin:
            case ELEM_ADJ_AfterBegin:
                IFR( pPointer->MoveToPointer(_pLeft) );
                break;
                
            case ELEM_ADJ_BeforeEnd:
            case ELEM_ADJ_AfterEnd:
                IFR( pPointer->MoveToPointer(_pRight) );
                break;

            default:
                AssertSz(0, "unexpected adjacency type");
        }
            
    }

    return S_OK;
}

BOOL 
CBlockPointer::IsListCompatible(ELEMENT_TAG_ID tagIdListItem, ELEMENT_TAG_ID tagIdListContainer)
{
    Assert(IsListItem(tagIdListItem));
    Assert(IsListContainer(tagIdListContainer));

    switch (tagIdListItem)
    {
    case TAGID_LI:
        return (tagIdListContainer == TAGID_OL || tagIdListContainer == TAGID_UL
                || tagIdListContainer == TAGID_MENU || tagIdListContainer == TAGID_DIR);
        
    case TAGID_DD:
    case TAGID_DT:
        return (tagIdListContainer == TAGID_DL);

    default:
        AssertSz(0, "Unexpected list item");
        return TRUE;
    }    
}

ELEMENT_TAG_ID 
CBlockPointer::GetListItemType(ELEMENT_TAG_ID tagIdListContainer)
{
    Assert(IsListContainer(tagIdListContainer));

    if (tagIdListContainer == TAGID_DL)
        return TAGID_DD;

#if DBG==1    
    switch (tagIdListContainer)
    {
    case TAGID_OL:
    case TAGID_UL:
    case TAGID_MENU:
    case TAGID_DIR:
        break;

    default:
        AssertSz(0, "unexpected list container");
    }
#endif 

    return TAGID_LI;
}

#if DBG==1
BOOL 
CBlockPointer::IsSameScope(CBlockPointer *pOtherNode)
{
    HRESULT         hr;
    CBlockPointer   bpParent(_pEd);
    CBlockPointer   bpParentOther(_pEd);

    IFC( bpParent.MoveTo(this) );
    IFC( bpParent.MoveToParent() );

    IFC( bpParentOther.MoveTo(this) );
    IFC( bpParentOther.MoveToParent() );

    return (bpParent.IsEqual(&bpParentOther) == S_OK);
    
Cleanup:
    return FALSE;
}
#endif

HRESULT 
CBlockPointer::MergeListContainers(Direction dir)
{
    HRESULT             hr;
    CBlockPointer       bpCurrent(_pEd);
    SP_IHTMLElement     spOtherElement;
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagIdMain;
    ELEMENT_TAG_ID      tagIdOther;
    CBlockPointer       bpParent(_pEd);
    
    Assert(IsElementType() && _pElement);

    //
    // Find the other element
    //

    IFC( bpCurrent.MoveTo(this) );
    Assert(bpCurrent.GetType() == NT_ListContainer);

    IFC( bpCurrent.MoveToSibling(dir) );
    if (hr == S_FALSE)
    {
        //
        // We may be a nested list container, so try merging the parent list container
        //
        IFC( bpParent.MoveTo(&bpCurrent) );
        IFC( bpParent.MoveToParent() );

        if (hr == S_FALSE)
        {
            hr = S_FALSE;
            goto Cleanup;
        }

        if (bpParent.GetType() == NT_ListItem && dir == RIGHT)
        {
            // Check for <li>....<ol>...</ol></li> + <ol=bpCurrent>...</ol> merge
            IFC( bpCurrent.MoveToSibling(dir) );
            if (hr != S_FALSE)
            {
                hr = S_FALSE;
                goto Cleanup;
            }

            IFC( bpCurrent.FloatUp(&bpCurrent, FALSE) );

            IFC( bpParent.MoveTo(&bpCurrent) );
            IFC( bpParent.MoveToParent() );
        }

        if (bpParent.GetType() != NT_ListContainer)
        {
            hr = S_FALSE;
            goto Cleanup;
        }

        IFC( bpParent.MergeListContainers(dir) );
        if (hr == S_FALSE)
            goto Cleanup;
    }

    if (bpCurrent.GetType() == NT_ListItem && dir == LEFT)
    {
        // Check for <li>....<ol>...</ol></li> + <ol=bpCurrent>...</ol> merge
        IFC( bpCurrent.MoveToLastChild() );
        if (bpCurrent.GetType() == NT_ListContainer)
            IFC( bpCurrent.FloatUp(&bpCurrent, FALSE) );
    }

    if (hr == S_FALSE || bpCurrent.GetType() != NT_ListContainer)
        return S_FALSE; // can't merge 

    //
    // Check that both elements are of the same type
    //    

    IFC( GetMarkupServices()->GetElementTagId(_pElement, &tagIdMain) );

    IFC( bpCurrent.GetElement(&spOtherElement) );
    IFC( GetMarkupServices()->GetElementTagId(spOtherElement, &tagIdOther) );

    if (tagIdMain != tagIdOther)
        return S_FALSE;

    //
    // Do the merge
    //

    IFC( GetMarkupServices()->CreateElement(tagIdMain, NULL, &spElement) );
    IFC( CopyAttributes(_pElement, spElement, TRUE) );

    if (dir == LEFT)        
        IFC( bpCurrent.InsertAbove(spElement, this) )
    else
        IFC( InsertAbove(spElement, &bpCurrent) );
    
    spElement = _pElement;
    IFC( MoveToParent() );

    IFC( GetMarkupServices()->RemoveElement(spOtherElement) );
    IFC( GetMarkupServices()->RemoveElement(spElement) ); 

Cleanup:
    RRETURN1(hr, S_FALSE);
}

// Copy the RTL Attribute from one element to another
HRESULT
CBlockPointer::CopyRTLAttr( IHTMLElement * pSrcElement, IHTMLElement * pDestElement)
{
    HRESULT hr = S_OK;
    IHTMLElement2 *pSrcElem2 = NULL;
    IHTMLElement2 *pDestElem2 = NULL;
    BSTR bstrSrc = NULL;
    BSTR bstrDest = NULL;

    IFC( pSrcElement->QueryInterface(IID_IHTMLElement2,(LPVOID*)&pSrcElem2) );
    if(!pSrcElem2) 
        goto Cleanup;
    
    IFC( pSrcElem2->get_dir(&bstrSrc) );

    IFC( pDestElement->QueryInterface(IID_IHTMLElement2,(LPVOID*)&pDestElem2) );
    if(!pDestElem2) 
        goto Cleanup;
    
    IFC( pDestElem2->get_dir(&bstrDest) );

    if (StrCmpIW(bstrSrc, bstrDest) != 0)
        IFC( pDestElem2->put_dir(bstrSrc) );

Cleanup:
    ReleaseInterface(pSrcElem2);
    ReleaseInterface(pDestElem2);
    SysFreeString(bstrSrc);
    SysFreeString(bstrDest);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CBlockPointer::IsEmpty
//
//  Synopsis:   Determines whether the current block is empty or not.
//
//  Arguments:  pfEmpty = Pointer to flag to determine if empty or not
//
//  Returns:    HRESULT indicating whether the function was successful
//
//--------------------------------------------------------------------------
HRESULT
CBlockPointer::IsEmpty(BOOL *pfEmpty, BOOL fIgnorePhraseElements /*=TRUE */)
{
    HRESULT             hr;
    CEditPointer        epLeft(_pEd);
    CEditPointer        epRight(_pEd);
    BOOL                bEmpty = FALSE;
    DWORD               dwSearch = BREAK_CONDITION_BLOCKPOINTER;
    DWORD               dwFound;
    BOOL                fIgnoreGlyphs = FALSE;

    Assert( pfEmpty );

    fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);
    
    // See if we want to ignore phrase elements
    if( !fIgnorePhraseElements )
    {
        dwSearch |= BREAK_CONDITION_Phrase;
    }
    
    // Create  the markup pointers, and position them after the 
    // beginning and before the end
    IFC( MovePointerTo(epLeft, ELEM_ADJ_AfterBegin) );
    IFC( MovePointerTo(epRight, ELEM_ADJ_BeforeEnd) );

    // Scan right
    IFC( epLeft.Scan(RIGHT, dwSearch, &dwFound, NULL) );

    // Empty only if we didn't find an element before the end
    IFC( epLeft->IsRightOf( epRight, &bEmpty  ) );

Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    *pfEmpty = bEmpty;

    return S_OK;
}

HRESULT 
CListCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{  
    HRESULT             hr = S_OK;
    OLECMD              cmd;
    CSegmentListIter    iter;
    SP_ISegmentList     spSegmentList;
    IMarkupPointer      *pStart, *pEnd;
    CEdUndoHelper       undoUnit(GetEditor());
    SP_IDisplayPointer  spCaretMarker;

    //
    // Validation of command
    //
    
    IFR( CommonQueryStatus(&cmd, NULL) );
    if (hr != S_FALSE)
    {
        if (cmd.cmdf == MSOCMDSTATE_DISABLED)
            return E_FAIL;        

        RRETURN(hr);
    }

    IFR( GetSegmentList(&spSegmentList) );
    IFR( iter.Init(GetEditor(), spSegmentList) );
    IFR( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
    for (;;)
    {
        IFR( iter.Next(&pStart, &pEnd) );
        if (hr == S_FALSE)
            return S_OK; // done

        IFR( AdjustSegment(pStart, pEnd) );

        // NOTE: CreateCaretMarker fails when there is no caret.  This is
        // a common case when executing commands through the range

        IGNORE_HR( CreateCaretMarker(&spCaretMarker) );
        IFR( ApplyListCommand(pStart, pEnd, FALSE, TRUE) );
        IGNORE_HR( RestoreCaret(spCaretMarker) );
    }
    

    if (pvarargOut)
    {
        VariantInit(pvarargOut);
        return E_NOTIMPL;
    }
    
    return S_OK;
}

HRESULT 
CBlockFmtListCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{  
    HRESULT             hr = S_OK;
    OLECMD              cmd;
    CSegmentListIter    iter;
    SP_ISegmentList     spSegmentList;
    IMarkupPointer      *pStart, *pEnd;
    CEdUndoHelper       undoUnit(GetEditor());
    SP_IDisplayPointer  spCaretMarker;

    //
    // Validation of command
    //
    
    IFR( CommonQueryStatus(&cmd, NULL) );
    if (hr != S_FALSE)
    {
        if (cmd.cmdf == MSOCMDSTATE_DISABLED)
            return E_FAIL;        

        RRETURN(hr);
    }

    IFR( GetSegmentList(&spSegmentList) );
    IFR( iter.Init(GetEditor(), spSegmentList) );
    IFR( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
    for (;;)
    {
        IFR( iter.Next(&pStart, &pEnd) );
        if (hr == S_FALSE)
            return S_OK; // done

        IFR( AdjustSegment(pStart, pEnd) );

        // NOTE: CreateCaretMarker fails when there is no caret.  This is
        // a common case when executing commands through the range

        IGNORE_HR( CreateCaretMarker(&spCaretMarker) );        
        IFR( ApplyListCommand(pStart, pEnd, FALSE, FALSE) );
        IGNORE_HR( RestoreCaret(spCaretMarker) );
    }
    

    if (pvarargOut)
    {
        VariantInit(pvarargOut);
        return E_NOTIMPL;
    }
    
    return S_OK;
}

HRESULT
CListCommand::ApplyListCommand(IMarkupPointer *pStart, IMarkupPointer *pEnd, BOOL fQueryMode, BOOL fCanRemove)
{
    HRESULT             hr;
    SP_IMarkupPointer   spStart, spEnd;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spListContainer;
    SP_IHTMLElement     spListItem;
    ELEMENT_TAG_ID      tagId;

    IFR( CopyMarkupPointer(GetEditor(), pStart, &spStart) );
    IFR( CopyMarkupPointer(GetEditor(), pEnd, &spEnd) );

    //
    // This command has 3 modes:
    //
    //   A. Create a list type
    //   B. Change list type
    //   C. Remove current list
    //
    // We now need to decide which mode we are in.  The algorithm is:
    //   1. Find the common node
    //   2. Find the list container (or list item) above.  If we find one that is not
    //      equal to the current list type, we are in case B.
    //   3. Otherwise, if we find a list container that is equal to the current list type,
    //      we are in case C.
    //   4. Otherwise, we are in case A.
    //

    //
    // Find common element
    //
    
    IFR( ClingToText(spStart, RIGHT, pEnd) );    
    IFR( ClingToText(spEnd, LEFT, spStart) );    
    IFR( GetEditor()->FindCommonElement(spStart, spEnd, &spElement, TRUE, TRUE) );

    if (spElement != NULL)
    {
        // Check for case B/C
        IFR( FindListContainer(GetMarkupServices(), spElement, &spListContainer));
        if (spListContainer != NULL)
        {
            IFR( GetMarkupServices()->GetElementTagId(spListContainer, &tagId) );

            if (GetListContainerType() != tagId || !fCanRemove)
            {
                if (fQueryMode)
                    return S_OK; // ok to apply list
                            
                IFR( ChangeListType(spListContainer, NULL, FALSE, spStart, spEnd) ); // case C

                // For DD/DT case, we need to change the actual listitem type as well as the container
                if (hr == S_FALSE && (_tagId == TAGID_DD || _tagId == TAGID_DT))
                {
                    // Check for common list item first
                    IFR( CreateList(pStart, pEnd, TRUE) );
                }
            }
            else
            {
                if (fQueryMode)
                    return S_FALSE; // ok to remove list
                    
                IFR( RemoveList(spStart, spEnd, spListContainer) ); // case B
            }
                
            return S_OK;
        }
        
    }

    // We are in case A - create the list
    
    if (fQueryMode)
        return S_OK; // ok to Apply list    
        
    IFR( CreateList(pStart, pEnd, TRUE) );
    
    return S_OK;
}

HRESULT 
CListCommand::SetCurrentTagId(ELEMENT_TAG_ID tagId, ELEMENT_TAG_ID *ptagIdOld)
{
    if (ptagIdOld)
        *ptagIdOld = _tagId;

    _tagId = tagId;

    return S_OK;
}

HRESULT 
CListCommand::PrivateQueryStatus( OLECMD * pCmd, 
                            OLECMDTEXT * pcmdtext )
{
    HRESULT             hr = S_OK;
    SP_ISegmentList     spSegmentList;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup ;
    }
#endif

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE)
        goto Cleanup;

    pCmd->cmdf = MSOCMDSTATE_UP; // up by default

    IFC( GetSegmentList(&spSegmentList) );

#if DBG==1    
    BOOL fEmpty;
    IFR( spSegmentList->IsEmpty( &fEmpty ) );
    Assert(!fEmpty );
#endif    

    IFR( GetFirstSegmentPointers(spSegmentList, &spStart, &spEnd) );    
    IFR( ApplyListCommand(spStart, spEnd, TRUE, TRUE) );    
    if (hr == S_FALSE)
        pCmd->cmdf = MSOCMDSTATE_DOWN;

    hr = S_OK;
    
Cleanup:
    return hr;
}

ELEMENT_TAG_ID 
CListCommand::GetListContainerType()
{
    if (IsListContainer(_tagId))
        return _tagId;

    Assert(IsListItem(_tagId));
    
    switch (_tagId)   
    {
        case TAGID_DD:
        case TAGID_DT:
            return TAGID_DL;
    }

    AssertSz(0, "unexpected list command");
    return TAGID_NULL;
}

ELEMENT_TAG_ID 
CListCommand::GetListItemType()
{
    if (IsListItem(_tagId))
        return _tagId;

    Assert(IsListContainer(_tagId));
    return TAGID_LI;
}

ELEMENT_TAG_ID  
CListCommand::GetListItemType(IHTMLElement *pListContainer)
{
    HRESULT             hr;
    ELEMENT_TAG_ID      tagId;

    IFC( GetMarkupServices()->GetElementTagId(pListContainer, &tagId) );
    if (tagId == TAGID_DL)
        return TAGID_DD;

Cleanup:
    return TAGID_LI;
}

HRESULT         
CListCommand::CreateList(IMarkupPointer *pStart, IMarkupPointer *pEnd, BOOL fAdjustOut)
{   
    HRESULT             hr;
    SP_IHTMLElement     spElement, spListItem, spNewContainer;
    SP_IMarkupPointer   spLimit;
    CBlockPointer       bpCurrent(GetEditor());
    CBlockPointer       bpCurrentStart(GetEditor());
    CBlockPointer       bpEnd(GetEditor());
    SP_IMarkupPointer   spLeft, spRight;
    ELEMENT_TAG_ID      tagId;

    // Start with first list item scope
    IFR( bpCurrent.MoveTo(pStart, RIGHT) );
    if (fAdjustOut)
        IFR( ForceScope(&bpCurrent) );

    // Do the fuzzy adjust
    IFR( GetEditor()->CreateMarkupPointer(&spLimit) );
    IFR( spLimit->SetGravity(POINTER_GRAVITY_Right) );
    
    IFR( spLimit->MoveToPointer(pEnd) );

    if (fAdjustOut)
        IFR( FuzzyAdjustOut(&bpCurrent, spLimit) );

    // Flatten first node if necessary
    if (bpCurrent.GetType() == NT_Block)
        IFR( bpCurrent.FlattenNode() );

    // 
    // Create list type
    //  

    do
    {
        switch (bpCurrent.GetType())
        {
        case NT_Text:
        case NT_Control:
        case NT_FlowLayout:
        case NT_TextBreak:
            IFR( bpCurrentStart.MoveTo(&bpCurrent) );
            IFR( bpCurrent.MoveToLastNodeInBlock() );
            IFR( GetMarkupServices()->CreateElement(GetListItemType(), NULL, &spElement) );            
            IFR( bpCurrentStart.InsertAbove(spElement, &bpCurrent, GetListContainerType(), this) );
            break;
            
        case NT_BlockLayout:             
            IFR( GetMarkupServices()->CreateElement(GetListItemType(), NULL, &spElement) );            
            IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, GetListContainerType(), this) );
            break;
            
        case NT_Block:
        case NT_ListItem:
            tagId = TAGID_NULL;
        
            IFR( bpCurrent.GetElement(&spElement) );
            if (spElement != NULL)
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

            switch (tagId)
            {
                case TAGID_BLOCKQUOTE:
                    if (spLeft == NULL)
                    {
                        IFR( GetEditor()->CreateMarkupPointer(&spLeft) );
                        IFR( spLeft->SetGravity(POINTER_GRAVITY_Left) );
                    }

                    if (spRight == NULL)
                    {
                        IFR( GetEditor()->CreateMarkupPointer(&spRight) );
                        IFR( spRight->SetGravity(POINTER_GRAVITY_Right) );
                    }

                    IFR( bpCurrent.MovePointerTo(spLeft, ELEM_ADJ_AfterBegin) );
                    IFR( bpCurrent.MovePointerTo(spRight, ELEM_ADJ_BeforeEnd) );

                    IFR( CreateList(spLeft, spRight) );
                    IFR( bpCurrent.Morph(&bpCurrent, GetListContainerType()) );
                    break;
                    
                case TAGID_P:
                case TAGID_DIV:
                case TAGID_PRE:
                    if (!bpCurrent.HasAttributes())
                    {
                        IFR( bpCurrent.Morph(&bpCurrent, GetListItemType(), GetListContainerType()) );
                        break;
                    }
                    // Otherwise, fall through
                    
                default:
                    if (IsListItem(tagId))
                    {
                        IFR( bpCurrent.Morph(&bpCurrent, GetListItemType(), GetListContainerType()) );
                    }
                    else
                    {
                        SP_IHTMLElement spCurrentElement;
                        SP_IHTMLElement spParentElement;
                        CBlockPointer   bpParent(GetEditor());
                        
                        IFR( GetMarkupServices()->CreateElement(GetListItemType(), NULL, &spElement) );            
                        IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, GetListContainerType(), this) );
                        if (tagId == TAGID_P || tagId == TAGID_DIV || tagId == TAGID_PRE)
                        {
                            if(tagId == TAGID_P)
                                IFR( bpCurrent.Morph(&bpCurrent, TAGID_DIV) );

                            IFR( bpCurrent.GetElement(&spCurrentElement) );
                            IFR( bpParent.MoveTo(&bpCurrent) );
                            IFR( bpParent.MoveToParent() );

                        }
                        else
                        {
                            IFR( bpCurrent.GetElement(&spCurrentElement) );
                            IFR( bpParent.MoveTo(&bpCurrent) );
                        }

                        IFR( bpParent.MoveToParent() );

                        // we always want to move the direction to the list container
                        // if we didn't land on it, just put it on the list item
                        if(bpParent.GetType() == NT_ListContainer)
                        {
                            IFR( bpParent.GetElement(&spParentElement) );
                            IFR( MoveRTLAttr(spCurrentElement, spParentElement) );
                        }
                        else
                            IFR( MoveRTLAttr(spCurrentElement, spElement) );
                    }
            }            
            break;
            
        case NT_ListContainer:
            IFR( bpCurrent.GetElement(&spElement) );
            IFR( ChangeListType(spElement, &spNewContainer, TRUE /* Morph list items */) );
            IFR( bpCurrent.MoveTo(spNewContainer) );
            break;

        default:
            AssertSz(0, "unexpected block type");         
        }

        //
        // Move to next logical block
        //
        IFR( bpCurrent.MoveToNextLogicalBlock(spLimit, TRUE) );        
    } 
    while (hr != S_FALSE);

    return S_OK;
}

HRESULT
CListCommand::MoveRTLAttr(IHTMLElement *pSourceElement, IHTMLElement *pDestElement)
{
    HRESULT             hr; 
    BSTR                bstrDir = NULL;
    SP_IHTMLElement2    spSourceElement2;
    SP_IHTMLElement2    spDestElement2;

    IFC( pSourceElement->QueryInterface(IID_IHTMLElement2,(LPVOID*)&spSourceElement2) );
    IFC( spSourceElement2->get_dir(&bstrDir) );

    if (bstrDir && StrCmpIW(bstrDir, L""))
    {
        IFC( pDestElement->QueryInterface(IID_IHTMLElement2,(LPVOID*)&spDestElement2) );
        IFC( spDestElement2->put_dir(bstrDir) );
        IFC( spSourceElement2->put_dir(L"") );
    }

Cleanup:
    SysFreeString(bstrDir);    
    RRETURN(hr);
}

HRESULT         
CListCommand::RemoveList(IMarkupPointer *pStart, IMarkupPointer *pEnd, IHTMLElement *pListContainer)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;
    CBlockPointer       bpStart(GetEditor()), bpEnd(GetEditor());
    CBlockPointer       bpListContainer(GetEditor());
    CBlockPointer       bpTest(GetEditor());
    CEditPointer        epLimit(GetEditor());
    DWORD               dwSearch, dwFound;
    INT                 cFloatUp;

#if DBG==1
    ELEMENT_TAG_ID tagId;
    Assert(S_OK == GetMarkupServices()->GetElementTagId(pListContainer, &tagId));
    Assert(IsListContainer(tagId));
#endif

    IFR( bpListContainer.MoveTo(pListContainer) );

    //
    // We know that pStart/pEnd are in list items that are contained in pListContainer.
    // Thus, find the list items, and float the range up to remove the list
    //

    // Find the left list item
    IFR( bpStart.MoveTo(pStart, RIGHT) );
    IFR( bpStart.MoveToScope( &bpListContainer) );

    // Find the right list item
    IFR( bpEnd.MoveTo(pEnd, LEFT) );
    IFR( bpEnd.MoveToScope( &bpListContainer) );

    // Remember limit
    IFR( bpEnd.MovePointerTo(epLimit, ELEM_ADJ_AfterEnd) );
    
    // Remove the list
    // NOTE: parser drops </LI>'s, so keep floating while at an </LI> boundary

    IFR( bpTest.MoveTo(&bpEnd) );    
    IFR( bpTest.MoveToSibling(RIGHT) );
    if (hr == S_FALSE)
    {
        IFR( bpTest.MoveToParent() );

        cFloatUp = 1; // we're going to FloatUp with morph below
        for (;;)
        {
            IFR( bpTest.MoveToSibling(RIGHT) );
            if (hr != S_FALSE)
                break;

            IFR( bpTest.MoveToParent() );
            if (hr == S_FALSE || bpTest.GetType() != NT_ListItem)
                break;

            ++cFloatUp;        
        }

        for (INT i = 0; i < cFloatUp - 1; ++i)
        {
            IFR( bpStart.FloatUp(&bpEnd, FALSE /* fFixupBlockType */) );
        }
    }

    IFR( bpStart.FloatUp(&bpEnd, TRUE /* fFixupBlockType */ ) );

    // Adjust limit out
    dwSearch = BREAK_CONDITION_BLOCKPOINTER;
    IFR( epLimit.Scan(RIGHT, dwSearch - BREAK_CONDITION_ExitBlock, &dwFound) );
    IFR( epLimit.Scan(LEFT, dwSearch, &dwFound) );
    
    // Flatten all children
    if (bpStart.GetType() == NT_Block)
        IFR( bpStart.FlattenNode() );
        
    do
    {
        IFR( bpStart.MoveToNextLogicalBlock(epLimit, TRUE) );
    }
    while (hr != S_FALSE);

    return S_OK;
}

//
//  CListCommand::ChangeListsChildListsTypes
//
//  (The name of the function should be read as Change List's Child List's Types.)
//  We recurse through the child of bpbCurrent looking for list containers. When
//  we find one, we call ChangeListType().
//
//  Pretty simple really.
//

HRESULT
CListCommand::ChangeListsChildListsTypes(
    CBlockPointer   *pbpCurrent, 
    BOOL            fMorphListItems     /* = FALSE */,
    IMarkupPointer  *pSelectionStart    /* = NULL */,
    IMarkupPointer  *pSelectionEnd      /* = NULL */)
{
    HRESULT             hr;
    CBlockPointer       bpChild(GetEditor());
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spElementNew;
    ELEMENT_TAG_ID      tagId;
    SP_IMarkupPointer   spTest;

    // pSelectionStart implies pSelectionEnd
    Assert(pSelectionStart == NULL || pSelectionEnd != NULL);

    // pSelectionEnd implies pSelectionStart
    Assert(pSelectionStart != NULL || pSelectionEnd == NULL);

    if (pSelectionStart)
    {
        IFC( GetEditor()->CreateMarkupPointer(&spTest) );
    }

    IFC( bpChild.MoveTo(pbpCurrent) );
    IFC( bpChild.MoveToFirstChild() );
    while (hr == S_OK)
    {
        if (bpChild.GetType() == NT_ListContainer)
        {
            BOOL fMorph = TRUE;

            // If we have a selection, only morph if the list container intersects
            // the selection.
            if (pSelectionStart)
            {
                IFC( bpChild.MovePointerTo(spTest, ELEM_ADJ_AfterBegin) );
                IFC( spTest->IsLeftOf(pSelectionEnd, &fMorph) );
                if (fMorph)
                {
                    IFC( bpChild.MovePointerTo(spTest, ELEM_ADJ_BeforeEnd) );
                    IFC( spTest->IsRightOf(pSelectionStart, &fMorph) );
                }
            }
            
            if (fMorph)
            {
                IFC( bpChild.GetElement(&spElement) );
                if (spElement != NULL)
                {
                    IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

                    if (GetListContainerType() != tagId)
                    {
                        // Calling ChangeListType will call ChangeListsChildListTypes
                        IFC( ChangeListType(spElement, &spElementNew, fMorphListItems, pSelectionStart, pSelectionEnd) );
                        IFC( bpChild.MoveTo(spElementNew) );
                    }
                }
            }
        }
        else
        {
            IFC( ChangeListsChildListsTypes(&bpChild, fMorphListItems, pSelectionStart, pSelectionEnd) );
        }
        IFC( bpChild.MoveToSibling(RIGHT) );
    }

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}

HRESULT
CListCommand::ChangeListType(
    IHTMLElement    *pListContainer, 
    IHTMLElement    **ppNewContainer, 
    BOOL            fMorphListItems,
    IMarkupPointer  *pSelectionStart, 
    IMarkupPointer  *pSelectionEnd)
{
    HRESULT         hr;
    CBlockPointer   bpCurrent(GetEditor());
    CBlockPointer   bpParent(GetEditor());
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID  tagId;

    if (ppNewContainer)
        *ppNewContainer = NULL;

    //
    // Change container type
    //
    IFR( bpCurrent.MoveTo(pListContainer) );
    IFR( bpCurrent.Morph(&bpCurrent, GetListContainerType()) );

    if (ppNewContainer)
        IFR( bpCurrent.GetElement(ppNewContainer) );

    IFR( ChangeListsChildListsTypes(&bpCurrent, fMorphListItems, pSelectionStart, pSelectionEnd) );

    //
    // Change parent list containers
    //

    IFR( bpParent.MoveTo(&bpCurrent) );
    IFR( bpParent.MoveToParent() );
    if (hr == S_OK && bpParent.GetType() == NT_ListContainer)
    {
        SP_IMarkupPointer spLeft, spRight;
        CBlockPointer     bpTest(GetEditor());
        BOOL              fEqual;

        IFR( GetEditor()->CreateMarkupPointer(&spLeft) );
        IFR( GetEditor()->CreateMarkupPointer(&spRight) );
        IFR( bpTest.MoveTo(&bpCurrent) );
        do     
        {
            // Check left boundary
            IFR( bpParent.MovePointerTo(spLeft, ELEM_ADJ_AfterBegin) );
            IFR( bpTest.MovePointerTo(spRight, ELEM_ADJ_BeforeBegin) );
            IFR( spLeft->IsEqualTo(spRight, &fEqual) );
            if (!fEqual)
                break;

            // Check right boundary
            IFR( bpTest.MovePointerTo(spLeft, ELEM_ADJ_AfterEnd) );
            IFR( bpParent.MovePointerTo(spRight, ELEM_ADJ_BeforeEnd) );
            IFR( spLeft->IsEqualTo(spRight, &fEqual) );
            if (!fEqual)
                break;

            // Morph list
            IFR( bpParent.Morph(&bpParent, GetListContainerType()) );

            // Find parent
            IFR( bpTest.MoveTo(&bpParent) );
            IFR( bpParent.MoveToParent() );            
        } 
        while (hr == S_OK && bpParent.GetType() == NT_ListContainer);
    }

    //
    // Change list items if type is difference
    //
    IFR( GetMarkupServices()->GetElementTagId(pListContainer, &tagId) );
    
    if (!bpCurrent.IsListCompatible(GetListItemType(), tagId) || fMorphListItems)
    {
        IFR( bpCurrent.MoveToFirstChild() );
        while (hr == S_OK)
        {
            IFR( bpCurrent.GetElement(&spElement) );
            if (spElement != NULL)
            {
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                if (IsListItem(tagId))
                {   
                    // TODO: this can be made faster by collecting all children and calling
                    //       morph once [ashrafm]

                    IFR( bpCurrent.Morph(&bpCurrent, GetListItemType(), GetListContainerType()) );
                }
            }
            
            IFR( bpCurrent.MoveToSibling(RIGHT) );
        }
    }
    else
    {
        return S_FALSE;
    }

    return S_OK;
}

HRESULT
CListCommand::ChangeListItemType(IHTMLElement *pListItem)
{
    HRESULT         hr;
    CBlockPointer   bpCurrent(GetEditor());

    IFR( bpCurrent.MoveTo(pListItem) );
    IFR( bpCurrent.Morph(&bpCurrent, GetListItemType(), GetListContainerType()) );

    return S_OK;    
}

//+---------------------------------------------------------------------------
//
//  CBlockFmtCommand Class
//
//----------------------------------------------------------------------------

HRESULT 
CBlockFmtCommand::PrivateQueryStatus(  
                        OLECMD          *pCmd,
                        OLECMDTEXT      *pcmdtext )
{
    HRESULT hr = S_OK;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup ;
    }
#endif

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE) 
        goto Cleanup;
              
    pCmd->cmdf = MSOCMDSTATE_UP; 
    hr = S_OK;
    
Cleanup:
    return hr;
}

HRESULT 
CBlockFmtCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )                        
{  
    HRESULT             hr;
    ELEMENT_TAG_ID      tagId;
    ELEMENT_TAG_ID      tagIdOld = TAGID_NULL;            
    BSTR                bstrName;
    SP_ISegmentList     spSegmentList;
    IMarkupPointer      *pStart, *pEnd;
    CSegmentListIter    iter;
    CEdUndoHelper       undoUnit(GetEditor());
    SP_IDisplayPointer  spCaretMarker;

    IFC( CommonPrivateExec(nCmdexecopt, pvarargIn, pvarargOut) );
    if (hr != S_FALSE)
        RRETURN(hr);

    IFR( GetSegmentList(&spSegmentList) );

    if (pvarargIn)
    {        
        if (V_VT(pvarargIn) != VT_BSTR)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        
        IFR( CGetBlockFmtCommand::LookupTagId(GetMarkupServices(), V_BSTR(pvarargIn), &_tagId) );

        if (ShouldRemoveFormatting(_tagId))
        {
            GetSpringLoader()->Reset();
        }
        else if (!IsListItem(_tagId) && !IsListContainer(_tagId))
        {
            // reset the springloader with the compose settings
            GetSpringLoader()->SpringLoadComposeSettings(NULL, TRUE); 
        }
        
        if (IsListContainer(_tagId) || IsListItem(_tagId))
        {
            // new in constructor may fail if out of memory
            if (_pListCommand == NULL)
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            IFC( _pListCommand->SetCurrentTagId(_tagId, &tagIdOld) ) ;
            IFC( _pListCommand->Exec(nCmdexecopt, pvarargIn, pvarargOut, GetCommandTarget()) );
            IFC( _pListCommand->SetCurrentTagId(tagIdOld, NULL) );
        }    
        else
        {
            IFC( iter.Init(GetEditor(), spSegmentList) );
            IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
            for (;;)
            {
                IFC( iter.Next(&pStart, &pEnd) );
                if (hr == S_FALSE)
                    return S_OK; // done

                IFR( AdjustSegment(pStart, pEnd) );

                // NOTE: CreateCaretMarker fails when there is no caret.  This is
                // a common case when executing commands through the range

                IGNORE_HR( CreateCaretMarker(&spCaretMarker) );
                IFR( ApplyCommand(pStart, pEnd) );
                IGNORE_HR( RestoreCaret(spCaretMarker) );
            }    
        }
    }
    
    if (pvarargOut)
    {
        V_VT(pvarargOut) = VT_BSTR;

        hr = THR(GetFirstSegmentBlockFormat(spSegmentList, &tagId));
        if (hr != S_OK)
        {
            V_BSTR(pvarargOut) = NULL;
        }
        else
        {
            bstrName = CGetBlockFmtCommand::LookupFormatName(GetMarkupServices(), tagId);
            V_BSTR(pvarargOut) = (bstrName)?SysAllocString(bstrName):NULL;
        }
        hr = S_OK;
    }

Cleanup:    
    if (FAILED(hr) && pvarargOut)
        VariantInit(pvarargOut);

    RRETURN(hr);
}



///////////////////////////////////////////////////////////////////////////////////////
//
//  CBlockFmtCommand::GetFirstSegmentBlockFormat
//
//  Synopsis:   Returns the block format for the first segment in a list of segments
//              
//
//////////////////////////////////////////////////////////////////////////////////////
HRESULT
CBlockFmtCommand::GetFirstSegmentBlockFormat(
    ISegmentList    *pSegmentList,
    ELEMENT_TAG_ID  *ptagIdOut
    )
{
    HRESULT                 hr     = S_OK;
    BOOL                    fEmpty = FALSE;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;

    Assert( pSegmentList );
    Assert( ptagIdOut );

    *ptagIdOut = TAGID_UNKNOWN;
    
    IFC( pSegmentList->IsEmpty(&fEmpty) );
    if (fEmpty) 
    {
        IFC( GetActiveElemSegment(GetMarkupServices(), &spStart, &spEnd) );
        IFC( GetBlockFormat(spStart, spEnd, ptagIdOut) );
        return S_OK;
    }
    
    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFC( pSegmentList->CreateIterator(&spIter) );

    Assert(S_FALSE == spIter->IsDone());

    IFC( spIter->Current(&spSegment) );
    IFC( spSegment->GetPointers(spStart, spEnd) );
    IFC( ClingToText(spStart, RIGHT, spEnd) );
    IFC( ClingToText(spEnd, LEFT, spStart) );
    IFC( GetBlockFormat(spStart, spEnd, ptagIdOut) );

Cleanup:
    RRETURN1(hr, S_FALSE);
}



HRESULT
CBlockFmtCommand::FindBlockFmtElement(
    IHTMLElement    *pBlockElement, 
    IHTMLElement    **ppBlockFmtElement, 
    ELEMENT_TAG_ID  *ptagIdOut)
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spBlockElement;
    SP_IHTMLElement spParentElement;
    
    Assert(ptagIdOut != NULL);

    spBlockElement = pBlockElement;
    
    while (spBlockElement != NULL)
    {
        IFC( GetMarkupServices()->GetElementTagId(spBlockElement, ptagIdOut) );

        if (IsListContainer(*ptagIdOut) 
            || IsBasicBlockFmt(*ptagIdOut)
            || (*ptagIdOut) == TAGID_DD
            || (*ptagIdOut) == TAGID_DT)
          break; // found block format
            
        IFC( GetEditor()->GetParentElement( spBlockElement, &spParentElement) );
        spBlockElement = spParentElement;

        // reached top of the tree without finding the block element
        if (spBlockElement == NULL)
        {
            *ptagIdOut = TAGID_NULL;
            goto Cleanup;
        }
    }

Cleanup:
    if (ppBlockFmtElement)
    {
        if (SUCCEEDED(hr))
        {
            *ppBlockFmtElement = spBlockElement;
            if (spBlockElement != NULL)
                (*ppBlockFmtElement)->AddRef();
        }
        else
        {
            *ppBlockFmtElement = NULL;
            *ptagIdOut = TAGID_NULL;
        }         
    }
    
    RRETURN(hr);
}

HRESULT
CBlockFmtCommand::GetBlockFormat(
    IMarkupPointer  *pStart,
    IMarkupPointer  *pEnd,
    ELEMENT_TAG_ID  *ptagIdOut)
{   
    HRESULT             hr = E_FAIL;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spBlockElement;
    SP_IHTMLElement     spBlockFmtElement;
    SP_IHTMLElement     spNewElement;
    SP_IMarkupPointer   spTest;
    BOOL                fInRange;
    long                i;

    *ptagIdOut = TAGID_NULL;

    hr = THR( GetEditor()->FindCommonElement(pStart, pEnd, &spElement, TRUE, TRUE));
    if (FAILED(hr) || spElement == NULL)
        return S_OK;

    //
    // Walk up to find a block format element
    //

    IFR( GetEditor()->FindBlockElement(spElement, &spBlockElement) );
    IFR( FindBlockFmtElement(spBlockElement, &spElement, ptagIdOut) );
    spBlockElement = spElement;


    if (*ptagIdOut == TAGID_NULL)
    {
        CBlockPointer   bpCurrent(GetEditor());
        ELEMENT_TAG_ID  tagId;

        IFR( GetEditor()->CreateMarkupPointer(&spTest) );    
                    
        //
        // Run through all the text
        //
        IFR( bpCurrent.MoveTo(pStart, RIGHT) );
        while (!bpCurrent.IsLeafNode())
        {
            IFR( bpCurrent.MoveToFirstChild() );
            Assert(hr != S_FALSE);
        }
        IFR( bpCurrent.MovePointerTo(spTest, ELEM_ADJ_BeforeBegin) );
        IFR( spTest->CurrentScope(&spElement) );
        IFR( FindBlockFmtElement(spElement, &spBlockFmtElement, ptagIdOut) );
        if (*ptagIdOut == TAGID_NULL)
            return S_OK; // done
        
        for (i=0;;i++)
        {
            // Move to next leaf node
            IFR( bpCurrent.MoveToLastNodeInBlock() );
            IFR( bpCurrent.MoveToNextLeafNode() );
            if (hr == S_FALSE)
                break;
                
            IFR( bpCurrent.MovePointerTo(spTest, ELEM_ADJ_BeforeBegin) );
            IFR( spTest->IsLeftOfOrEqualTo(pEnd, &fInRange) );
            if (!fInRange)
                break;

            // Check block format type
            IFR( spTest->CurrentScope(&spElement) );
            IFR( FindBlockFmtElement(spElement, &spBlockFmtElement, &tagId) );
            if (tagId != (*ptagIdOut))
            {
                *ptagIdOut = TAGID_NULL;
                return S_FALSE;
            }
        }
    }
    else if (*ptagIdOut == TAGID_DL)
    {
        //
        // For definition list, check child types
        //

        CBlockPointer   bpCurrent(GetEditor());
        ELEMENT_TAG_ID  tagId;

        *ptagIdOut = TAGID_NULL;
        
        IFR( bpCurrent.MoveTo(spBlockElement) );
        IFR( bpCurrent.MoveToFirstChild() );
        if (bpCurrent.GetType() == NT_ListItem)
        {
            IFR( bpCurrent.GetElement(&spElement) );
            IFR( GetMarkupServices()->GetElementTagId(spElement, ptagIdOut) );

            if (*ptagIdOut != TAGID_DD && *ptagIdOut != TAGID_DT)
            {
                *ptagIdOut = TAGID_UNKNOWN;
                return S_OK;
            }

            for (;;)
            {
                IFR( bpCurrent.MoveToSibling(RIGHT) );
                if (hr == S_FALSE)
                    break;

                if (bpCurrent.GetType() != NT_ListItem)
                {
                    *ptagIdOut = TAGID_UNKNOWN;
                    break;
                }

                IFR( bpCurrent.GetElement(&spElement) );
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                if (tagId != *ptagIdOut)
                {
                    *ptagIdOut = TAGID_UNKNOWN;
                    break;
                }
            }
        }
    }

    return S_OK;
}


BOOL
CBlockFmtCommand::IsBasicBlockFmt(ELEMENT_TAG_ID tagId)
{
    switch (tagId)
    {
        case TAGID_P:
        case TAGID_DIV:
        case TAGID_PRE:
        case TAGID_ADDRESS:
        case TAGID_H1:
        case TAGID_H2:
        case TAGID_H3:
        case TAGID_H4:
        case TAGID_H5:
        case TAGID_H6:
            return TRUE;

        default:
            return FALSE;
    }
}

BOOL 
CBlockFmtCommand::ShouldRemoveFormatting(ELEMENT_TAG_ID tagId)
{
    switch (tagId)
    {
        case TAGID_PRE:
        case TAGID_H1:
        case TAGID_H2:
        case TAGID_H3:
        case TAGID_H4:
        case TAGID_H5:
        case TAGID_H6: 
            return TRUE;

        default:
            return FALSE;
    }
}

HRESULT 
CBlockFmtCommand::FloatToTopLevel(CBlockPointer *pbpStart, CBlockPointer *pbpEnd)
{
    HRESULT         hr;
    CBlockPointer   bpParent(GetEditor());
    CBlockPointer   &bpStart= *pbpStart; // just for convenience
    CBlockPointer   &bpEnd = *pbpEnd; // just for convenience
    
    for (;;)
    {
        IFR( bpParent.MoveTo(&bpStart) );
        IFR( bpParent.MoveToParent() );
        if (hr == S_FALSE)
            break; // done

        if (bpParent.GetType() == NT_BlockLayout 
            || bpParent.GetType() == NT_FlowLayout
            || bpParent.GetType() == NT_Container)
            break; // done

        IFR( bpStart.FloatUp(&bpEnd, TRUE) );
    }    
    
    return S_OK;
}

HRESULT
CBlockFmtCommand::ApplyComposeSettings(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    CSpringLoader * psl = GetSpringLoader();
    BOOL fEqual = FALSE;

    if (psl)
    {
        IGNORE_HR(psl->SpringLoadComposeSettings(NULL, TRUE));

        if (pStart->IsEqualTo(pEnd, &fEqual) || !fEqual)
        {
            IGNORE_HR(psl->Fire(pStart, pEnd));
        }
    }

    return S_OK;
}
   

HRESULT 
CBlockFmtCommand::ApplyCommand(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    CBlockPointer       bpCurrent(GetEditor());
    CBlockPointer       bpTest(GetEditor());
    CBlockPointer       bpParent(GetEditor());
    CBlockPointer       bpStart(GetEditor());
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    BOOL                fLeftOf = FALSE;
    ELEMENT_TAG_ID      tagIdDest = _tagId;
    ELEMENT_TAG_ID      tagId;

    IFR( GetEditor()->CreateMarkupPointer(&spStart) );
    IFR( GetEditor()->CreateMarkupPointer(&spEnd) );

    //
    // Find first leaf node
    //

    IFR( bpCurrent.MoveTo(pStart, RIGHT) );
    
    if (bpCurrent.IsLeafNode() || bpCurrent.GetType() == NT_FlowLayout)
    {
        IFR( bpCurrent.MoveToFirstNodeInBlock() );
    }
    else
    {
        while (!bpCurrent.IsLeafNode() && bpCurrent.GetType() != NT_FlowLayout)
        {
            IFR( bpCurrent.MoveToFirstChild() );
            Assert(hr != S_FALSE);
        }
    }
    
    do
    {
        //
        // Apply command
        //

        if (bpCurrent.IsLeafNode() || bpCurrent.GetType() == NT_FlowLayout)
        {
            //
            // Group all text nodes together
            //
            
            IFR( bpStart.MoveTo(&bpCurrent) );            
            IFR( bpCurrent.MoveToLastNodeInBlock() );
            //
            // Apply block command
            //

            IFR( bpParent.MoveTo(&bpStart) );
            IFR( bpParent.MoveToBlockScope(&bpCurrent) );

            if (! (_tagId == TAGID_P && bpParent.GetType() == NT_ListItem) )
            {
                if (_tagId == TAGID_NULL) // normal command            
                {
                    IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDest) );    

                    if (bpParent.IsLeafNode())
                    {
                        IFR( FloatToTopLevel(&bpStart, &bpCurrent) )
                        hr = S_FALSE;
                    }
                    else
                    {
                        IFR( FloatToTopLevel(&bpParent, &bpParent) )
                        hr = S_OK;
                    }
                }

                if (hr == S_OK && bpParent.GetType() == NT_Block)
                {   
                    IFR( bpParent.GetElement(&spElement) );
                    IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                
                    if (IsBasicBlockFmt(tagId))
                    {
                        // Morph element
                        IFR( bpParent.Morph(&bpParent, tagIdDest, TAGID_NULL) );            
                        IFR( bpParent.GetElement(&spElement) );
                    }
                    else
                    {
                        IFR( GetMarkupServices()->CreateElement(tagIdDest, NULL, &spElement) );
                        IFR( bpStart.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
                    }
                }        
                else 
                {
                    IFR( GetMarkupServices()->CreateElement(tagIdDest, NULL, &spElement) );
                    IFR( bpStart.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
                }
            
                IFR( bpStart.MovePointerTo(spStart, ELEM_ADJ_AfterBegin) );
                IFR( bpCurrent.MovePointerTo(spEnd, ELEM_ADJ_BeforeEnd) );

                if ( ShouldRemoveFormatting(_tagId))
                {
                    IFR( DYNCAST(CRemoveFormatCommand, GetEditor()->GetCommandTable()->Get(IDM_REMOVEFORMAT))->Apply(spStart, spEnd) ); 
                }
                else
                {
                    IFR( ApplyComposeSettings(spStart, spEnd) );
                }

                //
                // Flatten parent
                //

                IFR( bpParent.MoveTo(spElement) );
                IFR( bpParent.MoveToParent() );
                if (hr == S_OK && bpParent.GetType() == NT_Block)
                {
                    IFR( bpParent.FlattenNode() );
                }
            }
        }

        //
        // Find next leaf node
        //

        IFR( bpCurrent.MoveToNextLeafNode() );
        if (hr == S_OK)
        {
            // Check that the leaf node is in range                
            IFR( bpCurrent.MovePointerTo(spStart, ELEM_ADJ_BeforeBegin) );
            IFR( pEnd->IsLeftOf(spStart, &fLeftOf) );
        }
    } 
    while (hr == S_OK && !fLeftOf);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  COutdentCommand Class
//
//----------------------------------------------------------------------------
HRESULT
COutdentCommand::PrivateExec( DWORD nCmdexecopt,VARIANTARG * pvarargIn, VARIANTARG * pvarargOut)
{
    HRESULT             hr;
    IMarkupPointer      *pStart = NULL;
    IMarkupPointer      *pEnd = NULL;
    CSegmentListIter    iter;
    SP_ISegmentList     spSegmentList;
    SP_IDisplayPointer  spCaretMarker;
    
    CEdUndoHelper        undoUnit(GetEditor());

    IFC( CommonPrivateExec(nCmdexecopt, pvarargIn, pvarargOut) );
    if (hr != S_FALSE)
        RRETURN(hr);

    IFC( GetSegmentList(&spSegmentList) );
    IFC( iter.Init(GetEditor(), spSegmentList) );
    IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );

    for (;;)
    {
        IFC( iter.Next(&pStart, &pEnd) );
        if (hr == S_FALSE)
            return S_OK; // done

        IFR( AdjustSegment(pStart, pEnd) );

        // NOTE: CreateCaretMarker fails when there is no caret.  This is
        // a common case when executing commands through the range

        IGNORE_HR( CreateCaretMarker(&spCaretMarker) );        
        IFR( ApplyBlockCommand(pStart, pEnd) );    
        IGNORE_HR( RestoreCaret(spCaretMarker) );
    }

Cleanup:

    RRETURN( hr );
}

HRESULT 
COutdentCommand::PrivateQueryStatus(OLECMD * pCmd, OLECMDTEXT * pcmdtext)
{
    HRESULT hr = S_OK;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif
    
    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE) 
        goto Cleanup;
        
    pCmd->cmdf = MSOCMDSTATE_UP;
    hr = S_OK;

Cleanup:
    return hr;
}

HRESULT 
COutdentCommand::ApplyBlockCommand(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement, spListItem, spNewContainer;
    SP_IMarkupPointer   spLimit;
    CBlockPointer       bpCurrent(GetEditor());
    CBlockPointer       bpCurrentStart(GetEditor());
    CBlockPointer       bpEnd(GetEditor());
    SP_IMarkupPointer   spRight;
    ELEMENT_TAG_ID      tagId, tagIdDefault;

    IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDefault) )    
    
    IFR( GetEditor()->CreateMarkupPointer(&spRight) );
    IFR( spRight->SetGravity(POINTER_GRAVITY_Right) );
    
    IFR( GetEditor()->CreateMarkupPointer(&spLimit) );
    IFR( spLimit->SetGravity(POINTER_GRAVITY_Right) );
    
    // Start with first list item scope
    IFR( bpCurrent.MoveTo(pStart, RIGHT) );
    IFR( ForceScope(&bpCurrent) );

    // Do the fuzzy adjust
    IFR( spLimit->MoveToPointer(pEnd) );
    IFR( FuzzyAdjustOut(&bpCurrent, spLimit) );
    
    // 
    // Create list type
    //        
        
    do
    {
        switch (bpCurrent.GetType())
        {
        case NT_Text:
        case NT_Control:
        case NT_FlowLayout:
        case NT_TextBreak:
            IFR( ForceScope(&bpCurrent) );
            IFR( OutdentBlock(&bpCurrent, spLimit) );
            break;
            
        case NT_ListItem:
            IFR( OutdentListItem(&bpCurrent) ); 
            if (bpCurrent.GetType() == NT_Block)
            {
                IFR( bpCurrent.FlattenNode() );
            }
            break;
            
        case NT_Block:
            IFR( bpCurrent.GetElement(&spElement) );
            IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
            if (tagId == TAGID_BLOCKQUOTE)
            {
                IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagId) );    
                IFR( bpCurrent.Morph(&bpCurrent, tagId) );
                IFR( bpCurrent.MovePointerTo(spRight, ELEM_ADJ_AfterEnd) );
                IFR( bpCurrent.FlattenNode() );
                IFR( bpCurrent.MoveTo(spRight, LEFT) );
            }
            else
            {
                IFR( OutdentBlock(&bpCurrent, spLimit) );
            }
            break;
            
        case NT_BlockLayout:             
            IFR( OutdentBlock(&bpCurrent, spLimit) );
            break;
            
        case NT_ListContainer:
            IFR( OutdentBlock(&bpCurrent, spLimit, TRUE /* fBlockquoteOnly */) );
            if (hr == S_FALSE)
            {
                IFR( bpCurrent.MoveToFirstChild() );                
                continue;
            }
            break;

        default:
            AssertSz(0, "unexpected block type");         
        }

        //
        // Move to next logical block
        //
        IFR( bpCurrent.MoveToNextLogicalBlock(spLimit, TRUE) );        
    } 
    while (hr != S_FALSE);

    return S_OK;
    
}


HRESULT 
COutdentCommand::FindIndentBlock(CBlockPointer *pbpBlock)
{
    HRESULT         hr;
    CBlockPointer   bpIndentBlock(GetEditor());
    CBlockPointer   &bpBlock = *pbpBlock;
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID  tagId;
    
    //
    // Walk up the tree until we find the indent block
    //
    
    IFR( bpIndentBlock.MoveTo(&bpBlock) );

    while (hr == S_OK)
    {
        switch (bpIndentBlock.GetType())
        {
            case NT_Block:
                IFR( bpIndentBlock.GetElement(&spElement) );
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                if (tagId == TAGID_BLOCKQUOTE)
                {
                    IFR( bpBlock.MoveTo(&bpIndentBlock) );
                    return S_OK;
                }
                break;
                
            case NT_ListItem:
                IFR( bpBlock.MoveTo(&bpIndentBlock) );
                return S_OK; // found list item
                
            case NT_Container:
            case NT_BlockLayout:
            case NT_FlowLayout:
                return S_FALSE; // can't find indent block

            case NT_ListContainer:
                break; // keep looking

            default:
                AssertSz(0, "unexpected block type");
        }
        
        IFR( bpIndentBlock.MoveToParent() );
    }
    
    return S_FALSE; // not found    
}

HRESULT 
COutdentCommand::OutdentBlock(CBlockPointer *pBlock, IMarkupPointer *pRightBoundary, BOOL fBlockQuoteOnly /* = FALSE */)
{
    HRESULT             hr;
    CBlockPointer       bpIndentBlock(GetEditor());
    CBlockPointer       bpParent(GetEditor());
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spRight;
    ELEMENT_TAG_ID      tagId;
    BOOL                fDone;
    
    IFR( bpIndentBlock.MoveTo(pBlock) );
    IFR( FindIndentBlock(&bpIndentBlock) );
    if (hr == S_FALSE)
        return S_FALSE;
        
    if (bpIndentBlock.GetType() == NT_ListItem)
    {
	if (!fBlockQuoteOnly)
	    return OutdentListItem(&bpIndentBlock);

	return S_FALSE; // not blockquote
    }

    Assert(bpIndentBlock.GetType() == NT_Block);
    
    IFR( GetEditor()->CreateMarkupPointer(&spRight) );
    IFR( spRight->SetGravity(POINTER_GRAVITY_Right) );    
    IFR( bpIndentBlock.MovePointerTo(spRight, ELEM_ADJ_AfterEnd) );
    if (bpIndentBlock.IsEqual(pBlock) == S_OK)
    {
        //
        // The indent element is entirely contained with the command segment, so just morph
        // to default block and flatten
        //
        IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagId) );    
        IFR( bpIndentBlock.Morph(&bpIndentBlock, tagId) );
        IFR( bpIndentBlock.FlattenNode() );
        IFR( pBlock->MoveTo(spRight, LEFT) );
    }
    else
    {
        //
        // The indent element is partially in the range, so float the block up past the ident 
        // element
        //

        fDone = FALSE;
        do
        {
            IFR( bpParent.MoveTo(pBlock) );
            IFR( bpParent.MoveToParent() );
            Assert( hr != S_FALSE );
            Assert( bpParent.GetType() == NT_Block );

            fDone = (bpParent.IsEqual(&bpIndentBlock) == S_OK);
    
            IFR( pBlock->FloatUp(pBlock, TRUE) );
        } 
        while (!fDone);
    }        
    
    return S_OK;    
}

HRESULT 
COutdentCommand::OutdentListItem(CBlockPointer *pBlock)
{
    HRESULT         hr;
    CBlockPointer   bpListContainer(GetEditor());
    CBlockPointer   bpListContainerContainer(GetEditor());

    Assert(pBlock->GetType() == NT_ListItem);

    IFR( bpListContainer.MoveTo(pBlock) );
    IFR( bpListContainer.MoveToParent() );

    IFR( bpListContainerContainer.MoveTo(&bpListContainer) );
    IFR( bpListContainerContainer.MoveToParent() );

    if (bpListContainer.GetType() != NT_ListContainer)
    {
        // Stranded LI - so just leave it alone
        return S_FALSE;
    }        
    else if (bpListContainerContainer.GetType() != NT_ListContainer && 
             bpListContainerContainer.GetType() != NT_ListItem && 
             _cmdId == IDM_UI_OUTDENT)
    {
        return S_FALSE;
    }
    else
    {
        // if the container's container is a listitem, we need to float up
        // the container, then the original listitem. See bug 82995.
        
        if (bpListContainerContainer.GetType() == NT_ListItem)
        {
            IFR( bpListContainer.FloatUp(&bpListContainer, FALSE) );        
        }
        
        // It is safe to outdent the list item
        IFR( pBlock->FloatUp(pBlock, TRUE) );        
    }
    
    return S_OK;    
}

//+---------------------------------------------------------------------------
//
//  CIndentCommand Class
//
//----------------------------------------------------------------------------
HRESULT
CIndentCommand::PrivateExec( DWORD nCmdexecopt,VARIANTARG * pvarargIn, VARIANTARG * pvarargOut)
{
    HRESULT          hr;
    IMarkupPointer   *pStart = NULL;
    IMarkupPointer   *pEnd = NULL;
    CSegmentListIter iter;
    SP_ISegmentList  spSegmentList;
    CEdUndoHelper    undoUnit(GetEditor());
    SP_IDisplayPointer spCaretMarker;

    IFR( CommonPrivateExec(nCmdexecopt, pvarargIn, pvarargOut) );
    if (hr != S_FALSE)
        RRETURN(hr);

    IFR( GetSegmentList(&spSegmentList) );
    IFR( iter.Init(GetEditor(), spSegmentList) );
    IFR( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
    for (;;)
    {
        IFR( iter.Next(&pStart, &pEnd) );
        if (hr == S_FALSE)
            return S_OK; // done

        IFR( AdjustSegment(pStart, pEnd) );

        // NOTE: CreateCaretMarker fails when there is no caret.  This is
        // a common case when executing commands through the range

        IGNORE_HR( CreateCaretMarker(&spCaretMarker) );        
        IFR( ApplyBlockCommand(pStart, pEnd) );    
        IGNORE_HR( RestoreCaret(spCaretMarker) );
    }

    RRETURN(hr);
}

HRESULT 
CIndentCommand::PrivateQueryStatus(OLECMD * pCmd, OLECMDTEXT * pcmdtext)
{
    HRESULT hr = S_OK;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif
    
    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE) 
        goto Cleanup;

    pCmd->cmdf = MSOCMDSTATE_UP;
    hr = S_OK;

Cleanup:
    return hr;
}

HRESULT 
CIndentCommand::ApplyBlockCommand(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement, spListItem, spNewContainer;
    SP_IMarkupPointer   spLimit;
    CBlockPointer       bpCurrent(GetEditor());
    CBlockPointer       bpCurrentStart(GetEditor());
    CBlockPointer       bpParent(GetEditor());
    CBlockPointer       bpTest(GetEditor());
    SP_IMarkupPointer   spRight;
    ELEMENT_TAG_ID      tagId, tagIdDefault;
    BOOL                fLEQ, fOneBlock;

    IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDefault) )    
    IFR( GetEditor()->CreateMarkupPointer(&spRight) );
    IFR( spRight->SetGravity(POINTER_GRAVITY_Right) );
    IFR( GetEditor()->CreateMarkupPointer(&spLimit) );    
    IFR( spLimit->SetGravity(POINTER_GRAVITY_Right) );
    
    // Start with first indent item scope
    IFR( bpCurrent.MoveTo(pStart, RIGHT) );
    IFR( ForceScope(&bpCurrent) );

    // Now, do the fuzzy adjust out to get all directly enclosed scopes
    IFR( spLimit->MoveToPointer(pEnd) );    
    IFR( FuzzyAdjustOut(&bpCurrent, spLimit) );
        
    // 
    // Indent
    //        
        
    do
    {
        switch (bpCurrent.GetType())
        {
        case NT_Text:
        case NT_Control:
        case NT_FlowLayout:
        case NT_TextBreak:
            IFR( ForceScope(&bpCurrent) );
            // fall through
            
        case NT_ListContainer:
            if (bpCurrent.GetType() == NT_ListContainer)
            {
                CBlockPointer bpCurrentParent(GetEditor());

                // If the parent is a list container, just insert a list
                // container of the same kind to increase the indent level

                IFR( bpCurrentParent.MoveTo(&bpCurrent) );
                IFR( bpCurrentParent.MoveToParent() );
                if (bpCurrentParent.GetType() == NT_ListContainer)
                {
                    IFR( bpCurrentParent.GetElement(&spElement) );
                    IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                    IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );
                    IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
                    break;
                }
            }
            // Otherwise, fall through
            
        case NT_Block:
        case NT_BlockLayout:             
            fOneBlock = TRUE;
            IFR( bpCurrentStart.MoveTo(&bpCurrent) )
            IFR( bpTest.MoveTo(&bpCurrent) );
            do
            {                
                IFR( bpTest.MoveToSibling(RIGHT) );
                if (hr == S_FALSE)
                    break;

                IFR( bpTest.MovePointerTo(spRight, ELEM_ADJ_BeforeEnd) );
                IFR( spRight->IsLeftOfOrEqualTo(spLimit, &fLEQ) );
                if (fLEQ)
                {
                    fOneBlock = FALSE;
                    IFR( bpCurrent.MoveTo(&bpTest) );
                }
            }
            while (fLEQ);

            if (fOneBlock && bpCurrent.GetType() == NT_ListContainer)
            {
                // Only the list was selected, so indent the list items
                IFR( bpCurrent.MoveToFirstChild() );
                continue;
            }

            // To indent first block in list item, create another list
            if (bpCurrent.GetType() == NT_Block)
            {
                IFR( bpParent.MoveTo(&bpCurrent) );
                IFR( bpParent.MoveToSibling(LEFT) );
                if (hr == S_FALSE)
                {                
                    IFR( bpParent.MoveToParent() );
                    if (hr == S_OK && bpParent.GetType() == NT_ListItem)
                    {
                        ELEMENT_TAG_ID tagIdListItem;
                        ELEMENT_TAG_ID tagIdListContainer = TAGID_UL;

                        IFR( bpParent.GetElement(&spElement) );
                        IFR( GetMarkupServices()->GetElementTagId(spElement, &tagIdListItem) );                        


                        IFR( bpParent.MoveToParent() );
                        if (hr == S_OK && bpParent.GetType() == NT_ListContainer)
                        {
                            IFR( bpParent.GetElement(&spElement) );
                            IFR( GetMarkupServices()->GetElementTagId(spElement, &tagIdListContainer) );                        
                        }

                        IFR( bpCurrent.Morph(&bpCurrent, tagIdListItem, tagIdListContainer) );
                        
                        IFR( bpParent.MoveTo(&bpCurrent) );
                        IFR( bpParent.MoveToParent() );

                        if (bpParent.GetType() == NT_ListContainer)
                            IFR( bpParent.FloatUp(&bpParent, FALSE) );
                        break;
                    }
                }
            }

            // Indent using blockquote
            IFR( CreateBlockquote(&bpCurrent, &spElement) );
            
            // Insert the blockquote
            IFR( bpCurrentStart.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
            IFR( bpCurrent.MoveTo(spElement) );

            // Try blockquote merging
            IFR( bpCurrent.MovePointerTo(spRight, ELEM_ADJ_AfterEnd) );
            IFR( MergeBlockquotes(&bpCurrent) );
            IFR( bpCurrent.MoveTo(spRight, LEFT) );
            break;
            
        case NT_ListItem:
            IFR( bpParent.MoveTo(&bpCurrent) );
            IFR( bpParent.MoveToParent() );
            if (bpParent.GetType() == NT_ListContainer)
            {
                IFR( bpParent.GetElement(&spElement) );
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );
                IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
            }
            else
            {
                // Stranded LI, so just add a list container
                IFR( bpCurrent.GetElement(&spElement) );
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                
                // Decide on a list container, and morph to get block tree validation code
                if (tagId == TAGID_DD || tagId == TAGID_DT)
                {
                    IFR( bpCurrent.Morph(&bpCurrent, tagId, TAGID_DL) );
                }
                else if (tagId == TAGID_LI)
                {
                    IFR( bpCurrent.Morph(&bpCurrent, tagId, TAGID_UL) );
                }
                else
                {
                    AssertSz(0, "Unexpected list item type");
                }
            }
            break;
            
        default:
            AssertSz(0, "unexpected block type");         
        }

        //
        // Move to next logical block
        //
        IFR( bpCurrent.MoveToNextLogicalBlock(spLimit, TRUE) );        
    } 
    while (hr != S_FALSE);

    return S_OK;
    
}

HRESULT 
CIndentCommand::MergeBlockquotes(CBlockPointer *pbpBlock)
{
    HRESULT hr;

    IFR( MergeBlockquotesHelper(pbpBlock, LEFT) );
    IFR( MergeBlockquotesHelper(pbpBlock, RIGHT) );

    return S_OK;
}

HRESULT 
CIndentCommand::MergeBlockquotesHelper(CBlockPointer *pbpBlock, Direction dir)
{
    HRESULT               hr;
    CBlockPointer         &bpStart= *pbpBlock;
    CBlockPointer         bpCurrent(GetEditor());
    SP_IHTMLElement       spElement;
    SP_IHTMLElement       spElementStart;
    ELEMENT_TAG_ID        tagId;
    SP_IHTMLComputedStyle spStyleStart, spStyleCurrent;
    VARIANT_BOOL          fEqual;
  
    Assert(bpStart.GetType() == NT_Block);
    
#if DBG==1
    ELEMENT_TAG_ID  tagIdDebug;
    SP_IHTMLElement spElementDebug;

    Assert(S_OK == bpStart.GetElement(&spElementDebug) );
    Assert(S_OK == GetMarkupServices()->GetElementTagId(spElementDebug, &tagIdDebug) );
    Assert(tagIdDebug == TAGID_BLOCKQUOTE);
#endif

    //
    // Find the other element
    //
    
    IFR( bpCurrent.MoveTo(&bpStart) );
    IFR( bpCurrent.MoveToSibling(dir) );
    if (hr == S_FALSE || bpCurrent.GetType() != NT_Block)
        return S_FALSE; // can't merge 

    //
    // Check that both elements are of the same type
    //    

    IFR( bpCurrent.GetElement(&spElement) );
    IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
    if (tagId != TAGID_BLOCKQUOTE)
        return S_FALSE;

    //
    // Don't merge if our computed styles don't match
    //
    IFR( bpStart.GetElement(&spElementStart) );

    IFR( GetEditor()->GetComputedStyle(spElement, &spStyleCurrent) );
    IFR( GetEditor()->GetComputedStyle(spElementStart, &spStyleStart) );

    IFR( spStyleStart->IsEqual(spStyleCurrent, &fEqual) );

    if (!fEqual)
        return S_FALSE;
            
    // 
    // Do actual merge
    //

    IFR( CreateBlockquote(&bpStart, &spElement) );
    IFR( CopyAttributes(spElementStart, spElement, TRUE) );

    if (dir == LEFT)        
        IFR( bpCurrent.InsertAbove(spElement, &bpStart, TAGID_NULL, this) )
    else
        IFR( bpStart.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
    
    IFR( bpStart.GetElement(&spElement) );
    IFR( bpStart.MoveToParent() );
    IFR( GetMarkupServices()->RemoveElement(spElement) );
    
    IFR( bpCurrent.GetElement(&spElement) );    
    IFR( GetMarkupServices()->RemoveElement(spElement) ); 

    return S_OK;
}

HRESULT 
CIndentCommand::CreateBlockquote(CBlockPointer *pbpContext, IHTMLElement **ppElement)
{
    HRESULT                 hr;
    SP_IHTMLElement         spElement;
    SP_IHTMLElement2        spElement2;
    SP_IHTMLElement2        spNewElem2;
    SP_IHTMLDocument3       spDoc3;
    SP_IHTMLStyle           spStyle;
    SP_IHTMLCurrentStyle    spCurrentStyle;
    CBlockPointer           &bpContext = *pbpContext;
    BSTR                    bstrDir = NULL;

    IFR( GetMarkupServices()->CreateElement(TAGID_BLOCKQUOTE, NULL, ppElement) );
    Assert(*ppElement);
    
    if (bpContext.GetType() == NT_Block)
    {
        IFC( bpContext.GetElement(&spElement) );
        IFC( (*ppElement)->get_style(&spStyle) );
        // get new element's element2 interface for applying direction
        IFC( (*ppElement)->QueryInterface(IID_IHTMLElement2,(LPVOID*)&spNewElem2) );
        
        //
        // Use RTL info to determine margin
        //
        IFC( spElement->QueryInterface(IID_IHTMLElement2,(LPVOID*)&spElement2) );
        IFC( spElement2->get_currentStyle(&spCurrentStyle) );
        IFC( spCurrentStyle->get_direction(&bstrDir) );

        // first choice is default
        if(!bstrDir)
        {
            IFC( GetDoc()->QueryInterface(IID_IHTMLDocument3, (LPVOID *)&spDoc3) );
            IFC( spDoc3->get_dir(&bstrDir) );
            
            if(!StrCmpIW(bstrDir, L"rtl"))
            {
                if (GetEditor()->GetCssEditingLevel())
                {
                    IFC( spStyle->put_marginLeft(CVariant(VT_I4)) );
                }
                
                IFC( spNewElem2->put_dir(bstrDir) );
            }
            else
            {
                if (GetEditor()->GetCssEditingLevel())
                {
                    IFC( spStyle->put_marginRight(CVariant(VT_I4)) );
                }
                
                IFC( spNewElem2->put_dir(bstrDir) );
            }

        }
        else if(!StrCmpIW(bstrDir, L"rtl"))
        {
            if (GetEditor()->GetCssEditingLevel())
            {
                IFC( spStyle->put_marginLeft(CVariant(VT_I4)) );
            }
            IFC( spNewElem2->put_dir(bstrDir) );
        }
        else
        {
            if (GetEditor()->GetCssEditingLevel())
            {
                IFC( spStyle->put_marginRight(CVariant(VT_I4)) );
            }                
            IFC( spNewElem2->put_dir(bstrDir) );
        }            
    }

Cleanup:
    if (bstrDir)
        SysFreeString(bstrDir);
        
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  CAlignCommand
//
//----------------------------------------------------------------------------

HRESULT 
CAlignCommand::SetElementAlignment(IHTMLElement *pElement, BSTR szAlign /* = NULL */ , BOOL fUseDefaultAlign /*=TRUE*/)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;
    BOOL            fLayout;

    if (szAlign == NULL && fUseDefaultAlign)
        szAlign = _szAlign; // default alignment is that for the current command

    //
    // If an element has layout, setting the alignment will align the contents rather than
    // the element itself.  However, we want to align the element.  So, fail the call with 
    // S_FALSE.
    //

    IFR( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    
    IFR(IsBlockOrLayoutOrScrollable(pElement, NULL, &fLayout));
    if (fLayout && tagId != TAGID_TABLE)
        return S_FALSE;

    //
    // Set the alignemnt
    //
    switch (tagId)
    {
    case TAGID_CAPTION:
        hr = THR(CAlignment<IHTMLTableCaption>().Set(IID_IHTMLTableCaption, pElement, szAlign));
        break;

    case TAGID_TABLE:
        hr = THR(CAlignment<IHTMLTable>().Set(IID_IHTMLTable, pElement, szAlign));
        break;

    case TAGID_DIV:
        hr = THR(CAlignment<IHTMLDivElement>().Set(IID_IHTMLDivElement, pElement, szAlign));
        break;

    case TAGID_H1:
    case TAGID_H2:
    case TAGID_H3:
    case TAGID_H4:
    case TAGID_H5:
    case TAGID_H6:
        hr = THR(CAlignment<IHTMLHeaderElement>().Set(IID_IHTMLHeaderElement, pElement, szAlign));
        break;

    case TAGID_P:
        hr = THR(CAlignment<IHTMLParaElement>().Set(IID_IHTMLParaElement, pElement, szAlign));
        break;

    case TAGID_CENTER:
        if (_cmdId == IDM_JUSTIFYCENTER)
            hr = S_OK;
        else
            hr = S_FALSE;
        break;

    default:
        // not supported
        hr = S_FALSE;
        break;
    };

    RRETURN1(hr, S_FALSE);
}

BOOL 
CAlignCommand::IsValidOnControl()
{
    HRESULT         hr;
    BOOL            bResult = FALSE;
    SP_ISegmentList spSegmentList;
    INT             iSegmentCount;

    IFC( GetSegmentList(&spSegmentList) );
    Assert(spSegmentList != NULL);
    
    IFC( GetSegmentCount(spSegmentList, &iSegmentCount) );

    bResult = (iSegmentCount >= 1);

Cleanup:
    return bResult;
}
       
HRESULT    
CAlignCommand::GetElementAlignment(IHTMLElement *pElement, BSTR *pszAlign)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;

    *pszAlign = NULL;
    
    IFR( GetMarkupServices()->GetElementTagId(pElement, &tagId) );

    switch (tagId)
    {
    case TAGID_CAPTION:
        IFR( CAlignment<IHTMLTableCaption>().Get(IID_IHTMLTableCaption, pElement, pszAlign) );
        break;

    case TAGID_DIV:
        IFR( CAlignment<IHTMLDivElement>().Get(IID_IHTMLDivElement, pElement, pszAlign) );
        break;

    case TAGID_H1:
    case TAGID_H2:
    case TAGID_H3:
    case TAGID_H4:
    case TAGID_H5:
    case TAGID_H6:
        IFR( CAlignment<IHTMLHeaderElement>().Get(IID_IHTMLHeaderElement, pElement, pszAlign) );
        break;

    case TAGID_P:
        IFR( CAlignment<IHTMLParaElement>().Get(IID_IHTMLParaElement, pElement, pszAlign) );
        break;

    case TAGID_CENTER:
        *pszAlign = SysAllocString(_T("center"));
        hr = S_OK;
        break;

	case TAGID_TABLE:
        IFR( CAlignment<IHTMLTable>().Get(IID_IHTMLTable, pElement, pszAlign) );
        break;

    default:
        // not supported
        hr = S_FALSE;
    };

    RRETURN1(hr, S_FALSE);
}
    
HRESULT 
CAlignCommand::FindAlignment( 
    IHTMLElement     *pElement, 
    BSTR             *pszAlign,
    BOOL              fMoveToParent /*=TRUE*/)
{
    HRESULT             hr = S_OK;
    CBlockPointer       bpCurrent(GetEditor());
    SP_IHTMLElement     spElement;
    
    *pszAlign = NULL;

    //
    // Get ready to walk up the tree looking for the alignment.
    //
    // Note that if the element is a layout, we want the alignment
    // applied above, not the alignment of the contents of the layout.
    // So, if layout, start at parent. (NOTE: (krisma) we don't want to
    // do this if the calling f'n has already moved to the parent of
    // what it wants the alignment of.)
    //
    IFR( bpCurrent.MoveTo(pElement) );

	if (bpCurrent.GetType() == NT_BlockLayout && fMoveToParent)
        IFR( bpCurrent.MoveToParent() );
        
    //
    // Walk up the tree looking for the alignment
    //

    while (hr == S_OK)
    {
        IFR( bpCurrent.GetElement(&spElement) );
        IFR( GetElementAlignment(spElement, pszAlign) );
        if (hr == S_OK)
            return S_OK; // done

        //
        // Stop at layout or container boundaries
        //
        switch (bpCurrent.GetType())
        {
            case NT_BlockLayout:
            case NT_Container:
                return S_FALSE;
        }
            
        IFR( bpCurrent.MoveToParent() );
    }

    return S_FALSE;
}

HRESULT
CAlignCommand::PrivateQueryStatus( OLECMD * pCmd,
                            OLECMDTEXT * pcmdtext )
{
    HRESULT             hr = S_OK; 
    BSTR                szAlign = NULL;
    SP_ISegmentList     spSegmentList;
    SP_IMarkupPointer   spStart, spEnd;
    CBlockPointer       bpCurrent(GetEditor());
    SP_IHTMLElement     spElement;
    BOOL                fMovedToParent = FALSE;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif 

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE)
        goto Cleanup;

    pCmd->cmdf = MSOCMDSTATE_UP;

    IFC( GetSegmentList(&spSegmentList) );

#if DBG==1    
    //
    // NOTE: iSegmentCount < 1 is handled by CommonQueryStatus above
    //
    BOOL fEmpty;

    Assert( spSegmentList->IsEmpty(&fEmpty) == S_OK );
    Assert( fEmpty == FALSE );
#endif    

    IFC( GetFirstSegmentPointers(spSegmentList, &spStart, &spEnd) );

    //
    // Now, use the block tree to cling to a leaf node.  For the text case,
    // we know the node can not have alignment, so move to the parent.
    //
    // However, don't cross layout boundaries
    //

    IFC( bpCurrent.MoveTo(spStart, RIGHT) );
    for(;;)
    {
        switch (bpCurrent.GetType())
        {
            case NT_Text:
                IFC( bpCurrent.MoveToParent() ); // move back up to parent to get alignment
                fMovedToParent = TRUE;
                // fall through
                
            case NT_BlockLayout: // can't cross layout
            case NT_FlowLayout:
            case NT_Control:
            case NT_TextBreak:
                goto Done; // stop
        }
        IFC( bpCurrent.MoveToFirstChild() );
        Assert(hr != S_FALSE);
    }
        
Done:
    //
    // Now, walk up to get the alignment
    //

    IFC( bpCurrent.GetElement(&spElement) );
    Assert(spElement != NULL);

    // If we've already moved to our parent, we don't want FindAlignment to 
    // do it again. (bug 81723).
    IFC( FindAlignment(spElement, &szAlign, !fMovedToParent) );

    if (!szAlign)
    {
        if (_cmdId == IDM_JUSTIFYNONE)
            pCmd->cmdf = MSOCMDSTATE_DOWN;
    }
    else
    {
        if (StrCmpIW(szAlign, _szAlign) == 0)
            pCmd->cmdf = MSOCMDSTATE_DOWN;
    }

    hr = S_OK;

Cleanup:
    SysFreeString(szAlign);        
    RRETURN(hr);
}

HRESULT 
CAlignCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{  
    HRESULT                 hr = S_OK;
    OLECMD                  cmd;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    ED_PTR                  ( edStart );
    ED_PTR                  ( edEnd) ;
    SELECTION_TYPE          eSelectionType;
    CEdUndoHelper           undoUnit(GetEditor());
    SP_IDisplayPointer      spCaretMarker;
    BSTR                    bstrAlignBefore = NULL ;
    
    //
    // Validation of command
    //
    
    IFC( CommonQueryStatus(&cmd, NULL) );
    if (hr != S_FALSE)
    {
        if (cmd.cmdf == MSOCMDSTATE_DISABLED)
            return E_FAIL;        

        RRETURN(hr);
    }

    //
    // Apply command
    //

    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->GetType( &eSelectionType ) );
    IFC( spSegmentList->CreateIterator( &spIter ) );
    
    IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );

    while( spIter->IsDone() == S_FALSE )
    {   
        SP_IHTMLElement         spElement;
    
        IFC( spIter->Current( &spSegment ) );
        IFC( spSegment->GetPointers( edStart, edEnd ));

        //
        // For site selection, alignment applies only to the selected
        // element.  Otherwise, it applies to the current block boundaries.
        //
        if (eSelectionType == SELECTION_TYPE_Control)
        {
            CBlockPointer       bp(GetEditor());
            SP_IHTMLElement3    spElement3;
            VARIANT_BOOL        fAcceptsHtml;
            ELEMENT_TAG_ID  tagId = TAGID_NULL;
    
            IFC( GetSegmentElement(spSegment, &spElement) );
            Assert(spElement != NULL);

            hr = THR( FindAlignment( spElement, & bstrAlignBefore ));
            if ( hr == S_FALSE || ! bstrAlignBefore )
            {           
                bstrAlignBefore = ::SysAllocString( _T("left"));
            }
           
            if (_cmdId == IDM_JUSTIFYNONE)
                IFR( ApplySiteAlignNone(spElement) )
            else
                IFR( ApplySiteAlignCommand(spElement) );

            THR(GetMarkupServices()->GetElementTagId(spElement, &tagId));
            
            IFC( spElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) );
            IFC( spElement3->get_canHaveHTML(&fAcceptsHtml) );

            if (fAcceptsHtml == VARIANT_TRUE && tagId != TAGID_TABLE)
            {    
                //
                // Insert a div inside the contents of the thing you're setting the alignment on
                // this makes the contents of the site not inherit the alignment you set on the text
                // 
                
                SP_IHTMLElement spInnerDiv;
                SP_IMarkupPointer spStart ;
                SP_IMarkupPointer spEnd;

                IFC( GetEditor()->CreateMarkupPointer( & spStart ));
                IFC( GetEditor()->CreateMarkupPointer( & spEnd ));
                
                IFC( spStart->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterBegin ));
                IFC( spEnd->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeEnd ));
                
                IFC( GetMarkupServices()->CreateElement(TAGID_DIV, NULL, &spInnerDiv) );
                IFC( InsertElement( GetMarkupServices(), spInnerDiv , spStart, spEnd ) );
                IFC( SetElementAlignment( spInnerDiv, bstrAlignBefore, FALSE  ));
                //
                // Flatten new div
                //
                IFC( bp.MoveTo(spInnerDiv) );
                IFC( bp.FlattenNode() );            
            }
        }
        else
        {
            IFC( AdjustSegment(edStart, edEnd) );            
            
            // NOTE: CreateCaretMarker fails when there is no caret.  This is
            // a common case when executing commands through the range

            IGNORE_HR( CreateCaretMarker(&spCaretMarker) );        
            IFC( ApplyAlignCommand(edStart, edEnd) );    
            IGNORE_HR( RestoreCaret(spCaretMarker) );
        }

        IFC( spIter->Advance() );
    }
    
Cleanup:    
    ::SysFreeString( bstrAlignBefore );
    return S_OK;
}

HRESULT 
CAlignCommand::ApplySiteAlignNone(IHTMLElement *pElement)
{
    HRESULT             hr;
    CBlockPointer       bpCurrent(GetEditor());
    SP_IHTMLElement     spElement;
    SP_IObjectIdentity  spIdent;

    Assert(pElement);

    //
    // Remove align properties on all parent elements of site selected element
    //
    

    //
    // Only remove alignment if block is an only child
    //

    IFR( bpCurrent.MoveTo(pElement) );
    if (!IsOnlyChild(&bpCurrent))
        return S_OK;

    //
    // At this point, bpCurrent either is pElement or a parent of pElement.    
    // We need to know which one.
    //

    IFR( bpCurrent.GetElement(&spElement) );
    if (spElement == NULL)
        return E_FAIL; // nothing to do

    IFR( pElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&spIdent) );
    if (spIdent->IsEqualObject(spElement) == S_OK)
        IFR( bpCurrent.MoveToParent() ); // start at parent

    while (hr == S_OK && bpCurrent.GetType() == NT_Block)
    {
        IFR( bpCurrent.GetElement(&spElement) );
        IFR( SetElementAlignment(spElement) );

        if (!IsOnlyChild(&bpCurrent))
            break;

        IFR( bpCurrent.MoveToParent() );
    }

    return S_OK;
}

HRESULT 
CAlignCommand::ApplySiteAlignCommand(IHTMLElement *pElement)
{
    HRESULT         hr;
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID  tagIdDefault;
    CBlockPointer   bpParent(GetEditor());

    // 
    // Try to set the alignment on the control.  If this fails, just insert a DIV tag
    // around the control and flatten the parent to remove excess nesting
    //
    IFR( SetElementAlignment(pElement) );
    if (hr == S_FALSE)
    {
        CBlockPointer bpCurrent(GetEditor());
        
        IFR( bpCurrent.MoveTo(pElement) );
        IFR( bpParent.MoveTo(&bpCurrent) );
        IFR( bpParent.MoveToParent() );
        
        if (bpCurrent.IsLeafNode() && bpParent.GetType() != NT_ListItem)
        {
            IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDefault) )              
            IFR( GetMarkupServices()->CreateElement(tagIdDefault, NULL, &spElement) );
        }
        else
        {
            // We don't want to create nested blocks with a P tag, so force
            // a DIV
            IFR( GetMarkupServices()->CreateElement(TAGID_DIV, NULL, &spElement) );
        }
        
        IFR( SetElementAlignment(spElement) );
        Assert(hr != S_FALSE);
        IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this, FALSE /* fValidate */) );
    
        //
        // Now flatten parent to reduce nesting
        //
        IFR( bpCurrent.MoveTo(spElement) );
        IFR( bpCurrent.MoveToParent() );
        if (hr == S_OK && bpCurrent.GetType() == NT_Block)
            IFR( bpCurrent.FlattenNode() );
        
    }
    return S_OK;
}

HRESULT 
CAlignCommand::ApplyAlignCommand(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{    
    HRESULT             hr;
    SP_IMarkupPointer   spLimit;
    CBlockPointer       bpCurrent(GetEditor());
    CBlockPointer       bpParent(GetEditor());
    CBlockPointer       bpStart(GetEditor());
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagIdDefault;
    ELEMENT_TAG_ID      tagId;
    BOOL                fNeedInsertAbove;

    IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDefault) );
    IFR( GetEditor()->CreateMarkupPointer(&spLimit) );

    // Start with first list item scope
    IFR( bpCurrent.MoveTo(pStart, RIGHT) );
    IFR( ForceScope(&bpCurrent) );

    // Do the fuzzy adjust
    IFR( spLimit->MoveToPointer(pEnd) );
    IFR( FuzzyAdjustOut(&bpCurrent, spLimit) );
    
    // 
    // Apply the alignment command
    //        

    // Just in case the first block is nested, we need to flatten
    if (bpCurrent.GetType() == NT_Block)
        IFR( bpCurrent.FlattenNode() );
        
    do
    {
        switch (bpCurrent.GetType())
        {
        case NT_Control:
        case NT_Text:
        case NT_FlowLayout:
        case NT_TextBreak:

            //
            // Group all text nodes together
            //
            
            IFR( bpStart.MoveTo(&bpCurrent) );            
            IFR( bpCurrent.MoveToLastNodeInBlock() );

            //
            // Now get the block scope
            //

            fNeedInsertAbove = TRUE;
            
            IFR( bpStart.MoveToBlockScope(&bpCurrent) ); 
            if (hr == S_OK)
            {
                if (bpStart.GetType() == NT_Block)
                {
                    IFR( bpStart.GetElement(&spElement) );
                    IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                    
                    fNeedInsertAbove = (tagId == TAGID_BLOCKQUOTE);
                }

                if (fNeedInsertAbove)
                    IFR( bpStart.MoveToFirstChild() ); // restore start pointer                
            }
            
            if (fNeedInsertAbove)
            {
                // No block scope, so just insert one
                IFR( bpParent.MoveTo(&bpStart) );
                IFR( bpParent.MoveToParent() );
                
                if (bpParent.GetType() == NT_ListItem) 
                {
                    // P's in LI's render excess space, so use DIV
                    IFR( GetMarkupServices()->CreateElement(TAGID_DIV, NULL, &spElement) )
                }
                else
                {
                    IFR( GetMarkupServices()->CreateElement(tagIdDefault, NULL, &spElement) );                
                }
                    
                IFR( bpStart.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
                IFR( bpCurrent.MoveTo(spElement) );
            }
            else
            {
                IFR( bpCurrent.MoveTo(&bpStart) );
            }
            continue;

        case NT_Block:
            IFR( bpCurrent.GetElement(&spElement) );
            IFR( SetElementAlignment(spElement) );
            if (hr == S_FALSE)
            {
                //
                // If the block is a center tag, morph to DIV and try again
                //
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                if (tagId == TAGID_CENTER)
                {
                    IFR( bpCurrent.Morph(&bpCurrent, TAGID_DIV, TAGID_NULL) );
                    IFR( bpCurrent.GetElement(&spElement) );
                    IFR( SetElementAlignment(spElement) );
                    Assert(hr == S_OK);
                }
                else if (tagId == TAGID_BLOCKQUOTE)
                {
                    //
                    // For blockquote, force alignment to get applied on
                    // inside.
                    //
                    IFR( bpCurrent.MoveToFirstChild() );
                    continue;
                }
                else
                {
                    hr = S_FALSE; // can't set alignment
                }
            }
            if (hr == S_FALSE)
            {
                IFR( GetMarkupServices()->CreateElement(TAGID_DIV, NULL, &spElement) );
                IFR( SetElementAlignment(spElement) );
                IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
                Assert(hr == S_OK);
            }

            break;
            
        case NT_BlockLayout:             
            //
            // Need to insert div tag above
            //
            {
                SP_IHTMLElement spCurrentElem;

                IFR( bpCurrent.GetElement(&spCurrentElem) );
                IFR( GetMarkupServices()->GetElementTagId(spCurrentElem, &tagId) );
                if ( tagId == TAGID_TABLE || EdUtil::IsTablePart(tagId) )
                {
                    //
                    // need to clear the block fmt of current element
                    // otherwise it will not be merged when flattening
                    // nodes   In table case, <DIV> will be removed 
                    // when flattening node
                    // #107902
                    //
                    IGNORE_HR( SetElementAlignment(spCurrentElem) );
                }
                
                IFR( GetMarkupServices()->CreateElement(TAGID_DIV, NULL, &spElement) );
                IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
                IFR( SetElementAlignment(spElement) );
            }
            Assert(hr == S_OK);            
            break;
            
        case NT_ListItem:
            IFR( bpCurrent.GetElement(&spElement) );
            IFR( SetElementAlignment(spElement) );
            if (hr == S_OK)
                    break;
            
            // Otherwise, fall through

        case NT_Container:
        case NT_ListContainer:
            IFR( bpCurrent.MoveToFirstChild() );
            continue;

        default:
            AssertSz(0, "unexpected block type");         
        }

        //
        // Move to next logical block
        //
        IFR( bpCurrent.MoveToNextLogicalBlock(spLimit, TRUE) );        
    } 
    while (hr != S_FALSE);

    return S_OK;   
}

HRESULT 
CBlockCommand::ForceScope(CBlockPointer *pbpBlock)
{
    HRESULT         hr;
    CBlockPointer   bpStart(GetEditor());
    CBlockPointer   bpEnd(GetEditor());
    ELEMENT_TAG_ID  tagId;
    SP_IHTMLElement spElement;
    
    switch (pbpBlock->GetType())
    {
        case NT_Block:
        case NT_ListItem:
        case NT_ListContainer:
        case NT_Container:
        case NT_BlockLayout:
            break; // done

        case NT_Text:
        case NT_Control:
        case NT_FlowLayout:
        case NT_TextBreak:
            IFR( bpStart.MoveTo(pbpBlock) );
            IFR( bpStart.MoveToFirstNodeInBlock() );
            
            IFR( bpEnd.MoveTo(pbpBlock) );
            IFR( bpEnd.MoveToLastNodeInBlock() );

            IFR( bpStart.MoveToBlockScope(&bpEnd) );
            if (hr == S_OK)
            {
                IFR( pbpBlock->MoveTo(&bpStart) );
            }
            else
            {
                IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagId) )    
                IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );
                IFR( bpStart.InsertAbove(spElement, &bpEnd, TAGID_NULL, this) );
                IFR( pbpBlock->MoveTo(spElement) );
            }
            break;

        default:
            AssertSz(0, "unexpected block type");
    }

    return S_OK;
}

HRESULT 
CBlockCommand::FuzzyAdjustOut(CBlockPointer *pbpStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    DWORD               dwSearch = BREAK_CONDITION_BLOCKPOINTER;
    DWORD               dwFound;
    CBlockPointer       &bpStart = *pbpStart;
    CBlockPointer       bpTest(GetEditor());
    CBlockPointer       bpEnd(GetEditor());
    SP_IMarkupPointer   spEnd;
    BOOL                bRightOf;
    CEditPointer        epLimit(GetEditor(), pEnd);


    IFR( bpEnd.MoveTo(epLimit, LEFT) );
    
    //
    // Skip past any text/control nodes
    //
    
    if (bpEnd.IsLeafNode() || bpEnd.GetType() == NT_FlowLayout)
    {
        IFR( bpTest.MoveTo(&bpEnd) );
        for (;;)
        {
            IFR( bpTest.MoveToSibling(RIGHT) );
            if (hr == S_FALSE || (!bpTest.IsLeafNode() && bpTest.GetType() != NT_FlowLayout))
                break;

            IFR( bpEnd.MoveTo(&bpTest) );
        }
    }
    IFR( bpEnd.MovePointerTo(epLimit, ELEM_ADJ_AfterEnd) );

    //
    // Skip past exit block scopes to get right boundary
    //
    
    for (;;)
    {
        IFR( epLimit.Scan(RIGHT, dwSearch, &dwFound) );
        if (!epLimit.CheckFlag(dwFound, BREAK_CONDITION_ExitBlock)
            || epLimit.CheckFlag(dwFound, BREAK_CONDITION_Site))
        {
            IFR( epLimit.Scan(LEFT, dwSearch, &dwFound) );
            break;
        }
    }    
    
    //
    // Now, we want to position bpStart on the outermost block that is completely contained
    //    

    IFR( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFR( bpStart.MovePointerTo(spEnd, ELEM_ADJ_AfterEnd) );    
    IFR( spEnd->IsRightOf(epLimit, &bRightOf) );
    if (bRightOf)
    {
        //
        // We are already outside the limit, so go down the tree        
        //
        for (;;)
        {
            IFR( bpStart.MoveToFirstChild() );
            if (hr == S_FALSE || bpStart.IsLeafNode() || bpStart.GetType() == NT_FlowLayout)
            {
                IFR( ForceScope(&bpStart) );
                return S_OK; // done, block is in range
            }

            IFR( bpStart.MovePointerTo(spEnd, ELEM_ADJ_AfterEnd) );    
            IFR( spEnd->IsRightOf(epLimit, &bRightOf) );
            if (!bRightOf)
                return S_OK; // done, block is in range
        }
        
    }
    else
    {       
        //
        // We are inside the limit, so go up the tree starting at a forced block scope
        //
        
        IFR( ForceScope(&bpStart) );

        IFR( bpTest.MoveTo(&bpStart) );
        for (;;)
        {
            IFR( bpTest.MoveToSibling(LEFT) );
            if (hr != S_FALSE)
                return S_OK; // it has left siblings, so we can't go up the tree                

            IFR( bpTest.MoveToParent() );
            if (hr == S_FALSE || bpTest.GetType() == NT_Container || bpTest.GetType() == NT_BlockLayout)
                return S_OK; // can't do anything here
            
            IFR( bpTest.MovePointerTo(spEnd, ELEM_ADJ_AfterEnd) );    
            IFR( spEnd->IsRightOf(epLimit, &bRightOf) );
            if (bRightOf)
                return S_OK; // done, parent scope is not contained

            IFR( bpStart.MoveTo(&bpTest) );
            IFR( bpTest.MoveTo(&bpStart) );            
        }
    }
    
    return S_OK;
}

HRESULT
CBlockCommand::CreateCaretMarker(IDisplayPointer **ppDispCaretMarker)
{
    HRESULT                 hr;
    SP_IDisplayPointer      spCaretMarker;
    SP_IHTMLCaret           spCaret;
    SELECTION_TYPE          eSelectionType;
    SP_ISegmentList         spSegmentList;

    Assert(ppDispCaretMarker);
    *ppDispCaretMarker = NULL;
    
    //
    // If we have a caret, create a marker with gravity left (opposite to caret). 
    // So, when we are done, we can compare positions and adjust properly
    //

    IFR( GetSegmentList(&spSegmentList) ); 
    IFR( spSegmentList->GetType(&eSelectionType) );
    if (eSelectionType == SELECTION_TYPE_Caret)
    {    
        IFR( GetDisplayServices()->GetCaret(&spCaret) );    
        if (spCaret != NULL)
        {
            IFR( GetDisplayServices()->CreateDisplayPointer(&spCaretMarker) );
            IFR( spCaret->MoveDisplayPointerToCaret(spCaretMarker) );
            IFR( spCaretMarker->SetPointerGravity(POINTER_GRAVITY_Left) );

            *ppDispCaretMarker = spCaretMarker;
            spCaretMarker->AddRef();
        }
    }

    return S_OK;
}

HRESULT 
CBlockCommand::RestoreCaret(IDisplayPointer *pDispCaretMarker)
{
    HRESULT             hr;
    SP_IDisplayPointer  spCaretPos;
    SP_IHTMLCaret       spCaret;
    BOOL                fEqual;

    //
    // If restore position is not the same, then adjust for insert
    //
    IFR( GetDisplayServices()->GetCaret(&spCaret) );    
    if (spCaret != NULL && pDispCaretMarker != NULL)
    {
        IFR( GetDisplayServices()->CreateDisplayPointer(&spCaretPos) );
        IFR( spCaret->MoveDisplayPointerToCaret(spCaretPos) );
        IFR( spCaretPos->IsEqualTo(pDispCaretMarker, &fEqual) );
        
        if (!fEqual)
        {
            if (GetEditor())
            {
                CSelectionManager *pSelMan;
                
                pSelMan = GetEditor()->GetSelectionManager();
                if (pSelMan && pSelMan->GetActiveTracker())
                {
                    IFR( pSelMan->GetActiveTracker()->AdjustPointerForInsert( spCaretPos, LEFT, LEFT, ADJPTROPT_None ));
                    IFR( spCaret->MoveCaretToPointer(spCaretPos, TRUE /* fScrollIntoView */, CARET_DIRECTION_INDETERMINATE) );
                }
            }
        }
    }
   
    return S_OK;    
}

BOOL 
CBlockCommand::IsOnlyChild(CBlockPointer *pbpCurrent)
{
    HRESULT             hr;
    CBlockPointer       bpTest(GetEditor());

    IFC( bpTest.MoveTo(pbpCurrent) );

    IFC( bpTest.MoveToSibling(LEFT) );
    if (hr != S_FALSE)
        return FALSE;

    IFC( bpTest.MoveToSibling(RIGHT) );
    if (hr != S_FALSE)
        return FALSE;

    // Is only child
    return TRUE;
    
Cleanup:
    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CBlockFormats::~CBlockFormats
//
//  Synopsis:   Clean up our array
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//--------------------------------------------------------------------------
CBlockFormats::~CBlockFormats()
{
    for (int i = _lCount-1; i >= 0; i--)
    {
        VariantClear(&_paryBlockFormats[i]);
    }
    if( _paryBlockFormats )
        delete [] _paryBlockFormats;
}

//+-------------------------------------------------------------------------
//
//  Method:     CBlockFormats::get__NewEnum
//
//  Synopsis:   Returns an enumerator object which can be used to enumerate
//              over the block formats.  Allows VBScript and JScript
//              clients to enumerate the contents using the for each statement
//              and the Enumerator object respectively.
//
//  Arguments:  ppEnum = OUTPUT - pointer to enumerator object
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CBlockFormats::get__NewEnum(/*[out, retval]*/ LPUNKNOWN *ppEnum)
{
    HRESULT     hr;

    if(ppEnum == NULL)
      return E_POINTER;
      
    *ppEnum = NULL;

    // Use the STL CComEnum class to implement our enumerator.  We are going 
    // to be enumerating and copying variants
    typedef CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > EnumVar;
    CComObject<EnumVar>  *pEnum;

    // Create our enumerator
    IFC( CComObject<EnumVar>::CreateInstance(&pEnum) );
      
    // Initialize the enumerator with this data, AtlFlagCopy is used
    // to make a copy of the data with _Copy<VARIANT>::copy().  Note that
    // the second parameter is a pointer to the next item AFTER the last
    // item in our array.
    IFC( pEnum->Init(&_paryBlockFormats[0], &_paryBlockFormats[GetCount()], NULL, AtlFlagCopy) );

    // An IUnknown pointer is required so use QueryInterface() which also
    // calls AddRef().
    IFC( pEnum->QueryInterface(IID_IUnknown, (void **)ppEnum) );

Cleanup:
       
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CBlockFormats::get_Count
//
//  Synopsis:   Returns the number of block formats
//
//  Arguments:  plCount = OUTPUT - pointer to count
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CBlockFormats::get_Count(/*[out, retval]*/ long *plCount)
{
    if( plCount == NULL )
        return E_POINTER;

    Assert( IsInitialized() );

    *plCount = GetCount();
    
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CBlockFormats::Item
//
//  Synopsis:   Returns the specific block format requested.  We only support
//              retrieval by integer based index.
//
//  Arguments:  pvarIndex = Index to retrieve
//              pbstrlockFormat = OUTPUT - pointer to BSTR for block format
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CBlockFormats::Item(/*[in]*/ VARIANT *pvarIndex, /*[out, retval]*/ BSTR *pbstrBlockFormat)
{
    if( (pbstrBlockFormat == NULL) || (pvarIndex == NULL) )
        return E_POINTER;
        
    Assert( IsInitialized() );

    // VB6 will pass an VT_I2, but I also allow VT_I4 too
    if( (V_VT( pvarIndex ) == VT_I2) || (V_VT(pvarIndex) == VT_I4) )
    {
        int nIndex;

        // VB Arrays are 1 based
        nIndex = (V_VT(pvarIndex) == VT_I2) ? V_I2(pvarIndex) - 1 : V_I4(pvarIndex) - 1;

        // Check that a valid index is passed 
        if( (nIndex >= GetCount()) || (nIndex < 0) )
            return E_INVALIDARG;

        *pbstrBlockFormat = SysAllocString(V_BSTR(&_paryBlockFormats[nIndex]));

        if( *pbstrBlockFormat == NULL )
            return E_OUTOFMEMORY;
    }

    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CBlockFormats::Init
//
//  Synopsis:   Initializes the block formats collection.  Takes an
//              array of block formats and creates a collection.
//
//  Arguments:  psa = SAFEARRAY of block formats
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CBlockFormats::Init( SAFEARRAY *psa )
{
    HRESULT hr = S_OK;
    LONG lLBound = 0;
    LONG lUBound = 0;
    LONG lActualIndex = 0;
    LONG lCount, lIndex;
    BSTR  bstrBuf;

    Assert(psa);

    // Get the index bounds of this safe array.
    SafeArrayGetLBound(psa, 1, &lLBound);
    SafeArrayGetUBound(psa, 1, &lUBound);
    lCount = lUBound - lLBound + 1;

    // If array is not empty we'll need to create our internal array
    if (lCount > 0)
    {
        // Create our array and store this data
        _paryBlockFormats = new CComVariant[ lCount ];
        if( !_paryBlockFormats )
            goto Error;

        for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
        {
            if (SafeArrayGetElement(psa, &lIndex, &bstrBuf) == S_OK)
            {
                V_VT(&_paryBlockFormats[lActualIndex]) = VT_BSTR;
                V_BSTR(&_paryBlockFormats[lActualIndex++]) = bstrBuf;
            }
        }
        Assert(lCount == lActualIndex);
    }
    _lCount = lActualIndex;
    
    SetInitialized(TRUE);

Cleanup:
    RRETURN(hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\cutcmd.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998, 1999
//
//  File:       CUTCMD.CXX
//
//  Contents:   Implementation of Cut command.
//
//  History:    07-14-98 - raminh - created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif

#ifndef _X_CUTCMD_HXX_
#define _X_CUTCMD_HXX_
#include "cutcmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

using namespace EdUtil;

//
// Externs
//

MtDefine(CCutCommand, EditCommand, "CCutCommand");


//+---------------------------------------------------------------------------
//
//  CCutCommand::Exec
//
//----------------------------------------------------------------------------

HRESULT
CCutCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT                 hr = S_OK;
    SP_IHTMLElement         spElement = NULL;
    SP_IHTMLElement3        spElement3;
    SELECTION_TYPE          eSelectionType;
    SP_ISegmentList         spSegmentList = NULL;
    SP_ISegment             spSegment = NULL;
    SP_ISegmentListIterator spIter = NULL;
    BOOL                    fEmpty = FALSE;
    BOOL                    fRet;
    VARIANT_BOOL            fRetVal;
    BOOL                    fNotRange = TRUE;
    CEdUndoHelper           undoUnit(GetEditor());
    CHTMLEditor             *pEditor = GetEditor();
    ED_PTR( edStart);
    ED_PTR( edEnd );    
    
    ((IHTMLEditor *) pEditor)->AddRef();    // FireOnCancelableEvent can remove the whole doc

    //
    // Do the prep work
    //
    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->GetType( &eSelectionType ) );           
    IFC( spSegmentList->IsEmpty( &fEmpty ) );           

    //
    // Cut is allowed iff we have a non-empty segment
    //    
    if ( eSelectionType == SELECTION_TYPE_Caret || fEmpty )
    {
        goto Cleanup;
    }

    //  See if the segment list contains a password element
    if (SegmentListContainsPassword(spSegmentList))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    //
    // Now Handle the cut 
    //
    IFC( undoUnit.Begin(IDS_EDUNDOCUT) );

    //
    // Fire on-cut event on element common to all segmetns.
    //
    
    IFC( GetEditor()->FindCommonParentElement( spSegmentList, &spElement));

    if (! spElement)
        goto Cleanup;

    IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->fireEvent(_T("oncut"), NULL, &fRetVal));
    fRet = !!fRetVal;

    if (! fRet)
    {
        goto Cleanup;
    }

    //
    // TODO - call Query Status here.
    //

    IFC( spSegmentList->CreateIterator(&spIter) );
    
    //
    // Do verfication for all segments. Any invalid - we fail.
    //
    while( spIter->IsDone() == S_FALSE )
    {
        IFC( spIter->Current(&spSegment) );        
        IFC( spSegment->GetPointers( edStart, edEnd ));
        
        IFC( edStart->IsEqualTo( edEnd, & fRet ) );
        if ( fRet )
        {
            goto Cleanup;
        }

        //
        // Cannot delete or cut unless the range is in the same flow layout
        //
        if( !GetEditor()->PointersInSameFlowLayout( edStart, edEnd, NULL ) )
        {
            goto Cleanup;
        }

        IFC( spIter->Advance() );
    }
    
    //
    // Save to clipboard.
    //
    
#ifndef UNIX
    IFC( GetMarkupServices()->SaveSegmentsToClipboard( spSegmentList, 0 ) );
#else
    IFC( GetMarkupServices()->SaveSegmentsToClipboard( spSegmentList, 0, NULL ) );
#endif

    //
    // Delete segments.
    //
    if (eSelectionType == SELECTION_TYPE_Control)
    {
        IFC (GetEditor()->RemoveElementSegments(spSegmentList));
    }
    else
    {
        fNotRange =  !GetCommandTarget()->IsRange();
    
        IFC( spIter->First() );

        while( spIter->IsDone() == S_FALSE )
        {
            // Get our current segment, and advance the iterator
            // to the next segment.  This is because we might
            // blow away our segment in the call to Delete.  We should
            // probably fix this if this becomes a public interface.
            IFC( spIter->Current(&spSegment) );        
            IFC( spIter->Advance() );

            IFC( spSegment->GetPointers( edStart, edEnd ));
            IFC( pEditor->Delete( edStart, edEnd, fNotRange ) );
        }
    
        if ( eSelectionType == SELECTION_TYPE_Text) 
        {
            pEditor->GetSelectionManager()->EmptySelection();
        }
    }

Cleanup:   
    ReleaseInterface( (IHTMLEditor *) pEditor );
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  CCutCommand::QueryStatus
//
//----------------------------------------------------------------------------

HRESULT
CCutCommand::PrivateQueryStatus( 
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    HRESULT                 hr = S_OK;
    VARIANT_BOOL            fEditable;
    SELECTION_TYPE          eSelectionType;
    BOOL                    fRet;
    VARIANT_BOOL            fRetVal;
    IHTMLEditor             *pEditor = GetEditor();
    SP_IHTMLElement         spElement = NULL;
    SP_ISegmentList         spSegmentList = NULL;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    BOOL                    fEmpty = FALSE;
    SP_IHTMLElement3        spElement3;
    
    pEditor->AddRef();    // FireOnCancelableEvent can remove the whole doc

    ED_PTR (edStart);
    ED_PTR (edEnd);
    
    // 
    // Status is disabled by default
    //
    pCmd->cmdf = MSOCMDSTATE_DISABLED;

    //
    // Get Segment list and selection type
    //
    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->GetType(& eSelectionType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );

    //
    // Cut is allowed iff we have a non-empty segment
    //
    if( eSelectionType == SELECTION_TYPE_Caret  ||
        fEmpty == TRUE                          ||    
        GetEditor()->GetSelectionManager()->IsIMEComposition() )
    {
        goto Cleanup;
    }

    //  See if the segment list contains a password element
    if (SegmentListContainsPassword(spSegmentList))
        goto Cleanup;

    //
    // Fire cancelable event
    //
    IFC( GetEditor()->FindCommonParentElement( spSegmentList, &spElement));
    if (! spElement) 
        goto Cleanup;

    IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->fireEvent(_T("onbeforecut"), NULL, &fRetVal));
    fRet = !!fRetVal;
    
    if (! fRet)
    {
        pCmd->cmdf = MSOCMDSTATE_UP; 
        goto Cleanup;
    }

    if ( ! GetCommandTarget()->IsRange() && eSelectionType != SELECTION_TYPE_Control)
    {
        IFC(spElement3->get_isContentEditable(&fEditable));

        if ( ! fEditable) 
            goto Cleanup;
    }

    if (!GetCommandTarget()->IsRange())
    {
        VARIANT_BOOL fDisabled;

        spElement = GetEditor()->GetSelectionManager()->GetEditableElement();
        
        IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        IFC(spElement3->get_isDisabled(&fDisabled));

        if (fDisabled)
            goto Cleanup;
    }

    //
    // Do verfication for the first segment - fail if invalid
    //

    IFC( spSegmentList->CreateIterator( &spIter ) );
    if (S_FALSE == spIter->IsDone() )
    {
        IFC( spIter->Current(&spSegment) );
        IFC( spSegment->GetPointers(edStart, edEnd) );
        IFC( edStart->IsEqualTo(edEnd, &fRet) );
        if (fRet)
        {
            goto Cleanup;
        }

        if (!(GetEditor()->PointersInSameFlowLayout(edStart, edEnd, NULL)) )
        {
            goto Cleanup;
        }

        pCmd->cmdf = MSOCMDSTATE_UP;
    }

    
Cleanup:
    ReleaseInterface(pEditor);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\cartrack.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif


#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif


#ifndef _X_IME_HXX_
#define _X_IME_HXX_
#include "ime.hxx"
#endif

#ifndef _X_INPUTTXT_H_
#define _X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef _X_EDCOMMAND_HXX_
#define _X_EDCOMMAND_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_AUTOURL_H_ 
#define _X_AUTOURL_H_ 
#include "autourl.hxx"
#endif

#ifndef _X_SELSERV_HXX_
#define _X_SELSERV_HXX_
#include "selserv.hxx"
#endif 


#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

#define OEM_SCAN_RIGHTSHIFT 0x36
#define ISC_BUFLENGTH  10


MtDefine( CCaretTracker, Utilities , "CCaretTracker" )

ExternTag(tagSelectionTrackerState)
ExternTag(tagEdKeyNav)

using namespace EdUtil;

//
//
// Constructors & Initialization
// 
//

CCaretTracker::CCaretTracker( CSelectionManager* pManager ) :
    CEditTracker( pManager )
{
    _pBatchPUU = NULL;
    Init();
}

VOID
CCaretTracker::Init()
{
    _eType = TRACKER_TYPE_Caret;
    _fValidPosition = TRUE;
    _fCaretShouldBeVisible = TRUE;
    _fHaveTypedSinceLastUrlDetect = FALSE;
    _fCheckedCaretForAtomic = FALSE;
    _ptVirtualCaret.InitPosition();
    SetState(CR_DORMANT);
}


CCaretTracker::~CCaretTracker()
{
    Destroy();
}

HRESULT
CCaretTracker::Init2()
{
    HRESULT hr = S_OK;
    Assert( CR_DORMANT );

    SetCaretVisible( _pManager->GetDoc(), FALSE );

    // Set the selection type to none
    if( GetSelectionServices() && WeOwnSelectionServices() == S_OK )
        IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_None, NULL ) );

    _state = CR_PASSIVE;

Cleanup:
    return S_OK; // do nothting. We should be in the CR_PASSIVE State.
}

HRESULT
CCaretTracker::Init2(
                        IDisplayPointer*        pDispStart, 
                        IDisplayPointer*        pDispEnd, 
                        DWORD                   dwTCFlags,
                        CARET_MOVE_UNIT inLastCaretMove )
{
    HRESULT hr              = S_OK;

    SetState( CR_ACTIVE );    

    BOOL fStartPositioned = FALSE;
    BOOL fEndPositioned = FALSE;

    hr = THR( pDispStart->IsPositioned( & fStartPositioned ));
    if (!hr) hr = THR( pDispEnd->IsPositioned( & fEndPositioned) );

    if ( ! fStartPositioned || ! fEndPositioned )
    {
        _fValidPosition = FALSE;
    }

    if ( _fValidPosition )
    {
        hr = PositionCaretAt( pDispStart, CARET_DIRECTION_INDETERMINATE, POSCARETOPT_None, ADJPTROPT_None );
        if (FAILED(hr))
            _fValidPosition = FALSE;
    }
    
    SetCaretShouldBeVisible( ShouldCaretBeVisible() );

    IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Caret, (ISelectionServicesListener*) _pManager ) );   

Cleanup:
#if DBG == 1
    int caretStart = GetCp( pDispStart) ;
    BOOL fVisible = FALSE;
    TraceTag(( tagSelectionTrackerState, "\n---Start Caret Tracker--- Cp: %d Visible:%d\n",caretStart, fVisible ));
#endif    

    return hr;
}

HRESULT
CCaretTracker::Init2( 
                        ISegmentList*           pSegmentList, 
                        DWORD                   dwTCFlags,
                        CARET_MOVE_UNIT         inLastCaretMove )
{
    HRESULT hr = S_OK;

    //  We need to properly tear down the current tracker and make ourself
    //  passive.  We get called here when restoring the selection (selection
    //  none) during a drag leave.
    
    IFC( _pManager->EnsureDefaultTrackerPassive());

Cleanup:
    return hr;
}

HRESULT
CCaretTracker::Init2( 
                        CEditEvent* pEvent,
                        DWORD                   dwTCFlags,
                        IHTMLElement* pIElement )
{    
    HRESULT hr = S_OK;

    SetState( CR_ACTIVE );

    IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Caret, (ISelectionServicesListener*) _pManager ) );

    if ( pEvent )
    {
        hr = PositionCaretFromEvent( pEvent );
    }

    SetCaretShouldBeVisible( ShouldCaretBeVisible() );

Cleanup:

#if DBG == 1
    BOOL fVisible = FALSE;
    TraceTag(( tagSelectionTrackerState, "\n---Start Caret Tracker--- Visible:%d\n",fVisible ));
#endif   

    return hr;
}



//
//
// Virtuals from all trackers
// (excluding) event handling
//

//+====================================================================================
//
// Method: ShouldBeginSelection
//
// Synopsis: We don't want to start selection in Anchors, Images etc.
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::ShouldStartTracker(
        CEditEvent* pEvent ,
        ELEMENT_TAG_ID eTag,
        IHTMLElement* pIElement,
        SST_RESULT * peResult )
{
    if ( _pManager->IsEditContextNoScope())
    {
        *peResult = SST_NO_CHANGE;
    }
    else if ( ! pEvent->IsShiftKeyDown())
        *peResult = SST_CHANGE;

    RRETURN( S_OK);
}

//+====================================================================================
//
// Method: BecomeDormant
//
// Synopsis: Transition to a dormant state. For the caret tracker - this involves positioning based
//           on where we got the click.
//
//------------------------------------------------------------------------------------

HRESULT 
CCaretTracker::BecomeDormant(   CEditEvent      *pEvent, 
                                TRACKER_TYPE    typeNewTracker,
                                BOOL            fTearDownUI /*= TRUE*/ )
{
    CSpringLoader       *psl = GetSpringLoader();
    HRESULT hr = S_OK;
    
    // If we're ending the tracker, then autodetect, but only
    // if the reason for ending the tracker was NOT an IME composition.
    //
    if (_pManager->HaveTypedSinceLastUrlDetect() && 
        ( !pEvent || 
           ( pEvent->GetType() != EVT_IME_STARTCOMPOSITION &&
             pEvent->GetType() != EVT_IME_ENDCOMPOSITION &&
             pEvent->GetType() != EVT_IME_COMPOSITION ) ) )
    {
        UrlAutodetectCurrentWord(NULL);
        _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );
    }    

    // This is a 'click away' situation, in which we need to fire the 
    // tracker on the current line.  Fire the spring loader settings
    // if the line is empty
    if( psl && pEvent && pEvent->GetType() == EVT_LMOUSEDOWN )
    {
        psl->FireOnEmptyLine();
    }                   
    
    if ( pEvent && _fValidPosition && ( typeNewTracker != TRACKER_TYPE_Control) )
        hr = PositionCaretFromEvent( pEvent );

    TraceTag(( tagSelectionTrackerState, "\n---Caret Tracker: Become Dormant--- "));

    Destroy();                    
    SetState( CR_DORMANT);

    RRETURN( hr );
}

//+====================================================================================
//
// Method: Awaken
//
// Synopsis: Transition from dormant to a "live" state.
//
//------------------------------------------------------------------------------------


HRESULT 
CCaretTracker::Awaken() 
{
    Assert( IsDormant());

    //
    // Setup the selection services correctly
    //
    SetupSelectionServices();

    Init ();

    RRETURN( S_OK );
}

//+====================================================================================
//
// Method: Destroy
//
// Synopsis: Release anything we currently own.
//
//------------------------------------------------------------------------------------

VOID
CCaretTracker::Destroy()
{
    ClearInterface( & _pBatchPUU);
}

BOOL
CCaretTracker::IsListeningForMouseDown(CEditEvent* pEvent)
{
    BOOL fShiftKeyDown;

    fShiftKeyDown= pEvent->IsShiftKeyDown();

#ifndef NO_IME
    return _pManager->IsIMEComposition() ||
           ( fShiftKeyDown && ! GetCommandTarget()->IsMultipleSelection() ) ;
#endif // NO_IME
}

//+====================================================================================
//
// Method: OnSetEditContext
//
// Synopsis: A set edit context has happened. Ensure our visibility is correct.
//
//------------------------------------------------------------------------------------


HRESULT 
CCaretTracker::OnSetEditContext( BOOL fContextChange )
{
    if ( ! fContextChange )
    {
        SetCaretShouldBeVisible( ShouldCaretBeVisible() );
    }

    RRETURN( S_OK );
}


HRESULT 
CCaretTracker::GetLocation(POINT *pPoint, BOOL fTranslate)
{
    HRESULT hr;
    
    SP_IHTMLCaret spCaret;

    IFR( GetDisplayServices()->GetCaret(&spCaret) );
    IFR( spCaret->GetLocation(pPoint, fTranslate) );

    return S_OK;    
}



HRESULT
CCaretTracker::Position(
                IDisplayPointer* pDispPointer ,
                IDisplayPointer* pDispEnd)
{
    // Since we don't know where we are coming from, assume that we are at the EOL
    HRESULT hr = THR( PositionCaretAt( pDispPointer, CARET_DIRECTION_INDETERMINATE, POSCARETOPT_None, ADJPTROPT_None )); 
    
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: AdjustForDeletion
//
// Synopsis: The World has been destroyed around us. Reposition ourselves.
//
//------------------------------------------------------------------------------------


BOOL
CCaretTracker::AdjustForDeletion( IDisplayPointer* pDispPointer )
{
    PositionCaretAt( pDispPointer, CARET_DIRECTION_INDETERMINATE, POSCARETOPT_None, ADJPTROPT_None );
                    
    return FALSE;
}


//+====================================================================================
//
// Method: OnEditFocusChanged
//
// Synopsis: Change the Visibility of the caret - based on the Edit Focus
//
//------------------------------------------------------------------------------------


VOID
CCaretTracker::OnEditFocusChanged()
{
    SetCaretShouldBeVisible( ShouldCaretBeVisible() );
}

//
//
// Event Handling
//
//
//

//+====================================================================================
//
// Method:      Position Caret At
//
// Synopsis:    Wrapper to place the Caret at a given TreePointer.
//
// WARNING:     You should normally use PositionCaretFromMessage
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::PositionCaretAt( 
    IDisplayPointer         *pDispPointer, 
    CARET_DIRECTION         eDir             /* = CARET_DIRECTION_INDETERMINATE */,
    DWORD                   fPositionOptions /* = POSCARETOPT_None */,
    DWORD                   dwAdjustOptions  /* = ADJPTROPT_None */   )
{
    HRESULT             hr = S_OK;
    CSpringLoader *     psl;
    SP_IHTMLCaret       spCaret;
    BOOL                fResetSpringLoader = FALSE;
    BOOL                fOutsideUrl = ! CheckFlag( dwAdjustOptions , ADJPTROPT_AdjustIntoURL );
    SP_IMarkupPointer   spPointer;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(FALSE);

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );

    if( _pManager->HaveTypedSinceLastUrlDetect() )
    {
        IGNORE_HR( UrlAutodetectCurrentWord( NULL ) );
        _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );
    }
    
    psl = GetSpringLoader();
    if (psl)
    {
        IFC( pDispPointer->PositionMarkupPointer(spPointer) );        
        fResetSpringLoader = !psl->IsSpringLoadedAt(spPointer);
    }

    _ptVirtualCaret.InitPosition();
    
    IFC( GetDisplayServices()->GetCaret( &spCaret ));
    
    if( ! CheckFlag( fPositionOptions, POSCARETOPT_DoNotAdjust ))
    {
        BOOL fAtBOL = FALSE;

        IGNORE_HR( pDispPointer->IsAtBOL(&fAtBOL) );
        IFC( AdjustPointerForInsert( pDispPointer, fAtBOL ? RIGHT : LEFT, fAtBOL ? RIGHT : LEFT, dwAdjustOptions ));
    }

    SetCaretShouldBeVisible( ShouldCaretBeVisible() );
    IFC( spCaret->MoveCaretToPointerEx( pDispPointer, _fCaretShouldBeVisible , ! _pManager->GetDontScrollIntoView() , eDir ));
    _fCheckedCaretForAtomic = FALSE;

    // Reset the spring loader.
    if (psl)
    {
        IFC( pDispPointer->PositionMarkupPointer(spPointer) );

        if (fOutsideUrl && !fResetSpringLoader && psl->IsSpringLoaded())
        {
            ED_PTR( epTest ); 
            DWORD        dwFound;

            IFC( pDispPointer->PositionMarkupPointer(epTest) );
            IFC( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );

            fResetSpringLoader = epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterAnchor);
        }
        else if (fResetSpringLoader)
        {
            fResetSpringLoader = !psl->IsSpringLoadedAt(spPointer);
        }

        IGNORE_HR(psl->SpringLoadComposeSettings(spPointer, fResetSpringLoader, TRUE));
    }
    
Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    RRETURN( hr );
}

//+====================================================================================
//
// Method: CCaretTracker.HandleMessage
//
// Synopsis: Look for Keystrokes and such.
//
//------------------------------------------------------------------------------------


HRESULT
CCaretTracker::HandleEvent(
    CEditEvent* pEvent)
{

    HRESULT hr = S_FALSE;
    IHTMLElement* pIElement = NULL;
    IHTMLElement* pIEditElement = NULL;
    IObjectIdentity * pIdent = NULL;

    Assert ( !IsDormant());

    if ( IsPassive() ) // Caret Tracker is allowed to be passive. We just ignore the message.
        goto Cleanup ;
        
   
    if (_pBatchPUU && ShouldTerminateTypingUndo(pEvent))
        IFC( TerminateTypingBatch() );

    if ( _fValidPosition)
    {
        switch( pEvent->GetType() )
        {
            case EVT_KILLFOCUS:
                IGNORE_HR( _pManager->TerminateIMEComposition( TERMINATE_NORMAL ));
                break;

            case EVT_LMOUSEDOWN:
            case EVT_DBLCLICK :
            case EVT_RMOUSEUP:
            case EVT_RMOUSEDOWN:
#ifdef UNIX
            case EVT_MMOUSEDOWN:
#endif

                hr = THR ( HandleMouse( pEvent  ));

#ifdef UNIX
                if ( pEvent->GetType() == EVT_MMOUSEDOWN )
                    hr = S_FALSE;

#endif


                if (( pEvent->GetType() == EVT_RMOUSEUP ) || 
                    (!_pManager->IsContextEditable() ))
                    hr = S_FALSE;
                break;

            case EVT_KEYPRESS:
                hr = THR( HandleChar( pEvent));
                break;


            case EVT_KEYDOWN:
                hr = THR( HandleKeyDown( pEvent ));
                break;

            case EVT_KEYUP:
                hr = THR( HandleKeyUp( pEvent));
                break;

            case EVT_INPUTLANGCHANGE:
                hr = THR( HandleInputLangChange() );
                break;
        }
    }
    else
    {
        //
        // The Caret is hidden inside a No-Scope or an Element that we can't go inside 
        // ( eg. Image )
        // If we clicked on the same element as our context - don't do anything
        //
        // If we didn't process the mouse down.
        //
        if ( ( pEvent->GetType() == EVT_LMOUSEDOWN ) || 
             ( pEvent->GetType() == EVT_DBLCLICK )  )
        {             
            IFC( pEvent->GetElement( &pIElement) );
            IFC( pIElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent));        
            IFC( _pManager->GetEditableElement( & pIEditElement ));

            if (pIdent->IsEqualObject(pIEditElement) != S_OK)
            {
                hr = THR ( HandleMouse( pEvent ));
            }
            else
                hr = S_FALSE; // Not our event !
        }

    }

Cleanup:
    ReleaseInterface( pIElement );
    ReleaseInterface( pIEditElement );
    ReleaseInterface( pIdent );
    RRETURN1( hr, S_FALSE );

}

//+====================================================================================
//
// Method: HandleChar
//
// Synopsis: Delete the Selection, and cause this tracker to end ( & kill us ).
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::HandleChar(
                    CEditEvent* pEvent)
{
    HRESULT     hr = S_FALSE;
    IHTMLElement * pIElement = NULL;
    IHTMLInputElement* pIInputElement = NULL;
    BSTR bstrType = NULL;
    LONG keyCode ;
    IGNORE_HR( pEvent->GetKeyCode( & keyCode )) ;

    
    // Char codes we DON'T handle go here
    switch( keyCode )
    {
        case VK_BACK:
        case VK_F16:
            hr = S_OK;
            goto Cleanup;
            
        case VK_ESCAPE:
        {
            hr = S_FALSE;
            goto Cleanup;
        }            
    }

    if( keyCode < ' ' && keyCode != VK_TAB && keyCode != VK_RETURN )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Get the editable element
    IFC( _pManager->GetEditableElement( &pIElement ) );                                                          

#ifdef FORMSMODE
    if ( IsContextEditable()  && !_pManager->IsInFormsSelectionMode(pIElement))
#else
    if ( IsContextEditable() && ! _pManager->IsEditContextNoScope() )
#endif 
    {
        SP_IHTMLCaret pc;
        OLECHAR t ;
        BOOL fOverWrite = _pManager->GetOverwriteMode();
        IFC( GetDisplayServices()->GetCaret( &pc ));
            
        t = (OLECHAR)keyCode;
        
        if ( !_fCheckedCaretForAtomic )
        {
            SP_IDisplayPointer  spDispCaret;
            SP_IHTMLElement     spAtomicElement;

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
            IFC( pc->MoveDisplayPointerToCaret( spDispCaret ));

            IFC( GetCurrentScope(spDispCaret, &spAtomicElement) );
            if ( _pManager->CheckAtomic( spAtomicElement ) == S_OK )
            {
                //  Okay, we need to adjust out of the atomic element since we don't
                //  allow the user to type into atomic elements.
                IFC( AdjustOutOfAtomicElement(spDispCaret, spAtomicElement, RIGHT) );
                IFC( pc->MoveCaretToPointer(spDispCaret, FALSE, CARET_DIRECTION_INDETERMINATE) );
            }

            _fCheckedCaretForAtomic = TRUE;
        }

        switch (keyCode)
        {
            case VK_TAB:
            {
                
                if( IsCaretInPre( pc ))
                {
                    t = 9;
                    IFC( InsertText( &t, 1, pc, fOverWrite ));                    
                }
                else
                {
                    hr = S_FALSE;
                }

                break;
            }

            case VK_RETURN:
            {
                IFC( HandleEnter( pEvent, pc, pEvent->IsShiftKeyDown(), pEvent->IsControlKeyDown() ) );
                // Autodetect on space, return, or anyof the character in the string.
                IGNORE_HR( UrlAutodetectCurrentWord( &t ) );
                _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );

                break;
            }
            
            case VK_SPACE:
            {
                IFC( HandleSpace( (OLECHAR) keyCode ));
                break;
            }
            
            default:
            {
                BOOL fAccept = TRUE;

                if(_pManager->HasActiveISC())
                {
                    SP_IMarkupPointer   spPos;
                    MARKUP_CONTEXT_TYPE eCtxt;
                    LONG cch = ISC_BUFLENGTH;
                    OLECHAR aryISCBuffer[ISC_BUFLENGTH];
                    BOOL fPassword = FALSE;

                    IFC( _pManager->GetEditor()->CreateMarkupPointer( & spPos ));
                    IFC( pc->MoveMarkupPointerToCaret( spPos ));
                    IFC( spPos->Left( TRUE, & eCtxt , NULL , &cch , aryISCBuffer ));

                    // paulnel: if we are editing a password field we want to allow any character combination
                    if ( _pManager->GetEditableTagId() == TAGID_INPUT )
                    {
                        IFC( pIElement->QueryInterface (IID_IHTMLInputElement, 
                                                        ( void** ) &pIInputElement ));
                                
                        IFC(pIInputElement->get_type(&bstrType));
            
                        if (!StrCmpIC( bstrType, TEXT("password")))
                        {
                            fPassword = TRUE;
                        }
                    }

                    if(!fPassword)
                        fAccept = _pManager->GetISCList()->CheckInputSequence(aryISCBuffer, cch, t);
                }

                if( fAccept )
                    IFC( InsertText( &t, 1, pc, fOverWrite ));
                    
                break;
            }
        }
    }

Cleanup:

    SysFreeString( bstrType );
    ReleaseInterface( pIInputElement );
    ReleaseInterface( pIElement );

    return hr ;
}

//+====================================================================================
//
// Method: HandleMouseMessage
//
// Synopsis: When we get a mouse message, we move the Caret, and end ourselves.
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::HandleMouse(
        CEditEvent* pEvent )
{
    HRESULT hr = S_OK;
    SP_IMarkupPointer spStart;
    SP_IMarkupPointer spEnd;
    SP_IHTMLCaret spCaret;
    BOOL fSelect;

#ifndef NO_IME
    if ( _pManager->IsIMEComposition())
    {
        hr = THR( _pManager->HandleImeEvent( pEvent ) );
    }
    else
#endif // NO_IME

    if ( ! pEvent->IsShiftKeyDown() )
    {
        BOOL fAllow = TRUE;
        
        if ( pEvent->GetType() == EVT_RMOUSEUP )
        {
            fAllow = GetEditor()->AllowSelection( GetEditableElement(), pEvent) == S_OK ;               
        }

        if ( fAllow )       
            hr = PositionCaretFromEvent( pEvent );           
    }
    else
    {
        IFC( _pManager->FireOnSelectStart( pEvent, &fSelect , this) );

       if( fSelect )
        {
            SP_IDisplayPointer spDispStart; 
            SP_IDisplayPointer spDispEnd; 
        
            IFC( GetDisplayServices()->CreateDisplayPointer( & spDispStart ));
            IFC( GetDisplayServices()->CreateDisplayPointer( & spDispEnd ));
            IFC( GetDisplayServices()->GetCaret( & spCaret ));
            
            if( ShouldCaretBeVisible() )
            {
                IFC( spCaret->Show( FALSE ) );            
            }
            
            IFC( spCaret->MoveDisplayPointerToCaret( spDispStart ));

            IFC( pEvent->MoveDisplayPointerToEvent( spDispEnd, GetEditableElement(), TRUE ));
            IFC( _pManager->SelectFromShift( spDispStart, spDispEnd ));
        }        
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CCaretTracker::HandleKeyDown(
                CEditEvent* pEvent )
{
    CSpringLoader  * psl;
    HRESULT          hr = S_FALSE;
    SP_IHTMLElement spEditElement ;
    SP_IHTMLElement3 spElement3;
    LONG             eLineDir = LINE_DIRECTION_LeftToRight;
    SP_IDisplayPointer  spDispPointer;
    SP_ILineInfo     spLineInfo;
    LONG keyCode ;
    BOOL             fVertical = FALSE;
    
    IGNORE_HR( pEvent->GetKeyCode(&keyCode ));    

    if ( IsContextEditable() )
    {
        switch(keyCode )
        {
            case VK_BACK:
            case VK_F16:
            {
                // tell the caret which way it is moving in the logical string
                SP_IHTMLCaret       spCaret;
                SP_IMarkupPointer   spPointer;
                SP_IDisplayPointer  spDispCaret;
                SP_IHTMLElement     spListItem;

                BOOL                fDelaySpringLoad = FALSE;
                CEdUndoHelper       undoUnit(_pManager->GetEditor());
                
                IFC( _pManager->GetEditor()->CreateMarkupPointer( &spPointer ));
                
                IFC( GetDisplayServices()->GetCaret( &spCaret ));
    
                IFC( spCaret->MoveMarkupPointerToCaret( spPointer ));

                //
                // Should backspace remove the list item?
                //

                if (ShouldBackspaceExitList(spPointer, &spListItem))
                {
                    IFC( undoUnit.Begin(_pManager->GetOverwriteMode() ? IDS_EDUNDOOVERWRITE : IDS_EDUNDOTYPING) );

                    IFC( ExitList(spListItem) );

                    // May need to scroll 
                    IGNORE_HR( spCaret->ScrollIntoView() ); // ScrollIntoView can return S_FALSE - we want to return S_OK to say we consumed the event                    
                }
                else
                {
                    IFC( BeginTypingUndo(&undoUnit,
                                        _pManager->GetOverwriteMode() ? IDS_EDUNDOOVERWRITE : IDS_EDUNDOTYPING) );

                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
                    IFC( spCaret->MoveDisplayPointerToCaret( spDispCaret ));

                    IFC( spCaret->MoveMarkupPointerToCaret( spPointer ));

                    IFC( HandleBackspaceSpecialCase(spPointer) );

                    if (hr == S_FALSE)
                    {
                        IFC( HandleBackspaceAtomicSelection(spPointer) );
                    }

                    // Not a special case, so execute default code
                    if (hr == S_FALSE)
                    {
                        psl = GetSpringLoader();        
                        if (psl)
                        {
                            IFC( MustDelayBackspaceSpringLoad(psl, spPointer, &fDelaySpringLoad) );
                            
                            if (!fDelaySpringLoad)
                                IFC( psl->SpringLoad(spPointer, SL_ADJUST_FOR_INSERT_LEFT | SL_TRY_COMPOSE_SETTINGS | SL_RESET) );
                        }

                        IFC( _pManager->GetEditor()->DeleteCharacter( spPointer , TRUE, pEvent->IsControlKeyDown(), _pManager->GetStartEditContext() ));

                        if (psl && fDelaySpringLoad)
                        {
                            IFC( psl->SpringLoad(spPointer, SL_ADJUST_FOR_INSERT_LEFT | SL_TRY_COMPOSE_SETTINGS | SL_RESET) );
                        }
                        
                        // F16 (forward DELETE) does not move the caret, hence, we use the same flags. However,
                        // Backspace defaults the the beginning of the line.
                        
                        if( keyCode == VK_BACK )
                        {
                            CEditPointer ep(_pManager->GetEditor());
                            DWORD        dwFound;
                            BOOL         fFoundText;
                            DISPLAY_GRAVITY eDispGravity;

                            // If there is text to the left of the new caret position, we want 
                            // fNotAtBOL == TRUE instead of FALSE
                            IFC( ep->MoveToPointer(spPointer) );
                            IFC( ep.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, &dwFound) );

                            fFoundText = ep.CheckFlag(dwFound, BREAK_CONDITION_TEXT);

                            eDispGravity = fFoundText ? DISPLAY_GRAVITY_PreviousLine : DISPLAY_GRAVITY_NextLine;
                            IFC( SetCaretDisplayGravity(eDispGravity) );
                            IFC( spDispCaret->SetDisplayGravity(eDispGravity) );
                        }
                        
                        // Disable auto-detect during backspace
                        _pManager->HaveTypedSinceLastUrlDetect();
                        _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );

                        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                        IFC( spDispPointer->MoveToMarkupPointer(spPointer, spDispCaret) );
                        IFC( PositionCaretAt( spDispPointer, CARET_DIRECTION_FORWARD , POSCARETOPT_None, ADJPTROPT_None ));
    
                        if (IsInsideUrl(spPointer))
                        {
                            IGNORE_HR( UrlAutodetectCurrentWord( NULL ) );
                            _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );
                        }
                        else
                        {
                            _pManager->SetHaveTypedSinceLastUrlDetect( TRUE );
                        }

                    }
                }

                break;
            }

            case VK_ESCAPE:
            {
                if ( _pManager->HasFocusAdorner() )
                {
                    IFC( HandleEscape());
                    goto Cleanup;
                }                    
            }
            break;
            
           
                
            case VK_INSERT: // we should handle this in keydown - sets the appropriate flag
            {
                BOOL newORMode = ! ( _pManager->GetOverwriteMode());
                
                if( pEvent->IsShiftKeyDown() || pEvent->IsControlKeyDown() || pEvent->IsAltKeyDown() )
                {
                    hr = S_FALSE;
                    break;
                }
                
                hr = S_OK;
                _pManager->SetOverwriteMode( newORMode );
                break;
            }

            case VK_TAB:
            {
                //
                // TODO: This is a hack. We have to do this because Trident never gives us
                // the VK_TAB as a WM_CHAR message.
                //
                if( pEvent->IsShiftKeyDown() || pEvent->IsControlKeyDown() || pEvent->IsAltKeyDown() )
                {
                    hr = S_FALSE;
                    break;
                }

                hr = THR( HandleChar( pEvent ));

                break;
            }

#ifndef NO_IME
            case VK_KANJI:
                if (   949 == GetKeyboardCodePage()
                    && _pManager->IsContextEditable())
                {
                    THR(_pManager->StartHangeulToHanja(NULL, pEvent ));
                }
                hr = S_OK;
                break;
#endif // !NO_IME

                // only get line direction if the left or right key are used 
                // this is a performance enhancement 
            case VK_LEFT:
            case VK_RIGHT:
            case VK_UP:
            case VK_DOWN:
            {
                SP_IHTMLCaret       spCaret;
                SP_IDisplayPointer  spDispPointer;
                HRESULT             hr2 = S_FALSE;
                SP_IMarkupPointer   spMarkup;
                SP_IHTMLElement     spElement;

                // alt+VK_LEFT and alt+VK_RIGHT are navigation commands and are not 
                // meant to move the caret. We should return S_FALSE and let trident
                // navigate.

                //
                // We will not deal with Alt+ combinations in any case - zhenbinx
                //
                Assert(VK_PRIOR + 1 == VK_NEXT);
                Assert(VK_NEXT  + 1 == VK_END);
                Assert(VK_END   + 1 == VK_HOME);
                Assert(VK_HOME  + 1 == VK_LEFT);
                Assert(VK_LEFT  + 1 == VK_UP);
                Assert(VK_UP    + 1 == VK_RIGHT);
                Assert(VK_RIGHT + 1 == VK_DOWN);
                if (pEvent->IsAltKeyDown() && (VK_LEFT <= keyCode && keyCode <= VK_DOWN))
                {
                    goto Cleanup;
                }

                hr2 = THR( GetDisplayServices()->CreateDisplayPointer( &spDispPointer ));
                if (hr2)
                    goto Cleanup;

                hr2 = THR( GetDisplayServices()->GetCaret( &spCaret ));
                if (hr2)
                    goto Cleanup;

                hr2 = THR( spCaret->MoveDisplayPointerToCaret( spDispPointer ));
                if (hr2)
                    goto Cleanup;

                hr2 = THR( spDispPointer->GetLineInfo(&spLineInfo));
                if (hr2)
                    goto Cleanup;

                hr2 = THR( spLineInfo->get_lineDirection(&eLineDir));
                if (hr2)
                    goto Cleanup;

                //
                // Need to get vertical-ness
                //
                IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
                IFC( spDispPointer->PositionMarkupPointer(spMarkup) );
                IFC( spMarkup->CurrentScope(&spElement) );
                IFC( MshtmledUtil::IsElementInVerticalLayout(spElement, &fVertical) );
                
            }
            // we don't want a break here. Fall through to default 
            default:
            {

                CARET_MOVE_UNIT cmu = GetMoveDirectionFromEvent( pEvent,  (eLineDir == LINE_DIRECTION_RightToLeft), fVertical);
                
                if( cmu != CARET_MOVE_NONE )
                {
                    if( pEvent->IsShiftKeyDown() )
                    {
                        VARIANT_BOOL fRet = VB_TRUE;
                        IFC( _pManager->GetEditableElement( &spEditElement ));
                        if (spEditElement)
                        {
                            hr = THR(spEditElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
                            if (!hr)
                               hr = THR(spElement3->fireEvent(_T("onselectstart"), NULL, &fRet));
                        }

                        if (!!hr || fRet)
                        {
                            hr = _pManager->StartSelectionFromShift( pEvent );
                            _pManager->_fEnsureAtomicSelection = TRUE;
#ifndef NO_IME
                            if (_pManager->IsIMEComposition())
                            {
                                _pManager->TerminateIMEComposition(TERMINATE_NORMAL);
                            }
#endif // NO_IME
                        }                            
                    }
                    else
                    {
                        SP_IMarkupPointer  spOrigCaretPointer;
                        SP_IDisplayPointer spDispPointer;
                        SP_IHTMLElement    spAtomicElement;
                        SP_IHTMLCaret      spCaret;
                        BOOL               fStartIsAtomic = FALSE;
                        
                        IFC( GetDisplayServices()->CreateDisplayPointer( &spDispPointer ));
                        IFC( GetDisplayServices()->GetCaret( &spCaret ));
                        IFC( GetEditor()->CreateMarkupPointer(&spOrigCaretPointer) );
                        IFC( spCaret->MoveMarkupPointerToCaret(spOrigCaretPointer) );

                        //  Check the atomic selection setting for the element we are orininally in.
                        if (cmu == CARET_MOVE_BACKWARD || cmu == CARET_MOVE_WORDBACKWARD)
                        {
                            IFC( spCaret->MoveDisplayPointerToCaret( spDispPointer ));
                            IFC( GetCurrentScope(spDispPointer, &spAtomicElement) );
                            fStartIsAtomic = ( _pManager->CheckAtomic(spAtomicElement) == S_OK );
                        }

                        //  Move the caret.
                        IFC( MoveCaret(pEvent, cmu, spDispPointer, TRUE) );
                 
                        //  See if we moved the caret into an atomic selected element.
                        //  Adjust if we need to.
                        IFC( spCaret->MoveDisplayPointerToCaret( spDispPointer ));
                        IFC( GetCurrentScope(spDispPointer, &spAtomicElement) );
                        if ( _pManager->CheckAtomic(spAtomicElement) == S_OK )
                        {
                            //  We moved into an atomic element.  So we now want to select the
                            //  atomic element rather than reposition the caret outside of it.
                            if ((cmu != CARET_MOVE_BACKWARD && cmu != CARET_MOVE_WORDBACKWARD) || fStartIsAtomic)
                            {
                                hr = THR( _pManager->StartAtomicSelectionFromCaret( spDispPointer ) );

                                //
                                // Set _ptVirtualCaret for SelectTracker
                                //
                                if (SUCCEEDED(hr))
                                {
                                    SP_IMarkupPointer   spMarkup;
                                    POINT               ptLoc;

                                    IFC( _pManager->GetEditor()->CreateMarkupPointer(&spMarkup) );
                                    IFC( spDispPointer->PositionMarkupPointer(spMarkup) );
                                    IFC( _ptVirtualCaret.GetPosition(spMarkup, &ptLoc) );
                                    Assert( _pManager->GetActiveTracker()->GetTrackerType() == TRACKER_TYPE_Selection);                                    
                                    IFC( _pManager->GetActiveTracker()->GetVirtualCaret().UpdatePosition(spMarkup, ptLoc) ); 
                                }
                                goto Cleanup;
                            }
                            else
                            {
                                SP_IMarkupPointer   spPointer;
                                BOOL                fAtOutsideEdge = FALSE;

                                IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
                                IFC( spPointer->MoveAdjacentToElement( spAtomicElement, ELEM_ADJ_AfterEnd) );
                                IFC( spPointer->IsEqualTo(spOrigCaretPointer, &fAtOutsideEdge) );

                                if (!fAtOutsideEdge)
                                {
                                    SP_IDisplayPointer  spDispCaret;

                                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
                                    IFC( spDispCaret->MoveToMarkupPointer(spPointer, NULL) );
                                    IFC( spCaret->MoveCaretToPointer(spDispCaret, FALSE, CARET_DIRECTION_INDETERMINATE) );
                                }
                            }

                            _pManager->_fEnsureAtomicSelection = TRUE;
                        }
                    }
                }
                break;
            }
        }

        //
        // Direction keys
        //
        if (S_FALSE == hr)
        {
            hr = HandleDirectionalKeys(pEvent);
        }
    }
    //
    // Not editable case
    // this is possible for a viewlink/iframe with contents not editable
    // but we have the focus adorner
    //
    else if ( keyCode == VK_ESCAPE &&
              _pManager->HasFocusAdorner())
    {
        IFC( HandleEscape());
    }

Cleanup:


    return( hr );
}

HRESULT
CCaretTracker::HandleEscape()
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spEditElement ;
    SP_IMarkupPointer spStartCaret;
    SP_IMarkupPointer spEndCaret;
    CSelectionChangeCounter selCounter(_pManager);
    
    //
    // If we're in a UI Active control - we site select it.
    //
    SP_IDisplayPointer spDispStartCaret;
    SP_IDisplayPointer spDispEndCaret;
    
    //
    // We create 2 pointers, move them around the control, Position the Temp Markup Pointers
    // and then Site Select the Control
    //
    IFC( GetEditor()->CreateMarkupPointer( & spStartCaret ));
    IFC( GetEditor()->CreateMarkupPointer( & spEndCaret ));
    IFC( _pManager->GetAdornedElement( & spEditElement ));
   
    IFC( spStartCaret->MoveAdjacentToElement( spEditElement, ELEM_ADJ_BeforeBegin ));
    IFC( spEndCaret->MoveAdjacentToElement( spEditElement, ELEM_ADJ_AfterEnd ));

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispStartCaret) );
    IFC( spDispStartCaret->MoveToMarkupPointer(spStartCaret, NULL) );
    IFC( spDispStartCaret->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    
    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEndCaret) );
    IFC( spDispEndCaret->MoveToMarkupPointer(spEndCaret, NULL) );
    IFC( spDispEndCaret->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    

    IFC( GetEditor()->MakeParentCurrent( spEditElement ));

    selCounter.BeginSelectionChange();
    IFC( _pManager->PositionControl( spDispStartCaret, spDispEndCaret )); 
    selCounter.EndSelectionChange();
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CCaretTracker::HandleKeyUp(
                CEditEvent* pEvent )
{
    return HandleDirectionalKeys(pEvent);
}

//+====================================================================================
//
// Method: HandleInputLangChange
//
// Synopsis: Update the screen caret to reflect change in keyboard language
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::HandleInputLangChange()
{
    HRESULT hr = S_FALSE;
    SP_IHTMLCaret       spCaret;
    SP_IMarkupPointer   spPointer;
    

    if ( IsContextEditable() )
    {
        BOOL fVisible;

        IFC( _pManager->GetEditor()->CreateMarkupPointer( &spPointer  ));                        
        IFC( GetDisplayServices()->GetCaret( &spCaret ));
        IFC( spCaret->IsVisible(&fVisible) );
        if (fVisible)        
        {
            //
            // force an update caret to handle shape change
            //
            IGNORE_HR( spCaret->Show(FALSE /* fScrollIntoView */) );
        }
        hr = S_OK;
    }

    // Something seems to be missing here...
Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method: HandleEnter
//
// Synopsis: Handle the enter key
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::HandleEnter( CEditEvent* pEvent, IHTMLCaret * pCaret, BOOL fShift, BOOL fCtrl )
{
    HRESULT             hr = S_FALSE;
    IMarkupServices *   pMarkupServices = _pManager->GetMarkupServices();
    SP_IMarkupPointer   spPos;
    SP_IMarkupPointer   spNewPos;
    SP_IHTMLElement     spFlowElement;
    VARIANT_BOOL        bHTML;
    VARIANT_BOOL        bMultiLine = VARIANT_FALSE;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement3    spElement3;
    CSpringLoader       *pSpringLoader = NULL;
    CEdUndoHelper       undoUnit(_pManager->GetEditor());
    SP_IDisplayPointer  spDispNewPos;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    //
    // Position a worker pointer at the current caret location. Then
    // check to see if we are in a multi-line flow element.
    //
    IFC( _pManager->GetEditor()->CreateMarkupPointer( &spPos ));
    IFC( pCaret->MoveMarkupPointerToCaret( spPos ));
    IFC( GetEditor()->GetFlowElement( spPos, &spFlowElement ));
    if ( ! spFlowElement )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC(spFlowElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->get_isMultiLine(&bMultiLine));
    if (!bMultiLine)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Get the spring loader
    pSpringLoader = GetSpringLoader();

#ifndef NO_IME
    if (_pManager->IsIMEComposition())
    {
        _pManager->TerminateIMEComposition( TERMINATE_NORMAL, pEvent );
    }
#endif // NO_IME

    //
    // Check to see if we can contain HTML. If not, just insert a \r.
    //

    IFC(spElement3->get_canHaveHTML(&bHTML));


    if (bHTML && !fShift && ShouldEnterExitList(spPos, &spElement))
    {
        IFC( undoUnit.Begin(IDS_EDUNDOTYPING) );

        IFC( ExitList(spElement) );

        // May need to scroll 
        IGNORE_HR( pCaret->ScrollIntoView() ); // ScrollIntoView can return S_FALSE - we want to return S_OK to say we consumed the event                    
        goto Cleanup;            
    }
    else
    {
        IFC( BeginTypingUndo(&undoUnit, IDS_EDUNDOTYPING) );

        if (!bHTML)
        {
            IFC( spPos->SetGravity( POINTER_GRAVITY_Right ));
            IFC( pCaret->InsertText(_T("\r"),1));

            spNewPos = spPos;
        }
        else
        {
            if( fShift )
            {                  
                CEditPointer    ep(GetEditor());
                DWORD           dwFound;
                
                // Fire the spring loader before inserting the <BR>
                if( pSpringLoader != NULL )
                {
                    pSpringLoader->Fire(spPos);
                }
        
                IFC( pMarkupServices->CreateElement( TAGID_BR, NULL, &spElement ));
                IFC( InsertElement(pMarkupServices, spElement, spPos, spPos ));
                IFC( _pManager->GetEditor()->CreateMarkupPointer( &spNewPos ));
                IFC( spNewPos->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterEnd ));                    

                // TODO: use inflate block 

                //
                // Check for </BlockElement>.  If found, make sure breakonempty is set.
                //

                IFC( ep->MoveToPointer(spNewPos) );
                IFC( ep.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound, &spElement, NULL, NULL, SCAN_OPTION_SkipWhitespace) );

                if (ep.CheckFlag(dwFound, BREAK_CONDITION_ExitBlock) && !ep.CheckFlag(dwFound, BREAK_CONDITION_Site))
                {
                    ELEMENT_TAG_ID tagId;

                    IFC( pMarkupServices->GetElementTagId(spElement, &tagId) );
                    if (!IsListContainer(tagId) && tagId != TAGID_LI)
                    {
                        SP_IHTMLElement3 spElement3;
                        
                        IFC( spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
                        IFC( spElement3->put_inflateBlock( VARIANT_TRUE ) );
                    }                
                }
            }
            else
            {
                CEditPointer epTest(GetEditor());
                DWORD        dwSearch, dwFound;
                
                // Fire the spring loader on empty lines
                if( pSpringLoader != NULL )
                {
                    pSpringLoader->FireOnEmptyLine( spPos, TRUE );
                }

                //
                // If we have glyphs turned on, we can get inbetween block elements.  So
                // to be compat with fontpage, we check for this case and adjust into the
                // block element on the left.
                //
                // For example, we could end up with </P>{caret}<P>.
                //
                // In this case, we want to adjust into blocks so that we have {caret}</P><P>
                //
                
                IFC( epTest->MoveToPointer(spPos) );

                dwSearch = BREAK_CONDITION_Content | BREAK_CONDITION_Glyph;
                
                IFC( epTest.Scan(LEFT, dwSearch, &dwFound) );
                if (!epTest.CheckFlag(dwFound, BREAK_CONDITION_Glyph) 
                    || !epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
                {
                    IFC( epTest.Scan(RIGHT, dwSearch, &dwFound) );
                }

                if (epTest.CheckFlag(dwFound, BREAK_CONDITION_Glyph) 
                    && epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
                {       
                    SP_IDisplayPointer spDispPos;

                    //
                    // We are between blocks due to glyphs, so adjust for insert.
                    //

                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPos) );
                    IFC( pCaret->MoveDisplayPointerToCaret(spDispPos) );

                    // Frontpage compat
                    IFC( spDispPos->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );

                    // Adjust pointer
                    IFC( GetEditor()->AdjustPointer(
                        spDispPos, LEFT, LEFT, _pManager->GetStartEditContext(), _pManager->GetEndEditContext(), 0));

                    IFC( spDispPos->PositionMarkupPointer(spPos) );
                }
                
                //
                // Handle enter
                //
                
                IFC( _pManager->GetEditor()->HandleEnter( spPos, &spNewPos, pSpringLoader ));
            }    
        }

    }
    //
    // Move the caret to the new location.
    // We know we are going right and are visible, if ambiguious, 
    // we are at the beginning of the inserted line
    //

    IFC( SetCaretDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    
    IFC( ConstrainPointer( spNewPos ));
    
    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispNewPos) );
    IFC( spDispNewPos->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    IFC( spDispNewPos->MoveToMarkupPointer(spNewPos, NULL) );
    
    IFC( pCaret->MoveCaretToPointer( spDispNewPos, TRUE, CARET_DIRECTION_FORWARD));
    _fCheckedCaretForAtomic = FALSE;

    if(pSpringLoader && spNewPos)
        pSpringLoader->Reposition(spNewPos);

Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    RRETURN1(hr, S_FALSE);
}


HRESULT
CCaretTracker::PositionCaretFromEvent(
                CEditEvent* pEvent )
{
    IDisplayPointer * pDispPointer = NULL;

    ELEMENT_TAG_ID eTag = TAGID_NULL;
    SP_IHTMLElement spEditElement;
    SP_IHTMLElement spHitTestElement;
    
    HRESULT hr = S_OK;

    if ( pEvent )
    {
        //
        // We may require the caret to become visible again, but we should only
        // move on button down
        //
        if ( ( pEvent->GetType() == EVT_LMOUSEDOWN ) || 
             ( pEvent->GetType() == EVT_LMOUSEUP ) ||
             ( pEvent->GetType() == EVT_RMOUSEUP ) 
#ifdef UNIX
                || ( pEvent->GetType() == EVT_MMOUSEDOWN )
#endif
            )
        {
#ifdef FORMSMODE
            if (_pManager->IsInFormsSelectionMode())
                goto Cleanup;
#endif             
            hr = THR( GetDisplayServices()->CreateDisplayPointer( & pDispPointer));
            if ( hr )
                goto Cleanup;
            
            IFC( pEvent->GetElement( & spEditElement ));
            IFC( GetLayoutElement( GetMarkupServices(), spEditElement, & spHitTestElement ));

            //
            // Just in case move the mouse into a different edit context between
            // and rbutton-down and rbutton-up
            // 
            IFC( _pManager->EnsureEditContextClick( spEditElement ) );
            
            hr = THR( pEvent->MoveDisplayPointerToEvent( pDispPointer, spHitTestElement ));
            if( hr ) 
            {
                _fValidPosition = FALSE;
                goto Cleanup;
            }

            //
            // IEV6-14696-zhenbinx-10/17/2000
            // The element might not be editable. This could happen if 
            // a noneditable element is inside edit context.  RMOUSEDOWN 
            // setup the edit context and RMOUSEUP will try to position the caret.
            //
            if (EdUtil::IsEditable(spEditElement) == S_FALSE)
            {
                _fValidPosition = FALSE;
                goto Cleanup;
            }
                
            hr = PositionCaretAt( pDispPointer, CARET_DIRECTION_FORWARD, POSCARETOPT_None, ADJPTROPT_None );
            if ( hr )
                goto Cleanup;
        }
        else
        {
            SetCaretShouldBeVisible ( ShouldCaretBeVisible() );
        }
        
        IFC( pEvent->GetTagId( &eTag));
    }    

Cleanup:
    ReleaseInterface( pDispPointer );
    RRETURN ( hr );
}

//
//
// Typing & Undo
//
//
//
//+====================================================================================
//
// Method: HandleSpace
//
// Synopsis: Handle conversion of spaces to NBSP.
//
//------------------------------------------------------------------------------------



HRESULT
CCaretTracker::HandleSpace( OLECHAR t )
{
    HRESULT hr = S_OK;
    SP_IMarkupPointer   spPos;
    SP_IHTMLCaret pc;
    CEdUndoHelper undoUnit(_pManager->GetEditor()); 

    BOOL fOverWrite = _pManager->GetOverwriteMode();
    IFC( GetDisplayServices()->GetCaret( &pc ));

    //
    // Only insert nbsp if the container can accept html and isn't in a PRE tag
    //
    if( _pManager->CanContextAcceptHTML() && ! IsCaretInPre( pc ) )
    {
        ED_PTR( spPos ) ;
        DWORD dwSearch = BREAK_CONDITION_OMIT_PHRASE;
        DWORD dwFound = BREAK_CONDITION_None;                    
        OLECHAR chTest;

        IFC( pc->MoveMarkupPointerToCaret( spPos ));
        IFC( spPos.Scan( LEFT , dwSearch , &dwFound , NULL , NULL , & chTest , NULL ));
        
        if( spPos.CheckFlag( dwFound, BREAK_CONDITION_Text ) && chTest == 32 )
        {    
            IFC( BeginTypingUndo(&undoUnit, IDS_EDUNDOTYPING) );

            //
            // there is a space to the left of us, delete it and insert
            // "&nbsp "
            //
            
            SP_IMarkupPointer spCaret;
            OLECHAR t2[2];
            t2[0] = 160;
            t2[1] = 32;
            
            IFC( _pManager->GetEditor()->CreateMarkupPointer( & spCaret ));
            IFC( pc->MoveMarkupPointerToCaret( spCaret ));
            IFC( _pManager->GetMarkupServices()->Remove( spCaret, spPos ));
            IFC( InsertText( t2, 2, pc ));                    

            goto Cleanup;
            
        }
        else if( spPos.CheckFlag( dwFound, BREAK_CONDITION_TEXT - BREAK_CONDITION_Text ) ||
                 spPos.CheckFlag( dwFound, BREAK_CONDITION_Site )                        ||
                 spPos.CheckFlag( dwFound, BREAK_CONDITION_Block )                       ||
                 spPos.CheckFlag( dwFound, BREAK_CONDITION_NoScopeBlock ) )

        {
            //
            // There is an image, control, block or site to the left of us
            // so we should insert an &nbsp
            //

            t = 160;
        }
        else
        {
            //
            // plain text or nbsp to my left, look right. If there is a space to my right,
            // insert an nbsp.
            //
            
            IFC( pc->MoveMarkupPointerToCaret( spPos ));
            dwFound = BREAK_CONDITION_None;
            IFC( spPos.Scan( RIGHT , dwSearch , &dwFound , NULL , NULL , & chTest , NULL ));

            if( spPos.CheckFlag( dwFound, BREAK_CONDITION_Text ) && chTest == 32 )
            {
                OLECHAR chNBSP = 160;

                IFC( BeginTypingUndo(&undoUnit, IDS_EDUNDOTYPING) );
    
                CEditPointer epStart(_pManager->GetEditor());
                
                // there is a space to our right, we should replace it with an nbsp

                IFC( GetMarkupServices()->InsertText(&chNBSP, 1, spPos) );
                IFC( epStart->MoveToPointer(spPos) );
                IFC( epStart.Scan( LEFT, dwSearch , &dwFound , NULL , NULL , NULL , NULL ));
                Assert(epStart.CheckFlag(dwFound, BREAK_CONDITION_Text));
                IFC( GetMarkupServices()->Remove(epStart, spPos) );
            }
            
        }

    }

    IFC( InsertText( &t, 1, pc, fOverWrite ));

Cleanup:
    RRETURN( hr );
}
          

//+---------------------------------------------------------------------------
//
//  Member:     CCaretTracker::ShouldTerminateTypingUndo, private
//
//  Synopsis:   Decides when to terminate the current typing batch undo unit.
//              Tries to emulate word insert loop behavior.
//
//  Arguments:  [pMessage] - current selection message
//
//  Returns:    BOOL - whether or not to terminate
//
//----------------------------------------------------------------------------

BOOL
CCaretTracker::ShouldTerminateTypingUndo(CEditEvent* pEvent )
{
    CARET_MOVE_UNIT cmu;
    LONG keyCode;
    
    //
    // We try to emulate the word model of undo batching by terminating
    // undo on the following messages.
    //

    switch (pEvent->GetType() )
    {
        case EVT_KEYDOWN:
            // Terminate for special chars
            IGNORE_HR( pEvent->GetKeyCode( & keyCode ));
            switch ( keyCode )
            {
                case VK_ESCAPE:
                case VK_INSERT:
                case VK_TAB:                
                    return TRUE;
            }

            // Terminate undo for keynav case
            cmu = GetMoveDirectionFromEvent( pEvent, FALSE /* fRightToLeft */, FALSE /*fVertical*/);
            return (cmu != CARET_MOVE_NONE);
       
        case EVT_KEYPRESS:

            IGNORE_HR( pEvent->GetKeyCode(& keyCode));
            if (keyCode < ' ' && keyCode != VK_RETURN && keyCode != VK_BACK)
                return TRUE;

            return FALSE;
       
        case EVT_MOUSEMOVE:
        case EVT_TIMER:
        case EVT_KEYUP:
            return FALSE;
    }

    return TRUE;    
}

//+---------------------------------------------------------------------------
//
//  Member:     CCaretTracker::BeginUndoUnit, private
//
//  Synopsis:   Ensures we have a typing batch undo unit on the
//              top of the undo stack and then begins the undo unit.
//
//  Arguments:  [pUndoUnit]  - undo unit manager
//              [uiStringID] - resource id for the undo unit
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CCaretTracker::BeginTypingUndo(CEdUndoHelper *pUndoUnit, UINT uiStringID)
{
    HRESULT hr = S_OK;
    SP_IOleUndoManager spUndoMgr;;
    
    Assert( pUndoUnit );

    //
    // If the current batch parent undo unit is not on the top of the
    // stack, we can't batch.
    //

    if (_pBatchPUU && !_pBatchPUU->IsTopUnit())
    {
        _pBatchPUU->Release();
        _pBatchPUU = NULL;
    }

    //
    // Create a new parent undo unit if there isn't one we can reuse
    //

    if (!_pBatchPUU)
    {
        _pBatchPUU = new CBatchParentUndoUnit(_pManager->GetEditor(), uiStringID);
        if (!_pBatchPUU)
            RRETURN(E_OUTOFMEMORY);

        //
        // Create and commit an empty batch undo unit.  The begin call below
        // will cause the proxy to add to this undo unit.
        //
        IFC( _pManager->GetEditor()->GetUndoManager( & spUndoMgr ));        
        IFC( spUndoMgr->Open(_pBatchPUU) );
        IFC( spUndoMgr->Close(_pBatchPUU, TRUE) );
    }        

    IFC( pUndoUnit->Begin(uiStringID, _pBatchPUU) );
    
Cleanup:
    RRETURN(hr);    
}


HRESULT
CCaretTracker::InsertText( 
    OLECHAR    *    pText,
    LONG            lLen,
    IHTMLCaret *    pc,
    BOOL            fOverWrite)
{
    HRESULT             hr = S_OK;
    CSpringLoader       * psl = NULL;
    SP_IMarkupPointer   spStartPosition;
    SP_IMarkupPointer   spCaretPosition;

    Assert(pText && pc);

    CEdUndoHelper undoUnit(_pManager->GetEditor()); 

    IFC( BeginTypingUndo(&undoUnit, IDS_EDUNDOTYPING) );

    IFC( GetEditor()->CreateMarkupPointer( & spCaretPosition ));
    IFC( pc->MoveMarkupPointerToCaret( spCaretPosition ));

    if (fOverWrite)
    {
        IFC( DeleteNextChars(spCaretPosition, lLen) );
    }

    // Get the spring loaded state
    psl = GetSpringLoader();

    // If whitespace, make sure we fall out of the current URL (if any)
    if (pText && (lLen >= 1 || lLen == -1) && IsWhiteSpace(*pText) && pc)
    {
        ED_PTR( ep); 
        DWORD        dwFound;

        // A failure here should not abort the text insertion
        hr = THR( pc->MoveMarkupPointerToCaret(ep) );            
        if (SUCCEEDED(hr))
        {
            SP_IHTMLElement spElement; 
        
            hr = THR( ep.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound, &spElement) );
            if (SUCCEEDED(hr) 
                && ep.CheckFlag(dwFound, BREAK_CONDITION_ExitAnchor)
                && IsQuotedURL(spElement) == S_FALSE)
            {
                SP_IDisplayPointer spDispPointer;
                
                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                IFC( spDispPointer->MoveToMarkupPointer(ep, NULL) );
                IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                
                hr = THR( pc->MoveCaretToPointer(spDispPointer, FALSE /* fScrollIntoView */, CARET_DIRECTION_INDETERMINATE) );
                _fCheckedCaretForAtomic = FALSE;

                // Can't trust spring loaded space from inside the anchor,
                // so reset
                if (SUCCEEDED(hr) && psl)
                    psl->Reset();
            }
        }
    }

    // Fire the spring loader at the caret position.
    if (psl && psl->IsSpringLoaded())
    {
        IFC( GetEditor()->CreateMarkupPointer( & spStartPosition ));
        IFC( pc->MoveMarkupPointerToCaret( spStartPosition) );        

        IFC( pc->InsertText( pText , lLen ) );

        IFC( pc->MoveMarkupPointerToCaret( spCaretPosition ));
        IGNORE_HR(psl->Fire( spStartPosition, spCaretPosition, FALSE ));
    }
    else
    {
        IFC( pc->InsertText( pText , lLen ) );
    }

    IFC( SetCaretDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );

    // Update the IME Position if a composition is in progress
    if( _pManager->IsIMEComposition() )
    {
        _pManager->UpdateIMEPosition();
    }
           
    // Autodetect on space, return, or anyof the character in the string.
    if( VK_TAB == (DWORD) pText[0]
        || VK_SPACE == (DWORD) pText[0] 
        || IsInsideUrl(spCaretPosition))
    {
        IGNORE_HR( UrlAutodetectCurrentWord( pText ) );
        _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );
    }
// t-amolke (06/01/99) - The following piece of code was commented out: Now URL autodetection will not occur
// on quote, but only on white space. Also, quotes around URLs seems to work properly without this code.
#if 0
else if (_T('"') == pText[0]
             || _T('>') == pText[0])
    {
        ED_PTR( ep );         
        DWORD        dwFound;
        
        // Before we autodetect again on a quote, make sure we don't have an url to the left of us.
        // This behavior will allow the user to add quotes around a url without them being deleted.

        IFC( pc->MoveMarkupPointerToCaret(ep) );
        IFC( ep.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) ); // skip quote
        Assert(ep.CheckFlag(dwFound, BREAK_CONDITION_Text)); 

        IFC( ep.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) ); // find out what is left of the quote

        if (!ep.CheckFlag(dwFound, BREAK_CONDITION_EnterAnchor))
        {
            IGNORE_HR( UrlAutodetectCurrentWord( pText ) );
            _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );
        }        
    }
#endif
    else
    {
        _pManager->SetHaveTypedSinceLastUrlDetect( TRUE );
    }

    if (pc)
    {
        pc->SetCaretDirection(CARET_DIRECTION_FORWARD);
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CCaretTracker::HandleBackspaceSpecialCase(IMarkupPointer *pPointer)
{
    HRESULT         hr;
    ED_PTR( epTest );     
    SP_IHTMLElement spElement;
    DWORD           dwFound;
    DWORD           dwOptions = SCAN_OPTION_None;
    
    Assert(pPointer);

    //
    // If we backspace at the edge of an anchor, remove the anchor
    //
    
    IFR( epTest->MoveToPointer(pPointer) );

    //
    // If backspace is hit right after url autodetection, then we will 
    // allow whitespace
    //

    Assert(GetEditor()->GetAutoUrlDetector());
    
    if (!GetEditor()->GetAutoUrlDetector()->UserActionSinceLastDetection())
    {
        dwOptions |= SCAN_OPTION_SkipWhitespace;
    }

    //
    // Look for the anchor to remove
    //

    IFR( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound, &spElement, NULL, NULL, dwOptions) ); 
    if (epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterAnchor))
    {
        CEdUndoHelper undoUnit( _pManager->GetEditor() );

        undoUnit.Begin( IDS_EDUNDOTEXTDELETE );
        IFR( GetMarkupServices()->RemoveElement(spElement) );
        _pManager->SetHaveTypedSinceLastUrlDetect(TRUE);
        
        return S_OK;
    }

    return S_FALSE; // not a special case
    
}

HRESULT
CCaretTracker::TerminateTypingBatch()
{
    if (_pBatchPUU)
    {
        _pBatchPUU->Release();
        _pBatchPUU = NULL;
    }

    return S_OK;
}  

//+----------------------------------------------------------------------------
//
//  Function:   UrlAutoDetectCurrentWord
//
//  Synopsis:   Performs URL autodetection on the current word (ie, around
//      or just prior to the caret). 
//      Note: Autodetection is not always triggered by a character (can
//      be by caret movement, etc.).  In this case, pChar should be NULL,
//      and some rules are different.
//
//  Arguments:  [pChar]     The character entered that triggered autodetction.
//
//  Returns:    HRESULT     S_OK if everything's cool, otherwise error
//
//-----------------------------------------------------------------------------
HRESULT
CCaretTracker::UrlAutodetectCurrentWord( OLECHAR *pChar )
{
    HRESULT                 hr              = S_OK;
    IHTMLCaret          *   pc              = NULL;
    IHTMLElement        *   pElement        = NULL;
    IHTMLElement        *   pAnchor         = NULL;
    IMarkupServices     *   pms             = _pManager->GetMarkupServices();
    IMarkupPointer      *   pmp             = NULL;
    IMarkupPointer      *   pLeft           = NULL;
    BOOL                    fFound          = FALSE;
    BOOL                    fLimit          = FALSE;
    AUTOURL_REPOSITION      aur;

    if( IsContextEditable() )
    {
        hr = THR( GetDisplayServices()->GetCaret( &pc ) );
        if( hr )
            goto Cleanup;

        hr = THR( GetEditor()->CreateMarkupPointer( &pmp ) );
        if( hr )
            goto Cleanup;

        hr = THR( GetEditor()->CreateMarkupPointer( &pLeft ) );
        if( hr )
            goto Cleanup;

        hr = THR( pc->MoveMarkupPointerToCaret( pmp ) );
        if( hr )
            goto Cleanup;

        if( pChar )
        {    
            hr = THR( pmp->MoveUnit( MOVEUNIT_PREVCHAR ) );
            if( hr )
                goto Cleanup;

            if( VK_RETURN == *pChar )
            {
                pChar = NULL;
            }
            else 
            {
                fLimit = ( _T('"') == *pChar ||
                           _T('>') == *pChar );

                if( fLimit )
                {
                    // If we're in an anchor, don't limit because of a quote.
                    IFC( pmp->CurrentScope( &pElement ) );

                    IFC( FindTagAbove( pms, pElement, TAGID_A, &pAnchor ) );
                    fLimit = !pAnchor;
                }
            }
        }

        // Position left to our current position
        hr = THR( pLeft->MoveToPointer( pmp ) );
        if( hr ) 
            goto Cleanup;

        // Fire off the autodetection
        hr = THR( _pManager->GetEditor()->GetAutoUrlDetector()->DetectCurrentWord( pmp, pChar, &aur, fLimit ? pmp : NULL, pLeft, &fFound ) );
        if( hr )
            goto Cleanup;

        if ( aur != AUTOURL_REPOSITION_No )
        {
            ED_PTR( epAdjust ); 
            DWORD        dwSearch = BREAK_CONDITION_OMIT_PHRASE;
            DWORD        dwFound;
            Direction    eTextDir;
            SP_IDisplayPointer spDispAdjust;
            SP_IDisplayPointer spDispLine;

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispLine) );
            IFC( pc->MoveDisplayPointerToCaret( spDispLine ) );            
            IFC( pc->MoveMarkupPointerToCaret( epAdjust ) );
            
            eTextDir = ( aur == AUTOURL_REPOSITION_Inside ) ? LEFT : RIGHT;

            IFC( epAdjust.Scan(eTextDir, dwSearch - BREAK_CONDITION_Anchor, &dwFound) );
            if (epAdjust.CheckFlag(dwFound, dwSearch))
            {
                IFC( epAdjust.Scan(Reverse(eTextDir), dwSearch, &dwFound) );
            }

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispAdjust) );
            IFC( spDispAdjust->MoveToMarkupPointer(epAdjust, spDispLine) );

            if (hr == S_FALSE)
            {
                IFC( spDispAdjust->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
            }
            
            IFC( pc->MoveCaretToPointer( spDispAdjust, TRUE, CARET_DIRECTION_INDETERMINATE ));
            _fCheckedCaretForAtomic = FALSE;
        }
    } 
Cleanup:

    ReleaseInterface( pc );
    ReleaseInterface( pmp );
    ReleaseInterface( pElement );
    ReleaseInterface( pAnchor );
    ReleaseInterface( pLeft );

    RRETURN( hr );
}


HRESULT
CCaretTracker::DeleteNextChars(
    IMarkupPointer *    pPos,
    LONG                lLen)
{
    HRESULT hr = S_OK;
    LONG cch;
    OLECHAR chTest = 0;
    MARKUP_CONTEXT_TYPE eCtxt;
    SP_IMarkupPointer spEnd;
    SP_IHTMLElement spElement;
    BOOL fDone = FALSE;
    
    IFC( GetEditor()->CreateMarkupPointer( & spEnd ));

    if( pPos )
    {
        IFC( spEnd->MoveToPointer( pPos ));
    }
    else
    {
        SP_IHTMLCaret pc;
        IFC( GetDisplayServices()->GetCaret( & pc ));
        IFC( pc->MoveMarkupPointerToCaret( spEnd ));
    }

    while( ! fDone)
    {
        cch = lLen;
        IFC( spEnd->Right( TRUE, & eCtxt , & spElement , & cch , & chTest ));

        switch( eCtxt )
        {
            case CONTEXT_TYPE_Text:
                if( cch >= 1 )
                {
                    //
                    // If we hit a \r, we essentially hit a block break - we are done
                    //
                    
                    if( chTest != '\r' )
                    {                    
                        //
                        // Passed over a character, back up, move a markup pointer to 
                        // the start, and jump the end to the next cluster end point.
                        //
                        SP_IMarkupPointer spStart;
                        
                        
                        IFC( spEnd->Left( TRUE, & eCtxt , NULL , & cch , & chTest ));
                        Assert( eCtxt == CONTEXT_TYPE_Text );
                        IFC( _pManager->GetEditor()->CreateMarkupPointer( & spStart ));
                        IFC( spStart->MoveToPointer( spEnd ));
                        IFC( spEnd->MoveUnit( MOVEUNIT_NEXTCLUSTEREND )); 
                        IFC( _pManager->GetMarkupServices()->Remove( spStart, spEnd ));
                        lLen -= cch;
                        Assert(lLen >= 0);
                        fDone = (lLen <= 0);
                    }
                    else
                    {
                        fDone = TRUE;
                    }
                }
                break;
                
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_ExitScope:
            {
                BOOL fLayout, fBlock;
                IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout));

                fDone = fLayout || fBlock;    // we are done if we hit a layout...
                break;
            }

            default:
                break;
        }
    }

Cleanup:
    RRETURN( hr );
}

//
//
// Utilities & Privates 
//
//

BOOL
CCaretTracker::IsContextEditable()
{

#if 0 // BUBBUG: This breaks HTMLDialogs due to their wacky select code
    BOOL fOut = FALSE;
    HRESULT hr = S_OK;
    SP_IHTMLCaret spCaret;
    
    IFC( GetDisplayServices()->GetCaret( & spCaret ));
    IFC( spCaret->IsVisible( & fOut ));
    fOut = fOut && _pManager->IsContextEditable();
Cleanup:
    return fOut;
#else
    return _pManager->IsContextEditable() && (_fCaretShouldBeVisible || _pManager->HasFocusAdorner());
#endif
}

BOOL CCaretTracker::IsCaretInPre( IHTMLCaret * pCaret )
{
    HRESULT             hr = S_OK;
    BOOL                fPre;
    SP_IMarkupPointer   spPointer;
    
    IFC( _pManager->GetEditor()->CreateMarkupPointer( & spPointer ));
    IFC( pCaret->MoveMarkupPointerToCaret( spPointer ));
    IFC( GetEditor()->IsPointerInPre(spPointer, &fPre) );
    
    return fPre;

Cleanup:
    return FALSE;
}

HRESULT 
CCaretTracker::IsQuotedURL(IHTMLElement *pAnchorElement)
{
    HRESULT         hr;
    ED_PTR( ep); 
    TCHAR           ch = 0;
    DWORD           dwFound;

    IFC( ep->MoveAdjacentToElement(pAnchorElement, ELEM_ADJ_BeforeBegin) );
    IFC( ep.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound, NULL, NULL, &ch) );

    hr = S_FALSE; // not quoted
    if (ep.CheckFlag(dwFound, BREAK_CONDITION_Text) && (ch == '"' || ch == '<'))
    {
        hr = S_OK;
    }    

Cleanup:
    RRETURN1(hr, S_FALSE);
}




//+---------------------------------------------------------------------------+
//
//
//  Synopsis: Get the caret moving direction based on 
//                  Key Event
//                  Control State
//                  Vertical
//                  RightToLeft     //  Reading Order of current paragraph
//          
//+---------------------------------------------------------------------------+
/*
    Remark:
            Caret Positioning in Mixed Latin and Bidi environment
            -- based on paper by AlexMo  (zhenbinx)
  
            CP  denotes the character position of the character after the caret
            fBeforeCP is 
                TRUE when the caret is located "before" the current character
                FALSE when the caret is located "after" the preceding character
  
  
            Hit Testing

            Reading order   Horizontal Half of Char.    CP Selected     fBeforeCP
            LTR             Left                        CP              TRUE
            LTR             Right                       CP+1            FALSE
            RTL             Left                        CP+1            FALSE
            RTL             Right                       CP              TRUE


            Cursor Movement
            
            Reading order       Arrow Direction     CP Selection    fBeforeCP
            LTR                 Left - backward     CP - 1          TRUE
            LTR                 Right - forward     CP + 1          FALSE
            RTL                 Left - forward      CP + 1          FALSE
            RTL                 Right - backward    CP - 1          TRUE


            The basic idea of cursor movement is that when the cursor is advanced
            over certain character using the arrow keys, we want to keep the
            caret closer to that character. 

            Note that with arrow movement, the reading order of the current run  
            is not relevant. The reading order of the current paragraph decides 
            whether left arrow moves forward or backward. 
  
            The same logic can be extended to other cursor movement using arrow
            key. A CTRL_ARROW would move the CP to the beginning of the next or
            previous word. The CP would be the one of the characters beginning 
            the word. Since we want the caret to show next to that character,
            we will set fBeforeCP = TRUE. In word movement, we set the flag to
            TRUE in both forward and backward movements since we want the caret
            to be attached to the beginning of the current word. 

            UP/DOWN/PgUp/PgDn

            Apply the hit selection rules after UP, DOWN, PGUP, PGDN

            HOME/END

            Home -  Logical start of current line
            End  -  Logical end of current line
              
                  fBeforeCP = FALSE   after HOME
                  fBeforeCP = TRUE    after END
            
*/

CARET_MOVE_UNIT
CCaretTracker::GetMoveDirectionFromEvent(CEditEvent *pEvent,   
                                         BOOL   fRightToLeft,
                                         BOOL   fVertical
                                         )
{
    //
    //  Variables that affects arrow key movement
    //
    //                   0    = 1 state(s)
    //  fRightToLeft *1  0/1  = 1 state(s)
    //  fVertical    *2  0/1  = 2 states
    //  fControl     *4  0/1  = 4 states
    //
    //  e.g.
    //      000     means !fControl, !fVertical, !fRightToLeft
    //      011     means !fControl, fVertical, fRightToLeft
    //      111     means fControl, fVertical, fRightToLeft
    //
    //
    Assert (VK_UP     == VK_LEFT + 1);
    Assert (VK_RIGHT  == VK_UP + 1);
    Assert (VK_DOWN   == VK_RIGHT + 1);
    const int NUM_ARROWKEYMOVESTATES  = 8;
    const int NUM_ARROWKEYS = 4;
    static const CARET_MOVE_UNIT arrowkeyMoveStates[NUM_ARROWKEYS][NUM_ARROWKEYMOVESTATES] =
    {
        {
            CARET_MOVE_BACKWARD,                    // 000
            CARET_MOVE_FORWARD,                   // 001
            CARET_MOVE_NEXTLINE, CARET_MOVE_NEXTLINE,   // 010, 011
            CARET_MOVE_WORDBACKWARD, CARET_MOVE_WORDFORWARD, CARET_MOVE_NEXTBLOCK, CARET_MOVE_NEXTBLOCK // 100, 101, 110, 111
        },  // VK_LEFT  0x25
        { 
            CARET_MOVE_PREVIOUSLINE,
            CARET_MOVE_PREVIOUSLINE,
            CARET_MOVE_BACKWARD, CARET_MOVE_FORWARD,
            CARET_MOVE_BLOCKSTART, CARET_MOVE_BLOCKSTART, CARET_MOVE_WORDBACKWARD, CARET_MOVE_WORDFORWARD
        },  // VK_UP 0x26
        { 
            CARET_MOVE_FORWARD,
            CARET_MOVE_BACKWARD,
            CARET_MOVE_PREVIOUSLINE, CARET_MOVE_PREVIOUSLINE, 
            CARET_MOVE_WORDFORWARD, CARET_MOVE_WORDBACKWARD, CARET_MOVE_BLOCKSTART, CARET_MOVE_NEXTBLOCK
        },  // VK_RIGHT 0x27
        { 
            CARET_MOVE_NEXTLINE,
            CARET_MOVE_NEXTLINE,
            CARET_MOVE_FORWARD, CARET_MOVE_BACKWARD,
            CARET_MOVE_NEXTBLOCK, CARET_MOVE_NEXTBLOCK, CARET_MOVE_WORDFORWARD, CARET_MOVE_WORDBACKWARD
        },  // VK_DOWN 0x28
    };

    //
    //  Variable(s) that affects block key moment
    //
    //                      0   =  1 state
    //      fControl * 1    0/1 =  1 state
    //
    //
    Assert (VK_NEXT == VK_PRIOR + 1);  
    Assert (VK_END  == VK_NEXT  + 1);
    Assert (VK_HOME == VK_END   + 1);
    const int NUM_BLOCKKEYMOVESTATES = 2;
    const int NUM_BLOCKKEYS = 4;
    static const CARET_MOVE_UNIT blockkeyMoveStates[NUM_BLOCKKEYS][NUM_BLOCKKEYMOVESTATES] =
    {
        {
            CARET_MOVE_PAGEUP,          // 0
            CARET_MOVE_VIEWSTART        // 1
        },  // VK_PRIOR     0x21
        {
            CARET_MOVE_PAGEDOWN,
            CARET_MOVE_VIEWEND
        },  // VK_NEXT      0x22
        {
            CARET_MOVE_LINEEND,
            CARET_MOVE_DOCEND
        },  // VK_END       0x23
        {
            CARET_MOVE_LINESTART,
            CARET_MOVE_DOCSTART
        },  // VK_HOME      0x24
    };


    BOOL        fControl;
    LONG        keyCode;
    UINT        uState = 0;

    fControl = pEvent->IsControlKeyDown();
    IGNORE_HR( pEvent->GetKeyCode(&keyCode) );

    //  If the alt key is down, we shouldn't do anything here. (bug 94675)
    if (pEvent->IsAltKeyDown())
        return CARET_MOVE_NONE;

    switch (keyCode)
    {
        case  VK_LEFT:
        case  VK_UP:
        case  VK_RIGHT:
        case  VK_DOWN:
            {
            uState += ((fRightToLeft ? 1:0) +
                       (fVertical ? 2 : 0) +
                       (fControl ? 4 : 0));

            TraceTag((tagSelectionTrackerState, "Arrow Keycode State %u", uState));
            Assert( uState < NUM_ARROWKEYMOVESTATES );
            Assert( keyCode - VK_LEFT >= 0);
            Assert( keyCode - VK_LEFT < NUM_ARROWKEYS );
            
            return arrowkeyMoveStates[keyCode - VK_LEFT][uState];
            }
            
        case VK_PRIOR:
        case VK_NEXT:
        case VK_HOME:
        case VK_END:
            {
            uState += (fControl ? 1: 0);

            TraceTag((tagSelectionTrackerState, "Block Keycode State %u", uState));
            Assert( keyCode - VK_PRIOR >= 0 );
            Assert( keyCode - VK_PRIOR < NUM_BLOCKKEYS );
            
            return blockkeyMoveStates[keyCode - VK_PRIOR][uState];
            }
    }
    
    return CARET_MOVE_NONE;
}



//+---------------------------------------------------------------------------+
//
//
//  Synopsis: Get the caret direction 
//              
//            Character RTL attributes affects the caret direction
//            Push mode where (parent RTL != character RTL)
//
//+---------------------------------------------------------------------------+

CARET_DIRECTION
CCaretTracker::GetCaretDirFromMove(
                        CARET_MOVE_UNIT unMove,
                        BOOL            fPushMode
                        )
{
    Assert (CARET_MOVE_BACKWARD     == CARET_MOVE_NONE		  + 1 );
    Assert (CARET_MOVE_FORWARD      == CARET_MOVE_BACKWARD	  + 1 );
    Assert (CARET_MOVE_WORDBACKWARD == CARET_MOVE_FORWARD      + 1 );
    Assert (CARET_MOVE_WORDFORWARD  == CARET_MOVE_WORDBACKWARD + 1 );
    Assert (CARET_MOVE_PREVIOUSLINE == CARET_MOVE_WORDFORWARD  + 1 );
    Assert (CARET_MOVE_NEXTLINE     == CARET_MOVE_PREVIOUSLINE + 1 );
    Assert (CARET_MOVE_PAGEUP       == CARET_MOVE_NEXTLINE     + 1 );
    Assert (CARET_MOVE_PAGEDOWN     == CARET_MOVE_PAGEUP       + 1 );
    Assert (CARET_MOVE_VIEWSTART    == CARET_MOVE_PAGEDOWN     + 1 );
    Assert (CARET_MOVE_VIEWEND      == CARET_MOVE_VIEWSTART    + 1 );
    Assert (CARET_MOVE_LINESTART    == CARET_MOVE_VIEWEND      + 1 );  
    Assert (CARET_MOVE_LINEEND      == CARET_MOVE_LINESTART    + 1 ); 
    Assert (CARET_MOVE_DOCSTART     == CARET_MOVE_LINEEND      + 1 );       
    Assert (CARET_MOVE_DOCEND       == CARET_MOVE_DOCSTART     + 1 ); 
    Assert (CARET_MOVE_BLOCKSTART   == CARET_MOVE_DOCEND       + 1 ); 
    Assert (CARET_MOVE_NEXTBLOCK    == CARET_MOVE_BLOCKSTART   + 1 ); 
    Assert (CARET_MOVE_ATOMICSTART  == CARET_MOVE_NEXTBLOCK    + 1 );
    Assert (CARET_MOVE_ATOMICEND    == CARET_MOVE_ATOMICSTART  + 1 );     
    //
    // 
    //
    static const CARET_DIRECTION arCaretDir[][2] = 
    {
        //
        // _fMoveForward  ==  fAfterPrevCP == !fBeforeCP	
        //
        //
        //   0                              1 -- push mode
        //
        { CARET_DIRECTION_SAME          , CARET_DIRECTION_SAME          },   //CARET_MOVE_NONE         = 0,
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_BACKWARD     = 1,
        { CARET_DIRECTION_FORWARD       , CARET_DIRECTION_FORWARD       },   //CARET_MOVE_FORWARD      = 2,
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_WORDBACKWARD = 3,  always attach to beginning of current word
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_WORDFORWARD  = 4,  always attach to beginning of current word
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_PREVIOUSLINE = 5,  hit testing rule
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_NEXTLINE     = 6,  hit testing rule
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_PAGEUP       = 7,  hit testing rule
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_PAGEDOWN     = 8,  hit testing rule
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_VIEWSTART    = 9,  hit testing rule
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_VIEWEND      = 10, hit testing rule
        { CARET_DIRECTION_FORWARD       , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_LINESTART    = 11, logical start      
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_FORWARD       },   //CARET_MOVE_LINEEND      = 12, logical end
        { CARET_DIRECTION_FORWARD       , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_DOCSTART     = 13, logical start           
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_FORWARD       },   //CARET_MOVE_DOCEND       = 14, logical end
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_BLOCKSTART   = 15, always attach to beginning of current block
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_NEXTBLOCK    = 16, always attach to beginning of current block
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_ATOMICSTART  = 17,
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_ATOMICEND    = 18        
    };

    UINT            uState=0;
    CARET_DIRECTION caretDir;

    Assert (unMove >= CARET_MOVE_NONE && unMove <= CARET_MOVE_ATOMICEND);
    uState  += (fPushMode ? 1 : 0);  
    caretDir = arCaretDir[unMove - CARET_MOVE_NONE][uState];
    TraceTag((tagEdKeyNav,"Move %d Caret Dir is %d", unMove, caretDir));
    
    return caretDir;
}

//+====================================================================================
//
// Method: ShouldEnterExitList
//
// Synopsis: What does this do ?
//
//------------------------------------------------------------------------------------
BOOL    
CCaretTracker::ShouldEnterExitList(IMarkupPointer *pPosition, IHTMLElement **ppElement)
{
    HRESULT                 hr;
    SP_IHTMLElement         spElement;
    SP_IHTMLElement         spListItem;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    CBlockPointer           bpChild(_pManager->GetEditor());

    *ppElement = NULL;
    
    //
    // Are we in a list item scope?
    //

    IFC( pPosition->CurrentScope(&spElement) );
    if (spElement == NULL)
        goto Cleanup;

    IFC( EdUtil::FindListItem(GetMarkupServices(), spElement, &spListItem) );
    if (spListItem == NULL)
        goto Cleanup;

    //
    // Is the list item empty?  For the list item to be empty, the block tree must have
    // branching factor exactly equal to one from the list item to an empty text node below.
    //

    IFC( bpChild.MoveTo(spElement) );

    for (;;)
    {        
        IFC( bpChild.MoveToFirstChild() );

        IFC( bpChild.MoveToSibling(RIGHT) );
        if (hr != S_FALSE)
            return FALSE; // has siblings so not empty
            
        if (bpChild.GetType() == NT_Text)
            break; // we have our text node
        
        if (bpChild.GetType() != NT_Block)
            return FALSE; // if not a block, then not empty            
    }

    //
    // Is the scope empty?
    //
    
    IFC( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFC( bpChild.MovePointerTo(spEnd, ELEM_ADJ_BeforeEnd) );
    
    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    IFC( bpChild.MovePointerTo(spStart, ELEM_ADJ_AfterBegin) );

    if (!GetEditor()->DoesSegmentContainText(spStart, spEnd, FALSE /* fSkipNBSP */))
    {
        *ppElement = spListItem;
        (*ppElement)->AddRef();

        return TRUE;
    }

Cleanup:
    return FALSE;
}

HRESULT
CCaretTracker::MoveCaret(
    CEditEvent*         pEvent,
    CARET_MOVE_UNIT     inMove, 
    IDisplayPointer*    pDispPointer,
    BOOL                fMoveCaret
    )
{
    HRESULT             hr;    
    SP_IHTMLCaret       spCaret;
    Direction           eMvDir;
    CSpringLoader       * psl = NULL;
    SP_IMarkupPointer   spPointer;

    POINT               ptXYPos;
    ptXYPos.x = 0;
    ptXYPos.y = 0;
    
    IFC( GetDisplayServices()->GetCaret( &spCaret ));
    IFC( spCaret->MoveDisplayPointerToCaret( pDispPointer ));
    
    if( _pManager->HaveTypedSinceLastUrlDetect() )
    {
        IGNORE_HR( UrlAutodetectCurrentWord( NULL ) );
        _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );
    }

    //
    // Get the previous X/Y position for move
    //
    
    IFC( _pManager->GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );
    IFC( _ptVirtualCaret.GetPosition(spPointer, &ptXYPos) );

    //
    // Actually move the display pointer
    //
    
    // reset suggesetd XY if necessary. 
    if (!_ptVirtualCaret.IsFrozen() && (inMove != CARET_MOVE_PREVIOUSLINE && inMove != CARET_MOVE_NEXTLINE) )
    {
        ptXYPos.y = CARET_XPOS_UNDEFINED;
        ptXYPos.x = CARET_XPOS_UNDEFINED;
    }
    
    IFC( MovePointer(inMove, pDispPointer,&ptXYPos, &eMvDir) );

    if ( fMoveCaret )
    {
        BOOL fShouldIScroll = TRUE;
        
        //Assert( _pManager->IsInEditContext( pDispPointer ));
        if( ! _pManager->IsInEditContext( pDispPointer ))
            goto Cleanup;

        //
        // Check for non-multiline case.  If not multiline, we'll move
        // elsewhere on the same line, so force a scroll.
        //
        if (inMove == CARET_MOVE_PAGEUP || inMove == CARET_MOVE_PAGEDOWN)
        {
            VARIANT_BOOL     bMultiLine;
            SP_IHTMLElement  spFlowElement;
            SP_IHTMLElement3 spElement3;

            fShouldIScroll = FALSE;

            IFC( pDispPointer->GetFlowElement(&spFlowElement) );
            IFC( spFlowElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );

            IFC( spElement3->get_isMultiLine(&bMultiLine) );

            fShouldIScroll = (bMultiLine == VARIANT_FALSE);
   
        }

#ifndef NO_IME
        if (_pManager->IsIMEComposition())
        {
            _pManager->TerminateIMEComposition(TERMINATE_NORMAL, pEvent );
        }
#endif // NO_IME

        psl = GetSpringLoader();

        // Before we perform a move, see if we need to fire to preserve formatting
        // on the empty line
        if( psl )
        {
            psl->FireOnEmptyLine();
        }
        
        // Actually move the caret
        {
            CARET_DIRECTION dirCaret;
            BOOL            fPushMode;

            // HACKHACK: 
            // Now we just return fPushMode since it is the only case where 
            // ambiguious position is of more critical issue. 
            //
            // IFC( MshtmledUtil::IsDisplayPointerInPushBlock(GetEditor(), pDispPointer, &fPushMode) );
            fPushMode= TRUE;
            dirCaret = CCaretTracker::GetCaretDirFromMove(inMove, fPushMode);
            IFC( spCaret->MoveCaretToPointer( pDispPointer, fShouldIScroll, dirCaret));
        }
        _fCheckedCaretForAtomic = FALSE;

        // Reset the spring loader with the compose font
        if (psl)
        {
            SP_IMarkupPointer spDispPointer;

            IFC( GetEditor()->CreateMarkupPointer(&spDispPointer) );
            IFC( pDispPointer->PositionMarkupPointer(spDispPointer) );
            
            IGNORE_HR(psl->SpringLoadComposeSettings(spDispPointer, TRUE));
        }
    }

    // fire the selectionchange event
    {
        CSelectionChangeCounter selCounter(_pManager);
        selCounter.SelectionChanged();
    }
    
    //
    // Update the XPosition
    //
    // We have to update the pointer in any case...
    // 
    {
        BOOL fFreeze = _ptVirtualCaret.FreezePosition(FALSE);
        IFC( pDispPointer->PositionMarkupPointer(spPointer) );
        IFC( _ptVirtualCaret.UpdatePosition(spPointer, ptXYPos) );
        _ptVirtualCaret.FreezePosition(fFreeze);
    }
  

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: SetCaretVisible.
//
// Synopsis: Set's the Caret's visiblity.
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::SetCaretVisible( IHTMLDocument2* pIDoc, BOOL fVisible )
{
    HRESULT hr = S_OK ;
    SP_IHTMLCaret spc;
    IDisplayServices * pds = NULL;

    IFC( pIDoc->QueryInterface( IID_IDisplayServices, (void **) & pds ));
    IFC( pds->GetCaret( &spc ));

    if( fVisible )
        hr = spc->Show( FALSE );
    else
        hr = spc->Hide();

Cleanup:
    ReleaseInterface( pds );
    RRETURN( hr );
}




//+====================================================================================
//
// Method:GetCaretPointer
//
// Synopsis: Utility Routine to get the IDisplayPointer at the Caret
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::GetCaretPointer( IDisplayPointer ** ppDispPointer )
{
    HRESULT hr = S_OK;
    SP_IHTMLCaret  spCaret;
    
    IFC( GetDisplayServices()->CreateDisplayPointer( ppDispPointer));
    IFC( GetDisplayServices()->GetCaret( &spCaret ));
    IFC( spCaret->MoveDisplayPointerToCaret( *ppDispPointer ));

Cleanup:
    RRETURN( hr );
}

VOID 
CCaretTracker::SetCaretShouldBeVisible( BOOL fVisible )
{
    _fCaretShouldBeVisible = fVisible;
    SetCaretVisible( _pManager->GetDoc(), _fCaretShouldBeVisible );
}



BOOL
CCaretTracker::ShouldCaretBeVisible()
{
    IHTMLElement* pIElement = NULL;
    IHTMLInputElement* pIInputElement = NULL;
    HRESULT hr = S_OK;
    BSTR bstrType = NULL;
    BOOL fShouldBeVisible = FALSE;

    ELEMENT_TAG_ID eTag = _pManager->GetEditableTagId();

    if ( _pManager->IsContextEditable() )
    {

    #ifdef FORMSMODE
        if (_pManager->IsInFormsSelectionMode() )
             fShouldBeVisible = FALSE;
        else
    #endif 
        if (!_pManager->IsEnabled())
             fShouldBeVisible = FALSE;
        else
        {
            switch( eTag )
            {
                case TAGID_IMG:
                case TAGID_OBJECT:
                case TAGID_APPLET:
                case TAGID_SELECT:
                    fShouldBeVisible = FALSE;
                    break;

                case TAGID_INPUT:
                {
                    //
                    // for input's of type= image, or type=button - we don't want to make the caret visible.
                    //
                    IFC( _pManager->GetEditableElement( &pIElement ) );
               
                    if ( S_OK == THR( pIElement->QueryInterface ( IID_IHTMLInputElement, 
                                                                 ( void** ) & pIInputElement ))
                        && S_OK == THR(pIInputElement->get_type(&bstrType)))
                    {                    
                        if (   !StrCmpIC(bstrType, TEXT("image"))
                            || !StrCmpIC(bstrType, TEXT("radio"))
                            || !StrCmpIC(bstrType, TEXT("checkbox")))
                        {
                            fShouldBeVisible = FALSE;
                        }                
                        else
                            fShouldBeVisible = TRUE;
                    }
                    else
                        fShouldBeVisible = TRUE;
                }
                break;

                default:
                    fShouldBeVisible = TRUE;
            }
        }
    }
    //
    // See if we can have a visible caret - via the FireOnBeforeEditFocus event.
    //
    if ( fShouldBeVisible )
    {
        fShouldBeVisible = _pManager->CanHaveEditFocus();
    }
    
Cleanup:
    SysFreeString(bstrType);
    ReleaseInterface( pIInputElement);
    ReleaseInterface( pIElement );

    return ( fShouldBeVisible);
}

//+====================================================================================
//
// Method: DontBackspace
//
// Synopsis: Dont Backspace when you're at the start of these
//
// Typical example is - don't backspace from inside an input.
//
//------------------------------------------------------------------------------------


BOOL
DontBackspace( ELEMENT_TAG_ID eTagId )
{
    switch( eTagId )
    {
        case TAGID_INPUT:
        case TAGID_BODY:
        case TAGID_TD:
        case TAGID_TR:
        case TAGID_TABLE:

            return TRUE;

        default:
            return FALSE;

    }
}

//+---------------------------------------------------------------------------
//
//  Member:     OnExitTree
//
//  Synopsis:   An element is leaving the tree.  We may have to nix our caret
//              if the caret is in bound by the element
//
//----------------------------------------------------------------------------
HRESULT 
CCaretTracker::OnExitTree(
                            IMarkupPointer* pIStart, 
                            IMarkupPointer* pIEnd  ,
                            IMarkupPointer* pIContentStart,
                            IMarkupPointer* pIContentEnd )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spPointer;
    SP_IMarkupPointer       spPointer2;
    CEditPointer            startPointer( GetEditor() );
    CEditPointer            endPointer( GetEditor());
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    BOOL fPositioned, fPositionedEnd;
    SELECTION_TYPE          eType = SELECTION_TYPE_None;
    BOOL                    fCaretPositioned;
    BOOL                    fSameMarkup;
    
    //
    // A layout is leaving the tree. Does this completely contain selection ?
    //
    if( !IsPassive() )
    { 
        IFC( GetEditor()->CreateMarkupPointer( &spPointer ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointer2 )); 


        // Retrieve the segment list
        IFC( GetSelectionServices()->QueryInterface(IID_ISegmentList, (void **)&spSegmentList ) );


        //
        // Verify that we are really tracking a caret
        //
        IFC( spSegmentList->GetType(&eType) );
        Assert( eType == SELECTION_TYPE_Caret || eType == SELECTION_TYPE_None );        

        if ( eType == SELECTION_TYPE_Caret )
        {            
            // Position pointers around the current selection.
            IFC( spSegmentList->CreateIterator( &spIter ) );
            IFC( spIter->Current(&spSegment) );
            IFC( spSegment->GetPointers( startPointer, endPointer ));

            IFC( startPointer->IsPositioned( &fCaretPositioned ) );
            IFC( pIContentStart->IsPositioned( & fPositioned ));
            IFC( pIContentEnd->IsPositioned( & fPositionedEnd ));

            if ( fPositioned &&
                 fPositionedEnd )
            {
                IFC( spPointer->MoveToPointer( pIContentStart ));
                IFC( spPointer2->MoveToPointer( pIContentEnd ));
            }
            else
            {
                IFC( spPointer->MoveToPointer( pIStart ));
                IFC( spPointer2->MoveToPointer( pIEnd ));
            }
            
            if( (startPointer.Between( spPointer, spPointer2) && endPointer.Between( spPointer, spPointer2)) ||
                (!fCaretPositioned) )
            {
                SP_IDisplayPointer spDispPointer;
                
                IFC( spPointer->MoveToPointer( pIEnd ));

                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                hr = THR( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );

                if (hr == CTL_E_INVALIDLINE)
                {
                    if (SUCCEEDED(GetEditor()->AdjustIntoTextSite(spPointer, RIGHT)))
                    {
                        hr = THR( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                    }    
                    else
                    {
                        IFC( spPointer->MoveToPointer( pIStart ) );
                        if (SUCCEEDED(GetEditor()->AdjustIntoTextSite(spPointer, LEFT)))
                        {
                            hr = THR( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                        }
                    }
                }
                IFC(hr);

                IFC( ArePointersInSameMarkup( spPointer, startPointer, &fSameMarkup ) )

                if( !fSameMarkup )
                {
                    IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_None, NULL ) );
                }
                
                IFC( _pManager->EnsureEditContext( spPointer ));
                
                if ( hr == S_FALSE )
                {
                    goto Cleanup;
                }
                PositionCaretAt( spDispPointer, CARET_DIRECTION_INDETERMINATE, POSCARETOPT_DoNotAdjust, ADJPTROPT_None );
            }
        }
    }        

Cleanup:

    RRETURN1 ( hr, S_FALSE );
}


//+===================================================================================
// Method:      GetElementToTabFrom
//
// Synopsis:    Gets the element where we should tab from based on caret
//
//------------------------------------------------------------------------------------
HRESULT 
CCaretTracker::GetElementToTabFrom(BOOL fForward, IHTMLElement **pElement, BOOL *pfFindNext)
{
    HRESULT                 hr = S_OK;
    SELECTION_TYPE          eType;
    SP_IMarkupPointer       spLeft;
    SP_IMarkupPointer       spRight;
    SP_IHTMLElement         spElementCaret;
    SP_IObjectIdentity      spIdent;
    MARKUP_CONTEXT_TYPE     context = CONTEXT_TYPE_None;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    BOOL                    fEmpty = FALSE;
    
    // Retrieve the segment list
    IFC( GetSelectionServices()->QueryInterface(IID_ISegmentList, (void **)&spSegmentList ) );
    IFC( spSegmentList->GetType( &eType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );
    
    Assert( pfFindNext );
    Assert( pElement );
    
    IFC( GetEditor()->CreateMarkupPointer( &spLeft ));
    IFC( GetEditor()->CreateMarkupPointer( &spRight ));

    if( !IsPassive() && (fEmpty == FALSE) && (eType == SELECTION_TYPE_Caret) )
    {
        // Return the position of the caret
        IFC( spSegmentList->CreateIterator(&spIter) );
        IFC( spIter->Current(&spSegment) );
        IFC( spSegment->GetPointers( spLeft, spRight ) );
    }
    else
    {
        SP_IHTMLCaret spCaret;
        BOOL fPositioned;

        // There is no selection, try to use the physical caret
        IFC( GetDisplayServices()->GetCaret(&spCaret) );
        IFC( spCaret->MoveMarkupPointerToCaret(spRight) );
        IFC( spRight->IsPositioned(&fPositioned) );

        if (!fPositioned)
        {
            // no caret to fall back on - go use the edit context
            if( fForward )
            {
                IFC( spRight->MoveToPointer( _pManager->GetStartEditContext()));
            }
            else
            {
                IFC( spRight->MoveToPointer( _pManager->GetEndEditContext()));
            }
        }

    }
    
    // First find the element where selection would contains caret
    IFC(spRight->CurrentScope(&spElementCaret));
    if (!spElementCaret)
        goto Cleanup;

    // Now, scan upto the first scope boundary
    for(;;)
    {
        if (fForward)
        {
            IFC( spRight->Right(TRUE, &context, pElement, NULL, NULL));
        }
        else
        {
            IFC( spRight->Left(TRUE, &context, pElement, NULL, NULL));
        }

        Assert( context != CONTEXT_TYPE_None );
        
        if(     (context == CONTEXT_TYPE_EnterScope)    || 
                (context == CONTEXT_TYPE_ExitScope)     ||
                (context == CONTEXT_TYPE_NoScope) )
        {
            break;
        }

        ClearInterface(pElement);
    }

    IFC( spElementCaret->QueryInterface( IID_IObjectIdentity, (void **)&spIdent ) );

    if( spIdent->IsEqualObject(*pElement) == S_FALSE )
    {
        *pfFindNext = FALSE;
    }
    //
    // We always want to say yes to findNext - if we have a focus adorner
    //
    if ( _pManager->HasFocusAdorner() )
    {
        *pfFindNext = TRUE;
    }
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCaretTracker::ExitList
//
//  Synopsis:   This method causes the list item to exit the list.  Used
//              by backspace and enter.
//
//----------------------------------------------------------------------------

HRESULT 
CCaretTracker::ExitList(IHTMLElement* pIElement)
{
    HRESULT hr;
    
    CBlockPointer   bpListItem(_pManager->GetEditor());
    CBlockPointer   bpParent(_pManager->GetEditor());

    IFC( TerminateTypingBatch() );
    
    IFC( bpListItem.MoveTo(pIElement) );
    Assert(bpListItem.GetType() == NT_ListItem);

    IFC( bpParent.MoveTo(&bpListItem) );
    IFC( bpParent.MoveToParent() );

    if (hr == S_FALSE
        || bpParent.GetType() == NT_Container
        || bpParent.GetType() == NT_BlockLayout
        || bpParent.GetType() == NT_FlowLayout)
    {
        ELEMENT_TAG_ID tagId = TAGID_DIV;

        // Can't float through a container or a block layout
        // so just morph to the default block element
        IFC( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagId) );
        IFC( bpListItem.Morph(&bpListItem, tagId) );
    }
    else
    {
        CBlockPointer   bpListItemParent(_pManager->GetEditor());
                        
        // If should outdent on an empty list item, wait for
        // </li></li>...</ol> case which is often is created
        // by the parser.
        for (;;)
        {
            IFC( bpListItem.FloatUp(&bpListItem, TRUE) );

            IFC( bpListItemParent.MoveTo(&bpListItem) );
            IFC( bpListItemParent.MoveToParent() );

            if (bpListItemParent.GetType() == NT_ListItem)
            {
                SP_IMarkupPointer spInner, spOuter;
                BOOL              fEqual;
                
                IFC( GetEditor()->CreateMarkupPointer(&spInner) );
                IFC( bpListItem.MovePointerTo(spInner, ELEM_ADJ_AfterEnd) );
                
                IFC( GetEditor()->CreateMarkupPointer(&spOuter) );
                IFC( bpListItemParent.MovePointerTo(spOuter, ELEM_ADJ_BeforeEnd) );

                IFC( spInner->IsEqualTo(spOuter, &fEqual) );
                if (!fEqual)
                    break; // done                        
            }
            else
            {
                break; // done
            }
        }
    }

    if (bpListItem.GetType() == NT_Block)
    {            
        IGNORE_HR( bpListItem.FlattenNode() );
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCaretTracker::ShouldBackspaceExitList
//
//  Synopsis:   Is the user trying to remove the list item?
//
//----------------------------------------------------------------------------
BOOL    
CCaretTracker::ShouldBackspaceExitList(IMarkupPointer *pPointer, IHTMLElement **ppListItem)
{
    HRESULT             hr;
    CEditPointer        ep(GetEditor());
    DWORD               dwFound;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spEditElement;
    SP_IObjectIdentity  spIdent;
    BOOL                fResult = FALSE;

    IFC( ep->MoveToPointer(pPointer) );

    //
    // Look for exit scope of a list item.  If we find one, we should
    // exit the list to be like Word 2k.
    //
    
    IFC( ep.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound, &spElement) );
    
    if (ep.CheckFlag(dwFound, BREAK_CONDITION_ExitBlock) && spElement != NULL)
    {
        ELEMENT_TAG_ID tagId;
    
        IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

        fResult = IsListItem(tagId);
        if (fResult)
        {
            // If the list item is the editable element, we don't want to delete it.
            // (Bug 103246)
            IFC( _pManager->GetEditableElement(&spEditElement) );
            IFC( spElement->QueryInterface(IID_IObjectIdentity, (void **) &spIdent));        

            if (spEditElement != NULL && spIdent->IsEqualObject(spEditElement) != S_OK)
            {
                *ppListItem = spElement;
                spElement->AddRef();
            }
            else
            {
                fResult = FALSE;
            }
        }
    }

Cleanup:
    return fResult;
}

HRESULT 
CCaretTracker::SetCaretDisplayGravity(DISPLAY_GRAVITY eGravity)
{
    HRESULT             hr;   
    SP_IHTMLCaret       spCaret;
    DISPLAY_GRAVITY     eCurGravity;
    
    IFR( GetDisplayServices()->GetCaret(&spCaret) );

    if (spCaret != NULL)
    {
        SP_IDisplayPointer  spDispCaret;

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
        IFC( spCaret->MoveDisplayPointerToCaret(spDispCaret) );

        IFC( spDispCaret->GetDisplayGravity( &eCurGravity ) );

        if( eCurGravity != eGravity )
        {
            IFC( spDispCaret->SetDisplayGravity(eGravity) );
            IFC( spCaret->MoveCaretToPointer(spDispCaret, FALSE, CARET_DIRECTION_SAME) );
        }
    }
    
Cleanup:
    RRETURN(hr);
}

HRESULT
CCaretTracker::HandleBackspaceAtomicSelection(IMarkupPointer *pPointer)
{
    HRESULT             hr;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    SP_IHTMLElement     spAtomicElement;

    IFC( pPointer->CurrentScope(&spAtomicElement) );
    if ( _pManager->CheckAtomic(spAtomicElement) == S_OK )
    {
        IFC( GetEditor()->CreateMarkupPointer(&spStart) );
        IFC( spStart->MoveToPointer(pPointer) );

        IFC( GetEditor()->CreateMarkupPointer(&spEnd) );
        IFC( spEnd->MoveToPointer(pPointer) );

        //  Delete will take care of adjusting for atomic
        IFC( GetEditor()->Delete( spStart, spEnd, FALSE ));
        goto Cleanup;
    }

    hr = S_FALSE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

BOOL 
CCaretTracker::IsInsideUrl(IMarkupPointer *pPointer)
{
    HRESULT          hr;
    BOOL             fInsideUrl = FALSE;
    SP_IHTMLElement  spElement, spParentElement;
    ELEMENT_TAG_ID   tagId;


    IFC( pPointer->CurrentScope(&spElement) );

    while (spElement != NULL)
    {
        IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) ); 
        if (tagId == TAGID_A)
        {
            fInsideUrl = TRUE;
            goto Cleanup;
        }
        else if (tagId == TAGID_BODY)
        {
            break; // perf optimization
        }

        IFC( spElement->get_parentElement(&spParentElement) );
        spElement = spParentElement;
    }

Cleanup:
    return fInsideUrl;    
}

HRESULT
CCaretTracker::EnsureAtomicSelection(CEditEvent* pEvent)
{
    HRESULT             hr;
    SP_IMarkupPointer   spPointer;
    SP_IHTMLCaret       spCaret;
    SP_IHTMLElement     spAtomicElement;

    //  Get the scope at the caret position
    IFC( GetDisplayServices()->GetCaret(&spCaret) );
    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( spCaret->MoveMarkupPointerToCaret(spPointer) );
    IFC( spPointer->CurrentScope(&spAtomicElement) );

    //  If the caret scope is atomic, go to atomic selection
    if ( _pManager->CheckAtomic(spAtomicElement) == S_OK )
    {
        SP_IDisplayPointer  spDispCaret;

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
        IFC( spCaret->MoveDisplayPointerToCaret(spDispCaret) );
        IFC( _pManager->StartAtomicSelectionFromCaret(spDispCaret) );
    }

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\ctltrack.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef _X_CTLTRACK_HXX_
#define _X_CTLTRACK_HXX_
#include "ctltrack.hxx"
#endif 

#ifndef _X_TABLE_H_
#define _X_TABLE_H_
#include "table.h"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef _X_EDADORN_HXX_
#define _X_EDADORN_HXX_
#include "edadorn.hxx"
#endif 

#ifndef _X_SELSERV_HXX_
#define _X_SELSERV_HXX_
#include "selserv.hxx"
#endif 

#ifndef X_EDUNITS_HXX_
#define X_EDUNITS_HXX_
#include "edunits.hxx"
#endif

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif


MtDefine( CControlTracker, Utilities , "CControlTracker" )

MtDefine( CControlTracker_aryControlElements_pv, Utilities, "CControlTracker Elements" )    
MtDefine( CControlTracker_aryControlAdorners_pv, Utilities, "CControlTracker Adorners" )
MtDefine( CControlTracker_aryRects_pv, Utilities, "CControlTracker Move Rects" )

ExternTag( tagSelectionTrackerState );
DeclareTag(tagDisableMouseClip, "Edit", "DisableMouseClip");
DeclareTag(tagShowMovePosition, "Edit", "ShowMovePositions");

extern int edWsprintf(LPTSTR pstrOut, LPCTSTR pstrFormat, LPCTSTR pstrParam);
extern BOOL g_fInVid;

#define SCROLL_SIZE 5 

//
// Control Tracker Action Table.
//

static const CONTROL_ACTION_TABLE ControlActionTable [] = {

    {EVT_LMOUSEDOWN,    
        {   A_ERRCONTROL,                  // CT_START
            A_ERRCONTROL,                  // CT_WAIT1
            A_PASSIVE_DOWN,                // CT_PASSIVE
            A_ERRCONTROL,                  // CT_DRAGMOVE
            A_ERRCONTROL,                  // CT_RESIZE
            A_ERRCONTROL,                  // CT_LIVERESIZE
            A_ERRCONTROL,                  // CT_WAITMOVE
            A_ERRCONTROL,                  // CT_2DMOVE
            A_ERRCONTROL,                  // CT_PENDINGUP 
            A_ERRCONTROL,                  // CT_UIACTIVATE 
            A_PENDINGUIACTIVATE_UIACTIVATE,  // CT_PENDINGUIACTIVATE,            
            A_ERRCONTROL,                  // CT_EXTENDSELECTION 
            A_ERRCONTROL,                  // CT_REDUCESELECTION 
            A_ERRCONTROL,                  // CT_WAITCHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_CHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_DORMANT
            A_ERRCONTROL }},               // CT_END 
            
    {EVT_LMOUSEUP,    
        {   A_ERRCONTROL,                  // CT_START
            A_WAIT_PASSIVE,                // CT_WAIT1
            A_IGNCONTROL,                  // CT_PASSIVE // from first-click + double-click
            A_ERRCONTROL,                  // CT_DRAGMOVE
            A_RESIZE_PASSIVE,              // CT_RESIZE
            A_LIVERESIZE_PASSIVE,          // CT_LIVERESIZE
            A_WAITMOVE_PASSIVE,            // CT_WAITMOVE
            A_2DMOVE_PASSIVE,              // CT_2DMOVE
            A_PENDINGUP_PENDINGUIACTIVATE, // CT_PENDINGUP
            A_ERRCONTROL,                  // CT_UIACTIVATE
            A_IGNCONTROL,                  // CT_PENDINGUIACTIVATE,            
            A_ERRCONTROL,                  // CT_EXTENDSELECTION 
            A_ERRCONTROL,                  // CT_REDUCESELECTION                        
            A_WAITCHANGEPRI_CHANGEPRI,     // CT_WAITCHANGEPRIMARY             
            A_ERRCONTROL,                  // CT_CHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_DORMANT
            A_ERRCONTROL }},               // CT_END 
            
    {EVT_MOUSEMOVE,    
        {   A_ERRCONTROL,                  // CT_START
            A_WAIT_MOVE,                   // CT_WAIT1
            A_IGNCONTROL,                  // CT_PASSIVE
            A_ERRCONTROL,                  // CT_DRAGMOVE
            A_RESIZE_MOVE,                 // CT_RESIZE
            A_LIVERESIZE_MOVE,             // CT_LIVERESIZE
            A_WAITMOVE_MOVE,               // CT_WAITMOVE
            A_2DMOVE_2DMOVE,               // CT_2DMOVE
            A_PENDINGUP_MOVE,              // CT_PENDINGUP
            A_ERRCONTROL,                  // CT_UIACTIVATE
            A_IGNCONTROL,                  // CT_PENDINGUIACTIVATE,            
            A_ERRCONTROL,                  // CT_EXTENDSELECTION 
            A_ERRCONTROL,                  // CT_REDUCESELECTION                        
            A_WAITCHANGEPRI_DRAGMOVE,      // CT_WAITCHANGEPRIMARY             
            A_ERRCONTROL,                  // CT_CHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_DORMANT
            A_ERRCONTROL }},               // CT_END 

    {EVT_RMOUSEDOWN,    
        {   A_ERRCONTROL,                  // CT_START
            A_IGNCONTROL,                  // CT_WAIT1
            A_PASSIVE_DOWN,                // CT_PASSIVE
            A_ERRCONTROL,                  // CT_DRAGMOVE
            A_RESIZE_PASSIVE,              // CT_RESIZE
            A_LIVERESIZE_PASSIVE,          // CT_LIVERESIZE
            A_ERRCONTROL,                  // CT_WAITMOVE
            A_ERRCONTROL,                  // CT_2DMOVE
            A_ERRCONTROL,                  // CT_PENDINGUP 
            A_ERRCONTROL,                  // CT_UIACTIVATE 
            A_PENDINGUIACTIVATE_UIACTIVATE, // CT_PENDINGUIACTIVATE,            
            A_ERRCONTROL,                  // CT_EXTENDSELECTION             
            A_ERRCONTROL,                  // CT_REDUCESELECTION                        
            A_ERRCONTROL,                  // CT_WAITCHANGEPRIMARY                        
            A_ERRCONTROL,                  // CT_CHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_DORMANT
            A_ERRCONTROL }},               // CT_END 

    {EVT_RMOUSEUP,    
        {   A_ERRCONTROL,                  // CT_START
            A_WAIT_PASSIVE,                // CT_WAIT1
            A_IGNCONTROL,                  // CT_PASSIVE // We could have gotten here from an RMOUSE_DOWN during resize.
            A_ERRCONTROL,                  // CT_DRAGMOVE
            A_RESIZE_PASSIVE,              // CT_RESIZE
            A_LIVERESIZE_PASSIVE,          // CT_LIVERESIZE
            A_WAITMOVE_PASSIVE,            // CT_WAITMOVE
            A_ERRCONTROL,                  // CT_2DMOVE
            A_ERRCONTROL,                  // CT_PENDINGUP 
            A_ERRCONTROL,                  // CT_UIACTIVATE 
            A_ERRCONTROL,                  // CT_PENDINGUIACTIVATE,            
            A_ERRCONTROL,                  // CT_EXTENDSELECTION            
            A_ERRCONTROL,                  // CT_REDUCESELECTION              
            A_WAITCHANGEPRI_CHANGEPRI,     // CT_WAITCHANGEPRIMARY                        
            A_ERRCONTROL,                  // CT_CHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_DORMANT
            A_ERRCONTROL }},               // CT_END 

    {EVT_DBLCLICK,
        {   A_ERRCONTROL,                  // CT_START
            A_ERRCONTROL,                  // CT_WAIT1
            A_PASSIVE_PENDINGUIACTIVATE,   // CT_PASSIVE
            A_ERRCONTROL,                  // CT_DRAGMOVE
            A_ERRCONTROL,                  // CT_RESIZE
            A_ERRCONTROL,                  // CT_LIVERESIZE
            A_ERRCONTROL,                  // CT_WAITMOVE
            A_ERRCONTROL,                  // CT_2DMOVE
            A_ERRCONTROL,                  // CT_PENDINGUP
            A_ERRCONTROL,                  // CT_UIACTIVATE
            A_IGNCONTROL ,                 // CT_PENDINGUIACTIVATE,            
            A_ERRCONTROL,                  // CT_EXTENDSELECTION                         
            A_ERRCONTROL,                  // CT_REDUCESELECTION              
            A_ERRCONTROL,                  // CT_WAITCHANGEPRIMARY                        
            A_ERRCONTROL,                  // CT_CHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_DORMANT
            A_ERRCONTROL }},               // CT_END 

    //
    // Some OLE controls eat RButtonUp - and generate a Context Menu
    // we treat these as an RMOUSE_UP.
    //
   { EVT_CONTEXTMENU,
        {   A_IGNCONTROL,                  // CT_START
            A_WAIT_PASSIVE,                // CT_WAIT1
            A_IGNCONTROL,                  // CT_PASSIVE
            A_IGNCONTROL,                  // CT_DRAGMOVE
            A_RESIZE_PASSIVE,              // CT_RESIZE
            A_LIVERESIZE_PASSIVE,          // CT_LIVERESIZE
            A_WAITMOVE_PASSIVE,            // CT_WAITMOVE
            A_IGNCONTROL,                  // CT_2DMOVE
            A_IGNCONTROL,                  // CT_PENDINGUP
            A_IGNCONTROL,                  // CT_UIACTIVATE
            A_ERRCONTROL,                  // CT_EXTENDSELECTION                         
            A_ERRCONTROL,                  // CT_REDUCESELECTION                        
            A_ERRCONTROL,                  // CT_WAITCHANGEPRIMARY                        
            A_WAITCHANGEPRI_CHANGEPRI,     // CT_CHANGEPRIMARY                        
            A_IGNCONTROL,                  // CT_DORMANT
            A_IGNCONTROL }} ,              // CT_END 
            
    { EVT_NONE ,
        {   A_IGNCONTROL,                  // CT_START
            A_IGNCONTROL,                  // CT_WAIT1
            A_IGNCONTROL,                  // CT_PASSIVE
            A_IGNCONTROL,                  // CT_DRAGMOVE
            A_IGNCONTROL,                  // CT_RESIZE
            A_IGNCONTROL,                  // CT_LIVERESIZE
            A_IGNCONTROL,                  // CT_WAITMOVE
            A_IGNCONTROL,                  // CT_2DMOVE
            A_IGNCONTROL,                  // CT_PENDINGUP
            A_IGNCONTROL,                  // CT_UIACTIVATE
            A_IGNCONTROL,                  // CT_EXTENDSELECTION                         
            A_IGNCONTROL,                  // CT_REDUCESELECTION                        
            A_IGNCONTROL,                  // CT_WAITCHANGEPRIMARY                                    
            A_IGNCONTROL,                  // CT_CHANGEPRIMARY                        
            A_IGNCONTROL,                  // CT_DORMANT
            A_IGNCONTROL }}                // CT_END 

};

using namespace EdUtil;

//
//
// Constructors & Initialization
//
//
                
CControlTracker::CControlTracker( CSelectionManager* pManager )
      : CEditTracker( pManager )
{
    _pUndoUnit = NULL;
    _pPrimary = NULL;
    _pDispLastClick = NULL;
    _pFirstEvent = NULL;
    _pNextEvent = NULL;
    Init();
}

VOID
CControlTracker::Init()
{
    _fActiveControl = FALSE; 
    _startMouseX = - 1;                   
    _startMouseY = - 1;
    _startLastMoveX = -1;
    _startLastMoveY = -1;
    _eType = TRACKER_TYPE_Control;
    _state = CT_DORMANT;
    _pFirstEvent = NULL;
    _pNextEvent  = NULL;
    _elemHandle  = ELEMENT_CORNER_NONE ; 

    Assert( ! _pUndoUnit );
}

HRESULT
CControlTracker::Init2( 
        IDisplayPointer*   pDispStart, 
        IDisplayPointer*   pDispEnd, 
        DWORD              dwTCFlags,
        CARET_MOVE_UNIT    inLastCaretMove )
{
    HRESULT         hr  = S_OK;
    CSpringLoader * psl = GetSpringLoader();

    IGNORE_HR( _pManager->AttachFocusHandler());

    // Reset the spring loader
    if (psl)
        psl->Reset();

    IFC( Position( pDispStart, pDispEnd ) );
    if ( hr == S_FALSE )
    {
        hr = S_OK;
        goto Cleanup;
    }

    IFC( _pManager->RequestRemoveAdorner( GetControlElement() ));

    SetState( CT_PASSIVE );        

    _pManager->HideCaret();

Cleanup:    
    if ( FAILED( hr ))
    {
        _pManager->EnsureDefaultTrackerPassive( );
    }
    _startMouseX = 0; // Don't set to -1 - as we've been created via OM.
    _startMouseY = 0;

    return hr;
}

HRESULT
CControlTracker::Init2( 
            CEditEvent*  pEvent, 
            DWORD        dwTCFlags, 
            IHTMLElement* pIElement /*= NULL*/)
{
    HRESULT         hr            = S_OK;
    SP_IHTMLElement spElement    ;
    ELEMENT_TAG_ID  eTag          = TAGID_NULL;
    CSpringLoader   *psl          = GetSpringLoader();
    BOOL            fGoActive     = dwTCFlags & TRACKER_CREATE_GOACTIVE;
    BOOL            fActiveOnMove = dwTCFlags & TRACKER_CREATE_ACTIVEONMOVE;
    SP_IHTMLElement spElementSelect;
    HOW_SELECTED    eHow;

    IGNORE_HR( _pManager->AttachFocusHandler());
    
    // IE6-#24607 (mharper) If the control tracker is being initialized
    // as a result of a click, then it should be CT_PASSIVE, otherwise
    // mousemoves on the page will cause the tracker to transition to 
    // CT_2DMOVE.  

    if ( pEvent && (pEvent->GetType() == EVT_CLICK) )
    {
        SetState( CT_PASSIVE );
    }
    else
    {
        SetState( CT_WAIT1 );
    }

     // Reset the spring loader
    if (psl)
        psl->Reset();

    if ( ! pIElement )
    {
        IFC( pEvent->GetElementAndTagId( & spElement, &eTag ));
    }
    else
    {
        spElement = pIElement;
    }

    Assert( IsParentEditable( GetMarkupServices(), spElement) == S_OK );
    IGNORE_HR( IsElementSiteSelectable( eTag, spElement, &eHow, &spElementSelect ));       
    if( eHow == HS_NONE )
    {
        AssertSz(0,"Element is not site selectable");
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!FireOnControlSelect(spElementSelect ) ||
        _pManager->GetActiveTracker() != this)
    {
        _pManager->EnsureDefaultTrackerPassive();
        goto Cleanup;
    }
    IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Control, (ISelectionServicesListener*) _pManager ) );    
    IFC( AddControlElement( spElementSelect ));

#if DBG == 1
    VerifyOkToStartControlTracker( pEvent);
#endif

    POINT pt;
    IFC( pEvent->GetPoint( & pt ));

    _startMouseX = pt.x;
    _startMouseY = pt.y;            
    _pManager->HideCaret();
    IFC( _pManager->RequestRemoveAdorner( GetControlElement() ));
    
    if ( fActiveOnMove )
    {
        IFC(DoDrag());

        //
        // If the drag fails, then we are still going to be the active tracker, so in reality, the Init
        // worked fine.  Just ignore this error and bubble S_OK
        //
        if( hr == S_FALSE )
            hr = S_OK;
    }

    if ( fGoActive  && !fActiveOnMove )
    {
        _aryGrabAdorners[0]->SetNotifyManagerOnPositionSet( TRUE );
    }

    
Cleanup:
    return hr;
}

HRESULT 
CControlTracker::Init2( 
        ISegmentList*   pSegmentList, 
        DWORD           dwTCFlags ,
        CARET_MOVE_UNIT inLastCaretMove  ) 
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spElement ;
    ELEMENT_TAG_ID eTag;
    SELECTION_TYPE eType = SELECTION_TYPE_None;
 //   WHEN_DBG( MARKUP_CONTEXT_TYPE eContext );
    HOW_SELECTED eHow;
    ED_PTR( edTempStart );
    ED_PTR( edTempEnd );    
    SP_ISegmentListIterator spIter;
    SP_ISegment spSegment;
    SP_IElementSegment spElemSegment;
    SP_IDisplayPointer spDispStart, spDispEnd;
    int  nPrimaryIndex = -1 ;
    BOOL fIsPrimary = FALSE;

    IFC( pSegmentList->GetType(  &eType ));

    Assert( eType == SELECTION_TYPE_Control );
    IFC( pSegmentList->CreateIterator( & spIter ));


    IFC( spIter->Current( & spSegment ));
    IFC( spSegment->GetPointers( edTempStart, edTempEnd ));
    
    IFC( _pManager->GetDisplayServices()->CreateDisplayPointer(&spDispStart) );
    IFC( spDispStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    IFC( spDispStart->MoveToMarkupPointer(edTempStart, NULL) );

    IFC( _pManager->GetDisplayServices()->CreateDisplayPointer(&spDispEnd) );
    IFC( spDispEnd->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    hr = THR( spDispEnd->MoveToMarkupPointer(edTempEnd, NULL) );

    //  BUG 14295: We could fail here in MoveToMarkupPointer if the scope of the end
    //  pointer is not in a flow layout.  This was causing us to bail out due to the
    //  error CTL_E_INVALIDLINE returned by MoveToMarkupPointer. However, if spDispEnd
    //  was positioned we won't bail even though it's not in a flow layout.
    
    if (hr == CTL_E_INVALIDLINE)
    {
        BOOL                fPositioned = FALSE;
        
        hr = THR(spDispEnd->IsPositioned(&fPositioned));
        if (hr == S_OK && fPositioned)
        {
            AssertSz(false, "Display pointer was moved somewhere, but not in a flow layout"); 
            hr = S_OK;
        }
        else
        {
            hr = CTL_E_INVALIDLINE;
            goto Cleanup;
        }
    }

    IFC( Init2( spDispStart, 
                spDispEnd, 
                dwTCFlags, 
                inLastCaretMove ));

    if (hr == S_OK && _aryControlElements.Size() > 0)
    {
        hr = spSegment->QueryInterface( IID_IElementSegment, (void**) & spElemSegment ) ;

        if ( hr == S_OK)
        {
            spElemSegment->IsPrimary(&fIsPrimary) ;
            if (fIsPrimary)
            {
                nPrimaryIndex =  0;
            }
        }
    }

    IFC( spIter->Advance());

    while( spIter->IsDone() != S_OK )
    {
        IFC( spIter->Current( & spSegment ));
        IFC( spSegment->GetPointers( edTempStart, edTempEnd ));

        IFC( spSegment->QueryInterface( IID_IElementSegment, (void**) & spElemSegment ));

        IFC( spElemSegment->GetElement( & spElement ));

        AssertSz( ! ( !spElement ), "CControlTracker - expected to find an element");
    
        IFC( GetMarkupServices()->GetElementTagId( spElement , & eTag ));
              
        //
        // Verify that this object CAN be site selected
        //
        IGNORE_HR( IsElementSiteSelectable( eTag, spElement, &eHow ));       
        if( eHow == HS_NONE )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        if (GetCommandTarget()->IsMultipleSelection())
        {
            if (FireOnControlSelect(spElement) && 
                _pManager->GetActiveTracker() == this)
            {   
                CSelectionChangeCounter selCounter(_pManager);
                selCounter.BeginSelectionChange();
                
                hr = THR( AddControlElement( spElement ));

                selCounter.EndSelectionChange();

                if (hr == S_OK && !fIsPrimary && _aryControlElements.Size() > 0)
                {
                    spElemSegment->IsPrimary(&fIsPrimary) ;
                    if (fIsPrimary)
                    {
                        nPrimaryIndex = _aryControlElements.Size()-1;
                    }
                }
    
            }
        }
        IFC( spIter->Advance());
    }
    
    if (nPrimaryIndex > 0 )
    {
        MakePrimary(nPrimaryIndex);
    }

Cleanup:
    RRETURN( hr );
}

CControlTracker::~CControlTracker()
{
    BecomeDormant( NULL, TRACKER_TYPE_None, FALSE );
}

//
//
// Virtual Methods for all trackers
//
//

//+====================================================================================
//
// Method: BecomeDormant
//
// Synopsis: Transition to a dormant state. For the caret tracker - this involves positioning based
//           on where we got the click.
//
//------------------------------------------------------------------------------------

HRESULT 
CControlTracker::BecomeDormant( CEditEvent      *pEvent , 
                                TRACKER_TYPE    typeNewTracker,
                                BOOL            fTearDownUI /*=TRUE*/)
{
    HRESULT hr = S_OK;

    if ( _pManager->IsInTimer() )
        StopTimer();
        
    if ( fTearDownUI )
    {
        UnSelect();
    }
    Destroy();

    // Set the selection type to none
    if ( GetSelectionServices() && WeOwnSelectionServices() == S_OK )
    {    
         IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_None, NULL ));
    }
    
    SetState( CT_DORMANT);

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: Awaken
//
// Synopsis: Transition from dormant to a "live" state.
//
//------------------------------------------------------------------------------------

HRESULT 
CControlTracker::Awaken() 
{
    Assert( IsDormant());
    if ( ! IsDormant() )
    {
        AssertSz(0,"Here we are");
    }
    
    //
    // Setup the selection services correctly
    //
    SetupSelectionServices();

    Init ();

    RRETURN( S_OK );    
}

//+---------------------------------------------------------------------------
//
//  Member: IsActive
//
//  Synopsis: Am I in an "active" state.
//
//----------------------------------------------------------------------------

BOOL
CControlTracker::IsActive()
{
    return( _state != CT_PASSIVE &&
            _state != CT_UIACTIVATE &&  // UI-Activate is like a 'psuedo-dormant' state - you are about to be dormant
            _state != CT_DORMANT );
}

//+====================================================================================
//
// Method: Destroy
//
// Synopsis: Release anything we currently own.
//
//------------------------------------------------------------------------------------

VOID
CControlTracker::Destroy()
{
    CONTROL_ELEMENT **pElem = NULL;
    int             i;

    for( i = NumberOfSelectedItems(), pElem = _aryControlElements;
         i > 0;
         i--, pElem++ )
    {
        (*pElem)->pIElement->Release();
        (*pElem)->pIElementStart->Release();
        delete *pElem;
    }
    
    _aryControlElements.DeleteAll();

   //
   // We don't need to Unselect anything here - if we're being deleted by a doc
   // shut down, the Selection Arrays should already be gone.
   //
   DestroyAllAdorners();
   ClearInterface( & _pPrimary );
   ClearInterface( & _pDispLastClick );
   if ( _pFirstEvent )
   {
        delete _pFirstEvent;
        _pFirstEvent = NULL;
   }
   if ( _pNextEvent )
   {
        delete _pNextEvent;
        _pNextEvent = NULL;
   }   

   IGNORE_HR( _pManager->DetachFocusHandler());

   IGNORE_HR( DeleteMoveRects() );
}

HRESULT
CControlTracker::ShouldStartTracker(
                    CEditEvent* pEvent ,
                    ELEMENT_TAG_ID eTag,
                    IHTMLElement* pIElement,
                    SST_RESULT* peResult)
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElement;
    SST_RESULT      eResult = SST_NO_CHANGE;
    BOOL            fExtendSelectionAllowed;
    
    Assert( peResult );

    if ( IsPassive() )
    {
        ELEMENT_TAG_ID eControlTag;

        if ( NumberOfSelectedItems() == 1 )
        {
            IFC( GetMarkupServices()->GetElementTagId( GetControlElement(), & eControlTag));

            if ( eControlTag == TAGID_TABLE &&
                 IsMessageOverControl(pEvent) )
            {
                SP_IHTMLElement spElement;
                IFC( GetSiteSelectableElementFromMessage(pEvent, & spElement ));                    
                
                if (IsSelected( spElement ) == S_OK )
                {
                    eResult = SST_NO_BUBBLE; // we dont want to change. But we want to not try to change other trackers
                    goto Cleanup;
                }
                else
                {
                    eResult = SST_CHANGE; // we want to change to siteselect the element in hittest
                    goto Cleanup;
                }
            }
        }    
        
        if ( IsInAdorner(pEvent))
        {
            eResult = SST_NO_BUBBLE; 
            goto Cleanup;
        }
    }

    if ( IsActive() )
    {
        eResult = SST_NO_BUBBLE;
        goto Cleanup;
    }

    //
    // Check to see if the Element we want to site select is already in a selection
    // or this is a shift selection
    // 
    
    if ( 
        //
        // Per NetDocs, ( IE 5 bug #95392) - we now want to site select if
        // something site selectable is in the selection
        // Leave old code here until we're sure we like this behavior.
        // 
        // Bug 3186.  We don't want to always site select if the event occurred
        // in a selection.  We only want to do it if a click occurred in the site
        // selectable element.  Otherwise we'll break drag drop functionality.
        _pManager->IsMessageInSelection( pEvent ) ||
        _pManager->GetTrackerType() == TRACKER_TYPE_Selection && pEvent->IsShiftKeyDown())
    {
        //
        // The element we clicked on is already in a text selection.
        // it cannot be site selected.
        //
        goto Cleanup;
    }
    
    fExtendSelectionAllowed = GetCommandTarget()->IsMultipleSelection() && 
                               NumberOfSelectedItems() > 0 && 
                               ( pEvent->IsShiftKeyDown() || pEvent->IsControlKeyDown() ) ;                                            

    if ( IsElementSiteSelectable( eTag, pIElement, NULL , & spElement, fExtendSelectionAllowed ) &&
         EdUtil::IsMasterParentEditable( GetMarkupServices(), spElement) == S_OK )
    {
        if( IsPassive() && 
            IsSelected( spElement ) == S_OK )
        {
            //
            // you would site select the same element - but you aren't in the adorner
            // this only make sense for the glyph case
            //
            Assert( ! IsInAdorner(pEvent));            
            eResult = SST_NO_BUBBLE;
            goto Cleanup;
        }
        else 
        {
            //
            // If we still want to create a control tracker - ensure that it's not the same
            // as the Editable Element - IF we  are currently UI-Active
            //
            if ( _pManager->IsElementContentSameAsContext( spElement ) == S_OK )
            {
                eResult = _pManager->IsUIActive() ? SST_NO_CHANGE : SST_CHANGE;
            }              
            else if ( GetCommandTarget()->IsMultipleSelection())
            {
                if ( IsPassive()  &&
                     ( pEvent->IsShiftKeyDown() || pEvent->IsControlKeyDown() ) ) 
                {
                    //
                    // We are hitting shift or control in a multiple selection.
                    // This denotes the start of multiple selection. We return No-Bubble
                    // and handle the extending of selection in HandleAction
                    //
                    eResult = SST_NO_BUBBLE;
                }
                else
                    eResult = SST_CHANGE;
            }
            else
            {
                eResult = SST_CHANGE;
            }                

            //  Bug 104792: Don't change if the user clicked on a control in an atomic element.
            //  Bug 4023: But check the site selectable element to see if it's atomic, not the element
            //  that received the click.
            if (eResult == SST_CHANGE && _pManager->CheckAtomic(spElement) == S_OK)
            {
                eResult = SST_NO_CHANGE;
            }
        }            
    }        

Cleanup:
    *peResult = eResult;
    
    RRETURN( hr );        
}


//+====================================================================================
//
// Method: Position
//
// Synopsis: Given two markup pointers, select the element they adorn.
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::Position(
        IDisplayPointer* pDispStart,
        IDisplayPointer* pDispEnd)
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spElementSelect;
    IHTMLElement       *pIElement = NULL;
    ELEMENT_TAG_ID      eTag = TAGID_NULL;
    MARKUP_CONTEXT_TYPE eContext = CONTEXT_TYPE_None;
    SP_IMarkupPointer   spStart;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);
    
    
    CControlTracker::HOW_SELECTED eHow =  CControlTracker::HS_NONE ;    

    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    
    //
    // Assumed that if we get here - it's from a control range, and the pointers are around
    // the element we want to select.
    //
    IFC( pDispStart->PositionMarkupPointer(spStart) );
    IFC( spStart->Right( FALSE, & eContext, & pIElement, NULL, NULL ));

    AssertSz( pIElement, "CControlTracker - expected to find an element");
    AssertSz( eContext != CONTEXT_TYPE_Text, "Did not expect to find text");
    
    IFC( GetMarkupServices()->GetElementTagId( pIElement , & eTag ));
        
    //
    // Verify that this object CAN be site selected
    //
    IGNORE_HR( IsElementSiteSelectable( eTag, pIElement, &eHow, &spElementSelect ));       
    if( eHow == HS_NONE )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!FireOnControlSelect(spElementSelect ) ||
        _pManager->GetActiveTracker() != this)
    {
        _pManager->EnsureDefaultTrackerPassive();
        hr = S_FALSE;
        goto Cleanup;
    }           
    IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Control, (ISelectionServicesListener*) _pManager ) );

    IFC (AddControlElement( spElementSelect ));
    
Cleanup:
    GetEditor()->IgnoreGlyphs( fIgnoreGlyphs );
    
    ReleaseInterface(pIElement);
    RRETURN1( hr, S_FALSE );
}

BOOL
CControlTracker::IsPointerInSelection(
                        IDisplayPointer   *pDispPointer,  
                        POINT             *pptGlobal, 
                        IHTMLElement      *pIElementOver )
{
    //
    // We now do this work - by seeing if the given point is in the adorner 
    //  OR it's the same element we're over ( to handle the glyph case)
    // We do this - as this routine is called to handle mouse overs. At the end of the document
    // hit testing will put the pointers at the edge of the control - making us think the mouse is 
    // inside the site selected object when it really isn't.
    // 

    BOOL fWithin =  IsInAdorner( *pptGlobal ) || 
                    ( IsSelected( pIElementOver, NULL ) == S_OK ) ;
      
    return ( fWithin );
}

//+---------------------------------------------------------------------------
//
//  Member:     OnExitTree
//
//  Synopsis: An adorned element is leaving the tree. Up to us to do the right thing here.
//
//----------------------------------------------------------------------------

HRESULT 
CControlTracker::OnExitTree(
            IMarkupPointer* pIStart, 
            IMarkupPointer* pIEnd, 
            IMarkupPointer* pIContentStart,
            IMarkupPointer* pIContentEnd            )
{
    HRESULT hr = S_OK;
    SP_IDisplayPointer spDispCtlTemp;
    int i;
    //
    // An element that contained selection may have left the tree.
    //
    
    for(i = NumberOfSelectedItems()-1; i >= 0; i--)
    {
        if ( Between( _aryControlElements[i]->pIElementStart, pIStart, pIEnd )  ||
             Between( _aryControlElements[i]->pIElementStart, pIContentStart, pIContentEnd ) )
        {
            if( _aryGrabAdorners[i]->IsPrimary() && ! _pPrimary )
            {
                //
                // We store what the primary was - so we can move the caret there.
                //
                IFC( GetEditor()->CreateMarkupPointer( & _pPrimary ));
                IFC( _pPrimary->MoveToPointer( _aryControlElements[i]->pIElementStart ));                
            }            
            
            IFC( RemoveItem( i ));
        }
    }

    if( NumberOfSelectedItems() > 0 ) // not the last item
    {
         hr = S_OK;
         goto Cleanup;
    }

    //
    // Create yet another pointer as ours gets released.
    //
    IFC( _pManager->GetDisplayServices()->CreateDisplayPointer(&spDispCtlTemp) );
    IFC( spDispCtlTemp->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    if (_pPrimary)
    {
        IFC( spDispCtlTemp->MoveToMarkupPointer(_pPrimary, NULL) );       
    }
    else
    {
        SP_IHTMLCaret  spCaret;
        
        Verify( S_OK == GetDisplayServices()->GetCaret( &spCaret ) );
        IFC( spCaret->MoveDisplayPointerToCaret(spDispCtlTemp));
    }
           
    hr = THR( _pManager->SetCurrentTracker( TRACKER_TYPE_Caret, spDispCtlTemp, spDispCtlTemp ) );
    Assert( IsDormant());
    Assert( ! _pPrimary );
    
Cleanup:
    RRETURN( hr );
} 

//+---------------------------------------------------------------------
//
// Method: OnLayoutChange
//
// Synopsis: our layoutness has changed. Update control selection so only things with layout remain selected.
//
//+---------------------------------------------------------------------

HRESULT 
CControlTracker::OnLayoutChange()
{
    HRESULT hr = S_OK;
    int     i;
    BOOL    fRemoveOccured = FALSE ;

    SP_IMarkupPointer  spPointer;
    SP_IDisplayPointer spDispPointer;
    CSelectionChangeCounter selCounter(_pManager);
    
    IFC( MarkupServices_CreateMarkupPointer( GetMarkupServices(), & spPointer ));
    IFC( GetDisplayServices()->CreateDisplayPointer( & spDispPointer ));
    
    IFC( spPointer->MoveAdjacentToElement( 
                                           _aryControlElements[PrimaryAdorner()]->pIElement, 
                                           ELEM_ADJ_BeforeBegin));
    
    IFC( spDispPointer->MoveToMarkupPointer( spPointer, NULL) );        
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

    for( i = 0 ; i < _aryControlElements.Size(); i ++ )
    {
        if ( IsLayout( _aryControlElements[i]->pIElement ) == S_FALSE )
        {
            IFC( RemoveControlElement(  _aryControlElements[i]->pIElement));
            if ( !fRemoveOccured)
                fRemoveOccured = TRUE ;
        }
    }

    
    if (fRemoveOccured || NumberOfSelectedItems() == 0 )
    {
        selCounter.BeginSelectionChange();
    }
        
    if ( NumberOfSelectedItems() == 0 )
    {        
        IFC( _pManager->PositionCaret( spDispPointer ));
    }

    if (fRemoveOccured || NumberOfSelectedItems() == 0 )
    {
        selCounter.EndSelectionChange();
    }
    
Cleanup:
    RRETURN( hr );
}

//
//
// Message Handling
//
//

HRESULT
CControlTracker::HandleEvent(
                    CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    Assert( pEvent );
    
    if ( _fActiveControl )
        goto Cleanup; // Bail!!
        
    switch( pEvent->GetType())
    {
        case EVT_KEYPRESS:
        {
            hr = HandleChar( pEvent );
        }
        break;

        case EVT_KEYDOWN:
        {
            hr = HandleKeyDown( pEvent ) ; 
        }
        break;

        case EVT_SETFOCUS:
        {
            SetDrawAdorners( TRUE ) ;
            hr = S_OK;
        }
        break;

        case EVT_KILLFOCUS:
        {
            SetDrawAdorners( FALSE );
        }
        // fall thru...
        
        case EVT_LOSECAPTURE:
        {            
            //
            // A focus change/loss of capture has occured. 
            // If we have capture - this is a bad thing.
            // a sample of this is throwing up a dialog from a script.
            //
            IFC( OnLoseFocus());
        }
        break;

        case EVT_LMOUSEDOWN:
        case EVT_RMOUSEDOWN:
        case EVT_MOUSEMOVE:
        case EVT_DBLCLICK:
        case EVT_LMOUSEUP:
        case EVT_RMOUSEUP:
        case EVT_CONTEXTMENU:
        {
            CONTROL_ACTION inAction = GetAction( pEvent );
            
            if ( inAction != A_IGNCONTROL ) // perf & dump sanity 
            {
                  hr = HandleAction( inAction, 
                                     pEvent );     
            }     
            else if ( pEvent->GetType() == EVT_LMOUSEUP )
            {
#if DBG == 1
                DumpTrackerState( pEvent, _state, inAction) ;
#endif                
                //
                // Consume mouse up's.
                //
                hr = S_OK;
            }
#if DBG == 1
            else
            {
                if ( IsTagEnabled( tagSelectionTrackerState ))
                    DumpTrackerState( pEvent, _state, inAction) ;
            }
#endif
        }
        break;
        
        case EVT_IME_STARTCOMPOSITION:
            hr = S_FALSE;
            break;

    }


Cleanup:
    RRETURN1 ( hr , S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member: HandleActivation
//
//  Synopsis: We are either about to become UI Active - or create a caret 
//            (ie we drilled into the control).
//
//----------------------------------------------------------------------------

HRESULT
CControlTracker::HandleActivation( 
                   CEditEvent* pEvent,  
                   CONTROL_ACTION inAction)
{                                   
    HRESULT hr = S_FALSE;

    ELEMENT_TAG_ID eTag = TAGID_NULL;
    Assert( inAction == A_PENDINGUIACTIVATE_UIACTIVATE );
    
    IFC( GetMarkupServices()->GetElementTagId( GetControlElement() , & eTag ));        
    if ( eTag != TAGID_TABLE )
    {
        SetState( CT_UIACTIVATE );
        hr = S_OK ;                
        IGNORE_HR( BecomeUIActive( pEvent ) );
    }                
    else
    {
        Assert( ! _pFirstEvent && ! _pNextEvent ); // ensure we don't have events cached.
        
        //
        // Only transition to a caret if the last place we clicked on is inside the table.
        // So ignore clicks on the border, between cells etc.
        // 
        
        SP_IMarkupPointer spStart;
        SP_IMarkupPointer spEnd;
        SP_IMarkupPointer spLastClick;
        
        IFC( GetEditor()->CreateMarkupPointer( & spStart ));
        IFC( GetEditor()->CreateMarkupPointer( & spEnd ));
        IFC( GetEditor()->CreateMarkupPointer( & spLastClick ));
        
        IFC( spStart->MoveAdjacentToElement( GetControlElement(), ELEM_ADJ_BeforeBegin ));
        IFC( spEnd->MoveAdjacentToElement( GetControlElement(), ELEM_ADJ_AfterEnd));
        IFC( _pDispLastClick->PositionMarkupPointer( spLastClick ));
        
        if ( BetweenExclusive( spLastClick, spStart, spEnd ))
        {
            SP_IHTMLElement     spElement;

            //  Make sure we won't be positioning the caret inside of an atomic
            //  element.  If we would be we need to go and select the atomic element.
            IFC( GetCurrentScope(_pDispLastClick, &spElement) );
            if (_pManager->CheckAtomic(spElement) == S_OK)
            {
                IFC( _pManager->StartAtomicSelectionFromCaret(_pDispLastClick) );
                ClearInterface( & _pDispLastClick );            
            }
            else
            {
                Assert( _pDispLastClick );
                SetState( CT_END );
                IFC( _pManager->PositionCaret( _pDispLastClick ));
                ClearInterface( & _pDispLastClick );            
                // fire the selectionchange event
                {
                    CSelectionChangeCounter selCounter(_pManager);
                    selCounter.SelectionChanged();
                }
            }
        }
        else
        {
            if ( _pManager->IsInTimer() )
            {
                StopTimer();
            }
            
            SetState( CT_PASSIVE );	
        }
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member: TransitionToPreviousCaret
//
//  Synopsis: We're leaving site selection mode - transition to the previous caret
//            if possible.
//
//----------------------------------------------------------------------------

HRESULT
CControlTracker::TransitionToPreviousCaret( )
{
    HRESULT hr = S_OK;
    SP_IDisplayPointer  spDispPointer;

    IFC( _pManager->GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        
    if ( _pManager->IsCaretAlreadyWithinContext() )
    {
        SP_IHTMLCaret spCaret;

        IFC( GetDisplayServices()->GetCaret(&spCaret) );
        IFC( spCaret->MoveDisplayPointerToCaret(spDispPointer));

        _pManager->PositionCaret( spDispPointer );
    }
    else
    {
        IFC( spDispPointer->MoveToMarkupPointer(_pManager->GetStartEditContext(), NULL) );        
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        _pManager->PositionCaret( spDispPointer );
    }
    
Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member: HandleAction
//
//  Synopsis: Given an Action - denoting a state transition - transition to the 
//            next state
//
//----------------------------------------------------------------------------

HRESULT
CControlTracker::HandleAction( 
                   CONTROL_ACTION inAction,
                   CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    POINT   pt;

#if DBG == 1 || TRACKER_RETAIL_DUMP == 1
    CONTROL_STATE oldState = _state;
#endif 

    switch( inAction )
    {
        case A_IGNCONTROL:
            break;
            
        case A_ERRCONTROL:
            AssertSz(0,"Unexpected Event for State !");
            break;
            
        case A_START_WAIT:
            AssertSz(0,"Unexpected State Transition");
            break;
            
            
        case A_WAIT_PASSIVE:   
            hr = S_OK;
                            
            SetState( CT_PASSIVE );
            break;
            
        case A_PASSIVE_DOWN:
        {
            //
            // Based on where the mouse down was - we decide how to transition 
            //
            CONTROL_STATE newState;
            
            //
            // on any downclick - store where we started the click from 
            //
            IFC( pEvent->GetPoint( & pt ));
            _startMouseX = pt.x;
            _startMouseY = pt.y;            
           
            //
            //
            // See which state to transition to.  It may return S_FALSE if we
            // get an element which we are not expecting (101917), so we just 
            // return to the passive state, and bubble the event
            //
            IFC( GetStateForPassiveDown( pEvent , & newState ));

            //
            // We need to at least own selection services, and have elements in our array
            // to perform these operations
            //
            if( hr == S_FALSE )
                goto Cleanup;

            Assert( newState == CT_PASSIVE || NumberOfSelectedItems() );
            
            switch( newState )
            {
                case CT_PASSIVE:
                    //
                    // We used to set the caret visibility here ? Still needed ?
                    //
                    if ( pEvent->GetType() == EVT_LMOUSEDOWN )  
                    {   
                        hr = S_OK;
                    }
                    // else 
                    // return S_FALSE for RBUTTONDOWN for context menu 
                    //  
                    break;
                    
                case CT_RESIZE:                
                    if (!FireOnAllElements(FireOnResizeStart))
                    {
                       //
                       //  Start of Resize cancelled. Become passive.
                       //
                       newState = CT_PASSIVE ;
                    }
                    else
                    {
                        hr = THR( BeginResize( pEvent ));
                        if ( hr )
                        {
                          //
                          // Start of Resize failed. Become passive.
                          //
                          newState = CT_PASSIVE ;
                        }
                    }
                    hr = S_OK;
                    break;

                case CT_LIVERESIZE:                
                    if (!FireOnAllElements(FireOnResizeStart))
                    {
                       //
                       // Start of Resize cancelled. Become passive.
                       //
                       newState = CT_PASSIVE ;
                    }
                    else
                    {
                        hr = THR( BeginLiveResize( pEvent ));
                        if ( hr )
                        {
                            //
                            // Start of Live Resize failed. Become passive.
                            //
                            newState = CT_PASSIVE ;
                        }
                    }
                    hr = S_OK;
                    break;

                case CT_WAITMOVE:
                    if (  pEvent->GetType() == EVT_LMOUSEDOWN )  
                    {   
                        hr = S_OK;
                    }
                    // else 
                    // return S_FALSE for RBUTTONDOWN for context menu 
                    // 
                    POINT ptWait;
                    IFC( pEvent->GetPoint( & ptWait ));
                    _startMouseX = ptWait.x;
                    _startMouseY = ptWait.y;                 
                    break;
                    
                case CT_PENDINGUP:
                {
                    Assert( pEvent->GetType() != EVT_RMOUSEDOWN );

                    ELEMENT_TAG_ID eTag = TAGID_NULL;
                    IFC( GetMarkupServices()->GetElementTagId( GetControlElement() , & eTag ));
                    if ( eTag != TAGID_TABLE )
                    {
                        SetDrillIn( TRUE, pEvent );                
                    }                        
                        
                    hr = S_OK;
                 }   
                 break;

                case CT_EXTENDSELECTION:
                {
                    SP_IHTMLElement spElement;
                    IFC( GetSiteSelectableElementFromMessage( 
                                                    pEvent, & spElement ));
                    
                    if (FireOnControlSelect(spElement) && _pManager->GetActiveTracker() == this)
                    {   
                        IFC ( AddControlElement( spElement ));
                        IFC ( MakePrimary(_aryControlElements.Size() - 1 ));

                        // fire the selectionchange event
                        {
                            CSelectionChangeCounter selCounter(_pManager);
                            selCounter.SelectionChanged();
                        }
                    }
                    newState = CT_PASSIVE; // return to passive state after adding the element.
                }
                break;

                case CT_REDUCESELECTION:
                {
                    if ( NumberOfSelectedItems() > 1 )
                    {
                        SP_IHTMLElement spElement;
                        IFC( GetSiteSelectableElementFromMessage( 
                                                        pEvent, & spElement ));
                        IFC( RemoveControlElement( spElement ));

                        // fire the selectionchange event
                        {
                            CSelectionChangeCounter selCounter(_pManager);
                            selCounter.SelectionChanged();
                        }
                        
                        newState = CT_PASSIVE; // return to passive state after adding the element.
                        
                    }
                    else
                    {
                        SP_IHTMLElement spControlElement;
                        
                        spControlElement = GetControlElement();

                        //
                        // about to terminate ourselves. Transition to a caret.
                        //   
                        SetDrillIn( TRUE );
                        IFC( BecomeCurrent( _pManager->GetDoc(), spControlElement));
                        IFC( _pManager->PositionCaret( pEvent ));
                        newState = CT_DORMANT;
                        Assert( IsDormant());
                        
                    }
                }
                break;

                case CT_WAITCHANGEPRIMARY :
                {
                    // nothing to do - just go to this state.
                    break;
                }
                default:
                {
                    AssertSz(0,"Unexpected State");
                }                    
            }

            if ( newState != _state )
                SetState( newState );
        }            
        break;
            
        case A_PENDINGUIACTIVATE_UIACTIVATE:   
        {
#ifdef FORMSMODE
            if (IsAnyElementInFormsMode())
            {   
                break;
            }
#endif
            SetDrillIn( TRUE  );                            
            hr = HandleActivation( pEvent, inAction );
        }
        break;

        case A_RESIZE_MOVE:
        {
            //
            // No state transition - do the work of doing the resize
            //
            DoResize( pEvent );
            hr = S_OK;
        }            
        break;
            
        case A_LIVERESIZE_MOVE:
        {
            //
            // No state transition - do the work of doing the live resize
            //
            DoLiveResize( pEvent );
            hr = S_OK;
        }            
        break;
            
        case A_RESIZE_PASSIVE:
        {
            //
            // Commit the Resize Operation - and transfer to passive
            //
            CommitResize( pEvent );
            if ( pEvent->GetType() == EVT_LMOUSEUP )
                hr = S_OK;
            
            SetState( CT_PASSIVE );
        }            
        break;
        
        case A_LIVERESIZE_PASSIVE:
        {
            //
            // Commit the Live Resize Operation - and transfer to passive
            //

            CommitLiveResize( pEvent );
            if ( pEvent->GetType() == EVT_LMOUSEUP )
                hr = S_OK;
            
            SetState( CT_PASSIVE );
        }            
        break;
        
        case A_WAITMOVE_PASSIVE:
        {
            SetState( CT_PASSIVE);
        }            
        break;

        case A_2DMOVE_PASSIVE:
        {
            End2DMove();
            SetState(CT_PASSIVE);
            hr = S_OK;
        }
        break;

        case A_2DMOVE_2DMOVE :
        {
            if ( pEvent->GetType() == EVT_LMOUSEDOWN )
                hr = S_OK;
        
            Do2DMove( pEvent);
            SetState(CT_2DMOVE);
            hr = S_OK;
        }
        break;

        case A_WAITMOVE_MOVE:
        case A_PENDINGUP_MOVE:
        case A_WAIT_MOVE:
        case A_WAITCHANGEPRI_DRAGMOVE:                   
        {
            IFC( pEvent->GetPoint( & pt ));
            if ( !IsValidMove( & pt) )            
            {
                break;
            }

            if ( _state == CT_PENDINGUP )
            {
                SetDrillIn( FALSE );
            }

            BOOL f2DMove = FALSE;
            if (GetCommandTarget()->Is2DPositioned())
            {
                f2DMove = TRUE;

                //
                // Check if all elements positioned. If so then go into 2DMove Mode.
                //
                for ( int i = 0 ; i < NumberOfSelectedItems(); i ++ )
                {
                    if ( ! IsElementPositioned( GetControlElement(i)))
                    {
                        f2DMove = FALSE;
                        break;
                    }
                }
            }

            if ( f2DMove )
            {
                if (FireOnAllElements(FireOnMoveStart))
                {
                    Assert( ! _pUndoUnit );
                    _pUndoUnit = new CEdUndoHelper (_pManager->GetEditor());
                    if(NULL == _pUndoUnit)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }
                    _pUndoUnit->Begin(IDS_EDUNDOMOVE);

                    if (TakeCapture() != S_OK)
                    {
                        SetState(CT_PASSIVE);
                    }
                    else
                    {
                        SetState(CT_2DMOVE);
                        Begin2DMove(pEvent);
                    }
                }
                else
                {
                    SetState(CT_PASSIVE);
                }
            }
            else
            {
               SetState( CT_DRAGMOVE);
               DoDrag(); 
            }
        }            
        break;

        case A_PASSIVE_PENDINGUIACTIVATE:        
        {
            ELEMENT_TAG_ID eTag = TAGID_NULL;
            IFC( GetMarkupServices()->GetElementTagId( GetControlElement() , & eTag ));

            //
            // Don't UI-Activate if we shouldn't go UI-Active, (and we're not a a table)
            // or the magic event told us not to
            // 
            if( IsInResizeHandle( pEvent )                                                      ||
                IsInMoveArea( pEvent )                                                          ||
                NumberOfSelectedItems() > 1                                                     ||
                ( !ShouldClickInsideGoActive( GetControlElement(0)) && eTag != TAGID_TABLE )    ||
                  !FireOnBeforeEditFocus( eTag != TAGID_TABLE ? 
                                            GetControlElement(0) : 
                                            _pManager->GetEditableElement(),
                                            _pManager->IsContextEditable() ) ||
                   _pManager->GetActiveTracker() != this )                                                                    
            {
                break;
            }
            //
            // else fallthru
            //            
        }
            
        case A_PENDINGUP_PENDINGUIACTIVATE:
        {       
            IFC( MoveLastClickToEvent( pEvent ));
            IFC( StartTimer());
            SetState( CT_PENDINGUIACTIVATE );

            if ( _pFirstEvent )
            {
                StoreNextEvent( DYNCAST( CHTMLEditEvent, pEvent ));
            }                                
        }    
        break;

        case A_PENDINGUP_END:
        {
            AssertSz(0,"Unexpected Transition");
        }    
        break;

        case A_WAITCHANGEPRI_CHANGEPRI:
        {
            SP_IHTMLElement spElement;
            int iSel;                

            IFC( GetSiteSelectableElementFromMessage( pEvent, & spElement ));
            if ( hr == S_FALSE )
            {
                AssertSz(0,"Did not find a site selectable elemnet. Why are you here ?");
                goto Cleanup;
            }    
            
            IFC( IsSelected( spElement, & iSel ));
            if ( hr != S_OK || iSel == -1 )
            {
                AssertSz(0, "Element not selected ");
                hr = E_FAIL;
                SetState( CT_PASSIVE );
                goto Cleanup;
            }
            
            if ( ! _aryGrabAdorners[ iSel ]->IsPrimary())
            {
                IFC( MakePrimary( iSel ));
            }
            
            if (  pEvent->GetType() == EVT_LMOUSEDOWN )  
            {   
                hr = S_OK;
            }

            SetState( CT_PASSIVE ) ;
        }
        break;


        default:
        {
            AssertSz( 0, "Unknown Tracker Transition");
        }            
    }

#if DBG == 1 || TRACKER_RETAIL_DUMP == 1

#if DBG == 1
    if ( IsTagEnabled( tagSelectionTrackerState ))
    {
#endif
        DumpTrackerState( pEvent, oldState, inAction) ;
#if DBG == 1
    }
#endif   

#endif

Cleanup:    
    RRETURN1( hr, S_FALSE);
}

HRESULT
CControlTracker::MoveLastClickToEvent( CEditEvent* pEvent )
{
    HRESULT hr;
    ClearInterface( & _pDispLastClick );
    IFC( _pManager->GetDisplayServices()->CreateDisplayPointer( & _pDispLastClick ));
    

    IFC( pEvent->MoveDisplayPointerToEvent( _pDispLastClick, GetEditableElement(), TRUE ));

Cleanup:    
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member: GetStateForPassiveDown
//
//  Synopsis: A mouse down occurred. Ambiguious as to what next state is
//            We make some tests to see what the next state should be
//
//   If in Resize    - Next State is CT_RESIZE or CT_LIVERESIZE
//   If in Move Area - Next State is CT_DRAGMOVE
//   If inside && allowed to go active && Fire On Edit Focus - Next State is CT_ACTIVATE
//
//      else state is CT_PASSIVE
//
//----------------------------------------------------------------------------


HRESULT
CControlTracker::GetStateForPassiveDown( CEditEvent* pEvent, CONTROL_STATE* pNewState )
{
    CONTROL_STATE   newState = CT_PASSIVE;
    BOOL            fLocked;
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElement;
    BOOL fInResizeHandle, fInMoveArea;
    
    Assert( _state == CT_PASSIVE );
    
    if ( ! AllElementsEditable() )
    {
        newState = CT_PASSIVE;
        goto Cleanup;      
    }

    hr = THR( GetSiteSelectableElementFromMessage( pEvent, & spElement)); 

    fInResizeHandle = IsInResizeHandle(pEvent);
    fInMoveArea = IsInMoveArea(pEvent);
    
    //
    // TODO - This is related to bug 101917.  This assert occurs, and we 
    // fail out of the control tracker.  We get back to CT_PASSIVE correctly
    // and resume handling events, so I am removing this assert until we can
    // correctly fix this bug.
    //
    //
    //AssertSz( hr != S_FALSE, "No site selectable element. Why are you here ?");
    if ( hr )
        goto Cleanup;
        
    fLocked = AllElementsUnlocked() ? FALSE : TRUE;    

    if ( GetCommandTarget()->IsMultipleSelection()  &&
         ! fInResizeHandle && 
         ( pEvent->IsShiftKeyDown() || pEvent->IsControlKeyDown() ))
    {         
        if ( IsSelected( spElement, NULL ) == S_OK )
        {
            newState = CT_REDUCESELECTION;                
        }
        else
        {
            newState = CT_EXTENDSELECTION;
        }
    }         
    else if ( ! fLocked && fInResizeHandle )
    {
        newState = GetCommandTarget()->IsLiveResize() ? CT_LIVERESIZE : CT_RESIZE;
    }
    else if ( ! fLocked && fInMoveArea )
    {
        newState = CT_WAITMOVE;
    }
    else
    {
    
#if DBG == 1    
        BOOL fSameElement;
        fSameElement = IsInAdorner(pEvent, NULL ) ||
                       IsSelected( spElement, NULL ) == S_OK ;
        AssertSz( fSameElement, "Not in same element as control - why are you getting this event ?" );
#endif             
        int iSel;
        //
        // Valid to change the primary for >1 selected elements
        // otherwise we have the same IE5 drill in behavior
        //
        if ( GetCommandTarget()->IsMultipleSelection() &&
             NumberOfSelectedItems() > 1 &&
             IsSelected( spElement, & iSel ) == S_OK )
        {                  
            newState = CT_WAITCHANGEPRIMARY; 
        } 
        else if ( pEvent->GetType() == EVT_LMOUSEDOWN )
        {                
            //                        
            // Here we will go UI Active.
            // Only allow going UI Active on LBUTTONDOWN. 
            //
            ELEMENT_TAG_ID eTag = TAGID_NULL;
            
            IFC( GetMarkupServices()->GetElementTagId( GetControlElement() , & eTag ));
            if ( ShouldClickInsideGoActive( GetControlElement(0)) || eTag == TAGID_TABLE )
            {
                //
                // For tables the editable element is getting focus. Otherwise the control
                // is getting focus.
                //
                if ( NumberOfSelectedItems() == 1)
                {
                    if (FireOnBeforeEditFocus((eTag != TAGID_TABLE) ? 
                                                       GetControlElement(0) : 
                                                      _pManager->GetEditableElement(), 
                                               _pManager->IsContextEditable()))
                    {
                        if (_pManager->GetActiveTracker() == this )
                        {
                            newState = CT_PENDINGUP;
                        }
                        else
                        {
                            newState = CT_PASSIVE;
                        }
                    }
                    else
                    {
                        newState = CT_WAITMOVE;
                    }
                }
                else
                {
                    newState = CT_PASSIVE;
                }
            }
            else
            {
                //
                // Click in something that CANNOT be active - eg. Image or HR.
                //
                newState = CT_WAITMOVE;
            }
        }
        else
        {
            newState = CT_PASSIVE;
        }
    }     


#if DBG == 1 || TRACKER_RETAIL_DUMP == 1

#if DBG == 1
    if ( IsTagEnabled( tagSelectionTrackerState ))
    {
#endif
        DumpIntermediateState( pEvent, _state, newState) ;
#if DBG == 1
    }
#endif  

#endif

Cleanup:
    if ( pNewState )
        *pNewState = newState;
    
    RRETURN1( hr, S_FALSE );
}

              
//+====================================================================================
//
// Method: HandleKeyDown
//
// Synopsis: Trap ESC to go deactive
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::HandleKeyDown( 
                        CEditEvent* pEvent )
{
    HRESULT             hr = S_FALSE;
    IMarkupPointer     *pControlStart = NULL ;
    IMarkupPointer     *pControlEnd = NULL ;
    ELEMENT_ADJACENCY   eAdj = ELEM_ADJ_BeforeBegin;
    SP_IDisplayPointer  spDispControlStart;
    SP_IHTMLElement     spElement ;
    LONG                keyCode ;

    IGNORE_HR( pEvent->GetKeyCode(& keyCode ));

#ifdef FORMSMODE
    if (_pManager->IsInFormsSelectionMode(GetControlElement(0)))
    {
        hr = S_OK;
        goto Cleanup;
    }
#endif
        
    if ( !IsActive() )
    {
        switch( keyCode )
        {       
            //
            // at some point we may want to change this behavior - to move the thing that we site select
            // for now we just transition to a caret - and pump the message on.
            //
            case VK_HOME:
            case VK_END:
            case VK_ESCAPE:
            case VK_LEFT:
            case VK_RIGHT:            
            {
                switch( keyCode )
                {
                    case VK_NEXT:
                    case VK_END:
                    case VK_RIGHT:
                        eAdj = ELEM_ADJ_AfterEnd;
                    break;    

                    default:
                        eAdj = ELEM_ADJ_BeforeBegin;
                }

                if ( g_fInVid && ( keyCode == VK_LEFT || keyCode == VK_RIGHT ) )
                {
                    //
                    // special case VID
                    // to match AppHack in CDoc::PerformTA()
                    // 
                    goto Cleanup;
                }
                
                //
                // We are Site Selected. Hitting escape transitions to a caret before the control
                //
                IFC( GetEditor()->CreateMarkupPointer( & pControlStart ));
                IFC( GetEditor()->CreateMarkupPointer( & pControlEnd ));

                SP_IHTMLElement spPrimaryElement;
                spPrimaryElement = GetControlElement(  PrimaryAdorner() );
                IFC( pControlStart->MoveAdjacentToElement( spPrimaryElement  , eAdj ));
                IFC( pControlEnd->MoveAdjacentToElement( spPrimaryElement, eAdj ));

                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispControlStart) );
                IFC( spDispControlStart->MoveToMarkupPointer(pControlStart, NULL) );
                IFC( spDispControlStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

                _pManager->PositionCaret(spDispControlStart, ( keyCode == VK_ESCAPE ||
                                                               keyCode == VK_LEFT ||
                                                               keyCode == VK_RIGHT ) ? 
                                                                NULL : pEvent );  
                // fire the selectionchange event
                {
                    CSelectionChangeCounter selCounter(_pManager);                
                    selCounter.SelectionChanged();
                }
                
                hr = S_OK;
            }
            break;

            case VK_PRIOR:
            case VK_NEXT:
            {
                CARET_MOVE_UNIT     eMoveUnit = CARET_MOVE_PAGEDOWN;
                POINT               ptPoint;

                ptPoint.x = CARET_XPOS_UNDEFINED;
                ptPoint.y = CARET_XPOS_UNDEFINED;

                //  Determine the unit of movement.
                switch (keyCode)
                {
                    case VK_PRIOR:
                        eMoveUnit = CARET_MOVE_PAGEUP;
                        break;
                        
                    case VK_NEXT:
                        eMoveUnit = CARET_MOVE_PAGEDOWN;
                        break;
                };

                //  Set a markup pointer before our element
                IFC( GetEditor()->CreateMarkupPointer( & pControlStart ) );
                IFC( pControlStart->MoveAdjacentToElement( GetControlElement(0), ELEM_ADJ_BeforeBegin ) );

                //  Position a display pointer at the markup position
                IFC( GetDisplayServices()->CreateDisplayPointer(& spDispControlStart) );
                IFC( spDispControlStart->MoveToMarkupPointer(pControlStart, NULL) );

                //  Move the display pointer by the specified unit of movement,
                //  and scroll to it.
                IFC( MovePointer(eMoveUnit, spDispControlStart, &ptPoint, NULL, TRUE) );

                hr = S_OK;
            }
            break;            
        }
    }
    
Cleanup:    
    ReleaseInterface (pControlStart);
    ReleaseInterface (pControlEnd);
    RRETURN1 ( hr, S_FALSE );
}


//+============================================================================
//
// Method: HandleChar
//
// Synopsis: Trap Enter and ESC to go active/ deactive
//
//-----------------------------------------------------------------------------


HRESULT
CControlTracker::HandleChar(
                CEditEvent* pEvent )
{
    HRESULT         hr = S_FALSE;
    LONG            keyCode;
    SP_IHTMLElement spElement;

#ifdef FORMSMODE
    if (_pManager->IsInFormsSelectionMode(GetControlElement(0)))
    {
        hr = S_OK;
    }
    else
    {
#endif

    IGNORE_HR( pEvent->GetKeyCode(&keyCode));
    switch( keyCode )
    {        
        case VK_RETURN:
        {
            if ( ! IsActive())
            {
                if ( ShouldClickInsideGoActive( GetControlElement(0)))
                {
                    if ( FireOnBeforeEditFocus( GetControlElement(0)) &&
                         _pManager->GetActiveTracker() == this )
                    {
                        SetDrillIn( TRUE , NULL );
                        IGNORE_HR( BecomeUIActive( pEvent ) ) ;
                    }
                }                    
                hr = S_OK;
            }
        }
        break;
    }
#ifdef FORMSMODE
    }
#endif

    RRETURN1 ( hr, S_FALSE );
}

//+====================================================================================
//
// Method: OnTimerTick
//
// Synopsis: Callback from Trident - for WM_TIMER messages.
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::OnTimerTick()
{
    HRESULT                 hr = S_OK;    
    StopTimer();
    
    switch (_state)
    {
        case CT_PENDINGUIACTIVATE:
#ifdef FORMSMODE
            if (IsAnyElementInFormsMode() )
                break;
#endif
            _pManager->SetDrillIn( TRUE );
            
            hr = HandleActivation( NULL, A_PENDINGUIACTIVATE_UIACTIVATE );
            break;
            
        default:
            AssertSz(0, "Unexpected state");
            break;
    }
    RRETURN(hr);
}

//
//
// Resizing / Moving / Dragging 
//
//
HRESULT
CControlTracker::DoResize( CEditEvent* pEvent  )
{
    HRESULT hr = S_OK;
    POINT   ptSnap;
    int     i;

    IFC( pEvent->GetPoint( & ptSnap));

    if ( ::PtInRect( & _rcClipMouse, ptSnap  )  )
    {
        if (_fClipMouse)
        {
             hr = IgnoreResizeCursor(FALSE);
             _fClipMouse = FALSE ;
        }
        
        for( i = _aryGrabAdorners.Size()-1; i >= 0; i--)
        {  
            _aryGrabAdorners[i]->DuringResize(ptSnap);
            FireOnResize(GetControlElement(i),_pManager->IsContextEditable());
        }
    }
    else
    {
        _fClipMouse = TRUE;
        hr = IgnoreResizeCursor(TRUE);

    }    

Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CControlTracker::IgnoreResizeCursor(BOOL fIgnore)
{
    HRESULT hr = S_FALSE;
    LPCTSTR idc = NULL;

    if (fIgnore)
    {
        idc = IDC_NO ;
    }
    else
    {
        switch (_elemHandle)
        {
            case ELEMENT_CORNER_BOTTOMRIGHT:
            case ELEMENT_CORNER_TOPLEFT:
                idc = IDC_SIZENWSE;
                break;
            
            case ELEMENT_CORNER_BOTTOMLEFT:
            case ELEMENT_CORNER_TOPRIGHT:
                idc = IDC_SIZENESW;
                break;
            
            case ELEMENT_CORNER_TOP:
            case ELEMENT_CORNER_BOTTOM:
                idc = IDC_SIZENS;
                break;
            
            case ELEMENT_CORNER_LEFT :
            case ELEMENT_CORNER_RIGHT:
                idc = IDC_SIZEWE;
                break;
            
            default:
                AssertSz(0, "Unexpected Element Corner");
                return S_FALSE;
        }
    }

    HCURSOR hcursor = LoadCursorA(NULL, (char *)idc);

    Assert(hcursor);
    if (hcursor)
    {
        ::SetCursor(hcursor);
        return S_OK;
    }

    hr = GetLastError();
    RRETURN(hr);
}

//+====================================================================================
//
// Method: DoLiveResize
//
// Synopsis: live updation of object while resizing the object 
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::DoLiveResize( CEditEvent* pEvent )
{
    HRESULT hr = S_OK;
    RECT    newRect;
    POINT   change;
    BOOL    fResize = FALSE;
    POINT   ptSnap;
    
    IFC( pEvent->GetPoint( & ptSnap ));

    if ( ::PtInRect( & _rcClipMouse, ptSnap ) )
    {
        if (_fClipMouse)
        {
             hr = IgnoreResizeCursor(FALSE);
             _fClipMouse = FALSE ;
        }
     

        fResize = ( ptSnap.x != _startLastMoveX ) || 
                  ( ptSnap.y != _startLastMoveY )   ;

        if ( fResize ) 
        {       
            change.x = ptSnap.x - _startLastMoveX;
            change.y = ptSnap.y - _startLastMoveY;

            _startLastMoveX = ptSnap.x;
            _startLastMoveY = ptSnap.y;

            for(int i = _aryGrabAdorners.Size()-1; i >= 0; i--)
            {  
                _aryGrabAdorners[i]->DuringLiveResize( change, &newRect );
                IFC( ResizeElement( newRect, GetControlElement(i)));
                FireOnResize(GetControlElement(i),_pManager->IsContextEditable());
            }

            Refresh();
       }
    }       
    else
    {
        _fClipMouse = TRUE;
        hr = IgnoreResizeCursor(TRUE);
    }
     
Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method: Begin2DMove
//
// Synopsis: Start Moving the object in 2D Fashion, continuous update of position
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::Begin2DMove( CEditEvent* pEvent )
{
    HRESULT             hr = S_OK;
    POINT               ptSnap ;                                // Point where move started
    SP_IHTMLElement     spBodyElement ;
    POINT               ptOrigin;

    IFC( pEvent->GetPoint( & ptSnap ));
    
    IFC(GetEditor()->GetBody(&spBodyElement));
    
    IFC(GetElementRect(spBodyElement, &_rcClipMouse));

    IFC( EdUtil::GetClientOrigin( GetEditor(), spBodyElement, &ptOrigin) );

    ptSnap.x -= ptOrigin.x ;
    ptSnap.y -= ptOrigin.y ;

    _startMouseX = ptSnap.x ;
    _startMouseY = ptSnap.y ;    

    
    IFC(GetMovingPlane(&_rcRange));

    FilterOffsetElements();

    //
    // Clear off, and setup move rects
    //
    IFC( DeleteMoveRects() );
    IFC( SetupMoveRects() );
  
Cleanup:
    RRETURN (hr);
}


HRESULT
CControlTracker::DeleteMoveRects()
{
    RECT    **ppRect = NULL;
    int     i;
    
    for( i = _aryMoveRects.Size(), ppRect = _aryMoveRects;
         i > 0;
         i--, ppRect++ )
    {
        delete *ppRect;
    }

    _aryMoveRects.DeleteAll();
    
    RRETURN(S_OK);
}

HRESULT
CControlTracker::SetupMoveRects()
{
    int     nCount = NumberOfSelectedItems();       // Number of items that could be moved
    HRESULT hr = S_OK;
    
    for(int i = 0; i < nCount; i++)
    {
        RECT *pRect = NULL;

        pRect = new RECT;
        if( !pRect )
            goto Error;

        //
        // Retrieve and store the original position of the rect
        //
        IFC( GetElementRect( GetControlElement(i), pRect ) );
        IFC( _aryMoveRects.Append( pRect ) );
    }

Cleanup:
    RRETURN(hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

// get the moving plane, the wide rectangle which contains
// all the moving rectangles
HRESULT
CControlTracker::GetMovingPlane(RECT* rcRange)
{
    HRESULT hr = S_OK;
    SP_IHTMLElement     spBodyElement;
    SP_IHTMLElement2    spBodyElement2;
    RECT    rcPlane = { 0, 0, 0, 0 };
    int     i = 0;
    long                lTop, lLeft;
    
    Assert( NumberOfSelectedItems() );

    IFC(GetElementRect(GetControlElement(i), &rcPlane));
        
    for (i = 1 ; i < NumberOfSelectedItems(); i++)
    {
        RECT  actualRect;
        GetElementRect(GetControlElement(i), &actualRect);
                   
        if (actualRect.left < rcPlane.left)    
            rcPlane.left = actualRect.left ;
        
        if (actualRect.top < rcPlane.top )      
            rcPlane.top  = actualRect.top ;
        
        if (actualRect.right > rcPlane.right)  
            rcPlane.right  = actualRect.right ;
        
        if (actualRect.bottom > rcPlane.bottom ) 
            rcPlane.bottom = actualRect.bottom ;
    }

    //  We need to offset the rect to adjust for scrolling.

    IFC(GetEditor()->GetBody(&spBodyElement));
    IFC( spBodyElement->QueryInterface( IID_IHTMLElement2, (void **) &spBodyElement2 ));

    IGNORE_HR(spBodyElement2->get_scrollTop(&lTop));
    IGNORE_HR(spBodyElement2->get_scrollLeft(&lLeft));

    OffsetRect(&rcPlane, -lLeft, -lTop);

    *rcRange = rcPlane ;

Cleanup :
    RRETURN1 (hr , S_FALSE);
}
    
// fix for multiple container-child selections and filtering 
// the childs out from moving : 99243 : chandras
HRESULT
CControlTracker::FilterOffsetElements()
{
   HRESULT hr = S_OK;
   int i = 0;
   int nCount = NumberOfSelectedItems();
  
   for (i = 0; i < nCount; i++)
        _aryGrabAdorners[i]->SetPositionChange(TRUE);
  
   if (nCount > 1)
   {
       SP_IHTMLElement spBodyElement ;
   
       IFC(GetEditor()->GetBody((&spBodyElement)));

       for (i = 0; i < nCount ; i++)
       {
            SP_IHTMLElement spParent;
            BOOL fFound = FALSE ;
            ELEMENT_TAG_ID eTag = TAGID_NULL;
            
            GetControlElement(i)->get_offsetParent(&spParent);
            IFC( GetMarkupServices()->GetElementTagId(spParent, & eTag ));

            while (spParent != NULL && (eTag != TAGID_BODY) && !fFound)
            {
                SP_IHTMLElement spTempParent;
        
                if (IsSelected(spParent) == S_OK)
                {
                    _aryGrabAdorners[i]->SetPositionChange(FALSE);
                    fFound = TRUE;
                }            
                spParent->get_offsetParent(&spTempParent); 
                spParent = spTempParent;
                if (spParent != NULL)
                {
                    IFC( GetMarkupServices()->GetElementTagId(spParent, & eTag ));
                }
            }        
       }
   }
  
Cleanup:
   RRETURN (hr);
}

//+====================================================================================
//
// Method: Do2DMove
//
// Synopsis: Moving the object in 2D Fashion, continuous update of position
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::Do2DMove( CEditEvent* pEvent )
{
    HRESULT hr = S_OK;
    CHTMLEditEvent  *pEditEvent;
    POINT   ptOffset;
    POINT   ptSnap ;
    POINT   ptOrigin;
   
    //  Bug 2026(109652) Don't resize if the src element is a view link master element.  When
    //  moving a viewlink the capture handler will call us with the view link master as the
    //  src element.  We don't want to handle it now because we are expecting the view link
    //  body.
    pEditEvent = DYNCAST( CHTMLEditEvent, pEvent );
    if (pEditEvent)
    {
        SP_IHTMLElement     spSrcElement;

        IFC( pEditEvent->GetEventObject()->get_srcElement(&spSrcElement) );
        Assert( spSrcElement != NULL );

        //  If the src element is the viewlink master element, then don't do the move.  We'll
        //  get called again to move the viewlink body.
        if ( GetEditor()->IsMasterElement(spSrcElement) == S_OK )
        {
            ELEMENT_TAG_ID eTag = TAGID_NULL;
            IFC( GetMarkupServices()->GetElementTagId(spSrcElement, & eTag ));

            if (eTag != TAGID_INPUT)
                goto Cleanup;
        }
    }

    IFC( pEvent->GetPoint( & ptSnap ));

#if DBG == 1
           if (IsTagEnabled(tagShowMovePosition))
            {
                CHAR achBuf[100];
                wsprintfA(achBuf, "MSHTMLEd::2D-Move Event Point at Start:: ( %d , %d ) \r\n", ptSnap.x, ptSnap.y);
                OutputDebugStringA(achBuf);
            }
#endif 

    IFC( EdUtil::GetClientOrigin( GetEditor(), GetControlElement(0), &ptOrigin) );

    ptSnap.x -= ptOrigin.x ;
    ptSnap.y -= ptOrigin.y ;

    // don't let the point go out of document, 
    // position the point at the edges of the final possible rect corners
    if ( !PtInRect(&_rcClipMouse,ptSnap) )
    {   
        if (ptSnap.x < _rcClipMouse.left )
            ptSnap.x = _rcClipMouse.left;
        else if (ptSnap.x > _rcClipMouse.right)
            ptSnap.x = _rcClipMouse.right;
        
        if (ptSnap.y < _rcClipMouse.top)
            ptSnap.y = _rcClipMouse.top;
        else if (ptSnap.y > _rcClipMouse.bottom)
            ptSnap.y = _rcClipMouse.bottom;
    }
    
    if (ptSnap.x != _startMouseX || ptSnap.y != _startMouseY)
    {
        RECT rcTemp;

        ptOffset.x =  ptSnap.x - _startMouseX;
        ptOffset.y =  ptSnap.y - _startMouseY;      

        ::SetRect(&rcTemp, _rcRange.left   + ptOffset.x, 
                           _rcRange.top    + ptOffset.y, 
                           _rcRange.right  + ptOffset.x, 
                           _rcRange.bottom + ptOffset.y);

        // this is important for the plane not to get out of the document.
        if ((rcTemp.left  <= _rcClipMouse.left && ptOffset.x < 0)  || 
            (rcTemp.right >= _rcClipMouse.right && ptOffset.x > 0))
              ptOffset.x = 0 ;
        if ((rcTemp.top    <= _rcClipMouse.top  && ptOffset.y < 0) || 
            (rcTemp.bottom >= _rcClipMouse.bottom && ptOffset.y > 0))
                ptOffset.y = 0 ;

        if (ptOffset.x != 0 || ptOffset.y != 0)
        {
            ScrollPointIntoView(&ptSnap);
        
            Live2DMove(ptOffset);

            ::SetRect(&_rcRange, _rcRange.left + ptOffset.x, 
                                 _rcRange.top  + ptOffset.y, 
                                 _rcRange.right + ptOffset.x, 
                                 _rcRange.bottom + ptOffset.y);

            _startMouseX = ptSnap.x;
            _startMouseY = ptSnap.y;            

            Refresh();
        }
    }      
    
Cleanup:
    RRETURN1( hr , S_FALSE );
}

VOID
CControlTracker::ScrollPointIntoView(POINT* ptSnap)
{
    RECT rect;

    rect.left   = ptSnap->x - SCROLL_SIZE;
    rect.top    = ptSnap->y - SCROLL_SIZE;
    rect.right  = ptSnap->x + SCROLL_SIZE;
    rect.bottom = ptSnap->y + SCROLL_SIZE;
    
    IGNORE_HR( GetDisplayServices()->ScrollRectIntoView( _pManager->GetEditableElement(), rect) );
}

//+====================================================================================
//
// Method: Live2DMove
//
// Synopsis: live updation of position while moving the object in 2D Fashion
//-------------------------------------------------------------------------------------

HRESULT 
CControlTracker::Live2DMove(POINT ptDisplace)
{
    HRESULT  hr = S_OK;
     
    for (int i = 0 ; i < NumberOfSelectedItems(); i++)
    {
        Assert( IsElementPositioned( GetControlElement(i) ));

        if (_aryGrabAdorners[i]->GetPositionChange())
        {
            RECT    *pMoveRect = GetMoveRect(i);    // Where the element would be had no snapping occured
            RECT    snapRect;                       // Where the element should be snapped to
            POINT   point;
            int     nWidth = 0 , nHeight = 0;  
            
            CEdUnits edUnit(GetEditor()->GetCssEditingLevel()) ;

            //
            // Get the width and height of our element
            //
            nWidth  =  (pMoveRect->right - pMoveRect->left) ;
            nHeight =  (pMoveRect->bottom - pMoveRect->top) ;

            //
            // Construct our snapping rectangle.  This is the rectangle where the element WOULD BE
            // had no snapping occurred.  This rectangle is stored in _aryMoveRects and is updated
            // everytime a move occurs
            //
            snapRect.left   = pMoveRect->left + ptDisplace.x;
            snapRect.top    = pMoveRect->top  + ptDisplace.y;
            snapRect.right  = snapRect.left + nWidth;
            snapRect.bottom = snapRect.top  + nHeight;

            //
            // Update our moved rect. This is where the element would be had no snapping occurred
            //
            pMoveRect->left = snapRect.left;
            pMoveRect->top = snapRect.top;
            pMoveRect->right = snapRect.right;
            pMoveRect->bottom = snapRect.bottom;
            
            //
            // Snap the rect, and update our element.
            //
            SnapRect(GetControlElement(i), &snapRect, ELEMENT_CORNER_NONE);

            point.x = snapRect.left;
            point.y = snapRect.top;

            IFC (edUnit.SetLeft(GetControlElement(i), point.x));
            IFC (edUnit.SetTop (GetControlElement(i), point.y));
        }
        FireOnMove(GetControlElement(i),_pManager->IsContextEditable());   
   }
  
Cleanup:
    RRETURN1( hr , S_FALSE );
}

//+====================================================================================
//
// Method: End2DMove
//
// Synopsis: End Moving the object in 2D Fashion
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::End2DMove()
{
    HRESULT hr = S_OK;

    SetRect(&_rcRange, 0,0,0,0);

    Assert ( _pManager->IsInCapture() );
    ReleaseCapture();
    
    for (int i = 0; i < NumberOfSelectedItems(); i++)
        _aryGrabAdorners[i]->SetPositionChange(TRUE);
    
    if(_pUndoUnit)
    {
        delete _pUndoUnit;
        _pUndoUnit = NULL;
    } 
    FireOnAllElements(FireOnMoveEnd);

    RRETURN (hr);
}

/////////////////////////////////
// Forceful refresh of screen
/////////////////////////////////

VOID
CControlTracker::Refresh()
{
    HWND myHwnd = NULL;
    SP_IOleWindow spOleWindow;

    IGNORE_HR(_pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if (spOleWindow)
        IGNORE_HR(spOleWindow->GetWindow( &myHwnd ));

    ::RedrawWindow( myHwnd ,NULL,NULL,RDW_UPDATENOW);
}

//+====================================================================================
//
// Method: DoDrag
//
// Synopsis: Let Trident do it's dragging. If we fail - set _fMouseUP so we don't begin 
//           dragging again.
//
//------------------------------------------------------------------------------------

 HRESULT
CControlTracker::DoDrag()
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement3    spElement3;
    VARIANT_BOOL        fRet;
    CSelectionManager*  pManager = _pManager;
    CControlTracker*    pTracker = this;
    CEdUndoHelper       undoDrag(GetEditor());
    
    IFC( undoDrag.Begin(IDS_EDUNDOMOVE) );
    spElement = GetControlElement(0);
    if (!spElement)
        goto Cleanup;

    IFC(spElement->QueryInterface(IID_IHTMLElement3, (void**)&spElement3));

    IGNORE_HR( GetSelectionManager()->FirePreDrag() );

    IFC(spElement3->dragDrop(&fRet));
    if (!fRet)
    {
        SP_IHTMLElement2    spElement2;
        SP_IOleWindow       spOleWindow;
        HWND                hwnd;
        RECT                windowRect;
        RECT                rectBlock;

        //  Drag drop failed.  We need to scroll back to the original drag element.  It has already
        //  been selected in drag code.  First check to see if we need to scroll.

        //
        // 1) Get the visible window
        //
        IFC( GetSelectionManager()->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow) );
        IFC( spOleWindow->GetWindow(&hwnd) );
        GetEditor()->GetWindowRect( hwnd, &windowRect );

        //
        // 2) See if a scrolling is necessary
        //
        IFC( spElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&spElement2) );
        Assert(!(spElement2 == NULL));
        IFC( GetEditor()->GetBoundingClientRect(spElement2, &rectBlock) );

        if ( ShouldScrollIntoView(hwnd, &rectBlock, &windowRect) )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BOOL;
            V_BOOL(&v) = VARIANT_TRUE;

            hr = spElement->scrollIntoView(v);
            VariantClear(&v);
        }
    }

    hr = fRet ? S_OK : S_FALSE;
    
Cleanup:
    if ( ( hr == S_FALSE || 
           pManager->HasSameTracker(pTracker)) &&
         ! ( IsDormant()) )
    {
        //
        // The Drag failed. So we go back to the passive state.
        //
        SetState( CT_PASSIVE );
    }

    RRETURN1( hr , S_FALSE );
}

//+====================================================================================
//
// Method: Resize Element
//
// Synopsis: Resize a given IHTMLElement - given the new Rect size 
//           Note that the Rect is the 
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::ResizeElement(RECT& newRect, IHTMLElement* pIElement)
{
    HRESULT        hr = S_OK;
    CEdUnits       edUnit(GetEditor()->GetCssEditingLevel()) ;
    LONG           lNewHeight, lNewWidth ;
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    VARIANT vtLeft, vtTop;
    
    VariantInit( & vtTop );
    VariantInit( & vtLeft );
    
    // pass global coordinates only to snaprect (chandras)
    SnapRect(pIElement, &newRect, _elemHandle);

    // (chandras) : left, top makes sense only when the element is positioned,
    // try to change the values when the element is resized at top or left
    // 
    if (IsElementPositioned( pIElement))
    {
        SP_IHTMLStyle spStyle;
        BOOL fAbsolute = FALSE;

        IFC( EdUtil::Is2DElement(pIElement, &fAbsolute)) ;
        IFC( pIElement->get_style( &spStyle ));
        IFC( spStyle->get_left( & vtLeft ));
        IFC( spStyle->get_top( & vtTop ));

        Assert ( V_VT( & vtTop ) == VT_BSTR && V_VT( & vtLeft ) == VT_BSTR );

        //
        // Per Access PM we are going to set Left and Top on resize
        // only if the Left *and* the Top attributes are set
        //    
        if (( V_BSTR( & vtLeft ) != NULL &&  V_BSTR( & vtTop )  != NULL ))
        {
            POINT point;
            point.x = newRect.left ;
            point.y = newRect.top;

            //  point needs to be in global coordinates because we need to compare
            //  it to the offset we obtain from EdUtil::GetOffsetTopLeft() in
            //  CEdUnits::AdjustLeftDimensions() and CEdUnits::AdjustTopDimensions().
            //  We'll take this difference and add it to the current left and/or top
            //  position of the element.

            if ( _elemHandle == ELEMENT_CORNER_LEFT       ||
                 _elemHandle == ELEMENT_CORNER_TOPLEFT    ||
                 _elemHandle == ELEMENT_CORNER_BOTTOMLEFT  )
            {            
                edUnit.Clear(); // we intend to use this again, so clear it.
                IFC (edUnit.SetLeft(pIElement,point.x));
            }
    
            if ( _elemHandle == ELEMENT_CORNER_TOP     ||
                 _elemHandle == ELEMENT_CORNER_TOPLEFT ||
                 _elemHandle == ELEMENT_CORNER_TOPRIGHT )  
            {
                edUnit.Clear(); // we intend to use this again, so clear it.
                IFC (edUnit.SetTop (pIElement, point.y)); 
            }
        }
    }

    IFC( GetMarkupServices()->GetElementTagId(pIElement, & eTag ));   

    // set the new width preserving units
    lNewWidth = abs(newRect.right - newRect.left);
    edUnit.Clear(); // we intend to use this again, so clear it. 
    IFC(edUnit.SetWidth(pIElement, lNewWidth, eTag)); 

    // 
    // set the new height preserving units, but Don't attempt to resize drop down lists
    //
    if( IsDropDownList( pIElement ) )
        goto Cleanup;
    
    lNewHeight = abs(newRect.bottom - newRect.top) ;
    edUnit.Clear(); // we intend to use this again, so clear it. 
    IFC( edUnit.SetHeight(pIElement,lNewHeight, eTag)); 

Cleanup:
    VariantClear(&vtLeft);
    VariantClear(&vtTop);
    RRETURN ( hr );
}

//-----------------------------------------------------------------------------
//
// Method: EndResize
//
// Synopsis: End the Resize Change to the element : can get fired to terminate the resize
//
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::EndResize( POINT point )
{
    HRESULT hr = S_OK;
    RECT    newRect;
    BOOL    fResize = FALSE;

    _fInEndResize = TRUE;
    
    //
    // marka - per brettt - dont have a threshold - just don't resize if the point didn't move.
    //
    fResize = ( point.x != _startLastMoveX ) || 
              ( point.y != _startLastMoveY) ;
          
    for(int i = _aryGrabAdorners.Size()-1; i >= 0; i--)
    {
        _aryGrabAdorners[i]->EndResize( point, & newRect );
        if ( fResize && !_fClipMouse )
        {
            IFC( ResizeElement( newRect, GetControlElement(i)));
        }
        FireOnResizeEnd(GetControlElement(i),_pManager->IsContextEditable());
    }

    _elemHandle = ELEMENT_CORNER_NONE;

Cleanup:
    _fInEndResize = FALSE;
    _fClipMouse = FALSE;
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: CommitResize
//
// Synopsis: Commit the Resize Change to the element
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::CommitResize( CEditEvent* pEvent )
{
    HRESULT        hr = S_OK;
    CEdUndoHelper  undoUnit(_pManager->GetEditor());
    POINT          ptSnap;
    
    IFC( pEvent->GetPoint( & ptSnap ));

    Assert ( _pManager->IsInCapture() );
    ReleaseCapture();

    IGNORE_HR( undoUnit.Begin(IDS_EDUNDORESIZE) );

    IFC(EndResize(ptSnap));
    
Cleanup:
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: CommitLiveResize
//
// Synopsis: Commit the Live Resize Change to the element
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::CommitLiveResize( CEditEvent* pEvent )
{
    HRESULT        hr = S_OK;
    POINT          ptSnap;

    IFC( pEvent->GetPoint( & ptSnap ));

    Assert ( _pManager->IsInCapture() );
    ReleaseCapture();

    IFC(EndResize(ptSnap));
    
Cleanup:
    if(_pUndoUnit)
    {
        delete _pUndoUnit;
        _pUndoUnit = NULL;
    } 
    RRETURN ( hr );
}

// 
//
// Privates & Utils
//
//

//+====================================================================================
//
// Method: ShouldGoUIActiveOnFirstClick
//
// Synopsis: See if the element we clicked on should go UI Active Immediately. This happens
//          
//
//------------------------------------------------------------------------------------

BOOL
CControlTracker::ShouldGoUIActiveOnFirstClick(
                        IHTMLElement*  pIElement, 
                        ELEMENT_TAG_ID eTag)
{
    ELEMENT_TAG_ID eControlTag = TAGID_NULL;
    BOOL   fActivate = FALSE ;

#ifdef FORMSMODE
    if (_pManager->IsInFormsSelectionMode( pIElement))
    {
        return FALSE;
    }
#endif

    IGNORE_HR( GetMarkupServices()->GetElementTagId( GetControlElement(), & eControlTag));
    if (( eControlTag == TAGID_TABLE ) && ( eTag != TAGID_TABLE ))
            fActivate = TRUE;

    return fActivate;
}

VOID
CControlTracker::BecomeActiveOnFirstMove( CEditEvent* pEvent )
{
    SP_IHTMLElement spElement ;
    IGNORE_HR( pEvent->GetElement( &spElement));

    if (FireOnResizeStart(spElement ,_pManager->IsContextEditable()))
    {
         HRESULT hr = S_OK;

         if (GetCommandTarget()->IsLiveResize())
         {
            hr = THR( BeginLiveResize( pEvent ));
            if ( hr )
            {
                  //
                  // Start of Resize failed. Become passive.
                  //
                  SetState (CT_PASSIVE);
            }
            else
            {
                SetState( CT_LIVERESIZE  );
            }
         }
         else
         {
            hr = THR( BeginResize( pEvent ));
            if ( hr )
            {
                  //
                  // Start of Resize failed. Become passive.
                  //
                  SetState( CT_PASSIVE );
            }
            else
            {   
                  SetState( CT_RESIZE );
            }
         }
    }
}

HRESULT
CControlTracker::CreateAdorner(IHTMLElement* pIControlElement)
{
    HRESULT hr = S_OK;
    BOOL fLocked = IsElementLocked();
    //
    // For Control Selection - it is possible to select something at browse time
    // but not show any grab handles.
    //
    IHTMLDocument2* pDoc = _pManager->GetDoc();
    CGrabHandleAdorner* pNewAdorner;

    if ( EdUtil::IsParentEditable( GetMarkupServices(), pIControlElement) == S_OK )
    {
        ELEMENT_TAG_ID eTag = TAGID_NULL;

        _pManager->GetMarkupServices()->GetElementTagId(pIControlElement, &eTag);

        pNewAdorner = new CGrabHandleAdorner( pIControlElement , pDoc, fLocked);
    }
    else
    {
        pNewAdorner = new CSelectedControlAdorner( pIControlElement , pDoc, fLocked );
    }
    if (pNewAdorner == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }


    pNewAdorner->SetManager( _pManager );

    IFC( pNewAdorner->CreateAdorner() );
    IFC( _aryGrabAdorners.Append(pNewAdorner) );

    pNewAdorner->AddRef();

Cleanup:
    RRETURN ( hr );
}

VOID
CControlTracker::DestroyAllAdorners()
{
    CGrabHandleAdorner* pAdorner;

    for(int i = _aryGrabAdorners.Size()-1; i >=0 ; i--)
    {
        pAdorner =  _aryGrabAdorners.Item(i);
        pAdorner->DestroyAdorner();
        pAdorner->Release();
    }

    _aryGrabAdorners.DeleteAll();
}

//+====================================================================================
//
// Method: DestroyAdorner
//
// Synopsis: Destroy the adorner at the given index
//
//------------------------------------------------------------------------------------

VOID
CControlTracker::DestroyAdorner( int iIndex , BOOL* pfPrimary )
{
    CGrabHandleAdorner* pAdorner;

    pAdorner = _aryGrabAdorners.Item(iIndex);
    *pfPrimary = pAdorner->IsPrimary();

    pAdorner->DestroyAdorner();
    pAdorner->Release();

    _aryGrabAdorners.Delete(iIndex);
}

//+====================================================================================
//
// Method: IsElementLocked
//
// Synopsis: Is the Control Element Locked ?
//
//------------------------------------------------------------------------------------

BOOL
CControlTracker::IsElementLocked()
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;

    hr = THR( GetEditor()->IsElementLocked( GetControlElement(0) , &fLocked ));

    return fLocked;
}

//+====================================================================================
//
// Method: BecomeActive
//
// Synopsis: We are actively dragging a control handle, we are in an "Active State".
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::BeginResize( CEditEvent* pEvent )
{
    int i;
    USHORT adj;
    HRESULT hr = S_OK;
    int     iSel = 0;
    POINT   pt;
    SP_IHTMLElement spElementClicked;
    
    IFC( pEvent->GetPoint( & pt ));

    IFC (TakeCapture());
    
    _startLastMoveX = pt.x;
    _startLastMoveY = pt.y;

    Assert(NULL == _pUndoUnit);

    //
    // Adjust what the primary is
    //
    IFC( GetSiteSelectableElementFromMessage( pEvent , & spElementClicked));    
    hr = IsSelected( spElementClicked, & iSel );
    AssertSz( hr == S_OK , "Element is not selected. How are you resizing it ?");
    if ( hr )
        goto Cleanup;

    if ( iSel != PrimaryAdorner() )
    {
        IFC( MakePrimary( iSel ));
    }
    
    // Start from the primary element
    i = PrimaryAdorner() ;
    Assert( _aryGrabAdorners[i]->IsPrimary());

   _aryGrabAdorners[iSel]->BeginResize(pt, CT_ADJ_NONE ) ;

    _elemHandle = GetElementCorner(pEvent) ;

    ClipMouseForElementCorner(  _aryControlElements[iSel]->pIElement , _elemHandle );

    // Get its adjustment mask
    adj = _aryGrabAdorners[iSel]->GetAdjustmentMask();

    for(i = 0; i < _aryGrabAdorners.Size() ; i++ )
    {    // Resize the remaining elements using primary's adjustment mask
        if ( i != iSel )
        {
            _aryGrabAdorners[i]->BeginResize(pt, adj ) ;
        }            
    }

Cleanup:
    RRETURN( hr );    
}

HRESULT
CControlTracker::ClipMouseForElementCorner( IHTMLElement* pIElement,ELEMENT_CORNER eCorner )
{
    HRESULT hr = S_OK;
    RECT  rect, screenRect ;
    SP_IHTMLElement2 spElement2, spBodyElement2;
    SP_IHTMLElement spBodyElement ;

    IFC( pIElement->QueryInterface( IID_IHTMLElement2, (void**) & spElement2 ));
    
    IFC( GetEditor()->GetBoundingClientRect( spElement2, & rect ));

    IFC (GetEditor()->GetBody(&spBodyElement));
    Assert (spBodyElement != NULL) ;

    IFC( spBodyElement->QueryInterface( IID_IHTMLElement2, (void**) & spBodyElement2 ));
    IFC( GetEditor()->GetBoundingClientRect( spBodyElement2, & screenRect ));

    switch( eCorner )
    {
        case ELEMENT_CORNER_TOP: 
            screenRect.bottom = rect.bottom ;
            break;
            
        case ELEMENT_CORNER_TOPRIGHT:
            screenRect.bottom = rect.bottom ;        
            screenRect.left = rect.left;
            break;
            
        case ELEMENT_CORNER_LEFT:
            screenRect.right = rect.right ;
            break;
            
        case ELEMENT_CORNER_TOPLEFT:
            screenRect.right = rect.right ;
            screenRect.bottom = rect.bottom ;
            break;

        case ELEMENT_CORNER_RIGHT:
            screenRect.left = rect.left;
            break;
            
        case ELEMENT_CORNER_BOTTOM:
            screenRect.top = rect.top;
            break;
                    
        case ELEMENT_CORNER_BOTTOMLEFT:
            screenRect.top = rect.top ;
            screenRect.right = rect.right ;
            break;
            
        case ELEMENT_CORNER_BOTTOMRIGHT :
            screenRect.top = rect.top ;
            screenRect.left = rect.left ;
            break;

        default:
            AssertSz(0,"unexpected corner");
    }
    
    _rcClipMouse = screenRect;

    _fClipMouse = FALSE;
        
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: BeginLiveResize
//
// Synopsis: Begin the process of doing a live resize.
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::BeginLiveResize(CEditEvent* pEvent)
{
    int i;
    USHORT adj;
    HRESULT hr = S_OK;
    int     iSel = 0;
    SP_IHTMLElement spElementClicked;
    POINT   pt;

    IFC( pEvent->GetPoint( & pt ));
    
    IFC(TakeCapture());

    _startLastMoveX = pt.x;
    _startLastMoveY = pt.y;
     
    Assert(NULL == _pUndoUnit);

    _pUndoUnit = new CEdUndoHelper(_pManager->GetEditor());
    if(NULL == _pUndoUnit)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _pUndoUnit->Begin(IDS_EDUNDORESIZE);

    //
    // Adjust what the primary is
    //
    IFC( GetSiteSelectableElementFromMessage( pEvent, & spElementClicked ));    
    hr = IsSelected( spElementClicked, & iSel );
    AssertSz( hr == S_OK , "Element is not selected. How are you resizing it ?");
    if ( hr )
        goto Cleanup;

    if ( iSel != PrimaryAdorner() )
    {
        IFC( MakePrimary( iSel ));
    }
    
    // Start from the primary element
    i = PrimaryAdorner() ;
    Assert( _aryGrabAdorners[i]->IsPrimary());

    _aryGrabAdorners[iSel]->BeginResize(pt, CT_ADJ_NONE ) ;
    _elemHandle = GetElementCorner(pEvent);

    IFC( ClipMouseForElementCorner( _aryControlElements[iSel]->pIElement, _elemHandle ));

    // Get its adjustment mask
    adj = _aryGrabAdorners[iSel]->GetAdjustmentMask();

    for(i = 0; i < _aryGrabAdorners.Size() ; i++ )
    {    // Resize the remaining elements using primary's adjustment mask
        if ( i != iSel )
        {
            _aryGrabAdorners[i]->BeginResize(pt, adj ) ;
        }            
    }

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: Unselect
//
// Synopsis: Remove our element from being selected. ASSUME ONLY ONE ELEMENT (not true in VS7)
//
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::UnSelect()
{
    HRESULT           hr = S_OK;
    CONTROL_ELEMENT **pceElem = NULL;
    int             i;
    
    // Iterate thru all of our elements, and unselect each one
    for( i = NumberOfSelectedItems(), pceElem = _aryControlElements;
         i > 0;
         i--, pceElem++ )
    {
        IFC( GetSelectionServices()->RemoveSegment( (*pceElem)->pISegment ) );
        ReleaseInterface( (*pceElem)->pISegment );

        (*pceElem)->pIElementStart->Release();
        (*pceElem)->pIElement->Release();

        delete *pceElem;
        
    }

    _aryControlElements.DeleteAll();

    DestroyAllAdorners();   

Cleanup:
    RRETURN ( hr );
}

HRESULT
CControlTracker::BecomeUIActive(  CEditEvent* pEvent )
{
    HRESULT        hr = S_OK;
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    BOOL           fOldActiveControl = _fActiveControl;
    CHTMLEditEvent* pFirstEvent = NULL;
    CHTMLEditEvent* pNextEvent = NULL;
    SP_IHTMLElement spControlElement;
    CSelectionChangeCounter selCounter(_pManager);
    BOOL fSucceed = TRUE ;
    
    //
    // BecomeDormant destroys these cached messages - so we copy construct new ones
    // and bubble if necessary
    //
    BOOL fBubbleFirstEvent = _pFirstEvent != NULL ;
    BOOL fBubbleNextEvent  = _pNextEvent != NULL ;

    // Make sure to stop the timer if it's been started.  We may switch CDoc here and
    // we won't be able to stop the timer after that and we'll continue to get timer
    // events.
    if (_pManager->IsInTimer())
        StopTimer();

    if ( fBubbleFirstEvent )
    {
        pFirstEvent = new CHTMLEditEvent ( DYNCAST( CHTMLEditEvent, _pFirstEvent ));
    }

    if ( fBubbleNextEvent )
    {
        pNextEvent = new CHTMLEditEvent ( DYNCAST( CHTMLEditEvent, _pNextEvent ));
    }        

    _pManager->SetDontFireEditFocus(TRUE);

    spControlElement = GetControlElement();

    if ( GetEditor()->IsMasterElement( spControlElement) == S_OK )
    {
        SP_IMarkupPointer spStart, spEnd;

        IFC( GetEditor()->CreateMarkupPointer( & spStart ));
        IFC( GetEditor()->CreateMarkupPointer( & spEnd ));
        
        IFC( PositionPointersInMaster( spControlElement, spStart, spEnd  ));

        IFC( spStart->CurrentScope( & spControlElement ));
    }

    IFC( GetMarkupServices()->GetElementTagId( spControlElement , & eTag ));
    _fActiveControl = ( eTag == TAGID_OBJECT );

    selCounter.BeginSelectionChange();
    
    if (S_OK != BecomeCurrent(  _pManager->GetDoc(), spControlElement ))
    {
        fSucceed = FALSE;
        SetState( CT_PASSIVE );
        _fActiveControl = fOldActiveControl;
        delete _pFirstEvent;
        _pFirstEvent = NULL;
        delete _pNextEvent;
        _pNextEvent = NULL;
    }
    else if ( IsDormant() )
    {
        if ( fBubbleFirstEvent )
        {
            IFC( _pManager->HandleEvent( pFirstEvent ));    
        }
        if ( fBubbleNextEvent )
        {
            IFC( _pManager->HandleEvent( pNextEvent ));    
        }
    }
    else
    {
        fSucceed = FALSE;
        SetState( CT_PASSIVE );
        delete _pFirstEvent;
        _pFirstEvent = NULL;
        delete _pNextEvent;
        _pNextEvent = NULL;
    }

    selCounter.EndSelectionChange( fSucceed );
    
Cleanup:     
    _pManager->SetDontFireEditFocus(FALSE);
    
    delete pFirstEvent;
    delete pNextEvent;
    RRETURN1 ( hr, S_FALSE );
}


VOID 
CControlTracker::SetDrawAdorners( BOOL fDrawAdorner )
{
    CGrabHandleAdorner* pAdorner = NULL;
    
    for(int i = _aryGrabAdorners.Size()-1; i >=0 ; i--)
    {
        pAdorner =  _aryGrabAdorners.Item(i);
        pAdorner->SetDrawAdorner( fDrawAdorner );
    }
}

//+====================================================================================
//
// Method: IsThisElementSiteSelectable
//
// Synopsis: Check to see if this particular element is SiteSelectable or not.
//
//------------------------------------------------------------------------------------


BOOL
CControlTracker::IsThisElementSiteSelectable( 
                        CSelectionManager * pManager,
                        ELEMENT_TAG_ID eTag, 
                        IHTMLElement* pIElement)
{
    BOOL  fSiteSelectable = FALSE;
#if 0
    if ( IsParentEditable( pManager->GetMarkupServices(), pIElement) == S_FALSE )
        return FALSE;
#endif

    fSiteSelectable = IsSiteSelectable( eTag ) ;
                      
    if ( ! fSiteSelectable && ! IsTablePart( eTag ) && eTag != TAGID_BODY && eTag != TAGID_FRAMESET )
    {
        //
        // If the element has layout - then 
        //
        fSiteSelectable = (IsLayout( pIElement ) == S_OK ) ;  // removed the elementpositioned check : 82961 (chandras)
    }           

    return fSiteSelectable;
}

//+====================================================================================
//
// Method:ShouldClickInsideGoActive
//
// Synopsis: Certain elements allow grab handles - but don't go UI Active, and handles
//           don't go away when you click inside. eg. Image.
//
//------------------------------------------------------------------------------------

BOOL
CControlTracker::ShouldClickInsideGoActive(IHTMLElement* pIElement )
{
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    BOOL fActivate = TRUE ;

#ifdef FORMSMODE
    if (_pManager->IsInFormsSelectionMode(pIElement))
    {
        fActivate = FALSE;
    }
    else 
#endif
    if (SUCCEEDED( GetMarkupServices()->GetElementTagId( pIElement, & eTag )))
    {
        switch( eTag )
        {
            case TAGID_IMG:
            case TAGID_TABLE:
            case TAGID_HR:
                fActivate = FALSE;
                break;
            
            case TAGID_INPUT:
                {
                    SP_IHTMLInputElement spInputElement ;
                    BSTR bstrType = NULL;
    
                    //
                    // for input's of type= image, or type=button - we don't want to make UI activable
                    //               
                    if ( S_OK == THR(pIElement->QueryInterface( IID_IHTMLInputElement,(void**)&spInputElement )) && 
                         S_OK == THR(spInputElement->get_type(&bstrType)))
                    {                    
                        if (!StrCmpIC(bstrType, TEXT("image")))
                        {
                            fActivate = FALSE;
                        }                
                    }
                }
                break;
        }
    }   
    
    return fActivate;
}

//+====================================================================================
//
// Method: IsSiteSelectable
//
// Synopsis: Is this element site selectable or not.
//
//------------------------------------------------------------------------------------

BOOL 
CControlTracker::IsSiteSelectable( ELEMENT_TAG_ID eTag )
{
    switch ( eTag )
    {
        case TAGID_BUTTON:
        case TAGID_INPUT:
        case TAGID_OBJECT:
        case TAGID_MARQUEE:
//      case TAGID_HTMLAREA:
        case TAGID_TEXTAREA:
        case TAGID_IMG:
        case TAGID_APPLET:
        case TAGID_TABLE:
        case TAGID_SELECT:
        case TAGID_HR:
        case TAGID_OPTION:    
        case TAGID_IFRAME:
        case TAGID_LEGEND:
        
            return TRUE;

        default:

            return FALSE;
    }    
}

//+====================================================================================
//
// Method: GetSiteSelectableElementFromMessage
//
// Synopsis: Get the Site Selectable Element from the message I have.
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::GetSiteSelectableElementFromMessage( 
                        CEditEvent*    pEvent,
                        IHTMLElement** ppISiteSelectable  )
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID  eTag = TAGID_NULL;

    IFC( pEvent->GetElementAndTagId( & spElement, & eTag ));
    
    hr = IsElementSiteSelectable( eTag ,
                                  spElement,
                                  NULL,
                                  ppISiteSelectable ,
                                  TRUE ) ? S_OK : S_FALSE;
                                  
Cleanup:    
    RRETURN1( hr, S_FALSE );
}


//+====================================================================================
//
// Method: GetSiteSelectableElementFromMessage
//
// Synopsis: Get the Site Selectable Element from the message I have.
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::GetSiteSelectableElementFromElement( 
                        IHTMLElement* pIElement,
                        IHTMLElement** ppISiteSelectable  )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID eTag = TAGID_NULL;

    IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));
    
    hr = IsElementSiteSelectable( eTag ,
                                  pIElement,
                                  NULL,
                                  ppISiteSelectable ,
                                  TRUE ) ? S_OK : S_FALSE;
                                  
Cleanup:    
    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method: IsElementSiteSelectable
//
// Synopsis: Do the work of figuring out whether we should have a control tracker,
//           and why we're doing it.
//
// Split up from ShouldStartTracker, as FindSelectedElement requires this routine as well
//
//------------------------------------------------------------------------------------

BOOL
CControlTracker::IsElementSiteSelectable( 
                        ELEMENT_TAG_ID eTag, 
                        IHTMLElement*  pIElement,
                        CControlTracker::HOW_SELECTED *peHowSelected,
                        IHTMLElement** ppIWeWouldSelectThisElement /* = NULL */,
                        BOOL           fSelectTablesFromTableParts /* = FALSE*/)
{
    HRESULT hr = S_OK;
    
    BOOL                    fShouldStart = FALSE;
    CControlTracker::HOW_SELECTED eHow =  CControlTracker::HS_NONE ;
    SP_IHTMLElement         spSelectThisElement;
    SP_IHTMLElement         spMasterElement;
    IHTMLElement           *pIOuterElement = NULL ;
    ELEMENT_TAG_ID          eOuterTag = TAGID_NULL;    
    IMarkupPointer         *pTempPointer = NULL;


    fShouldStart = IsThisElementSiteSelectable( _pManager, eTag, pIElement );    
    if ( ! fShouldStart )
    {          
        IFC( _pManager->GetEditor()->CreateMarkupPointer( &pTempPointer ));
        hr = THR( pTempPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin));
        if ( hr )
        {
            hr = THR( pTempPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
        }            
        IFC( GetEditor()->GetFlowElement( pTempPointer, & pIOuterElement ));
        if ( pIOuterElement )
        {                    
            IFC( GetMarkupServices()->GetElementTagId( pIOuterElement, & eOuterTag));
            fShouldStart = IsThisElementSiteSelectable( _pManager, eOuterTag, pIOuterElement );
            if ( fShouldStart )
            {
                spSelectThisElement = pIOuterElement ;            
                eHow =  CControlTracker::HS_OUTER_ELEMENT;
            }                
        }

        if ( ! fShouldStart && 
               fSelectTablesFromTableParts &&
               IsTablePart( eOuterTag ) )
        {
            SP_IHTMLElement spTableElement;
            IFC( GetEditor()->GetTableFromTablePart( pIOuterElement, & spTableElement ));

            spSelectThisElement = (IHTMLElement*) spTableElement ;            
            eHow =  CControlTracker::HS_OUTER_ELEMENT;

            fShouldStart = TRUE;
        }
    }   
    else
    {
        spSelectThisElement = pIElement ;
        eHow =  CControlTracker::HS_FROM_ELEMENT;
    }        


Cleanup:
    if ( ppIWeWouldSelectThisElement )
    {
        ReplaceInterface( ppIWeWouldSelectThisElement, (IHTMLElement*) spSelectThisElement );
    }

    ReleaseInterface (pTempPointer);
    ReleaseInterface (pIOuterElement);
    
    if ( peHowSelected )
        *peHowSelected = eHow;
    
    return fShouldStart;    
}

//+==========================================================================================
//
// Method: SnapRect
//
// Synopsis: Snap the Rectangle with host 
//
//----------------------------------------------------------------------------------------------------

void
CControlTracker::SnapRect(IHTMLElement* pIElement, RECT* rcSnap, ELEMENT_CORNER eHandle)
{
    if (GetEditor()->GetEditHost())
    {
        SP_IHTMLElement spBodyElement ;
        IGNORE_HR (GetEditor()->GetBody(&spBodyElement));
        Assert (spBodyElement != NULL) ;

        TransformRect(spBodyElement, rcSnap, COORD_SYSTEM_GLOBAL, COORD_SYSTEM_CONTENT); 
        GetEditor()->GetEditHost()->SnapRect(pIElement, rcSnap, eHandle);
        TransformRect(spBodyElement, rcSnap, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL); 

    }
}

//+==========================================================================================
//
//  Method: IsValidMove
//
// Synopsis: Check the Mouse has moved by at least _sizeDragMin - to be considered a "valid move"
//
//----------------------------------------------------------------------------------------------------

BOOL
CControlTracker::IsValidMove ( const POINT*  ppt)
{
    return ((abs(ppt->x - _startMouseX ) > GetMinDragSizeX()) ||
        (abs( ppt->y - _startMouseY) > GetMinDragSizeY() )) ;
}

//+====================================================================================
//
// Method: IsMessageOverControl
//
// Synopsis: Is the given message over the control ?
//
//------------------------------------------------------------------------------------

BOOL 
CControlTracker::IsMessageOverControl( CEditEvent* pEvent )
{
    Assert( _aryGrabAdorners[0] && pEvent );
    
    return IsInAdorner(pEvent);    
}

#if DBG == 1

VOID
CControlTracker::VerifyOkToStartControlTracker( CEditEvent* pEvent )
{
    HRESULT hr = S_OK;

    ELEMENT_TAG_ID   eTag = TAGID_NULL;
    IHTMLElement    *pElement = NULL;
    SST_RESULT       eResult = SST_NO_CHANGE;
    
    //
    // Examine the Context of the thing we started dragging in.
    //
    IFC( pEvent->GetElementAndTagId(  & pElement, & eTag ));
    ShouldStartTracker( pEvent, eTag, pElement, & eResult );
    
    Assert( eResult == SST_NO_BUBBLE || eResult == SST_NO_CHANGE ); // the control element is set. We should be saying we don't want to change or bubble.

Cleanup:
    AssertSz( ! hr , "Unexpected ResultCode in VerifyOkToStartControlTracker");
    ReleaseInterface(pElement);
}

#endif


//+====================================================================================
//
// Method: AddControlElement
//
// Synopsis:Add the element to the selection, growing the array and creating an
//          adorner as needed. The new element will be flagged and rendered
//          as the primary selection, and the element which previously was
//          flagged and rendered as such will be flagged and rendered as
//          a secondary selection.
//
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::AddControlElement( IHTMLElement* pIElement )
{
    HRESULT         hr = S_FALSE;
    CONTROL_ELEMENT *pceElement = NULL;
    SP_IMarkupPointer spPointer;

    Assert( pIElement );
    Assert( _aryGrabAdorners.Size() >= 0);

    hr = IsSelected(pIElement);
    if ( FAILED(hr) || S_OK == hr)
    {
        hr = S_FALSE; // the item is already selected
        goto Cleanup;
    }

    pceElement = new CONTROL_ELEMENT;
    if( !pceElement )
        goto Error;

    // Store the element for selection services    
    IFC( GetSelectionServices()->AddElementSegment(pIElement, &pceElement->pISegment));

    // Fill out the structure used to keep track of this control
    pceElement->pIElement = pIElement;

    // Reference count the element
    pIElement->AddRef();

    //
    // Create a ptr at start of element
    //
    IFC( GetEditor()->CreateMarkupPointer( & spPointer ));
    pceElement->pIElementStart = spPointer;
    pceElement->pIElementStart->AddRef();
    
    IFC( pceElement->pIElementStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
    IFC( pceElement->pIElementStart->SetGravity(POINTER_GRAVITY_Right));

    IFC(_aryControlElements.Append( pceElement ));

    
    // Create the adorner and flag it as the primary
    IFC( CreateAdorner( pIElement ));

    //
    // First Element is primary. 
    //
    SetPrimary( _aryGrabAdorners.Size()-1 , _aryGrabAdorners.Size() == 1 ? TRUE : FALSE );
        
    Assert( NumberOfSelectedItems() == _aryGrabAdorners.Size());

    // We are initiating a site selection.  We need to call notify begin selection
    // so that other trident instances can tear down their selection.
    
    if (NumberOfSelectedItems() == 1)
    {
        IFC( _pManager->NotifyBeginSelection( START_SITE_SELECTION ) );
    }    

Cleanup:  
    return hr;

Error:
    return E_OUTOFMEMORY;
}

HRESULT
CControlTracker::RemoveItem( int nIndex )
{
    HRESULT          hr = S_OK;
    BOOL             fPrimary = FALSE;
    CONTROL_ELEMENT *pceElement = NULL;

    Assert( nIndex >= 0 && nIndex < NumberOfSelectedItems() );
    
    // Delete our copy of the control
    pceElement = _aryControlElements.Item(nIndex);
    
    // Delete segment
    GetSelectionServices()->RemoveSegment( pceElement->pISegment );
    ReleaseInterface( pceElement->pISegment );

    Assert( pceElement != NULL );
    
    pceElement->pIElement->Release();

    pceElement->pIElementStart->Release();
    
    delete pceElement;
    
    _aryControlElements.Delete(nIndex);

    // Delete the adorner
    DestroyAdorner( nIndex , &fPrimary );

    // See if the item flagged as the primary is being deleted

    if (fPrimary && _aryGrabAdorners.Size() > 0)
    {
        SetPrimary( _aryGrabAdorners.Size() - 1 ,TRUE);
    }

    Assert( NumberOfSelectedItems() == _aryGrabAdorners.Size());

    RRETURN( hr );
}

//+====================================================================================
//
// Method: RemoveControlElement
//
// Synopsis:Remove the element from the selection, along with its adorner. If
//          the adorner is flagged for primary selection rendering, pick and
//          flag another element to be the primary.
//
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::RemoveControlElement( IHTMLElement* pIElementToRemove )
{
    HRESULT          hr = S_OK;
    int              nIndex   = -1 ;

    IFC( IsSelected(pIElementToRemove, &nIndex));

    if(nIndex < 0)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    IFC( RemoveItem( nIndex ));
    
Cleanup:
    return hr;
}    

BOOL
CControlTracker::AllElementsEditable()
{
    int cItems = NumberOfSelectedItems();

    for(int i = 0; i < cItems; i++)
    {
        if(! _aryGrabAdorners[i]->IsEditable())
            return FALSE;
    }
    return TRUE;
}

BOOL
CControlTracker::AllElementsUnlocked()
{
    int cItems = NumberOfSelectedItems();

    for(int i = 0; i < cItems; i++)
    {
        if( _aryGrabAdorners[i]->IsLocked())
            return FALSE;
    }
    return TRUE;
}

BOOL
CControlTracker::IsInMoveArea(CEditEvent *pEvent)
{
    for(int i = _aryGrabAdorners.Size()-1; i >= 0; i--)
    {
        if( _aryGrabAdorners[i]->IsInMoveArea(pEvent))
            return TRUE;
    }
    return FALSE;
}

BOOL
CControlTracker::IsInResizeHandle(CEditEvent *pEvent)
{
    for(int i = _aryGrabAdorners.Size()-1; i >= 0; i--)
    {
        if( _aryGrabAdorners[i]->IsInResizeHandle(pEvent))
            return TRUE;
    }
    return FALSE;
}

BOOL
CControlTracker::IsInAdorner(CEditEvent *pEvent, int *pnClickedElement /* = NULL */)
{
    POINT ptGlobal;

    pEvent->GetPoint(&ptGlobal);

    return IsInAdorner(ptGlobal, pnClickedElement);
}

BOOL
CControlTracker::IsInAdorner(POINT ptGlobal, int* pnClickedElement /* = NULL */)
{
    int cItems = NumberOfSelectedItems();

    for(int i = 0; i < cItems; i++)
    {
        if( _aryGrabAdorners[i]->IsInAdornerGlobal(ptGlobal))
        {
            if(pnClickedElement)
                *pnClickedElement = i;
            return TRUE;
        }
    }

    return FALSE;
}

//+====================================================================================
//
// Method: IsSelected
//
// Synopsis: Is this element selected ? 
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::IsSelected(IHTMLElement* pIElement, int* pnIndex /* = NULL */)
{
    IObjectIdentity *pIdent = NULL ;
    int i ;
    HRESULT  hr ;
    if (pnIndex)
        *pnIndex = -1;

    hr = S_FALSE ;
    for(i = NumberOfSelectedItems()-1; i >= 0; i--)
    {
        IFC(GetControlElement(i)->QueryInterface(IID_IObjectIdentity, (void**)&pIdent ));

        if ( pIdent->IsEqualObject ( pIElement ) == S_OK )
        {
            if(pnIndex)
                *pnIndex = i;
            
            hr = S_OK;
            goto Cleanup;

        }
        ClearInterface(&pIdent);
    }
    hr = S_FALSE ;

Cleanup:
    ReleaseInterface(pIdent);
    return hr;
}

HRESULT
CControlTracker::IsSelected(IMarkupPointer * pIPointer, int* pnIndex /* = NULL */)
{
    int i ;
    HRESULT  hr ;
    BOOL fEqual;
    if (pnIndex)
        *pnIndex = -1;

    for(i = NumberOfSelectedItems()-1; i >= 0; i--)
    {
        IFC( _aryControlElements[i]->pIElementStart->IsEqualTo( pIPointer, & fEqual ));
        if ( fEqual )
        {
            if(pnIndex)
                *pnIndex = i;
            
            hr = S_OK;
            goto Cleanup;
        }
    }
    hr = S_FALSE ;

Cleanup:
    return hr;
}

//+====================================================================================
//
// Method: PrimaryAdorner
//
// Synopsis: Return the element that is the primary adorner
//
//------------------------------------------------------------------------------------

int 
CControlTracker::PrimaryAdorner()
{
    for ( int i = 0; i < _aryGrabAdorners.Size(); i ++ )
    {
        if ( _aryGrabAdorners[i]->IsPrimary())
        {
            return i;
        }
    }
    
    AssertSz(0, "No Primary Found");
    return - 1;
}


//+====================================================================================
//
// Method: MakePrimary.
//
// Synopsis: Make the Element at position iIndex the Primary. Note that the index of this
// element then changes.
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::MakePrimary(int iIndex)
{
    HRESULT hr = S_OK;
    Assert( iIndex <= _aryGrabAdorners.Size() - 1);
    Assert( iIndex >= 0 );

    SetPrimary( PrimaryAdorner(), FALSE );
    SetPrimary( iIndex, TRUE );
    
    Assert( NumberOfSelectedItems() == _aryGrabAdorners.Size());
    if ( _pPrimary )
    {
        ClearInterface( & _pPrimary );
    }

    return hr;
}

VOID
CControlTracker::SetPrimary( int iIndex, BOOL fPrimary )
{
    _aryGrabAdorners[ iIndex ]->SetPrimary( fPrimary );                
    _aryControlElements[ iIndex ]->pISegment->SetPrimary( fPrimary );
}



//+---------------------------------------------------------------------------
//
//  Member:     GetAction
//
//  Synopsis: Get the Action associated with the current state for the given message
//
//----------------------------------------------------------------------------


CONTROL_ACTION 
CControlTracker::GetAction( CEditEvent* pEvent)
{
    unsigned int LastEntry = sizeof (ControlActionTable) / sizeof (ControlActionTable[0]);
    unsigned int i;
    CONTROL_ACTION Action = A_ERRCONTROL;

    Assert ( !IsDormant() );

    // Discard any spurious mouse move messages

    for (i = 0; i <= LastEntry; i++)
    {
        if ( (ControlActionTable[i]._iJMessage == pEvent->GetType() ) || ( i == LastEntry ) )
        {
            Action = ControlActionTable[i]._aAction[_state];
            break;
        }
    }
    return (Action);    
}

//+===================================================================================
// Method:      GetElementToTabFrom
//
// Synopsis:    Gets the element where we should tab from based on selection
//
//------------------------------------------------------------------------------------
HRESULT 
CControlTracker::GetElementToTabFrom(BOOL fForward, IHTMLElement **pElement, BOOL *pfFindNext)
{
    HRESULT             hr = S_OK;

#if DBG==1
    SELECTION_TYPE      eType;
    SP_ISegmentList     spList;
    BOOL                fEmpty;
    
    IFC( GetSelectionServices()->QueryInterface(IID_ISegmentList, (void **)&spList ) );
    IFC( spList->IsEmpty( &fEmpty ) );
    IFC( spList->GetType( &eType ) );

    Assert( !fEmpty && (eType == SELECTION_TYPE_Control) );
    Assert( pfFindNext );
    Assert( pElement );

#endif // DBG

    // Retrieve the primary control element
    *pElement = GetControlElement(PrimaryAdorner());
    ((IUnknown *)*pElement)->AddRef();

#if DBG==1
Cleanup:
#endif

    RRETURN( hr );
}

HRESULT
CControlTracker::StartTimer()
{
    HRESULT hr = S_OK;

    Assert( _pManager->GetActiveTracker() == this );
    Assert( ! _pManager->IsInTimer() );

    IFC(GetEditor()->StartDblClickTimer( /*GetDoubleClickTime() * 1.2 */ ));
    _pManager->SetInTimer( TRUE);

Cleanup:
    RRETURN( hr );
}

HRESULT
CControlTracker::StopTimer()
{
    HRESULT hr = S_OK;
    Assert( _pManager->GetActiveTracker() == this );
    Assert( _pManager->IsInTimer() );

    IFC(GetEditor()->StopDblClickTimer());
    _pManager->SetInTimer( FALSE );               

Cleanup:
    RRETURN( hr );
}

#if DBG == 1 || TRACKER_RETAIL_DUMP == 1

void 
CControlTracker::DumpTrackerState(
                        CEditEvent* pEvent,
                        CONTROL_STATE inOldState,
                        CONTROL_ACTION inAction )
{
    TCHAR sControlState[30];
    TCHAR sOldControlState[30];    
    CHAR  sMessageType[50];
    TCHAR sAction[32];
    CHAR  achBuf[4096];
    
    //
    // We use OutputDebugString here directly - instead of just a good ol' trace tag
    // as we want to enable logging of Tracker State in Retail as well ( if DEBUG_RETAIL_DUMP is defined )
    //   
    
    StateToString( sControlState, _state );
    StateToString( sOldControlState, inOldState );
    
    if ( pEvent)
    {
        pEvent->toString( sMessageType );
    }

    ActionToString( sAction, inAction);

    wsprintfA(
        achBuf,
        "Old State: %ls State: %ls Action:%ls Message:%s ",
        sOldControlState, sControlState,sAction, sMessageType );

    OutputDebugStringA("MSHTML trace: ");
    OutputDebugStringA(achBuf);
    OutputDebugStringA("\n");    

}

void 
CControlTracker::DumpIntermediateState(
                CEditEvent* pEvent,
                CONTROL_STATE inOldState,
                CONTROL_STATE newState )
{
    TCHAR sControlState[30];
    TCHAR sOldControlState[30];    
    CHAR sMessageType[50];
    CHAR achBuf[4096];
    
    //
    // We use OutputDebugString here directly - instead of just a good ol' trace tag
    // as we want to enable logging of Tracker State in Retail as well ( if DEBUG_RETAIL_DUMP is defined )
    //   
    
    StateToString( sControlState, newState );
    StateToString( sOldControlState, inOldState );
    
    if ( pEvent )
    {
        pEvent->toString( sMessageType );
    }

    wsprintfA(
        achBuf,
        "IntermediateState - Old State: %ls Intermediate State:%ls  Message:%s ",
        sOldControlState, sControlState,  sMessageType );

    OutputDebugStringA("MSHTML trace: ");
    OutputDebugStringA(achBuf);
    OutputDebugStringA("\n");    
}

void 
CControlTracker::StateToString(TCHAR* pAryMsg, CONTROL_STATE inState )
{
    switch ( inState )
    {
        case CT_START:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_START"));
            break;

        case CT_WAIT1:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_WAIT1"));
            break;
        
        case CT_PASSIVE:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_PASSIVE"));
            break;

        case CT_DRAGMOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_DRAGMOVE"));
            break;

        case CT_RESIZE: 
            edWsprintf( pAryMsg , _T("%s"), _T("CT_RESIZE"));
            break;
        
        case CT_LIVERESIZE: 
            edWsprintf( pAryMsg , _T("%s"), _T("CT_LIVERESIZE"));
            break;
        
        case CT_WAITMOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_WAITMOVE"));
            break;

        case CT_2DMOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_2DMOVE"));
            break;

        case CT_PENDINGUP:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_PENDINGUP"));
            break;
        
        case CT_UIACTIVATE:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_UIACTIVATE"));
            break;
        
        case CT_DORMANT: 
            edWsprintf( pAryMsg , _T("%s"), _T("CT_DORMANT"));
            break;
        
        case CT_END:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_END"));
            break;

        case CT_WAITCHANGEPRIMARY:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_WAITCHANGEPRIMARY"));
            break;
        
        case CT_CHANGEPRIMARY:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_CHANGEPRIMARY"));
            break;

        case CT_EXTENDSELECTION:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_EXTENDSELECTION"));
            break;

        case CT_REDUCESELECTION:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_REDUCESELECTION"));
            break;

        case CT_PENDINGUIACTIVATE:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_PENDINGUIACTIVATE"));
            break;
            
        default:
            AssertSz(0,"Unknown State");
    }
    
}

void 
CControlTracker::ActionToString(TCHAR* pAryMsg, CONTROL_ACTION inState )
{
    switch ( inState )
    {         
        case A_IGNCONTROL:
            edWsprintf( pAryMsg , _T("%s"), _T("A_IGNCONTROL"));
            break;
        
        case A_ERRCONTROL:
            edWsprintf( pAryMsg , _T("%s"), _T("A_ERRCONTROL"));
            break;
            
        case A_START_WAIT:
            edWsprintf( pAryMsg , _T("%s"), _T("A_START_WAIT"));
            break;
            
        case A_WAIT_MOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_WAIT_MOVE"));
            break;
            
        case A_WAIT_PASSIVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_WAIT_PASSIVE"));
            break;
            
        case A_PASSIVE_DOWN:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PASSIVE_DOWN"));
            break;
            
        case A_PASSIVE_DOUBLECLICK:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PASSIVE_DOUBLECLICK"));
            break;
                       
        case A_RESIZE_MOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_RESIZE_MOVE"));
            break;

        case A_RESIZE_PASSIVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_RESIZE_PASSIVE"));
            break;
            
        case A_LIVERESIZE_MOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_LIVERESIZE_MOVE"));
            break;

        case A_LIVERESIZE_PASSIVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_LIVERESIZE_PASSIVE"));
            break;
            
        case A_WAITMOVE_PASSIVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_WAITMOVE_PASSIVE"));
            break;
            
        case A_WAITMOVE_MOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_WAITMOVE_MOVE"));
            break;

        case A_2DMOVE_2DMOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_2DMOVE_2DMOVE"));
            break;
            
        case A_2DMOVE_PASSIVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_2DMOVE_PASSIVE"));
            break;
        case A_PENDINGUP_MOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PENDINGUP_MOVE"));
            break;
            
        case A_PENDINGUIACTIVATE_UIACTIVATE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PENDINGUIACTIVATE_UIACTIVATE"));
            break;            

        case A_PENDINGUP_PENDINGUIACTIVATE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PENDINGUP_PENDINGUIACTIVATE"));
            break;
            
        case A_PENDINGUP_END:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PENDINGUP_END"));
            break;

        case A_WAITCHANGEPRI_CHANGEPRI:
            edWsprintf( pAryMsg , _T("%s"), _T("A_WAITCHANGEPRI_CHANGEPRI"));
            break;
    
        case A_WAITCHANGEPRI_DRAGMOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_WAITCHANGEPRI_DRAGMOVE"));
            break;
                  

        case A_PASSIVE_PENDINGUIACTIVATE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PASSIVE_PENDINGUIACTIVATE"));
            break;
    
        default:
            AssertSz(0,"Unknown Action");
     }
}

#endif

VOID 
CControlTracker::SetDrillIn( BOOL fDrillIn, CEditEvent* pEvent )
{
    _pManager->SetDrillIn( fDrillIn );
    if ( pEvent )
    {
        StoreFirstEvent( DYNCAST( CHTMLEditEvent, pEvent ));
    }
    else if ( _pFirstEvent )
    {
        delete _pFirstEvent;
        _pFirstEvent = NULL;
    }
}

VOID
CControlTracker::StoreFirstEvent( CHTMLEditEvent* pEvent )
{
    Assert( !_pFirstEvent );
    _pFirstEvent = new CHTMLEditEvent( pEvent );
}

VOID
CControlTracker::StoreNextEvent( CHTMLEditEvent* pEvent )
{
    Assert( !_pNextEvent );
    _pNextEvent = new CHTMLEditEvent( pEvent );
}

#ifdef FORMSMODE
BOOL
CControlTracker::IsAnyElementInFormsMode( )
{
    for (int i = 0 ; i < _aryControlElements.Size() ; i++)
    {
        if ( _pManager->IsInFormsSelectionMode( GetControlElement(i)))
            return TRUE;
    }
   
    return FALSE;
}
#endif

VOID 
CControlTracker::SetState( CONTROL_STATE inState )
{
    Assert( ( _state == CT_DORMANT  && ( inState == CT_WAIT1 || inState == CT_PASSIVE || inState == CT_DORMANT )) 
            ||
            _state != CT_DORMANT );

    if ( inState == CT_PASSIVE && _pManager->GetActiveTracker() != this )
    {
        AssertSz(0,"Here we are");
    }
    
    _state = inState ; 
}

BOOL 
CControlTracker::FireOnAllElements(PFNCTRLWALKCALLBACK pfnCtrlWalk)
{
    for (int iCtrl = 0 ; iCtrl < _aryControlElements.Size() ; iCtrl++)
    {
        if (!pfnCtrlWalk(GetControlElement(iCtrl),_pManager->IsContextEditable()))
            break;
    }
    return (iCtrl == _aryControlElements.Size());
}

void 
CControlTracker::TransformRect(
                    IHTMLElement*  pIElement,
                    RECT *         prc,
                    COORD_SYSTEM   srcCoord,
                    COORD_SYSTEM   destCoord)
{
    POINT ptTopLeft , ptBottomRight ;
    ptTopLeft.x     = prc->left   ;
    ptTopLeft.y     = prc->top    ;
    ptBottomRight.x = prc->right  ;
    ptBottomRight.y = prc->bottom ;
    
    IGNORE_HR( GetDisplayServices()->TransformPoint( & ptTopLeft, 
                                                       srcCoord, 
                                                       destCoord, 
                                                       pIElement));

    IGNORE_HR( GetDisplayServices()->TransformPoint( & ptBottomRight, 
                                                       srcCoord, 
                                                       destCoord, 
                                                       pIElement));
    prc->left   = ptTopLeft.x     ;
    prc->top    = ptTopLeft.y     ;
    prc->right  = ptBottomRight.x ;
    prc->bottom = ptBottomRight.y ;
}

ELEMENT_CORNER
CControlTracker::GetElementCorner(CEditEvent *pEvent)
{
    for(int i = _aryGrabAdorners.Size()-1; i >= 0; i--)
    {
        if( _aryGrabAdorners[i]->IsInResizeHandle(pEvent))
            return _aryGrabAdorners[i]->GetElementCorner();
    }
    return ELEMENT_CORNER_NONE;
}

HRESULT 
CControlTracker::GetLocation(POINT *pPoint, BOOL fTranslate)
{
    HRESULT             hr = S_OK ;

    IFC( GetLocation(pPoint, ELEM_ADJ_BeforeBegin, fTranslate) );
    
Cleanup:
    RRETURN( hr );
}

HRESULT 
CControlTracker::GetLocation(POINT *pPoint,
    ELEMENT_ADJACENCY eAdj,
    BOOL fTranslate /* = TRUE */)
{
    HRESULT             hr = S_OK ;
    SP_IMarkupPointer   spMarkupPointer;
    SP_IDisplayPointer  spDisplayPointer;
    SP_ILineInfo        spLineInfo;

    //  Set a markup pointer next to our element
    IFC( GetEditor()->CreateMarkupPointer( & spMarkupPointer ) );
    IFC( spMarkupPointer->MoveAdjacentToElement( GetControlElement(0), eAdj ) );

    //  Position a display pointer at the markup position
    IFC( GetDisplayServices()->CreateDisplayPointer(& spDisplayPointer) );
    IFC( spDisplayPointer->MoveToMarkupPointer(spMarkupPointer, NULL) );

    //  Get line info for our display pointer.
    IFR( spDisplayPointer->GetLineInfo(&spLineInfo) );
    IFC( spLineInfo->get_baseLine(&pPoint->y) );
    IFC( spLineInfo->get_x(&pPoint->x) );

    if (fTranslate)
    {
        SP_IHTMLElement     spIFlowElement;
        
        //  Get the flow element so that we can transform our point to global coordinates
        IFC( spDisplayPointer->GetFlowElement( & spIFlowElement ));
        if ( ! spIFlowElement )
        {
            IFC( _pManager->GetEditableElement( & spIFlowElement));
        }

        //  Transform our point to global coordinates
        IFC( GetDisplayServices()->TransformPoint( pPoint, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL, spIFlowElement ));
    }
    
Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//  Method:     CControlTracker::EmptySelection
//
//  Synopsis:   Unselect and remove the adorners for any selected controls, 
//              while keeping the tracker active.
//
//  Arguments:  NONE
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CControlTracker::EmptySelection( BOOL fChangeTrackerAndSetRange /*=TRUE*/)
{
    if ( fChangeTrackerAndSetRange )
    {
        RRETURN( UnSelect() );
    }
    else
        return S_OK;
}

HRESULT
CControlTracker::EnableModeless( BOOL fEnable )
{
    HRESULT hr = S_OK;

    if ( ! fEnable ) // dialog is coming up. we better shut ourselves down.
    {
        hr = THR( OnLoseFocus()) ;
    }

    RRETURN( hr );
}


HRESULT 
CControlTracker::OnLoseFocus()
{
    if ( !IsPassive() )
    {            
        if ( _pManager->IsInTimer() )
            StopTimer();
        
        if ( _pManager->IsInCapture()  )
            ReleaseCapture(FALSE); // the capture change handles this for us.

        EndCurrentEvents();
        
        SetState( CT_PASSIVE );
    }

    return S_OK;
}

VOID
CControlTracker::EndCurrentEvents()
{
    switch (_state)
    {
        case CT_RESIZE:
        case CT_LIVERESIZE :
        {
            POINT ptLast ;

            if( !_fInEndResize )
            {
                ptLast.x = _startLastMoveX ;
                ptLast.y = _startLastMoveY ;

                SetState( CT_PASSIVE );
                
                EndResize(ptLast);

                if(_pUndoUnit)
                {
                    delete _pUndoUnit;
                    _pUndoUnit = NULL;
                } 
            }
        }
        break;
        
        case CT_2DMOVE:
        {     
            if(_pUndoUnit)
            {
                delete _pUndoUnit;
                _pUndoUnit = NULL;
            } 
            SetState( CT_PASSIVE );
        }    
        break;
       
        case CT_PENDINGUP:
        {
            SetDrillIn( FALSE );
            SetState( CT_PASSIVE );
        }
        break;

        case CT_PENDINGUIACTIVATE:
        {
            SetDrillIn( FALSE );
            if ( _pNextEvent )
            {
                delete _pNextEvent;
                _pNextEvent = NULL;
            }
            SetState( CT_PASSIVE );
        }
        break;
        
        default:
            SetState( CT_PASSIVE );
    }
}

BOOL
CControlTracker::FireOnControlSelect( IHTMLElement* pIElement )
{
    BOOL fReturnVal = TRUE ;

    if ( IsParentEditable( GetMarkupServices(), pIElement) == S_OK )
    {
        fReturnVal = EdUtil::FireOnControlSelect( pIElement, TRUE ) ;

        if ( ! _pManager->IsContextEditable() )
        {
            fReturnVal = FALSE;
            _pManager->EnsureDefaultTrackerPassive() ;
        }
    }

    return fReturnVal;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\edit\delcmd.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998, 1999
//
//  File:       DELCMD.CXX
//
//  Contents:   Implementation of Delete command.
//
//  History:    07-14-98 - raminh - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_BLOCKCMD_HXX_
#define X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include <wchdefs.h>
#endif

using namespace EdUtil;

//
// Externs
//

MtDefine(CDeleteCommand, EditCommand, "CDeleteCommand");


//+---------------------------------------------------------------------------
//
//  CDeleteCommand private method: IsLaunderChar( ch )
//  Is the ch a character we launder when we launder spaces?
//----------------------------------------------------------------------------

BOOL
CDeleteCommand::IsLaunderChar ( TCHAR ch )
{
    return    _T(' ')  == ch
           || _T('\t') == ch
           || WCH_NBSP == ch;
}

BOOL
CDeleteCommand::IsInPre( IMarkupPointer  * pStart, IHTMLElement ** ppPreElement )
{
    BOOL                fMatch = FALSE;
    IHTMLElement    *   pNextElement = NULL ;
    HRESULT             hr   = S_OK;
    ELEMENT_TAG_ID      eTag = TAGID_NULL ;
    IMarkupServices   * pMarkupServices = GetMarkupServices();

    IFC( pStart->CurrentScope( ppPreElement ) );
    if (! *ppPreElement)
    {
        // Scope is NULL, must be a TXTSLAVE
        return TRUE;
    }

    while ( ! fMatch && *ppPreElement )
    {
        IFC( pMarkupServices->GetElementTagId( *ppPreElement, & eTag) );

        switch ( eTag )
        {
        case TAGID_PRE :
        case TAGID_PLAINTEXT :
        case TAGID_LISTING :
        case TAGID_XMP :
        case TAGID_TEXTAREA:
        case TAGID_INPUT: 
            fMatch = TRUE;
            break;
        }

        GetEditor()->GetParentElement( (*ppPreElement), &pNextElement );
        ReplaceInterface( ppPreElement, pNextElement );
        ClearInterface( & pNextElement );
    }

Cleanup:
    if (! fMatch)
        ClearInterface( ppPreElement );
    return fMatch;
}


//+---------------------------------------------------------------------------
//
// CDeleteCommand::HasLayoutOrIsBlock()
//
// Synopsis:    Determine whether pIElement is a block element or has a layout
//
//----------------------------------------------------------------------------

BOOL
CDeleteCommand::HasLayoutOrIsBlock( IHTMLElement * pIElement )
{
    BOOL    fIsBlockElement;
    BOOL    fHasLayout;

    IGNORE_HR(IsBlockOrLayoutOrScrollable(pIElement, &fIsBlockElement, &fHasLayout));

    return( fIsBlockElement || fHasLayout );
}


//+---------------------------------------------------------------------------
//
// CDeleteCommand::IsIntrinsicControl()
//
// Synopsis:    Determine whether pIElement is an intrinsic control (including INPUT)
//
//----------------------------------------------------------------------------

BOOL
CDeleteCommand::IsIntrinsicControl( IHTMLElement * pHTMLElement )
{
    ELEMENT_TAG_ID  eTag;

    IGNORE_HR( GetMarkupServices()->GetElementTagId( pHTMLElement, & eTag) );

    switch (eTag)
    {
    case TAGID_BUTTON:
    case TAGID_TEXTAREA:
#ifdef  NEVER
    case TAGID_HTMLAREA:
#endif
    case TAGID_FIELDSET:
    case TAGID_LEGEND:
    case TAGID_MARQUEE:
    case TAGID_SELECT:
    case TAGID_INPUT:
        return TRUE;

    default:
        return FALSE;
    }
}


//+---------------------------------------------------------------------------
//
// CDeleteCommand::SkipBlanks()
//
// Synopsis: Walks pPointerToMove in the appropriate direction until a block/layout
//           tag or a non-blank character is encountered. Returns the number of
//           characters crossed.
//
//----------------------------------------------------------------------------

HRESULT
CDeleteCommand::SkipBlanks( IMarkupPointer * pPointerToMove,
                            Direction        eDir,
                            long           * pcch )
{
    HRESULT             hr = S_OK;
    IHTMLElement      * pHTMLElement = NULL;
    long                cch;
    TCHAR               pch[ TEXTCHUNK_SIZE + 1 ]; 
    MARKUP_CONTEXT_TYPE context;
    SP_IMarkupPointer   spPointer;

    Assert( pcch );
    *pcch = 0;

    IFC( GetEditor()->CreateMarkupPointer( & spPointer ) );
    IFC( spPointer->MoveToPointer( pPointerToMove ) );

    for ( ; ; )
    {
        //
        // Move in the appropriate direction
        //
        cch = TEXTCHUNK_SIZE;
        ClearInterface( & pHTMLElement );
        if (eDir == LEFT)
        {
            IFC( spPointer->Left( TRUE, & context, & pHTMLElement, & cch, pch ) );
        }
        else
        {
            IFC( spPointer->Right( TRUE, & context, & pHTMLElement, & cch, pch ) );
        }

        switch( context )
        {
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_ExitScope:
            case CONTEXT_TYPE_NoScope:
                if ( HasLayoutOrIsBlock( pHTMLElement ) || IsIntrinsicControl( pHTMLElement ) )
                {
                    // we're done
                    goto Cleanup;
                }
                break;

            case CONTEXT_TYPE_Text:
            {
                //
                // Got some fresh text, look for white space pch using
                // the appropriate direction.
                //
                TCHAR * pchStart;
                long    iOffset;

                if ( eDir == RIGHT )
                {
                    // Left to right we go from beginning of pch to the end
                    for( pchStart = pch; pchStart < ( pch + cch ); pchStart++ )
                    {
                        if (! IsLaunderChar( * pchStart ) )
                        {
                            break;
                        }
                    }
                    iOffset = (pch + cch) - pchStart;
                }
                else
                {
                    // Right to left we go the other way around
                    for( pchStart = pch + (cch - 1); pchStart >= pch; pchStart-- )
                    {
                        if (! IsLaunderChar( * pchStart ) )
                        {
                            break;
                        }
                    }
                    iOffset = (pchStart + 1) - pch;
                }

                //
                // Check the offset of blanks
                //
                if (iOffset == cch)
                {
                    // First character was non-blank, we're done
                    goto Cleanup;
                }
                else if (iOffset == 0)
                {
                    // We got text which was all white space, update pPointerToMove
                    // and continue on...
                    IFC( pPointerToMove->MoveToPointer( spPointer ) );
                    *pcch += cch;
                }
                else
                {
                    // Position the pointer back to where the white space ends
                    if (eDir == LEFT)
                    {
                        IFC( spPointer->Right( TRUE, NULL, NULL, & iOffset, NULL ) );
                    }
                    else
                    {
                        IFC( spPointer->Left( TRUE, NULL, NULL, & iOffset, NULL ) );
                    }
                    //
                    // Update pPointerToMove  and we're done
                    //
                    IFC( pPointerToMove->MoveToPointer( spPointer ) );
                    *pcch += (cch - iOffset);
                    goto Cleanup;
                }
                break;
            }

            case CONTEXT_TYPE_None:
                goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface( pHTMLElement );
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CDeleteCommand::LaunderSpaces()
//
//  Synopsis:   Replace consecutive blanks resulted from delete or paste
//              operations into a blank and &NBSP's such that the blank 
//              sequence is properly preserved.
//
//----------------------------------------------------------------------------
HRESULT
CDeleteCommand::LaunderSpaces ( IMarkupPointer    * pStart,
                                IMarkupPointer    * pEnd )
{
    const TCHAR chNBSP  = WCH_NBSP;

    HRESULT     hr = S_OK;
    long        cch;
    long        cchCurrent;
    long        cchBlanks = 0;
    DWORD       dwBreak;
    TCHAR       pch[ TEXTCHUNK_SIZE + 1];
    BOOL        fFirstInBlock;
    BOOL        fResult;

    IMarkupServices   * pMarkupServices = GetMarkupServices();
    IMarkupPointer    * pLeft = NULL;
    IMarkupPointer    * pRight = NULL;
    IMarkupPointer    * pDeletionPoint = NULL;
    MARKUP_CONTEXT_TYPE context;
    CEditPointer        ePointer( GetEditor() );
    IHTMLElement      * pPreElement = NULL;

    if (! (pStart && pEnd) ) 
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( GetEditor()->CreateMarkupPointer( & pLeft ) );
    IFC( GetEditor()->CreateMarkupPointer( & pRight ) );

    IFC ( pStart->IsRightOf( pEnd, & fResult ) );
    if ( fResult )
    {
        IFC( pLeft->MoveToPointer(  pEnd ) );
        IFC( pRight->MoveToPointer( pStart ) );
    }
    else
    {
        IFC( pLeft->MoveToPointer(  pStart ) );
        IFC( pRight->MoveToPointer( pEnd ) );
    }

    IFC( pLeft->SetGravity( POINTER_GRAVITY_Right ) );

    //
    // If either end of the segment is in a pre formatted element, we're done
    //
    if ( IsInPre( pLeft, & pPreElement ) )
    {       
        goto Cleanup;
    }
    ClearInterface( & pPreElement );
    if ( IsInPre( pRight, & pPreElement ) )
    {       
        goto Cleanup;
    }

    //
    // Move pLeft left and pRight right while next to blanks
    //
    IFC( SkipBlanks( pLeft, LEFT, & cch ) );
    cchBlanks += cch;

    IFC( SkipBlanks( pRight, RIGHT, & cch ) );
    cchBlanks += cch;

    if (! cchBlanks)
    {
        // No blanks found, we're done
        goto Cleanup;
    }    

    //
    // Check whether pLeft is at the first blank of a block or layout element
    //
    IFC( ePointer.MoveToPointer( pLeft ) );
    IGNORE_HR( ePointer.Scan(  LEFT,
                    BREAK_CONDITION_Block |
                    BREAK_CONDITION_Site |
                    BREAK_CONDITION_Control |
                    BREAK_CONDITION_NoScopeBlock |
                    BREAK_CONDITION_Text ,
                    &dwBreak ) );

    fFirstInBlock = ePointer.CheckFlag( dwBreak, BREAK_CONDITION_ExitBlock  ) ||
                    ePointer.CheckFlag( dwBreak, BREAK_CONDITION_ExitSite )   ||
                    ePointer.CheckFlag( dwBreak, BREAK_CONDITION_NoScopeBlock );
       
    if ( cchBlanks == 1 && !fFirstInBlock )
    {
        // We only have one blank and it's not at the beginning of a block
        goto Cleanup;
    }

    //
    // pLeft and pRight span consecutive blanks at this point, 
    // let's preserve the blanks now
    //
    
    IFC( GetEditor()->CreateMarkupPointer( & pDeletionPoint ) );
    IFC( pDeletionPoint->MoveToPointer( pLeft ) );    
  
    cchCurrent = 0;

    while ( cchBlanks )
    {       
        cch = 1;
        IFC( pDeletionPoint->Right( TRUE, & context, NULL, & cch, pch ) );
        switch ( context )
        {
        case CONTEXT_TYPE_Text:
            Assert ( cch == 1 );
            Assert ( IsLaunderChar( *pch ) );
            cchBlanks -= cch;
            cchCurrent++;
            
            if (*pch != chNBSP)
            {                
                if ( cchBlanks == 0                             // We're on the last white character
                     && !(cchCurrent == 1 && fFirstInBlock) )   // And it is not the first char in a block
                {
                    // Leave it alone, we're don