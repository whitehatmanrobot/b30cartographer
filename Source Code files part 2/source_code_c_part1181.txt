STATUS FARINTERNAL EmfSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL EmfChangeData (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
void      FARINTERNAL EmfSetExtents (LPOBJECT_EMF);
DWORD     INTERNAL    EmfGetSize (LPHANDLE);
HANDLE    INTERNAL    GetHemfp (LPOBJECT_EMF);
OLESTATUS INTERNAL    EmfUpdateStruct (LPOBJECT_EMF, LPOLECLIENT, HANDLE, 
                            LPMETAFILEPICT, HANDLE, BOOL);
OLECLIPFORMAT FARINTERNAL EmfEnumFormat (LPOLEOBJECT, OLECLIPFORMAT);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DIB.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

/* The DIB file will be of the following format:                        */
/*                                                                      */
/*      0004                                                            */
/*      "DIB"                                                           */
/*      4 bytes of xExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of yExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of size of (BITMAPINFOHEADER + RBGQUAD + bit array)     */
/*      BITMAPINFOHEADER structure                                      */
/*      RBGQUAD array                                                   */
/*      array of DI bits                                                */
/*                                                                      */

OLESTATUS FARINTERNAL DibRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL DibSaveToStream (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS FARINTERNAL DibClone (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS FARINTERNAL DibEqual (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS FARINTERNAL DibCopy (LPOLEOBJECT);
OLESTATUS FARINTERNAL DibQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FARINTERNAL DibGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL DibChangeData (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
BOOL      INTERNAL    DibStreamRead (LPOLESTREAM,LPOBJECT_DIB);
void      INTERNAL    DibUpdateStruct (LPOBJECT_DIB, LPOLECLIENT, HANDLE, LPBITMAPINFOHEADER, DWORD);

OLECLIPFORMAT FARINTERNAL DibEnumFormat (LPOLEOBJECT, OLECLIPFORMAT);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in BM.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


/* The BM file will be of the following format:                         */
/*                                                                      */
/*      0007                                                            */
/*      "BITMAP"                                                        */
/*      4 bytes of xExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of yExtent in MM_HIMETIRC units (or) 0                  */
/*      4 bytes of size of (BITMAP + bits)                              */
/*      BITMAP structure                                                */
/*      bitmap bits                                                     */
/*                                                                      */

OLESTATUS FARINTERNAL BmRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL BmSaveToStream (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS FARINTERNAL BmClone (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR *);
OLESTATUS FARINTERNAL BmEqual (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS FARINTERNAL BmCopy (LPOLEOBJECT);
OLESTATUS FARINTERNAL BmQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FARINTERNAL BmGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL BmChangeData (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
OLESTATUS INTERNAL    BmStreamWrite (LPOLESTREAM, LPOBJECT_BM);
BOOL      INTERNAL    BmStreamRead (LPOLESTREAM, LPOBJECT_BM);
void      INTERNAL    BmUpdateStruct (LPOBJECT_BM, LPOLECLIENT, HBITMAP, LPBITMAP, DWORD);

OLECLIPFORMAT FARINTERNAL BmEnumFormat (LPOLEOBJECT, OLECLIPFORMAT);
LPOBJECT_BM   INTERNAL    BmCreateObject (HBITMAP, LPOLECLIENT, BOOL, 
                                LHCLIENTDOC, LPCSTR, LONG);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in GENERIC.C                                                   //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////




/* The GENERIC file will be of the following format:                    */
/*                                                                      */
/*      0007                                                            */
/*      "GENERIC"                                                       */
/*      4 bytes of cfFormat                                             */

OLESTATUS FARINTERNAL GenRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL GenSaveToStream (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS FARINTERNAL GenEqual (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS FARINTERNAL GenCopy (LPOLEOBJECT);
OLESTATUS FARINTERNAL GenQueryBounds (LPOLEOBJECT, LPRECT);
OLESTATUS FARINTERNAL GenGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLESTATUS FARINTERNAL GenSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL GenChangeData (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
OLESTATUS INTERNAL    GenDeleteData (HANDLE);
OLESTATUS FARINTERNAL GenQueryType (LPOLEOBJECT, LPLONG);
OLESTATUS FARINTERNAL GenClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);

OLECLIPFORMAT FARINTERNAL GenEnumFormat (LPOLEOBJECT, OLECLIPFORMAT);
LPOBJECT_GEN  INTERNAL    GenCreateObject (HANDLE, LPOLECLIENT, BOOL, 
                                LHCLIENTDOC, LPCSTR, LONG);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in ERROR.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS FARINTERNAL ErrPlay (LPOLEOBJECT, UINT, BOOL, BOOL);
OLESTATUS FARINTERNAL ErrShow (LPOLEOBJECT, BOOL);
OLESTATUS FARINTERNAL ErrSetHostNames (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
OLESTATUS FARINTERNAL ErrSetTargetDevice (LPOLEOBJECT, HANDLE);
OLESTATUS FARINTERNAL ErrSetColorScheme (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
OLESTATUS FARINTERNAL ErrSetBounds (LPOLEOBJECT, OLE_CONST RECT FAR*);
OLESTATUS FARINTERNAL ErrQueryOpen (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrActivate (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
OLESTATUS FARINTERNAL ErrClose (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrUpdate (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrReconnect (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS FARINTERNAL ErrQueryOutOfDate (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrGetUpdateOptions (LPOLEOBJECT, OLEOPT_UPDATE FAR *);
OLESTATUS FARINTERNAL ErrSetUpdateOptions (LPOLEOBJECT, OLEOPT_UPDATE);
void FAR* FARINTERNAL ErrQueryProtocol (LPOLEOBJECT, OLE_LPCSTR);
OLE_RELEASE_METHOD FARINTERNAL ErrQueryReleaseMethod (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrQueryRelease (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrAbort (LPOLEOBJECT);
OLESTATUS FARINTERNAL ErrCopyFromLink (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS FARINTERNAL ErrRequestData (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS FARINTERNAL ErrExecute (LPOLEOBJECT, HANDLE, UINT);

OLESTATUS FARINTERNAL ErrObjectConvert (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*); 

OLESTATUS FARINTERNAL ErrObjectLong (LPOLEOBJECT, UINT, LPLONG);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DRAW.C                                                      //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
                    

OLESTATUS FARINTERNAL DibDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
OLESTATUS FARINTERNAL BmDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
OLESTATUS FARINTERNAL GenDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
OLESTATUS FARINTERNAL MfDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
void      INTERNAL    MfInterruptiblePaint (LPOBJECT_MF, HDC);
BOOL      APIENTRY    MfCallbackFunc (HDC, LPHANDLETABLE, LPMETARECORD, int, LPVOID);
OLESTATUS FARINTERNAL EmfDraw (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
void      INTERNAL    EmfInterruptiblePaint (LPOBJECT_EMF, HDC, LPRECT);
int       FARINTERNAL EmfCallbackFunc (HDC, LPHANDLETABLE, LPENHMETARECORD, int, LPVOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\clidemo.c ===
/*
 * clidemo.c - OLE client application sample code
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 *
 */

 /***************************************************************************
 * IMPORTANT - README:
 * OLE client applications are windows programs which use the OLE client
 * APIs.  Therefore it is imperative that you understand how these APIs
 * operate. Most importantly it is essential that you keep in mind which
 * procedure calls result in asynchronous states: a state where the operation
 * is not truely complete after a return from the call.
 *
 * Many functions produce asynchronous states, for example, OleActivate,
 * OleClose, OleCopyFromLink, OleCreate ... Reference your SDK manual for
 * a complete list.
 *
 * So whenever you call any of these library functions keep in mind that
 * the operation is not necessarily complete once a return is made.
 * These operations require communications with a server application.  With
 * OLE the inter-application communication is done through DDE.  In order
 * for a DDE conversation to complete several DDE messages need to be
 * sent and recieved by both the server and client OLE DLLs.  So, the
 * asynchronous operations will not complete until the client application
 * enters a message dipatch loop.  Therefore, it is necessary to enter
 * a dispatch loop and wait for completion.  It is not necessary to block
 * all other operation; however, it is very important to coordinate the
 * user activity to prevent disastrous re-entry cases.
 *
 * In this application I have written a macro to prevent re-entry
 * problems.  Namely: ANY_OBJECT_BUSY which prevents a user from initiating
 * an action which will result in an asynchronous call if there is an object
 * already in an asynchronous state.
 *
 * The following is brief summary of the three macros:
 *
 * ANY_OBJECT_BUSY: checks to see if any object in the document is busy.
 *              This prevents a new document from being saved to file if there are
 *              objects in asynchronous states.
 *
 * So, the problem is that we have to enter a message dispatch loop in order
 * to let DDE messages get through so that asynchronous operations can finish.
 * And while we are in the message dispatch loops (WaitForObject or WaitForAllObjects)
 * we have to prevent the user from doing things that can't be done when an
 * object(s) is busy.  Yes, it is confusing , but, the end result is a super
 * cool application that can have linked and embbeded objects!
 ***************************************************************************/

//*** INCLUDES ***

#include <windows.h>                   //* WINDOWS
#include <ole.h>                       //* OLE structs and defines
#include <shellapi.h>                  //* Shell, drag and drop headers

#include "demorc.h"                    //* header for resource file
#include "global.h"                    //* global app variables
#include "clidemo.h"                   //* app includes:
#include "register.h"
#include "stream.h"
#include "object.h"
#include "dialog.h"
#include "utility.h"

//*** VARIABLES ***

//** Global
HANDLE            hInst;
BOOL              fRetry = FALSE;
HWND              hwndFrame;           //* main window
HANDLE            hAccTable;           //* accelerator table
CHAR              szFrameClass[] = "CliDemo";//* main window class name
CHAR              szItemClass[]  = "ItemClass";//* item window class name
CHAR              szAppName[CBMESSAGEMAX];//* Application name
INT               iObjects = 0;        //* object count
INT               iObjectNumber = 0;   //* object number for object name
CHAR              szFileName[CBPATHMAX];

extern INT giXppli ;
extern INT giYppli ;
                                       //* ClipBoard formats:
OLECLIPFORMAT     vcfLink;             //* "ObjectLink"
OLECLIPFORMAT     vcfNative;           //* "Native"
OLECLIPFORMAT     vcfOwnerLink;        //* "OwnerLink"


/***************************************************************************
 * WinMain() - Main Windows routine
 ***************************************************************************/
int APIENTRY WinMain(
   HINSTANCE hInstance,
   HINSTANCE hPrevInst,
   LPSTR  lpCmdLine,
   INT    nCmdLine
){
    hInst = hInstance;

    if (!InitApplication(hInst))   //* register window classes
      return FALSE;

    if (!InitInstance(hInst))          //* create window instance
        return FALSE;

    OfnInit(hInst);                    //* setup to use <commdlg.dll>

                                       //* register clipboard formats
                                       //* used for OLE
    vcfLink      = (OLECLIPFORMAT)RegisterClipboardFormat("ObjectLink");
    vcfNative    = (OLECLIPFORMAT)RegisterClipboardFormat("Native");
    vcfOwnerLink = (OLECLIPFORMAT)RegisterClipboardFormat("OwnerLink");


    ShowWindow(hwndFrame, SW_SHOWNORMAL);
    UpdateWindow(hwndFrame);
    ProcessCmdLine(lpCmdLine);

    while (ProcessMessage(hwndFrame, hAccTable)) ;

    return FALSE;
}

/***************************************************************************
 * InitApplication()
 *
 * registers the window classes used by the application.
 *
 * Returns BOOL:      - TRUE if successful.
 ***************************************************************************/

static BOOL InitApplication(           //* ENTRY:
   HANDLE         hInst                //* instance handle
){                                     //* LOCAL:
   WNDCLASS       wc;                  //* temp wind-class structure

   wc.style          = 0;
   wc.lpfnWndProc    = (WNDPROC)FrameWndProc;
   wc.cbClsExtra     = 0;
   wc.cbWndExtra     = 0;
   wc.hInstance      = hInst;
   wc.hIcon          = LoadIcon(hInst, MAKEINTRESOURCE(ID_APPLICATION));
   wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
   wc.hbrBackground  = (HBRUSH)(COLOR_APPWORKSPACE + 1);
   wc.lpszMenuName   = MAKEINTRESOURCE(ID_APPLICATION);
   wc.lpszClassName  = szFrameClass;

   if (!RegisterClass(&wc))
      return FALSE;
                                       //* application item class
   wc.style          = CS_DBLCLKS | CS_VREDRAW | CS_HREDRAW;
   wc.lpfnWndProc    = (WNDPROC)ItemWndProc;
   wc.hIcon          = NULL;
   wc.cbWndExtra     = sizeof(APPITEMPTR);
   wc.lpszMenuName   = NULL;
   wc.lpszClassName  = szItemClass;

   if (!RegisterClass(&wc))
      return FALSE;

   return TRUE;

}

/***************************************************************************
 * InitInstance()
 *
 * create the main application window.
 *
 * Returns BOOL:      - TRUE if successful else FALSE.
 ***************************************************************************/

static BOOL InitInstance(              //* ENTRY:
   HANDLE         hInst                //* instance handel
){
	HDC hDC ;

   hAccTable = LoadAccelerators(hInst, MAKEINTRESOURCE(ID_APPLICATION));

   if (!(hwndFrame =
      CreateWindow(
         szFrameClass, "",
         WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
         CW_USEDEFAULT, CW_USEDEFAULT,
         CW_USEDEFAULT, CW_USEDEFAULT,
         NULL,
         NULL,
         hInst,
         NULL
      )))
      return FALSE;                    //* ERROR return

   LoadString(hInst, IDS_APPNAME, szAppName, CBMESSAGEMAX);
   DragAcceptFiles(hwndFrame, TRUE);   //* allow dragged and dropped files

   hDC    = GetDC (NULL);       // Get the hDC of the desktop window
   giXppli = GetDeviceCaps (hDC, LOGPIXELSX);
   giYppli = GetDeviceCaps (hDC, LOGPIXELSY);
   ReleaseDC (NULL, hDC);
	


   return TRUE;                        //* SUCCESS return

}

/***************************************************************************
 *  ProcessCmdLine()
 *
 *  process command line getting any command arguments.
 ***************************************************************************/

VOID ProcessCmdLine(LPSTR lpCmdLine)
{                                     //* LOCAL:
   OFSTRUCT       ofs;


   if (*lpCmdLine)
   {                                   //* look for file extension
      LPSTR lpstrExt = lpCmdLine;      //* pointer to file extension

      while (*lpstrExt && *lpstrExt != '.')
         lpstrExt = AnsiNext(lpstrExt);

      lstrcpy(szFileName, lpCmdLine);
      if (!(*lpstrExt))                //* append default extension
      {
         lstrcat(szFileName,".");
         lstrcat(szFileName,szDefExtension);
      }
                                       //* get the files fully
      OpenFile(szFileName, &ofs, OF_PARSE);//* qualified name
      lstrcpy(szFileName, ofs.szPathName);
   }
   else
      *szFileName = 0;
                                       //* pass filename to main winproc
   SendMessage(hwndFrame,WM_INIT,(WPARAM)0,(LPARAM)0);

}


/***************************************************************************
 *  FrameWndProc()
 *
 *  Message handler for the application frame window.
 *
 *  Returns long - Variable, depends on message.
 ***************************************************************************/

LONG  APIENTRY FrameWndProc(           //* ENTRY:
   HWND           hwnd,                //* standard wind-proc parameters
   UINT           msg,
   DWORD          wParam,
   LONG           lParam
){                                     //* LOCAL:
                                       //* ^ Document file name
   static LHCLIENTDOC   lhcDoc;        //* Document Handle
   static LPOLECLIENT   lpClient;      //* pointer to client
   static LPAPPSTREAM   lpStream;      //* pointer to stream vtbl
   APPITEMPTR           pItem;         //* application item pointer

   switch (msg)
   {
      case WM_INIT:                    //* user defined message
         if (!InitAsOleClient(hInst, hwnd, szFileName, &lhcDoc, &lpClient, &lpStream))
            DestroyWindow(hwnd);
         break;
                                       //* the following three messages are
                                       //* used to avoid problems with OLE
                                       //* see the comment in object.h
      case WM_DELETE:                  //* user defined message
         pItem = (APPITEMPTR) lParam;  //* delete object
         WaitForObject(pItem);
         ObjDelete(pItem,OLE_OBJ_DELETE);
         if (wParam)
            cOleWait--;
         break;

      case WM_ERROR:                   //* user defined message
         ErrorMessage(wParam);         //* display error message
         break;

      case WM_RETRY:                   //* user defined message
         RetryMessage((APPITEMPTR)lParam, RD_RETRY | RD_CANCEL);
         break;

      case WM_INITMENU:
         UpdateMenu((HMENU)wParam);
         break;

      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         pItem = GetTopItem();

         switch (wID)
         {
            case IDM_NEW:
               ANY_OBJECT_BUSY;
               NewFile(szFileName,&lhcDoc,lpStream);
               break;

            case IDM_OPEN:
               ANY_OBJECT_BUSY;
               MyOpenFile(szFileName,&lhcDoc,lpClient,lpStream);
               break;

            case IDM_SAVE:
               ANY_OBJECT_BUSY;
               SaveFile(szFileName,lhcDoc,lpStream);
               break;

            case IDM_SAVEAS:
               ANY_OBJECT_BUSY;
               SaveasFile(szFileName,lhcDoc,lpStream);
               break;

            case IDM_ABOUT:
               AboutBox();
               break;

            case IDM_INSERT:
               ANY_OBJECT_BUSY;
               ObjInsert(lhcDoc, lpClient);
               break;

            case IDM_INSERTFILE:
               ANY_OBJECT_BUSY;
               ObjCreateFromTemplate(lhcDoc,lpClient);
               break;

            case IDM_PASTE:
            case IDM_PASTELINK:
               ANY_OBJECT_BUSY;
               ObjPaste(wID == IDM_PASTE,lhcDoc,lpClient);
               break;

            case IDM_LINKS:
               ANY_OBJECT_BUSY;
               pItem = GetTopItem();
               LinkProperties();
               break;

            case IDM_EXIT:
               ANY_OBJECT_BUSY;
               SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
               break;

            case IDM_COPY:
            case IDM_CUT:
               ANY_OBJECT_BUSY;

               if (!ObjCopy(pItem))
               {
                  ErrorMessage((wParam == IDM_CUT) ?
                     E_CLIPBOARD_CUT_FAILED : E_CLIPBOARD_COPY_FAILED);
                  break;
               }

               if (wParam == IDM_COPY)
                  break;

            case IDM_CLEAR:            //* CUT falls through to clear
               ANY_OBJECT_BUSY;
               ClearItem(pItem);
               break;

            case IDM_CLEARALL:
               ANY_OBJECT_BUSY;
               ClearAll(lhcDoc,OLE_OBJ_DELETE);
               Dirty(DOC_DIRTY);
               break;

            default:
               if( (wParam >= IDM_VERBMIN) && (wParam <= IDM_VERBMAX) )
               {
                  ANY_OBJECT_BUSY;
                  ExecuteVerb(wParam - IDM_VERBMIN,pItem);
                  break;
               }
               return DefWindowProc(hwnd, msg, wParam, lParam);
         }
         break;
      }

      case WM_DROPFILES:
         ANY_OBJECT_BUSY;
         ObjCreateWrap((HANDLE)wParam, lhcDoc, lpClient);
         break;

      case WM_CLOSE:
         ANY_OBJECT_BUSY;
         if (!SaveAsNeeded(szFileName, lhcDoc, lpStream))
            break;
         DeregDoc(lhcDoc);
         DestroyWindow(hwnd);
         break;

      case WM_DESTROY:
         EndStream(lpStream);
         EndClient(lpClient);
         PostQuitMessage(0);
         break;

      case WM_QUERYENDSESSION:         //* don't let windows terminate
         return (QueryEndSession(szFileName,lhcDoc, lpStream));

      default:
         return DefWindowProc(hwnd, msg, wParam, lParam);
   }
   return 0L;

}

/***************************************************************************
 * InitAsOleClient()
 *
 * Initiates the creation of stream and client vtbls.  These vtbls are very
 * important for the proper operation of this application.  The stream vtbl
 * lets the OLE librarys know where the location of the stream I/O routines
 * reside.  The stream routines are used by OleLoadFromStream and the like.
 * The client vtbl is used to hold the pointer to the CallBack function.
 * IMPORTANT: both the client and the stream structures have pointers to
 * vtbls which have the pointers to the functions.  Therefore, it is
 * necessary to allocate space for the vtbl and the client structure
 * which has the pointer to the vtbl.
 **************************************************************************/

static BOOL InitAsOleClient(           //* ENTRY:
   HANDLE         hInstance,           //* applicaion instance handle
   HWND           hwnd,                //* main window handle
   PSTR           pFileName,           //* document file name
   LHCLIENTDOC    *lhcDoc,             //* pointer to document Handle
   LPOLECLIENT    *lpClient,           //* pointer to client pointer
   LPAPPSTREAM    *lpStream            //* pointer to APPSTREAM pointer
){
                                       //* initiate client vtbl creation
   if (!(*lpClient = InitClient(hInstance)))
   {
      SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
      return FALSE;                    //* ERROR return
   }
                                       //* initiate stream vtbl creation
   if (!(*lpStream = InitStream(hInstance)))
   {
      SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
      return FALSE;                    //* ERROR return
   }

   if (*pFileName && RegDoc(pFileName,lhcDoc)
       && LoadFile(pFileName,*lhcDoc,*lpClient,*lpStream))
   {
      SetTitle(pFileName);
      return TRUE;                     //* SUCCESS return
   }

   NewFile(pFileName, lhcDoc, *lpStream);
   return TRUE;                        //* SUCCESS return

}                                      //* SUCCESS return

/****************************************************************************
 *  InitClient()
 *
 *  Initialize the OLE client structure, create and fill the OLECLIENTVTBL
 *  structure.
 *
 *  Returns LPOLECLIENT - if successful a pointer to a client structure
 *                        , otherwise NULL.
 ***************************************************************************/

static LPOLECLIENT InitClient(         //* ENTRY:
   HANDLE hInstance                    //* application instance handle
){                                     //* LOCAL:
   LPOLECLIENT lpClient=NULL;          //* pointer to client struct
                                       //* Allocate vtbls
   if (!(lpClient = (LPOLECLIENT)GlobalLock(
         GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(OLECLIENT))
      )))
      goto Error;                      //* ERROR jump

   if (!(lpClient->lpvtbl = (LPOLECLIENTVTBL)GlobalLock(
            GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(OLECLIENTVTBL))
      )))
      goto Error;                      //* ERROR jump
                                       //* set the CALLBACK function
                                       //* pointer
   lpClient->lpvtbl->CallBack  = CallBack;

   return lpClient;                    //* SUCCESS return

Error:                                 //* ERROR Tag

   ErrorMessage(E_FAILED_TO_ALLOC);
   EndClient(lpClient);                //* free any allocated space

   return NULL;                        //* ERROR return

}

/****************************************************************************
 *  InitStream()
 *
 *  Create and fill the STREAMVTBL. Create a stream structure and initialize
 *  pointer to stream vtbl.
 *
 *  Returns LPAPPSTREAM - if successful a pointer to a stream structure
 *                        , otherwise NULL .
 ***************************************************************************/

static LPAPPSTREAM InitStream(         //* ENTRY:
   HANDLE hInstance                    //* handle to application instance
){                                     //* LOCAL:
   LPAPPSTREAM lpStream = NULL;        //* pointer to stream structure

   if (!(lpStream = (LPAPPSTREAM)GlobalLock(
         GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(APPSTREAM))
      )))
      goto Error;                      //* ERROR jump

   if (!(lpStream->olestream.lpstbl = (LPOLESTREAMVTBL)GlobalLock(
         GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(OLESTREAMVTBL))
      )))
      goto Error;                      //* ERROR jump

                                       //* set stream func. pointers
   lpStream->olestream.lpstbl->Get = (DWORD ( CALLBACK *)(LPOLESTREAM, VOID FAR *, DWORD)) ReadStream;
   lpStream->olestream.lpstbl->Put = (DWORD ( CALLBACK *)(LPOLESTREAM, OLE_CONST VOID FAR *, DWORD)) WriteStream;

   return lpStream;                    //* SUCCESS return

Error:                                 //* ERROR Tag

   ErrorMessage(E_FAILED_TO_ALLOC);
   EndStream(lpStream);

   return NULL;                        //* ERROR return

}

/***************************************************************************
 *  UpdateMenu()
 *
 *  Enabling or disable menuitems based upon program state.
 ***************************************************************************/

static VOID UpdateMenu(                //* ENTRY:
   HMENU       hMenu                   //* menu handle to updated
){                                     //* LOCAL:
   INT         mf;                     //* generic menu flag
   APPITEMPTR  paItem;                 //* app item pointer
   HMENU       hSub;
                                       //* there must be at least on object
                                       //* for the following to be enabled

   paItem = GetTopItem() ;

   mf = (paItem ? MF_ENABLED : MF_GRAYED);
   EnableMenuItem(hMenu, IDM_CUT, mf); //* i.e. Cut,Copy,Clear,Clearall...
   EnableMenuItem(hMenu, IDM_COPY, mf);
   EnableMenuItem(hMenu, IDM_CLEAR, mf);
   EnableMenuItem(hMenu, IDM_CLEARALL, mf);
                                       //* enable links option only if there
                                       //* is at least one linked object
   EnableMenuItem(hMenu, IDM_LINKS, MF_GRAYED);
   for (; paItem; paItem = GetNextItem(paItem))
   {
      if (paItem->otObject == OT_LINK)
      {
         EnableMenuItem(hMenu, IDM_LINKS, MF_ENABLED);
         break;
      }
   }

   if (hSub = GetSubMenu(hMenu,POS_EDITMENU))
      UpdateObjectMenuItem(hSub);

   if (OleQueryCreateFromClip(STDFILEEDITING, olerender_draw, 0) == OLE_OK)
      EnableMenuItem(hMenu, IDM_PASTE, MF_ENABLED);
   else if (OleQueryCreateFromClip(STATICP, olerender_draw, 0) == OLE_OK)
      EnableMenuItem(hMenu, IDM_PASTE, MF_ENABLED);
   else
      EnableMenuItem(hMenu, IDM_PASTE, MF_GRAYED);

   if (OleQueryLinkFromClip(STDFILEEDITING, olerender_draw, 0) == OLE_OK)
      EnableMenuItem(hMenu, IDM_PASTELINK, MF_ENABLED);
   else
      EnableMenuItem(hMenu, IDM_PASTELINK, MF_GRAYED);

}

/***************************************************************************
 *  NewFile()
 *
 *  Save the present document and open a new blank one.
 ***************************************************************************/

static VOID NewFile(                   //* ENTRY:
   PSTR           pFileName,           //* open file name
   LHCLIENTDOC    *lhcptrDoc,          //* pointer to client doc. handle
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){                                     //* LOCAL:
   static CHAR  szUntitled[CBMESSAGEMAX] = "";//* "(Untitled)" string
   LHCLIENTDOC lhcDocNew;              //* handle for new doc.

   if (!(*szUntitled))
      LoadString(hInst, IDS_UNTITLED, (LPSTR)szUntitled, CBMESSAGEMAX);

   if (SaveAsNeeded(pFileName, *lhcptrDoc, lpStream))
   {                                   //* try to register new document
      if (!RegDoc(szUntitled, &lhcDocNew))
         return;                       //* before deregistring the old one
      DeregDoc(*lhcptrDoc);
      *lhcptrDoc = lhcDocNew;
      Dirty(DOC_CLEAN);                //* new document is clean
      lstrcpy(pFileName,szUntitled);
      SetTitle(pFileName);
      iObjectNumber = 0;
   }

}

/***************************************************************************
 *  MyOpenFile()
 *
 *  Open a file and load it.  Notice that the new file is loaded before
 *  the old is removed.  This is done to assure a succesful file load
 *  before removing an existing document.
 ***************************************************************************/

static VOID MyOpenFile(                //* ENTRY:
   PSTR           pFileName,           //* open file name
   LHCLIENTDOC    *lhcptrDoc,          //* pointer to document handle
   LPOLECLIENT    lpClient,            //* pointer to client structure
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){                                     //* LOCAL:
   CHAR           szNewFile[CBPATHMAX];//* new file name buffer
   LHCLIENTDOC    lhcDocNew;           //* handle of new document
   APPITEMPTR     pItem;               //* hold top item

   if (SaveAsNeeded(pFileName, *lhcptrDoc, lpStream))
   {
      *szNewFile = 0;

      if (!OfnGetName(hwndFrame, szNewFile, IDM_OPEN))
         return;                       //* ERROR return

      if (!RegDoc(szNewFile,&lhcDocNew))
         return;                       //* ERROR return

      pItem = GetTopItem();
      ShowDoc(*lhcptrDoc,0);           //* make old doc objects hidden.
                                       //* try to load the new file before
      if (!LoadFile(szNewFile, lhcDocNew, lpClient, lpStream))
      {                                //* before removing the old.
         DeregDoc(lhcDocNew);          //* restore old document if new
         SetTopItem(pItem);            //* file did not load
         ShowDoc(*lhcptrDoc,1);
         return;                       //* ERROR return
      }

      DeregDoc(*lhcptrDoc);            //* deregister old document
      *lhcptrDoc = lhcDocNew;
      lstrcpy(pFileName,szNewFile);
      SetTitle(pFileName);             //* set new title
      Dirty(DOC_CLEAN);
   }

}                                      //* SUCCESS return

/***************************************************************************
 *  SaveasFile()
 *
 * Prompt the user for a new file name.  Write the document to the new
 * filename.
 ***************************************************************************/

static VOID SaveasFile(                //* ENTRY:
   PSTR           pFileName,           //* old filename
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){
   CHAR           szNewFile[CBPATHMAX];//* new file name

   *szNewFile = 0;                  //* prompt user for new file name
   if (!OfnGetName(hwndFrame, szNewFile, IDM_SAVEAS))
      return;                          //* ERROR return
                                       //* rename document
   if (!SaveFile(szNewFile, lhcDoc, lpStream))
      return;

   if (Error(OleRenameClientDoc(lhcDoc, szNewFile)))
   {
      ErrorMessage(W_FAILED_TO_NOTIFY);
      return;                          //* ERROR return
   }

   lstrcpy(pFileName,szNewFile);
   SetTitle(pFileName);

}                                      //* SUCCESS return

/***************************************************************************
 *  SaveFile()
 *
 * Save a compound document file.  If the file is untitled, ask the user
 * for a name and save the document to that file.
 ***************************************************************************/

static BOOL SaveFile(                  //* ENTRY:
   PSTR           pFileName,           //* file to save document to
   LHCLIENTDOC    lhcDoc,              //* OLE document handle
   LPAPPSTREAM    lpStream             //* pointer to app. stream struct
){                                     //* LOCAL:
   CHAR           szNewFile[CBPATHMAX];//* New file name strings
   CHAR           szOemFileName[2*CBPATHMAX];
   static CHAR    szUntitled[CBMESSAGEMAX] = "";
   int            fh;                  //* file handle

   *szNewFile = 0;
   if (!(*szUntitled))
      LoadString(hInst, IDS_UNTITLED, (LPSTR)szUntitled, CBMESSAGEMAX);

   if (!lstrcmp(szUntitled, pFileName))//* get filename for the untitled case
   {
      if (!OfnGetName(hwndFrame, szNewFile, IDM_SAVEAS))
         return FALSE;                 //* CANCEL return
      lstrcpy(pFileName,szNewFile);
      SetTitle(pFileName);
   }

   AnsiToOem(pFileName, szOemFileName);
   if ((fh = _lcreat((LPSTR)szOemFileName, 0)) <= 0)
   {
      ErrorMessage(E_INVALID_FILENAME);
      return FALSE;                    //* ERROR return
   }

   lpStream->fh = fh;
                                       //* save file on disk
   if (!WriteToFile(lpStream))
   {
      _lclose(fh);
      ErrorMessage(E_FAILED_TO_SAVE_FILE);
      return FALSE;                    //* ERROR return
   }
   _lclose(fh);

   if (Error(OleSavedClientDoc(lhcDoc)))
   {
      ErrorMessage(W_FAILED_TO_NOTIFY);
      return FALSE;                    //* ERROR return
   }

   Dirty(DOC_CLEAN);
   return TRUE;                        //* SUCCESS return

}

/***************************************************************************
 *  LoadFile()
 *
 *  Load a document file from disk.
 ***************************************************************************/

static BOOL LoadFile(                  //* ENTRY:
   PSTR           pFileName,           //* file name
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPOLECLIENT    lpClient,            //* pointer to client structure
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){                                     //* LOCAL:
                                       //* OEM file name
   CHAR           szOemFileName[2*CBPATHMAX];
   int            fh;                  //* file handle
   INT            iObjectNumberHold;   //* hold object number

   AnsiToOem(pFileName, szOemFileName);
   if ((fh = _lopen(szOemFileName, OF_READ | OF_SHARE_DENY_WRITE)) == -1)
   {
      ErrorMessage(E_FAILED_TO_READ_FILE);
      return FALSE;                    //* ERROR return
   }

   lpStream->fh = fh;

   iObjectNumberHold = iObjectNumber;  //* save object number so it can
   iObjectNumber     = 0;              //* be restored if read from file
                                       //* fails
   if (!ReadFromFile(lpStream, lhcDoc, lpClient))
   {
      _lclose(fh);
      ErrorMessage(E_FAILED_TO_READ_FILE);
      iObjectNumber = iObjectNumberHold;
      return FALSE;                    //* ERROR return
   }
   _lclose(fh);
   return TRUE;                        //* SUCCESS return

}

/***************************************************************************
 *  RegDoc()
 *
 * Register the client document with the OLE library.
 **************************************************************************/

static BOOL RegDoc(                    //* ENTRY:
   PSTR           pFileName,           //* file name
   LHCLIENTDOC    *lhcptrDoc           //* pointer to client document handle
){

   if (Error(OleRegisterClientDoc(szAppName, (LPSTR)pFileName, 0L, lhcptrDoc)))
   {
      ErrorMessage(W_FAILED_TO_NOTIFY);
      return FALSE;                    //* ERROR return
   }
   return TRUE;                        //* SUCCESS return

}

/****************************************************************************
 *  DeregDoc()
 *
 *  This function initiates the removal of all OLE objects from the
 *  current document and deregisters the document with the OLE library.
 ***************************************************************************/

static VOID DeregDoc(                  //* ENTRY:
   LHCLIENTDOC    lhcDoc               //* client document handle
){

    if (lhcDoc)
    {                                  //* release all OLE objects
        ClearAll(lhcDoc,OLE_OBJ_RELEASE);      //* and remove them from the screen
        WaitForAllObjects();
        if (Error(OleRevokeClientDoc(lhcDoc)))
            ErrorMessage(W_FAILED_TO_NOTIFY);
    }

}                                      //* SUCCESS return

/***************************************************************************
 *  ClearAll()
 *
 * This function will destroy all of the item windows in the current
 * document and delete all OLE objects.  The loop is basically an enum
 * of all child windows.
 **************************************************************************/

static VOID ClearAll(                  //* ENTRY:
   LHCLIENTDOC    lhcDoc,              //* application document handle
   BOOL           fDelete              //* Delete / Release
){                                     //* LOCAL:
   APPITEMPTR     pItemNext;           //* working handles
   APPITEMPTR     pItem;               //* pointer to application item

   pItem = GetTopItem();

   while (pItem)
   {
      pItemNext = GetNextItem(pItem);
      if (pItem->lhcDoc == lhcDoc)
         ObjDelete(pItem, fDelete);
      pItem = pItemNext;
   }

}
                                    //* SUCCESS return
/***************************************************************************
 * ClearItem()
 *
 * This function will destroy an item window, and make the
 * next window active.
 **************************************************************************/

VOID  FAR ClearItem(                 //* ENTRY:
   APPITEMPTR     pItem                //* application item pointer
){

   pItem->fVisible = FALSE;
   SetTopItem(GetNextActiveItem());
   ObjDelete(pItem, OLE_OBJ_DELETE);
   Dirty(DOC_DIRTY);

}

/****************************************************************************
 *  SaveAsNeeded()
 *
 *  This function will have the file saved if and only
 *  if the document has been modified. If the fDirty flag has
 *  been set to TRUE, then the document needs to be saved.
 *
 *  Returns: BOOL -  TRUE if document doesn't need saving or if the
 *                   document has been saved successfully.
 ***************************************************************************/

static BOOL SaveAsNeeded(              //* ENTRY:
   PSTR           pFileName,           //* file to save
   LHCLIENTDOC    lhcDoc,              //* OLE doc handle
   LPAPPSTREAM    lpStream             //* pointer to OLE stream vtbl ...
){                                     //* LOCAL:
   CHAR           sz[CBMESSAGEMAX];    //* work strings
   CHAR           sz2[CBMESSAGEMAX + CBPATHMAX];

   if (Dirty(DOC_QUERY))               //* if doc is clean don't bother
   {

      LoadString(hInst, IDS_MAYBESAVE, sz, CBMESSAGEMAX);
      wsprintf(sz2, sz, (LPSTR)pFileName );

      switch (MessageBox(hwndFrame, sz2, szAppName, MB_YESNOCANCEL | MB_ICONQUESTION))
      {

         case IDCANCEL:
            return FALSE;              //* CANCEL return

         case IDYES:
            return (SaveFile(pFileName,lhcDoc,lpStream));

         default:
            break;
      }
   }
   return TRUE;                        //* SUCCESS return

}

/****************************************************************************
 *  SetTitle()
 *
 *  Set the window caption to the current file name. If szFileName is
 *  NULL, the caption will be set to "(Untitled)".
 ***************************************************************************/

static VOID SetTitle(                  //* ENTRY:
   PSTR           pFileName            //* file name
){                                     //* LOCAL
                                       //* window title string
   CHAR           szTitle[CBMESSAGEMAX + CBPATHMAX];

   wsprintf(szTitle, "%s - %s", (LPSTR)szAppName, (LPSTR)pFileName);
   SetWindowText(hwndFrame, szTitle);

}

/***************************************************************************
 *  EndClient()
 *
 *  Perform cleanup prior to app termination. The OLECLIENT
 *  memory blocks and procedure instance thunks freed.
 **************************************************************************/

static VOID EndStream(                 //* ENTRY:
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){                                     //* LOCAL:
   HANDLE         hGeneric;            //* temp handle

    if (lpStream)                      //* is there a STREAM struct?
    {
      if (lpStream->olestream.lpstbl)
      {
         FreeProcInstance((FARPROC)lpStream->olestream.lpstbl->Get);
         FreeProcInstance((FARPROC)lpStream->olestream.lpstbl->Put);
         hGeneric = GlobalHandle((LPSTR)lpStream->olestream.lpstbl);
         GlobalUnlock(hGeneric);
         GlobalFree(hGeneric);
      }
      hGeneric = GlobalHandle((LPSTR)lpStream);
      GlobalUnlock(hGeneric);
      GlobalFree(hGeneric);
    }

}                                      //* SUCCESS return

/***************************************************************************
 *  EndClient()
 *
 *  Perform cleanup prior to app termination. The OLECLIENT
 *  memory blocks and procedure instance thunks are freed.
 **************************************************************************/

static VOID EndClient(                 //* ENTRY:
   LPOLECLIENT    lpClient             //* pointer to client structure
){                                     //* LOCAL:
   HANDLE         hGeneric;            //* temp handle

   if (lpClient)                       //* is there a client structure
   {
      if (lpClient->lpvtbl)
      {
         FreeProcInstance(lpClient->lpvtbl->CallBack);
         hGeneric = GlobalHandle((LPSTR)lpClient->lpvtbl);
         GlobalUnlock(hGeneric);
         GlobalFree(hGeneric);
      }
      hGeneric = GlobalHandle((LPSTR)lpClient);
      GlobalUnlock(hGeneric);
      GlobalFree(hGeneric);
   }

}                                      //* SUCCESS return

/****************************************************************************
 * QueryEndSession()
 ***************************************************************************/

static LONG QueryEndSession(           //* ENTRY:
   PSTR           pFileName,           //* document name
   LHCLIENTDOC    lhcDoc,              //* client document handle
   LPAPPSTREAM    lpStream             //* application stream pointer
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer


   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
      if (OleQueryOpen(pItem->lpObject) == OLE_OK)
      {
         MessageBox(hwndFrame,"Exit CliDemo before closing Windows",
               szAppName, MB_OK | MB_ICONSTOP);
         return 0L;
      }

   if (!SaveAsNeeded(pFileName, lhcDoc, lpStream))
      return 0L;
   DeregDoc(lhcDoc);
   return 1L;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\client\utils.c ===
/****************************** Module Header ******************************\
* Module Name: utils.c
*
* Purpose: Conatains all the utility routines
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, srinik (../../1990,91)    Designed and coded
*   curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>

#include "dll.h"

#define KB_64      65536
#define NULL_WORD  0x0000

extern ATOM  aPackage;
extern OLEOBJECTVTBL    vtblMF, vtblBM, vtblDIB, vtblGEN;

// QuerySize API support
DWORD           dwObjSize = 0;
OLESTREAMVTBL   dllStreamVtbl;
OLESTREAM       dllStream;

#ifdef WIN16
#pragma alloc_text(_DDETEXT, UtilMemClr, MapStrToH, MapExtToClass, FileExists)
#endif

BOOL PutStrWithLen(
    LPOLESTREAM   lpstream,
    LPSTR         lpbytes
){
    LONG     len;

    len = (LONG) lstrlen(lpbytes) + 1;

    if (PutBytes (lpstream, (LPSTR)&len, sizeof(len)))
        return TRUE;

    return PutBytes(lpstream, lpbytes, len);

}

BOOL GetStrWithLen(
    LPOLESTREAM   lpstream,
    LPSTR         lpbytes
){
    if (GetBytes (lpstream, lpbytes, sizeof(LONG)))
        return TRUE;

    return GetBytes (lpstream, lpbytes + sizeof(LONG), (*(LONG FAR *)lpbytes));
}

ATOM GetAtomFromStream(
    LPOLESTREAM lpstream
){
    BOOL    err = TRUE;
    LONG    len;
    char    str[MAX_STR+1];


    if (GetBytes (lpstream, (LPSTR)&len, sizeof(len)))
        return (ATOM)0;

    if (len == 0)
        return (ATOM)0;

    if (GetBytes(lpstream, (LPSTR)str, len))
        return (ATOM)0;

    return GlobalAddAtom(str);

}

BOOL PutAtomIntoStream(
    LPOLESTREAM     lpstream,
    ATOM            at
){
    LONG    len = 0;
    char    buf[MAX_STR + 1];

    if (at == 0)
        return  (PutBytes (lpstream, (LPSTR)&len, sizeof(len)));


    len = GlobalGetAtomName (at,(LPSTR)buf, MAX_STR) + 1;

    if (PutBytes (lpstream, (LPSTR)&len, sizeof(len)))
        return TRUE;

    return PutBytes(lpstream, buf, len);
}


// DuplicateAtom: Bump the use count up on a global atom.

ATOM FARINTERNAL DuplicateAtom (
    ATOM atom
){
    char buffer[MAX_ATOM+1];

    Puts("DuplicateAtom");

    if (!atom)
        return (ATOM)0;

    GlobalGetAtomName (atom, buffer, MAX_ATOM);
    return GlobalAddAtom (buffer);
}



BOOL GetBytes(
    LPOLESTREAM     lpstream,
    LPSTR           lpstr,
    LONG            len
){

    ASSERT (lpstream->lpstbl->Get , "stream get function is null");
    return (((*lpstream->lpstbl->Get)(lpstream, lpstr, (DWORD)len)) != (DWORD)len);
}


BOOL PutBytes(
    LPOLESTREAM     lpstream,
    LPSTR           lpstr,
    LONG            len
){

    ASSERT (lpstream->lpstbl->Put , "stream get function is null");
    return (((*lpstream->lpstbl->Put)(lpstream, lpstr, (DWORD)len)) != (DWORD)len);
}



BOOL FARINTERNAL UtilMemCmp (
    LPSTR   lpmem1,
    LPSTR   lpmem2,
    DWORD   dwCount
){
    UINT HUGE_T * hpmem1;
    UINT HUGE_T * hpmem2;
    DWORD       words;
    DWORD       bytes;

    bytes = dwCount %  MAPVALUE(2,4);
    words = dwCount >> MAPVALUE(1,2);//* we compare DWORDS
                                     //* in the 32 bit version
#ifdef WIN16
    if (dwCount <= KB_64) {
        UINT FAR  * lpwMem1 = (WORD FAR *) lpmem1;
        UINT FAR  * lpwMem2 = (WORD FAR *) lpmem2;

        while (words--) {
            if (*lpwMem1++ != *lpwMem2++)
                return FALSE;
        }

        if (bytes) {
            if (* (char FAR *) lpwMem1 != *(char FAR *) lpwMem2)
                return FALSE;
        }

    }
    else
#endif
   {
        hpmem1 = (UINT HUGE_T *) lpmem1;
        hpmem2 = (UINT HUGE_T *) lpmem2;

        while (words--) {
            if (*hpmem1++ != *hpmem2++)
                return FALSE;
        }

	 	  lpmem1 = (LPSTR)hpmem1;
		  lpmem2 = (LPSTR)hpmem2;

        for (; bytes-- ; ) {
            if ( *lpmem1++ != *lpmem2++ )
                return FALSE;
        }
    }

    return TRUE;
}


void FARINTERNAL UtilMemCpy (
    LPSTR   lpdst,
    LPSTR   lpsrc,
    DWORD   dwCount
){
    UINT HUGE_T * hpdst;
    UINT HUGE_T * hpsrc;
    DWORD       words;
    DWORD       bytes;
							
    bytes = dwCount %  MAPVALUE(2,4);
    words = dwCount >> MAPVALUE(1,2);//* we compare DWORDS
                                     //* in the 32 bit version
#ifdef WIN16
    if (dwCount <= KB_64) {
        UINT FAR  * lpwDst = (UINT FAR *) lpdst;
        UINT FAR  * lpwSrc = (UINT FAR *) lpsrc;

        while (words--)
            *lpwDst++ = *lpwSrc++;

        if (bytes)
            * (char FAR *) lpwDst = * (char FAR *) lpwSrc;
    }
    else
#endif			
    {			
        hpdst = (UINT HUGE_T *) lpdst;
        hpsrc = (UINT HUGE_T *) lpsrc;

        for(;words--;    )
            *hpdst++ = *hpsrc++;

        lpdst = (LPSTR)hpdst;
        lpsrc = (LPSTR)hpsrc;
		
        for (;bytes--;)
            *lpdst++ = *lpsrc++;
    }
}


//DuplicateData: Duplicates a given Global data handle.
HANDLE FARINTERNAL DuplicateGlobal (
    HANDLE  hdata,
    UINT    flags
){
    LPSTR   lpdst = NULL;
    LPSTR   lpsrc = NULL;
    HANDLE  hdup  = NULL;
    DWORD   size;
    BOOL    err   = TRUE;

    if (!hdata)
        return NULL;

    if(!(lpsrc = GlobalLock (hdata)))
        return NULL;

    hdup = GlobalAlloc (flags, (size = (DWORD)GlobalSize(hdata)));

    if(!(lpdst = GlobalLock (hdup)))
        goto errRtn;;

    err = FALSE;
    UtilMemCpy (lpdst, lpsrc, size);

errRtn:
    if(lpsrc)
        GlobalUnlock (hdata);

    if(lpdst)
        GlobalUnlock (hdup);

    if (err && hdup) {
        GlobalFree (hdup);
        hdup = NULL;
    }

    return hdup;
}


BOOL FARINTERNAL CmpGlobals (
    HANDLE  hdata1,
    HANDLE  hdata2
){
    LPSTR       lpdata1 = NULL;
    LPSTR       lpdata2 = NULL;
    DWORD       size1;
    DWORD       size2;
    BOOL        retval = FALSE;


    size1 = (DWORD)GlobalSize (hdata1);
    size2 = (DWORD)GlobalSize (hdata2);

    if (size1 != size2)
        return FALSE;

    if (!(lpdata1 = GlobalLock (hdata1)))
        goto errRtn;

    if (!(lpdata2 = GlobalLock (hdata2)))
        goto errRtn;

    retval = UtilMemCmp (lpdata1, lpdata2, size1);

errRtn:
    if (lpdata1)
        GlobalUnlock (hdata1);

    if (lpdata2)
        GlobalUnlock (hdata2);

    return retval;
}


int  FARINTERNAL GlobalGetAtomLen (
    ATOM    aItem
){
    // !!! Change this
    char    buf[MAX_STR];

    if (!aItem)
        return 0;

    return (GlobalGetAtomName (aItem, (LPSTR)buf, MAX_STR));

}


BOOL FARINTERNAL MapExtToClass (
    LPSTR   lptemplate,
    LPSTR   lpbuf,
    int     len
){
    LONG    cb;
	 LPSTR    lpstrBack = NULL;

	 while (*lptemplate)
       {
		 if ((*lptemplate) == '\\'){
			 lpstrBack = lptemplate ;
			 }

		 lptemplate ++ ;
		 }

    while (lpstrBack && *lpstrBack && *lpstrBack != '.')
		 lpstrBack++ ;


    cb = len;
    if (lpstrBack == NULL || *(lpstrBack+1) == '\0')
        return FALSE;

    if (RegQueryValue (HKEY_CLASSES_ROOT, lpstrBack, lpbuf, &cb))
        return FALSE;

    return TRUE;
}


// Get exe name from aClass and set it as aServer
void INTERNAL SetExeAtom (
    LPOBJECT_LE lpobj
){
    char    key[MAX_STR];

    // if old link object assume the class same as the exe file name.
    if (lpobj->bOldLink)
        lpobj->aServer = DuplicateAtom (lpobj->app);
    else {
        if (GlobalGetAtomName (lpobj->app, key, sizeof(key)))
            lpobj->aServer = GetAppAtom ((LPSTR)key);
    }
}


ATOM FARINTERNAL GetAppAtom (
    LPCSTR   lpclass
){
    char    buf1[MAX_STR];


    if (!QueryApp (lpclass, PROTOCOL_EDIT, buf1)) {
        return (ATOM)0;
    }

    return GlobalAddAtom ((LPSTR)buf1);
}


BOOL FARINTERNAL QueryVerb (
    LPOBJECT_LE lpobj,
    UINT        verb,
    LPSTR       lpbuf,
    LONG        cbmax
){
    LONG    cb = MAX_STR;
    char    key[MAX_STR];
    // do not need 256 bytes buffer
    char    class[MAX_STR];
    int     len;

    if (!GlobalGetAtomName (lpobj->app, (LPSTR)class, sizeof(class)))
        return FALSE;

    lstrcpy (key, (LPSTR)class);
    lstrcat (key, "\\protocol\\StdFileEditing\\verb\\");
    len = lstrlen (key);
    key [len++] = (char) ('0' + verb);
    key [len++] = 0;

    if (RegQueryValue (HKEY_CLASSES_ROOT, key, lpbuf, &cbmax))
        return FALSE;
    return TRUE;
}




BOOL QueryApp (
    LPCSTR  lpclass,
    LPCSTR  lpprotocol,
    LPSTR   lpbuf
){
    LONG    cb = MAX_STR;
    char    key[MAX_STR];

    lstrcpy (key, lpclass);
    lstrcat (key, "\\protocol\\");
    lstrcat (key, lpprotocol);
    lstrcat (key, "\\server");

    if (RegQueryValue (HKEY_CLASSES_ROOT, key, lpbuf, &cb))
        return FALSE;
    return TRUE;
}


HANDLE MapStrToH (
    LPSTR   lpstr
){

    HANDLE  hdata  = NULL;
    LPSTR   lpdata = NULL;

    hdata = GlobalAlloc (GMEM_DDESHARE, lstrlen (lpstr) + 1);
    if (hdata == NULL || (lpdata = (LPSTR)GlobalLock (hdata)) == NULL)
        goto errRtn;

    lstrcpy (lpdata, lpstr);
    GlobalUnlock (hdata);
    return hdata;

errRtn:
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);
    return NULL;
}


HANDLE FARINTERNAL CopyData (
    LPSTR       lpsrc,
    DWORD       dwBytes
){
    HANDLE  hnew;
    LPSTR   lpnew;
    BOOL    retval = FALSE;

    if (hnew = GlobalAlloc (GMEM_MOVEABLE, dwBytes)){
        if (lpnew = GlobalLock (hnew)){
            UtilMemCpy (lpnew, lpsrc, dwBytes);
            GlobalUnlock (hnew);
            return hnew;
        }
        else
            GlobalFree (hnew);
    }

    return NULL;
}

void  UtilMemClr (
    PSTR    pstr,
    UINT    size
){

    while (size--)
        *pstr++ = 0;

}


OLESTATUS FAR PASCAL ObjQueryName (
    LPOLEOBJECT lpobj,
    LPSTR       lpBuf,
    UINT FAR *  lpcbBuf
){
    if (lpobj->ctype != CT_LINK && lpobj->ctype != CT_EMBEDDED
            && lpobj->ctype != CT_STATIC)
        return OLE_ERROR_OBJECT;

    PROBE_WRITE(lpBuf);
    if (!*lpcbBuf)
        return OLE_ERROR_SIZE;

    if (!CheckPointer(lpBuf+*lpcbBuf-1, WRITE_ACCESS))
        return OLE_ERROR_SIZE;

    ASSERT(lpobj->aObjName, "object name ATOM is NULL\n");
    *lpcbBuf = GlobalGetAtomName (lpobj->aObjName, lpBuf, *lpcbBuf);
    return OLE_OK;
}


OLESTATUS FAR PASCAL ObjRename (
    LPOLEOBJECT lpobj,
    LPCSTR      lpNewName
){
    if (lpobj->ctype != CT_LINK && lpobj->ctype != CT_EMBEDDED
            && lpobj->ctype != CT_STATIC)
        return OLE_ERROR_OBJECT;

    PROBE_READ(lpNewName);
    if (!lpNewName[0])
        return OLE_ERROR_NAME;

    if (lpobj->aObjName)
        GlobalDeleteAtom (lpobj->aObjName);
    lpobj->aObjName = GlobalAddAtom (lpNewName);
    return OLE_OK;
}




BOOL QueryHandler(
    UINT cfFormat
){
    HANDLE  hInfo = NULL;
    LPSTR   lpInfo = NULL;
    BOOL    fRet = FALSE, fOpen = FALSE;
    LONG    cb = MAX_STR;
    char    str[MAX_STR];
    HKEY    hKey;

    // we don't have the client app window handle, use the screen handle
    fOpen = OpenClipboard (NULL);

    if (!(hInfo = GetClipboardData (cfFormat)))
        goto errRtn;

    if (!(lpInfo = GlobalLock(hInfo)))
        goto errRtn;

    // First string of lpInfo is CLASS. See whether any handler is installed
    // for this class.

    lstrcpy (str, lpInfo);
    lstrcat (str, "\\protocol\\StdFileEditing\\handler");
    if (RegOpenKey (HKEY_CLASSES_ROOT, str, &hKey))
        goto errRtn;
    RegCloseKey (hKey);
    fRet = TRUE;

errRtn:
    if (lpInfo)
        GlobalUnlock (hInfo);

    if (fOpen)
        CloseClipboard();
    return fRet;
}

OLESTATUS INTERNAL FileExists (
    LPOBJECT_LE lpobj
){
    char        filename[MAX_STR];
    OFSTRUCT    ofstruct;

    if (!GlobalGetAtomName (lpobj->topic, filename, MAX_STR))
        return OLE_ERROR_MEMORY;

    // For package with link we append "/LINK" to the filename. We don't want
    // to check for it's existence here.
    if (lpobj->app != aPackage) {
        // when OF_EXIST is specified, file is opened and closed immediately
        if (OpenFile (filename, &ofstruct, OF_EXIST) == -1)
            return OLE_ERROR_OPEN;
    }

    return OLE_OK;
}


BOOL  FARINTERNAL UtilQueryProtocol (
    LPOBJECT_LE lpobj,
    LPCSTR      lpprotocol
){
    char    buf[MAX_STR];
    ATOM    aExe;

    if (!GlobalGetAtomName (lpobj->app, (LPSTR) buf, MAX_STR))
        return FALSE;

    if (!QueryApp (buf, lpprotocol, (LPSTR) buf))
        return FALSE;

    aExe = GlobalAddAtom (buf);
    if (aExe)
        GlobalDeleteAtom (aExe);
    if (aExe != lpobj->aServer)
        return FALSE;

    return TRUE;
}

#ifdef WIN16
WORD FARINTERNAL FarCheckPointer (lp, iAccessType)
LPVOID  lp;
int     iAccessType;
{
    return (CheckPointer (lp, iAccessType));
}
#endif


DWORD PASCAL FAR DllPut (
    LPOLESTREAM lpstream,
    OLE_CONST void FAR *lpstr,
    DWORD       dwSize
){
    UNREFERENCED_PARAMETER(lpstream);
    UNREFERENCED_PARAMETER(lpstr);

    dwObjSize += dwSize;
    return dwSize;
}



OLESTATUS FARINTERNAL ObjQueryType (
    LPOLEOBJECT lpobj,
    LPLONG      lptype
){
    Puts("ObjQueryType");

    if (lpobj->ctype != CT_STATIC)
        return OLE_ERROR_OBJECT;

    *lptype = lpobj->ctype;
    return OLE_OK;
}

OLESTATUS FARINTERNAL ObjQuerySize (
    LPOLEOBJECT    lpobj,
    DWORD FAR *    lpdwSize
){
    Puts("ObjQuerySize");

    *lpdwSize = dwObjSize = 0;

    if ((*lpobj->lpvtbl->SaveToStream) (lpobj, &dllStream) == OLE_OK) {
        *lpdwSize = dwObjSize;
        return OLE_OK;
    }

    return OLE_ERROR_BLANK;
}

BOOL FARINTERNAL IsObjectBlank (
    LPOBJECT_LE lpobj
){
    LPOLEOBJECT lpPictObj;
    BOOL        retval=FALSE;

    // Cleaner way is to provide a method like QueryBlank()

    if (!lpobj->hnative)
        return TRUE;

    if (!(lpPictObj = lpobj->lpobjPict))
        return FALSE;

    if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblMF)
        retval = (((LPOBJECT_MF)lpPictObj)->hmfp != NULL);
    else if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblBM)
        retval = (((LPOBJECT_BM)lpPictObj)->hBitmap != NULL);
    if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblDIB)
        retval = (((LPOBJECT_DIB)lpPictObj)->hDIB != NULL);
    if (lpPictObj->lpvtbl == (LPOLEOBJECTVTBL)&vtblGEN)
        retval = (((LPOBJECT_GEN)lpPictObj)->hData != NULL);

    return retval;
}

BOOL FAR PASCAL OleIsDcMeta (HDC hdc)
{
#ifdef WIN16
    if (!bWLO && (wWinVer == 0x0003)) {

        WORD    wDsAlias, wGDIcs = HIWORD(SaveDC);
        WORD    wOffset = LOWORD(((DWORD)SaveDC));
        WORD FAR PASCAL AllocCStoDSAlias (WORD);
        WORD FAR PASCAL FreeSelector (WORD);

        if (!wGDIds) {
            wDsAlias = AllocCStoDSAlias (wGDIcs);
            wGDIds = GetGDIds (MAKELONG(wOffset, wDsAlias));
            FreeSelector (wDsAlias);
        }

        return IsMetaDC (hdc, wGDIds);
    }
    else
#endif
        return (GetDeviceCaps (hdc, TECHNOLOGY) == DT_METAFILE);
}

void ConvertBM32to16(
   LPBITMAP      lpsrc,
   LPWIN16BITMAP lpdest
){

#ifdef WIN32
    lpdest->bmType       = (short)lpsrc->bmType;
    lpdest->bmWidth      = (short)lpsrc->bmWidth;
    lpdest->bmHeight     = (short)lpsrc->bmHeight;
    lpdest->bmWidthBytes = (short)lpsrc->bmWidthBytes;
    lpdest->bmPlanes     = (BYTE)lpsrc->bmPlanes;
    lpdest->bmBitsPixel  = (BYTE)lpsrc->bmBitsPixel;
#endif

#ifdef WIN16
    *lpdest = *lpsrc;
#endif

}

void ConvertBM16to32(
   LPWIN16BITMAP lpsrc,
   LPBITMAP     lpdest
){

#ifdef WIN32
    lpdest->bmType       = MAKELONG(lpsrc->bmType,NULL_WORD);
    lpdest->bmWidth      = MAKELONG(lpsrc->bmWidth,NULL_WORD);
    lpdest->bmHeight     = MAKELONG(lpsrc->bmHeight,NULL_WORD);
    lpdest->bmWidthBytes = MAKELONG(lpsrc->bmWidthBytes,NULL_WORD);
    lpdest->bmPlanes     = (WORD)lpsrc->bmPlanes;
    lpdest->bmBitsPixel  = (WORD)lpsrc->bmBitsPixel;
#endif

#ifdef WIN16
    *lpdest = *lpsrc;
#endif

}
void ConvertMF16to32(
   LPWIN16METAFILEPICT lpsrc,
   LPMETAFILEPICT      lpdest
){

#ifdef WIN32
   lpdest->mm     = (DWORD)lpsrc->mm;
   lpdest->xExt   = (DWORD)MAKELONG(lpsrc->xExt,NULL_WORD);
   lpdest->yExt   = (DWORD)MAKELONG(lpsrc->yExt,NULL_WORD);
#endif

#ifdef WIN16
   *lpdest = *lpsrc;
#endif

}


void ConvertMF32to16(
   LPMETAFILEPICT      lpsrc,
   LPWIN16METAFILEPICT lpdest
){

#ifdef WIN32
   lpdest->mm     = (short)lpsrc->mm;
   lpdest->xExt   = (short)lpsrc->xExt;
   lpdest->yExt   = (short)lpsrc->yExt;
#endif

#ifdef WIN16
   *lpdest = *lpsrc;
#endif

}

DWORD INTERNAL GetFileVersion(LPOLEOBJECT lpoleobj)
{

   if (lpoleobj->lhclientdoc)
      return ((LPCLIENTDOC)(lpoleobj->lhclientdoc))->dwFileVer;

   if (lpoleobj->lpParent)
      return GetFileVersion(lpoleobj->lpParent);

   return (DWORD)MAKELONG(wReleaseVer,OS_WIN32);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\stream.h ===
/*
 * stream.h - OLE stream I/O headers.
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** CONSTANTS ***

#define MAXREAD   ((LONG)  (60L * 1024L))

//*** GLOBALS ***

extern DWORD    vcbObject;

//*** PROTOTYPES ***

//* OLE callbacks

DWORD  APIENTRY ReadStream(LPAPPSTREAM, LPSTR, DWORD);
DWORD  APIENTRY WriteStream(LPAPPSTREAM, LPSTR, DWORD);

//* Far

BOOL FAR          WriteToFile(LPAPPSTREAM);
BOOL FAR          ObjWrite(LPAPPSTREAM, APPITEMPTR);
BOOL FAR          ReadFromFile(LPAPPSTREAM, LHCLIENTDOC, LPOLECLIENT);
BOOL FAR          ObjRead(LPAPPSTREAM, LHCLIENTDOC, LPOLECLIENT);

//* Local

DWORD             lread(int, VOID FAR *, DWORD);
DWORD             lwrite(int, VOID FAR *, DWORD);
static VOID       UpdateLinks(LHCLIENTDOC);
static VOID       UpdateFromOpenServers(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\register.c ===
/*
 * register.c - Handles the Win 3.1 registration library.
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** INCLUDES ***

#include <windows.h>
#include <ole.h>

#include "global.h"
#include "register.h"
#include "clidemo.h"	 
#include "demorc.h"   

/****************************************************************************
 * RegGetClassId() - Retrieves the string name of a class.
 *
 * Retrieve the string name of a class. Classes are guarenteed to be 
 * in ASCII, but should not be used directly as a rule because they
 * might be meaningless if running non-English Windows.
 ***************************************************************************/

VOID FAR RegGetClassId(                //* ENTRY:
   LPSTR    lpstrName,                 //* destination string name of class
   LPSTR    lpstrClass                 //* source name of class
){                                     //* LOCAL:
   DWORD    dwSize = KEYNAMESIZE;      //* size of keyname string 
   CHAR     szName[KEYNAMESIZE];       //* string name for class 

   if (!RegQueryValue(HKEY_CLASSES_ROOT, lpstrClass, (LPSTR)szName, &dwSize))
	   lstrcpy(lpstrName, (LPSTR)szName);
   else
	   lstrcpy(lpstrName, lpstrClass);

}



/***************************************************************************
 *  RegMakeFilterSpec() - Retrieves class-associated default extensions.
 *
 * Get the class-associated default extensions, and build a filter spec, 
 * to be used in the "Change Link" standard dialog box, which contains 
 * all the default extensions which are associated with the given class 
 * name.  Again, the class names are guaranteed to be in ASCII.
 *
 * Returns int - The index idFilterIndex states which filter item 
 *               matches the extension, or 0 if none is found.
 ***************************************************************************/

INT FAR RegMakeFilterSpec(             //* ENTRY:
   LPSTR          lpstrClass,          //* class name
   LPSTR          lpstrExt,            //* file extension
   LPSTR          lpstrFilterSpec      //* destination filter spec
){                                     //* LOCAL:
   DWORD          dwSize;              //* size of reg request
   CHAR           szClass[KEYNAMESIZE];//* class name 
   CHAR           szName[KEYNAMESIZE]; //* name of subkey 
   CHAR           szString[KEYNAMESIZE];//* name of subkey 
   INT            i;                    //* index of subkey query 
   INT            idWhich = 0;          //* index of combo box item 
   INT            idFilterIndex = 0;    //* index to filter matching extension 

   for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szName, KEYNAMESIZE); ) 
   {
      if (  *szName == '.'             //* Default Extension...
            && (dwSize = KEYNAMESIZE)
            && !RegQueryValue(HKEY_CLASSES_ROOT, szName, szClass, &dwSize)
            && (!lpstrClass || !lstrcmpi(lpstrClass, szClass))
            && (dwSize = KEYNAMESIZE)
            && !RegQueryValue(HKEY_CLASSES_ROOT, szClass, szString, &dwSize)) 
      {
         idWhich++;	

         if (lpstrExt && !lstrcmpi(lpstrExt, szName))
            idFilterIndex = idWhich;
                                       //* Copy over "<Class Name String> 
                                       //* (*<Default Extension>)"
                                       //* e.g. "Server Picture (*.PIC)"
         lstrcpy(lpstrFilterSpec, szString);
         lstrcat(lpstrFilterSpec, " (*");
         lstrcat(lpstrFilterSpec, szName);
         lstrcat(lpstrFilterSpec, ")");
         lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;
                                       //* Copy over "*<Default Extension>" 
                                       //* (e.g. "*.PIC") */
         lstrcpy(lpstrFilterSpec, "*");
         lstrcat(lpstrFilterSpec, szName);
         lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;
      }
   }
   
   *lpstrFilterSpec = 0;

   return idFilterIndex;

}



/***************************************************************************
 *  RegCopyClassName()
 *
 *  Get the class name from the registration data base.  We have the
 *  descriptive name and we search for the class name.
 *
 *  returns BOOL - TRUE if class name was found and retrieved from the
 *                 registration database.
 ***************************************************************************/

BOOL FAR RegCopyClassName(             //* ENTRY:
   HWND           hwndList,            //* HANDLE to list box 
   LPSTR          lpstrClassName       //* destination character string
){                                     //* LOCAL:
   DWORD          dwSize;              //* key name size
   HKEY           hkeyTemp;            //* temp key
   CHAR           szClass[KEYNAMESIZE];//* class name string
   CHAR           szKey[KEYNAMESIZE];  //* key name string
   INT            i;                   //* index

   szClass[0] = '\0';

   if (!RegOpenKey(HKEY_CLASSES_ROOT, szClass, &hkeyTemp)) 
   {
      i = (INT)SendMessage(hwndList, LB_GETCURSEL, 0, 0L);
      SendMessage(hwndList, LB_GETTEXT, i, (DWORD)(LPSTR)szKey);

      for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szClass, KEYNAMESIZE); )
         if (*szClass != '.') 
         {
            dwSize = KEYNAMESIZE;
            if (!RegQueryValue(HKEY_CLASSES_ROOT, szClass, lpstrClassName, &dwSize))
               if (!lstrcmp(lpstrClassName, szKey))
               {
                    RegCloseKey(hkeyTemp);
                    lstrcpy(lpstrClassName,szClass);    
                    return TRUE;
                }
         }
      RegCloseKey(hkeyTemp);
   }

   *lpstrClassName = 0;
   return FALSE;

}



/***************************************************************************
 *  RegGetClassNames()
 *
 *  Fills in the list box in the Insert New dialog with the names of 
 *  OLE Servers.
 *
 *  returns TRUE if the listbox filled successfully.
 **************************************************************************/

BOOL FAR RegGetClassNames(       //* ENTRY:
   HWND hwndList                 //* HANDLE to the listbox being filled
){                               //* LOCAL:
   DWORD    dwSize;              //* sixe of data
   HKEY     hkeyTemp;            //* temporary registration key
   CHAR     szExec[KEYNAMESIZE]; //* executables name 
   CHAR     szClass[KEYNAMESIZE];//* class name
   CHAR     szName[KEYNAMESIZE]; //* key name
   INT      i;                   

   SendMessage(hwndList, LB_RESETCONTENT, 0, 0L);

   szClass[0]='\0';

   if (!RegOpenKey(HKEY_CLASSES_ROOT, szClass, &hkeyTemp)) 
   {
      for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szClass, KEYNAMESIZE); )
         if (*szClass != '.') 
         {         
            lstrcpy(szExec, szClass);
            lstrcat(szExec, "\\protocol\\StdFileEditing\\server");
            dwSize = KEYNAMESIZE;
            if (!RegQueryValue(HKEY_CLASSES_ROOT, szExec, szName, &dwSize)) 
            {
               dwSize = KEYNAMESIZE;
               if (!RegQueryValue(HKEY_CLASSES_ROOT, szClass, szName, &dwSize)) 
                  SendMessage(hwndList, LB_ADDSTRING, 0, (DWORD)(LPSTR)szName);
            }
         }
      RegCloseKey(hkeyTemp);
      return TRUE;
   }
   return FALSE;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\global.h ===
/*
 * global.h
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** CONSTANTS ***

#define PROTOCOL_STRLEN    15          //* protocol name string size
#define CFILTERMAX         200	         //* Max # filters
                                       //* Max # chars/filter
#define CBFILTERMAX        (100 * CFILTERMAX)
#define CBPATHMAX          250         //* max qualified file name
#define CBOBJNAMEMAX       14          //* maximum length of object name
#define CBVERBTEXTMAX      30          //* maximum length of verb text
#define CBVERBNUMBMAX      8           //* maximum number of verbs
#define OBJECT_LINK_MAX    256*3       //* maximum size of object link data
#define CDIGITSMAX         5
#define KEYNAMESIZE        300         //* Maximum registration key length
#define RETRY              3
                                       //* protocol name strings
#define STDFILEEDITING     ((LPSTR)"StdFileEditing")
#define STATICP            ((LPSTR)"Static")
                                       //* object name prefixes
#define OBJPREFIX          ((LPSTR)"CliDemo #")
#define OBJCLONE           ((LPSTR)"CliDemo1#")
#define OBJTEMP            ((LPSTR)"CliDemo2#")

#define DOC_CLEAN          0           //* Dirty() methods
#define DOC_DIRTY          1
#define DOC_UNDIRTY        2
#define DOC_QUERY          3

#define OLE_OBJ_RELEASE   FALSE       //* object deletion type
#define OLE_OBJ_DELETE    TRUE

#define WM_ERROR           WM_USER + 1 //* user defined messages
#define WM_INIT            WM_USER + 2
#define WM_DELETE          WM_USER + 3
#define WM_RETRY           WM_USER + 4
#define WM_CHANGE          WM_USER + 5

#define RD_CANCEL          0x00000001
#define RD_RETRY           0x00000002

//*** TYPES ***

typedef struct _APPSTREAM FAR *LPAPPSTREAM;

typedef struct _APPSTREAM {
    OLESTREAM        olestream;
    INT              fh;
} APPSTREAM;

typedef struct _APPITEM *APPITEMPTR;

typedef struct _APPITEM {              //* Application item
   OLECLIENT         oleclient;
   HWND              hwnd;
   LPOLEOBJECT       lpObject;         //* OLE object pointers
   LPOLEOBJECT       lpObjectUndo;     //* undo object
   LONG              otObject;         //* OLE object type
   LONG              otObjectUndo;
   OLEOPT_UPDATE     uoObject;         //* OLE object update option
   OLEOPT_UPDATE     uoObjectUndo;     //* link name atom
   ATOM              aLinkName;        //* Save the link's document name
   ATOM              aLinkUndo;        //* Save the link's document name
   LPSTR             lpLinkData;       //* pointer to link data
   BOOL              fVisible;         //* TRUE: item is to be displayed
   BOOL              fOpen;            //* server open? --for undo objects
   BOOL              fRetry;           //* retry flag for busy servers
   BOOL              fNew;
   BOOL              fServerChangedBounds;
   RECT              rect;             //* bounding rectangle
   LHCLIENTDOC       lhcDoc;           //* client document handle
   ATOM              aServer;
} APPITEM;


typedef struct _RETRY *RETRYPTR;

typedef struct _RETRY {                //* Application item
   LPSTR       lpserver;
   BOOL        bCancel;
   APPITEMPTR  paItem;
} RETRYSTRUCT;

//*** GLOBALS ***

extern OLECLIPFORMAT vcfLink;          //* ObjectLink clipboard format
extern OLECLIPFORMAT vcfNative;        //* Native clipboard format
extern OLECLIPFORMAT vcfOwnerLink;     //* OwnerLink clipboard format

extern HANDLE        hInst;            //* instance handle
extern HWND        hwndFrame;        //* main window handle
extern HANDLE        hAccTable;        //* accelerator table
extern HWND          hwndProp;         //* link properties dialog
extern HWND          hRetry;           //* retry dialog box handle
extern INT           cOleWait;         //* wait for asyncc commands
extern INT           iObjects;         //* object count
extern INT           iObjectNumber;    //* unique name id
extern CHAR          szItemClass[];    //* item class name
extern CHAR          szDefExtension[]; //* default file extension
extern CHAR          szAppName[];      //* application name
extern BOOL          fLoadFile;        //* load file flag
extern CHAR          szFileName[];     //* open file name
extern FARPROC       lpfnTimerProc;    //* pointer to timer callback function
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\utility.h ===
/* 
 * utility.h 
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** PROTO TYPES ***

//* FAR  
BOOL FAR          ObjectsBusy(VOID);
VOID FAR          WaitForAllObjects(VOID);
VOID FAR          WaitForObject(APPITEMPTR);
VOID FAR          ErrorMessage(DWORD);
VOID FAR          Hourglass(BOOL);
BOOL FAR          DisplayBusyMessage (APPITEMPTR);
BOOL FAR          Dirty(INT);
LPSTR FAR         CreateNewUniqueName(LPSTR);
BOOL FAR          ValidateName(LPSTR);
BOOL FAR          ProcessMessage(HWND, HANDLE);
VOID FAR          FreeAppItem(APPITEMPTR);
LONG FAR          SizeOfLinkData (LPSTR);
VOID FAR          ShowDoc(LHCLIENTDOC, INT);
APPITEMPTR FAR    GetTopItem(VOID);
VOID FAR          SetTopItem(APPITEMPTR);
APPITEMPTR FAR    GetNextActiveItem(VOID);
APPITEMPTR FAR    GetNextItem(APPITEMPTR);
BOOL FAR          ReallocLinkData(APPITEMPTR,LONG);
BOOL FAR          AllocLinkData(APPITEMPTR,LONG);
VOID FAR          FreeLinkData(LPSTR);
VOID FAR          ShowNewWindow(APPITEMPTR);
PSTR FAR          UnqualifyPath(PSTR);
VOID CALLBACK     fnTimerBlockProc(HWND, UINT, UINT, DWORD);
BOOL FAR          ToggleBlockTimer(BOOL);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\dialog.c ===
/*
 * dialog.c - Handles the Windows 3.1 common dialogs.
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** INCLUDES ****

#include <windows.h>                   //* WINDOWS
#include <ole.h>                       //* OLE

#include "global.h"                    //* global
#include "demorc.h"                    //* String table constants
#include "register.h"                  //* Class registration library
#include "utility.h"
#include "dialog.h"
#include "object.h"

//*** GLOBALS ***
                                       //* strings used with commdlg
CHAR        szDefExtension[CBMESSAGEMAX];
CHAR        szFilterSpec[CBFILTERMAX];
CHAR        szInsertFilter[CBFILTERMAX];
CHAR        szLastDir[CBPATHMAX];
OPENFILENAME OFN;
HWND        hwndProp = NULL;
HWND        hRetry;

/***************************************************************************
 * OfnInit()
 * Initializes the standard file dialog OFN structure.
 **************************************************************************/

VOID FAR OfnInit(                      //* ENTRY:
   HANDLE         hInst                //* instance handle
){                                     //* LOCAL:
   LPSTR          lpstr;               //* string pointer

   LoadString(hInst, IDS_FILTER, szFilterSpec, CBMESSAGEMAX);
   LoadString(hInst, IDS_EXTENSION, szDefExtension, CBMESSAGEMAX);

   OFN.lStructSize    = sizeof(OPENFILENAME);
   OFN.hInstance      = hInst;
   OFN.nMaxCustFilter = CBFILTERMAX;
   OFN.nMaxFile       = CBPATHMAX;
   OFN.lCustData      = 0;
   OFN.lpfnHook       = NULL;
   OFN.lpTemplateName = NULL;
   OFN.lpstrFileTitle = NULL;
                                       //* Construct the filter string
                                       //* for the Open and Save dialogs
   lpstr = (LPSTR)szFilterSpec;
   lstrcat(lpstr, " (*.");
   lstrcat(lpstr, szDefExtension);
   lstrcat(lpstr, ")");
   lpstr += lstrlen(lpstr) + 1;

   lstrcpy(lpstr, "*.");
   lstrcat(lpstr, szDefExtension);
   lpstr += lstrlen(lpstr) + 1;
   *lpstr = 0;

   RegMakeFilterSpec(NULL, NULL, (LPSTR)szInsertFilter);

}

/***************************************************************************
 * OfnGetName()
 *
 * Calls the standard file dialogs to get a file name
 **************************************************************************/

BOOL FAR OfnGetName(                   //* ENTRY:
   HWND           hwnd,                //* parent window handle
   LPSTR          szFileName,          //* File name
   WORD           msg                  //* operation
){                                     //* LOCAL:
   BOOL           frc;                 //* return flag
   CHAR           szCaption[CBMESSAGEMAX];//* dialog caption

   OFN.hwndOwner       = hwnd;               //* window
   OFN.nFilterIndex    = 1;
   OFN.lpstrInitialDir = (LPSTR)szLastDir;
   OFN.Flags           = OFN_HIDEREADONLY;

   switch (msg)                        //* message
   {
      case IDM_OPEN:                   //* open file
         Normalize(szFileName);
         OFN.lpstrDefExt = (LPSTR)szDefExtension;
         OFN.lpstrFile   = (LPSTR)szFileName;
         OFN.lpstrFilter = (LPSTR)szFilterSpec;
         LoadString(hInst, IDS_OPENFILE, szCaption, CBMESSAGEMAX);
         OFN.lpstrTitle  = (LPSTR)szCaption;
         OFN.Flags       |= OFN_FILEMUSTEXIST;
         return GetOpenFileName((LPOPENFILENAME)&OFN);
         break;

      case IDM_SAVEAS:                 //* save as file
         Normalize(szFileName);
         OFN.lpstrDefExt = (LPSTR)szDefExtension;
         OFN.lpstrFile   = (LPSTR)szFileName;
         OFN.lpstrFilter = (LPSTR)szFilterSpec;
         LoadString(hInst, IDS_SAVEFILE, szCaption, CBMESSAGEMAX);
         OFN.lpstrTitle  = (LPSTR)szCaption;
         OFN.Flags       |= OFN_PATHMUSTEXIST;
         return GetSaveFileName((LPOPENFILENAME)&OFN);
         break;

      case IDM_INSERTFILE:             //* insert file
         OFN.lpstrDefExt = NULL;
         OFN.lpstrFile   = (LPSTR)szFileName;
         OFN.lpstrFilter = (LPSTR)szInsertFilter;
         LoadString(hInst, IDS_INSERTFILE, szCaption, CBMESSAGEMAX);
         OFN.lpstrTitle  = (LPSTR)szCaption;
         OFN.Flags      |= OFN_FILEMUSTEXIST;
         frc             = GetOpenFileName((LPOPENFILENAME)&OFN);
         AddExtension(&OFN);
         return frc;
         break;

      default:                         //* default
         break;
   }

   return FALSE;
}

/***************************************************************************
 * OfnGetNewLinkName() - Sets up the "Change Link..." dialog box
 *
 * returns LPSTR - fully qualified filename
 **************************************************************************/

LPSTR FAR OfnGetNewLinkName(           //* ENTRY:
   HWND           hwnd,                //* calling window or dialog
   LPSTR          lpstrData            //* link data
){                                     //* LOCAL:
   LPSTR          lpReturn = NULL;     //* return string
   LPSTR          lpstrFile = NULL;    //* non-qualified file name
   LPSTR          lpstrPath = NULL;    //* pathname
   LPSTR          lpstrTemp = NULL;    //* work string
   CHAR           szDocFile[CBPATHMAX];//* document name
   CHAR           szDocPath[CBPATHMAX];//* document path name
   CHAR           szServerFilter[CBPATHMAX];
   CHAR           szCaption[CBMESSAGEMAX];

                                       //* Figure out the link's path
                                       //* name and file name
   lpstrTemp = lpstrData;
   while (*lpstrTemp++);
   lpstrPath = lpstrFile = lpstrTemp;

   while (*(lpstrTemp = AnsiNext(lpstrTemp)))
      if (*lpstrTemp == '\\')
         lpstrFile = lpstrTemp + 1;
                                        //* Copy the document name
   lstrcpy(szDocFile, lpstrFile);
   *(lpstrFile - 1) = 0;
                                          //* Copy the path name
   lstrcpy(szDocPath, ((lpstrPath != lpstrFile) ? lpstrPath : ""));
   if (lpstrPath != lpstrFile)           //* Restore the backslash
      *(lpstrFile - 1) = '\\';
   while (*lpstrFile != '.' && *lpstrFile)//* Get the extension
   lpstrFile++;
                                          //* Make a filter that respects
                                          //* the link's class name
   OFN.hwndOwner       = hwnd;
   OFN.nFilterIndex    = RegMakeFilterSpec(lpstrData, lpstrFile, szServerFilter);
   OFN.lpstrDefExt     = NULL;
   OFN.lpstrFile       = (LPSTR)szDocFile;
   OFN.lpstrFilter     = (LPSTR)szServerFilter;
   OFN.lpstrInitialDir = (LPSTR)szDocPath;
   LoadString(hInst, IDS_CHANGELINK, szCaption, CBMESSAGEMAX);
   OFN.lpstrTitle     = (LPSTR)szCaption;
   OFN.lpstrCustomFilter = NULL;
   OFN.Flags          = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;

                                           //* If we get a file... */
   if (GetOpenFileName((LPOPENFILENAME)&OFN))
   {
      if (!(lpReturn = GlobalLock(GlobalAlloc(LHND, CBPATHMAX))))
         goto Error;

      AddExtension(&OFN);
      lstrcpy(lpReturn, szDocFile);

      OFN.lpstrInitialDir = (LPSTR)szLastDir;
   }

   return lpReturn;                    //* SUCCESS return

Error:                                 //* ERROR Tag

   return NULL;                        //* ERROR return

}

/***************************************************************************
 * Normalize()
 * Removes the path specification from the file name.
 *
 * Note:  It isn't possible to get "<drive>:<filename>" as input because
 *        the path received will always be fully qualified.
 **************************************************************************/

VOID Normalize(                        //* ENTRY:
   LPSTR          lpstrFile            //* file name
){                                     //* LOCAL:
   LPSTR          lpstrBackslash = NULL;//* back slash
   LPSTR          lpstrTemp = lpstrFile;//* file name

   while (*lpstrTemp)
   {
      if (*lpstrTemp == '\\')
         lpstrBackslash = lpstrTemp;

      lpstrTemp = AnsiNext(lpstrTemp);
   }
   if (lpstrBackslash)
      lstrcpy(lpstrFile, lpstrBackslash + 1);

}

/***************************************************************************
 * AddExtension()
 *
 * Adds the extension corresponding to the filter dropdown.
 **************************************************************************/

VOID AddExtension(                     //* ENTRY:
   LPOPENFILENAME lpOFN                //* open file structure
){

   if (lpOFN->nFileExtension == (WORD)lstrlen(lpOFN->lpstrFile)
         && lpOFN->nFilterIndex)
   {
      LPSTR   lpstrFilter = (LPSTR)lpOFN->lpstrFilter;

      while (*lpstrFilter && --lpOFN->nFilterIndex)
      {
         while (*lpstrFilter++) ;
         while (*lpstrFilter++) ;
      }
                                       //* If we got to the filter,
      if (*lpstrFilter)                //* retrieve the extension
      {
         while (*lpstrFilter++) ;
         lpstrFilter++;
                                       //* Copy the extension
         if (lpstrFilter[1] != '*')
            lstrcat(lpOFN->lpstrFile, lpstrFilter);
      }
   }

}
/****************************************************************************
 *  fnInsertNew()
 *
 *  Dialog procedure for the Insert New dialog.
 *
 *  Returns int - TRUE if message processed, FALSE otherwise
 ***************************************************************************/

BOOL  APIENTRY fnInsertNew(            //* ENTRY:
   HWND           hDlg,                //* standard dialog box paramters
   UINT           msg,
   WPARAM         wParam,
   LPARAM         lParam               //* (LPSTR) class name
){                                     //* LOCAL:
   HWND           hwndList;            //* handle to listbox
   static LPSTR   lpClassName;         //* classname for return value

   hwndList = GetDlgItem(hDlg, IDD_LISTBOX);

   switch (msg)
   {
      case WM_INITDIALOG:
         if (!RegGetClassNames(hwndList))
            EndDialog(hDlg, IDCANCEL);

         lpClassName = (LPSTR)lParam;
         SetFocus(hwndList);
         SendMessage(hwndList, LB_SETCURSEL, 0, 0L);
         return (FALSE);

      case WM_COMMAND:
      {
         WORD wID  = LOWORD(wParam);
         WORD wCmd = HIWORD(wParam);

         switch (wID)
         {
            case IDD_LISTBOX:
               if (wCmd != LBN_DBLCLK)
               break;

            case IDOK:
               if (!RegCopyClassName(hwndList, lpClassName))
                  wParam = IDCANCEL;

            case IDCANCEL:
               EndDialog(hDlg, wParam);
               break;
         }
         break;
      }
   }
   return FALSE;

}

/***************************************************************************
 * LinkProperties();
 *
 * Manage the link properties dialog box.
 **************************************************************************/

VOID FAR LinkProperties()
{                                      //* LOCAL

   DialogBox (
      hInst,
      MAKEINTRESOURCE(DTPROP),
      hwndFrame,
      (DLGPROC)fnProperties
   );

}

/***************************************************************************
 * fnProperties()
 *
 * Dialog procedure for link properties. The Links dialog allows the user to
 * change the link options, edit/play the object, cancel the link as
 * well change links.
 *
 * returns BOOL - TRUE if processed, FALSE otherwise
 **************************************************************************/

BOOL  APIENTRY fnProperties(           //* ENTRY:
   HWND           hDlg,                //* standard dialog box parameters
   UINT           msg,
   WPARAM         wParam,
   LPARAM         lParam               //* (HWND) child window with focus
){                                     //* LOCAL:
  static APPITEMPTR *pLinks;           //* pointer to links (associated windows)
  static INT      nLinks;              //* number of links
  static HWND     hwndList;            //* handle to listbox window
  static BOOL     fTry;

   switch (msg)
   {
      case WM_INITDIALOG:
         hwndProp = hDlg;
         hwndList = GetDlgItem(hDlg, IDD_LINKNAME);
         if (!(InitLinkDlg(hDlg, &nLinks, hwndList, &pLinks)))
            EndDialog(hDlg, TRUE);
         UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
         break;

      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         switch (wID)
         {
           case IDD_CHANGE:            //* change links
               BLOCK_BUSY(fTry);
               if (ChangeLinks(hDlg,nLinks,hwndList,pLinks))
                  DisplayUpdate(nLinks,hwndList,pLinks, FALSE);
               return TRUE;

           case IDD_FREEZE:            //* cancel links
               BLOCK_BUSY(fTry);
               CancelLinks(hDlg,nLinks,hwndList,pLinks);
               UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
               return TRUE;

           case IDD_UPDATE:            //* update links
               BLOCK_BUSY(fTry);
               DisplayUpdate(nLinks,hwndList,pLinks,TRUE);
               UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
               return TRUE;

            case IDD_AUTO:
            case IDD_MANUAL:           //* change link update options
               BLOCK_BUSY(fTry);
               if (!SendMessage(GetDlgItem(hDlg,wParam),BM_GETCHECK, 0, 0L))
               {
                  CheckRadioButton(hDlg, IDD_AUTO ,IDD_MANUAL ,wParam);
                  ChangeUpdateOptions(hDlg,nLinks,hwndList,pLinks,
                     (wParam == IDD_AUTO ? oleupdate_always : oleupdate_oncall));
                  UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
               }
               return TRUE;

           case IDD_LINKNAME:
               if (HIWORD(wParam) == LBN_SELCHANGE)
                  UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
               return TRUE;

            case IDCANCEL:
               BLOCK_BUSY(fTry);
               UndoObjects();
               END_PROP_DLG(hDlg,pLinks);
               return TRUE;

            case IDOK:
               BLOCK_BUSY(fTry);
               DelUndoObjects(FALSE);
               END_PROP_DLG(hDlg,pLinks);
               return TRUE;
         }
      }
   }
   return FALSE;
}


/****************************************************************************
 * InitLinkDlg();
 *
 * Initialize the list box of links.
 ***************************************************************************/

static BOOL InitLinkDlg (              //* ENTRY:
   HWND           hDlg,                //* dialog box handle
   INT            *nLinks,             //* pointer to number of links
   HWND           hwndList,            //* listbox handle
   APPITEMPTR     **pLinks             //* list of window handles of links
){                                     //* LOCAL
   APPITEMPTR     pItem;               //* application item pointer
   LPSTR          lpstrData = NULL;    //* pointer to link data
   CHAR           szFull[CBMESSAGEMAX * 4];//* list box entry string
   CHAR           pLinkData[OBJECT_LINK_MAX];//* holder of link data
   BOOL           fSelect = FALSE;     //* item selected flag
   HANDLE         hWork;               //* working memory handle
   APPITEMPTR     pTop;                //* pointer to the top object

   if (!(*pLinks = (APPITEMPTR *)LocalLock(LocalAlloc(LHND,sizeof(APPITEMPTR)*10))))
   {
      ErrorMessage(E_FAILED_TO_ALLOC);
      return 0;
   }
   *nLinks = 0;
                                       //* set tabs
   SendMessage(hwndList,WM_SETREDRAW,FALSE,0L);
                                       //* enumerate child windows
   for (pTop = pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (pItem->otObject == OT_LINK && pItem->fVisible)
      {
         *(*pLinks + *nLinks) = pItem;
         if (!((*nLinks += 1)%10))
         {                             //* add blocks of ten
            hWork = LocalHandle((LPSTR)(*pLinks));
            LocalUnlock(hWork);
            if (!(hWork = LocalReAlloc(hWork,(*nLinks+10)*sizeof(APPITEMPTR),0)))
            {
               ErrorMessage(E_FAILED_TO_ALLOC);
               return FALSE;           //* ERROR return
            }
            *pLinks = (APPITEMPTR *)LocalLock(hWork);
         }

         if (pTop == pItem)
            fSelect = TRUE;

         if (!ObjGetData(pItem, pLinkData))
            continue;
                                       //* make listbox entry
         MakeListBoxString(pLinkData, szFull, pItem->uoObject);
                                       //* add listbox entry
         SendMessage(hwndList, LB_ADDSTRING, 0, (LONG)(LPSTR)szFull);
      }
   }

   if (fSelect)
      SendMessage(hwndList, LB_SETSEL, 1, 0L);

   SendMessage(hwndList,WM_SETREDRAW,TRUE,0L);
   UpdateWindow(hwndList);

   return TRUE;                        //* SUCCESS return

}

/****************************************************************************
 * MakeListBoxString()
 *
 * build an listbox entry string
 ***************************************************************************/

static VOID MakeListBoxString(         //* ENTRY:
   LPSTR          lpLinkData,          //* pointer to link data
   LPSTR          lpBoxData,           //* return string
   OLEOPT_UPDATE  oleopt_update        //* OLE update option
){                                     //* LOCAL:
   CHAR           szType[CBMESSAGEMAX];//* holds update option string
   LPSTR          lpTemp;              //* working string pointer
   INT            i;                   //* index

                                       //* get classname
   RegGetClassId(lpBoxData, lpLinkData);
   lstrcat(lpBoxData, " - ");           //* ads tab

   while (*lpLinkData++);              //* skip to document name

   lpTemp = lpLinkData;
   while (*lpTemp)                     //* copy document name;
   {                                   //* strip drive an directory
      if (*lpTemp == '\\' || *lpTemp == ':')
         lpLinkData = lpTemp + 1;
      lpTemp = AnsiNext(lpTemp);
   }
   lstrcat(lpBoxData, lpLinkData);
   lstrcat(lpBoxData, " - ");

   while (*lpLinkData++);              //* copy item data
   lstrcat(lpBoxData, lpLinkData);
   lstrcat(lpBoxData, " - ");
                                       //* add update option string
   switch (oleopt_update)
   {
      case oleupdate_always: i = SZAUTO; break;
      case oleupdate_oncall: i = SZMANUAL; break;
      default: i = SZFROZEN;
   }
   LoadString(hInst, i, szType, CBMESSAGEMAX);
   lstrcat(lpBoxData, szType);

}                                      //* SUCCESS return

/***************************************************************************
 * UpdateLinkButtons()
 *
 * Keep link buttons active as appropriate.  This routine is called after
 * a selection is made so the buttons reflect the selected items.
 **************************************************************************/

static VOID UpdateLinkButtons(         //* ENTRY:
   HWND           hDlg,                //* dialog box handle
   INT            nLinks,              //* number of links
   HWND           hwndList,            //* listbox handle
   APPITEMPTR     *pLinks              //* pointer to link's window handles
){                                     //* LOCAL:
   ATOM           aCurName=0;          //* atom of current doc
   BOOL           fChangeLink = TRUE;  //* enable/disable changelink button
   INT            iAuto,iManual,i;     //* count of manual and auto links
   APPITEMPTR     pItem;               //* application item pointer
   INT            iStatic;

   iStatic = iAuto = iManual = 0;

   for (i = 0; i < nLinks; i++)        //* enum selected links
   {
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         if (pItem->otObject == OT_STATIC)
            iStatic++;
         else
         {
            switch(pItem->uoObject)
            {                          //* count number of manual and
               case oleupdate_always:  //* automatic links selected
                  iAuto++;
                  break;
               case oleupdate_oncall:
                  iManual++;
                  break;
            }
                                       //* check if all selected links are
            if (!aCurName)             //* linked to same file
               aCurName = pItem->aLinkName;
            else if (aCurName != pItem->aLinkName)
               fChangeLink = FALSE;
         }
      }
   }

   if (!(iAuto || iManual || iStatic)  //* if no links disable all buttons
      || (!iAuto && !iManual && iStatic))
   {
      EnableWindow(GetDlgItem(hDlg, IDD_FREEZE), FALSE );
      EnableWindow(GetDlgItem(hDlg, IDD_CHANGE), FALSE );
      EnableWindow(GetDlgItem(hDlg, IDD_UPDATE), FALSE );
      CheckDlgButton(hDlg, IDD_AUTO, FALSE);
      EnableWindow(GetDlgItem(hDlg, IDD_AUTO),FALSE);
      CheckDlgButton(hDlg, IDD_MANUAL, FALSE);
      EnableWindow(GetDlgItem(hDlg, IDD_MANUAL),FALSE);
   }
   else
   {
      EnableWindow(GetDlgItem(hDlg, IDD_UPDATE), TRUE );
      EnableWindow(GetDlgItem(hDlg, IDD_FREEZE), TRUE );

      if (iAuto && iManual || !(iAuto || iManual))
      {                                //* Set update buttons
         CheckDlgButton(hDlg, IDD_AUTO, FALSE);
         EnableWindow(GetDlgItem(hDlg, IDD_AUTO),FALSE);
         CheckDlgButton(hDlg, IDD_MANUAL, FALSE);
         EnableWindow(GetDlgItem(hDlg, IDD_MANUAL),FALSE);
      }
      else
      {
         EnableWindow(GetDlgItem(hDlg, IDD_MANUAL), TRUE);
         EnableWindow(GetDlgItem(hDlg, IDD_AUTO), TRUE);
         if (iAuto)
         {
            CheckDlgButton(hDlg, IDD_AUTO, TRUE);
            CheckDlgButton(hDlg, IDD_MANUAL, FALSE);
         }
         else
         {
            CheckDlgButton(hDlg, IDD_AUTO, FALSE);
            CheckDlgButton(hDlg, IDD_MANUAL, TRUE);
         }
      }
   }

   EnableWindow(GetDlgItem(hDlg, IDD_CHANGE),fChangeLink && aCurName);

}

/****************************************************************************
 * ChangeLinks()
 *
 * This routine changes the linked data if the user chooses a new file to
 * replace the old document data portion of the linked date.  The routine
 * does nothing if the user cancels.
 *
 * returns TRUE - if data changed FALSE if user cancel or err.
 ***************************************************************************/

static BOOL ChangeLinks(               //* ENTRY:
   HWND           hDlg,                //* dialog handle
   INT            nLinks,              //* number of links in listbox
   HWND           hwndList,            //* listbox
   APPITEMPTR     *pLinks              //* list of application link handles
){                                     //* LOCAL
   INT            i;                   //* general index
   HANDLE         hWork;               //* work
   APPITEMPTR     pItem;               //* application item
   LPSTR          lpNewDoc = NULL;     //* new document
   ATOM           aOldDoc;             //* atom of old doc. name
   ATOM           aCurDoc = 0;      //* atom of change-to doc. name
   BOOL           fMessage = FALSE;    //* error message flag
   LPSTR          lpLinkData;          //* pointer to link data

   lpLinkData = NULL;
                                       //* This loop finds all selected links
   for (i = 0; i < nLinks; i++)        //* and updates them
   {
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         CHECK_IF_STATIC(pItem);

         pItem->lpLinkData = lpLinkData;
         if (!ObjGetData(pItem,NULL))
            continue;

         if (!lpNewDoc)
         {
            if (!(lpNewDoc = OfnGetNewLinkName(hDlg, pItem->lpLinkData)))
              return FALSE;            //* ERROR jump
            aOldDoc = pItem->aLinkName;
            aCurDoc = AddAtom(lpNewDoc);
            SendMessage(hwndList,WM_SETREDRAW,FALSE,0L);
         }

         ObjSaveUndo(pItem);
         ObjChangeLinkData(pItem,lpNewDoc);
         pItem->aLinkName = aCurDoc;
         lpLinkData = pItem->lpLinkData;

         CHANGE_LISTBOX_STRING(hwndList, i, pItem, pItem->lpLinkData);

         pItem->lpLinkData = NULL;
      }
   }

   /*************************************************************************
   * now deal with non-selected links and look for a match...
   *************************************************************************/

                                       //* this loop finds non-selected links
   for (i = 0; i < nLinks; i++)        //* and asks the user to update these?
   {
      if (!SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         if (pItem->otObject == OT_STATIC)
            continue;

         if (!ObjGetData(pItem,NULL))
            continue;

         if (pItem->aLinkName == aOldDoc)
         {
            if (!fMessage)
            {
               CHAR szMessage[2*CBMESSAGEMAX+3*CBPATHMAX];
               CHAR szRename[2*CBMESSAGEMAX];
               CHAR szOldDoc[CBMESSAGEMAX];
               LPSTR pOldDoc;

               GetAtomName(aOldDoc,szOldDoc,CBMESSAGEMAX);
               pOldDoc =(LPSTR)UnqualifyPath(szOldDoc);
               LoadString(hInst, IDS_RENAME, szRename, 2*CBMESSAGEMAX);
               wsprintf(
                     szMessage,
                     szRename,
                     pOldDoc,
                     (LPSTR)UnqualifyPath(szFileName),
                     pOldDoc
               );

               if (MessageBox(hDlg, szMessage,
                  szAppName, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
                  break;
               fMessage = TRUE;
            }

            ObjSaveUndo(pItem);
            ObjChangeLinkData(pItem,lpNewDoc);
            CHANGE_LISTBOX_STRING(hwndList, i, pItem, pItem->lpLinkData);

            pItem->aLinkName = aCurDoc;
         }
      }
   }

   if(lpNewDoc)
   {
      hWork = GlobalHandle(lpNewDoc);
      GlobalUnlock(hWork);
      GlobalFree(hWork);
   }

#if 0
// This is bogus -- this memory is owned by OLECLI32.DLL, not this app,
// so it should not be freed here.
   if (lpLinkData)
      FreeLinkData(lpLinkData);
#endif

   SendMessage(hwndList,WM_SETREDRAW,TRUE,0L);
   InvalidateRect(hwndList,NULL,TRUE);
   UpdateWindow(hwndList);

   WaitForAllObjects();

   if (aCurDoc)
      DeleteAtom(aCurDoc);

   return(TRUE);
}

/****************************************************************************
 * DisplayUpdate()
 *
 * Get the most up to date rendering information and show it.
 ***************************************************************************/

static VOID DisplayUpdate(             //* ENTRY:
   INT            nLinks,              //* number of links in listbox
   HWND           hwndList,            //* listbox
   APPITEMPTR     *pLinks,             //* list of application link handles
   BOOL           fSaveUndo            //* save undo objects
){                                     //* LOCAL:
   INT            i;                   //* index
   APPITEMPTR     pItem;               //* temporary item pointer


   for (i = 0; i < nLinks; i++)
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         CHECK_IF_STATIC(pItem);
         if (fSaveUndo)
            ObjSaveUndo(pItem);
         Error(OleUpdate(pItem->lpObject));
      }

   WaitForAllObjects();

}

/****************************************************************************
 * UndoObjects()
 *
 * Bring objects back to their original state.
 ***************************************************************************/

static VOID UndoObjects()
{
   APPITEMPTR     pItem;               //* application item pointer
                                       //* enum objects
   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
      if (pItem->lpObjectUndo)
         ObjUndo(pItem);

   WaitForAllObjects();

}


/****************************************************************************
 * DelUndoObjects()
 *
 * remove all objects created for undo operation.
 ***************************************************************************/

static VOID DelUndoObjects(            //* ENTRY:
   BOOL           fPrompt              //* prompt user?
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer
   BOOL           fPrompted = FALSE;   //* prompted user?

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (pItem->lpObjectUndo)
      {
         if (fPrompt && !fPrompted)    //* prompt user in activation case
         {
            CHAR szPrompt[CBMESSAGEMAX];

            LoadString(hInst, IDS_SAVE_CHANGES, szPrompt, CBMESSAGEMAX);

            if (MessageBox(hwndFrame, szPrompt,
                  szAppName, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
            {
               UndoObjects();
               return;                 //* user canceled operation
            }
            fPrompted = TRUE;
         }
        ObjDelUndo(pItem);             //* delete udo object
      }
   }

   WaitForAllObjects();

}                                      //* SUCCESS return

/****************************************************************************
 * CancelLinks()
 ***************************************************************************/

static VOID CancelLinks(               //* ENTRY:
   HWND           hDlg,                //* calling dialog
   INT            nLinks,              //* number of links in listbox
   HWND           hwndList,            //* listbox
   APPITEMPTR     *pLinks              //* list of application link handles
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer
   INT            i;                   //* index
   CHAR           pLinkData[OBJECT_LINK_MAX];//* holder of link data

   SendMessage(hwndList,WM_SETREDRAW,FALSE,0L);
   for (i = 0; i < nLinks; i++)
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         CHECK_IF_STATIC(pItem);
         ObjGetData(pItem,pLinkData);
         ObjSaveUndo(pItem);
         ObjFreeze(pItem);

         CHANGE_LISTBOX_STRING(hwndList, i, pItem, pLinkData);
      }

   SendMessage(hwndList,WM_SETREDRAW,TRUE,0L);
   InvalidateRect(hwndList,NULL,TRUE);
   UpdateWindow(hwndList);

}


/****************************************************************************
 * ChangeUpdateOptions()
 *
 * Change the update options for all selected objects.
 ***************************************************************************/

static VOID ChangeUpdateOptions(       //* ENTRY:
   HWND           hDlg,                //* calling dialog
   INT            nLinks,              //* number of links in listbox
   HWND           hwndList,            //* listbox
   APPITEMPTR     *pLinks,             //* list of application link handles
   OLEOPT_UPDATE  lUpdate              //* update option
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item
   INT            i;                   //* index
   CHAR           pLinkData[OBJECT_LINK_MAX];

   SendMessage(hwndList,WM_SETREDRAW,FALSE,0L);

   for (i = 0; i < nLinks; i++)        //* enum selected objects
   {
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         CHECK_IF_STATIC(pItem);
         ObjGetData(pItem,pLinkData);
         ObjSaveUndo(pItem);
         if (Error(OleSetLinkUpdateOptions(pItem->lpObject,lUpdate)))
            continue;
         pItem->uoObject = lUpdate;

         CHANGE_LISTBOX_STRING(hwndList, i, pItem, pLinkData);
      }
   }

   SendMessage(hwndList,WM_SETREDRAW,TRUE,0L);
   InvalidateRect(hwndList,NULL,TRUE);
   UpdateWindow(hwndList);
   WaitForAllObjects();

}
/****************************************************************************
 * InvalidLink()
 *
 * Deal with letting the user know that the program has inadvertently come
 * across an invalid link.
 *
 * Global fPropBoxActive - flag to determine whether or not the link dialog
 *                         box is active.  If it is not active we give the
 *                         user an opportunity to enter the links property
 *                         dialog directly from here.
 ***************************************************************************/

VOID FAR InvalidLink()
{

   if (!hwndProp)
      DialogBox(hInst, "InvalidLink", hwndFrame, (DLGPROC)fnInvalidLink);
   else
      ErrorMessage(E_FAILED_TO_CONNECT);

}

/****************************************************************************
 *  fnABout()
 *
 *  About box dialog box procedure.
 ***************************************************************************/

BOOL  APIENTRY fnInvalidLink(        //* ENTRY:
   HWND           hDlg,              //* standard windows dialog box
   UINT           message,
   WPARAM         wParam,
   LPARAM         lParam
){

   switch (message)
   {
      case WM_INITDIALOG:
         return (TRUE);

      case WM_COMMAND:
         if (LOWORD(wParam) == IDD_CHANGE)
            LinkProperties();
         EndDialog(hDlg, TRUE);
         return (TRUE);
    }
    return (FALSE);

}

/****************************************************************************
 *  AboutBox()
 *
 *  Show the About Box dialog.
 ***************************************************************************/

VOID FAR AboutBox()
{

   DialogBox(hInst, "AboutBox", hwndFrame, (DLGPROC)fnAbout);

}

/****************************************************************************
 *  fnABout()
 *
 *  About box dialog box procedure.
 ***************************************************************************/

BOOL  APIENTRY fnAbout(               //* ENTRY:
   HWND         hDlg,                 //* standard windows dialog box
   UINT         message,
   WPARAM       wParam,
   LPARAM       lParam
){

   switch (message)
   {
      case WM_INITDIALOG:
         return (TRUE);

      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         if (wID == IDOK || wID == IDCANCEL)
         {
            EndDialog(hDlg, TRUE);
            return (TRUE);
         }
         break;
      }
    }
    return (FALSE);

}



/***************************************************************************
 * RetryMessage()
 *
 * give the user the chance to abort when a server is in retry case.
 *
 * Returns BOOL - TRUE if user chooses to cancel
 **************************************************************************/

VOID FAR RetryMessage (                //* ENTRY:
   APPITEMPTR     paItem,              //* application item pointer
   LONG lParam
){
   RETRYPTR    pRetry;
   LONG        objectType;
   HANDLE      hData;
   static CHAR szServerName[KEYNAMESIZE];
   HWND        hwnd;                   //* window handle

   if (IsWindow(hwndProp))
      hwnd = hwndProp;
   else if (IsWindow(hwndFrame))
      hwnd = hwndFrame;
   else
      return;                          //* should not happen
                                       //* get the busy servers name
   lstrcpy(szServerName, "server application");

   if (paItem)
   {
      if (!paItem->aServer)
      {
         OleQueryType(paItem->lpObject, &objectType );
         if (OLE_OK == OleGetData(paItem->lpObject, (OLECLIPFORMAT) (objectType == OT_LINK ? vcfLink : vcfOwnerLink), &hData ))
         {
            RegGetClassId(szServerName, GlobalLock(hData));
            paItem->aServer = AddAtom(szServerName);
            GlobalUnlock( hData );
         }
      }
      else
         GetAtomName(paItem->aServer,szServerName,KEYNAMESIZE);

   }

   hData = LocalAlloc(LHND,sizeof(RETRYSTRUCT));
   if(!(pRetry = (RETRYPTR)LocalLock(hData)))
     return;

   pRetry->lpserver = (LPSTR)szServerName;
   pRetry->bCancel  = (BOOL)(lParam & RD_CANCEL);
   pRetry->paItem   = paItem;

   DialogBoxParam(hInst, "RetryBox", hwnd, (DLGPROC)fnRetry, (LONG)pRetry );

   LocalUnlock(hData);
   LocalFree(hData);

   hRetry = NULL;

}

/****************************************************************************
 *  fnRetry()
 *
 * Retry message box nothing to tricky; however, when a server becomes
 * unbusy a message is posted to automatically get rid of this dialog.
 * I send a no.
 ***************************************************************************/

BOOL  APIENTRY fnRetry(               //* ENTRY
   HWND   hDlg,                       //* standard dialog entry
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
){
   static RETRYPTR   pRetry;

   switch (message)
   {
      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         switch (wParam)
         {
               case IDD_SWITCH:
                  DefWindowProc( hDlg, WM_SYSCOMMAND, SC_TASKLIST, 0);
                  break;

               case IDCANCEL:
                  if (pRetry->paItem)
                     pRetry->paItem->fRetry = FALSE;
                  EndDialog(hDlg, TRUE);
                  return TRUE;

               default:
                   break;
         }
         break;
      }

      case WM_INITDIALOG:
      {
          CHAR       szBuffer[CBMESSAGEMAX];
          CHAR       szText[2*CBMESSAGEMAX];

          pRetry = (RETRYPTR)lParam;
          hRetry = hDlg;

          LoadString(hInst, IDS_RETRY_TEXT1, szBuffer, CBMESSAGEMAX);
          wsprintf(szText, szBuffer, pRetry->lpserver);
          SetWindowText (GetDlgItem(hDlg, IDD_RETRY_TEXT1), szText);

          LoadString(hInst, IDS_RETRY_TEXT2, szBuffer, CBMESSAGEMAX);
          wsprintf(szText, szBuffer, pRetry->lpserver);
          SetWindowText (GetDlgItem(hDlg, IDD_RETRY_TEXT2), szText);

          EnableWindow (GetDlgItem(hDlg, IDCANCEL), pRetry->bCancel);

          return TRUE;
      }

      default:
           break;
   }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\stream.c ===
/*
 * stream.c - io stream function callbacks
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

/***************************************************************************
 * This file contains all routines that directly and indirectly deal with
 * file i/o.  The OLE stream call back functions exist in this file.     
 **************************************************************************/

//*** INCLUDES ***

#include <windows.h>
#include <ole.h>

#include "global.h"
#include "utility.h"
#include "stream.h"
#include "object.h"
#include "demorc.h"

//*** Globals ***

BOOL fLoadFile = FALSE;

/***************************************************************************
 *  ReadStream() - OLE Callback Function (Get)       
 *
 *  This function is pointed to from the OLESTREAM vtbl; it is Get.
 *
 *  returns DWORD  - number of bytes actually read
 **************************************************************************/

DWORD  APIENTRY ReadStream(           //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer
   LPSTR          lpstr,               //* string pointer
   DWORD          cb                   //* byte count
){

   return _lread(lpStream->fh, lpstr, cb);

}

/***************************************************************************
 *  WriteStream() - OLE Callback function (Put)
 *
 *  This function is pointed to from the OLESTREAM vtbl; it is Put.
 *
 *  Returns DWORD  - number of bytes actually written
 **************************************************************************/

DWORD  APIENTRY WriteStream(           //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer 
   LPSTR          lpstr,               //* string pointer
   DWORD          cb                   //* number of bytes to write
){

   return _lwrite(lpStream->fh, lpstr, cb);

}

/****************************************************************************
 *  ReadFromFile()
 *
 *  This function reads OLE objects from a file. If the document 
 *  contains manual links, the user will be prompted to update those links.
 *
 *  Returns BOOL  - TRUE if the read(s) were successful
 ***************************************************************************/

BOOL FAR ReadFromFile(                 //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPOLECLIENT    lpClient             //* pointer to OLE client structure
){                                     //* LOCAL:
   BOOL           bReturn = FALSE;     //* return value
   INT            cFileObjects;        //* number of file objects

   Hourglass(TRUE);
   fLoadFile = TRUE;

   SetFilePointer((HANDLE)lpStream->fh, 0, NULL, 0);
                                       //* in the file
   if (_lread(lpStream->fh, (LPSTR)&cFileObjects, sizeof(INT)) < sizeof(INT))
      goto Error;

   for (; cFileObjects; --cFileObjects) 
   {
      if (!ObjRead(lpStream,lhcDoc,lpClient)) 
      {
         ErrorMessage(E_FAILED_TO_READ_OBJECT);
         goto Error;
      }
   }
   
   ShowDoc(lhcDoc,1);
   UpdateLinks(lhcDoc);

   bReturn = TRUE;                     //* SUCCESS

Error:                                 //* ERROR Tag
    
   Hourglass(FALSE);
   fLoadFile = FALSE;
   return bReturn;                     //* return

}

/****************************************************************************
 *  ObjRead()
 *
 *  Rread an object from the specified file. The file pointer will 
 *  be advanced past the object.
 *
 *  HANDLE fh     - DOS file handle of file to be read from
 *
 *  returns HWND  - window handle to item window containing the OLE object
 ***************************************************************************/

BOOL FAR ObjRead(                      //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPOLECLIENT    lpClient             //* pointer to OLE client structure
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer
   LPOLEOBJECT    lpObject;            //* pointer ole object 
   LONG           otObject;            //* type of object 
   RECT           rcObject;            //* object rect 
   CHAR           szTmp[CBOBJNAMEMAX]; //* temporary string buffer
   CHAR           szProto[PROTOCOL_STRLEN+1];//* protocol string
   INT            i;                   //* index

   if (_lread(lpStream->fh, szTmp, CBOBJNAMEMAX) < CBOBJNAMEMAX )
      return FALSE;

   if (_lread(lpStream->fh, szProto, PROTOCOL_STRLEN) < PROTOCOL_STRLEN )
      return FALSE;

   for (i=0; szProto[i] != ' '; i++);
   szProto[i] = 0;

   ValidateName( szTmp );

   if (!(pItem = PreItemCreate(lpClient, TRUE, lhcDoc))) 
      return FALSE;

   if (Error(OleLoadFromStream((LPOLESTREAM)&(lpStream->olestream), 
         szProto,(LPOLECLIENT)&(pItem->oleclient), lhcDoc, szTmp, &lpObject))) 
      goto Error;

   if (_lread(lpStream->fh, (LPSTR)&rcObject, sizeof(RECT)) < sizeof(RECT))
      goto Error;
   
   if (_lread(lpStream->fh, (LPSTR)&otObject, sizeof(LONG)) < sizeof(LONG))
      goto Error;

   if (PostItemCreate(lpObject, otObject, &rcObject, pItem))
   {
      pItem->fNew = TRUE;
      ObjSetBounds(pItem);
      return TRUE;                     //* SUCCESS return
   }
   else
      return FALSE;

Error:                                 //* ERROR Tag

   FreeAppItem(pItem);
   return FALSE;

}

/*************************************************************************
 *  WriteToFile()
 *
 *  Write current document to a file.
 *
 *  returns BOOL - TRUE if file successfully written
 ************************************************************************/

BOOL FAR WriteToFile(                  //* ENTRY:
   LPAPPSTREAM    lpStream             //* application stream pointer
){                                     //* LOCAL:
   INT            iObjectsWritten=0;   //* counter of objects written to file
   APPITEMPTR     pItem;               //* application Item pointer
   
   UpdateFromOpenServers();
      
   SetFilePointer((HANDLE)lpStream->fh, 0, NULL, 0);
   
   Hourglass(TRUE);

   if (_lwrite(lpStream->fh, (LPSTR)&iObjects, sizeof(INT)) < sizeof(INT))
      goto Error;

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (!ObjWrite(lpStream, pItem)) 
         goto Error;
      iObjectsWritten++;
   }

   if (iObjectsWritten != iObjects) 
      goto Error;


   Dirty(DOC_CLEAN);
   Hourglass(FALSE);
   return(TRUE);                       //* SUCCESS return

Error:                                 //* ERROR Tag
    
   Hourglass(FALSE);
   return(FALSE);                      //* ERROR return

}

/****************************************************************************
 *  ObjWrite()
 *
 *  This function writes an object to the specified
 *  file. The file pointer will be advanced past the end of
 *  the written object.

 *  Returns BOOL - TRUE if object written successfully
 ***************************************************************************/

BOOL FAR ObjWrite(                     //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer
   APPITEMPTR     pItem                //* application item pointer
){                                     //* LOCAL:
   POINT           pt;                  //* center of rec point
   RECT            rc;                  //* bounding rectangle
   UINT            cbTmp = CBOBJNAMEMAX;
   CHAR            szTmp[PROTOCOL_STRLEN];//* protocol string

   OleQueryName(pItem->lpObject, szTmp, &cbTmp);

   if (_lwrite(lpStream->fh, szTmp, CBOBJNAMEMAX) < CBOBJNAMEMAX )
      return FALSE;

   if (pItem->otObject == OT_STATIC)
      wsprintf(szTmp, "%-15s", STATICP);
   else   
      wsprintf(szTmp, "%-15s", STDFILEEDITING);

   if (_lwrite(lpStream->fh, szTmp, PROTOCOL_STRLEN) < PROTOCOL_STRLEN )
      return FALSE;

   if (Error(OleSaveToStream(pItem->lpObject, (LPOLESTREAM)&(lpStream->olestream))))
      return FALSE;

   GetClientRect(pItem->hwnd, (LPRECT)&rc);
   pt = *(LPPOINT)&rc;
   ClientToScreen(pItem->hwnd, (LPPOINT)&pt);
   ScreenToClient(hwndFrame, (LPPOINT)&pt);
   OffsetRect(
      &rc, 
      pt.x - rc.left - GetSystemMetrics(SM_CXFRAME),
      pt.y - rc.top  - GetSystemMetrics(SM_CYFRAME) 
   );

   if (_lwrite(lpStream->fh, (LPSTR)&rc, sizeof(RECT)) < sizeof(RECT)
         || _lwrite(lpStream->fh, (LPSTR)&(pItem->otObject), sizeof(LONG)) < sizeof(LONG))
      return FALSE;

   return TRUE;                        //* SUCCESS return

}

/****************************************************************************
 * UpdateLinks()
 *
 * Get the most up to date rendering information and show it.  
 ***************************************************************************/

static VOID UpdateLinks(               //* ENTRY
   LHCLIENTDOC    lhcDoc               //* client document handle
){                                     //* LOCAL:
   INT            i=0;                 //* index
   APPITEMPTR     pItem;               //* temporary item pointer
   CHAR           szUpdate[CBMESSAGEMAX];//* update message?

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (pItem->lhcDoc == lhcDoc && pItem->otObject == OT_LINK)
      {   
         if (!i)
         {
            LoadString(hInst, IDS_UPDATELINKS, szUpdate, CBMESSAGEMAX);
            if (MessageBox(hwndFrame, szUpdate, szAppName,
               MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
               break; 
            i++;
         }
         Error(OleUpdate(pItem->lpObject));
      }
   }

   WaitForAllObjects();

}

/****************************************************************************
 * UpdateFromOpenServers()
 *
 * Get the most up to date rendering information before storing it.  
 ***************************************************************************/

static VOID UpdateFromOpenServers(VOID)
{                                      //* LOCAL:
   APPITEMPTR pItem;                   //* temporary item pointer
   APPITEMPTR pItemNext;

   for (pItem = GetTopItem(); pItem; pItem = pItemNext) 
   {
      pItemNext = GetNextItem(pItem); 
      if (pItem->otObject == OT_EMBEDDED || 
         (pItem->uoObject == oleupdate_oncall 
               && pItem->otObject == OT_LINK ))  

         if (OleQueryOpen(pItem->lpObject) == OLE_OK)
         {  
            CHAR szMessage[2*CBMESSAGEMAX];
            CHAR szBuffer[CBMESSAGEMAX];
            UINT cb = CBOBJNAMEMAX;       //* The name will be the server window title.
            CHAR szTmp[CBOBJNAMEMAX];     //* when the object is edited. 

            Error(OleQueryName(pItem->lpObject,szTmp,&cb));
            LoadString(hInst, IDS_UPDATE_OBJ, szBuffer, CBMESSAGEMAX);
            wsprintf(szMessage, szBuffer, (LPSTR)szTmp);

            if (MessageBox(hwndFrame, szMessage, szAppName, MB_YESNO | MB_ICONEXCLAMATION) == IDYES) 
            {
               Error(OleUpdate(pItem->lpObject));
               WaitForObject(pItem);
            }
            if (!pItem->fVisible)
               ObjDelete(pItem, OLE_OBJ_DELETE);
         }

   }

   WaitForAllObjects();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\object.c ===
/*
 * object.c - OLE object support routines
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** INCLUDES ****

#include <windows.h>                   //* WINDOWS
#include <shellapi.h>                  //* SHELL
#include <ole.h>                       //* OLE

#include "global.h"                    //* global variables and structures
#include "stream.h"                    //* application includes:
#include "dialog.h"
#include "object.h"
#include "clidemo.h"
#include "demorc.h"
#include "utility.h"
#include "register.h"

#define HIMETRIC_PER_INCH       2540

//*** VARIABLES ***

//*** Globals
INT     cOleWait     = 0;

INT giXppli ;
INT giYppli ;



/***************************************************************************
 * CallBack()
 *
 * This routine will be called whenever an object has been changed,
 * saved, renamed, is being painted, or an  asynchronous operation has
 * completed. This routine is called by the OLE client DLL in the
 * above situations.  A pointer to this function is kept in the client
 * vtbl.  It is our obligation as a client application to insure that a
 * pointer to this procedure is in the vtbl.
 *
 * IMMPORTANT: notice that we are posting messages here rather that doing
 * the work right away.  Well, this is done to avoid any possibility of
 * getting into another dispatch message loop.  A MessageBox woul do this!
 *
 * Returns int - see below
 *
 * The return value is generally ignored, except for these notifications:
 * OLE_QUERY_PAINT and  OLE_QUERY_RETRY. For these two notifications,
 * returning TRUE means continue the current operation(eg painting or retry)
 * Returning FALSE means stop the current operation. This is useful as an
 * object which takes a long time to paint can be interrupted in order to
 * perform other operations.
 ***************************************************************************/

INT  APIENTRY CallBack(               //* ENTRY:
   LPOLECLIENT      lpClient,         //* client application pointer
   OLE_NOTIFICATION flags,            //* notification code being sent
   LPOLEOBJECT      lpObject          //* OLE object pointer
){                                    //* LOCAL:
   APPITEMPTR     pItem;              //* application item pointer


   pItem = (APPITEMPTR)lpClient;
   switch (flags)
   {
      case OLE_CLOSED:                 //* server has closed
         if (!pItem->fVisible)
         {
            PostMessage(hwndFrame, WM_DELETE, 0L, (DWORD)pItem);
            Dirty(DOC_UNDIRTY);
         }
         SetFocus( hwndFrame );
         break;

      case OLE_SAVED:                  //* server has saved object
      case OLE_CHANGED:                //* object has changes
         cOleWait++;
         pItem->fServerChangedBounds = pItem->fVisible = TRUE;
         PostMessage(pItem->hwnd, WM_CHANGE, 0, 0L);
         break;

      case OLE_RELEASE:                //* notification that an asynchronous
         ToggleBlockTimer(FALSE);      //* toggle timer off
         if (hRetry)
            PostMessage(hRetry,WM_COMMAND,IDCANCEL,0L);

         if (cOleWait)                 //* operation has completed
         {
            pItem->fRetry = TRUE;
            if (!--cOleWait)
               Hourglass(FALSE);
            Release(pItem);
         }
         break;

      case OLE_QUERY_RETRY:          //* Continue retrying.
         ToggleBlockTimer(FALSE);    //* toggle timer off
         if (!hRetry && pItem->fRetry)
            PostMessage(hwndFrame,WM_RETRY,0L, (DWORD)pItem);
         return (pItem->fRetry);

      case OLE_QUERY_PAINT:          //* continue repainting
         return TRUE;                //* a false return terminates either

        default:
            break;
    }
    return 0;                          //* return value is ignored in
                                       //* most cases, see header
}

/***************************************************************************
 * Release()
 *
 * Check for an error on the OLE_RELEASE notification.
 **************************************************************************/

static VOID Release(                   //* ENTRY:
   APPITEMPTR     pItem                //* Item pointer
){                                     //* LOCAL:
   DWORD wParam;              //* error code parameter

   if ((wParam = OleQueryReleaseError(pItem->lpObject)) == OLE_OK)
      return;

   switch (OleQueryReleaseMethod(pItem->lpObject))
   {
      case OLE_LNKPASTE:
         pItem->fVisible = FALSE;
         break;

      case OLE_CREATEFROMTEMPLATE:
      case OLE_CREATE:
         pItem->fVisible = FALSE;
         cOleWait++;
         PostMessage(hwndFrame, WM_DELETE,1L, (DWORD)pItem);
         Dirty(DOC_UNDIRTY);
   }
                                  //* post a message to the main window
                                  //* which will display a message box
   PostMessage(hwndFrame,WM_ERROR,wParam,0);

}

/***************************************************************************
 *  Error()
 *
 *  This function checks for error conditions
 *  generated by OLE API callsFor OLE_WAIT_FOR_RELEASE,
 *  we keep track of the number of objects waiting, when
 *  this count is zero, it is safe to exit the application.
 *
 *  Returns OLESTATUS -  0 if OLE_WAIT_FOR_RELEASE or OLE_OK
 *                       otherwise the OLESTATUS returned after an action
 *                       is taken.
 *************************************************************************/

OLESTATUS FAR Error(                   //* ENTRY
   OLESTATUS      olestat              //* OLE status
){

   switch (olestat)
   {
      case OLE_WAIT_FOR_RELEASE:
         if (!cOleWait)
            Hourglass(TRUE);
         cOleWait++;                   //* increment wait count

      case OLE_OK:
         return 0;

      case OLE_ERROR_STATIC:           //* static object
         ErrorMessage(W_STATIC_OBJECT);
         break;

      case OLE_ERROR_REQUEST_PICT:
      case OLE_ERROR_ADVISE_RENAME:
      case OLE_ERROR_DOVERB:
      case OLE_ERROR_SHOW:
      case OLE_ERROR_OPEN:
      case OLE_ERROR_NETWORK:
      case OLE_ERROR_ADVISE_PICT:
      case OLE_ERROR_COMM:             //* Invalid links
         InvalidLink();
         break;

      case OLE_BUSY:
         RetryMessage(NULL,RD_CANCEL);

      default:
         break;
    }
    return olestat;
}


/****************************************************************************
 * PreItemCreate()
 *
 * This routine allocates an application item structure. A pointer to this
 * structure is passed as the client structure, therefore we need to
 * have a pointer to the vtbl as the first entry. We are doing this
 * to allow acess to the application item information during a OLE
 * DLL callback.  This approach simplifies matters.
 *
 * Returns APPITEMPTR - a pointer to a new application item structure
 *                      which can operate as a client structure.
 ***************************************************************************/

APPITEMPTR FAR PreItemCreate(          //* ENTRY:
   LPOLECLIENT    lpClient,            //* OLE client pointer
   BOOL           fShow,               //* show/no-show flag
   LHCLIENTDOC    lhcDoc               //* client document handle
){                                     //* LOCAL:
   HANDLE         hitem;               //* temp handle for new item
   APPITEMPTR     pItem;               //* application item pointer


   if (hitem = LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof(APPITEM)))
      if (pItem = (APPITEMPTR)LocalLock(hitem))
      {                                //* set the vtbl pointer
         pItem->oleclient.lpvtbl     = lpClient->lpvtbl;
         pItem->lpObjectUndo         = NULL;
         pItem->fVisible             = fShow;
         pItem->fServerChangedBounds = FALSE;
         pItem->lhcDoc               = lhcDoc;

         return pItem;                 //* SUCCESS return
      }

   ErrorMessage(E_FAILED_TO_ALLOC);
   return NULL;                        //* ERROR return

}


/***************************************************************************
 * ItemWndProc()
 *
 * This function handles item window message processing.
 * There is an item window for each OLE object. This was done to
 * to simplify hit testing and repainting. These windows are child
 * windows.

 * returns long - standard child routine
 **************************************************************************/

LONG  APIENTRY ItemWndProc(           //* ENTRY:
   HWND           hwnd,                //* standard windows parameters
   UINT           msg,
   DWORD          wParam,
   LONG           lParam
){                                     //* LOCAL:
   static POINT   dragPt;              //* Mouse drag point
   static RECT    dragRect;            //* Mouse drag rectangle
   static BOOL    fCaptured;           //* captured flag
   APPITEMPTR     pItem;               //* application item pointer
   PAINTSTRUCT    ps;                  //* paint structure
   POINT          pt;                  //* point
   RECT           rc;                  //* bounding rectangle
//   char lpstr[256];

   switch (msg)
   {
      case WM_SIZE:
         if (pItem = (APPITEMPTR)GetWindowLong(hwnd,0))
         {
            if (!pItem->fServerChangedBounds && pItem->otObject == OT_EMBEDDED)
               ObjSetBounds(pItem);
            else
               pItem->fServerChangedBounds = FALSE;
         }
         break;

      case WM_CHANGE:
         --cOleWait;
         pItem = (APPITEMPTR)GetWindowLong(hwnd,0);
         if (!Error(OleQueryBounds(pItem->lpObject, &rc)))
         {
            ConvertToClient(&rc);

            SetWindowPos(
               hwnd,
               NULL,
               0,
               0,
               rc.right - rc.left + 2*GetSystemMetrics(SM_CXFRAME),
               rc.bottom - rc.top + 2*GetSystemMetrics(SM_CYFRAME),
               SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME
            );

            if (!pItem->fNew && !fLoadFile)
               ShowNewWindow(pItem);
            else
               InvalidateRect(hwnd, NULL, TRUE);

            Dirty(DOC_DIRTY);
         }
         break;

      case WM_NCLBUTTONDOWN:
         SetTopItem((APPITEMPTR)GetWindowLong(hwnd,0));
         return (DefWindowProc(hwnd, msg, wParam, lParam));

      case WM_PAINT:
         BeginPaint(hwnd, (LPPAINTSTRUCT)&ps);
         GetClientRect(hwnd, &rc);
         pItem = (APPITEMPTR)GetWindowLong(hwnd, 0);
                                       //* Call OLE draw
         Error(OleDraw(pItem->lpObject, ps.hdc, &rc, NULL, NULL));

         EndPaint(hwnd, (LPPAINTSTRUCT)&ps);
         break;

      case WM_LBUTTONDBLCLK:           //* execute a verb
         ANY_OBJECT_BUSY;
         ExecuteVerb(OLEVERB_PRIMARY,(APPITEMPTR)GetWindowLong(hwnd,0));
         break;

      case WM_LBUTTONDOWN:
         GetWindowRect(hwnd, (LPRECT)&dragRect);
         ScreenToClient(hwndFrame, (LPPOINT)&dragRect);
         ScreenToClient(hwndFrame, (LPPOINT)&dragRect.right);

         dragPt.x = (LONG)(SHORT)LOWORD(lParam);
         dragPt.y = (LONG)(SHORT)HIWORD(lParam);

         ClientToScreen(hwnd, (LPPOINT)&dragPt);
         ScreenToClient(hwndFrame, (LPPOINT)&dragPt);

         SetCapture(hwnd);
         fCaptured = TRUE;
         SetTopItem((APPITEMPTR)GetWindowLong(hwnd,0));
         break;

      case WM_LBUTTONUP:
         if (!fCaptured)
                break;
         ReleaseCapture();
         fCaptured = FALSE;
         Dirty(DOC_DIRTY);
         break;

      case WM_MOUSEMOVE:
         if (!fCaptured)
            break;
         pt.x = (LONG)(SHORT)LOWORD(lParam);
         pt.y = (LONG)(SHORT)HIWORD(lParam);

         ClientToScreen(hwnd, (LPPOINT)&pt);
         ScreenToClient(hwndFrame, (LPPOINT)&pt);

         OffsetRect(
               (LPRECT)&dragRect,
               pt.x - dragPt.x,
               pt.y - dragPt.y
         );

         MoveWindow(
            hwnd,
            dragRect.left, dragRect.top,
            dragRect.right - dragRect.left,
            dragRect.bottom - dragRect.top, TRUE
         );

         dragPt.x = pt.x;
         dragPt.y = pt.y;
         break;

      default:
         return (DefWindowProc(hwnd, msg, wParam, lParam));
   }
   return 0L;

}

/****************************************************************************
 * PostItemCreate()
 *
 * This function creates a child window which will contain the newly
 * created OLE object. A pointer to our item information is stored in the
 * extra bytes of this window. This is where we internally keep track
 * of information related to the object as well as the
 * pointer to the object for subsequent OLE API calls.  This routine is
 * called after an OLE object has been created by the client library.
 *
 * Returns BOOL - TRUE if application item has been created.
 ****************************************************************************/

BOOL FAR PostItemCreate(               //* ENTRY:
   LPOLEOBJECT    lpObject,            //* OLE object pointer
   LONG           otObject,            //* OLE object type
   LPRECT         lprcObject,          //* object bounding rect
   APPITEMPTR     pItem                //* application item pointer
){                                     //* LOCAL:
   INT            i;                   //* index
   RECT           rc;                  //* bounding rectangle
   CHAR           pData[OBJECT_LINK_MAX];//* copy of link data

   if (lprcObject)                     //* if the size of the objects
      rc = *lprcObject;                //* bounding rectangle is not
   else if (OleQueryBounds(lpObject, &rc) == OLE_OK)
      ConvertToClient(&rc);
   else
      SetRect(&rc, 0, 0, 0, 0);

   if (!(pItem->hwnd = CreateWindow(   //* Create the child window
         szItemClass, "",
         WS_BORDER | WS_CHILD | WS_CLIPSIBLINGS | WS_THICKFRAME,
         rc.left,rc.top,
         rc.right - rc.left + 2 * GetSystemMetrics(SM_CXFRAME),
         rc.bottom - rc.top + 2 * GetSystemMetrics(SM_CYFRAME),
         hwndFrame, NULL, hInst, NULL
   ))) goto Error;

                                       //* in windows extra bytes
   SetWindowLong(pItem->hwnd, 0, (LONG)pItem);

   pItem->otObject = otObject;
   pItem->lpObject = lpObject;
   pItem->fRetry  = TRUE;

   if( pItem->otObject == OT_EMBEDDED )//* if object is embedded tell library
   {                                   //* the container name and object name.
      UINT  cb=CBOBJNAMEMAX;           //* The name will be the server window title.
      CHAR  sz[CBOBJNAMEMAX];          //* when the object is edited.

      OleQueryName(lpObject, (LPSTR)sz, (UINT FAR *)&cb );


      WaitForObject(pItem);
      Error(OleSetHostNames(lpObject, (LPSTR)szAppName, (LPSTR)sz ));
      WaitForObject(pItem);
   }
   else if (pItem->otObject == OT_LINK)//* if the object is linked
   {                                   //* retrieve update options

      WaitForObject(pItem);
      if(Error(OleGetLinkUpdateOptions(pItem->lpObject, &pItem->uoObject)))
         goto Error;

      if (ObjGetData(pItem,pData))
      {
         for (i=0; pData[i];i++);      //* Skip past the server name
         pItem->aLinkName = AddAtom(&pData[++i]);
      }
      else
         pItem->aLinkName = AddAtom("");
   }
   iObjects++;
   Dirty(DOC_DIRTY);
                                       //* a user interface recommendations.
   return TRUE;                        //* SUCCESS return

Error:                                 //* ERROR Tag

   ErrorMessage(E_FAILED_TO_CREATE_CHILD_WINDOW);
   FreeAppItem(pItem);

   return FALSE;                       //* ERROR return

}

/***************************************************************************
 * ConvertToClient()
 *
 * This function will convert to client from himetric.
 **************************************************************************/

VOID FAR ConvertToClient(              //* ENTRY:
   LPRECT         lprc                 //* pointer to bounding rectangle
){                                     //* LOCAL

   //* If we have an empty rectangle then set the default size
   if (!(lprc->left || lprc->top || lprc->right || lprc->bottom))
      SetRect(lprc, 0, 0, CXDEFAULT, CYDEFAULT);
   else
   {
      //* We got the himetric units, converts them to pixels now.
      lprc->right   = MulDiv (giXppli, (lprc->right - lprc->left),
                          HIMETRIC_PER_INCH);

      lprc->bottom  = MulDiv (giYppli, (lprc->top - lprc->bottom),
                          HIMETRIC_PER_INCH);

      lprc->left    = 0;
      lprc->top     = 0;
    }
}

/***************************************************************************
 * ObjInsert()
 *
 * Query the user for object type to insert and insert the new OLE object
 ***************************************************************************/

VOID FAR ObjInsert(                    //* ENTRY:
   LHCLIENTDOC    lhcDoc,              //* OLE document handle
   LPOLECLIENT    lpClient             //* pointer to OLE client structure
){                                     //* LOCAL:
   LPOLEOBJECT    lpObject;            //* pointer to OLE object
   APPITEMPTR     pItem;               //* item pointer
   CHAR           szServerName[CBPATHMAX];//* Class name for OleCreate()
   CHAR           szClassName[CBPATHMAX];//* Class name for OleCreate()
   CHAR           szTmp[CBOBJNAMEMAX]; //* buffer to unique object name

   if (DialogBoxParam(hInst, MAKEINTRESOURCE(DTCREATE),hwndFrame,
            (DLGPROC) fnInsertNew, (LONG)((LPSTR)szClassName)) != IDCANCEL)
   {
      if (pItem = PreItemCreate(lpClient, FALSE, lhcDoc))
      {
         RegGetClassId(szServerName, szClassName);
         pItem->aServer = AddAtom(szServerName);
         if ( Error( OleCreate(STDFILEEDITING,(LPOLECLIENT)&(pItem->oleclient),
            (LPSTR)szClassName, lhcDoc,CreateNewUniqueName(szTmp),
            &lpObject,olerender_draw, 0)))
         {
            ErrorMessage(E_FAILED_TO_CREATE_OBJECT);
            FreeAppItem(pItem);
         }
         else
            PostItemCreate(lpObject, OT_EMBEDDED, NULL, pItem);
      }
   }


}

/***************************************************************************
 *  ObjDelete()
 *
 * Delete an OLE object. For this application, all OLE objects
 * are associated with a child window; therefore the window must be
 * destroyed.
 *
 * NOTE: There is one case when we call OleRelease and the other when
 * we call OleDelete.  We call OleRelease when we are deregistering
 * a document and OleDelete when removing an object from a document.
 **************************************************************************/

VOID FAR ObjDelete(                    //* ENTRY:
   APPITEMPTR     pItem,               //* pointer to application item
   BOOL           fDelete              //* delete or release flag
){                                     //* LOCAL:

   if (pItem->lpObjectUndo)
   {
      Error(OleDelete(pItem->lpObjectUndo));
                                       //* wait for asynchronous operation
      WaitForObject(pItem);
   }

   if (fDelete ? Error(OleDelete(pItem->lpObject))
                     : Error(OleRelease(pItem->lpObject)))
   {
      ErrorMessage(E_FAILED_TO_DELETE_OBJECT);
      return;                          //* ERROR return
   }

   if (pItem->fVisible)
   {
      ShowWindow(pItem->hwnd, SW_HIDE);
      pItem->fVisible = FALSE;
   }
                                       //* the operation has to complete
   WaitForObject(pItem);               //* before the application structure

   FreeAppItem(pItem);
   iObjects--;

}


/***************************************************************************
 *  ObjPaste()
 *
 *  This function obtains an object from the clipboard.
 *  Handles both embedded and linked objects. An item window is
 *  created for each new object.
 *
 *  Returns BOOL  - TRUE if object was pasted succesfully.
 **************************************************************************/

VOID FAR ObjPaste(                     //* ENTRY:
   BOOL           fPaste,              //* Paste/PasteLink flag
   LHCLIENTDOC    lhcDoc,              //* client document handle
   LPOLECLIENT    lpClient             //* pointer to client
){                                     //* LOCAL:
   LPOLEOBJECT    lpObject;            //* object pointer
   LONG           otObject;            //* object type
   APPITEMPTR     pItem;               //* application item pointer
   CHAR           szTmp[CBOBJNAMEMAX]; //* temporary object name string

   if (!(pItem = PreItemCreate(lpClient, TRUE, lhcDoc)))
      return;                          //* ERROR return

   if (!OpenClipboard(hwndFrame))
      goto Error;                      //* ERROR jump


   if (fPaste)                         //* PASTE the object.
   {                                   //* Try "StdFileEditing" protocol
      if (Error(OleCreateFromClip(STDFILEEDITING,(LPOLECLIENT)&(pItem->oleclient),lhcDoc,
         CreateNewUniqueName(szTmp),&lpObject, olerender_draw,0)))
      {
                                       //* next try "Static" protocol
         if (Error(OleCreateFromClip(
                  STATICP, (LPOLECLIENT)&(pItem->oleclient), lhcDoc,
                  CreateNewUniqueName(szTmp), &lpObject, olerender_draw, 0)))
            goto Error;               //* ERROR jump
      }
   }
   else
   {                                   //* LINK therefore must be
                                       // "STdFileEditing" protocol
        if (Error(OleCreateLinkFromClip(
            STDFILEEDITING,(LPOLECLIENT)&(pItem->oleclient), lhcDoc,
            CreateNewUniqueName(szTmp), &lpObject, olerender_draw, 0)))
            goto Error;                //* ERROR jump
   }

   OleQueryType(lpObject, &otObject);
   CloseClipboard();

   if (!PostItemCreate(lpObject, otObject, NULL, pItem))
      return;                          //* ERROR return

   ShowNewWindow(pItem);
   return;                             //* SUCCESS return


Error:                                 //* TAG Error

   ErrorMessage(E_GET_FROM_CLIPBOARD_FAILED);
   CloseClipboard();
   FreeAppItem(pItem);

   return;                             //* ERROR return

}

/***************************************************************************
 * ObjCopy()
 *
 * This function places an OLE object on the clipboard via the \
 * OleCopyToClipboard() function.
 *
 * Returns BOOL - TRUE if object successfully placed on clipboard
 **************************************************************************/

BOOL FAR ObjCopy(                      //* ENTRY:
   APPITEMPTR     pItem                //* pointer to app item
){                                     //* LOCAL:
   BOOL           fReturn = TRUE;      //* return value

   if (!OpenClipboard(hwndFrame))
      return FALSE;                    //* ERROR return

   EmptyClipboard();

   if (Error(OleCopyToClipboard(pItem->lpObject)))
      fReturn = FALSE;                 //* prepare for ERROR out

   CloseClipboard();
   return fReturn;                     //* ERROR or SUCCESS

}

/***************************************************************************
 *  ObjCreateFromTemplate()
 *
 *  Creates an embedded object from file.
 **************************************************************************/

VOID FAR ObjCreateFromTemplate(        //* ENTRY:
   LHCLIENTDOC    lhcDoc,              //* client document handle
   LPOLECLIENT    lpClient             //* client vtbl. pointer
){                                     //* LOCAL:
   LPOLEOBJECT    lpObject;            //* OLE object pointer
   APPITEMPTR     pItem;               //* application item pointer
   CHAR           szTmp[CBOBJNAMEMAX]; //* temporary object name string
   CHAR           szFileName[CBPATHMAX];//* file name string

   *szFileName = 0;

   if (!OfnGetName(hwndFrame, szFileName, IDM_INSERTFILE))
      return;                          //* ERROR operation aborted by user

   if (!(pItem = PreItemCreate(lpClient, FALSE, lhcDoc)))
      return;                          //* ERROR

   if (Error(OleCreateFromTemplate(STDFILEEDITING, (LPOLECLIENT)pItem, szFileName,
         lhcDoc, CreateNewUniqueName(szTmp), &lpObject, olerender_draw, 0)))
   {
      ErrorMessage(E_CREATE_FROM_TEMPLATE);
      FreeAppItem(pItem);
      return;                          //* ERROR
   }

   PostItemCreate(lpObject, OT_EMBEDDED, NULL, pItem);

}                                      //* SUCCESS


/****************************************************************************
 * ObjGetData()
 *
 * Get the object link data.  The data that is retrieved from OLE is copied
 * into lpLinkData if lpLinkData is not NULL.  Otherwise, space is dynamically
 * allocated or reallocated; space is allocated if pItem->lpLinkData is NULL
 * otherwise the pointer is reallocated. The data is returned is freed if
 * there has been an OLE_WARN_DELETE_DATA error.
 ***************************************************************************/

BOOL FAR ObjGetData(                   //* ENTRY:
   APPITEMPTR     pItem,               //* OLE object
   LPSTR          lpLinkData           //* pointer to linkdata
){                                     //* LOCAL:
   HANDLE         hData;               //* handle to OLE link data
   LPSTR          lpData;              //* pointer to OLE link data
   LPSTR          lpWork;              //* copy of OLE link data
   BOOL           fFree = FALSE;       //* free OLE memory flag
   LONG           lSize;               //* size of OLE link data
   INT            i;

   switch (Error(OleGetData(pItem->lpObject,
      (OLECLIPFORMAT)(pItem->otObject == OT_LINK ? vcfLink : vcfOwnerLink), &hData)))
   {
      case OLE_WARN_DELETE_DATA:
         fFree = TRUE;
      case OLE_OK:
         if(lpData = GlobalLock(hData))
         {
                                       //* copy the link data to new buffer
            lSize=SizeOfLinkData(lpData);

            if (!lpLinkData)
            {
               if (!pItem->lpLinkData)  //* allocate
                  AllocLinkData(pItem,lSize);
               else                     //* otherwise reallocate
                  ReallocLinkData(pItem,lSize);
               lpWork = pItem->lpLinkData;
            }
            else
               lpWork = lpLinkData;

            if (lpWork)
               for (i=0L; i<(INT)lSize; i++)
                  *(lpWork+i)=*(lpData+i);

            GlobalUnlock(hData);       //* free the linked data as needed
            if (fFree)
               GlobalFree(hData);

            return TRUE;               //* SUCCESS
         }
      default:
         return FALSE;                 //* FAILURE
   }

}

/***************************************************************************
 * ObjChangeLink()
 *
 * Change the linkdata.  This routine will change the document portion of
 * link data to lpDoc.  The old linkdata is expected to be in
 * lpaItem->lpLinkData
 **************************************************************************/

VOID FAR ObjChangeLinkData(            //* ENTRY:
   APPITEMPTR     pItem,               //* OLE object
   LPSTR          lpDoc                //* document name
){                                     //* LOCAL:
   LONG           lSize;               //* used to link data size
   LPSTR          lpLinkData;          //* OLE link data pointer
   static CHAR    pWork[OBJECT_LINK_MAX]; //* used to construct new link data
   INT            i;                   //* index
   HANDLE         hData;

   pItem->aLinkName = AddAtom(lpDoc);

   for (
      lpLinkData = pItem->lpLinkData, i=0;
      pWork[i] = *lpLinkData;
      lpLinkData++, i++
   );
                                       //* into working buffer.
   lstrcpy((LPSTR)&pWork[++i],lpDoc);  //* copy new document name.

   for (; pWork[i]; i++);              //* skip to end of document name
   for (++lpLinkData;*lpLinkData;lpLinkData++);
                                       //* copy item name.
   lstrcpy((LPSTR)&pWork[++i],++lpLinkData);
   for (; pWork[i]; i++);              //* skip to end of buffer
                                       //* which is the end of item info.
   pWork[++i] = 0;                  //* add extra null.

   lSize = SizeOfLinkData(pWork);      //* reallocate space so there is
   ReallocLinkData(pItem,lSize);       //* a properly sized block of info
                                       //* to send the linked data to the
   if (lpLinkData = pItem->lpLinkData) //* OLE DLL.
      for (i=0; i<(INT)lSize; i++)     //* copy new linkdata into this space
         *lpLinkData++ = pWork[i];
   else
      return;                          //* ERROR return

   Error(OleSetData(pItem->lpObject, vcfLink, GlobalHandle(pItem->lpLinkData)));

   /*
    * The handle passed into OleSetData is owned by the OLE client library
    * and should not be used after the call.  On win32s, it is inaccessible
    * after the call, so restore it by calling OleGetData.  Note that the
    * data is *still* owned by the library, but we will now have access
    * to the memory.
    */
   Error(OleGetData(pItem->lpObject, vcfLink, &hData));
   if (hData) {
       pItem->lpLinkData = GlobalLock(hData);
   }
}                                      //* SUCCESS return

/****************************************************************************
 * ObjSaveUndo()
 *
 * Clone the OLE object so that any changes to object can be undone if the
 * user choses to exit without update.
 ***************************************************************************/

VOID FAR ObjSaveUndo(                  //* ENTRY:
   APPITEMPTR     pItem                //* application item
){                                     //* LOCAL:
   CHAR           szTmp[CBOBJNAMEMAX]; //* holder of object name
   LPSTR          lpClone;             //* pointer to clond object name
   UINT           i=CBOBJNAMEMAX;

   if (!pItem->lpObjectUndo)
   {
      OleQueryName(pItem->lpObject, szTmp, &i);
                                       //* give clone a unique name by
                                       //* altering object name prefix.
      for (lpClone = OBJCLONE, i=0; *lpClone; szTmp[i++] = *lpClone++);

      if (Error(OleClone(pItem->lpObject, (LPOLECLIENT)pItem,
         pItem->lhcDoc, szTmp, &(pItem->lpObjectUndo))))
      return;                          //* ERROR return

      pItem->otObjectUndo  = pItem->otObject;
      pItem->uoObjectUndo  = pItem->uoObject;
      pItem->aLinkUndo     = pItem->aLinkName;

      GetClientRect(pItem->hwnd, &pItem->rect);

      if (OleQueryOpen(pItem->lpObject) == OLE_OK)
         pItem->fOpen = TRUE;

   }

}                                      //* SUCCESS return

/****************************************************************************
 * ObjUndo()
 *
 * Restore an object to its state before changes.  The lpObject Undo is a
 * clone to the original object with a different name, therefore, all we
 * have to do is rename that object and ditch the changed object.
 ***************************************************************************/

VOID FAR ObjUndo(                      //* ENTRY:
   APPITEMPTR     pItem                //* application item
){                                     //* LOCAL:
   CHAR           szTmp[CBOBJNAMEMAX]; //* object name holder
   UINT           i = CBOBJNAMEMAX;

   OleQueryName(pItem->lpObject, szTmp, &i);
   if (Error(OleDelete(pItem->lpObject)))
      return;                          //* ERROR return
                                       //* reset app item vars
   pItem->lpObject      = pItem->lpObjectUndo;
   pItem->otObject      = pItem->otObjectUndo;
   pItem->uoObject      = pItem->uoObjectUndo;
   pItem->aLinkName     = pItem->aLinkUndo;
   pItem->lpObjectUndo  = (LPOLEOBJECT)NULL;
   pItem->otObjectUndo  = (LONG)NULL;

   if (Error(OleRename(pItem->lpObject,szTmp)))
      return;                          //* ERROR return

   if (pItem->fOpen)
   {
      Error(OleReconnect(pItem->lpObject));
      pItem->fOpen = FALSE;
   }

   SetWindowPos(
      pItem->hwnd,
      NULL, 0, 0,
      pItem->rect.right - pItem->rect.left + 2*GetSystemMetrics(SM_CXFRAME),
      pItem->rect.bottom - pItem->rect.top + 2*GetSystemMetrics(SM_CYFRAME),
      SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME
   );

   InvalidateRect(pItem->hwnd,NULL,TRUE);

}                                      //* SUCCESS return


/****************************************************************************
 * ObjDelUndo()
 *
 * Delete the undo object if the user is happy with the changes he/she made.
 ***************************************************************************/

VOID FAR ObjDelUndo(                   //* ENTRY:
   APPITEMPTR     pItem                //* application item
){

   if (Error(OleDelete(pItem->lpObjectUndo)))
      return;                          //* ERROR return

   pItem->lpObjectUndo = (LPOLEOBJECT)NULL;
   pItem->otObjectUndo = (LONG)NULL;
   DeleteAtom(pItem->aLinkUndo);
   pItem->lpObjectUndo = NULL;

}                                      //* SUCCESS return

/****************************************************************************
 * ObjFreeze()
 *
 * Convert an object to a static object.
 ***************************************************************************/

VOID FAR ObjFreeze(                    //* ENTRY:
   APPITEMPTR     pItem                //* application item
){                                     //* LOCAL:
   CHAR           szTmp[CBOBJNAMEMAX]; //* temporary object name
   LPSTR          lpTemp;              //* temporary prefix string
   LPOLEOBJECT    lpObjectTmp;         //* temporary object pointer
   UINT           i=CBOBJNAMEMAX;

   OleQueryName(pItem->lpObject, szTmp, &i);
                                       //* create a unique name by changing
                                       //* the object name prefix
   for (lpTemp = OBJTEMP, i=0; *lpTemp; szTmp[i++] = *lpTemp++);

                                       //* this API creates a static object
   if (Error(OleObjectConvert(pItem->lpObject, STATICP, (LPOLECLIENT)pItem,
      pItem->lhcDoc, szTmp, &lpObjectTmp)))
      return;
                                       //* delete old object
   if (Error(OleDelete(pItem->lpObject)))
      return;

   WaitForObject(pItem);

   pItem->lpObject = lpObjectTmp;
   pItem->otObject = OT_STATIC;
   pItem->uoObject = -1L;

   for (lpTemp = OBJPREFIX, i=0; *lpTemp; szTmp[i++] = *lpTemp++);
   if (Error(OleRename(pItem->lpObject,szTmp)))
      return;


}

/***************************************************************************
 *  ObjCreateWrap()
 *
 * Create a wrapped object from the drag and drop feature of the 3.1 shell.
 * NOTE: We are assuming that only one file has been dropped.  See the SDK
 * documentation for instructions on how to deal with multiple files.
 ***************************************************************************/

VOID FAR ObjCreateWrap(                //* ENTRY:
   HANDLE         hdrop,               //* handle to dropped object
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPOLECLIENT    lpClient             //* pointer to client structure
){                                     //* LOCAL:
   CHAR           szDragDrop[CBPATHMAX];//* Drag and drop file name
   LPOLEOBJECT    lpObject;            //* pointer to OLE object
   POINT          pt;                  //* position of dropped object
   RECT           rc;                  //* object size and position
   CHAR           szTmp[CBOBJNAMEMAX]; //* buffer for unique object name
   APPITEMPTR     pItem;               //* application item pointer
   INT            x,y;                 //* icon sizes

   x = GetSystemMetrics(SM_CXICON) / 2;
   y = GetSystemMetrics(SM_CYICON) / 2;
                                       //* Get the drag and drop filename
                                       //* position
   DragQueryPoint(hdrop, &pt);
   DragQueryFile(hdrop, 0, szDragDrop, CBPATHMAX);
   DragFinish(hdrop);

   SetRect(&rc, pt.x - x, pt.y - y, pt.x + x, pt.y + y);

   if (!(pItem = PreItemCreate(lpClient, TRUE, lhcDoc)))
      return;                          //* ERROR return
                                       //* create OLE object
   if (Error(OleCreateFromFile(STDFILEEDITING, (LPOLECLIENT)pItem,
         "Package", szDragDrop, lhcDoc, CreateNewUniqueName(szTmp),
         &lpObject, olerender_draw, 0)))
   {
      ErrorMessage(E_FAILED_TO_CREATE_OBJECT);
      FreeAppItem(pItem);
      return;                          //* ERROR return
   }

   if (PostItemCreate(lpObject, OT_EMBEDDED, &rc, pItem))
      ShowNewWindow(pItem);

}                                      //* SUCCESS return

/***************************************************************************
 *  UpdateObjectMenuItem()
 *
 *  Add an object popup menu for the chosen object if multiple verbs exist.
 *  The registration system is used to determine which verbs exist for the
 *   given object.
 **************************************************************************/

VOID FAR UpdateObjectMenuItem(         //* ENTRY:
   HMENU       hMenu                   //* main menu
){                                     //* LOCAL
   INT         cVerbs;                 //* verb
   APPITEMPTR  pItem;                  //* application item ponter
   DWORD       dwSize = KEYNAMESIZE;
   CHAR        szClass[KEYNAMESIZE], szBuffer[200];
   CHAR        szVerb[KEYNAMESIZE];
   HMENU       hPopupNew=NULL;
   HKEY        hkeyTemp;
   CHAR        pLinkData[OBJECT_LINK_MAX];
                                       //* delete current item and submenu
   DeleteMenu(hMenu, POS_OBJECT, MF_BYPOSITION );

   if (!(pItem = GetTopItem()) )
      goto Error;                      //* ERROR jump
   else if (!pItem->fVisible)
      goto Error;                      //* ERROR jump
                                       //* if STATIC ?
   if ((pItem->otObject != OT_EMBEDDED) && (pItem->otObject != OT_LINK))
      goto Error;                      //* ERROR jump

   if (!ObjGetData(pItem, pLinkData))  //* get linkdata as key reg database
      goto Error;                      //* ERROR jump
                                       //* open reg database
   szClass[0] = 0;
   if (RegOpenKey(HKEY_CLASSES_ROOT, szClass, &hkeyTemp))
      goto Error;                      //* ERROR jump
                                       //* check if class is reg-db
   if (RegQueryValue(HKEY_CLASSES_ROOT, pLinkData, szClass, &dwSize))
   {
      RegCloseKey(hkeyTemp);
      goto Error;                      //* ERROR jump
   }

   for (cVerbs=0; ;++cVerbs)           //* extract all verbs from reg-db
   {
      dwSize = KEYNAMESIZE;
      wsprintf(szBuffer, "%s\\protocol\\StdFileEditing\\verb\\%d",
                                     (LPSTR)pLinkData,cVerbs);

      if (RegQueryValue(HKEY_CLASSES_ROOT, szBuffer, szVerb, &dwSize))
         break;

      if (!hPopupNew)
         hPopupNew = CreatePopupMenu();

      InsertMenu(hPopupNew, (UINT)-1, MF_BYPOSITION, IDM_VERBMIN+cVerbs, szVerb);
   }

   //* NOTE: For International versions the following  verb menu
   //* may need to be formatted differently.

   switch (cVerbs)                     //* determine how many verbs found
   {
      case 0:                          //* none
         wsprintf(szBuffer, "Edit %s %s", (LPSTR)szClass, (LPSTR)"&Object");
         InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION, IDM_VERBMIN, szBuffer);
         break;

      case 1:                          //* one
         wsprintf(szBuffer, "%s %s %s", (LPSTR)szVerb, (LPSTR)szClass,
            (LPSTR)"&Object");
         DestroyMenu(hPopupNew);
         InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION, IDM_VERBMIN, szBuffer);
         break;

     default:                          //* > 1
         wsprintf(szBuffer, "%s %s", (LPSTR)szClass, (LPSTR)"&Object");
         InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION | MF_POPUP, (UINT)hPopupNew, szBuffer);
         EnableMenuItem(hMenu, POS_OBJECT, MF_ENABLED|MF_BYPOSITION);
         break;
   }

   RegCloseKey(hkeyTemp);              //* close reg-db
   return;                             //* SUCCESS return

Error:                                 //* ERROR tag
   InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION, 0, "&Object");
   EnableMenuItem(hMenu, POS_OBJECT, MF_GRAYED | MF_BYPOSITION);

}                                      //* ERROR return

/***************************************************************************
 *  ExecuteVerb()
 *
 *  Execute the verb for the given object.
 ***************************************************************************/

VOID FAR ExecuteVerb(                  //* ENTRY:
   UINT iVerb,                          //* verb
   APPITEMPTR pItem                    //* application item pointer
){                                     //* LOCAL
   RECT        rc;                     //* holds client area bounding rect

   if (pItem->otObject == OT_STATIC)   //* if the object is static beep
   {
      ErrorMessage(W_STATIC_OBJECT);
      return;                          //* return
   }
                                       //* get cliet area rectangle
   GetClientRect(hwndFrame, (LPRECT)&rc);
                                       //* execute OLE verb
   if (Error(OleActivate(pItem->lpObject, iVerb, TRUE, TRUE, hwndFrame, &rc)))
      return;

   WaitForObject(pItem);               //* wait for async. operation

   ObjSetBounds(pItem);


}                                      //* SUCCESS return

/****************************************************************************
 * ObjSetBounds
 *
 * Set the object bounds.  The object bounds are the child windos bounding
 * rectangle.  OLE servers recieve need the bounding rectangle in HIMETRIC
 * coordinates.  So, we convert from screen coordinates to HIMETRIC.
 *
 * Returns BOOL - TRUE if successful.
 ***************************************************************************/
BOOL FAR ObjSetBounds(                 //* ENTRY:
   APPITEMPTR     pItem                //* application item pointer
){                                     //* LOCAL:
   RECT           itemRect;            //* bounding rectangle

   GetWindowRect(pItem->hwnd,&itemRect);//* get item window react

   itemRect.right -= GetSystemMetrics(SM_CXFRAME);
   itemRect.left += GetSystemMetrics(SM_CXFRAME);
   itemRect.top += GetSystemMetrics(SM_CYFRAME);
   itemRect.bottom -= GetSystemMetrics(SM_CYFRAME);

   itemRect.right  = MulDiv ((itemRect.right - itemRect.left),
                        HIMETRIC_PER_INCH, giXppli);
   itemRect.bottom = - MulDiv((itemRect.bottom - itemRect.top),
                        HIMETRIC_PER_INCH, giYppli);
   itemRect.top    = 0;
   itemRect.left   = 0;
                                       //* set the rect for the server
   if (Error(OleSetBounds(pItem->lpObject,(LPRECT)&itemRect)))
      return FALSE;                    //* ERROR return

   WaitForObject(pItem);               //* wait for async. operation
   return TRUE;                        //* SUCCESS return

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\clidemo\utility.c ===
/* 
 * utility.c - general purpose utility routines
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 *
 */

//*** INCLUDES ****

#include <windows.h>
#include <ole.h>

#include "global.h"
#include "demorc.h"
#include "utility.h"
#include "object.h"
#include "dialog.h"

static INT        iTimerID = 0;
static APPITEMPTR lpaItemHold;


/****************************************************************************
 *  ErrorMessage()
 *
 *  Display a message box containing the specified string from the table.
 *
 *  id WORD       - Index into string table.
 ***************************************************************************/

VOID FAR ErrorMessage(                 //* ENTRY:
   DWORD          id                   //* message ID
){                                     //* LOCAL:
   CHAR           sz[CBMESSAGEMAX];    //* string 
   HWND           hwnd;                //* parent window handle

   if (IsWindow(hwndProp))
      hwnd = hwndProp;
   else if (IsWindow(hwndFrame))
      hwnd = hwndFrame; 
   else
      return;

   LoadString(hInst, id, sz, CBMESSAGEMAX);
   MessageBox(hwnd, sz, szAppName, MB_OK | MB_ICONEXCLAMATION);

}


/****************************************************************************
 *  Hourglass()
 *
 *  Put up or takes down the hourglass cursor as needed.
 *
 *  int  bToggle  - TRUE turns the hour glass on
 *                  HG_OFF turn it off  
 ***************************************************************************/

VOID FAR Hourglass(                    //* ENTRY:
   BOOL           bOn                  //* hourglass on/off
){                                     //* LOCAL:
   static HCURSOR hcurWait = NULL;     //* hourglass cursor
   static HCURSOR hcurSaved;           //* old cursor
   static         iCount = 0;


   if (bOn)
   {
      iCount++;
      if (!hcurWait) 
         hcurWait = LoadCursor(NULL, IDC_WAIT);
      if (!hcurSaved) 
         hcurSaved = SetCursor(hcurWait);
   }
   else if (!bOn)
   {  
      if (--iCount < 0 )
         iCount = 0;
      else if (!iCount)
      {
         SetCursor(hcurSaved);
         hcurSaved = NULL;
      }
   }

}

/***************************************************************************
 *  WaitForObject()
 *
 *  Dispatch messagee until the specified object is not busy. 
 *  This allows asynchronous processing to occur.
 *
 *  lpObject    LPOLEOBJECT - pointer to object
 **************************************************************************/

void FAR WaitForObject(                //* ENTRY:
   APPITEMPTR    paItem                //* pointer to OLE object
){                                     //* LOCAL
   BOOL bTimerOn = FALSE;

   while (OleQueryReleaseStatus(paItem->lpObject) == OLE_BUSY)
   {
      lpaItemHold = paItem;
      if (!bTimerOn)
         bTimerOn = ToggleBlockTimer(TRUE);//* set timer
      ProcessMessage(hwndFrame, hAccTable);
   }

   if (bTimerOn)
       ToggleBlockTimer(FALSE);//* toggle timer off
}

/***************************************************************************
 *  WaitForAllObjects()
 *
 *  Wait for all asynchronous operations to complete. 
 **************************************************************************/

VOID FAR WaitForAllObjects(VOID)
{
   BOOL bTimerOn = FALSE;

   while (cOleWait) 
   {
      if (!bTimerOn)
         bTimerOn = ToggleBlockTimer(TRUE);//* set timer

      ProcessMessage(hwndFrame, hAccTable) ;
   }

   if (bTimerOn)
       ToggleBlockTimer(FALSE);//* toggle timer off
     
}

/****************************************************************************
 * ProcessMessage()
 *
 * Obtain and dispatch a message. Used when in a message dispatch loop. 
 *
 *  Returns BOOL - TRUE if message other than WM_QUIT retrieved
 *                 FALSE if WM_QUIT retrieved.
 ***************************************************************************/

BOOL FAR ProcessMessage(               //* ENTRY:
   HWND           hwndFrame,           //* main window handle
   HANDLE         hAccTable            //* accelerator table handle
){                                     //* LOCAL:
   BOOL           fReturn;             //* return value
   MSG            msg;                 //* message

   if (fReturn = GetMessage(&msg, NULL, 0, 0)) 
   {
      if (cOleWait || !TranslateAccelerator(hwndFrame, hAccTable, &msg)) 
      {
            TranslateMessage(&msg);
            DispatchMessage(&msg); 
      }
   }
   return fReturn;

}


/****************************************************************************
 *  Dirty()
 *
 *  Keep track of weather modifications have been made 
 *  to the document or not.
 *
 *  iAction - action type:
 *            DOC_CLEAN set document clean flag true
 *            DOC_DIRTY the opposite
 *            DOC_UNDIRTY undo one dirty op
 *            DOC_QUERY return present state
 *
 *  Returs int - present value of fDirty; 0 is clean.
 ***************************************************************************/

INT FAR Dirty(                         //* ENTRY:
   INT            iAction              //* see above comment
){                                     //* LOCAL:
   static INT     iDirty = 0;          //* dirty state >0 is dirty

   switch (iAction)
   {
      case DOC_CLEAN:
         iDirty = 0;
         break;
      case DOC_DIRTY:
         iDirty++;
         break;
      case DOC_UNDIRTY:
         iDirty--;
         break;
      case DOC_QUERY:
         break;
   }
   return(iDirty);

}

/***************************************************************************
 *  ObjectsBusy()
 *
 *  This function enumerates the OLE objects in the current document 
 *  and displays a message box stating whether an object is busy. 
 *  This function calls  the DisplayBusyMessage() function which 
 *  performs most of the work. This function is only used by the macro
 *  BUSY_CHECK(), defined in object.h.
 *
 *  fSelectionOnly  BOOL -NOT USED?
 *
 *  BOOL - TRUE if one or more objects found to be busy
 *             FALSE otherwise
 *
 ***************************************************************************/

BOOL FAR ObjectsBusy ()
{
   APPITEMPTR pItem;

   if (iTimerID)
   {
      RetryMessage(NULL,RD_CANCEL);
      return TRUE;
   }

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
      if (DisplayBusyMessage(pItem))
         return TRUE;

   return FALSE;

}

/***************************************************************************
 *  DisplayBusyMessage()
 *
 *  This function determines if an object is busy and displays 
 *  a message box stating this status. 
 *
 *  Returns BOOL - TRUE if object is busy
 **************************************************************************/

BOOL FAR DisplayBusyMessage (          //* ENTRY:
   APPITEMPTR     paItem               //* application item pointer
){                                     //* LOCAL:
    
   if (OleQueryReleaseStatus(paItem->lpObject) == OLE_BUSY) 
   {
      RetryMessage(paItem,RD_CANCEL);
      return TRUE;    
   }
   return FALSE;

}

/***************************************************************************
 * CreateNewUniqueName()
 *
 * Create a string name unique to this document. This is done by using the
 * prefix string("OleDemo #") and appending a counter to the end of the 
 * prefix string. The counter is incremented  whenever a new object is added. 
 * String will be 14 bytes long.
 *
 * Return LPSTR - pointer to unique object name.
 ***************************************************************************/

LPSTR FAR CreateNewUniqueName(         //* ENTRY:
   LPSTR          lpstr                //* destination pointer
){

    wsprintf( lpstr, "%s%04d", OBJPREFIX, iObjectNumber++ );
    return( lpstr );

}

/***************************************************************************
 *  ValidateName()
 *
 *  This function ensures that the given object name is valid and unique.
 *
 *  Returns: BOOL - TRUE if object name valid
 **************************************************************************/

BOOL FAR ValidateName(                 //* ENTRY:
   LPSTR          lpstr                //* pointer to object name
){                                     //* LOCAL:
   LPSTR          lp;                  //* worker string
   INT            n;
                                       //* check for "OleDemo #" prefix
   lp = OBJPREFIX;

   while( *lp ) 
   {
      if( *lpstr != *lp )
         return( FALSE );

      lpstr++; lp++;
   }
                                       //* convert string number to int
   for (n = 0 ; *lpstr ; n = n*10 + (*lpstr - '0'),lpstr++);

   if( n > 9999 )                      //* 9999 is largest legal number
      return FALSE;

   if( iObjectNumber <= n)             //* Make count > than any current
      iObjectNumber = n + 1;           //* object to ensure uniqueness

    return TRUE;
}

/***************************************************************************
 * FreeAppItem()
 *
 * Free application item structure and destroy the associated structure.
 **************************************************************************/

VOID FAR FreeAppItem(                  //* ENTRY:
   APPITEMPTR     pItem                //* pointer to application item
){                                     //* LOCAL:
   HANDLE         hWork;               //* handle used to free
   
   if (pItem)
   {                                   //* destroy the window
      if (pItem->hwnd)
         DestroyWindow(pItem->hwnd);

      hWork = LocalHandle((LPSTR)pItem);//* get handle from pointer

      if (pItem->aLinkName)
         DeleteAtom(pItem->aLinkName);

      if (pItem->aServer)
         DeleteAtom(pItem->aServer);

      LocalUnlock(hWork);
      LocalFree(hWork);
   }

}

/***************************************************************************
 * SizeOfLinkData()
 *
 * Find the size of a linkdata string.
 **************************************************************************/

LONG FAR SizeOfLinkData(               //* ENTRY:
   LPSTR          lpData               //* pointer to link data
){                                     //* LOCAL:
   LONG           lSize;               //* total size

   lSize = (LONG)lstrlen(lpData)+1;       //* get size of classname
   lSize += (LONG)lstrlen(lpData+lSize)+1; //* get size of doc.
   lSize += (LONG)lstrlen(lpData+lSize)+2;//* get size of item
   return lSize;

}

/****************************************************************************
 * ShowDoc()
 *
 * Display all the child windows associated with a document, or make all the
 * child windows hidden.
 ***************************************************************************/

VOID FAR ShowDoc(                      //* ENTRY:
   LHCLIENTDOC    lhcDoc,              //* document handle
   INT            iShow                //* show/hide
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer
   APPITEMPTR     pItemTop = NULL;

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (pItem->lhcDoc == lhcDoc)
      {
         if (!pItemTop)
            pItemTop = pItem;
         ShowWindow(pItem->hwnd,(iShow ? SW_SHOW : SW_HIDE)); 
         pItem->fVisible = (BOOL)iShow;
      }
   }
   
   if (pItemTop)
      SetTopItem(pItemTop);

}           
      
/****************************************************************************
 * GetNextActiveItem()
 *
 * Returns HWND - the next visible window. 
 ***************************************************************************/

APPITEMPTR FAR GetNextActiveItem()
{                                      //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
      if (pItem->fVisible)
         break;

   return pItem;

}
 
/****************************************************************************
 * GetTopItem()
 ***************************************************************************/

APPITEMPTR FAR GetTopItem()
{
   HWND hwnd;

   if (hwnd = GetTopWindow(hwndFrame))
      return ((APPITEMPTR)GetWindowLong(hwnd,0));
   else
      return NULL;

}
/****************************************************************************
 * GetNextItem()
 ***************************************************************************/

APPITEMPTR FAR GetNextItem(            //* ENTRY:
   APPITEMPTR     pItem                //* application item pointer
){                                     //* LOCAL:
   HWND           hwnd;                //* next item window handle

   if (hwnd = GetNextWindow(pItem->hwnd, GW_HWNDNEXT))
      return((APPITEMPTR)GetWindowLong(hwnd,0));
   else
      return NULL;

}

/****************************************************************************
 * SetTopItem()
 ***************************************************************************/

VOID FAR SetTopItem(
   APPITEMPTR     pItem
){
   APPITEMPTR     pLastItem;

   pLastItem = GetTopItem();
   if (pLastItem && pLastItem != pItem)
      SendMessage(pLastItem->hwnd,WM_NCACTIVATE, 0, 0L);

   if (!pItem)
      return;

   if (pItem->fVisible)
   {
      BringWindowToTop(pItem->hwnd);
      SendMessage(pItem->hwnd,WM_NCACTIVATE, 1, 0L);
   }

}

/***************************************************************************
 * ReallocLinkData()
 *
 * Reallocate link data in order to avoid creating lots and lots of global
 * memory thunks.
 **************************************************************************/

BOOL FAR ReallocLinkData(              //* ENTRY:
   APPITEMPTR     pItem,               //* application item pointer
   LONG           lSize                //* new link data size
){                                     //* LOCAL:
   HANDLE         handle;              //* temporary memory handle

   handle = GlobalHandle(pItem->lpLinkData);
   GlobalUnlock(handle);

   if (!(pItem->lpLinkData = GlobalLock(GlobalReAlloc(handle, lSize, 0)))) 
   {
      ErrorMessage(E_FAILED_TO_ALLOC); 
      return FALSE;
   }

   return TRUE;

}

/***************************************************************************
 * AllocLinkData()
 *
 * Allocate link data space.
 **************************************************************************/

BOOL FAR AllocLinkData(                //* ENTRY:
   APPITEMPTR     pItem,               //* application item pointer
   LONG           lSize                //* link data size
){

   if (!(pItem->lpLinkData = GlobalLock(
         GlobalAlloc(GMEM_DDESHARE | GMEM_ZEROINIT ,lSize)
      )))
   {
      ErrorMessage(E_FAILED_TO_ALLOC);
      return FALSE;
   }

   return TRUE;
}

/***************************************************************************
 * FreeLinkData()
 *
 * Free the space associated with a linkdata pointer.
 **************************************************************************/

VOID FAR FreeLinkData(                 //* ENTRY:
   LPSTR          lpLinkData           //* pointer to linkdata
){                                     //* LOCAL:
   HANDLE         handle;              //* temporary memory handle

   if (lpLinkData)
   {
      handle = GlobalHandle(lpLinkData);
      GlobalUnlock(handle);
      GlobalFree(handle);
   }
}

/****************************************************************************
 * ShowNewWindow()
 *
 * Show a new application item window.
 ***************************************************************************/

VOID FAR ShowNewWindow(                //* ENTRY:
   APPITEMPTR     pItem
){

   if (pItem->fVisible)
   {
      pItem->fNew = TRUE;
      SetTopItem(pItem);
      ShowWindow(pItem->hwnd,SW_SHOW);
   }
   else
      ObjDelete(pItem,OLE_OBJ_DELETE);

}

/****************************************************************************
 * UnqualifyPath()
 *
 * return pointer to unqualified path name.
 ***************************************************************************/

PSTR FAR UnqualifyPath(PSTR pPath)
{
   PSTR pReturn;

   for (pReturn = pPath; *pPath; pPath++)  
      if (*pPath == ':' || *pPath == '\\')
         pReturn = pPath+1;

   return pReturn;

}

/****************************************************************************
 * ToggleBlockTimer()
 *
 * Toggle a timer used to check for blocked servers.
 ***************************************************************************/

BOOL FAR ToggleBlockTimer(BOOL bSet)
{     
   if (bSet && !iTimerID)
   {
      if (iTimerID = SetTimer(hwndFrame,1, 3000, (TIMERPROC) fnTimerBlockProc))
          return TRUE;
   }
   else if (iTimerID)
   {
      KillTimer(hwndFrame,1);
      iTimerID = 0;
      return TRUE;
   }
   
   return FALSE;
}

/****************************************************************************
 *  fnTimerBlockProc()
 *
 *  Timer callback procedure
 ***************************************************************************/

VOID CALLBACK fnTimerBlockProc(      //* ENTRY: 
   HWND     hWnd,
   UINT     wMsg,
   UINT     iTimerID,
   DWORD    dwTime
){

   if (!hRetry)
      RetryMessage(lpaItemHold, RD_RETRY | RD_CANCEL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\srvrdemo\file.c ===
/*
  OLE SERVER DEMO
  File.c

  This file contains file input/output functions for for the OLE server demo.

  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
*/



#include <windows.h>
#include <commDlg.h>
#include <ole.h>

#include "srvrdemo.h"

// File signature stored in the file.
#define szSignature "ServerDemo"
#define cchSigLen (10+1)

// Delimiter for fields in the file
#define chDelim ':'

// Default file extension
#define szDefExt "sd"

// File header structure
typedef struct
{
   CHAR szSig [cchSigLen];
   CHAR chDelim1;
   VERSION version;
   CHAR chDelim2;
   CHAR rgfObjNums [cfObjNums+1];
} HEADER;

// BOOL  GetFileSaveFilename (LPSTR lpszFilename);
static VOID  InitOfn (OPENFILENAME *pofn);
static BOOL  SaveDocIntoFile (PSTR);
static LPOBJ ReadObj (INT fh);



/* CreateDocFromFile
 * -----------------
 *
 * Read a document from the specified file.
 *
 * LPSTR lpszDoc     - Name of the file containing the document
 * LHSERVERDOC lhdoc - Handle to the document
 * DOCTYPE doctype   - In what state the document is created
 *
 * RETURNS: TRUE if successful, FALSE otherwise
 *
 * CUSTOMIZATION: Re-implement
 *                This function will need to be completely re-implemented
 *                to support your application's file format.
 *
 */
BOOL CreateDocFromFile (LPSTR lpszDoc, LHSERVERDOC lhdoc, DOCTYPE doctype)
{
    INT     fh;        // File handle
    HEADER  hdr;
    INT     i;

    if ((fh =_lopen(lpszDoc, OF_READ)) == -1)
        return FALSE;

    // Read header from file.
    if (_lread(fh, (LPSTR) &hdr, (UINT)sizeof(HEADER)) < sizeof (HEADER))
      goto Error;

    // Check to see if file is a server demo file.
    if (lstrcmp(hdr.szSig, szSignature))
      goto Error;

    if (hdr.chDelim1 != chDelim)
      goto Error;

    // Check to see if file was saved under the most recent version.
    // Here is where you would handle reading in old versions.
    if (hdr.version != version)
      goto Error;

    if (hdr.chDelim2 != chDelim)
      goto Error;

    if (!CreateNewDoc (lhdoc, lpszDoc, doctype))
      goto Error;

    // Get the array indicating which object numbers have been used.
    for (i=1; i <= cfObjNums; i++)
      docMain.rgfObjNums[i] = hdr.rgfObjNums[i];

    // Read in object data.
    for (i=0; ReadObj (fh); i++);

    if (!i)
    {
         OLESTATUS olestatus;

         fRevokeSrvrOnSrvrRelease = FALSE;

         if ((olestatus = RevokeDoc()) > OLE_WAIT_FOR_RELEASE)
            goto Error;
         else if (olestatus == OLE_WAIT_FOR_RELEASE)
            Wait (&fWaitingForDocRelease);

         fRevokeSrvrOnSrvrRelease = TRUE;
         EmbeddingModeOff();
         goto Error;
    }

    _lclose(fh);

    fDocChanged = FALSE;
    return TRUE;

Error:
    _lclose(fh);
    return FALSE;

}



/* OpenDoc
 * -------
 *
 * Prompt the user for which document he wants to open
 *
 * RETURNS: TRUE if successful, FALSE otherwise.
 *
 * CUSTOMIZATION: None, except your application may or may not call
 *                CreateNewObj to create a default object.
 *
 */
BOOL OpenDoc (VOID)
{
   CHAR        szDoc[cchFilenameMax];
   BOOL        fUpdateLater;
   OLESTATUS   olestatus;

   if (SaveChangesOption (&fUpdateLater) == IDCANCEL)
      return FALSE;

   if (!GetFileOpenFilename (szDoc))
   {
      if (fUpdateLater)
      {
         // The user chose the "Yes, Update" button but the
         // File Open dialog box failed for some reason
         // (perhaps the user chose Cancel).
         // Even though the user chose "Yes, Update", there is no way
         // to update a client that does not accept updates
         // except when the document is closed.
      }
      return FALSE;
   }

   if (fUpdateLater)
   {
      // The non-standard OLE client did not accept the update when
      // we requested it, so we are sending the client OLE_CLOSED now that
      // we are closing the document.
      SendDocMsg (OLE_CLOSED);
   }

   fRevokeSrvrOnSrvrRelease = FALSE;

   if ((olestatus = RevokeDoc()) > OLE_WAIT_FOR_RELEASE)
      return FALSE;
   else if (olestatus == OLE_WAIT_FOR_RELEASE)
      Wait (&fWaitingForDocRelease);

   fRevokeSrvrOnSrvrRelease = TRUE;
   EmbeddingModeOff();

   if (!CreateDocFromFile (szDoc, 0, doctypeFromFile))
   {
      MessageBox (hwndMain,
                  "Reading from file failed.\r\nFile may not be in proper file format.",
                  szAppName,
                  MB_ICONEXCLAMATION | MB_OK);
      // We already revoked the document, so give the user a new one to edit.
      CreateNewDoc (0, "(Untitled)", doctypeNew);
      CreateNewObj (FALSE);
      return FALSE;
   }
   fDocChanged = FALSE;
   return TRUE;
}



/* ReadObj
 * --------
 *
 * Read the next object from a file, allocate memory for it, and return
 * a pointer to it.
 *
 * int fh - File handle
 *
 * RETURNS: A pointer to the object
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
static LPOBJ ReadObj (INT fh)
{
    HANDLE hObj = NULL;
    LPOBJ   lpobj = NULL;

    hObj = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (OBJ));

    if (hObj == NULL)
      return NULL;

    lpobj = (LPOBJ) LocalLock (hObj);

    if (lpobj==NULL)
    {
      LocalFree (hObj);
      return NULL;
    }

    if (_lread(fh, (LPSTR) &lpobj->native, (UINT)sizeof(NATIVE)) < sizeof (NATIVE))
    {
        LocalUnlock (hObj);
        LocalFree (hObj);
        return NULL;
    }

    lpobj->hObj             = hObj;
    lpobj->oleobject.lpvtbl = &objvtbl;
    lpobj->aName            = GlobalAddAtom (lpobj->native.szName);

    if (!CreateWindow(
        "ObjClass",
        "Obj",
        WS_THICKFRAME | WS_BORDER | WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE ,
        lpobj->native.nX,
        lpobj->native.nY,
        lpobj->native.nWidth,
        lpobj->native.nHeight,
        hwndMain,
        NULL,
        hInst,
        (LPSTR) lpobj ))
    {
        LocalUnlock (hObj);
        LocalFree (hObj);
        return NULL;
    }

    return lpobj;
}



/* SaveDoc
 * -------
 *
 * Save the document.
 *
 * CUSTOMIZATION: None
 *
 */

BOOL SaveDoc (VOID)
{
    if (docMain.doctype == doctypeNew)
        return SaveDocAs();
    else
    {
        CHAR     szDoc [cchFilenameMax];

        GlobalGetAtomName (docMain.aName, szDoc, cchFilenameMax);
        return SaveDocIntoFile(szDoc);
    }
}



/* SaveDocAs
 * ---------
 *
 * Prompt the user for a filename, and save the document under that filename.
 *
 * RETURNS: TRUE if successful or user chose CANCEL
 *          FALSE if SaveDocIntoFile fails
 *
 * CUSTOMIZATION: None
 *
 */
BOOL SaveDocAs (VOID)
{
   CHAR        szDoc[cchFilenameMax];
   BOOL        fUpdateLater = FALSE;
   CHAR szDocOld[cchFilenameMax];

   // If document is embedded, give user a chance to update.
   // Save old document name in case the save fails.
   if (!GlobalGetAtomName (docMain.aName, szDocOld, cchFilenameMax))
      ErrorBox ("Fatal Error: Document name is invalid.");

   if (GetFileSaveFilename (szDoc))

   {

      if (docMain.doctype == doctypeEmbedded)
         return SaveDocIntoFile(szDoc);

      if (fUpdateLater)
      {
         // The non-standard OLE client did not accept the update when
         // we requested it, so we are sending the client OLE_CLOSED now that
         // we are closing the document.
         SendDocMsg (OLE_CLOSED);
      }

      // Set the window title bar.
      SetTitle (szDoc, FALSE);
      OleRenameServerDoc(docMain.lhdoc, szDoc);

      if (SaveDocIntoFile(szDoc))
         return TRUE;
      else
      {  // Restore old name
         SetTitle (szDocOld, FALSE);
         OleRenameServerDoc(docMain.lhdoc, szDocOld);
         return FALSE;
      }
   }
   else  // user chose Cancel
      return FALSE;
         // The user chose the "Yes, Update" button but the
         // File Open dialog box failed for some reason
         // (perhaps the user chose Cancel).
         // Even though the user chose "Yes, Update", there is no way
         // to update a non-standard OLE client that does not accept updates
         // except when the document is closed.
}



/* SaveDocIntoFile
 * ---------------
 *
 * Save the document into a file whose name is determined from docMain.aName.
 *
 * RETURNS: TRUE if successful
 *          FALSE otherwise
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static BOOL SaveDocIntoFile (PSTR pDoc)
{
    HWND     hwnd;
    INT      fh;    // File handle
    LPOBJ    lpobj;
    HEADER   hdr;
    INT      i;

    hwnd = GetWindow (hwndMain, GW_CHILD);

    if (!hwnd)
    {
        ErrorBox ("Could not save NULL file.");
        return FALSE;
    }

    // Get document name.
    if ((fh =_lcreat(pDoc, 0)) == -1)
    {
        ErrorBox ("Could not save file.");
        return FALSE;
    }

    // Fill in header.
    lstrcpy (hdr.szSig, szSignature);
    hdr.chDelim1 = chDelim;
    hdr.version  = version;
    hdr.chDelim2 = chDelim;
    for (i=1; i <= cfObjNums; i++)
      hdr.rgfObjNums[i] = docMain.rgfObjNums[i];

    // Write header to file.
    if (_lwrite(fh, (LPSTR) &hdr, (UINT)sizeof(HEADER)) < sizeof(HEADER))
         goto Error; // Error writing file header

    // Write each object's native data.
    while (hwnd)
    {
      lpobj = (LPOBJ) GetWindowLong (hwnd, ibLpobj);
      if (_lwrite(fh, (LPSTR)&lpobj->native, (UINT)sizeof (NATIVE))
          < sizeof(NATIVE))
         goto Error; // Error writing file header

      hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    _lclose(fh);


    if (docMain.doctype != doctypeEmbedded)
    {
         docMain.doctype = doctypeFromFile;
         OleSavedServerDoc(docMain.lhdoc);
         fDocChanged = FALSE;
    }

    return TRUE;

Error:
      _lclose(fh);
      ErrorBox ("Could not save file.");
      return FALSE;

}



/* Common Dialog functions */


/* InitOfn
 * -------
 *
 * Initialize an OPENFILENAME structure with default values.
 * OPENFILENAME is defined in CommDlg.h.
 *
 *
 * CUSTOMIZATION: Change lpstrFilter.  You may also customize the common
 *                dialog box if you wish.  (See the Windows SDK documentation.)
 *
 */
static VOID InitOfn (OPENFILENAME *pofn)
{
   // GetOpenFileName or GetSaveFileName will put the 8.3 filename into
   // szFileTitle[].
   // SrvrDemo does not use this filename, but rather uses the fully qualified
   // pathname in pofn->lpstrFile[].
   static CHAR szFileTitle[13];

   pofn->Flags          = 0;
   pofn->hInstance      = hInst;
   pofn->hwndOwner      = hwndMain;
   pofn->lCustData      = 0;
   pofn->lpfnHook       = NULL;
   pofn->lpstrCustomFilter = NULL;
   pofn->lpstrDefExt    = szDefExt;
   // lpstrFile[] is the initial filespec that appears in the edit control.
   // Must be set to non-NULL before calling the common dialog box function.
   // On return, lpstrFile[] will contain the fully-qualified pathname
   // corresponding to the file the user chose.
   pofn->lpstrFile      = NULL;
   pofn->lpstrFilter    = "Server Demo (*." szDefExt ")\0*." szDefExt "\0" ;
   // lpstrFileTitle[] will contain the user's chosen filename without a path.
   pofn->lpstrFileTitle = szFileTitle;
   pofn->lpstrInitialDir= NULL;
   // Title Bar.  NULL means use default title.
   pofn->lpstrTitle     = NULL;
   pofn->lpTemplateName = NULL;
   pofn->lStructSize    = sizeof (OPENFILENAME);
   pofn->nFilterIndex   = 1L;
   pofn->nFileOffset    = 0;
   pofn->nFileExtension = 0;
   pofn->nMaxFile       = cchFilenameMax;
   pofn->nMaxCustFilter = 0L;
}




/* GetFileOpenFilename
 * -------------------
 *
 * Call the common dialog box function GetOpenFileName to get a file name
 * from the user when the user chooses the "File Open" menu item.
 *
 * LPSTR lpszFilename - will contain the fully-qualified pathname on exit.
 *
 * RETURNS: TRUE if successful, FALSE otherwise.
 *
 * CUSTOMIZATION: None
 *
 */
BOOL GetFileOpenFilename (LPSTR lpszFilename)
{
   OPENFILENAME ofn;
   InitOfn (&ofn);
   ofn.Flags |= OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
   // Create initial filespec.
   wsprintf (lpszFilename, "*.%s", (LPSTR) szDefExt);
   // Have the common dialog function return the filename in lpszFilename.
   ofn.lpstrFile = lpszFilename;
   if (!GetOpenFileName (&ofn))
      return FALSE;
   return TRUE;
}



/* GetFileSaveFilename
 * -------------------
 *
 * Call the common dialog box function GetSaveFileName to get a file name
 * from the user when the user chooses the "File Save As" menu item, or the
 * "File Save" menu item for an unnamed document.
 *
 * LPSTR lpszFilename - will contain the fully-qualified pathname on exit.
 *
 * RETURNS: TRUE if successful, FALSE otherwise.
 *
 * CUSTOMIZATION: None
 *
 */
BOOL GetFileSaveFilename (LPSTR lpszFilename)
{
   OPENFILENAME ofn;
   InitOfn (&ofn);
   ofn.Flags |= OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
   // Create initial filespec.
   wsprintf (lpszFilename, "*.%s", (LPSTR) szDefExt);
   // Have the common dialog function return the filename in lpszFilename.
   ofn.lpstrFile = lpszFilename;
   if (!GetSaveFileName (&ofn))
      return FALSE;
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\srvrdemo\doc.c ===
/*
  OLE SERVER DEMO           
  Doc.c             
                                                                     
  This file contains document methods and various document-related support 
  functions.
                                                                     
  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved   
*/                                                                     
 
/* 
   Important Note:

   No method should ever dispatch a DDE message or allow a DDE message to
   be dispatched.
   Therefore, no method should ever enter a message dispatch loop.
   Also, a method should not show a dialog or message box, because the 
   processing of the dialog box messages will allow DDE messages to be
   dispatched.
*/



#define SERVERONLY
#include <windows.h>
#include <ole.h>

#include "srvrdemo.h"

/* AssociateClient
 * ---------------
 *
 * Add a client to the list of clients associated with an object.
 *
 * This function is necessary only because ServerDemo does not create object
 * structures as they are requested, but rather has a fixed set of objects.
 * When DocGetObject is called with a NULL object name, the entire 
 * document is requested, but ServerDemo does not currently support making
 * the entire document an object, so DocGetObject returns one object.
 * That object now goes by two names: NULL and its real name.  Therefore
 * we need to keep track of both lpoleclient's that were passed to 
 * DocGetObject.  Ideally, DocGetObject should always create a new OBJ 
 * structure containing a pointer (or some reference) to the object's native
 * data and also containing one lpoleclient.
 *
 * LPOLECLIENT lpoleclient - the client to be associated with the object.
 * LPOBJ lpobj             - the object 
 *
 * RETURNS: TRUE if successful
 *          FALSE if out of memory
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
static BOOL AssociateClient (LPOLECLIENT lpoleclient, LPOBJ lpobj)
{
   INT i;
   for (i=0; i < clpoleclient; i++)
   {
      if (lpobj->lpoleclient[i]==lpoleclient)
      {
         return TRUE;
      }
      if (lpobj->lpoleclient[i]==NULL)
      {
         lpobj->lpoleclient[i]=lpoleclient;
         return TRUE;
      }
   }
   return FALSE;
}



/* CreateNewDoc
 * ------------
 *
 * If lhdoc == NULL then we must register the new document by calling
 * OleRegisterServerDoc, which will return a new handle which will be stored
 * in docMain.lhdoc.
 * Also if lhdoc==NULL then this document is being created at the request of
 * the user, not of the client library.
 *
 * LONG lhdoc      - Document handle
 * LPSTR lpszDoc   - Title of the new document
 * DOCTYPE doctype - What type of document is being created
 * 
 * RETURNS: TRUE if successful, FALSE otherwise.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
BOOL CreateNewDoc (LONG lhdoc, LPSTR lpszDoc, DOCTYPE doctype)
{
   INT i;

   // Fill in the fields of the document structure.

   docMain.doctype      = doctype;
   docMain.oledoc.lpvtbl= &docvtbl;

   if (lhdoc == 0)
   {
      if (OLE_OK != OleRegisterServerDoc 
                     (srvrMain.lhsrvr, 
                      lpszDoc,
                      (LPOLESERVERDOC) &docMain, 
                      (LHSERVERDOC FAR *) &docMain.lhdoc))
         return FALSE;
   }
   else
      docMain.lhdoc = lhdoc;

   // Reset all the flags because no object numbers have been used.
   for (i=1; i <= cfObjNums; i++)
      docMain.rgfObjNums[i] = FALSE;

   fDocChanged = FALSE;

   SetTitle (lpszDoc, doctype == doctypeEmbedded);
   return TRUE;
}



/* DestroyDoc
 * ----------
 *
 * Free all memory that had been allocated for a document.
 *
 *
 * CUSTOMIZATION: Re-implement.  Your application will probably use some
 *                other method for enumerating all the objects in a document.
 *                ServerDemo enumerates the child windows, but if each object 
 *                does not have its own window, this will not work.
 *
 */
VOID DestroyDoc (VOID)
{
   HWND hwnd;
   HWND hwndNext;

   // Delete all object windows.  
   hwnd = SelectedObjectWindow();
   while (hwnd) 
   {
      hwndNext = GetWindow (hwnd, GW_HWNDNEXT);
      // Each object window frees its own memory upon receiving WM_DESTROY.
      DestroyWindow (hwnd);
      hwnd = hwndNext;
   } 

   if (docMain.aName)
   {
      GlobalDeleteAtom (docMain.aName);
      docMain.aName = '\0';
   }

   if (docMain.hpal)
      DeleteObject (docMain.hpal);
}



/* DocClose                DOCUMENT "Close" METHOD
 * --------
 *
 * The library calls this method to unconditionally close the document.
 *
 * LPOLESERVERDOC lpoledoc - The server document to close
 * 
 * RETURNS: Return value from RevokeDoc.
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY DocClose (LPOLESERVERDOC lpoledoc)
{
   return RevokeDoc();
}



/* DocExecute                DOCUMENT "Execute" METHOD
 * ----------
 *
 * This application does not support the execution of DDE execution commands.
 * 
 * LPOLESERVERDOC lpoledoc - The server document
 * HANDLE hCommands        - DDE execute commands
 * 
 * RETURNS: OLE_ERROR_COMMAND
 *
 * CUSTOMIZATION: Re-implement if your application supports the execution of
 *                DDE commands.
 *
 */
OLESTATUS  APIENTRY DocExecute (LPOLESERVERDOC lpoledoc, HANDLE hCommands)
{
   return OLE_ERROR_COMMAND;
}



/* DocGetObject                DOCUMENT "GetObject" METHOD
 * ------------
 *
 * The library uses this method to get an object's structure for the
 * client.  Memory needs to be allocated and initialized here for this.
 * A NULL string indicates that the client has an embedded object
 * which was started from Create, CreateFromTemplate, or Edit, but not Open.
 *
 * First see if the object name is NULL.  If so, you would ordinarily
 * return the entire document, but Server Demo returns the selected object.
 * If the object name is not NULL, then go through the list of objects, 
 * searching for one with that name.  Return an error if there is not one.
 *
 * LPOLESERVERDOC lpoledoc        - The server document
 * OLE_LPCSTR lpszObjectName           - The name of the object to get data for
 * LPOLEOBJECT FAR *lplpoleobject - The object's data is put here
 * LPOLECLIENT lpoleclient        - The client structure
 * 
 * RETURNS:        OLE_OK
 *                 OLE_ERROR_NAME if object not found
 *                 OLE_ERROR_MEMORY if no more memory to store lpoleclient
 *
 * CUSTOMIZATION: Re-implement.
 *                lpszObjectName == "" indicates that the whole document 
 *                should be the object returned.
 *
 */
OLESTATUS  APIENTRY DocGetObject
   (LPOLESERVERDOC lpoledoc, OLE_LPCSTR lpszObjectName, 
    LPOLEOBJECT FAR *lplpoleobject, LPOLECLIENT lpoleclient)
{
    HWND  hwnd;
    ATOM  aName;
    LPOBJ lpobj;


    if (lpszObjectName == NULL || lpszObjectName[0] == '\0')
    {   
        // Return a new object or the selected object.
        hwnd = SelectedObjectWindow();
        lpobj = hwnd ? HwndToLpobj (hwnd) : CreateNewObj (FALSE);
        *lplpoleobject = (LPOLEOBJECT) lpobj;
        // Associate client with object.
        if (!AssociateClient (lpoleclient, lpobj))
            return OLE_ERROR_MEMORY;
        return OLE_OK;
    }

    if (!(aName = GlobalFindAtom (lpszObjectName)))
        return OLE_ERROR_NAME;

    hwnd = SelectedObjectWindow();

    // Go through all the child windows and find the window whose name
    // matches the given object name.

    while (hwnd)
    {
         lpobj = HwndToLpobj (hwnd);

         if (aName == lpobj->aName)
         {
            // Return the object with the matching name.
            *lplpoleobject = (LPOLEOBJECT) lpobj;
            // Associate client with the object.
            if (!AssociateClient (lpoleclient, lpobj))
               return OLE_ERROR_MEMORY;
            return OLE_OK;
         }
         hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }

   if (((DOCPTR)lpoledoc)->doctype ==  doctypeEmbedded)
   {
      lpobj = CreateNewObj (FALSE);
      *lplpoleobject = (LPOLEOBJECT) lpobj;
      
      // Associate client with object.
      if (!AssociateClient (lpoleclient, lpobj))
         return OLE_ERROR_MEMORY;
      return OLE_OK;
    }

    // Object with name lpszObjName was not found.
    return OLE_ERROR_NAME;
}

/* DocRelease                DOCUMENT "Release" METHOD
 * ----------
 *
 * The library uses this method to notify the server that a revoked
 * document has finally finished all conversations, and can be 
 * destroyed.
 * It sets fWaitingForDocRelease to FALSE so a new document can be created
 * and the user can continue working.
 *
 * LPOLESERVERDOC lpoledoc        - The server document
 * 
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY DocRelease (LPOLESERVERDOC lpoledoc)
{
   fWaitingForDocRelease = FALSE;
   // Free all memory that has been allocated for the document.
   DestroyDoc();

   return OLE_OK;
}



/* DocSave                DOCUMENT "Save" METHOD
 * -------
 *
 * Save document to a file.
 *
 * LPOLESERVERDOC lpoledoc - The document to save
 * 
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY DocSave (LPOLESERVERDOC lpoledoc)
{
    if (docMain.doctype == doctypeFromFile)
    {
         // No "File Save As" dialog box will be brought up because the
         // file name is already known.
         return SaveDoc() ? OLE_OK : OLE_ERROR_GENERIC;
    }
    else
      return OLE_ERROR_GENERIC;
}



/* DocSetDocDimensions        DOCUMENT "SetDocDimensions" METHOD
 * -------------------
 *
 * The library calls this method to tell the server the bounds on
 * the target device for rendering the document.
 * A call to this method is ignored for linked objects because the size of
 * a linked document depends only on the source file.
 *
 * LPOLESERVERDOC lpoledoc - The server document
 * CONST LPRECT         lprect   - The target size in MM_HIMETRIC units
 * 
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: Re-implement
 *                How an object is sized is application-specific. (Server Demo
 *                uses MoveWindow.)
 *                     
 */
OLESTATUS  APIENTRY DocSetDocDimensions 
   (LPOLESERVERDOC lpoledoc, OLE_CONST RECT FAR * lprect)
{
   if (docMain.doctype == doctypeEmbedded)
   {
      RECT rect = *lprect;
      
      // the units are in HIMETRIC
      rect.right   = rect.right - rect.left;
		// the following was bottom - top
		rect.bottom  = rect.top -  rect.bottom;
		
      HiMetricToDevice ( (LPPOINT) &rect.right );
      MoveWindow (SelectedObjectWindow(), 0, 0, 
                  rect.right + 2 * GetSystemMetrics(SM_CXFRAME), 
                  rect.bottom + 2 * GetSystemMetrics(SM_CYFRAME), 
                  TRUE);
      /* If for some reason your application needs to notify the client that
         the data has changed because DocSetDocDimensions has been called,
         then notify the client here.
         SendDocMsg (OLE_CHANGED);
      */
   }
   return OLE_OK;
}



/* DocSetHostNames        DOCUMENT "SetHostNames" METHOD
 * ---------------
 *
 * The library uses this method to set the name of the document
 * window.
 * All this function does is change the title bar text, although it could
 * do more if necesary. 
 * This function is only called for embedded objects; linked objects
 * use their filenames for the title bar text.
 *
 * LPOLESERVERDOC lpoledoc    - The server document
 * OLE_LPCSTR lpszClient           - The name of the client
 * OLE_LPCSTR lpszDoc              - The client's name for the document
 * 
 * RETURNS:        OLE_OK
 * 
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY DocSetHostNames 
   (LPOLESERVERDOC lpoledoc, OLE_LPCSTR lpszClient, OLE_LPCSTR lpszDoc)
{
   SetTitle ((LPSTR)lpszDoc, TRUE);
   lstrcpy ((LPSTR) szClient, lpszClient);
   lstrcpy ((LPSTR) szClientDoc, Abbrev((LPSTR)lpszDoc));
   UpdateFileMenu (IDM_UPDATE);   
   return OLE_OK;
}



/* DocSetColorScheme                DOCUMENT "SetColorScheme" METHOD
 * -----------------
 *
 * The client calls this method to suggest a color scheme (palette) for
 * the server to use.
 * In Server Demo the document's palette is never actually used because each 
 * object has its own palette.  See ObjSetColorScheme.
 *
 * LPOLESERVERDOC lpoledoc - The server document
 * CONST LOGPALETTE FAR * lppal    - Suggested palette
 *
 * RETURNS: OLE_ERROR_PALETTE if CreatePalette fails, 
 *          OLE_OK otherwise
 *
 * 
 * CUSTOMIZATION: If your application supports color schemes, then this 
 *                function is a good example of how to create and store
 *                a palette.
 */
OLESTATUS  APIENTRY DocSetColorScheme 
   (LPOLESERVERDOC lpoledoc, OLE_CONST LOGPALETTE FAR * lppal)
{
   HPALETTE hpal = CreatePalette (lppal);

   if (hpal==NULL)
      return OLE_ERROR_PALETTE;

   if (docMain.hpal) 
   {
      // Delete old palette
      DeleteObject (docMain.hpal);
   }
   // Store handle to new palette
   docMain.hpal = hpal;
   return OLE_OK;
}



/* RevokeDoc
 * ---------
 *
 * Call OleRevokeServerDoc.
 * If the return value is OLE_WAIT_FOR_BUSY, then set fWaitingForDocRelease
 * and enter a message-dispatch loop until fWaitingForDocRelease is reset.
 * As long as fWaitingForDocRelease is set, the user interface will be 
 * disabled so that the user will not be able to manipulate the document.
 * When the DocRelease method is called, it will reset fWaitingForDocRelease,
 * allowing RevokeDoc to free the document's memory and return.
 *
 * This is essentially a way to make an asynchronous operation synchronous.
 * We need to wait until the old document is revoked before we can delete
 * its data and create a new one.
 *
 * Note that we cannot call RevokeDoc from a method because it is illegal to
 * enter a message-dispatch loop within a method.
 *
 * RETURNS: The return value of OleRevokeServerDoc.
 *
 * CUSTOMIZATION: lhdoc may need to be passed in as a parameter if your 
 *                application does not have a global variable corresponding 
 *                to docMain.
 * 
 */
OLESTATUS RevokeDoc (VOID)
{
   OLESTATUS olestatus;

   if ((olestatus = OleRevokeServerDoc(docMain.lhdoc)) > OLE_WAIT_FOR_RELEASE)
      DestroyDoc();

   docMain.lhdoc = 0; // A NULL handle indicates that the document 
                         // has been revoked or is being revoked.
   return olestatus;

}



/* SaveChangesOption
 * -----------------
 *
 * Give the user the opportunity to save changes to the current document
 * before continuing.
 *
 * BOOL *pfUpdateLater - Will be set to TRUE if the client does not accept
 *                       the update and needs to be updated when the document
 *                       is closed.  In that case, OLE_CLOSED will be sent.
 *
 * RETURNS: IDYES, IDNO, or IDCANCEL
 *
 * CUSTOMIZATION: None
 *
 */
INT SaveChangesOption (BOOL *pfUpdateLater)
{
   INT  nReply;
   CHAR szBuf[cchFilenameMax];
   
   *pfUpdateLater = FALSE;
   
   if (fDocChanged)
   {
       CHAR szTmp[cchFilenameMax];
       
       if (docMain.aName) 
           GlobalGetAtomName (docMain.aName, szTmp, cchFilenameMax);
       else 
           szTmp[0] = '\0';

       if (docMain.doctype == doctypeEmbedded)
           wsprintf (szBuf, "The object has been changed.\n\nUpdate %s before closing the object?", Abbrev (szTmp));        
       else
           lstrcpy (szBuf, (LPSTR) "Save changes?");         
     
       nReply = MessageBox (hwndMain, szBuf, szAppName, 
                      MB_ICONEXCLAMATION | MB_YESNOCANCEL);
                  
       switch (nReply)
       {
          case IDYES:
              if (docMain.doctype != doctypeEmbedded)
                  SaveDoc();
              else
                  switch (OleSavedServerDoc (docMain.lhdoc))
                  {
                      case OLE_ERROR_CANT_UPDATE_CLIENT:
                          *pfUpdateLater = TRUE;
                          break;
                      case OLE_OK:
                          break;
                      default:
                          ErrorBox ("Fatal Error: Cannot update.");
                  }                                      
              return IDYES;
          case IDNO:
              return IDNO;
         case IDCANCEL:
              return IDCANCEL;
       }
   }
   return TRUE;
}



/* SendDocMsg
 * ----------
 *
 * This function sends messages to all the objects in a document when
 * the document has changed.
 *
 * WORD wMessage - The message to send
 * 
 * CUSTOMIZATION: The means of enumerating all the objects in a document
 *                is application specific.
 */
VOID SendDocMsg (WORD wMessage)
{
    HWND    hwnd;

    // Get handle to first object window.
    hwnd = SelectedObjectWindow();

    // Send message to all object windows.
    while (hwnd)
    {
        SendObjMsg (HwndToLpobj(hwnd), wMessage);
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\srvrdemo\obj.c ===
/*
  OLE SERVER DEMO           
  Obj.c             
                                                                     
  This file contains object methods and various object-related support 
  functions.
                                                                     
  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved   
*/                                                                     

/* 
   Important Note:

   No method should ever dispatch a DDE message or allow a DDE message to
   be dispatched.
   Therefore, no method should ever enter a message dispatch loop.
   Also, a method should not show a dialog or message box, because the 
   processing of the dialog box messages will allow DDE messages to be
   dispatched.
*/


#define SERVERONLY
#include <windows.h>
#include <ole.h>

#include "srvrdemo.h"



// Static functions.
static HBITMAP GetBitmap (LPOBJ lpobj);
static HANDLE  GetLink (LPOBJ lpobj);
static HANDLE  GetMetafilePict (LPOBJ lpobj);
static HANDLE  GetEnhMetafile (LPOBJ lpobj);
static HANDLE  GetNative (LPOBJ lpobj);
static INT     GetObjNum (LPOBJ lpobj);
static HANDLE  GetText (LPOBJ lpobj);
static VOID    DrawObj (HDC hdc, LPOBJ lpobj, RECT rc, INT dctype);



/* CreateNewObj
 * ------------
 *
 * BOOL fDoc_Changed - The new value for the global variable fDocChanged.
 *                     When initializing a new document, we need to create 
 *                     a new object without the creation counting as a 
 *                     change to the document.
 *
 * RETURNS: A pointer to the new object
 *
 * 
 * CUSTOMIZATION: Re-implement
 *                Some applications (like Server Demo) have a finite number of
 *                fixed, distinct, non-overlapping objects.  Other applications
 *                allow the user to create an object from any section of the
 *                document.  For example, the user might select a portion of
 *                a bitmap from a paint program, or a few lines of text from
 *                a word processor.  This latter type of application probably
 *                will not have a function like CreateNewObj.
 *
 */
LPOBJ CreateNewObj (BOOL fDoc_Changed)
{
    HANDLE hObj = NULL;
    LPOBJ  lpobj = NULL;
    // index into an array of flags indicating if that object number is used.
    INT    ifObj = 0;    

    if ((hObj = LocalAlloc (LMEM_MOVEABLE|LMEM_ZEROINIT, sizeof (OBJ))) == NULL)
      return NULL;

    if ((lpobj = (LPOBJ) LocalLock (hObj)) == NULL)
    {
      LocalFree (hObj);
      return NULL;
    }

    // Fill the fields in the object structure.
    
    // Find an unused number.
    for (ifObj=1; ifObj <= cfObjNums; ifObj++)
    {
      if (docMain.rgfObjNums[ifObj]==FALSE)
      {
         docMain.rgfObjNums[ifObj]=TRUE;
         break;
      }
    }

    if (ifObj==cfObjNums+1)
    {
      // Cannot create any more objects.
      MessageBeep(0);
      return NULL;
    }

    wsprintf (lpobj->native.szName, "Object %d", ifObj);

    lpobj->aName            = GlobalAddAtom (lpobj->native.szName);
    lpobj->hObj             = hObj;
    lpobj->oleobject.lpvtbl = &objvtbl;
    lpobj->native.idmColor  = IDM_RED;    // Default color 
    lpobj->native.version   = version;
    lpobj->native.nWidth    = OBJECT_WIDTH;          // Default size
    lpobj->native.nHeight   = OBJECT_HEIGHT;
    SetHiMetricFields (lpobj);

    // Place object in a location corrsponding to its number, for aesthetics.
    lpobj->native.nX = (ifObj - 1) * 20;
    lpobj->native.nY = (ifObj - 1) * 20;

    if (!CreateWindow (
        "ObjClass",
        "Obj",
        WS_BORDER | WS_THICKFRAME | WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE,
        lpobj->native.nX,
        lpobj->native.nY,
        lpobj->native.nWidth,
        lpobj->native.nHeight,
        hwndMain,
        NULL,
        hInst,
        (LPSTR) lpobj ))
         return FALSE;

    fDocChanged = fDoc_Changed;

    return lpobj;
}



/* CutOrCopyObj
 * ------------
 *
 * Put data onto clipboard in all the formats supported.  If the 
 * fOpIsCopy is TRUE, the operation is COPY, otherwise it is CUT.
 * This is important, because we cannot put the Object Link format
 * onto the clipboard if the object was cut from the document (there is
 * no longer anything to link to).
 *
 * BOOL fOpIsCopy - TRUE if the operation is COPY; FALSE if CUT
 * 
 * CUSTOMIZATION: None
 *
 *
 */
VOID CutOrCopyObj (BOOL fOpIsCopy)
{
    LPOBJ       lpobj;
    HANDLE      hData;
//	 UINT     hBit;

    if (OpenClipboard (hwndMain))
    {
        EmptyClipboard ();

        lpobj = SelectedObject();

        if ((hData = GetNative (lpobj)) != NULL)
            SetClipboardData(cfNative, hData);

        if ((hData = GetLink(lpobj)) != NULL)
            SetClipboardData(cfOwnerLink, hData);

        if (fOpIsCopy && docMain.doctype == doctypeFromFile)
        {
            // Can create a link if object exists in a file.
            if ((hData = GetLink(lpobj)) != NULL)
               SetClipboardData(cfObjectLink, hData);
        }

        if ((hData = GetEnhMetafile(lpobj)) != NULL)
        {
            SetClipboardData(CF_ENHMETAFILE, hData);
              GlobalFree(hData);
        }

        if ((hData = GetBitmap(lpobj)) != NULL)
        {
        //	  SetClipboardData(CF_BITMAP, GetBitmap(lpobj));
              SetClipboardData(CF_BITMAP, hData);
              DeleteObject(hData);
        }


        CloseClipboard ();
    }
}


/* DestroyObj
 * ----------
 *
 * Revoke an object, and free all memory that had been allocated for it.
 *
 * HWND hwnd - The object's window
 * 
 * CUSTOMIZATION: Re-implement, making sure you free all the memory that
 *                had been allocated for the OBJ structure and each of its
 *                fields.
 * 
 */
VOID DestroyObj (HWND hwnd)
{
   LPOBJ lpobj = HwndToLpobj (hwnd);

   if(lpobj->aName)
   {
      GlobalDeleteAtom (lpobj->aName);
      lpobj->aName = '\0';
   }

   if (lpobj->hpal) 
      DeleteObject (lpobj->hpal);
   // Allow the object's number to be reused.
   docMain.rgfObjNums [GetObjNum(lpobj)] = FALSE;


   // Free the memory that had been allocated for the object structure itself.
   LocalUnlock (lpobj->hObj);
   LocalFree (lpobj->hObj);
}



/* DrawObj
 * -------
 *
 * This function draws an object onto the screen, into a metafile, or into
 * a bitmap.
 * The object will always look the same.
 *
 * HDC    hdc    - The device context to render the object into
 * LPOBJ  lpobj  - The object to render
 * RECT   rc     - The rectangle bounds of the object
 * DCTYPE dctype - The type of device context.
 * 
 * CUSTOMIZATION: Server Demo specific
 *
 */
static VOID DrawObj (HDC hdc, LPOBJ lpobj, RECT rc, INT dctype)
{
   HPEN     hpen;
   HPEN     hpenOld;
   HPALETTE hpalOld = NULL;


   if (dctype == dctypeMetafile)
   {
      SetWindowOrgEx (hdc, 0, 0, NULL);
      // Paint entire object into the given rectangle.
      SetWindowExtEx (hdc, rc.right, rc.bottom, NULL);
   }
 
   if (lpobj->hpal)
   {
      hpalOld = SelectPalette (hdc, lpobj->hpal, TRUE);
      RealizePalette (hdc);
   }

   // Select brush of the color specified in the native data.
   SelectObject (hdc, hbrColor [lpobj->native.idmColor - IDM_RED] );

   hpen = CreatePen (PS_SOLID, 
                     /* Width */ (rc.bottom-rc.top) / 10,
                     /* Gray */ 0x00808080);
   hpenOld = SelectObject (hdc, hpen);

   // Draw rectangle with the gray pen and fill it in with the selected brush.
   Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);

   // Print name of object inside rectangle.
   SetBkMode (hdc, TRANSPARENT);
   SetTextAlign (hdc, TA_BASELINE | TA_CENTER);
   TextOut (hdc, 
            rc.right/2, 
            (rc.top+rc.bottom)/2, 
            lpobj->native.szName, 
            lstrlen (lpobj->native.szName));

   // Restore original objects
   SelectObject (hdc, 
                 (dctype == dctypeMetafile || dctype == dctypeEnhMetafile) 
                     ? GetStockObject (BLACK_PEN) : hpenOld);
   if (hpalOld)
   {
      SelectPalette (hdc, 
                     (dctype == dctypeMetafile || dctype == dctypeEnhMetafile) 
                        ? GetStockObject (DEFAULT_PALETTE) : hpalOld,
                     TRUE);
   }

   DeleteObject (hpen);
}



/* GetBitmap
 * ---------
 *
 * Return a handle to an object's picture data in bitmap format.
 *
 * LPOBJ lpobj - The object
 * 
 * RETURNS: A handle to the object's picture data
 * 
 * CUSTOMIZATION: Re-implement
 * 
 */
static HBITMAP GetBitmap (LPOBJ lpobj)
{
    HDC         hdcObj;
    HDC         hdcMem;
    RECT        rc;
    HBITMAP     hbitmap;
    HBITMAP    hbitmapOld;


    hdcObj = GetDC (lpobj->hwnd);
    // Create a memory device context.
    hdcMem = CreateCompatibleDC (hdcObj);
    GetClientRect (lpobj->hwnd, (LPRECT)&rc);
    // Create new bitmap object based on the bitmap of the OLE object.
    hbitmap = CreateCompatibleBitmap 
      (hdcObj, rc.right - rc.left, rc.bottom - rc.top);
    // Select new bitmap as the bitmap object for the memory device context.
    hbitmapOld = SelectObject (hdcMem, hbitmap);

    // Paint directly into the memory dc using the new bitmap object.
    DrawObj (hdcMem, lpobj, rc, dctypeBitmap);

    // Restore old bitmap object.
    hbitmap = SelectObject (hdcMem, hbitmapOld);
    DeleteDC (hdcMem);
    ReleaseDC (lpobj->hwnd, hdcObj);

    // convert width and height to HIMETRIC units
    rc.right  = rc.right - rc.left;
    rc.bottom = rc.bottom - rc.top;
    DeviceToHiMetric ( (LPPOINT) &rc.right );
    
    // Set the 1/10 of HIMETRIC units for the bitmap
    SetBitmapDimensionEx (hbitmap, (DWORD) (rc.right/10), (DWORD) (rc.bottom/10), NULL);

//    if (OpenClipboard (hwndMain))
//    {
//  //      EmptyClipboard ();
//          SetClipboardData(CF_BITMAP, hbitmap);
//          CloseClipboard();
//    }
	 return hbitmap;
}



/* GetLink
 * -------
 *
 * Return a handle to an object's object or owner link data.
 * Link information is in the form of three zero-separated strings,
 * terminated with two zero bytes:  CLASSNAME\0DOCNAME\0OBJNAME\0\0
 *
 * LPOBJ lpobj - The object 
 * 
 * RETURNS: A handle to the object's link data
 * 
 * CUSTOMIZATION: Re-implement
 *
 */
static HANDLE GetLink (LPOBJ lpobj)
{

    CHAR   sz[cchFilenameMax];
    LPSTR  lpszLink = NULL;
    HANDLE hLink = NULL;
    INT    cchLen;
    INT    i;

    // First make the class name.
    lstrcpy (sz, szClassName);
    cchLen = lstrlen (sz) + 1;

    // Then the document name.
    cchLen += GlobalGetAtomName 
               (docMain.aName, (LPSTR)sz + cchLen, 
                cchFilenameMax - cchLen) + 1;

    // Then the object name.
    lstrcpy (sz + cchLen, lpobj->native.szName);
    cchLen += lstrlen (lpobj->native.szName) + 1;

    // Add a second null to the end.
    sz[cchLen++] = 0;       


    hLink = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, cchLen);
    if (hLink == NULL)
      return NULL;
    if ((lpszLink = GlobalLock (hLink)) == NULL)
    {
      GlobalFree (hLink);
      return NULL;
    }

    for (i=0; i < cchLen; i++)
        lpszLink[i] = sz[i];

    GlobalUnlock (hLink);

    return hLink;
}



/* GetMetafilePict
 * ---------------
 *
 * Return a handle to an object's picture data in metafile format.
 *
 * LPOBJ lpobj - The object
 * 
 * RETURNS: A handle to the object's data in metafile format.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static HANDLE GetMetafilePict (LPOBJ lpobj)
{

    LPMETAFILEPICT  lppict = NULL;
    HANDLE          hpict = NULL;
    HANDLE          hMF = NULL;
    RECT            rc;
    HDC             hdc;

    hdc = CreateMetaFile(NULL);

    GetClientRect (lpobj->hwnd, (LPRECT)&rc);

    // Paint directly into the metafile.
    DrawObj (hdc, lpobj, rc, dctypeMetafile);

    // Get handle to the metafile.
    if ((hMF = CloseMetaFile (hdc)) == NULL)
      return NULL;

    if(!(hpict = GlobalAlloc (GMEM_DDESHARE, sizeof (METAFILEPICT))))
    {
        DeleteMetaFile (hMF);
        return NULL;
    }

    if ((lppict = (LPMETAFILEPICT)GlobalLock (hpict)) == NULL)
    {
        DeleteMetaFile (hMF);
        GlobalFree (hpict);
        return NULL;
    }

    rc.right  = rc.right - rc.left;
    rc.bottom = rc.bottom - rc.top;
    
    DeviceToHiMetric ( (LPPOINT) &rc.right);

    lppict->mm   =  MM_ANISOTROPIC;
    lppict->hMF  =  hMF;
    lppict->xExt =  rc.right;
    lppict->yExt =  rc.bottom;
    GlobalUnlock (hpict);
    return hpict;
}

/* GetEnhMetafile
 * ---------------
 *
 * Return a handle to an object's picture data in metafile format.
 *
 * LPOBJ lpobj - The object
 * 
 * RETURNS: A handle to the object's data in metafile format.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static HANDLE GetEnhMetafile (LPOBJ lpobj)
{

    LPMETAFILEPICT  lppict = NULL;
    HANDLE          hemf   = NULL;
    HANDLE          hMF    = NULL;
    RECT            rc;
    HDC             hdc, hdc2;


    GetClientRect (lpobj->hwnd, (LPRECT)&rc);

    rc.right   -= rc.left;
    rc.bottom  -= rc.top;
    rc.left     = rc.top  = 0;
	 
    DeviceToHiMetric ( (LPPOINT) &rc.right );
	 
    hdc = CreateEnhMetaFile ( NULL, NULL, &rc, NULL );
    
                                       //* this is necessary because
                                       //* we need to draw the object
                                       //* in device coordinates that are
                                       //* the same physical size as the HIMETRIC
                                       //* logical space used in CreateEnhMetaFile.
                                       //* In this case we have scaled the HIMETRIC
                                       //* units down in order to use the logical
                                       //* pixel ratio (which is recommended UI)
                                       //* so we therefore have to convert the
                                       //* scaled HIMETRIC units back to Device.
                                      
    hdc2 = GetDC(NULL);				

    SetMapMode(hdc2, MM_HIMETRIC);
    LPtoDP (hdc2, (LPPOINT)&rc.right, 1);
    if (rc.bottom < 0) rc.bottom *= -1;

    ReleaseDC(NULL,hdc2);

	DrawObj (hdc, lpobj, rc, dctypeMetafile);

    if ((hemf = (HANDLE)CloseEnhMetaFile (hdc)) == NULL)
      return NULL;

    return hemf;
}


/* GetNative
 * ---------
 *
 * Return a handle to an object's native data.
 *
 * LPOBJ lpobj - The object whose native data is to be retrieved.
 * 
 * RETURNS: a handle to the object's native data.
 *
 * CUSTOMIZATION: The line "*lpnative = lpobj->native;" will change to 
 *                whatever code is necessary to copy an object's native data.
 *
 */
static HANDLE GetNative (LPOBJ lpobj)
{
   LPNATIVE lpnative = NULL;
   HANDLE   hNative  = NULL;

   hNative = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, sizeof (NATIVE));
   if (hNative == NULL)
      return NULL;
   if ((lpnative = (LPNATIVE) GlobalLock (hNative)) == NULL)
   {
      GlobalFree (hNative);
      return NULL;
   }

   // Copy the native data.
   *lpnative = lpobj->native;

   GlobalUnlock (hNative);
   return hNative;
}



/* GetObjNum
 * ---------
 *
 * LPSTR lpobj - The object whose number is desired
 *
 * RETURNS: The number of the object, i.e., the numerical portion of its name.
 *
 * CUSTOMIZATION: Server Demo specific
 */
static INT GetObjNum (LPOBJ lpobj)
{
   LPSTR lpsz;
   INT n=0;

   lpsz = lpobj->native.szName + 7;
   while (*lpsz && *lpsz>='0' && *lpsz<='9')
      n = 10*n + *lpsz++ - '0';
   return n;
}



/* GetText
 * -------
 *
 * Return a handle to an object's data in text form.
 * This function simply returns the name of the object.
 *
 * LPOBJ lpobj - The object
 * 
 * RETURNS: A handle to the object's text.
 *
 * CUSTOMIZATION: Re-implement, if your application supports CF_TEXT as a 
 *                presentation format.
 *
 */
static HANDLE GetText (LPOBJ lpobj)
{
    HANDLE hText    = NULL;
    LPSTR  lpszText = NULL;

    if(!(hText = GlobalAlloc (GMEM_DDESHARE, sizeof (lpobj->native.szName))))
      return NULL;

    if (!(lpszText = GlobalLock (hText)))
      return NULL;

    lstrcpy (lpszText, lpobj->native.szName);

    GlobalUnlock (hText);

    return hText;
}



/* ObjDoVerb                OBJECT "DoVerb" METHOD
 * ---------
 *
 * This method is called by the client, through the library, to either
 * PLAY, or EDIT the object.  PLAY is implemented as a beep, and
 * EDIT will bring up the server and show the object for editing.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * WORD wVerb              - The verb acting on the object: PLAY or EDIT
 * BOOL fShow              - Should the object be shown?
 * BOOL fTakeFocus         - Should the object window get the focus?
 * 
 * RETURNS:        OLE_OK
 *
 * CUSTOMIZATION: Add any more verbs your application supports.
 *                Implement verbPlay if your application supports it.
 *
 */
OLESTATUS  APIENTRY ObjDoVerb 
   (LPOLEOBJECT lpoleobject, UINT wVerb, BOOL fShow, BOOL fTakeFocus)
{
    switch (wVerb) 
    {
         case verbPlay:
         {  // The application can do whatever is appropriate for the object.
            INT i;
            for (i=0; i<25;i++) MessageBeep (0);
            return OLE_OK;
         }

         case verbEdit:
            if (fShow)
               return objvtbl.Show (lpoleobject, fTakeFocus);
            else
               return OLE_OK;
         default:
            // Unknown verb.
            return OLE_ERROR_DOVERB;
    }
}



/* ObjEnumFormats        OBJECT "EnumFormats" METHOD
 * ---------------
 *
 * This method is used to enumerate all supported clipboard formats.
 * Terminate by returning NULL.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * OLECLIPFORMAT cfFormat  - The 'current' clipboard format
 * 
 * RETURNS: The 'next' clipboard format which is supported.
 *
 * CUSTOMIZATION: Verify that the list of formats this function 
 *                returns matches the list of formats your application 
 *                supports.
 *
 */
OLECLIPFORMAT  APIENTRY ObjEnumFormats
   (LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat)
{
      if (cfFormat == 0)
        return cfNative;

      if (cfFormat == cfNative)
         return cfOwnerLink;

      if (cfFormat == cfOwnerLink)
         return CF_ENHMETAFILE;

      if (cfFormat == CF_ENHMETAFILE)
         return CF_METAFILEPICT;

      if (cfFormat == CF_METAFILEPICT)
         return CF_BITMAP;

      if (cfFormat == CF_BITMAP)
         return cfObjectLink;

      if (cfFormat == cfObjectLink)
         return 0;

      return 0;
}



/* ObjGetData                OBJECT "GetData" METHOD
 * -----------
 *
 * Return the data requested for the specified object in the specified format.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * WORD cfFormat           - The data type requested in standard
 *                           clipboard format
 * LPHANDLE lphandle       - Pointer to handle to memory where data
 *                           will be stored
 * 
 * RETURNS: OLE_OK           if successful
 *          OLE_ERROR_MEMORY if there was an error getting the data.
 *          OLE_ERROR_FORMAT if the requested format is unknown.
 *
 * 
 * CUSTOMIZATION: Add any additional formats your application supports, and
 *                remove any formats it does not support.
 *
 */
OLESTATUS  APIENTRY ObjGetData
   (LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat, LPHANDLE lphandle)
{

   LPOBJ lpobj;

   lpobj = (LPOBJ) lpoleobject;

   if (cfFormat ==  cfNative)
   {
      if (!(*lphandle = GetNative (lpobj)))
         return OLE_ERROR_MEMORY;
      // The client has requested the data in native format, therefore
      // the data in the client and server are in sync.
      fDocChanged = FALSE;
      return OLE_OK; 
   }                

   if (cfFormat == CF_ENHMETAFILE)
   {
      if (!(*lphandle = GetEnhMetafile (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat == CF_METAFILEPICT)
   {
      if (!(*lphandle = GetMetafilePict (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat == CF_BITMAP)
   {
      if (!(*lphandle = (HANDLE)GetBitmap (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat == CF_TEXT) 
   {
      if (!(*lphandle = GetText (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat == cfObjectLink)
   {
      if (!(*lphandle = GetLink (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat ==  cfOwnerLink)
   {
      if (!(*lphandle = GetLink (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   return OLE_ERROR_FORMAT;
}



/* ObjQueryProtocol                OBJECT "QueryProtocol" METHOD
 * ----------------
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * OLE_LPCSTR lpszProtocol      - The protocol name, either "StdFileEditing"
 *                           or "StdExecute"
 * 
 * RETURNS: If lpszProtocol is supported, return a pointer to an OLEOBJECT 
 *          structure with an appropriate method table for that protocol.
 *          Otherwise, return NULL.
 *
 * CUSTOMIZATION: Allow any additional protocols your application supports.
 *
 *
 */
LPVOID  APIENTRY ObjQueryProtocol 
   (LPOLEOBJECT lpoleobject, OLE_LPCSTR lpszProtocol)
{
   return lstrcmp (lpszProtocol, "StdFileEditing") ? NULL : lpoleobject ;
}



/* ObjRelease                OBJECT "Release" METHOD
 * -----------
 *
 * The server application should not destroy data when the library calls the 
 * ReleaseObj method.
 * The library calls the ReleaseObj method when no clients are connected 
 * to the object.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * 
 * RETURNS: OLE_OK
 * 
 * CUSTOMIZATION: Re-implement.  Do whatever needs to be done, if anything,
 *                when no clients are connected to an object.
 *
 */
OLESTATUS  APIENTRY ObjRelease (LPOLEOBJECT lpoleobject)
{
   INT i;
   /* No client is connected to the object so break all assocaiations
      between clients and the object. */
   for (i=0; i < clpoleclient; i++)
      ((LPOBJ)lpoleobject)->lpoleclient[i] = NULL;
   return OLE_OK;
}



/* ObjSetBounds        OBJECT "SetBounds" METHOD
 * ------------
 *
 * This method is called to set new bounds for an object.
 * The bounds are in HIMETRIC units.
 * A call to this method is ignored for linked objects because the size of
 * a linked object depends only on the source file.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * OLE_CONST RECT FAR* lprect           - The new bounds
 * 
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: Re-implement
 *                How an object is sized is application-specific. (Server Demo
 *                uses MoveWindow.)
 *
 */
OLESTATUS  APIENTRY ObjSetBounds (LPOLEOBJECT lpoleobj, OLE_CONST RECT FAR * lprect)
{
   if (docMain.doctype == doctypeEmbedded)
   {
      RECT rect = *lprect;
      LPOBJ lpobj = (LPOBJ) lpoleobj;
      
      // the units are in HIMETRIC
      rect.right   = rect.right - rect.left;
      rect.bottom  = rect.top - rect.bottom;
      HiMetricToDevice ( (LPPOINT) &rect.right);
      MoveWindow (lpobj->hwnd, lpobj->native.nX, lpobj->native.nY, 
                  rect.right + 2 * GetSystemMetrics(SM_CXFRAME), 
                  rect.bottom + 2 * GetSystemMetrics(SM_CYFRAME), 
                  TRUE);
   }
   return OLE_OK;
}



/* ObjSetColorScheme                OBJECT "SetColorScheme" METHOD
 * -----------------
 *
 * The client calls this method to suggest a color scheme (palette) for
 * the server to use for the object.
 *
 * LPOLEOBJECT  lpoleobject       - The OLE object
 * OLE_CONST LOGPALETTE FAR * lppal             - Suggested palette
 *
 * RETURNS: OLE_ERROR_PALETTE if CreatePalette fails, 
 *          OLE_OK otherwise
 *
 * 
 * CUSTOMIZATION: If your application supports color schemes, then this 
 *                function is a good example of how to create and store
 *                a palette.
 *
 */
OLESTATUS  APIENTRY ObjSetColorScheme 
   (LPOLEOBJECT lpoleobject, OLE_CONST LOGPALETTE FAR *lppal)
{
   HPALETTE hpal = CreatePalette (lppal);
   LPOBJ lpobj   = (LPOBJ) lpoleobject;

   if (hpal==NULL)
      return OLE_ERROR_PALETTE;

   if (lpobj->hpal) 
      DeleteObject (lpobj->hpal);
   lpobj->hpal = hpal;
   return OLE_OK;
}



/* ObjSetData                OBJECT "SetData" METHOD
 * ----------
 *
 * This method is used to store data into the object in the specified
 * format.  This will be called with Native format after an embedded
 * object has been opened by the Edit method.
 *
 * LPOLEOBJECT lpoleobject      - The OLE object
 * WORD cfFormat                - Data type, i.e., clipboard format
 * HANDLE hdata                 - Handle to the data.
 * 
 * RETURNS:       OLE_OK if the data was stored properly
 *                OLE_ERROR_FORMAT if format was not cfNative.
 *                OLE_ERROR_MEMORY if memory could not be locked.
 * 
 * CUSTOMIZATION: The large then-clause will need to be re-implemented for
 *                your application.  You may wish to support additional
 *                formats besides cfNative.
 *
 */
OLESTATUS  APIENTRY ObjSetData 
   (LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat, HANDLE hdata)
{
    LPNATIVE lpnative;
    LPOBJ    lpobj;

    lpobj = (LPOBJ)lpoleobject;

    if (cfFormat != cfNative)
    {
      return OLE_ERROR_FORMAT;
    }

    lpnative = (LPNATIVE) GlobalLock (hdata);

    if (lpnative)
    {
        lpobj->native = *lpnative;
        if (lpobj->aName)
            GlobalDeleteAtom (lpobj->aName);
        lpobj->aName = GlobalAddAtom (lpnative->szName);
        // CreateNewObj made an "Object 1" but we may be changing its number.
        docMain.rgfObjNums[1] = FALSE;
        docMain.rgfObjNums [GetObjNum(lpobj)] = TRUE;

        MoveWindow (lpobj->hwnd, 0, 0,
//                    lpobj->native.nWidth + 2 * GetSystemMetrics(SM_CXFRAME), 
//                    lpobj->native.nHeight+ 2 * GetSystemMetrics(SM_CYFRAME),
                    lpobj->native.nWidth, 
                    lpobj->native.nHeight,

                    FALSE);
        GlobalUnlock (hdata);
    }
    // Server is responsible for deleting the data.
    GlobalFree(hdata);           
    return lpnative ? OLE_OK : OLE_ERROR_MEMORY;
}



/* ObjSetTargetDevice        OBJECT "SetTargetDevice" METHOD
 * -------------------
 *
 * This method is used to indicate the device type that an object
 * will be rendered on.  It is the server's responsibility to free hdata.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * HANDLE hdata            - Handle to memory containing
 *                           a StdTargetDevice structure
 * 
 * RETURNS: OLE_OK
 * 
 * CUSTOMIZATION: Implement.  Server Demo currently does not do anything.
 *
 */
OLESTATUS  APIENTRY ObjSetTargetDevice (LPOLEOBJECT lpoleobject, HANDLE hdata)
{
    if (hdata == NULL)
    {
      // Rendering for the screen is requested.
    }
    else
    {
      LPSTR lpstd = (LPSTR) GlobalLock (hdata);
      // lpstd points to a StdTargetDevice structure.
      // Use it to do whatever is appropriate to generate the best results 
      // on the specified target device.
      GlobalUnlock (hdata);
      // Server is responsible for freeing the data.
      GlobalFree (hdata);  
    }
    return OLE_OK;
}



/* ObjShow                OBJECT "Show" METHOD
 * --------
 *
 * This method is used to display the object.  
 * The server application should be activated and brought to the top.
 * Also, in a REAL server application, the object should be scrolled
 * into view.  The object should be selected.
 *
 * LPOLEOBJECT lpoleobject - Pointer to the OLE object
 * BOOL fTakeFocus         - Should server window get the focus?
 * 
 * RETURNS:        OLE_OK
 *
 * 
 * CUSTOMIZATION: In your application, the document should be scrolled 
 *                to bring the object into view.  Server Demo brings the 
 *                object to the front, in case it is a linked object inside a 
 *                document with other objects obscuring it.
 *
 */
OLESTATUS  APIENTRY ObjShow (LPOLEOBJECT lpoleobject, BOOL fTakeFocus)
{
    LPOBJ lpobj;
    HWND hwndOldFocus;

    hwndOldFocus = GetFocus();
    lpobj = (LPOBJ) lpoleobject;
    
    if (fTakeFocus)
       SetForegroundWindow (lpobj->hwnd);

    ShowWindow(hwndMain, SW_SHOWNORMAL);

    SetFocus (fTakeFocus ? lpobj->hwnd : hwndOldFocus);
    return OLE_OK;
}



/* PaintObj
 * ---------
 *
 * This function is called by the WM_PAINT message to paint an object 
 * on the screen.  
 *
 * HWND hwnd - The object window in which to paint the object
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
VOID PaintObj (HWND hwnd)
{
    LPOBJ       lpobj;
    RECT        rc;
    HDC         hdc;
    PAINTSTRUCT paintstruct;

    BeginPaint (hwnd, &paintstruct);
    hdc = GetDC (hwnd);

    lpobj = HwndToLpobj (hwnd);
    GetClientRect (hwnd, (LPRECT) &rc);

    DrawObj (hdc, lpobj, rc, dctypeScreen);

    ReleaseDC (hwnd, hdc);
    EndPaint (hwnd, &paintstruct);
}



/* RevokeObj
 * ---------
 *
 * Call OleRevokeObject because the user has destroyed the object.
 *
 * LPOBJ lpobj - The object which has been destroyed
 *
 * 
 * CUSTOMIZATION: You will only need to call OleRevokeObject once if there
 *                is only one LPOLECLIENT in your OBJ structure, which there
 *                should be.
 *
 */
VOID RevokeObj (LPOBJ lpobj)
{
   INT i;

   for (i=0; i< clpoleclient; i++)
   {
      if (lpobj->lpoleclient[i])
         OleRevokeObject (lpobj->lpoleclient[i]);
      else 
         /* if lpobj->lpoleclient[i]==NULL then there are no more non-NULLs
            in the array. */
         break;
   }
}



/* SendObjMsg
 * ----------
 *
 * This function sends a message to a specific object.
 *
 * LPOBJ lpobj   - The object
 * WORD wMessage - The message to send
 * 
 * CUSTOMIZATION: You will only need to call CallBack once if there
 *                is only one LPOLECLIENT in your OBJ structure, which there
 *                should be.
 *
 */
VOID SendObjMsg (LPOBJ lpobj, WORD wMessage)
{
   INT i;
   for (i=0; i < clpoleclient; i++)
   {
      if (lpobj->lpoleclient[i])
      {
         // Call the object's Callback function.
         lpobj->lpoleclient[i]->lpvtbl->CallBack 
            (lpobj->lpoleclient[i], wMessage, (LPOLEOBJECT) lpobj);
      }
      else
         break;
   }
}



/* SizeObj
 * -------
 *
 * Change the size of an object.
 *
 * HWND hwnd  - The object's window
 * RECT rect  - The requested new size in device units
 * BOOL fMove - Should the object be moved? (or just resized?)
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
VOID SizeObj (HWND hwnd, RECT rect, BOOL fMove)
{
   LPOBJ lpobj;

   lpobj = HwndToLpobj (hwnd);
   if (fMove)
   {
      lpobj->native.nX   = rect.left;
      lpobj->native.nY   = rect.top;
   }
   lpobj->native.nWidth  = rect.right  - rect.left;
   lpobj->native.nHeight = rect.bottom - rect.top ;
   SetHiMetricFields (lpobj);
   InvalidateRect (hwnd, (LPRECT)NULL, TRUE);
   fDocChanged = TRUE;
   if (docMain.doctype == doctypeFromFile)
   {
      // If object is linked, update it in client now. 
      SendObjMsg (lpobj, OLE_CHANGED);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\srvrdemo\srvrdemo.c ===
/*
  OLE SERVER DEMO
  SrvrDemo.c

  This file contains the window handlers, and various initialization and
  utility functions.

  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
*/


#define SERVERONLY
#include <windows.h>
#include <ole.h>

#include "srvrdemo.h"

/* Global variable definitions */

HWND   hwndMain = 0;

// Used in converting units from pixels to Himetric and vice-versa
int    giXppli = 0;       // pixels per logical inch along width
int    giYppli = 0;       // pixels per logical inch along height



// Since this is a not an MDI app, there can be only one server and one doc.
SRVR   srvrMain;
DOC    docMain;
CHAR   szClient[cchFilenameMax];
CHAR   szClientDoc[cchFilenameMax];

// Has the user made changes to the document?
BOOL   fDocChanged = FALSE;

// Is this the first instance of this application currently running?
BOOL   fFirstInstance = TRUE;

// This flag is used when OleRevokeServerDoc returns OLE_WAIT_FOR_RELEASE,
// and we must wait until DocRelease is called.
BOOL   fWaitingForDocRelease = FALSE;

// This flag is used when OleRevokeServer returns OLE_WAIT_FOR_RELEASE,
// and we must wait until SrvrRelease is called.
BOOL   fWaitingForSrvrRelease = FALSE;

// This flag is set to TRUE after an application has called OleBlockServer
// and now wishes to unblock the queued messages.  See WinMain.
// Server Demo never sets fUnblock to TRUE because it never calls
// OleBlockServer.
BOOL fUnblock = FALSE;

// Set this to FALSE if you want to guarantee that the server will not revoke
// itself when SrvrRelease is called.  This is used in the IDM_NEW case and
// the IDM_OPEN case (in OpenDoc).
BOOL fRevokeSrvrOnSrvrRelease = TRUE;

// Version number, which is stored in the native data.
VERSION version = 1;

HBRUSH hbrColor[chbrMax];

// Clipboard formats
OLECLIPFORMAT cfObjectLink;
OLECLIPFORMAT cfOwnerLink;
OLECLIPFORMAT cfNative;

// Method tables.
OLESERVERDOCVTBL docvtbl;
OLEOBJECTVTBL    objvtbl;
OLESERVERVTBL    srvrvtbl;

HANDLE hInst;
HANDLE hAccelTable;
HMENU  hMainMenu = NULL;

// Window dimensions saved in private profile.
static struct
{
   INT nX;
   INT nY;
   INT nWidth;
   INT nHeight;
} dimsSaved, dimsCurrent;


static enum
{
   // Corresponds to the order of the menus in the .rc file.
   menuposFile,
   menuposEdit,
   menuposColor,
   menuposObject
};


// Static functions.
static VOID  DeleteInstance (VOID);
static BOOL  ExitApplication (BOOL);
static VOID  GetWord (LPSTR *plpszSrc, LPSTR lpszDst);
static BOOL  InitApplication( HANDLE hInstance);
static BOOL  InitInstance (HANDLE hInstance);
static BOOL  ProcessCmdLine (LPSTR,HWND);
static VOID  SaveDimensions (VOID);
static VOID  SkipBlanks (LPSTR *plpsz);
static VOID  UpdateObjMenus (VOID);
static BOOL  FailedUpdate(HWND);

/* WinMain
 * -------
 *
 * Standard windows entry point
 *
 * CUSTOMIZATION: None
 *
 */
int APIENTRY WinMain(
   HINSTANCE hInstance,
   HINSTANCE hPrevInstance,
   LPSTR  lpCmdLine,
   INT    nCmdShow
){
    MSG    msg;

    if (!InitApplication(hInstance))
      return FALSE;

    msg.wParam = FALSE;

    if (!InitInstance(hInstance))
        goto errRtn;

    if (!InitServer (hwndMain, hInstance))
        goto errRtn;

    if (!ProcessCmdLine(lpCmdLine,hwndMain))
    {
        ExitApplication(FALSE);
        goto errRtn;
    }

    for (;;)
    {
         // Your application should set fUnblock to TRUE when it decides
         // to unblock.
         if (fUnblock)
         {
            BOOL fMoreMsgs = TRUE;
            while (fMoreMsgs)
            {
				if (srvrMain.lhsrvr == 0)
               OleUnblockServer (srvrMain.lhsrvr, &fMoreMsgs);
            }
            // We have taken care of all the messages in the OLE queue
            fUnblock = FALSE;
         }

         if (!GetMessage(&msg, NULL, 0, 0))
            break;
         if( !TranslateAccelerator(hwndMain, hAccelTable, &msg))
         {
               TranslateMessage(&msg);
               DispatchMessage(&msg);
         }
    }


errRtn:

    DeleteInstance ();
    return (msg.wParam);
}



/* InitApplication
 * ---------------
 *
 * Initialize the application - register the window classes
 *
 * HANDLE hInstance
 *
 * RETURNS: TRUE if classes are properly registered.
 *          FALSE otherwise
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static BOOL InitApplication( HANDLE hInstance )
{
    WNDCLASS  wc;

    wc.lpszClassName = "MainClass";
    wc.lpfnWndProc   = (WNDPROC)MainWndProc;
    wc.style         = 0;
    wc.cbClsExtra    = 4;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon(hInstance, "DocIcon");
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName  = "MainMenu";

    if (!RegisterClass(&wc))
        return FALSE;

    wc.lpszClassName = "ObjClass";
    wc.lpfnWndProc   = (WNDPROC)ObjWndProc;
    wc.hIcon         = NULL;
    wc.cbWndExtra    = cbWindExtra;
    wc.lpszMenuName  = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_CROSS);

    if (!RegisterClass(&wc))
        return FALSE;

    return TRUE;
}



/* InitInstance
 * ------------
 *
 * Create brushes used by the program, the main window, and
 * do any other per-instance initialization.
 *
 * HANDLE hInstance
 *
 * RETURNS: TRUE if successful
 *          FALSE otherwise.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static BOOL InitInstance (HANDLE hInstance)
{
    LONG rglColor [chbrMax] =
    {
      0x000000ff,  // Red
      0x0000ff00,  // Green
      0x00ff0000,  // Blue
      0x00ffffff,  // White
      0x00808080,  // Gray
      0x00ffff00,  // Cyan
      0x00ff00ff,  // Magenta
      0x0000ffff   // Yellow
    };


    INT iColor;
	 HDC hDC ;

    hInst = hInstance;

    // Initialize the method tables.
    InitVTbls ();

    // Initialize the brushes used.
    for (iColor = 0; iColor < chbrMax; iColor++)
      hbrColor[iColor] = CreateSolidBrush (rglColor[iColor]);

    // Register clipboard formats.
    cfObjectLink= (OLECLIPFORMAT)RegisterClipboardFormat ("ObjectLink");
    cfOwnerLink = (OLECLIPFORMAT)RegisterClipboardFormat ("OwnerLink");
    cfNative    = (OLECLIPFORMAT)RegisterClipboardFormat ("Native");

    hAccelTable = LoadAccelerators(hInst, "Accelerators");
//    hMainMenu   = LoadMenu(hInst, "MainMenu");


    hwndMain = CreateWindow(
        "MainClass",
        szAppName,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        3*OBJECT_WIDTH, 3*OBJECT_HEIGHT,
        NULL,
        NULL,
        hInstance,
        NULL
    );


    if (!hwndMain)
        return FALSE;

    szClient[0] = '\0';
    lstrcpy (szClientDoc, "Client Document");

    // Initialize global variables with LOGPIXELSX and LOGPIXELSY

    hDC    = GetDC (NULL);       // Get the hDC of the desktop window
    giXppli = GetDeviceCaps (hDC, LOGPIXELSX);
    giYppli = GetDeviceCaps (hDC, LOGPIXELSY);
    ReleaseDC (NULL, hDC);
	

    return TRUE;

}



/* DeleteInstance
 * --------------
 *
 * Deallocate the VTables, and the brushes created for this instance
 *
 *
 * CUSTOMIZATION: The call to FreeVTbls must remain.
 *
 */
static VOID DeleteInstance (VOID)
{
    INT i;

    for (i = 0; i < chbrMax; i++)
        DeleteObject (hbrColor[i]);

}



/* ExitApplication
 * ---------------
 *
 * Handles the WM_CLOSE and WM_COMMAND/IDM_EXIT messages.
 *
 * RETURNS: TRUE if application should really terminate
 *          FALSE if not
 *
 *
 * CUSTOMIZATION: None
 *
 */
static BOOL ExitApplication (BOOL fUpdateLater)
{

   if (fUpdateLater)
   {
      // The non-standard OLE client did not accept the update
      // when we requested it, so we are sending the client
      // OLE_CLOSED now that we are closing the document.
      SendDocMsg (OLE_CLOSED);
   }

   if (StartRevokingServer() == OLE_WAIT_FOR_RELEASE)
      Wait (&fWaitingForSrvrRelease);
   /* SrvrRelease will not necessarily post a WM_QUIT message.
      If the document is not embedded, SrvrRelease by itself does
      not cause the application to terminate.  But now we want it to.
   */
   if (docMain.doctype != doctypeEmbedded)
      PostQuitMessage(0);
   SaveDimensions();
   return TRUE;
}



/* MainWndProc
 * -----------
 *
 * Main window message handler.
 *
 *
 * CUSTOMIZATION: Remove the color menu and the object menu entirely.
 *                Add handlers for your application's menu items and any
 *                Windows messages your application needs to handle.
 *                The handlers for the menu items that involve OLE
 *                can be added to, but no logic should be removed.
 *
 *
 */
LONG  APIENTRY MainWndProc
   (HWND hwnd, UINT message, WPARAM wParam, LONG lParam )
{
    LPOBJ     lpobj;

    switch (message)
    {
        case WM_COMMAND:
        {
            WORD wID = LOWORD(wParam);

            if (fWaitingForDocRelease)
            {
               ErrorBox ("Waiting for a document to be revoked.\n\rPlease wait.");
               return 0;
            }

            switch (wID)
            {
               case IDM_EXIT:
                  SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                  break;

               case IDM_ABOUT:
                  DialogBox(hInst, "AboutBox", hwnd, (DLGPROC)About);
                  break;

               case IDM_NEW:
               {
                  BOOL fUpdateLater;
                  OLESTATUS olestatus;

                  if (SaveChangesOption (&fUpdateLater) == IDCANCEL)
                     break;
                  else if (fUpdateLater)
                     SendDocMsg (OLE_CLOSED);

                  // We want to revoke the doc but not the server, so if
                  // SrvrRelease is called, do not revoke server.
                  fRevokeSrvrOnSrvrRelease = FALSE;

                  if ((olestatus = RevokeDoc()) > OLE_WAIT_FOR_RELEASE)
                  {
                     ErrorBox ("Serious Error: Cannot revoke document.");
                     break;
                  }
                  else if (olestatus == OLE_WAIT_FOR_RELEASE)
                     Wait (&fWaitingForDocRelease);

                  fRevokeSrvrOnSrvrRelease = TRUE;

                  if (!CreateNewDoc (0, "(Untitled)", doctypeNew))
                  {
                     ErrorBox ("Serious Error: Cannot create new document.");
                     break;
                  }
                  // Your application need not create a default object.
                  CreateNewObj (FALSE);
                  EmbeddingModeOff();
                  break;
               }
               case IDM_OPEN:
                  OpenDoc();
                  UpdateObjMenus();
                  break;

               case IDM_SAVE:
                  SaveDoc();
                  break;

               case IDM_SAVEAS:
                  if (!SaveDocAs ())
                     break;
                  if (docMain.doctype != doctypeEmbedded)
                     EmbeddingModeOff();
                  break;

               case IDM_UPDATE:
                  switch (OleSavedServerDoc (docMain.lhdoc))
                  {
                     case OLE_ERROR_CANT_UPDATE_CLIENT:
                        if (!FailedUpdate(hwnd))
                           ExitApplication(TRUE);
                        break;
                     case OLE_OK:
                        break;
                     default:
                        ErrorBox ("Serious Error: Cannot update.");
                  }
                  break;

               /* Color menu */

               case IDM_RED:
               case IDM_GREEN:
               case IDM_BLUE:
               case IDM_WHITE:
               case IDM_GRAY:
               case IDM_CYAN:
               case IDM_MAGENTA:
               case IDM_YELLOW:
                  lpobj = SelectedObject();
                  lpobj->native.idmColor = wID;
                  // Recolor the object on the screen.
                  InvalidateRect (lpobj->hwnd, (LPRECT)NULL,  TRUE);
                  UpdateWindow (lpobj->hwnd);
                  fDocChanged = TRUE;
                  if (docMain.doctype == doctypeFromFile)
                     // If object is linked, update it in client now.
                     SendObjMsg (lpobj, OLE_CHANGED);
                  break;

               /* Edit menu */

               case IDM_COPY:
                  CutOrCopyObj (TRUE);
                  break;

               case IDM_CUT:
                  CutOrCopyObj (FALSE);
                  // Fall through.

               case IDM_DELETE:
                  RevokeObj (SelectedObject());
                  DestroyWindow (SelectedObjectWindow());
                  UpdateObjMenus();
                  break;

               /* Object menu */

               case IDM_NEXTOBJ:
                  lpobj = SelectedObject();
                  /* The 1 in the second parameter puts the current window
                     at the bottom of the current window list. */
                  SetWindowPos(lpobj->hwnd, (HANDLE)1, 0,0,0,0,
                              SWP_NOMOVE | SWP_NOSIZE);
                  break;

               case IDM_NEWOBJ:
                  lpobj = CreateNewObj (TRUE);
                  BringWindowToTop(lpobj->hwnd);
                  break;

               default:
                  ErrorBox ("Unknown Command.");
                  break;
            }
            break;
         }

        case WM_NCCALCSIZE:
            if (!IsIconic(hwnd) && !IsZoomed(hwnd))
            {
                dimsCurrent.nX = ((LPRECT)lParam)->left;
                dimsCurrent.nWidth = ((LPRECT)lParam)->right - dimsCurrent.nX;
                dimsCurrent.nY = ((LPRECT)lParam)->top;
                dimsCurrent.nHeight = ((LPRECT)lParam)->bottom - dimsCurrent.nY;
            }
            return DefWindowProc(hwnd, message, wParam, lParam);
            break;

        case WM_QUERYENDSESSION:
        {
            BOOL fUpdateLater;

            if (SaveChangesOption(&fUpdateLater) == IDCANCEL)
               return FALSE;

            if (fUpdateLater)
            {
               // The non-standard OLE client did not accept the update
               // when we requested it, so we are sending the client
               // OLE_CLOSED now that we are closing the document.
               SendDocMsg (OLE_CLOSED);
            }
            return TRUE;
        }

        case WM_CLOSE:
         {
            BOOL fUpdateLater;

            if (SaveChangesOption(&fUpdateLater) != IDCANCEL)
               ExitApplication(fUpdateLater);
            break;
         }

        default:
            return DefWindowProc(hwnd, message, wParam, lParam);
    }
    return 0;
}



/* About
 * -----
 *
 * "About Box" dialog handler.
 *
 * CUSTOMIZATION: None
 *
 */
BOOL  APIENTRY About (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
        {
            WORD wID = LOWORD(wParam);

            if (wID == IDOK || wID == IDCANCEL)
            {
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
        }
    }
    return FALSE;
}




/* ObjWndProc
 * ----------
 *
 * Message handler for the object windows.
 *
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
LONG  APIENTRY ObjWndProc
   (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static BOOL    fCapture = FALSE;
    static struct  {RECT rect; POINT pt;} drag;
    static RECT    rectMain;

    switch (message)
    {
        case WM_CREATE:
        {
            LPOBJ          lpobj;
            LPCREATESTRUCT lpcs;
            // The call to CreateWindow puts lpobj into lpCreateParams
            lpcs = (LPCREATESTRUCT) lParam;
            lpobj = (LPOBJ) lpcs->lpCreateParams;
            // Associate the window just created with the object.
            lpobj->hwnd = hwnd;
            /* Store pointer to object in the window structure. */
            SetWindowLong(hwnd, ibLpobj, (LONG) lpobj);
            UpdateObjMenus ();
            break;
        }
        case WM_SIZE:
        {
            RECT rect;
            if (fWaitingForDocRelease)
            {
               ErrorBox ("Waiting for a document to be revoked.\n\rPlease wait.");
               return 0;
            }
            // Get coordinates of object relative to main window's client area.
            GetWindowRect (hwnd, (LPRECT)&rect);
            ScreenToClient (hwndMain, (LPPOINT)&rect);
            ScreenToClient (hwndMain, (LPPOINT)&rect.right);
            SizeObj (hwnd, rect, TRUE);
            // Fall through.
        }
        case WM_PAINT:
            PaintObj (hwnd);
            break;

        case WM_LBUTTONDOWN:
            if (fWaitingForDocRelease)
            {
               ErrorBox ("Waiting for a document to be revoked.\n\rPlease wait.");
               return 0;
            }
            BringWindowToTop (hwnd);

            GetWindowRect (hwnd, (LPRECT) &drag.rect);
            ScreenToClient (hwndMain, (LPPOINT)&drag.rect.left);
            ScreenToClient (hwndMain, (LPPOINT)&drag.rect.right);

            drag.pt.x = LOWORD(lParam);
            drag.pt.y = HIWORD(lParam);

            // Convert drag.pt to the main window's client coordinates.
            ClientToScreen (hwnd, (LPPOINT)&drag.pt);
            ScreenToClient (hwndMain, (LPPOINT)&drag.pt);

            // Remember the coordinates of the main window so we do not drag
            // an object outside the main window.
            GetClientRect (hwndMain, (LPRECT) &rectMain);

            SetCapture (hwnd);
            fCapture = TRUE;
            break;

        case WM_MOUSEMOVE:
        {
            HDC   hdc;
            POINT pt;

            if (!fCapture)
                break;

            fDocChanged = TRUE;
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);

            // Convert pt to the main window's client coordinates.
            ClientToScreen (hwnd, (LPPOINT)&pt);
            ScreenToClient (hwndMain, (LPPOINT)&pt);

            if (!PtInRect (&rectMain, pt))
               break;

            hdc = GetDC(hwndMain);

            // Erase old drag rectangle
            InvertRect (hdc, (LPRECT)&drag.rect);

            // Update drag.rect
            OffsetRect (&drag.rect, pt.x - drag.pt.x, pt.y - drag.pt.y);

            // Update drag.pt
            drag.pt.x = pt.x;
            drag.pt.y = pt.y;

            // Show new drag rectangle
            InvertRect (hdc, (LPRECT)&drag.rect);
            ReleaseDC (hwndMain, hdc);
            break;
        }

        case WM_LBUTTONUP:
        {
            LPOBJ          lpobj;
            if (!fCapture)
                return TRUE;

            fCapture = FALSE;
            ReleaseCapture ();

            MoveWindow (hwnd, drag.rect.left, drag.rect.top,
                        drag.rect.right - drag.rect.left,
                        drag.rect.bottom - drag.rect.top, TRUE);
            InvalidateRect (hwnd, (LPRECT)NULL, TRUE);
            lpobj = HwndToLpobj (hwnd);
            lpobj->native.nX = drag.rect.left;
            lpobj->native.nY = drag.rect.top;
            break;
        }
        case WM_DESTROY:
            DestroyObj (hwnd);
            return DefWindowProc(hwnd, message, wParam, lParam);

        default:
            return DefWindowProc(hwnd, message, wParam, lParam);
    }
    return 0;
}



/* DeviceToHiMetric
 * ----------------
 *
 * Converts a point from device units to HiMetric units.
 * This function is designed to be generic enough to be reused.
 *
 * HWND hwnd    - The window whose display context is to be used
 * LPPOINT lppt - The point to be converted.
 *
 * CUSTOMIZATION: None
 *
 */
void DeviceToHiMetric ( LPPOINT lppt)
{
    lppt->x = MulDiv (lppt->x, HIMETRIC_PER_INCH, giXppli);
    lppt->y = MulDiv (lppt->y, HIMETRIC_PER_INCH, giYppli);
}


/* UpdateFileMenu
 * --------------
 *
 * Updates the "Update <Client doc>" and "Exit & Return to <Client doc>"
 * with the currently set client document name
 *
 * CUSTOMIZATION: Re-implement
 *
 */
VOID UpdateFileMenu (INT iSaveUpdateId)
{
    CHAR    str[cchFilenameMax];
    HMENU   hMenu = GetMenu(hwndMain);

    /* Change File menu so it contains "Update" instead of "Save". */

    lstrcpy (str, "&Update ");
    lstrcat (str, szClientDoc);
    ModifyMenu(hMenu, iSaveUpdateId, MF_BYCOMMAND|MF_STRING, IDM_UPDATE, str);

    /* Change File menu so it contains "Exit & Return to <client doc>" */
    /* instead of just "Exit" */

    lstrcpy (str, "E&xit && Return to ");
    lstrcat (str, szClientDoc);
    ModifyMenu(hMenu, IDM_EXIT, MF_BYCOMMAND|MF_STRING, IDM_EXIT, str);
}



/* EmbeddingModeOn
 * ---------------
 *
 * Do whatever is necessary for the application to start "embedding mode."
 *
 * CUSTOMIZATION: Re-implement
 *
 */
VOID EmbeddingModeOn(VOID)
{
    HMENU hMenu = GetMenu(hwndMain);

    UpdateFileMenu (IDM_SAVE);

    /* Change File menu so it contains "Save Copy As..." instead of */
    /* "Save As..." */
    ModifyMenu(hMenu, IDM_SAVEAS, MF_BYCOMMAND|MF_STRING, IDM_SAVEAS,
        "Save Copy As..");

    /* In embedded mode, the user can edit only the embedded object, not
       create new ones. */
    EnableMenuItem(hMenu, menuposObject, MF_BYPOSITION | MF_GRAYED);
    EnableMenuItem(hMenu, IDM_CUT,     MF_BYCOMMAND | MF_GRAYED);
    EnableMenuItem(hMenu, IDM_DELETE,  MF_BYCOMMAND | MF_GRAYED);
    DrawMenuBar (hwndMain);
}




/* EmbeddingModeOff
 * ----------------
 *
 * Do whatever is necessary for the application to end "embedding mode."
 *
 * CUSTOMIZATION: Re-implement
 *
 */
VOID EmbeddingModeOff (VOID)
{
    HMENU hMenu = GetMenu(hwndMain);

    /* Change File menu so it contains "Save" instead of "Update". */
    ModifyMenu(hMenu, IDM_UPDATE, MF_BYCOMMAND | MF_STRING, IDM_SAVE, "&Save");
    /* Change File menu so it contains "Exit & Return to <client doc>" */
    /* instead of just "Exit" */
    ModifyMenu(hMenu, IDM_EXIT, MF_BYCOMMAND | MF_STRING, IDM_EXIT, "E&xit");

    /* Change File menu so it contains "Save As..." instead of */
    /* "Save Copy As..." */
    ModifyMenu(hMenu, IDM_SAVEAS, MF_BYCOMMAND|MF_STRING, IDM_SAVEAS,
        "Save &As..");

    /* In non-embedded mode, the user can create new objects. */
    EnableMenuItem(hMenu, menuposObject, MF_BYPOSITION | MF_ENABLED);

    lstrcpy (szClientDoc, "Client Document");
    DrawMenuBar (hwndMain);
}



/* ErrorBox
 * --------
 *
 * char *szMessage - String to display inside message box.
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
VOID ErrorBox (CHAR *szMessage)
{
   MessageBox (hwndMain, szMessage, szAppName, MB_OK);
}



/* GetWord
 * -------
 *
 * LPSTR *plpszSrc - Pointer to a pointer to a source string
 * LPSTR lpszDst   - Pointer to destination buffer
 *
 * Will copy one space-terminated or null-terminated word from the source
 * string to the destination buffer.
 * When done, *plpszSrc will point to the character after the word.
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
static VOID GetWord (LPSTR *plpszSrc, LPSTR lpszDst)
{
   INT i = 0;
   while (**plpszSrc && **plpszSrc != ' ')
   {
         lpszDst[i++] = *(*plpszSrc)++;
   }
   lpszDst[i] = '\0';
}



/* HiMetricToDevice
 * ----------------
 *
 * Converts a point from HiMetric units to device units.
 * This function is designed to be generic enough to be reused.
 *
 * HWND hwnd    - The window whose display context is to be used
 * LPPOINT lppt - The point to be converted.
 *
 * CUSTOMIZATION: None
 *
 */
void HiMetricToDevice ( LPPOINT lppt )
{
    lppt->x = MulDiv (giXppli, lppt->x, HIMETRIC_PER_INCH);
    lppt->y = MulDiv (giYppli, lppt->y, HIMETRIC_PER_INCH);
}



/* HwndToLpobj
 * -----------
 *
 * Given an object's window, return a pointer to the object.
 * The GetWindowLong call extracts an LPOBJ from the extra data stored with
 * the window.
 *
 * HWND hwndObj - Handle to the object's window
 *
 * RETURNS: A pointer to the object
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
LPOBJ HwndToLpobj (HWND hwndObj)
{
   return (LPOBJ) GetWindowLong (hwndObj, ibLpobj);
}



/* CreateUntitledDoc
 * -----------------
 *
 * Create a fresh document with one object.
 *
 * RETURNS: TRUE if successful
 *          FALSE otherwise
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static BOOL CreateUntitledDoc (INT nCmdShow)
{
      if (!CreateNewDoc (0, "(Untitled)", doctypeNew))
         return FALSE;
      CreateNewObj (FALSE);
      ShowWindow(hwndMain, nCmdShow);
      UpdateWindow(hwndMain);
      return TRUE;
}


/* ProcessCmdLine
 * --------------
 *
 * Parses the Windows command line which was passed to WinMain.
 *
 * Case One: SrvrDemo.exe
 *   fEmbedding = FALSE
 *   Create an untitled document.
 *
 * Case two: SrvrDemo.exe filename
 *   fEmbedding = FALSE
 *   Create a new document from the file.
 *
 * Case three: SrvrDemo.exe -Embedding
 *   fEmbedding = TRUE
 *   Do not create or register a document.
 *   Do not show window until client requests it.
 *
 * Case four: SrvrDemo.exe -Embedding filename
 *   fEmbedding = TRUE
 *   Load file.
 *   Call OleRegisterServerDoc.
 *   Do not show window until client requests it.
 *
 *
 * LPSTR lpszLine - The Windows command line
 * int nCmdShow   - Parameter to WinMain
 * HWND hwndMain  - The application's main window
 *
 * RETURNS: TRUE  if the command line was processed correctly.
 *          FALSE if a filename was specified which did not
 *                contain a proper document.
 *
 * CUSTOMIZATION: None.
 *
 */

static BOOL ProcessCmdLine (LPSTR lpszLine, HWND hwndMain)
{
   CHAR     szBuf[cchFilenameMax];
   BOOL     fEmbedding = FALSE;  // Is "-Embedding" on the command line?
   INT      i=0;
   OFSTRUCT of;

   if (!*lpszLine)    // No filename or options, so start a fresh document.
   {
      return CreateUntitledDoc(SW_SHOWNORMAL);
   }

   SkipBlanks (&lpszLine);

   // Check for "-Embedding" or "/Embedding" and set fEmbedding.
   if(*lpszLine == '-' || *lpszLine == '/')
   {
      lpszLine++;
      GetWord (&lpszLine, szBuf);
      fEmbedding = !lstrcmp(szBuf, szEmbeddingFlag);
   }

   SkipBlanks (&lpszLine);

   if (*lpszLine) // if there is a filename
   {
      // Put filename into szBuf.
      GetWord (&lpszLine, szBuf);

      if (-1 == OpenFile(szBuf, &of, OF_READ | OF_EXIST))
      {
         // File not found
         if (fEmbedding)
            return FALSE;
         else
         {
            CHAR sz[100];
            wsprintf (sz, "File %s not found.", (LPSTR) szBuf);
            ErrorBox (sz);
            return CreateUntitledDoc(SW_SHOWNORMAL);
         }
      }

      if (!CreateDocFromFile (szBuf, 0, doctypeFromFile))
      {
         // File not in proper format.
         if (fEmbedding)
            return FALSE;
         else
         {
            CHAR sz[100];
            wsprintf (sz, "File %s not in proper format.", (LPSTR) szBuf);
            ErrorBox (sz);
            return CreateUntitledDoc(SW_SHOWNORMAL);
         }
      }
   }

   if (fEmbedding)
   {
      /* Do not show window until told to do so by client. */
      ShowWindow(hwndMain, SW_HIDE);
   }
   else
   {
      ShowWindow(hwndMain, SW_SHOWNORMAL);
      UpdateWindow(hwndMain);
   }
   return TRUE;
}



/* SaveDimensions
 * --------------
 *
 * Save the dimensions of the main window in a private profile file.
 *
 * CUSTOMIZATION: This function may be removed.  If you wish to support
 *                intelligent window placement, then the only necessary
 *                change is to change the string "SrvrDemo.Ini" to a filename
 *                appropriate for your application.
 */
static VOID SaveDimensions (VOID)
{
   if ((dimsCurrent.nX != dimsSaved.nX) ||
         (dimsCurrent.nY != dimsSaved.nY) ||
         (dimsCurrent.nWidth != dimsSaved.nWidth) ||
         (dimsCurrent.nHeight != dimsSaved.nHeight) )
   {
         // Save current window dimensions to private profile.
         CHAR szBuf[7];
         wsprintf (szBuf, "%d", dimsCurrent.nX);
         WritePrivateProfileString
         (szAppName, "x", szBuf, "SrvrDemo.Ini");
         wsprintf (szBuf, "%d", dimsCurrent.nY);
         WritePrivateProfileString
         (szAppName, "y", szBuf, "SrvrDemo.Ini");
         wsprintf (szBuf, "%d", dimsCurrent.nWidth);
         WritePrivateProfileString
         (szAppName, "w", szBuf, "SrvrDemo.Ini");
         wsprintf (szBuf, "%d", dimsCurrent.nHeight);
         WritePrivateProfileString
         (szAppName, "h", szBuf, "SrvrDemo.Ini");
   }
}



/* SelectedObject
 * --------------
 *
 * Return a pointer to the currently selected object.
 *
 * CUSTOMIZATION: What a "selected object" is will vary from application
 *                to application.  You may find it useful to have a function
 *                like this.  In your application it may be necessary to
 *                actually create an OBJ structure based on what data the
 *                user has selected from the document (by highlighting some
 *                text for example).
 *
 */
LPOBJ SelectedObject (VOID)
{
   return HwndToLpobj (SelectedObjectWindow());
}




/* SelectedObjectWindow
 * --------------------
 *
 * Return a handle to the window for the currently selected object.
 * The GetWindow calls returns a handle to the main window's first child,
 * which is the selected object's window.
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
HWND SelectedObjectWindow (VOID)
{
   return GetWindow (hwndMain, GW_CHILD);
}



/* SetHiMetricFields
 * -----------------
 *
 * Adjust the nHiMetricWidth and nHiMetricHeight fields of a NATIVE structure
 * so that they are equivalent to the nWidth and nHeight fields.
 * The negative sign in the last line is necessary because the positive
 * y direction is toward the top of the screen in MM_HIMETRIC mode.
 *
 * LPOBJ lpobj - Pointer to the object whose native data will be adjusted
 *
 * CUSTOMIZATION: Server Demo specific, although you may need a function like
 *                this if you keep track of the size of an object, and an
 *                object handler needs to know the object's size in
 *                HiMetric units.
 *
 *
 */
VOID SetHiMetricFields (LPOBJ lpobj)
{
   POINT pt;

   pt.x = lpobj->native.nWidth;
   pt.y = lpobj->native.nHeight;
   DeviceToHiMetric ( &pt);
   lpobj->native.nHiMetricWidth  = pt.x;
   lpobj->native.nHiMetricHeight = pt.y;
}



/* SkipBlanks
 * ----------
 *
 * LPSTR *plpsz - Pointer to a pointer to a character
 *
 * Increment *plpsz past any blanks in the character string.
 * This function is used in ProcessCmdLine.
 *
 */
static VOID SkipBlanks (LPSTR *plpsz)
{
   while (**plpsz && **plpsz == ' ')
      (*plpsz)++;
}



/* UpdateObjMenus
 * ---------------
 *
 * Grey or Ungrey menu items depending on the existence of at least one
 * object in the document.
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
static VOID UpdateObjMenus (VOID)
{
    static BOOL fObjMenusEnabled = TRUE;
    BOOL        fOneObjExists; // Does at least one object exist?
    WORD        wEnable;
    HMENU       hMenu;

    fOneObjExists = (SelectedObjectWindow() != NULL);
    if (fOneObjExists == fObjMenusEnabled)
    {
         // Nothing has changed.
         return;
    }

    wEnable = (WORD)(fOneObjExists ? MF_ENABLED : MF_GRAYED);

    hMenu = GetMenu(hwndMain);
    EnableMenuItem(hMenu, menuposColor, MF_BYPOSITION | wEnable);

    hMenu = GetSubMenu(GetMenu(hwndMain), menuposFile);
    EnableMenuItem(hMenu, IDM_SAVE,   MF_BYCOMMAND | wEnable);
    EnableMenuItem(hMenu, IDM_SAVEAS, MF_BYCOMMAND | wEnable);

    hMenu = GetSubMenu(GetMenu(hwndMain), menuposEdit);
    EnableMenuItem(hMenu, IDM_CUT,     MF_BYCOMMAND | wEnable);
    EnableMenuItem(hMenu, IDM_COPY,    MF_BYCOMMAND | wEnable);
    EnableMenuItem(hMenu, IDM_DELETE,  MF_BYCOMMAND | wEnable);

    hMenu = GetSubMenu(GetMenu(hwndMain), menuposObject);
    EnableMenuItem(hMenu, IDM_NEXTOBJ, MF_BYCOMMAND | wEnable);

    DrawMenuBar (hwndMain);
    fObjMenusEnabled = fOneObjExists;
}



/* Wait
 * ----
 *
 * Dispatch messages until the given flag is set to FALSE.
 * One use of this function is to wait until a Release method is called
 * after a function has returned OLE_WAIT_FOR_RELEASE.
 *
 * BOOL *pf - Pointer to the flag being waited on.
 *
 * CUSTOMIZATION: The use of OleUnblockServer is for illustration only.
 *                Since Server Demo does not call OleBlockServer, there
 *                will never be any messages in the OLE queue.
 *
 */
VOID Wait (BOOL *pf)
{
   MSG msg;
   BOOL fMoreMsgs = FALSE;

   *pf = TRUE;
   while (*pf==TRUE)
   {
      OleUnblockServer (srvrMain.lhsrvr, &fMoreMsgs);
      if (!fMoreMsgs)
      // if there are no more messages in the OLE queue, go to system queue
      {
         if (GetMessage (&msg, NULL, 0, 0))
         {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
         }
      }
   }
}

static BOOL FailedUpdate(HWND hwnd)
{

  return(DialogBox(hInst, "FailedUpdate", hwnd, (DLGPROC)fnFailedUpdate));

}

BOOL  APIENTRY fnFailedUpdate (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

   switch (message)
   {
      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         switch (wID)
         {
               case IDCANCEL:
               case IDD_CONTINUEEDIT:
                   EndDialog(hDlg, TRUE);
                   break;

               case IDD_UPDATEEXIT:
                   EndDialog(hDlg, FALSE);
                   break;

               default:
                   break;
         }
         break;
       }

       case WM_INITDIALOG:
       {
          CHAR szMsg[200];

          szMsg[0] = '\0';

          wsprintf(
               szMsg,
               "This %s document can only be updated when you exit %s.",
               (LPSTR) szClient,
               (LPSTR) szAppName
          );

          SetDlgItemText(hDlg, IDD_TEXT, szMsg);
          return TRUE;
       }

      default:
           break;
   }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\server\block.c ===
/****************************** Module Header ******************************\
* Module Name: Block.c
*
* Purpose: Includes OleServerBlock(), OleServerUnblock() and related routines.
*
* Created: Dec. 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Srinik (../12/1990)    Designed, coded
*    curts created portable version for WIN16/32
*
\***************************************************************************/


#include "windows.h"
#include "cmacs.h"
#include "dde.h"
#include "ole.h"
#include "srvr.h"


OLESTATUS APIENTRY OleBlockServer (
    LHSERVER  lhsrvr
){
    LPSRVR  lpsrvr;

    if (!CheckServer (lpsrvr = (LPSRVR) lhsrvr))
        return OLE_ERROR_HANDLE;

    PROBE_BLOCK(lpsrvr);
    lpsrvr->bBlock = TRUE;
    return OLE_OK;
}


// On return from this routine, if *lpStatus is TRUE it means that more
// messages are to be unblocked.

OLESTATUS APIENTRY OleUnblockServer (
    LHSERVER    lhsrvr,
    BOOL FAR *  lpStatus
){
    HANDLE  hq;
    PQUE    pq;
    LPSRVR  lpsrvr;

    if (!CheckServer (lpsrvr = (LPSRVR) lhsrvr))
        return OLE_ERROR_HANDLE;

    PROBE_WRITE(lpStatus);

    *lpStatus = lpsrvr->bBlock;
    if (hq = lpsrvr->hqHead) {
        if (!(pq = (PQUE) LocalLock (hq)))
            return OLE_ERROR_MEMORY;
        lpsrvr->bBlockedMsg = TRUE;
        lpsrvr->hqHead = pq->hqNext;
		
		  if (pq->wType)
				DocWndProc (pq->hwnd, pq->msg, pq->wParam, pq->lParam);
		  else
				SrvrWndProc (pq->hwnd, pq->msg, pq->wParam, pq->lParam);
			
        LocalUnlock (hq);
        LocalFree (hq);

        // Server could've got freed up as a result of the above SendMessage
        // Validate server handle before trying to access it.
        if (CheckServer (lpsrvr)) {
            lpsrvr->bBlockedMsg = FALSE;

            if (!lpsrvr->hqHead) {
                lpsrvr->hqTail = NULL;
                *lpStatus = lpsrvr->bBlock = FALSE;
            }
        }
        else {
            *lpStatus = FALSE;
        }
    }
    else {
        *lpStatus = lpsrvr->bBlock = FALSE;
    }

    return OLE_OK;
}


BOOL INTERNAL AddMessage (
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam,
    int     wType
){
    LPSRVR  lpsrvr;
    HANDLE  hq = NULL;
    PQUE    pq = NULL, pqTmp = NULL;
    BOOL    bBlocked = TRUE;

    if ((msg <= WM_DDE_INITIATE) || (msg > WM_DDE_LAST))
        return FALSE;


    if (!(lpsrvr = (LPSRVR) GetWindowLongPtr ((wType == WT_DOC) ? GetParent (hwnd) : hwnd, 0)))
        return FALSE;

    if (lpsrvr->bBlockedMsg || !lpsrvr->bBlock)
        return FALSE;

#ifdef LATER
    if ((msg == WM_DDE_INITIATE) && (lpsrvr->useFlags == OLE_SERVER_MULTI))
        return TRUE;
#endif

    // Create a queue node and fill up with data

    if (!(hq = LocalAlloc (LMEM_MOVEABLE, sizeof(QUE))))
        goto errRet;

    if (!(pq = (PQUE) LocalLock (hq)))
        goto errRet;

    pq->hwnd   = hwnd;
    pq->msg    = msg;
    pq->wParam = wParam;
    pq->lParam = lParam;
	 pq->wType  = wType;
    pq->hqNext = NULL;
    LocalUnlock (hq);

    // Now we got a node that we can add to the queue

    if (!lpsrvr->hqHead) {
        // Queue is empty.
#ifdef FIREWALLS
        ASSERT (!lpsrvr->hqTail, "Tail is unexpectedly non NULL")
#endif
        lpsrvr->hqHead = lpsrvr->hqTail = hq;
    }
    else {
        if (!(pqTmp = (PQUE) LocalLock (lpsrvr->hqTail)))
            goto errRet;
        pqTmp->hqNext = hq;
        LocalUnlock(lpsrvr->hqTail);
        lpsrvr->hqTail = hq;
    }

    return TRUE;

errRet:

    if (pq)
        LocalUnlock (hq);

    if (hq)
        LocalFree (hq);

    while (bBlocked && !OleUnblockServer ((LHSERVER) lpsrvr, &bBlocked))
            ;

    return FALSE;
}



// dispatches the queued message, till all the messages are posted
// does yielding  if necessary. if bPeek is true, may allow some of
// incoming messages to get in.


BOOL INTERNAL  UnblockPostMsgs (
    HWND    hwnd,
    BOOL    bPeek
){
    HANDLE  hq = NULL;
    PQUE    pq = NULL;
    LPSRVR  lpsrvr;
    HWND    hwndTmp;

    UNREFERENCED_PARAMETER(bPeek);

    // get the parent windows
    while (hwndTmp = GetParent (hwnd))
           hwnd = hwndTmp;

    lpsrvr = (LPSRVR) GetWindowLongPtr (hwnd, 0);

#ifdef  FIREWALLS
    ASSERT (lpsrvr, "No server window handle in server window");
    ASSERT (lpsrvr->hqPostHead, "Unexpectedly blocked queue is empty");
#endif


    while (hq = lpsrvr->hqPostHead) {

        if (!(pq = (PQUE) LocalLock (hq))) {

#ifdef  FIREWALLS
        ASSERT (FALSE, "Local lock failed for blocked messages");
#endif
            break;
        }
        if (IsWindowValid (pq->hwnd)) {
            if (!PostMessage (pq->hwnd, pq->msg, pq->wParam, pq->lParam)) {
                LocalUnlock (hq);
                break;
            }
        }

        lpsrvr->hqPostHead = pq->hqNext;
        LocalUnlock (hq);
        LocalFree (hq);
    }


    if (!lpsrvr->hqPostHead)
        lpsrvr->hqPostTail = NULL;

    return TRUE;
}


// Moves a message which can not be posted to a server to
// the internal queue. We use this when we have to enumerate
// the properties. When we change the properties stuff to
// some other form, this may not be necassry.

BOOL INTERNAL BlockPostMsg (
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
){
    LPSRVR  lpsrvr;
    HANDLE  hq = NULL;
    PQUE    pq = NULL, pqTmp = NULL;
    HWND    hwndTmp;
    HWND    hwndParent;

    hwndParent = (HWND)wParam;
    // get the parent windows
    while (hwndTmp = GetParent ((HWND)hwndParent))
           hwndParent = hwndTmp;

    lpsrvr = (LPSRVR) GetWindowLongPtr (hwndParent, 0);

#ifdef  FIREWALLS
    ASSERT (lpsrvr, "No server window handle in server window");
#endif

    // Create a queue node and fill up with data

    if (!(hq = LocalAlloc (LMEM_MOVEABLE, sizeof(QUE))))
        goto errRet;

    if (!(pq = (PQUE) LocalLock (hq)))
        goto errRet;

    pq->hwnd   = hwnd;
    pq->msg    = msg;
    pq->wParam = wParam;
    pq->lParam = lParam;
    pq->hqNext = NULL;
    LocalUnlock (hq);

    // Now we got a node that we can add to the queue

    if (!lpsrvr->hqPostHead) {
        // Queue is empty.
#ifdef FIREWALLS
        ASSERT (!lpsrvr->hqPostTail, "Tail is unexpectedly non NULL")
#endif
        lpsrvr->hqPostHead = lpsrvr->hqPostTail = hq;

        // create a timer.
        if (!SetTimer (lpsrvr->hwnd, 1, 100, NULL))
            return FALSE;

    }
    else {
        if (!(pqTmp = (PQUE) LocalLock (lpsrvr->hqPostTail)))
            goto errRet;
        pqTmp->hqNext = hq;
        LocalUnlock(lpsrvr->hqPostTail);
        lpsrvr->hqPostTail = hq;
    }

    return TRUE;

errRet:

    if (pq)
        LocalUnlock (hq);

    if (hq)
        LocalFree (hq);
    return FALSE;
}


BOOL INTERNAL IsBlockQueueEmpty (
    HWND    hwnd
){

    LPSRVR  lpsrvr;
    HWND    hwndTmp;

    // get the parent windows
    while (hwndTmp = GetParent ((HWND)hwnd))
            hwnd= hwndTmp;
    lpsrvr = (LPSRVR) GetWindowLongPtr (hwnd, 0);
    return (!lpsrvr->hqPostHead);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\srvrdemo\srvrdemo.h ===
/*
  OLE SERVER DEMO   
  SrvrDemo.h

  This file contains typedefs, defines, global variable declarations, and
  function prototypes.

  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved    
*/



/*
   Explanation of Function Comments.

   Every function has a comment preceding it which gives the following
   information:

   1) Function name.
   2) A description of what the function does.
   3) A list of parameters, each with its type and a short description.
   4) A list of return values, each with an explanation of the condition that
      will cause the function to return that value.
   5) A customization section giving tips on how to customize this function
      for your OLE application.
      If the customization section says "None" then you may find the function
      usable as is.    
      If the customization section says "Re-implement" then the function
      should still serve the same purpose and do what is indicated in the
      function comment, but will probably need to be re-implemented for
      your particular application.  Any Server Demo code relating to OLE
      will be useful as a guide in your re-implementation.
      If the customization section says "Server Demo specific" then the
      function will probably have no counterpart in your application.
*/


/* Menu Identifiers */

// File menu 

#define IDM_NEW      100
#define IDM_OPEN     101   
#define IDM_SAVE     102   
#define IDM_SAVEAS   103
#define IDM_EXIT     104
#define IDM_ABOUT    105
#define IDM_UPDATE   106

// Edit menu 

#define IDM_CUT      107  
#define IDM_COPY     108   
#define IDM_DELETE   109

// Color menu 

#define IDM_RED      110
#define IDM_GREEN    111
#define IDM_BLUE     112
#define IDM_WHITE    113
#define IDM_GRAY     114
#define IDM_CYAN     115
#define IDM_MAGENTA  116
#define IDM_YELLOW   117

// New object menu 

#define IDM_NEWOBJ   118
#define IDM_NEXTOBJ  119

#define IDD_CONTINUEEDIT    120
#define IDD_UPDATEEXIT      121
#define IDD_TEXT            122

#define OBJECT_WIDTH        120
#define OBJECT_HEIGHT       60

// number HIMETRIC units per inch
#define  HIMETRIC_PER_INCH  2540

/* Types */

// Document type

typedef enum
{
    doctypeNew,      // The document is untitled.
    doctypeFromFile, // The document exists in a file and may be linked.
    doctypeEmbedded  // The document is an embedded document.
} DOCTYPE;


// Device context type, passed to DrawObj.

typedef enum
{
   dctypeScreen,        
   dctypeBitmap,        
   dctypeMetafile,
   dctypeEnhMetafile
} DCTYPE ;


// Version 

typedef WORD VERSION;


// Verb

typedef enum
{
   verbPlay = OLEVERB_PRIMARY,
   verbEdit
} VERB;


// Server structure 

typedef struct
{
    OLESERVER     olesrvr;        // This must be the first field so that 
                                  //   an LPOLESERVER can be cast to a SRVR*.
    LHSERVER      lhsrvr;         // Registration handle
} SRVR ;


// How many objects (distinct numbers) will we allow?
#define cfObjNums 20

// How many distinct clients can be associated with the object?
#define clpoleclient 20


// Document structure 

typedef struct  
{
    OLESERVERDOC oledoc;      // This must be the first field so that an
                              //   LPOLESERVERDOC can be cast to an DOC*.
    LHSERVERDOC  lhdoc;       // Registration handle
    DOCTYPE      doctype;     // Document type
    ATOM         aName;       // Document name
    HPALETTE     hpal;        // Handle to a logical color palette
    BYTE         rgfObjNums[cfObjNums+1]; // What object numbers have been used
} DOC, *DOCPTR ;


// Native data structure 

typedef struct  
{
    INT         idmColor;        
    INT         nWidth; 
    INT         nHeight;
    INT         nX;
    INT         nY;
    INT         nHiMetricWidth;  // Used by an object handler.  These two fields
    INT         nHiMetricHeight; // always correspond to nWidth and nHeight.
    VERSION     version;
    CHAR        szName[10];      // "Object nn"
} NATIVE, FAR *LPNATIVE;


// Object structure 

/* Ordinarily, an OBJ structure would not contain native data.  Rather, it
   would contain a pointer (or some other reference) to the native data.
   This method would allow multiple objects containing the same native data.
   Each OBJ structure would be created on the fly when some portion of the
   document was to be made into an object.  Each OBJ structure would have
   only one LPOLECLIENT, which would be passed in to DocGetObject.
*/

typedef struct 
{ 
    OLEOBJECT   oleobject;   // This must be the first field so that an 
                             //   LPOLEOBJECT can be cast to a LPOBJ.
    HANDLE      hObj;        // A circular handle to this structure,
                             //   used to delete this structure.
    LPOLECLIENT lpoleclient[clpoleclient];
                             // Clients associated with the object.
                             //   The array is NULL terminated.
    HWND        hwnd;        // The object's own window
    ATOM        aName;       // Unique identifier for each object within a doc
    HPALETTE    hpal;        // Logical palette to use in drawing object
    NATIVE      native;      // Object data in native format
} OBJ, FAR *LPOBJ ;

typedef struct {
    CHAR     *pClassName;
    CHAR     *pFileSpec;
    CHAR     *pHumanReadable;
    CHAR     *pExeName;
}  CLASS_STRINGS;



/* Defines */

// The name of the application, used in message boxes and title bars.
#define szAppName        "Server Demo"

// THe class name in the registration database.
#define szClassName      "ServerDemo"

// Used to check for "-Embedding" on command line.
#define szEmbeddingFlag  "Embedding" 

// Maximum length of a fully-qualified pathname.
#define cchFilenameMax   256

// Maximum number of HBRUSHes.
#define chbrMax          9

// Number of extra bytes in the window structure for an object
#define cbWindExtra 4

// Offset (in the extra space) of the pointer to the object  
#define ibLpobj          0



/* Global variable declarations.  (See SrvrDemo.c for descriptions.) */

extern HANDLE           hInst;
extern HWND             hwndMain;
extern SRVR             srvrMain;
extern DOC              docMain;
extern BOOL             fDocChanged;
extern BOOL             fEmbedding; 
extern BOOL             fRevokeSrvrOnSrvrRelease;
extern BOOL             fWaitingForDocRelease;
extern BOOL             fWaitingForSrvrRelease;
extern BOOL             fUnblock;
extern CHAR             szClient[];
extern CHAR             szClientDoc[];
extern HBRUSH           hbrColor[chbrMax];
extern VERSION          version;
extern OLECLIPFORMAT    cfObjectLink;
extern OLECLIPFORMAT    cfOwnerLink;
extern OLECLIPFORMAT    cfNative;
extern OLESERVERDOCVTBL docvtbl;
extern OLEOBJECTVTBL    objvtbl;
extern OLESERVERVTBL    srvrvtbl;



/* Function Prototypes */

// Various functions

BOOL  CreateDocFromFile (LPSTR lpszDoc, LHSERVERDOC lhdoc, DOCTYPE doctype);
BOOL  CreateNewDoc (LONG lhdoc, LPSTR lpszDoc, DOCTYPE doctype);
LPOBJ CreateNewObj (BOOL fDoc_Changed);
VOID  CutOrCopyObj (BOOL fOpIsCopy);
VOID  DestroyDoc (VOID);
VOID  DestroyObj (HWND hwnd);
VOID  DeviceToHiMetric ( LPPOINT lppt);
VOID  EmbeddingModeOff (VOID) ;
VOID  EmbeddingModeOn (VOID);
VOID  UpdateFileMenu (INT);
VOID  ErrorBox (CHAR *jwf);
BOOL  GetFileOpenFilename (LPSTR lpszFilename);
BOOL  GetFileSaveFilename (LPSTR lpszFilename);
VOID  HiMetricToDevice ( LPPOINT lppt);
LPOBJ HwndToLpobj (HWND hwndObj);
BOOL  InitServer (HWND hwnd, HANDLE hInst);
VOID  InitVTbls (VOID);
BOOL  OpenDoc (VOID);
VOID  PaintObj (HWND hwnd);
OLESTATUS RevokeDoc (VOID);
VOID  RevokeObj (LPOBJ lpobj);
INT   SaveChangesOption (BOOL *pfUpdateLater);
BOOL  SaveDoc (VOID);
BOOL  SaveDocAs (VOID);
VOID  SavedServerDoc (VOID);
LPOBJ SelectedObject (VOID);
HWND  SelectedObjectWindow (VOID);
VOID  SendDocMsg (WORD wMessage );
VOID  SendObjMsg (LPOBJ lpobj, WORD wMessage);
VOID  SetTitle (LPSTR lpszDoc, BOOL bEmbedded);
VOID  SetHiMetricFields (LPOBJ lpobj);
VOID  SizeClientArea (HWND hwndMain, RECT rectReq, BOOL fFrame);
VOID  SizeObj (HWND hwnd, RECT rect, BOOL fMove);
OLESTATUS StartRevokingServer (VOID);
VOID  Wait (BOOL *pf);
LPSTR Abbrev (LPSTR lpsz);
BOOL  APIENTRY fnFailedUpdate (HWND, UINT, WPARAM, LONG);
int   Main(USHORT argc, CHAR **argv) ;

// Window handlers

BOOL  APIENTRY About       (HWND, UINT, WPARAM, LPARAM);
LONG  APIENTRY MainWndProc (HWND, UINT, WPARAM, LPARAM);
LONG  APIENTRY ObjWndProc  (HWND, UINT, WPARAM, LPARAM);

                   
// Server methods

OLESTATUS  APIENTRY SrvrCreate (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR *);
OLESTATUS  APIENTRY SrvrCreateFromTemplate (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR *);
OLESTATUS  APIENTRY SrvrEdit (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR * );
OLESTATUS  APIENTRY SrvrExecute (LPOLESERVER, HANDLE);
OLESTATUS  APIENTRY SrvrExit (LPOLESERVER);
OLESTATUS  APIENTRY SrvrOpen (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR *);
OLESTATUS  APIENTRY SrvrRelease (LPOLESERVER);

// Document methods

OLESTATUS  APIENTRY DocClose (LPOLESERVERDOC);
OLESTATUS  APIENTRY DocExecute (LPOLESERVERDOC, HANDLE);
OLESTATUS  APIENTRY DocGetObject (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR *, LPOLECLIENT);
OLESTATUS  APIENTRY DocRelease (LPOLESERVERDOC);
OLESTATUS  APIENTRY DocSave (LPOLESERVERDOC);
OLESTATUS  APIENTRY DocSetColorScheme (LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
OLESTATUS  APIENTRY DocSetDocDimensions (LPOLESERVERDOC, OLE_CONST RECT FAR *);
OLESTATUS  APIENTRY DocSetHostNames (LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);

// Object methods

OLESTATUS  APIENTRY ObjDoVerb (LPOLEOBJECT, UINT, BOOL, BOOL);
OLESTATUS  APIENTRY ObjGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
LPVOID     APIENTRY ObjQueryProtocol (LPOLEOBJECT, OLE_LPCSTR);
OLESTATUS  APIENTRY ObjRelease (LPOLEOBJECT);
OLESTATUS  APIENTRY ObjSetBounds (LPOLEOBJECT, OLE_CONST RECT FAR*);
OLESTATUS  APIENTRY ObjSetColorScheme (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
OLESTATUS  APIENTRY ObjSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS  APIENTRY ObjSetTargetDevice (LPOLEOBJECT, HANDLE);
OLESTATUS  APIENTRY ObjShow (LPOLEOBJECT, BOOL);
OLECLIPFORMAT  APIENTRY ObjEnumFormats (LPOLEOBJECT, OLECLIPFORMAT);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\samples\srvrdemo\server.c ===
/*
  OLE SERVER DEMO           
  Server.c             
                                                                     
  This file contains server methods and various server-related support 
  functions.
                                                                     
  (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved   
*/                                                                     
 


#define SERVERONLY
#include <windows.h>
#include <ole.h>

#include "srvrdemo.h"

CLASS_STRINGS  ClassStrings = {
    "ServerDemo", "*.sd", "Server Demo", "srvrdemo.exe"
};

/* 
   Important Note:

   No method should ever dispatch a DDE message or allow a DDE message to
   be dispatched.
   Therefore, no method should ever enter a message dispatch loop.
   Also, a method should not show a dialog or message box, because the 
   processing of the dialog box messages will allow DDE messages to be
   dispatched.
*/
BOOL RegServer(){

    LONG        fRet;
    HKEY        hKey;
    CHAR        szKeyName[300]; //Get better value
    BOOL        retVal = FALSE;
    
    lstrcpy(szKeyName, ClassStrings.pClassName);
    lstrcat(szKeyName, "\\protocol\\StdFileEditing\\verb");

    //Check if Class is installed, following should hold correct if class is installed.
    if ((fRet = RegOpenKey(HKEY_CLASSES_ROOT, szKeyName, &hKey)) == ERROR_SUCCESS)
        return FALSE;

    RegCloseKey(hKey);

    if ((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)(ClassStrings.pFileSpec+1), 
            REG_SZ, ClassStrings.pClassName, 7)) != ERROR_SUCCESS)
		return FALSE;

    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, ClassStrings.pClassName, REG_SZ, 
                  ClassStrings.pHumanReadable, 7)) != ERROR_SUCCESS)
		return FALSE;

    lstrcat(szKeyName, "\\0");
    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)szKeyName, REG_SZ, "PLAY", 4)) 
                  != ERROR_SUCCESS)
		return FALSE;

    szKeyName[lstrlen(szKeyName) - 1] = '1';  
    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)szKeyName, REG_SZ, "EDIT", 4)) 
         != ERROR_SUCCESS)
		return FALSE;

    lstrcpy(szKeyName, ClassStrings.pClassName);
    lstrcat(szKeyName, "\\protocol\\StdFileEditing\\Server");
    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)szKeyName, REG_SZ, ClassStrings.pExeName, 11)) 
         != ERROR_SUCCESS)
		return FALSE;

    lstrcpy(szKeyName, ClassStrings.pClassName);
    lstrcat(szKeyName, "\\protocol\\StdExecute\\Server");
    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)szKeyName, REG_SZ, ClassStrings.pExeName, 11)) 
         != ERROR_SUCCESS)
		return FALSE;

	
    return TRUE;

}


/* Abbrev
 * ------
 *
 * Return a pointer to the filename part of a fully-qualified pathname.
 *
 * LPSTR lpsz - Fully qualified pathname
 * 
 * CUSTOMIZATION: May be useful, but not necessary.
 *
 */
LPSTR Abbrev (LPSTR lpsz)
{
   LPSTR lpszTemp;
   
   lpszTemp = lpsz + lstrlen(lpsz) - 1;
   while (lpszTemp > lpsz && lpszTemp[-1] != '\\')
      lpszTemp--;
   return lpszTemp;
}





/* InitServer
 * ----------
 *
 * Initialize the server by allocating memory for it, and calling
 * the OleRegisterServer method.  Requires that the server method table
 * has been properly initialized.
 * 
 * HWND hwnd      - Handle to the main window
 * LPSTR lpszLine - The Windows command line
 * 
 * RETURNS: TRUE if the memory could be allocated, and the server
 *          was properly registered.
 *          FALSE otherwise
 *
 * CUSTOMIZATION: Your application might not use a global variable 
 *                for srvrMain.
 *
 */
BOOL InitServer (HWND hwnd, HANDLE hInst)
{
    RegServer();
    srvrMain.olesrvr.lpvtbl = &srvrvtbl;

    if (OLE_OK != OleRegisterServer
         (szClassName, (LPOLESERVER) &srvrMain, &srvrMain.lhsrvr, hInst, 
          OLE_SERVER_MULTI))
      return FALSE;
    else
      return TRUE;
}



/* InitVTbls
 * ---------
 *
 * Create procedure instances for all the OLE methods.
 * 
 * 
 * CUSTOMIZATION: Your application might not use global variables for srvrvtbl,
 *                docvtbl, and objvtbl.
 */
VOID InitVTbls (VOID)
{
   typedef LPVOID ( APIENTRY *LPVOIDPROC) (LPOLEOBJECT, LPSTR);

   // Server method table
   srvrvtbl.Create          = SrvrCreate;
   srvrvtbl.CreateFromTemplate = SrvrCreateFromTemplate;
   srvrvtbl.Edit            = SrvrEdit;
   srvrvtbl.Execute         = SrvrExecute;
   srvrvtbl.Exit            = SrvrExit;
   srvrvtbl.Open            = SrvrOpen;
   srvrvtbl.Release         = SrvrRelease;

   // Document method table
   docvtbl.Close            = DocClose;
   docvtbl.GetObject        = DocGetObject;
   docvtbl.Execute          = DocExecute;
   docvtbl.Release          = DocRelease;
   docvtbl.Save             = DocSave;
   docvtbl.SetColorScheme   = DocSetColorScheme;
   docvtbl.SetDocDimensions = DocSetDocDimensions;
   docvtbl.SetHostNames     = DocSetHostNames;

   // Object method table
   objvtbl.DoVerb           = ObjDoVerb;
   objvtbl.EnumFormats      = ObjEnumFormats;
   objvtbl.GetData          = ObjGetData;
   objvtbl.QueryProtocol    = ObjQueryProtocol;
   objvtbl.Release          = ObjRelease;
   objvtbl.SetBounds        = ObjSetBounds;
   objvtbl.SetColorScheme   = ObjSetColorScheme;
   objvtbl.SetData          = ObjSetData;
   objvtbl.SetTargetDevice  = ObjSetTargetDevice;
   objvtbl.Show             = ObjShow;

}



/* SetTitle 
 * --------
 *
 * Sets the main window's title bar. The format of the title bar is as follows
 *   
 * If embedded
 *        <Server App name> - <object type> in <client doc name>
 *   
 *      Example:  "Server Demo - SrvrDemo Shape in OLECLI.DOC"
 *                where OLECLI.DOC is a Winword document
 *   
 * otherwise
 *        <Server App name> - <server document name>     
 *   
 *      Example:  "Server Demo - OLESVR.SD" 
 *                where OLESVR.SD is a Server demo document
 *
 * LPSTR lpszDoc    - document name
 * BOOL  fEmbedded  - If TRUE embedded document, else normal document      
 * 
 * RETURNS: OLE_OK
 *
 * 
 * CUSTOMIZATION: Your application may store the document's name somewhere
 *                other than docMain.aName.  Other than that, you may
 *                find this a useful utility function as is.
 *
 */
VOID SetTitle (LPSTR lpszDoc, BOOL fEmbedded)
{
   CHAR szBuf[cchFilenameMax];

   if (lpszDoc && lpszDoc[0])
   {
      // Change document name.
      if (docMain.aName)
         GlobalDeleteAtom (docMain.aName);
      docMain.aName = GlobalAddAtom (lpszDoc);
   }

   if (fEmbedded)
   {
     // 
      if (lpszDoc && lpszDoc[0]) 
      {
         wsprintf (szBuf, "%s - SrvrDemo Shape in %s", (LPSTR) szAppName, 
             Abbrev (lpszDoc));
      }
      else
      {
         // Use name from docMain
         CHAR szDoc [cchFilenameMax];
     
         GlobalGetAtomName (docMain.aName, szDoc, cchFilenameMax);
         wsprintf (szBuf, "%s - SrvrDemo Shape in %s", (LPSTR) szAppName, 
             Abbrev (szDoc));
      }
      SetWindowText (hwndMain, (LPSTR)szBuf);
   } 
   else if (lpszDoc && lpszDoc[0])
   {
      wsprintf (szBuf, "%s - %s", (LPSTR) szAppName, Abbrev(lpszDoc));
      SetWindowText (hwndMain, szBuf);
   }
}




/* SrvrCreate                SERVER "Create" METHOD
 * ----------
 *
 * Create a document, allocate and initialize the OLESERVERDOC structure,
 * and associate the library's handle with it.
 * In this demo server, we also create an object for the user to edit.
 * 
 * LPOLESERVER lpolesrvr          - The server structure registered by
 *                                  the application
 * LHSERVERDOC lhdoc              - The library's handle
 * OLE_LPCSTR lpszClassName            - The class of document to create
 * OLE_LPCSTR lpszDoc                  - The name of the document
 * LPOLESERVERDOC FAR *lplpoledoc - Indicates the server doc structure to be
 *                                  created
 * 
 * RETURNS:        OLE_OK if the named document was created.
 *                 OLE_ERROR_NEW if the document could not be created.
 * 
 * CUSTOMIZATION: Your application might not call CreateNewObj.
 *
 */
OLESTATUS  APIENTRY SrvrCreate
   (LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc, OLE_LPCSTR lpszClassName, 
    OLE_LPCSTR lpszDoc, LPOLESERVERDOC FAR *lplpoledoc)
{
    if (!CreateNewDoc (lhdoc, (LPSTR) lpszDoc, doctypeEmbedded)) 
        return OLE_ERROR_NEW;

    // Although the document has not actually been changed, the client has not
    // received any data from the server yet, so the client will need to be
    // updated.  Therefore, CreateNewObj sets fDocChanged to TRUE.
    CreateNewObj (TRUE);
    *lplpoledoc = (LPOLESERVERDOC) &docMain;
    EmbeddingModeOn();
    return OLE_OK;
}



/* SrvrCreateFromTemplate        SERVER "CreateFromTemplate" METHOD
 * ----------------------
 *
 * Create a document, allocate and initialize the OLESERVERDOC structure, 
 * initializing the document with the contents named in the template name, 
 * and associate the library's handle with the document structure.
 * 
 * LPOLESERVER lpolesrvr        - The server structure registered by
 *                                the application
 * LHSERVERDOC lhdoc            - The library's handle
 * OLE_LPCSTR lpszClassName          - The class of document to create
 * OLE_LPCSTR lpszDoc                - The name of the document
 * OLE_LPCSTR lpszTemplate           - The name of the template
 * LPOLESERVERDOC FAR *lplpoledoc - Indicates the server doc structure 
 *                                  to be created
 * 
 * RETURNS:        OLE_OK if the named document was created.
 *                 OLE_ERROR_TEMPLATE if the document could not be created.
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrCreateFromTemplate
   (LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc, OLE_LPCSTR lpszClassName, 
    OLE_LPCSTR lpszDoc, OLE_LPCSTR lpszTemplate, LPOLESERVERDOC FAR *lplpoledoc)
{
    if (!CreateDocFromFile((LPSTR) lpszTemplate, (LHSERVERDOC) lhdoc, doctypeEmbedded)) 
        return OLE_ERROR_TEMPLATE;

    *lplpoledoc = (LPOLESERVERDOC) &docMain;

    // Although the document has not actually been changed, the client has not
    // received any data from the server yet, so the client will need to be
    // updated.
    fDocChanged = TRUE;
    EmbeddingModeOn();
    return OLE_OK;
}



/* SrvrEdit                SERVER "Edit" METHOD
 * --------
 *
 * A request by the libraries to create a document, allocate and
 * initialize the OLESERVERDOC structure, and associate the
 * library's handle with the document structure.
 * We create an object which will be modified by the SetData method
 * before the user has a chance to touch it.
 * 
 * LPOLESERVER lpolesrvr          - The server structure registered by
 *                                  the application
 * LHSERVERDOC lhdoc              - The library's handle
 * OLE_LPCSTR lpszClassName            - The class of document to create
 * OLE_LPCSTR lpszDoc                  - The name of the document
 * LPOLESERVERDOC FAR *lplpoledoc - Indicates the server doc structure to be
 *                                  created
 * 
 * RETURNS:        OLE_OK if the named document was created.
 *                 OLE_ERROR_EDIT if the document could not be created.
 * 
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrEdit 
   (LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc, OLE_LPCSTR lpszClassName, 
    OLE_LPCSTR lpszDoc, LPOLESERVERDOC FAR *lplpoledoc)
{
    if (!CreateNewDoc ((LONG)lhdoc, (LPSTR)lpszDoc, doctypeEmbedded))
        return OLE_ERROR_EDIT;

    // The client is creating an embedded object for the server to edit,
    // so initially the client and server are in sync.
    fDocChanged = FALSE;
    *lplpoledoc = (LPOLESERVERDOC) &docMain;
    EmbeddingModeOn();
    return OLE_OK;

}


/* SrvrExecute                SERVER "Execute" METHOD
 * --------
 *
 * This application does not support the execution of DDE execution commands.
 * 
 * LPOLESERVER lpolesrvr - The server structure registered by
 *                         the application
 * HANDLE hCommands      - DDE execute commands
 * 
 * RETURNS: OLE_ERROR_COMMAND
 *
 * CUSTOMIZATION: Re-implement if your application supports the execution of
 *                DDE commands.
 *
 */
OLESTATUS  APIENTRY SrvrExecute (LPOLESERVER lpolesrvr, HANDLE hCommands)
{
   return OLE_ERROR_COMMAND;
}



/* SrvrExit                SERVER "Exit" METHOD
 * --------
 *
 * This method is called the library to instruct the server to exit.
 * 
 * LPOLESERVER lpolesrvr - The server structure registered by
 *                         the application
 * 
 * RETURNS: OLE_OK
 * 
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrExit (LPOLESERVER lpolesrvr)
{
   if (srvrMain.lhsrvr)
   // If we haven't already tried to revoke the server.
   {
      StartRevokingServer();
   }
   return OLE_OK;
}



/* SrvrOpen                SERVER "Open" METHOD
 * --------
 *
 * Open the named document, allocate and initialize the OLESERVERDOC 
 * structure, and associate the library's handle with it.
 * 
 * LPOLESERVER lpolesrvr          - The server structure registered by
 *                                  the application
 * LHSERVERDOC lhdoc              - The library's handle
 * OLE_LPCSTR lpszDoc                  - The name of the document
 * LPOLESERVERDOC FAR *lplpoledoc - Indicates server doc structure to be
 *                                  created
 * 
 * RETURNS:        OLE_OK if the named document was opened.
 *                 OLE_ERROR_OPEN if document could not be opened correctly.
 * 
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrOpen (LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc,
                               OLE_LPCSTR lpszDoc, LPOLESERVERDOC FAR *lplpoledoc)
{
    if (!CreateDocFromFile ((LPSTR)lpszDoc, (LHSERVERDOC)lhdoc, doctypeFromFile))
        return OLE_ERROR_OPEN;

    *lplpoledoc = (LPOLESERVERDOC) &docMain;
    return OLE_OK;
}



/* SrvrRelease                SERVER "Release" METHOD
 * -----------
 *
 * This library calls the SrvrRelease method when it is safe to quit the
 * application.  Note that the server application is not required to quit.
 * 
 * srvrMain.lhsrvr != NULL indicates that SrvrRelease has been called
 * because the client is no longer connected, not because the server called
 * OleRevokeServer.
 * Therefore, only start the revoking process if the document is of type
 * doctypeEmbedded or if the server was opened for an invisible update.
 * 
 * srvrmain.lhsrvr == NULL indicates that OleRevokeServer has already 
 * been called (by the server application), and srvrMain is bad.
 * It is safe to quit now because SrvrRelease has just been called.
 *
 * Note that this method may be called twice: when OleRevokeServer is 
 * called in StartRevokingServer, SrvrRelease is called again.  
 * Therefore we need to be reentrant.
 * 
 * LPOLESERVER lpolesrvr - The server structure to release
 * 
 * RETURNS: OLE_OK
 * 
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrRelease (LPOLESERVER lpolesrvr)
{
   if (srvrMain.lhsrvr)
   {
      if (fRevokeSrvrOnSrvrRelease 
          && (docMain.doctype == doctypeEmbedded 
              || !IsWindowVisible (hwndMain)))
         StartRevokingServer();
   }
   else      
   {
      fWaitingForSrvrRelease = FALSE;
      // Here you should free any memory that had been allocated for the server.
      PostQuitMessage (0);
   }
   return OLE_OK;
}



/* StartRevokingServer
 * -------------------
 *
 * Hide the window, and start to revoke the server.  
 * Revoking the server will let the library close any registered documents.
 * OleRevokeServer may return OLE_WAIT_FOR_RELEASE.
 * Calling StartRevokingServer starts a chain of events that will eventually
 * lead to the application being terminated.
 *
 * RETURNS: The return value from OleRevokeServer
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS StartRevokingServer (VOID)
{
   OLESTATUS olestatus;

   if (srvrMain.lhsrvr)
   {
      LHSERVER lhserver;
      // Hide the window so user can do nothing while we are waiting. 
      ShowWindow (hwndMain, SW_HIDE);
      lhserver = srvrMain.lhsrvr;
      // Set lhsrvr to NULL to indicate that srvrMain is a bad and that
      // if SrvrRelease is called, then it is ok to quit the application.
      srvrMain.lhsrvr = 0;
      olestatus = OleRevokeServer (lhserver);
   }
   else
      // The programmer should ensure that this never happens.
      ErrorBox ("Fatal Error: StartRevokingServer called on NULL server.");
   return olestatus;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\server\cmacs.h ===
/****************************** Module Header ******************************\
* Module Name: CMACS.H
*
* This module contains common macros used by C routines.
*
* Created: 9-Feb-1989
*
* Copyright (c) 1985 - 1989  Microsoft Corporation
*
* History:
*   Created by Raor
*
\***************************************************************************/

#define _WINDOWS
#define  DLL_USE

#define INTERNAL        PASCAL NEAR
#define FARINTERNAL     PASCAL FAR

#ifdef FIREWALLS
extern short ole_flags;

#define DEBUG_PUTS          0x01
#define DEBUG_DEBUG_OUT     0x02
#define DEBUG_MESSAGEBOX    0x04

extern char    szDebugBuffer[];

#ifndef WIN32
#define UNREFERENCED_PARAMETER(x) (x)
#endif

#define DEBUG_OUT(parm1,parm2){\
    if(ole_flags & DEBUG_DEBUG_OUT){\
            wsprintf(szDebugBuffer,parm1,parm2);\
        OutputDebugString(szDebugBuffer);\
            OutputDebugString ("^^^  ");\
        }\
    }

#define ASSERT(x,y) {\
    if (!(x)) { \
        wsprintf (szDebugBuffer, "Assert Failure file %s, line %d\r\n     ", \
            (LPSTR) __FILE__, __LINE__);\
        OutputDebugString (szDebugBuffer);\
        OutputDebugString ((LPSTR) (y));\
        OutputDebugString ("@@@  ");\
    } \
}

#define Puts(msg) {\
                    if(ole_flags & DEBUG_PUTS){\
                        OutputDebugString ((LPSTR)(msg));\
                        OutputDebugString ("**  ");\
                    }\
                  }

#else

#define DEBUG_OUT(err, val) ;
#define ASSERT(cond, msg)
#define Puts(msg)        

#endif /* FIREWALLS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\server\checkptr.c ===
/* CheckPtr.c
   Pointer validation routine
   Written by t-jasonf.
*/

#include "windows.h"
#include "dde.h"
#include "ole.h"
#include "cmacs.h"
#include "srvr.h"


/* CheckPointer()
   Parameters :
      LPVOID lp         - pointer to check
      int    nREADWRITE - READ_ACCESS or WRITE_ACCESS
   Returns:
      0 if process does not have that kind of access to memory at lp.
      1 if process does have access.
*/
WORD CheckPointer (void *lp, int nReadWrite)
{
   char ch;
   WORD iRet;

   try
   {
      switch (nReadWrite)
      {
         case READ_ACCESS:
            ch = *((volatile char *)lp);
            break;
         case WRITE_ACCESS:
            ch = *((volatile char *)lp);
            *((volatile char *)lp) = ch;
            break;
      }
      iRet = 1;
   }
   except ( /*
            GetExceptionCode == STATUS_ACCESS_VIOLATION
            ? EXCEPTION_EXECUTE_HANDLER
            : EXCEPTION_CONTINUE_SEARCH
            */
            EXCEPTION_EXECUTE_HANDLER
          )
   {
      iRet = 0;
   }

   return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\server\item.c ===
/****************************** Module Header ******************************\
* Module Name: Item.c Object(item) main module
*
* Purpose: Includes All the object releated routiens.
*
* Created: Oct 1990.
*
* Copyright (c) 1990 - 1992  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*    curts created portable version for WIN16/32
*
\***************************************************************************/


#include "windows.h"
#include "cmacs.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"

extern HANDLE   hdllInst;
extern FARPROC  lpFindItemWnd;
extern FARPROC  lpItemCallBack;
extern FARPROC  lpSendDataMsg;
extern FARPROC  lpSendRenameMsg;
extern FARPROC  lpDeleteClientInfo;
extern FARPROC  lpEnumForTerminate;


extern  ATOM    cfNative;
extern  ATOM    cfBinary;
extern  ATOM    aClose;
extern  ATOM    aChange;
extern  ATOM    aSave;
extern  ATOM    aEditItems;
extern  ATOM    aStdDocName;

extern  WORD    cfLink;
extern  WORD    cfOwnerLink;
#ifdef WIN16
extern  BOOL    bWin30;
#endif

HWND            hwndItem;
HANDLE          hddeRename;
HWND            hwndRename;

UINT            enummsg;
UINT            enuminfo;
LPOLEOBJECT     enumlpoleobject;
OLECLIENTVTBL   clVtbl;
BOOL            bClientUnlink;

BOOL            fAdviseSaveDoc;
BOOL            fAdviseSaveItem;

char *  stdStrTable[STDHOSTNAMES+1] =
        {
            NULL,
            "StdTargetDevice",
            "StdDocDimensions",
            "StdColorScheme",
            "StdHostNames"
        };

#ifdef WIN16
extern HANDLE (FAR PASCAL *lpfnSetMetaFileBitsBetter) (HANDLE);
#endif

void ChangeOwner (HANDLE hmfp);

// !!!change child enumeration.
// !!!No consistency in errors (Sometimes Bools and sometimes OLESTATUS).


//SearchItem: Searches for a given item in a document tree.
//If found, returns the corresponding child windows handle.

HWND  INTERNAL SearchItem (
    LPDOC lpdoc,
    LPSTR lpitemname
){
    ATOM  aItem;

    Puts ("SearchItem");

    // If the item passed is an atom, get its name.
    if (!HIWORD(lpitemname))
        aItem = (ATOM) (LOWORD(lpitemname));
    else if (!lpitemname[0])
        aItem = (ATOM)0;
    else
        aItem = GlobalFindAtom (lpitemname);

    hwndItem = NULL;

    // !!! We should avoid hwndItem static. It should not cause
    // any problems since while enumerating we will not be calling
    // any window procs  or no PostMessages are entertained.

    EnumChildWindows (lpdoc->hwnd, (WNDENUMPROC)lpFindItemWnd,
        MAKELONG (aItem, ITEM_FIND));

    return hwndItem;

}

// FindItem: Given the itemname and the document handle,
// searches for the the item (object) in the document tree.
// Items are child windows for the document window.

// !!! change the child windows to somekind of
// linked lists at the item level. This will free up
// the space taken by the item windows.

int  INTERNAL FindItem (
    LPDOC          lpdoc,
    LPSTR          lpitemname,
    LPCLIENT FAR * lplpclient
){
    LPCLIENT    lpclient;
    HWND        hwnd;
    char        buf[MAX_STR];

    Puts ("FindItem");

    hwnd = SearchItem (lpdoc, lpitemname);

    if (!HIWORD(lpitemname)){
        if (LOWORD(lpitemname))
            GlobalGetAtomName ((ATOM)LOWORD(lpitemname),
                        (LPSTR)buf, MAX_STR);
        else
            buf[0] = '\0';

        lpitemname = (LPSTR)buf;
    }

    if (hwnd) {
        // we found the item window
        lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

#ifdef  FIREWALLS
            ASSERT ((CheckPointer(lpclient, WRITE_ACCESS)),
                "In Item the client handle missing")
            ASSERT ((CheckPointer(lpclient->lpoleobject, WRITE_ACCESS)),
                "In Item object handle missing")

#endif
            *lplpclient = lpclient;
            return OLE_OK;

    }

    // Item (object)window is not create yet. Let us create one.
    return RegisterItem ((LHDOC)lpdoc, lpitemname, lplpclient, TRUE);
}



//RegisterItem: Given the document handle and the item string
//creates item with the given document.

int  INTERNAL RegisterItem (
    LHDOC          lhdoc,
    LPSTR          lpitemname,
    LPCLIENT FAR * lplpclient,
    BOOL           bSrvr
){
    LPDOC           lpdoc;
    HANDLE          hclient  = NULL;
    LPCLIENT        lpclient = NULL;
    OLESTATUS        retval   = OLE_ERROR_MEMORY;
    LPOLESERVERDOC  lpoledoc;
    LPOLEOBJECT     lpoleobject = NULL;


    Puts ("CreateItem");

    lpdoc = (LPDOC)lhdoc;

#ifdef FIREWALLS
    ASSERT ((CheckPointer (lplpclient, WRITE_ACCESS)), "invalid lplpclient");
#endif

    // First create the callback client structure.

    hclient = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, sizeof (CLIENT));
    if(!(hclient && (lpclient = (LPCLIENT)GlobalLock (hclient))))
        goto errRtn;

    lpclient->hclient       = hclient;
    hclient                 = NULL;

    if (!HIWORD(lpitemname)) {
        ASSERT (!bSrvr, "invalid lpitemname in RegisterItem\n");
        lpclient->aItem = LOWORD(lpitemname);
    }
    else if (!lpitemname[0])
        lpclient->aItem = (ATOM)0;
    else
        lpclient->aItem = GlobalAddAtom (lpitemname);

    lpclient->oleClient.lpvtbl = &clVtbl;
    lpclient->oleClient.lpvtbl->CallBack = ItemCallBack;

    lpoledoc = lpdoc->lpoledoc;

    // Call the server app to create its own object structure and link
    // it to the given document.

    // Call the server if the item is not one of the standard items.

    if (bSrvr) {
        retval = (*lpoledoc->lpvtbl->GetObject)(lpoledoc, lpitemname,
                    (LPOLEOBJECT FAR *)&lpoleobject, (LPOLECLIENT)lpclient);
        if (retval != OLE_OK)
            goto errRtn;
    }

    lpclient->lpoleobject   = lpoleobject;

    lpclient->hwnd = CreateWindowEx (WS_EX_NOPARENTNOTIFY,"ItemWndClass", "ITEM",
                        WS_CHILD,0,0,0,0,lpdoc->hwnd,NULL, hdllInst, NULL);

    if (lpclient->hwnd == NULL)
        goto errRtn;

    // save the ptr to the item in the window.
    SetWindowLongPtr (lpclient->hwnd, 0, (LONG_PTR)lpclient);
    *lplpclient = lpclient;
    return OLE_OK;

errRtn:

    if (lpclient)
        RevokeObject ((LPOLECLIENT)lpclient, FALSE);

    else {
        if(hclient)
            GlobalFree (hclient);
    }

    return retval;

}


OLESTATUS  FAR PASCAL OleRevokeObject (
    LPOLECLIENT    lpoleclient
){
    return RevokeObject (lpoleclient, TRUE);

}

// OleRevokeObject: Revokes an object (unregisres an object
// from the document tree.

OLESTATUS  INTERNAL RevokeObject (
    LPOLECLIENT    lpoleclient,
    BOOL           bUnlink
){
    HANDLE      hclient;
    LPCLIENT    lpclient;

    lpclient = (LPCLIENT)lpoleclient;

    PROBE_WRITE(lpoleclient);
    if (lpclient->lpoleobject) {
       // first call the object for deletetion.

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBECT")

        if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT(lpclient->lpoleobject->lpvtbl->Release,
                "Invalid pointer to Release method")
#endif

        (*lpclient->lpoleobject->lpvtbl->Release)(lpclient->lpoleobject);

    }

    if (ISATOM(lpclient->aItem)) {
        GlobalDeleteAtom (lpclient->aItem);
        lpclient->aItem = (ATOM)0;
    }

    if (lpclient->hwnd) {
        SetWindowLongPtr (lpclient->hwnd, 0, (LONG_PTR)NULL);

        // another static for enumerating the properties.
        // we need to change these .
        bClientUnlink = bUnlink;

        EnumProps(lpclient->hwnd, (PROPENUMPROC)lpDeleteClientInfo);
        // post all the messages with yield which have been collected in enum
        // UnblockPostMsgs (lpclient->hwnd, FALSE);
        DestroyWindow (lpclient->hwnd);
    }

    GlobalUnlock (hclient = lpclient->hclient);
    GlobalFree (hclient);
    return OLE_OK;

}

BOOL    FAR PASCAL  DeleteClientInfo (
    HWND    hwnd,
    LPSTR   lpstr,
    HANDLE  hclinfo
){
    PCLINFO     pclinfo = NULL;
    HWND        hwndDoc;
    LPDOC       lpdoc;

#ifdef FIREWALLS
    ASSERT (hclinfo, "Client info null in item property list");
#endif


    // delete the printer dev info block
    if(pclinfo = (PCLINFO)LocalLock (hclinfo)){
        if(pclinfo->hdevInfo)
            GlobalFree (pclinfo->hdevInfo);


        if (bClientUnlink) {
            // terminate the conversation for the client.
            TerminateDocClients ((hwndDoc = GetParent(hwnd)), NULL, pclinfo->hwnd);
            lpdoc = (LPDOC)GetWindowLongPtr (hwndDoc, 0);
            // for some reason this delete is gving circular lists for properties

            //DeleteClient (hwndDoc, pclinfo->hwnd);
            //lpdoc->cClients--;
        }
        LocalUnlock (hclinfo);
    }
    LocalFree (hclinfo);

    RemoveProp(hwnd, lpstr);
    return TRUE;
}




// Call back for the Object windows numeration. data  field
// has the command and the extra information


BOOL    FAR PASCAL FindItemWnd(
    HWND    hwnd,
    LONG    data
){

    LPCLIENT    lpclient;
    int         cmd;
    HANDLE      hclinfo;
    PCLINFO     pclinfo = NULL;


    lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

#ifdef  FIREWALLS
    // ASSERT (lpclient, "In Item the client handle missing")
#endif

    cmd = HIWORD(data);
    switch (cmd) {
        case    ITEM_FIND:
            if (lpclient->aItem == (ATOM)(LOWORD (data))) {
                // we found the window we required. Remember the
                // object window.

                hwndItem = hwnd;
                return FALSE; // terminate enumeration.

            }
            break;

        case    ITEM_SAVED:
            if (lpclient->lpoleobject) {
                if (ItemCallBack ((LPOLECLIENT) lpclient, OLE_SAVED,
                        lpclient->lpoleobject) == OLE_ERROR_CANT_UPDATE_CLIENT)
                    fAdviseSaveDoc = FALSE;
            }
            break;

        case    ITEM_DELETECLIENT:

            // delete the client from our list if we have one

            hclinfo = FindClient (hwnd, (HWND) (LOWORD(data)));
            if (hclinfo){
                // delete the printer dev info block
                if(pclinfo = (PCLINFO)LocalLock (hclinfo)){
                    if(pclinfo->hdevInfo)
                        GlobalFree (pclinfo->hdevInfo);
                    LocalUnlock (hclinfo);
                }
                LocalFree (hclinfo);
                DeleteClient ( hwnd, (HWND) (LOWORD(data)));
            }
            break;

        case    ITEM_DELETE:
            // delete the client it self.
            RevokeObject ((LPOLECLIENT)lpclient, FALSE);
            break;

    }
    return TRUE;        // continue enumeration.
}



//DeleteFromItemsList: Deletes a client from the object lists of
//all the objects of a given  document. Thie client possibly
//is terminating the conversation with our doc window.


void INTERNAL   DeleteFromItemsList (
    HWND    hwndDoc,
    HWND    hwndClient
){

    EnumChildWindows (hwndDoc, (WNDENUMPROC)lpFindItemWnd,
        MAKELONG (hwndClient, ITEM_DELETECLIENT));

}


// DeleteAllItems: Deletes all the objects of a given
// document window.


void INTERNAL   DeleteAllItems (
    HWND    hwndDoc
){

    EnumChildWindows (hwndDoc, (WNDENUMPROC)lpFindItemWnd, MAKELONG (NULL, ITEM_DELETE));

}


// Object widnow proc:

LRESULT FAR PASCAL ItemWndProc(
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
){

    LPCLIENT    lpclient;

    lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

    switch (msg) {
       case WM_DESTROY:
            DEBUG_OUT("Item: Destroy window",0)

#ifdef  FIREWALLS
            ASSERT (!lpclient, "while destroy Item client is not null")
#endif
            break;
       default:
            DEBUG_OUT("item:  Default message",0)
            return DefWindowProc (hwnd, msg, wParam, lParam);

    }
    return 0L;

}

// PokeData: Prepares and gives the data to the server app thru
// the SetData object method.

OLESTATUS    INTERNAL PokeData (
    LPDOC       lpdoc,
    HWND        hwndClient,
    LPARAM      lparam
){
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    LPCLIENT        lpclient;
    DDEPOKE FAR *   lpPoke = NULL;
    HANDLE          hPoke = NULL;
    HANDLE          hnew   = NULL;
    OLECLIPFORMAT   format;
    BOOL            fRelease = FALSE;
    ATOM            aItem = GET_WM_DDE_POKE_ITEM((WPARAM)NULL,lparam);

    UNREFERENCED_PARAMETER(hwndClient);

    // Get the object handle first. Look in the registration
    // tree and if one is not created otherwise create one.

    retval = FindItem (lpdoc, (LPSTR) MAKEINTATOM(aItem),
                (LPCLIENT FAR *)&lpclient);

    if (retval != OLE_OK)
        goto errRtn;

    hPoke = GET_WM_DDE_POKE_HDATA((WPARAM)NULL,lparam);
    if(!(hPoke && (lpPoke = (DDEPOKE FAR *) GlobalLock (hPoke))))
        goto errRtn;

    GlobalUnlock (hPoke);

    format   = lpPoke->cfFormat;
    fRelease = lpPoke->fRelease;

    // We found the item. Now prepare the data to be given to the object
    if (!(hnew = MakeItemData (lpPoke, hPoke, format)))
        goto errRtn;

    // Now send the data to the object

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->SetData,
                "Invalid pointer to SetData method")
#endif

    retval = (*lpclient->lpoleobject->lpvtbl->SetData) (lpclient->lpoleobject,
                                                format, hnew);

    // We free the data if server returns OLE_ERROR_SETDATA_FORMAT.
    // Otherwise server must've deleted it.

    if (retval == OLE_ERROR_SETDATA_FORMAT) {
        if (!FreeGDIdata (hnew, format))
            GlobalFree (hnew);
    }


errRtn:
    if (retval == OLE_OK && fRelease) {
        if (hPoke)
            GlobalFree (hPoke);
    }

    return retval;
}




OLESTATUS  INTERNAL UnAdviseData (
    LPDOC   lpdoc,
    HWND    hwndClient,
    LPARAM  lparam
){
    char      buf[MAX_STR];
    int       options;
    LPCLIENT  lpclient;
    OLESTATUS retval  = OLE_ERROR_MEMORY;
    HANDLE    hclinfo = NULL;
    PCLINFO   pclinfo = NULL;

    UNREFERENCED_PARAMETER(hwndClient);

    if (!(HIWORD (lparam)))
        buf[0] = '\0';
    else
        GlobalGetAtomName ((ATOM)(HIWORD (lparam)), (LPSTR)buf, MAX_STR);

    // Scan for the advise options like "Close", "Save" etc
    // at the end of the item.

    if((retval = ScanItemOptions ((LPSTR)buf, (int far *)&options)) !=
            OLE_OK)
        goto errRtn;


    if (buf[0] == '\0') {
        // Unadvise for null should terminate all the advises
        DeleteFromItemsList (lpdoc->hwnd, hwndClient);
        return OLE_OK;
    }

    // Now get the corresponding object.
    retval = FindItem (lpdoc, (LPSTR)buf, (LPCLIENT FAR *)&lpclient);
    if (retval != OLE_OK)
        goto errRtn;


    // Find the client structure to be attcahed to the object.
    if ((hclinfo = FindClient (lpclient->hwnd, hwndClient)) == NULL ||
        (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL ){
            retval = OLE_ERROR_MEMORY;
            goto errRtn;
    }

    pclinfo->options &= (~(0x0001 << options));

errRtn:
    if (pclinfo)
        LocalUnlock (hclinfo);
    return retval;

}



// AdviseStdItems: This routine takes care of the DDEADVISE for a
//particular object in given document. Creates a client strutcure
//and attaches to the property list of the object window.

OLESTATUS INTERNAL  AdviseStdItems (
    LPDOC       lpdoc,
    HWND        hwndClient,
    LPARAM      lparam,
    BOOL FAR *  lpfack
){
    HANDLE          hopt   = GET_WM_DDE_ADVISE_HOPTIONS((WPARAM)NULL,lparam);
    ATOM            aItem  = GET_WM_DDE_ADVISE_ITEM((WPARAM)NULL,lparam);
    DDEADVISE FAR  *lpopt;
    OLESTATUS       retval = OLE_ERROR_MEMORY;

    if(!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
        goto errrtn;

#ifdef  FIREWALLS
    ASSERT ((aItem == aStdDocName), "AdviseStdItem is not Documentname");
#endif

    *lpfack = lpopt->fAckReq;
    retval = SetStdInfo (lpdoc, hwndClient, (LPSTR)"StdDocumentName",  NULL);

    if (lpopt)
        GlobalUnlock (hopt);

errrtn:

    if (retval == OLE_OK)
        // !!! make sure that we have to free the data for error case
        GlobalFree (hopt);
    return retval;
}



//AdviseData: This routine takes care of the DDEADVISE for a
//particular object in given document. Creates a client strutcure
//and attaches to the property list of the object window.

OLESTATUS INTERNAL  AdviseData (
    LPDOC       lpdoc,
    HWND        hwndClient,
    LPARAM      lparam,
    BOOL FAR *  lpfack
){
    HANDLE          hopt   = GET_WM_DDE_ADVISE_HOPTIONS((WPARAM)NULL,lparam);
    ATOM            aitem  = GET_WM_DDE_ADVISE_ITEM((WPARAM)NULL,lparam);
    DDEADVISE FAR   *lpopt = NULL;
    OLECLIPFORMAT   format = 0;
    char            buf[MAX_STR];
    int             options;
    LPCLIENT        lpclient;
    OLESTATUS       retval  = OLE_ERROR_MEMORY;
    HANDLE          hclinfo = NULL;
    PCLINFO         pclinfo = NULL;

    if(!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
        goto errRtn;

    if (!aitem)
        buf[0] = '\0';
    else
        GlobalGetAtomName (aitem, (LPSTR)buf, MAX_STR);

    // Scan for the advise options like "Close", "Save" etc
    // at the end of the item.

    if((retval = ScanItemOptions ((LPSTR)buf, (int far *)&options)) !=
            OLE_OK)
        goto errRtn;


    // Now get the corresponding object.
    retval = FindItem (lpdoc, (LPSTR)buf, (LPCLIENT FAR *)&lpclient);
    if (retval != OLE_OK)
        goto errRtn;

    if (!IsFormatAvailable (lpclient, lpopt->cfFormat)){
        retval = OLE_ERROR_DATATYPE;       // this format is not supported;
        goto errRtn;
    }

    *lpfack = lpopt->fAckReq;

    // Create the client structure to be attcahed to the object.
    if (!(hclinfo = FindClient (lpclient->hwnd, hwndClient)))
        hclinfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLINFO));

    if (hclinfo == NULL || (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL){
        retval = OLE_ERROR_MEMORY;
        goto errRtn;
    }

    // Remember the client window (Needed for sending DATA later on
    // when the data change message comes from the server)

    pclinfo->hwnd = hwndClient;
    if (lpopt->cfFormat == (SHORT)cfNative)
        pclinfo->bnative = TRUE;
    else
        pclinfo->format = lpopt->cfFormat;

    // Remeber the data transfer options.
    pclinfo->options |= (0x0001 << options);
    pclinfo->bdata   = !lpopt->fDeferUpd;
    LocalUnlock (hclinfo);
    pclinfo = (PCLINFO)NULL;


    // if the entry exists already, delete it.
    DeleteClient (lpclient->hwnd, hwndClient);

    // Now add this client to item client list
    // !!! This error recovery is not correct.
    if(!AddClient (lpclient->hwnd, hwndClient, hclinfo))
        goto errRtn;


errRtn:
    if (lpopt)
        GlobalUnlock (hopt);

    if (pclinfo)
        LocalUnlock (hclinfo);

    if (retval == OLE_OK) {
        // !!! make sure that we have to free the data
        GlobalFree (hopt);

    }else {
        if (hclinfo)
            LocalFree (hclinfo);
    }
    return retval;

}

BOOL INTERNAL IsFormatAvailable (
    LPCLIENT        lpclient,
    OLECLIPFORMAT   cfFormat
){
      OLECLIPFORMAT  cfNext = 0;


      do{

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBECT")
        else if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->EnumFormats,
                "Invalid pointer to EnumFormats method")
#endif

        cfNext = (*lpclient->lpoleobject->lpvtbl->EnumFormats)
                                (lpclient->lpoleobject, cfNext);
        if (cfNext == cfFormat)
            return TRUE;

      }while (cfNext != 0);

      return FALSE;
}

//ScanItemOptions: Scan for the item options like Close/Save etc.

OLESTATUS INTERNAL ScanItemOptions (
    LPSTR   lpbuf,
    int far *lpoptions
){
    ATOM    aModifier;

    *lpoptions = OLE_CHANGED;
    while ( *lpbuf && *lpbuf != '/')
           lpbuf++;

    // no modifier same as /change

    if (*lpbuf == '\0')
        return OLE_OK;

    *lpbuf++ = '\0';        // seperate out the item string
                            // We are using this in the caller.

    if (!(aModifier = GlobalFindAtom (lpbuf)))
        return OLE_ERROR_SYNTAX;

    if (aModifier == aChange)
        return OLE_OK;

    // Is it a save?
    if (aModifier == aSave){
        *lpoptions = OLE_SAVED;
        return  OLE_OK;
    }
    // Is it a Close?
    if (aModifier == aClose){
        *lpoptions = OLE_CLOSED;
        return OLE_OK;
    }

    // unknow modifier
    return OLE_ERROR_SYNTAX;

}

//RequestData: Sends data in response to a DDE Request message.
// for  agiven doc and an object.

OLESTATUS INTERNAL   RequestData (
    LPDOC       lpdoc,
    HWND        hwndClient,
    LPARAM      lparam,
    LPHANDLE    lphdde
){
    OLESTATUS   retval = OLE_OK;
    HANDLE      hdata;
    LPCLIENT    lpclient;
    char        buf[20];

    // If edit environment Send data if we can
    if ((HIWORD (lparam)) == aEditItems)
        return RequestDataStd (lparam, lphdde);

    // Get the object.
    retval = FindItem (lpdoc, (LPSTR) MAKEINTATOM(HIWORD(lparam)),
                (LPCLIENT FAR *)&lpclient);
    if (retval != OLE_OK)
        goto errRtn;

    retval = OLE_ERROR_DATATYPE;
    if (!IsFormatAvailable (lpclient, (OLECLIPFORMAT)(LOWORD (lparam))))
        goto errRtn;

    // Now ask the item for the given format  data

#ifdef FIREWALLS
    ASSERT (lpclient->lpoleobject->lpvtbl->GetData,
        "Invalid pointer to GetData method")
#endif

    MapToHexStr ((LPSTR)buf, hwndClient);
    SendDevInfo (lpclient, (LPSTR)buf);

    retval = (*lpclient->lpoleobject->lpvtbl->GetData) (lpclient->lpoleobject,
                (OLECLIPFORMAT)(LOWORD(lparam)), (LPHANDLE)&hdata);

    if (retval != OLE_OK)
        goto errRtn;

    if (LOWORD(lparam) == CF_METAFILEPICT)
        ChangeOwner (hdata);

    // Duplicate the DDE data
    if (MakeDDEData(hdata, (OLECLIPFORMAT)(LOWORD (lparam)), lphdde, TRUE)){
        // !!! Why do we have to duplicate the atom
        DuplicateAtom ((ATOM)(HIWORD (lparam)));
        return OLE_OK;
    }
    else
       return OLE_ERROR_MEMORY;

errRtn:
    return retval;

}

#ifdef WIN32
HANDLE INTERNAL BmDuplicate (
   HBITMAP     hold
){
    HANDLE      hMem;
    LPSTR       lpMem;
    LONG        retVal = TRUE;
    DWORD       dwSize;
    BITMAP      bm;

     // !!! another way to duplicate the bitmap

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) *
             ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, dwSize+sizeof(BITMAP)+sizeof(DWORD))))
        return NULL;

    if (!(lpMem = (LPBYTE)GlobalLock (hMem))){
        GlobalFree (hMem);
        return NULL;
    }
    *((DWORD FAR *) lpMem) = dwSize;
    *(BITMAP FAR *) (lpMem+sizeof(DWORD)) = bm;
    lpMem += (sizeof(DWORD) + sizeof (BITMAP));
    dwSize = GetBitmapBits (hold, 0, NULL);
    retVal = GetBitmapBits (hold, dwSize, lpMem);

    GlobalUnlock (hMem);
    return hMem;


}
#endif

//MakeDDEData: Create a Global DDE data handle from the server
// app data handle.

BOOL    INTERNAL MakeDDEData (
    HANDLE        hdata,
    OLECLIPFORMAT format,
    LPHANDLE      lph,
    BOOL          fResponse
){
    DWORD       size;
    HANDLE      hdde   = NULL;
    DDEDATA FAR *lpdata= NULL;
    BOOL        bnative;
    LPSTR       lpdst;
    LPSTR       lpsrc;

    if (!hdata) {
        *lph = NULL;
        return TRUE;
    }

    if (bnative = !(format == CF_METAFILEPICT || format == CF_DIB ||
                            format == CF_BITMAP || format == CF_ENHMETAFILE))
       size = (DWORD)GlobalSize (hdata) + sizeof (DDEDATA);
    else
#ifdef WIN32HACK
    {
       if (format == CF_BITMAP)
           hdata = BmDuplicate(hdata);

           size = sizeof (HANDLE_PTR) + sizeof (DDEDATA);
    }
#else
           size = sizeof (HANDLE_PTR) + sizeof (DDEDATA);
#endif


    hdde = (HANDLE) GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, size);
    if (hdde == NULL || (lpdata = (DDEDATA FAR *) GlobalLock (hdde)) == NULL)
        goto errRtn;

    // set the data otions. Ask the client to delete
    // it always.

    lpdata->fRelease  = TRUE;  // release the data
    lpdata->cfFormat  = (WORD)format;
    lpdata->fResponse = (WORD)fResponse;

    if (!bnative) {
        // If not native, stick in the handle what the server gave us.
        
        // Com1x bug 23211: data misalignment: truncate handle to 32 bits on Win64 
        // because a) handle is only 32 bit significant; b) this was causing data misalignment 
        // error; c) we're only allocating 32 bits for it above. 
#ifdef _WIN64
        if (format == CF_METAFILEPICT)
            *(void* __unaligned*)lpdata->Value = hdata;
    	else
#endif
            *(LONG*)lpdata->Value = HandleToLong(hdata);
   	}
    else {
        // copy the native data junk here.
        lpdst = (LPSTR)lpdata->Value;
        if(!(lpsrc = (LPSTR)GlobalLock (hdata)))
            goto errRtn;

         size -= sizeof (DDEDATA);
         UtilMemCpy (lpdst, lpsrc, size);
         GlobalUnlock (hdata);
         GlobalFree (hdata);

    }

    GlobalUnlock (hdde);
    *lph = hdde;
    return TRUE;

errRtn:
    if (lpdata)
        GlobalUnlock (hdde);

    if (hdde)
        GlobalFree (hdde);

    if (bnative)
         GlobalFree (hdata);

    return FALSE;
}


// ItemCallback: Calback routine for the server to inform the
// data changes. When the change message is received, DDE data
// message is sent to each of the clients depending on the
// options.

int FAR PASCAL  ItemCallBack (
    LPOLECLIENT      lpoleclient,
    OLE_NOTIFICATION msg,        // notification message
    LPOLEOBJECT      lpoleobject
){

    LPCLIENT    lpclient;
    int         retval = OLE_OK;
    HANDLE      hdata  = NULL;
    LPSTR       lpdata = NULL;
    LPDOC       lpdoc;
    HWND        hStdWnd;

    lpclient  = (LPCLIENT)lpoleclient;
    lpdoc = (LPDOC)GetWindowLongPtr (GetParent (lpclient->hwnd), 0);

    if (msg == OLE_RENAMED) {
#ifdef FIREWALLS
        if (!CheckPointer (lpoleobject, WRITE_ACCESS))
          ASSERT (0, "Invalid lpoleobject")
        else if (!CheckPointer (lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpoleobject->lpvtbl->GetData,
                "Invalid pointer to GetData method")
#endif

        if (IsFormatAvailable (lpclient, cfLink)) {

            // Get the link data.

            retval = (*lpoleobject->lpvtbl->GetData) (lpoleobject,
                                cfLink, (LPHANDLE)&hdata);
        }
        else {
            if(IsFormatAvailable (lpclient, cfOwnerLink)) {

                // Get the link data.
                retval = (*lpoleobject->lpvtbl->GetData) (lpoleobject,
                                    cfOwnerLink, (LPHANDLE)&hdata);
#ifdef  FIREWALLS
                ASSERT (retval != OLE_BUSY, "Getdata returns with OLE_BUSY")
#endif


            } else
                retval = OLE_ERROR_DATATYPE;
        }

        if (retval != OLE_OK)
            goto errrtn;

        if (!(lpdata = (LPSTR)GlobalLock (hdata)))
            goto errrtn;

        if (lpdoc->aDoc) {
            GlobalDeleteAtom (lpdoc->aDoc);
            lpdoc->aDoc = (ATOM)0;
        }

        // Move the string to the beginning and still terminated by null;
        lstrcpy (lpdata, lpdata + lstrlen (lpdata) + 1);
        lpdoc->aDoc = GlobalAddAtom (lpdata);

        // Now make the DDE data block
        GlobalUnlock (hdata);
        lpdata = NULL;

        // find if any StdDocName item is present at all
        if (!(hStdWnd = SearchItem (lpdoc, (LPSTR) MAKEINTATOM(aStdDocName))))
            GlobalFree (hdata);
        else {

            // hdata is freed by Makeddedata
            if (!MakeDDEData (hdata, cfBinary, (LPHANDLE)&hddeRename,
                        FALSE)) {
                retval = OLE_ERROR_MEMORY;
                goto errrtn;
            }

            EnumProps(hStdWnd, (PROPENUMPROC)lpSendRenameMsg);
            // post all the messages with yield which have been collected in enum
            // UnblockPostMsgs (hStdWnd, FALSE);
            GlobalFree (hddeRename);
        }

        // static. Avoid this. This may not cause any problems for now.
        // if there is any better way, change it.
        hwndRename = hStdWnd;

        // Post termination for each of the doc clients.
        EnumProps(lpdoc->hwnd, (PROPENUMPROC)lpEnumForTerminate);

        lpdoc->fEmbed = FALSE;

        // post all the messages with yield which have been collected in enum
        // UnblockPostMsgs (lpdoc->hwnd, FALSE);
        return OLE_OK;

     errrtn:
        if (lpdata)
            GlobalUnlock (hdata);

        if (hdata)
            GlobalFree (hdata);

        return retval;

    } else {

        // !!! any better way to do instead of putting in static
        // (There may not be any problems since we are not allowing
        // any messages to get thru while we are posting messages).


        if ((enummsg = msg) == OLE_SAVED)
            fAdviseSaveItem = FALSE;

        enumlpoleobject = lpoleobject;

#ifdef  FIREWALLS
        ASSERT (lpclient->hwnd && IsWindowValid (lpclient->hwnd), " Not valid object")
#endif

        // Enumerate all the clients and send DDE_DATA if necessary.
        EnumProps(lpclient->hwnd, (PROPENUMPROC)lpSendDataMsg);
        // post all the messages with yield which have been collected in enum
        // UnblockPostMsgs (lpclient->hwnd, FALSE);

        if ((msg == OLE_SAVED) && lpdoc->fEmbed && !fAdviseSaveItem)
            return OLE_ERROR_CANT_UPDATE_CLIENT;

        return OLE_OK;
    }
}


BOOL    FAR PASCAL  EnumForTerminate (
    HWND    hwnd,
    LPSTR   lpstr,
    HANDLE  hdata
){
    LPDOC   lpdoc;

    UNREFERENCED_PARAMETER(lpstr);

    lpdoc = (LPDOC)GetWindowLongPtr (hwnd , 0);

    // This client is in the rename list. So, no terminate
    if(hwndRename && FindClient (hwndRename, (HWND)hdata))
        return TRUE;

    if (PostMessageToClientWithBlock ((HWND)hdata, WM_DDE_TERMINATE, (WPARAM)hwnd, (LPARAM)0))
        lpdoc->termNo++;

    //DeleteClient (hwnd, (HWND)hdata);
    //lpdoc->cClients--;
    return TRUE;
}


BOOL    FAR PASCAL  SendRenameMsg (
    HWND    hwnd,
    LPSTR   lpstr,
    HANDLE  hclinfo
){
    ATOM    aData       = (ATOM)0;
    HANDLE  hdde        = NULL;
    PCLINFO pclinfo     = NULL;
    HWND    hwndClient;
    LPARAM  lParamNew;

    UNREFERENCED_PARAMETER(lpstr);

    if (!(pclinfo = (PCLINFO) LocalLock (hclinfo)))
        goto errrtn;

    // Make the item atom with the options.
    aData =  DuplicateAtom (aStdDocName);
    hdde  = DuplicateData (hddeRename);

    hwndClient  = pclinfo->hwnd;
    LocalUnlock (hclinfo);

    // Post the message
    lParamNew = MAKE_DDE_LPARAM(WM_DDE_DATA,hdde,aData);
    if (!PostMessageToClientWithBlock (hwndClient,WM_DDE_DATA,
            (WPARAM)GetParent(hwnd),lParamNew))
    {
        DDEFREE(WM_DDE_DATA,lParamNew);
        goto errrtn;
    }

    return TRUE;

errrtn:

    if (hdde)
        GlobalFree (hdde);
    if (aData)
        GlobalDeleteAtom (aData);

    return TRUE;

}



//SendDataMsg: Send data to the clients, if the data change options
//match the data advise options.

BOOL    FAR PASCAL  SendDataMsg (
    HWND    hwnd,
    LPSTR   lpstr,
    HANDLE  hclinfo
){
    PCLINFO    pclinfo = NULL;
    HANDLE      hdde    = NULL;
    ATOM        aData   = (ATOM)0;
    int         retval;
    HANDLE      hdata;
    LPCLIENT    lpclient;
    LPARAM      lParamNew;


    if (!(pclinfo = (PCLINFO) LocalLock (hclinfo)))
        goto errRtn;

    lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

#ifdef  FIREWALLS
    ASSERT ((CheckPointer(lpclient, WRITE_ACCESS)),
        "In Item the client handle missing")
#endif

    // if the client dead, then no message
    if (!IsWindowValid(pclinfo->hwnd))
        goto errRtn;

    if (pclinfo->options & (0x0001 << enummsg)) {
        fAdviseSaveItem = TRUE;
        SendDevInfo (lpclient, lpstr);

        // send message if the client needs data for every change or
        // only for the selective ones he wants.

        // now look for the data option.
        if (pclinfo->bnative){
            // prepare native data
            if (pclinfo->bdata){

                // Wants the data with DDE_DATA message
                // Get native data from the server.

#ifdef FIREWALLS
                if (!CheckPointer (enumlpoleobject, WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLEOBECT")
                else if (!CheckPointer (enumlpoleobject->lpvtbl,WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLEOBJECTVTBL")
                else
                    ASSERT (enumlpoleobject->lpvtbl->GetData,
                        "Invalid pointer to GetData method")
#endif

                retval = (*enumlpoleobject->lpvtbl->GetData) (enumlpoleobject,
                            cfNative, (LPHANDLE)&hdata);
#ifdef  FIREWALLS
                ASSERT (retval != OLE_BUSY, "Getdata returns with OLE_BUSY");
#endif
                if (retval != OLE_OK)
                    goto errRtn;

                // Prepare the DDE data block.
                if(!MakeDDEData (hdata, cfNative, (LPHANDLE)&hdde, FALSE))
                    goto errRtn;

            }


            // Make the item atom with the options.
            aData =  MakeDataAtom (lpclient->aItem, enummsg);
            lParamNew = MAKE_DDE_LPARAM(WM_DDE_DATA,hdde,aData);
            // Post the message
            if (!PostMessageToClientWithBlock (pclinfo->hwnd, WM_DDE_DATA,
                    (WPARAM)GetParent(hwnd), lParamNew))
            {
                DDEFREE(WM_DDE_DATA,lParamNew);
                goto errRtn;
            }
            hdde = NULL;
            aData = (ATOM)0;
        }

        // Now post the data for the disply format
        if (pclinfo->format){
            if (pclinfo->bdata){
#ifdef FIREWALLS
                if (!CheckPointer (enumlpoleobject, WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLEOBECT")
                else if (!CheckPointer (enumlpoleobject->lpvtbl,WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLEOBJECTVTBL")
                else
                    ASSERT (enumlpoleobject->lpvtbl->GetData,
                        "Invalid pointer to GetData method")
#endif
                retval = (*enumlpoleobject->lpvtbl->GetData) (enumlpoleobject,
                            pclinfo->format, (LPHANDLE)&hdata);

#ifdef  FIREWALLS
                ASSERT (retval != OLE_BUSY, "Getdata returns with OLE_BUSY");
#endif
                if (retval != OLE_OK)
                    goto errRtn;

                if (pclinfo->format == CF_METAFILEPICT)
                    ChangeOwner (hdata);
Puts("sending metafile...");
                if(!MakeDDEData (hdata, pclinfo->format, (LPHANDLE)&hdde, FALSE))
                    goto errRtn;

            }
            // atom is deleted. So, we need to duplicate for every post
            aData =  MakeDataAtom (lpclient->aItem, enummsg);
            lParamNew = MAKE_DDE_LPARAM(WM_DDE_DATA,hdde,aData);
            // now post the message to the client;
            if (!PostMessageToClientWithBlock (pclinfo->hwnd, WM_DDE_DATA,
                    (WPARAM)GetParent(hwnd), lParamNew))
            {
                DDEFREE(WM_DDE_DATA,lParamNew);
                goto errRtn;
            }

            hdde = NULL;
            aData = (ATOM)0;

        }

    }


errRtn:
    if (pclinfo)
        LocalUnlock (hclinfo);

    if (hdde)
        GlobalFree (hdde);

    if (aData)
        GlobalDeleteAtom (aData);

    return TRUE;

}


// IsAdviseStdItems: returns true if the item is one of the standard items
// StdDocName;
BOOL    INTERNAL IsAdviseStdItems (
    ATOM   aItem
){

    if ( aItem == aStdDocName)
        return TRUE;
    else
        return FALSE;
}

// GetStdItemIndex: returns index to Stditems in the "stdStrTable" if the item
// is one of the standard items StdHostNames, StdTargetDevice,
// StdDocDimensions, StdColorScheme

int INTERNAL GetStdItemIndex (
    ATOM  aItem
){
    char  str[MAX_STR];

    if (!aItem)
        return 0;

    if (!GlobalGetAtomName (aItem, (LPSTR) str, MAX_STR))
        return 0;

    if (!lstrcmpi (str, stdStrTable[STDTARGETDEVICE]))
        return STDTARGETDEVICE;
    else if (!lstrcmpi (str, stdStrTable[STDHOSTNAMES]))
        return STDHOSTNAMES;
    else if (!lstrcmpi (str, stdStrTable[STDDOCDIMENSIONS]))
        return STDDOCDIMENSIONS;
    else if (!lstrcmpi (str, stdStrTable[STDCOLORSCHEME]))
        return STDCOLORSCHEME;

    return 0;
}

//
// The wire representation of STDDOCDIMENSIONS is a 16-bit
// format. This means instead of 4 longs, there are
// 4 shorts. This structure is used below to pick the data
// from the wire representation.
// backward compatible is the name of the game.
//
typedef struct tagRECT16
{
  SHORT left;
  SHORT top;
  SHORT right;
  SHORT bottom;

} RECT16, *LPRECT16;

// PokeStdItems: Pokes the data for the standard items.
// For StdHostnames, StdDocDimensions and SetColorScheme the data is
// sent immediately and for the the StdTargetDeviceinfo the
// data is set in each client block and the data is sent just
// before the GetData call for rendering the right data.


OLESTATUS    INTERNAL PokeStdItems (
    LPDOC   lpdoc,
    HWND    hwndClient,
    HANDLE  hdata,
    int     index
){
    DDEDATA FAR *   lpdata = NULL;
    HANDLE          hnew   = NULL;
    LPOLESERVERDOC  lpoledoc;
    LPHOSTNAMES     lphostnames;
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    OLECLIPFORMAT   format;
    BOOL            fRelease;
    RECT            rcDoc;

    if(!(hdata && (lpdata = (DDEDATA FAR *)GlobalLock (hdata))))
        goto errRtn;

    format   = lpdata->cfFormat;
    fRelease = lpdata->fRelease;

#ifdef FIREWALSS
    ASSERT (format == cfBinary, "Format is not binary");
#endif

    // we have extracted the data successfully.
    lpoledoc = lpdoc->lpoledoc;
#ifdef FIREWALLS
        if (!CheckPointer (lpoledoc, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOC")
        else if (!CheckPointer (lpoledoc->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
#endif

    if (index == STDHOSTNAMES){
        lphostnames = (LPHOSTNAMES)lpdata->Value;
#ifdef FIREWALLS
        ASSERT (lpoledoc->lpvtbl->SetHostNames,
            "Invalid pointer to SetHostNames method")
#endif
        retval = (*lpoledoc->lpvtbl->SetHostNames)(lpdoc->lpoledoc,
                       (LPSTR)lphostnames->data,
                       ((LPSTR)lphostnames->data) +
                        lphostnames->documentNameOffset);
        goto end;
    }

    if (index == STDDOCDIMENSIONS){
#ifdef FIREWALLS
        ASSERT (lpoledoc->lpvtbl->SetDocDimensions,
            "Invalid pointer to SetDocDimensions method")
#endif
        rcDoc.left   = 0;
        rcDoc.top    = ((LPRECT16)(lpdata->Value))->top;
        rcDoc.bottom = 0;
        rcDoc.right  = ((LPRECT16)lpdata->Value)->left;

        retval = (*lpoledoc->lpvtbl->SetDocDimensions)(lpdoc->lpoledoc,
                                            (LPRECT)&rcDoc);

        goto end;

    }

    if (index == STDCOLORSCHEME) {
#ifdef FIREWALLS
        ASSERT (lpoledoc->lpvtbl->SetColorScheme,
            "Invalid pointer to SetColorScheme method")
#endif
        retval = (*lpoledoc->lpvtbl->SetColorScheme)(lpdoc->lpoledoc,
                                            (LPLOGPALETTE) lpdata->Value);
        goto end;
    }
#ifdef FIREWALLS
    ASSERT (index == STDTARGETDEVICE, "Unknown standard item");
#endif

    // case of the printer decvice info

    if (!(hnew = MakeItemData ((DDEPOKE FAR *)lpdata, hdata, format)))
        goto errRtn;

    // Go thru the all the items lists for this doc and replace the
    // printer device info information.
    // Free the block we duplicated.
    retval = SetStdInfo (lpdoc, hwndClient,
                (LPSTR) ULongToPtr(MAKELONG(STDTARGETDEVICE,0)),hnew);


end:
errRtn:
    if (hnew)
        // can only be global memory block
        GlobalFree (hnew);

    if (lpdata) {
        GlobalUnlock (hdata);
        if (retval == OLE_OK && fRelease)
            GlobalFree (hdata);
    }
    return retval;
}


// SetStdInfo: Sets the targetdevice info. Creates a client
// for "StdTargetDevice". This item is created only within the
// lib and it is never visible in server app. When the change
// message comes from the server app, before we ask for
// the data, we send the targetdevice info if there is
// info for the client whom we are trying to send the data
// on advise.


int INTERNAL   SetStdInfo (
    LPDOC   lpdoc,
    HWND    hwndClient,
    LPSTR   lpitemname,
    HANDLE  hdata
){
    HWND        hwnd;
    HANDLE      hclinfo  = NULL;
    PCLINFO    pclinfo = NULL;
    LPCLIENT    lpclient;
    OLESTATUS   retval   = OLE_OK;


    // first create/find the StdTargetDeviceItem.

    if ((hwnd = SearchItem (lpdoc, lpitemname))
                == NULL){
         retval = RegisterItem ((LHDOC)lpdoc, lpitemname,
                          (LPCLIENT FAR *)&lpclient, FALSE);

         if (retval != OLE_OK)
            goto errRtn;

         hwnd = lpclient->hwnd;

      }

#ifdef  FIREWALLS
      ASSERT (retval == OLE_OK, "No StdTragetDevice or StdDocname item");
#endif


    if(hclinfo = FindClient (hwnd, hwndClient)){
        if (pclinfo = (PCLINFO) LocalLock (hclinfo)){
            if (pclinfo->hdevInfo)
                GlobalFree (pclinfo->hdevInfo);
            pclinfo->bnewDevInfo = TRUE;
            if (hdata)
                pclinfo->hdevInfo = DuplicateData (hdata);
            else
                pclinfo->hdevInfo = NULL;
            pclinfo->hwnd = hwndClient;
            LocalUnlock (hclinfo);

            // We do not have to reset the client because we did not
            // change the handle it self.
        }
    } else {
        // Create the client structure to be attcahed to the object.
        hclinfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLINFO));
        if (hclinfo == NULL || (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL)
            goto errRtn;

        pclinfo->bnewDevInfo = TRUE;
        if (hdata)
            pclinfo->hdevInfo = DuplicateData (hdata);
        else
            pclinfo->hdevInfo = NULL;

        pclinfo->hwnd = hwndClient;
        LocalUnlock (hclinfo);


        // Now add this client to item client list
        // !!! This error recovery is not correct.
        if (!AddClient (hwnd, hwndClient, hclinfo))
            goto errRtn;

    }
    return OLE_OK;
errRtn:
    if (pclinfo)
        LocalUnlock (hclinfo);

    if (hclinfo)
        LocalFree (hclinfo);
    return OLE_ERROR_MEMORY;
}


// SendDevInfo: Sends targetdevice info to the  the object.
// Caches the last targetdevice info sent to the object.
// If the targetdevice block is same as the one in the
// cache, then no targetdevice info is sent.
// (!!! There might be some problem here getting back
// the same global handle).

void INTERNAL    SendDevInfo (
    LPCLIENT    lpclient,
    LPSTR       lppropname
){
    HANDLE      hclinfo  = NULL;
    PCLINFO    pclinfo = NULL;
    HANDLE      hdata;
    OLESTATUS   retval;
    HWND        hwnd;
    LPDOC       lpdoc;



    lpdoc = (LPDOC)GetWindowLongPtr (GetParent (lpclient->hwnd), 0);

    // find if any StdTargetDeviceInfo item is present at all
    hwnd = SearchItem (lpdoc, (LPSTR)ULongToPtr(MAKELONG(STDTARGETDEVICE, 0)));
    if (hwnd == NULL)
        return;

    hclinfo = GetProp(hwnd, lppropname);

    // This client has not set any target device info. no need to send
    // any stdtargetdevice info
    if (hclinfo != NULL) {
        if (!(pclinfo = (PCLINFO)LocalLock (hclinfo)))
            goto end;

        // if we cached it, do not send it again.
        if ((!pclinfo->bnewDevInfo) && pclinfo->hdevInfo == lpclient->hdevInfo)
            goto end;

        pclinfo->bnewDevInfo = FALSE;
        if(!(hdata = DuplicateData (pclinfo->hdevInfo)))
            goto end;
    } else {

        // already screen
        if (!lpclient->hdevInfo)
            goto end;

        //for screen send NULL.
        hdata = NULL;
    }


    // Now send the targetdevice info
#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBECT")
        else if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->SetTargetDevice,
                "Invalid pointer to SetTargetDevice method")
#endif
    retval = (*lpclient->lpoleobject->lpvtbl->SetTargetDevice)
                    (lpclient->lpoleobject, hdata);

    if (retval == OLE_OK) {
        if (pclinfo)
            lpclient->hdevInfo = pclinfo->hdevInfo;
        else
            lpclient->hdevInfo = NULL;

    }
    // !!! error case who frees the data?'

end:
    if (pclinfo)
        LocalUnlock (hclinfo);

    return;
}

void ChangeOwner (
    HANDLE hmfp
){
    LPMETAFILEPICT  lpmfp;

#ifdef WIN16
    if (lpmfp = (LPMETAFILEPICT) GlobalLock (hmfp)) {
        if (bWin30)
            GiveToGDI (lpmfp->hMF);
        else {
            if (lpfnSetMetaFileBitsBetter)
                (*lpfnSetMetaFileBitsBetter) (lpmfp->hMF);
        }

        GlobalUnlock (hmfp);
    }
#endif

#ifdef WIN32
    UNREFERENCED_PARAMETER(hmfp);
    UNREFERENCED_PARAMETER(lpmfp);
#endif

}


HANDLE INTERNAL MakeItemData (
    DDEPOKE FAR *   lpPoke,
    HANDLE          hPoke,
    OLECLIPFORMAT   cfFormat
){
    HANDLE  hnew;
    LPSTR   lpnew;
    DWORD   dwSize;

 
    if (cfFormat == CF_ENHMETAFILE)
        return CopyEnhMetaFile (LongToHandle(*(LONG*)lpPoke->Value), NULL);

    if (cfFormat == CF_METAFILEPICT) {
#ifdef _WIN64
        return DuplicateMetaFile(*(void* _unaligned*)lpPoke->Value);
#else
        return DuplicateMetaFile (*(LPHANDLE)lpPoke->Value);
#endif
    }

    if (cfFormat == CF_BITMAP)
        return DuplicateBitmap (LongToHandle(*(LONG*)lpPoke->Value));

    if (cfFormat == CF_DIB)
        return DuplicateData (LongToHandle(*(LONG*)lpPoke->Value));

    // Now we are dealing with normal case
    if (!(dwSize = (DWORD)GlobalSize (hPoke)))
        return NULL;

    dwSize = dwSize - sizeof (DDEPOKE) + sizeof(BYTE);

    if (hnew = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE, dwSize)) {
        if (lpnew = GlobalLock (hnew)) {
            UtilMemCpy (lpnew, (LPSTR) lpPoke->Value, dwSize);
            GlobalUnlock (hnew);
        }
        else {
            GlobalFree (hnew);
            hnew = NULL;
        }
    }

    return hnew;
}



HANDLE INTERNAL DuplicateMetaFile (
    HANDLE hSrcData
){
    LPMETAFILEPICT  lpSrcMfp;
    LPMETAFILEPICT  lpDstMfp = NULL;
    HANDLE          hMF = NULL;
    HANDLE          hDstMfp = NULL;

    if (!(lpSrcMfp = (LPMETAFILEPICT) GlobalLock(hSrcData)))
        return NULL;

    GlobalUnlock (hSrcData);

    if (!(hMF = CopyMetaFile (lpSrcMfp->hMF, NULL)))
        return NULL;

    if (!(hDstMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
        goto errMfp;

    if (!(lpDstMfp = (LPMETAFILEPICT) GlobalLock (hDstMfp)))
        goto errMfp;

    GlobalUnlock (hDstMfp);

    *lpDstMfp = *lpSrcMfp;
    lpDstMfp->hMF = hMF;
    return hDstMfp;
errMfp:
    if (hMF)
        DeleteMetaFile (hMF);

    if (hDstMfp)
        GlobalFree (hDstMfp);

     return NULL;
}



HBITMAP INTERNAL DuplicateBitmap (
    HBITMAP     hold
){
    HBITMAP     hnew;
    HANDLE      hMem;
    LPSTR       lpMem;
    LONG        retVal = TRUE;
    DWORD       dwSize;
    BITMAP      bm;

     // !!! another way to duplicate the bitmap

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) *
             ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, dwSize)))
        return NULL;

    if (!(lpMem = GlobalLock (hMem))){
        GlobalFree (hMem);
        return NULL;
    }

    GetBitmapBits (hold, dwSize, lpMem);
    if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight,
                    bm.bmPlanes, bm.bmBitsPixel, NULL))
        retVal = SetBitmapBits (hnew, dwSize, lpMem);

    GlobalUnlock (hMem);
    GlobalFree (hMem);

    if (hnew && (!retVal)) {
        DeleteObject (hnew);
        hnew = NULL;
    }

    return hnew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\server\srvr.c ===
/****************************** Module Header ******************************\
* Module Name: Srvr.c Server Main module
*
* Purpose: Includes All the server communication related routines.
*
* Created: Oct 1990.
*
* Copyright (c) 1985, 1986, 1987, 1988, 1989  Microsoft Corporation
*
* History:
*    Raor:   Wrote the original version.
*    curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>
#include <shellapi.h>
#include "cmacs.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"

// LOWWORD - BYTE 0 major verision, BYTE1 minor version,
// HIWORD is reserved

#define OLE_VERSION 0x0901L


extern ATOM    aOLE;
extern ATOM    aSysTopic;
extern ATOM    aStdExit;
extern ATOM    aStdCreate;
extern ATOM    aStdOpen;
extern ATOM    aStdEdit;
extern ATOM    aStdCreateFromTemplate;
extern ATOM    aStdShowItem;
extern ATOM    aProtocols;
extern ATOM    aTopics;
extern ATOM    aFormats;
extern ATOM    aStatus;
extern ATOM    cfNative;
extern ATOM    aEditItems;
extern ATOM    aStdClose;


extern HANDLE  hdllInst;

#ifdef WIN16
extern BOOL    bProtMode;
#endif

extern FARPROC lpTerminateClients;

#ifdef FIREWALLS
BOOL    bShowed = FALSE;
void    ShowVersion (void);
#endif


DWORD APIENTRY  OleQueryServerVersion ()
{
    return OLE_VERSION;
}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRegisterServer (lpclass, lpolesrvr, lplhsrvr)
*
* OleRegisterServer: Registers the server with the server library.
*
* Parameters:
*       1. Ptr to the server class.
*       2. Ptr to the olesrvr. This is private to the server app.
*          (Typically this is the ptr to the private storage area of
*           server app server related info).
*       3. Ptr to the LHSRVR. Place where to pass back the long
*          handle of the server in DLL (This is private to the DLL).
*
* return values:
*        returns OLE_OK if the server is successfully registered .
*        else returns the corresponding error.
*
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS APIENTRY  OleRegisterServer (
    LPCSTR          lpclass,            // class name
    LPOLESERVER     lpolesrvr,          // ole srvr(private to srvr app)
    LHSRVR FAR *    lplhsrvr,           // where we pass back our private handle
    HINSTANCE       hInst,
    OLE_SERVER_USE  useFlags
){
    HANDLE  hsrvr  = NULL;
    LPSRVR  lpsrvr = NULL;
    ATOM    aExe = (ATOM)0;

    Puts ("OleRegisterServer");

#ifdef WIN16
    if (!bProtMode)
       return OLE_ERROR_PROTECT_ONLY;
#endif

    PROBE_READ(lpclass);
    PROBE_WRITE(lpolesrvr);
    PROBE_WRITE(lplhsrvr);

    // add the app atom to global list
    if (!ValidateSrvrClass (lpclass, &aExe))
        return OLE_ERROR_CLASS;

    hsrvr = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, sizeof (SRVR));
    if (! (hsrvr && (lpsrvr = (LPSRVR)GlobalLock (hsrvr))))
        goto errReturn;

    // set the signature handle and the app atom.
    lpsrvr->sig[0]      = 'S';
    lpsrvr->sig[1]      = 'R';
    lpsrvr->hsrvr       = hsrvr;
    lpsrvr->aClass      = GlobalAddAtom (lpclass);
    lpsrvr->lpolesrvr   = lpolesrvr;
    lpsrvr->relLock     = TRUE;     // set the release lock.
    lpsrvr->aExe        = aExe;
    lpsrvr->useFlags    = useFlags;

#ifdef   FIREWALLS
    ASSERT ((useFlags == OLE_SERVER_SINGLE  || useFlags == OLE_SERVER_MULTI), "invalid server options");
#endif

    // Create the servre window and do not show it.
    if (!(lpsrvr->hwnd = CreateWindow ("SrvrWndClass", "Srvr",
        WS_OVERLAPPED,0,0,0,0,NULL,NULL, hdllInst, NULL)))
        goto errReturn;

    // save the ptr to the srever struct in the window.
    SetWindowLongPtr (lpsrvr->hwnd, 0, (LONG_PTR)lpsrvr);

    // Set the signature.
    SetWindowWord (lpsrvr->hwnd, WW_LE, WC_LE);
    SetWindowLongPtr (lpsrvr->hwnd, WW_HANDLE, (LONG_PTR)hInst);
    *lplhsrvr = (LONG_PTR)lpsrvr;

    return OLE_OK;

errReturn:
    if (lpsrvr){
        if (lpsrvr->hwnd)
            DestroyWindow (lpsrvr->hwnd);

        if (lpsrvr->aClass)
            GlobalDeleteAtom (lpsrvr->aClass);

        if (lpsrvr->aExe)
            GlobalDeleteAtom (lpsrvr->aExe);

        GlobalUnlock (hsrvr);
    }

    if (hsrvr)
        GlobalFree (hsrvr);

    return OLE_ERROR_MEMORY;

}


// ValidateSrvrClass checks whether the given server class is valid by
// looking in the win.ini.

BOOL INTERNAL ValidateSrvrClass (
    LPCSTR      lpclass,
    ATOM FAR *  lpAtom
){
    char    buf[MAX_STR];
    LONG    cb = MAX_STR;
    char    key[MAX_STR];
    LPSTR   lptmp;
    LPSTR   lpbuf;
    char    ch;

    lstrcpy (key, lpclass);
    lstrcat (key, "\\protocol\\StdFileEditing\\server");

    if (RegQueryValue (HKEY_CLASSES_ROOT, key, buf, &cb))
        return FALSE;

    if (!buf[0])
        return FALSE;

    // Get exe name without path and then get an atom for that

    lptmp = lpbuf = (LPSTR)buf;
    while ((ch = *lptmp++) && ch != '\0') {
        if (ch == '\\' || ch == ':')
            lpbuf = lptmp;
    }
    *lpAtom =  GlobalAddAtom (lpbuf);

    return TRUE;
}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRevokeServer (lhsrvr)
*
* OlerevokeServer: Unregisters the server which has been registered.
*
* Parameters:
*       1. DLL server handle.
*
*
* return values:
*        returns OLE_OK if the server is successfully unregisterd.
*        ( It is Ok for the app free the associated space).
*        If the unregistration is intiated, returns  OLE_STARTED.
*        Calls the Server class release entry point when the server
*        can be released.
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS APIENTRY  OleRevokeServer (
    LHSRVR  lhsrvr
){
    HWND         hwndSrvr;
    LPSRVR       lpsrvr;

    Puts ("OleRevokeServer");

    if (!CheckServer (lpsrvr = (LPSRVR)lhsrvr))
        return OLE_ERROR_HANDLE;

    if (lpsrvr->bTerminate  && lpsrvr->termNo)
        return OLE_WAIT_FOR_RELEASE;

    hwndSrvr = lpsrvr->hwnd;

#ifdef  FIREWALLS
    ASSERT (hwndSrvr, "Illegal server handle ")
#endif

    // Terminate the conversation with all clients.
    // If there are any clients to be terminated
    // return back with OLE_STARTED and srvr relase
    // will be called for releasing the server finally.

    // we are terminating.
    lpsrvr->bTerminate  = TRUE;
    lpsrvr->termNo      = 0;

    // send ack if Revoke is done as a result of StdExit
    if (lpsrvr->fAckExit) {
        LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK, 0x8000, lpsrvr->hDataExit);

        // Post the acknowledge to the client
        if (!PostMessageToClient (lpsrvr->hwndExit, WM_DDE_ACK, (WPARAM)lpsrvr->hwnd,
                            lparamNew))
        {
            // if the window died or post failed, delete the atom.
            GlobalFree (lpsrvr->hDataExit);
            DDEFREE(WM_DDE_ACK,lparamNew);
        }
    }

    // revoks all the documents registered with this server.
    RevokeAllDocs (lpsrvr);

    // enumerate all the clients which are in your list and post the
    // termination.
    EnumProps (hwndSrvr, (PROPENUMPROC)lpTerminateClients);
    // post all the messages with yield which have been collected in enum
    // UnblockPostMsgs (hwndSrvr, TRUE);

    // reset the release lock. Now it is ok to release the server
    // when all the doc clients and server clients have sent back the
    // termination.

    lpsrvr->relLock = FALSE;
    return ReleaseSrvr (lpsrvr);

}


// ReleaseSrvr: Called when ever a matching WM_TERMINATE is received
// from doc clients or the server clients of a particular server.
// If there are no more terminates pending, it is ok to release the server.
// Calls the server app "release" proc for releasing the server.

int INTERNAL    ReleaseSrvr (
    LPSRVR      lpsrvr
){

    HANDLE  hsrvr;


    // release srvr is called only when everything is
    // cleaned and srvr app can post WM_QUIT

    if (lpsrvr->bTerminate){
        // only if we are  revoking server then see whether it is ok to
        // call Release.

        // First check whethere any docs are active.
        // Doc window is a child window for server window.

        if (lpsrvr->termNo || GetWindow (lpsrvr->hwnd, GW_CHILD))
            return OLE_WAIT_FOR_RELEASE;

        // if the block queue is not empty, do not quit
        if (!IsBlockQueueEmpty(lpsrvr->hwnd))
            return OLE_WAIT_FOR_RELEASE;

    }

    if (lpsrvr->relLock)
        return OLE_WAIT_FOR_RELEASE;  // server is locked. So, delay releasing

    // Inform server app it is time to clean up and post WM_QUIT.

#ifdef FIREWALLS
    if (!CheckPointer (lpsrvr->lpolesrvr, WRITE_ACCESS))
        ASSERT(0, "Invalid LPOLESERVER")
    else if (!CheckPointer (lpsrvr->lpolesrvr->lpvtbl, WRITE_ACCESS))
        ASSERT(0, "Invalid LPOLESERVERVTBL")
    else
        ASSERT (lpsrvr->lpolesrvr->lpvtbl->Release,
            "Invalid pointer to Release method")
#endif

    (*lpsrvr->lpolesrvr->lpvtbl->Release)(lpsrvr->lpolesrvr);

    if (lpsrvr->aClass)
        GlobalDeleteAtom (lpsrvr->aClass);
    if (lpsrvr->aExe)
        GlobalDeleteAtom (lpsrvr->aExe);
    DestroyWindow (lpsrvr->hwnd);
    GlobalUnlock (hsrvr = lpsrvr->hsrvr);
    GlobalFree (hsrvr);
    return OLE_OK;
}


//TerminateClients: Call back for the enum properties.

BOOL    FAR PASCAL  TerminateClients (
    HWND    hwnd,
    LPSTR   lpstr,
    HANDLE  hdata
){
    LPSRVR  lpsrvr;

    UNREFERENCED_PARAMETER(lpstr);

    lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);

    // If the client already died, no terminate.
    if (IsWindowValid ((HWND)hdata)) {
        lpsrvr->termNo++;

        // irrespective of the post, incremet the count, so
        // that client does not die.

        PostMessageToClientWithBlock ((HWND)hdata, WM_DDE_TERMINATE,  (WPARAM)hwnd, (LPARAM)0);
    }
    else
        ASSERT (FALSE, "TERMINATE: Client's System chanel is missing");

    return TRUE;
}


LRESULT FAR PASCAL SrvrWndProc (
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
){

    LPSRVR      lpsrvr;
    WORD        status = 0;
    HANDLE      hdata;
    OLESTATUS   retval;

#ifdef FIREWALLS
    HWND        hwndClient;
#endif	
	

    if (AddMessage (hwnd, msg, wParam, lParam, WT_SRVR))
        return 0L;

    lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);


    switch (msg){

       case  WM_TIMER:
            UnblockPostMsgs (hwnd, FALSE);

            // if no more blocked message empty the queue.
            if (IsBlockQueueEmpty (hwnd))
                KillTimer (hwnd, wParam);

            if (lpsrvr->bTerminate && IsBlockQueueEmpty(lpsrvr->hwnd))
                    // Now see wheteher we can release the server .
                    ReleaseSrvr (lpsrvr);
            break;

       case WM_CREATE:
            DEBUG_OUT ("Srvr create window", 0)
            break;

       case WM_DDE_INITIATE:
#ifdef  FIREWALLS
    ASSERT (lpsrvr, "No server window handle in server window");
#endif

            DEBUG_OUT ("Srvr: DDE init",0);
            if (lpsrvr->bTerminate){
                DEBUG_OUT ("Srvr: No action due to termination process",0)
                break;
            }

            // class is not matching, so it is not definitely for us.
            // for apps sending the EXE for initiate, do not allow if the app
            // is mutiple server.

            if (!(lpsrvr->aClass == (ATOM)(LOWORD(lParam)) ||
                  (lpsrvr->aExe == (ATOM)(LOWORD(lParam)) && IsSingleServerInstance ())))

                break;

            if (!HandleInitMsg (lpsrvr, lParam)) {
                if (!(aSysTopic == (ATOM)(HIWORD(lParam)))) {

                    // if the server window is not the right window for
                    // DDE conversation, then try with the doc windows.
                    SendMsgToChildren (hwnd, msg, wParam, lParam);

                }
                break;
            }

            // We can enterain this client. Put him in our client list
            // and acknowledge the intiate.

            if (!AddClient (hwnd, (HWND)wParam, (HWND)wParam))
                break;

            lpsrvr->cClients++;
            lpsrvr->bnoRelease = FALSE;
            // add the atoms and post acknowledge

            DuplicateAtom (LOWORD(lParam));
            DuplicateAtom (HIWORD(lParam));

            SendMessage ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lParam);
            break;

       case WM_DDE_EXECUTE: {
            HANDLE hData = GET_WM_DDE_EXECUTE_HDATA(wParam,lParam);

            DEBUG_OUT ("srvr: execute", 0)

#ifdef  FIREWALLS
            // find the client in the client list.
            ASSERT (lpsrvr, "No server window handle in server window");
            hwndClient = FindClient (lpsrvr->hwnd, (HWND)wParam);
            ASSERT (hwndClient, "Client is missing from the server")
#endif
            // Are we terminating
            if (lpsrvr->bTerminate) {
                DEBUG_OUT ("Srvr: sys execute after terminate posted",0)
                // !!! are we supposed to free the data
                GlobalFree (hData);
                break;
            }


            retval = SrvrExecute (hwnd, hData, (HWND)wParam);
            SET_MSG_STATUS (retval, status)

            if (!lpsrvr->bTerminate) {
                LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,status,hData);

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lparamNew))
                {
                    GlobalFree (hData);
                    DDEFREE(WM_DDE_ACK,lparamNew);
                }
            }

            break;
       }

       case WM_DDE_TERMINATE:
            DEBUG_OUT ("Srvr: DDE terminate",0)

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpsrvr->hwnd, (HWND)wParam);
            ASSERT (hwndClient, "Client is missing from the server")
#endif
            DeleteClient (lpsrvr->hwnd, (HWND)wParam);
            lpsrvr->cClients--;

            if (lpsrvr->bTerminate){
                if ((--lpsrvr->termNo == 0) && (IsBlockQueueEmpty (lpsrvr->hwnd)))
                    // Now see wheteher we can release the server .
                    ReleaseSrvr (lpsrvr);

                    // if we released the server, then
                    // by the time we come here,, we have destroyed the window

            }else {
                // If client intiated the terminate. post matching terminate
                PostMessageToClient ((HWND)wParam, WM_DDE_TERMINATE, (WPARAM)hwnd, (LPARAM)0);

                // callback release tell the srvr app, it can exit if needs.
                // Inform server app it is time to clean up and post WM_QUIT.
                // only if no docs present.
#if 0
                if (lpsrvr->cClients == 0
                        && (GetWindow (lpsrvr->hwnd, GW_CHILD) == NULL)) {
#endif
                if (QueryRelease (lpsrvr)){

#ifdef FIREWALLS
                    if (!CheckPointer (lpsrvr->lpolesrvr, WRITE_ACCESS))
                        ASSERT (0, "Invalid LPOLESERVER")
                    else if (!CheckPointer (lpsrvr->lpolesrvr->lpvtbl,
                                    WRITE_ACCESS))
                        ASSERT (0, "Invalid LPOLESERVERVTBL")
                    else
                        ASSERT (lpsrvr->lpolesrvr->lpvtbl->Release,
                            "Invalid pointer to Release method")
#endif

                    (*lpsrvr->lpolesrvr->lpvtbl->Release) (lpsrvr->lpolesrvr);
                }
            }
            break;


       case WM_DDE_REQUEST: {
            ATOM aItem = GET_WM_DDE_REQUEST_ITEM(wParam,lParam);

            if (lpsrvr->bTerminate || !IsWindowValid ((HWND) wParam))
                goto RequestErr;

            if(RequestDataStd (lParam, (HANDLE FAR *)&hdata) != OLE_OK){
                LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,0x8000, aItem);

                // if request failed, then acknowledge with error.
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd,lparamNew))
                {
                  DDEFREE(WM_DDE_ACK,lparamNew);
RequestErr:
                  if (aItem)
                      GlobalDeleteAtom (aItem);
                }
            } else {  // post the data message and we are not asking for any
                      // acknowledge.
                LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_REQUEST,hdata,aItem);

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_DATA, (WPARAM)hwnd, lparamNew)) {
                    GlobalFree (hdata);
                    DDEFREE(WM_DDE_REQUEST,lparamNew);
                    goto RequestErr;
                }
            }
            break;
       }

       case WM_DESTROY:
            DEBUG_OUT ("Srvr: Destroy window",0)
            break;

       default:
            DEBUG_OUT ("Srvr:  Default message",0)
            return DefWindowProc (hwnd, msg, wParam, lParam);

    }

    return 0L;

}

BOOL    INTERNAL    HandleInitMsg (
    LPSRVR  lpsrvr,
    LPARAM  lParam
){


    // If it is not system or Ole, this is not the server.
    if (!((aSysTopic == (ATOM)(HIWORD(lParam))) ||
            (aOLE == (ATOM)(HIWORD(lParam)))))

        return FALSE;


    // single instance MDI accept
    if (lpsrvr->useFlags == OLE_SERVER_SINGLE)
        return TRUE;


    // this server is multiple instance. So, check for any clients or docs.
    if (!GetWindow (lpsrvr->hwnd, GW_CHILD) && !lpsrvr->cClients)
        return TRUE;

    return FALSE;

}


// AddClient: Adds the client as property to the server
// window. Key is the string generated from the window
// handle and the data is the window itself.


BOOL    INTERNAL AddClient  (
    HWND    hwnd,
    HANDLE  hkey,
    HANDLE  hdata
){
    char    buf[20];

    MapToHexStr ((LPSTR)buf, hkey);
    return SetProp (hwnd, (LPSTR)buf, hdata);

}


//DeleteClient: deletes the client from the server clients list.

BOOL    INTERNAL DeleteClient (
    HWND    hwnd,
    HANDLE  hkey
){
    char    buf[20];

    MapToHexStr ((LPSTR)buf, hkey);
    return (RemoveProp(hwnd, (LPSTR)buf)!= NULL);
}

// FindClient: Finds  whether a given client is
// in the server client list.

HANDLE  INTERNAL FindClient (
    HWND    hwnd,
    HANDLE  hkey
){

    char    buf[20];


    MapToHexStr ((LPSTR)buf, hkey);
    return GetProp (hwnd, (LPSTR)buf);
}



// SrvrExecute: takes care of the WM_DDE_EXEXCUTE for the
// server.


OLESTATUS INTERNAL SrvrExecute (
    HWND      hwnd,
    HANDLE    hdata,
    HWND      hwndClient
){
    ATOM      aCmd;
    BOOL      fActivate;

    LPSTR     lpdata = NULL;
    HANDLE    hdup   = NULL;
    OLESTATUS retval = OLE_ERROR_MEMORY;

    LPSTR     lpdocname;
    LPSTR     lptemplate;

    LPOLESERVERDOC  lpoledoc = NULL;
    LPDOC           lpdoc    = NULL;
    LPSRVR          lpsrvr;
    LPOLESERVER     lpolesrvr;
    LPSTR           lpnextarg;
    LPSTR           lpclassname;
    LPSTR           lpitemname;
    LPSTR           lpopt;
    char            buf[MAX_STR];
    WORD            wCmdType;

    // !!! this code can be lot simplified if we do the argument scanning
    // seperately and return the ptrs to the args. Rewrite later on.

    if (!(hdup = DuplicateData (hdata)))
        goto errRtn;

    if (!(lpdata  = GlobalLock (hdup)))
        goto errRtn;

    DEBUG_OUT (lpdata, 0)

    lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);

#ifdef   FIREWALLS
    ASSERT (lpsrvr, "Srvr: srvr does not exist");
#endif

    lpolesrvr = lpsrvr->lpolesrvr;

#ifdef   FIREWALLS
    ASSERT ((CheckPointer (lpolesrvr, WRITE_ACCESS)),
        "Srvr: lpolesrvr does not exist");
#endif

    if (*lpdata++ != '[') // commands start with the left sqaure bracket
        goto  errRtn;

    retval = OLE_ERROR_SYNTAX;
    // scan upto the first arg
    if (!(wCmdType = ScanCommand (lpdata, WT_SRVR, &lpdocname, &aCmd)))
        goto  errRtn;

    if (wCmdType == NON_OLE_COMMAND) {
        if (!UtilQueryProtocol (lpsrvr->aClass, PROTOCOL_EXECUTE))
            retval = OLE_ERROR_PROTOCOL;
        else {
#ifdef FIREWALLS
            if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
                ASSERT (0, "Invalid LPOLESERVERVTBL")
            else
                ASSERT (lpolesrvr->lpvtbl->Execute,
                    "Invalid pointer to Exit method")
#endif

            retval =  (*lpolesrvr->lpvtbl->Execute) (lpolesrvr, hdata);
        }

        goto errRtn1;
    }

    if (aCmd == aStdExit){
        if (*lpdocname)
            goto errRtn1;

#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->Exit, "Invalid pointer to Exit method")
#endif
        lpsrvr->fAckExit  = TRUE;
        lpsrvr->hwndExit  = hwndClient;
        lpsrvr->hDataExit = hdata;
        retval = (*lpolesrvr->lpvtbl->Exit) (lpolesrvr);
        lpsrvr->fAckExit = FALSE;
        goto end2;
    }

    // scan the next argument.
    if (!(lpnextarg = ScanArg(lpdocname)))
        goto errRtn;

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdShowItem("docname", "itemname"[, "true"])]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdShowItem) {

        // first find the documnet. If the doc does not exist, then
        // blow it off.

        if (!(lpdoc = FindDoc (lpsrvr, lpdocname)))
            goto errRtn1;

        lpitemname = lpnextarg;

        if( !(lpopt = ScanArg(lpitemname)))
            goto errRtn1;

        // scan for the optional parameter
        // Optional can be only TRUE or FALSE.

        fActivate = FALSE;
        if (*lpopt) {

            if( !(lpnextarg = ScanBoolArg (lpopt, (BOOL FAR *)&fActivate)))
                goto errRtn1;

            if (*lpnextarg)
                goto errRtn1;

        }


        // scan it. But, igonre the arg.
        retval = DocShowItem (lpdoc, lpitemname, !fActivate);
        goto end2;



    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdCloseDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdClose) {
        if (!(lpdoc = FindDoc (lpsrvr, lpdocname)))
            goto errRtn1;

        if (*lpnextarg)
            goto errRtn1;


#ifdef FIREWALLS
        if (!CheckPointer (lpdoc->lpoledoc, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOC")
        else if (!CheckPointer (lpdoc->lpoledoc->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
        else
            ASSERT (lpdoc->lpoledoc->lpvtbl->Close,
                "Invalid pointer to Close method")
#endif

        retval = (*lpdoc->lpoledoc->lpvtbl->Close)(lpdoc->lpoledoc);
        goto end2;
    }


    if (aCmd == aStdOpen) {
        // find if any document is already open.
        // if the doc is open, then no need to call srvr app.
        if (FindDoc (lpsrvr, lpdocname)){
            retval = OLE_OK;
            goto end1;

        }
    }

    if (aCmd == aStdCreate || aCmd == aStdCreateFromTemplate) {
        lpclassname = lpdocname;
        lpdocname   = lpnextarg;
        if( !(lpnextarg = ScanArg(lpdocname)))
            goto errRtn1;

    }

    // check whether we can create/open more than one doc.

    if ((lpsrvr->useFlags == OLE_SERVER_MULTI) &&
            GetWindow (lpsrvr->hwnd, GW_CHILD))
            goto errRtn;



    // No Doc. register the document. lpoledoc is being probed
    // for validity. So, pass some writeable ptr. It is not
    // being used to access anything yet

    if (OleRegisterServerDoc ((LHSRVR)lpsrvr, lpdocname,
        (LPOLESERVERDOC)NULL, (LHDOC FAR *)&lpdoc))
            goto errRtn;

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdOpenDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    // Documnet does not exit.

    if(aCmd == aStdOpen) {

#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->Open, "Invalid pointer to Open method")
#endif

        retval = (*lpolesrvr->lpvtbl->Open)(lpolesrvr, (LHDOC)lpdoc,
                lpdocname, (LPOLESERVERDOC FAR *) &lpoledoc);
        goto end;
    }
    else {
        lpdoc->fEmbed = TRUE;
    }



    //////////////////////////////////////////////////////////////////////////
    //
    // [StdNewDocument ("classname", "docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdCreate) {
#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->Create,
                "Invalid pointer to Create method")
#endif
        retval =  (*lpolesrvr->lpvtbl->Create) (lpolesrvr, (LHDOC)lpdoc,
                                    lpclassname, lpdocname,
                                    (LPOLESERVERDOC FAR *) &lpoledoc);

        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdEditDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////
    if (aCmd == aStdEdit){

        GlobalGetAtomName (lpsrvr->aClass, (LPSTR)buf, MAX_STR);

#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->Edit, "Invalid pointer to Edit method")
#endif

        retval = (*lpolesrvr->lpvtbl->Edit) (lpolesrvr, (LHDOC)lpdoc,
                                (LPSTR)buf, lpdocname,
                                (LPOLESERVERDOC FAR *) &lpoledoc);
        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdNewFormTemplate ("classname", "docname". "templatename)]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdCreateFromTemplate){
        lptemplate = lpnextarg;
        if(!(lpnextarg = ScanArg(lpnextarg)))
            goto errRtn;

#ifdef FIREWALLS
        if (!CheckPointer (lpolesrvr->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERVTBL")
        else
            ASSERT (lpolesrvr->lpvtbl->CreateFromTemplate,
                "Invalid pointer to CreateFromTemplate method")
#endif
        retval = (*lpolesrvr->lpvtbl->CreateFromTemplate)(lpolesrvr,
             (LHDOC)lpdoc, lpclassname, lpdocname, lptemplate,
             (LPOLESERVERDOC FAR *) &lpoledoc);

        goto end;

    }


    DEBUG_OUT ("Unknown command", 0);

end:

    if (retval != OLE_OK)
        goto errRtn;

    // Successful execute. remember the server app private doc handle here.

    lpdoc->lpoledoc = lpoledoc;

end1:
    // make sure that the srg string is indeed terminated by
    // NULL.
    if (*lpnextarg)
        retval = OLE_ERROR_SYNTAX;

errRtn:

   if ( retval != OLE_OK){
        // delete the oledoc structure
        if (lpdoc)
            OleRevokeServerDoc ((LHDOC)lpdoc);
   }

end2:
errRtn1:

   if (lpdata)
        GlobalUnlock (hdup);

   if (hdup)
        GlobalFree (hdup);

   if (retval == OLE_OK)
        lpsrvr->bnoRelease = TRUE;

   return retval;
}




void SendMsgToChildren (
    HWND   hwnd,
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
){

    hwnd = GetWindow(hwnd, GW_CHILD);
    while (hwnd) {
        SendMessage (hwnd, msg, wParam, lParam);
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
}


OLESTATUS INTERNAL   RequestDataStd (
    LPARAM      lparam,
    LPHANDLE    lphdde
){

    char    buf[MAX_STR];
    ATOM    item;
    HANDLE  hnew = NULL;

    if (!(item =  (ATOM)(HIWORD (lparam))))
        goto errRtn;

    GlobalGetAtomName (item, (LPSTR)buf, MAX_STR);

    if (item == aEditItems){
        hnew = MakeGlobal ((LPSTR)"StdHostNames\tStdDocDimensions\tStdTargetDevice");
        goto   PostData;

    }

    if (item == aProtocols) {
        hnew = MakeGlobal ((LPSTR)"Embedding\tStdFileEditing");
        goto   PostData;
    }

    if (item == aTopics) {
        hnew = MakeGlobal ((LPSTR)"Doc");
        goto   PostData;
    }

    if (item == aFormats) {
        hnew = MakeGlobal ((LPSTR)"Picture\tBitmap");
        goto   PostData;
    }

    if (item == aStatus) {
        hnew = MakeGlobal ((LPSTR)"Ready");
        goto   PostData;
    }

    // format we do not understand.
    goto errRtn;

PostData:

    // Duplicate the DDE data
    if (MakeDDEData (hnew, CF_TEXT, lphdde, TRUE)){
        // !!! why are we duplicating the atom.
        DuplicateAtom ((ATOM)(HIWORD (lparam)));
        return OLE_OK;
    }
errRtn:
    return OLE_ERROR_MEMORY;
}


BOOL INTERNAL QueryRelease (
    LPSRVR  lpsrvr
){

    HWND    hwnd;
    LPDOC   lpdoc;


    // Incase the terminate is called immediately after
    // the Std at sys level clear this.

    if (lpsrvr->bnoRelease) {
        lpsrvr->bnoRelease = FALSE;
        return FALSE;
    }


    if (lpsrvr->cClients)
        return FALSE;

    hwnd = GetWindow (lpsrvr->hwnd, GW_CHILD);

    // if either the server or the doc has any clients
    // return FALSE;

    while (hwnd){
        lpdoc = (LPDOC)GetWindowLongPtr (hwnd, 0);
        if (lpdoc->cClients)
            return FALSE;

        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    return TRUE;

}


//IsSingleServerInstance: returns true if the app is single server app else
//false.

BOOL    INTERNAL  IsSingleServerInstance ()
{
    HWND    hwnd;
    WORD    cnt = 0;
    HANDLE  hTask;
    char    buf[MAX_STR];


    hwnd  = GetWindow (GetDesktopWindow(), GW_CHILD);
#ifdef WIN16
    hTask = GetCurrentTask();
#else //NT
    hTask = (HANDLE)ULongToPtr(GetCurrentThreadId());
#endif

    while (hwnd) {
        if (hTask == GetWindowTask (hwnd)) {
            GetClassName (hwnd, (LPSTR)buf, MAX_STR);
            if (lstrcmp ((LPSTR)buf, SRVR_CLASS) == 0)
                cnt++;
        }
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
#ifdef  FIREWALLS
     ASSERT (cnt > 0, "srvr window instance count is zero");
#endif
    if (cnt == 1)
        return TRUE;
    else
        return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\server\doc.c ===
/****************************** Module Header ******************************\
* Module Name: Doc.c Document Main module
*
* Purpose: Includes All the document communication related routines.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*    curts created portable version for WIN16/32
*
\***************************************************************************/

#include "windows.h"
#include "cmacs.h"
#include "ole.h"
#include "dde.h"
#include "srvr.h"


extern  ATOM     cfBinary;
extern  ATOM     aStdClose;
extern  ATOM     aStdShowItem;
extern  ATOM     aStdDoVerbItem;
extern  ATOM     aStdDocName;
extern  ATOM     aTrue;
extern  ATOM     aFalse;

extern  FARPROC  lpTerminateDocClients;
extern  FARPROC  lpSendRenameMsg;
extern  FARPROC  lpFindItemWnd;
extern  FARPROC  lpEnumForTerminate;

extern  HANDLE   hdllInst;
extern  HANDLE   hddeRename;
extern  HWND     hwndRename;


extern  BOOL     fAdviseSaveDoc;

// ### Do we have to create a seperate window for each doc conversation.
// EDF thinks so.

/***************************** Public  Function ****************************\
*
* OLESTATUS FAR PASCAL  OleRegisterServerDoc (lhsrvr, lpdocname, lpoledoc, lplhdoc)
*
* OleRegisterServerDoc: Registers the Document with the server lib.
*
* Parameters:
*       1. Server long handle(server with which the document should
*          be registered)
*       2. Document name.
*       3. Handle to the doc of the server app (private to the server app).
*       4. Ptr for returning the Doc handle of the lib (private to the lib).
*
* return values:
*        returns OLE_OK if the server is successfully registered .
*        else returns the corresponding error.
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRegisterServerDoc (
    LHSRVR          lhsrvr,    // handle we passed back as part of registration.
    LPCSTR          lpdocname, // document name
    LPOLESERVERDOC  lpoledoc,  // Private doc handle of the server app.
    LHDOC FAR *     lplhdoc    // where we will be passing our doc private handle
){

    LPSRVR  lpsrvr = NULL;
    LPDOC   lpdoc  = NULL;
    HANDLE  hdoc   = NULL;


    Puts ("OleRegisterServerDoc");

    if (!CheckServer (lpsrvr = (LPSRVR)lhsrvr))
        return OLE_ERROR_HANDLE;

    // server's termination has already started.
    if (lpsrvr->bTerminate)
        return OLE_ERROR_TERMINATE;

    PROBE_READ(lpdocname);
    PROBE_WRITE(lplhdoc);

    // we are using the null from inside the server lib
    if (lpoledoc)
        PROBE_WRITE(lpoledoc);

    hdoc = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_DDESHARE, sizeof (DOC));

    if (!(hdoc && (lpdoc = (LPDOC)GlobalLock (hdoc))))
        goto errReturn;

    // set the signature, handle and the doc atom.
    lpdoc->sig[0]   = 'S';
    lpdoc->sig[1]   = 'D';
    lpdoc->hdoc     = hdoc;
    lpdoc->aDoc     = GlobalAddAtom (lpdocname);
    lpdoc->lpoledoc = lpoledoc;


    if (!(lpdoc->hwnd = CreateWindow ("DocWndClass", "Doc",
        WS_CHILD,0,0,0,0,lpsrvr->hwnd,NULL, hdllInst, NULL)))
        goto errReturn;

    // save the ptr to the struct in the window.
    SetWindowLongPtr (lpdoc->hwnd, 0, (LONG_PTR)lpdoc);
    SetWindowWord (lpdoc->hwnd, WW_LE, WC_LE);
    SetWindowLongPtr (lpdoc->hwnd, WW_HANDLE, GetWindowLongPtr(lpsrvr->hwnd, WW_HANDLE));
    *lplhdoc = (LONG_PTR)lpdoc;

    return OLE_OK;

errReturn:
    if (lpdoc){
        if (lpdoc->hwnd)
            DestroyWindow (lpsrvr->hwnd);

        if (lpdoc->aDoc)
            GlobalDeleteAtom (lpdoc->aDoc);

        GlobalUnlock(hdoc);
    }

    if (hdoc)
        GlobalFree (hdoc);

    return OLE_ERROR_MEMORY;
}


/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRevokeServerDoc (lhdoc)
*
* OleRevokeServerDoc: Unregisters the document which has been registered.
*
* Parameters:
*       1. DLL Doc handle.
*
* return values:
*        returns OLE_OK if the document is successfully unregisterd.
*        ( It is Ok for the app to free the associated space).
*        If the unregistration is intiated, returns  OLE_STARTED.
*        Calls the Doc class release entry point when the doc
*        can be released. App should wait till the Release is called
*
* History:
*   Raor:   Wrote it,
\***************************************************************************/

OLESTATUS  FAR PASCAL  OleRevokeServerDoc (
    LHDOC   lhdoc
){
    HWND    hwndSrvr;
    LPSRVR  lpsrvr;
    HWND    hwndDoc;
    LPDOC   lpdoc;

    Puts ("OleRevokeServerDoc");

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    if (lpdoc->bTerminate  && lpdoc->termNo)
        return OLE_WAIT_FOR_RELEASE;

    // ### this code is very similar to the srvr code.
    // we should optimize.

    hwndDoc = lpdoc->hwnd;

#ifdef  FIREWALLS
    ASSERT (hwndDoc, "No doc window")
#endif

    hwndSrvr = GetParent (hwndDoc);
    lpsrvr = (LPSRVR) GetWindowLongPtr (hwndSrvr, 0);
#ifdef  FIREWALLS
    ASSERT (hwndSrvr, "No srvr window")
    ASSERT (lpsrvr, "No srvr structure")
#endif

    // delete all the items(objects) for this doc
    DeleteAllItems (lpdoc->hwnd);

    // we are terminating.
    lpdoc->bTerminate = TRUE;
    lpdoc->termNo = 0;

    // send ack if Revoke is done as a result of StdClose
    if (lpdoc->fAckClose) {  // Post the acknowledge to the client
        LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK, 0x8000, lpdoc->hDataClose);

        if (!PostMessageToClient (lpdoc->hwndClose, WM_DDE_ACK, (WPARAM)lpdoc->hwnd,lparamNew))
        {
            // if the window died or post failed, delete the atom.
            GlobalFree (lpdoc->hDataClose);
            DDEFREE(WM_DDE_ACK,lparamNew);
        }
    }

    // Post termination for each of the doc clients.
    EnumProps(hwndDoc, (PROPENUMPROC)lpTerminateDocClients);
    // post all the messages with yield which have been collected in enum
    // UnblockPostMsgs (hwndDoc, TRUE);

#ifdef  WAIT_DDE
    if (lpdoc->termNo)
        WaitForTerminate((LPSRVR)lpdoc);
#endif

    return ReleaseDoc (lpdoc);
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRenameServerDoc (lhdoc, lpNewName)
*
* OleRenameServerDoc: Changes the name of the document
*
* Parameters:
*       1. DLL Doc handle.
*       2. New name for document
*
* return values:
*        returns OLE_OK if the document is successfully renamed
*
* History:
*   Srinik:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRenameServerDoc (
    LHDOC   lhdoc,
    LPCSTR  lpNewName
){
    LPDOC       lpdoc;
    OLESTATUS   retVal = OLE_OK;
    HANDLE      hdata;
    HWND        hStdWnd;

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    PROBE_READ(lpNewName);

    if (!(hdata = MakeGlobal (lpNewName)))
        return OLE_ERROR_MEMORY;

    if (lpdoc->aDoc)
        GlobalDeleteAtom (lpdoc->aDoc);
    lpdoc->aDoc = GlobalAddAtom (lpNewName);

    // if StdDocName item is present send rename to relevant clients
    if (hStdWnd = SearchItem (lpdoc, (LPSTR) MAKEINTATOM(aStdDocName))) {
        if (!MakeDDEData (hdata, cfBinary, (LPHANDLE)&hddeRename,FALSE))
            retVal = OLE_ERROR_MEMORY;
        else {
            EnumProps(hStdWnd, (PROPENUMPROC)lpSendRenameMsg);
            // post all the messages with yield which have been collected in enum
            // UnblockPostMsgs (hStdWnd, FALSE);
            GlobalFree (hddeRename);

        }
    }


    hwndRename = hStdWnd;
    // Post termination for each of the doc clients.
    EnumProps(lpdoc->hwnd, (PROPENUMPROC)lpEnumForTerminate);
    // post all the messages with yield which have been collected in enum
    // UnblockPostMsgs (lpdoc->hwnd, TRUE);

    // If it was an embedded object, from now on it won't be
    lpdoc->fEmbed = FALSE;

    if (!hStdWnd || retVal != OLE_OK)
        GlobalFree(hdata);

    // Do link manager stuff
    return retVal;
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleSavedServerDoc (lhdoc)
*
* OleSavedServerDoc: Changes the name of the document
*
* Parameters:
*       1. DLL Doc handle.
*
* return values:
*        returns OLE_OK if the link manager is successfully notified
*
* History:
*   Srinik:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleSavedServerDoc (
    LHDOC   lhdoc
){
    LPDOC   lpdoc;

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    fAdviseSaveDoc = TRUE;
    EnumChildWindows (lpdoc->hwnd, (WNDENUMPROC)lpFindItemWnd,
        MAKELONG (NULL, ITEM_SAVED));

    if (lpdoc->fEmbed && !fAdviseSaveDoc)
        return OLE_ERROR_CANT_UPDATE_CLIENT;

    return OLE_OK;
}




/***************************** Public  Function ****************************\
* OLESTATUS FAR PASCAL  OleRevertServerDoc (lhdoc)
*
* OleRevertServerDoc: Changes the name of the document
*
* Parameters:
*       1. DLL Doc handle.
*
* return values:
*        returns OLE_OK if the link manager has been successfully informed
*
* History:
*   Srinik:   Wrote it,
\***************************************************************************/

OLESTATUS FAR PASCAL  OleRevertServerDoc (
    LHDOC   lhdoc
){
    LPDOC   lpdoc;

    if (!CheckServerDoc (lpdoc = (LPDOC)lhdoc))
        return OLE_ERROR_HANDLE;

    return OLE_OK;
}



// TerminateDocClients: Call back for the document window for
// enumerating all the clients. Posts terminate for each of
// the clients.

BOOL    FAR PASCAL  TerminateDocClients (
    HWND    hwnd,
    LPSTR   lpstr,
    HANDLE  hdata
){
    LPDOC   lpdoc;

    UNREFERENCED_PARAMETER(lpstr);

    lpdoc = (LPDOC)GetWindowLongPtr (hwnd, 0);
    if (IsWindowValid ((HWND)hdata)){
        lpdoc->termNo++;
        // irrespective of the post, incremet the count, so
        // that client does not die.
        PostMessageToClientWithBlock ((HWND)hdata, WM_DDE_TERMINATE,  (WPARAM)hwnd, (LPARAM)0);
    }
    else
        ASSERT(FALSE, "TERMINATE: Client's Doc channel is missing");
    return TRUE;
}


// ReleaseDoc: If there are no more matching terminates pending
// Call the server for its release. (Server might be waiting for the
// docs to be terminated. Called thru OleRevokeServer).


int INTERNAL    ReleaseDoc (
    LPDOC      lpdoc
){
    HWND        hwndSrvr;
    HANDLE      hdoc;
    LPSRVR      lpsrvr;


    // release srvr is called only when everything is
    // cleaned and srvr app can post WM_QUIT.

    if (lpdoc->bTerminate  && lpdoc->termNo)
        return OLE_WAIT_FOR_RELEASE;

    // Call Release for the app to release its space.


    if (lpdoc->lpoledoc){

#ifdef FIREWALLS
    if (!CheckPointer (lpdoc->lpoledoc, WRITE_ACCESS))
        ASSERT (0, "Invalid LPOLESERVERDOC")
    else if (!CheckPointer (lpdoc->lpoledoc->lpvtbl, WRITE_ACCESS))
        ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
    else
        ASSERT (lpdoc->lpoledoc->lpvtbl->Release,
            "Invalid pointer to Release method")
#endif
        (*lpdoc->lpoledoc->lpvtbl->Release) (lpdoc->lpoledoc);

    }

    if (lpdoc->aDoc) {
        GlobalDeleteAtom (lpdoc->aDoc);
        lpdoc->aDoc = (ATOM)0;
    }

    hwndSrvr = GetParent (lpdoc->hwnd);
    DestroyWindow (lpdoc->hwnd);

    lpsrvr = (LPSRVR)GetWindowLongPtr (hwndSrvr, 0);

    // if the server is waiting for us, inform the server
    // we are done
    if (!lpsrvr->bTerminate) {
        // if we are not in terminate mode, then send advise to the server
        // if server can be revoked. raor (04/09)

        if (QueryRelease (lpsrvr)){

#ifdef FIREWALLS
            if (!CheckPointer (lpsrvr->lpolesrvr, WRITE_ACCESS))
                ASSERT (0, "Invalid LPOLESERVER")
            else if (!CheckPointer (lpsrvr->lpolesrvr->lpvtbl,
                            WRITE_ACCESS))
                ASSERT (0, "Invalid LPOLESERVERVTBL")
            else
                ASSERT (lpsrvr->lpolesrvr->lpvtbl->Release,
                    "Invalid pointer to Release method")
#endif

            (*lpsrvr->lpolesrvr->lpvtbl->Release) (lpsrvr->lpolesrvr);
        }

    } else
        ReleaseSrvr (lpsrvr);

    GlobalUnlock (hdoc = lpdoc->hdoc);
    GlobalFree (hdoc);

    return OLE_OK;
}


//RevokeAllDocs : revokes all the documents attached to a given
//server.

int INTERNAL RevokeAllDocs (
    LPSRVR  lpsrvr
){

    HWND    hwnd;
    HWND    hwndnext;

    hwnd = GetWindow (lpsrvr->hwnd, GW_CHILD);

    // Go thru each of the child windows and revoke the corresponding
    // document. Doc windows are child windows for the server window.

    while (hwnd){
        // sequence is important
        hwndnext = GetWindow (hwnd, GW_HWNDNEXT);
        OleRevokeServerDoc ((LHDOC)GetWindowLongPtr (hwnd, 0));
        hwnd =  hwndnext;
    }
    return OLE_OK;
}



// FindDoc: Given a document, searches for the document
// in the given server document tree. returns true if the
// document is available.


LPDOC INTERNAL FindDoc (
    LPSRVR  lpsrvr,
    LPSTR   lpdocname
){
    ATOM    aDoc;
    HWND    hwnd;
    LPDOC   lpdoc;

    aDoc = (ATOM)GlobalFindAtom (lpdocname);
    hwnd = GetWindow (lpsrvr->hwnd, GW_CHILD);

    while (hwnd){
        lpdoc = (LPDOC)GetWindowLongPtr (hwnd, 0);
        if (lpdoc->aDoc == aDoc)
            return lpdoc;
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    return NULL;
}



// DocWndProc: document window procedure.
// ### We might be able to merge this code with
// the server window proc.


LRESULT FAR PASCAL DocWndProc (
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
){
    LPDOC       lpdoc;
    WORD        status = 0;
    BOOL	fack;
    HANDLE      hdata  = NULL;
    OLESTATUS   retval;
    LPSRVR      lpsrvr;

#ifdef FIREWALLS
    HWND        hwndClient;
#endif	

    if (AddMessage (hwnd, msg, wParam, lParam, (int)WT_DOC))
        return 0L;

    lpdoc = (LPDOC)GetWindowLongPtr (hwnd, 0);

    switch (msg){


       case WM_CREATE:
            DEBUG_OUT ("doc create window", 0)
            break;

       case WM_DDE_INITIATE:

            DEBUG_OUT ("doc: DDE init",0);
            if (lpdoc->bTerminate){
                DEBUG_OUT ("doc: No action due to termination process",0)
                break;
            }

            // if we are the documnet then respond.

            if (! (lpdoc->aDoc == (ATOM)(HIWORD(lParam))))
                break;

            // We can enterain this client. Put this window in the client list
            // and acknowledge the initiate.

            if (!AddClient (hwnd, (HWND)wParam, (HWND)wParam))
                break;

            lpdoc->cClients++;
            lpsrvr = (LPSRVR) GetWindowLongPtr (GetParent(lpdoc->hwnd), 0);

            lpsrvr->bnoRelease = FALSE;

            // post the acknowledge
            DuplicateAtom (LOWORD(lParam));
            DuplicateAtom (HIWORD(lParam));
            SendMessage ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lParam);

            break;

       case WM_DDE_EXECUTE: {

            HANDLE hData = GET_WM_DDE_EXECUTE_HDATA(wParam,lParam);

            DEBUG_OUT ("doc: execute", 0)
#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpdoc->hwnd, (HWND)wParam);
            ASSERT (hwndClient, "Client is missing from the server")
#endif
            // Are we terminating
            if (lpdoc->bTerminate || !IsWindowValid  ((HWND)wParam)) {
                DEBUG_OUT ("doc: execute after terminate posted",0)
                // !!! are we supposed to free the data
                GlobalFree (hData);
                break;

            }

            retval = DocExecute (hwnd, hData, (HWND)wParam);
            SET_MSG_STATUS (retval, status);

#ifdef OLD
            // if we posted the terminate because of execute, do not send
            // ack.

            if (lpdoc->bTerminate) {
                // !!! We got close but, we are posting the
                // the terminate. Excel does not complain about
                // this. But powerpoint complains.
#ifdef  POWERPNT_BUG
                GlobalFree (hData);
#endif
                break;
            }
#endif
            if (!lpdoc->bTerminate) { // Post the acknowledge to the client
                LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK, status, hData);

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lparamNew)){
                    // the window either died or post failed, delete the data
                    GlobalFree (hData);
                    DDEFREE(WM_DDE_ACK,lparamNew);
                }
            }

            break;
       }

       case WM_DDE_TERMINATE:
            DEBUG_OUT ("doc: DDE terminate",0)

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpdoc->hwnd,(HWND)wParam);
            ASSERT(hwndClient || lpdoc->termNo, "Client is missing from the server")
#endif
            // We do not need this client any more. Delete him from the
            // client list.

            DeleteClient (lpdoc->hwnd, (HWND)wParam);
            lpdoc->cClients--;

            if (lpdoc->bTerminate){
                lpsrvr = (LPSRVR) GetWindowLongPtr (GetParent(lpdoc->hwnd), 0);
                if (!--lpdoc->termNo)
                    // Release this Doc and may be the server also
                    // if the server is waiting to be released also.
                    ReleaseDoc (lpdoc);
            } else {
                if (lpdoc->termNo == 0){

                    // If client intiated the terminate. Post matching terminate

                    PostMessageToClient ((HWND)wParam, WM_DDE_TERMINATE,
                                    (WPARAM)hwnd, (LPARAM)0);
                } else
                    lpdoc->termNo--;

                //Client initiated the termination. So, we shoudl take him
                // out from any of our items client lists.
                DeleteFromItemsList (lpdoc->hwnd, (HWND)wParam);

                lpsrvr = (LPSRVR)GetWindowLongPtr (GetParent (lpdoc->hwnd), 0);

                if (QueryRelease (lpsrvr)){

#ifdef FIREWALLS
                    if (!CheckPointer (lpsrvr->lpolesrvr, WRITE_ACCESS))
                        ASSERT (0, "Invalid LPOLESERVER")
                    else if (!CheckPointer (lpsrvr->lpolesrvr->lpvtbl,
                                    WRITE_ACCESS))
                        ASSERT (0, "Invalid LPOLESERVERVTBL")
                    else
                        ASSERT (lpsrvr->lpolesrvr->lpvtbl->Release,
                            "Invalid pointer to Release method")
#endif

                    (*lpsrvr->lpolesrvr->lpvtbl->Release) (lpsrvr->lpolesrvr);
                }

            }
            break;

       case WM_DESTROY:
            DEBUG_OUT ("doc: Destroy window",0)
            break;

       case WM_DDE_POKE: {
            int    iStdItem;
            LPARAM lparamNew;
            ATOM   aItem = GET_WM_DDE_POKE_ITEM(wParam,lParam);
            HANDLE hData = GET_WM_DDE_POKE_HDATA(wParam,lParam);

            DEBUG_OUT ("doc: Poke", 0)

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND) wParam)) {
                // we are getting pke message after we have posted the
                // the termination or the client got deleted.

                /*
                 * This path is valid for POKE, DATA, and ADVISE transactions
                 * only!
                 */
                FreePokeData (GET_WM_DDE_POKE_HDATA(wParam,lParam));
#ifdef OLD
                GlobalFree (GET_WM_DDE_POKE_HDATA(wParam,lParam));
#endif
                // !!! Are we supposed to delete the atoms also.
            PokeErr1:
                /*
                 * This path is valid for POKE, DATA, ADVISE and
                 * ACK transactions only!
                 */
                if (GET_WM_DDE_POKE_ITEM(wParam,lParam))
                    GlobalDeleteAtom (GET_WM_DDE_POKE_ITEM(wParam,lParam));
                DDEFREE(msg,lParam);
                break;

            }

            if (iStdItem = GetStdItemIndex (aItem))
                retval = PokeStdItems (lpdoc, (HWND)wParam, hData, iStdItem);
            else
                retval = PokeData (lpdoc, (HWND)wParam, lParam);

            SET_MSG_STATUS (retval, status);
            // !!! If the fRelease is false and the post fails
            // then we are not freeing the hdata. Are we supposed to
            lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);

            if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd,lparamNew))
            {
                DDEFREE(WM_DDE_ACK,lparamNew);
                goto PokeErr1;
            }

            break;
       }

       case WM_DDE_ADVISE: {
            ATOM   aItem = GET_WM_DDE_ADVISE_ITEM(wParam, lParam);

            DEBUG_OUT ("doc: Advise", 0)

            fack = TRUE;

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND)wParam))
                goto PokeErr1;

            if (IsAdviseStdItems (aItem))
                retval = AdviseStdItems (lpdoc, (HWND)wParam, lParam, (BOOL FAR *)&fack);
            else
                // advise data will not have any OLE_BUSY
                retval = AdviseData (lpdoc, (HWND)wParam, lParam, (BOOL FAR *)&fack);

            SET_MSG_STATUS (retval, status);

            if (fack) {
                LPARAM lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lparamNew))
                {
                     DDEFREE(WM_DDE_ACK,lparamNew);
                     goto PokeErr1;
                }

            }
            else if ((ATOM)(HIWORD (lParam)))
                GlobalDeleteAtom (aItem);

            break;
       }

       case WM_DDE_UNADVISE: {
            LPARAM lparamNew;
            ATOM   aItem = GET_WM_DDE_UNADVISE_ITEM(wParam, lParam);

            DEBUG_OUT ("doc: Unadvise", 0)

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND)wParam)) {
                goto PokeErr1;
            }

            retval = UnAdviseData (lpdoc, (HWND)wParam, lParam);
            SET_MSG_STATUS (retval, status);

            lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,status, aItem);
            if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd,lparamNew))
            {
                DDEFREE(WM_DDE_ACK,lparamNew);
            UnadviseErr:
                /*
                 * This path is valid for UNADVISE and REQUEST transaction only!
                 */
                if (GET_WM_DDE_UNADVISE_ITEM(wParam,lParam))
                    GlobalDeleteAtom (GET_WM_DDE_UNADVISE_ITEM(wParam,lParam));
                DDEFREE(msg,lParam);
                break;
            }

            break;
       }

       case WM_DDE_REQUEST: {
            LPARAM lparamNew;
            ATOM   aItem = GET_WM_DDE_REQUEST_ITEM(wParam,lParam);

            DEBUG_OUT ("doc: Request", 0)

            if (lpdoc->bTerminate || !IsWindowValid  ((HWND) wParam))
                goto UnadviseErr;

            retval = RequestData (lpdoc, (HWND)wParam, lParam, (HANDLE FAR *)&hdata);

            if(retval == OLE_OK) { // post the data message and we are not asking for any
                                   // acknowledge.
                lparamNew = MAKE_DDE_LPARAM(WM_DDE_DATA,hdata,aItem);

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_DATA, (WPARAM)hwnd,
                            lparamNew)) {
                    GlobalFree (hdata);
                    DDEFREE(WM_DDE_DATA,lparamNew);
                    goto UnadviseErr;
                }
                break;
             }

             if (retval == OLE_BUSY)
                status = 0x4000;
             else
                status = 0;

             lparamNew = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);

             // if request failed, then acknowledge with error.
             if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lparamNew))
             {
                 DDEFREE(WM_DDE_ACK,lparamNew);
                 goto UnadviseErr;
             }

             break;
       }

       default:
            DEBUG_OUT("doc:  Default message",0)
            return DefWindowProc (hwnd, msg, wParam, lParam);

    }

    return 0L;

}

//DocExecute: Interprets the execute command for the
//document conversation.


OLESTATUS INTERNAL DocExecute(
    HWND        hwnd,
    HANDLE      hdata,
    HWND        hwndClient
){

    ATOM            acmd;
    BOOL            fShow;
    BOOL            fActivate;

    HANDLE          hdup   = NULL;
    int             retval = OLE_ERROR_MEMORY;
    LPDOC           lpdoc;
    LPOLESERVERDOC  lpoledoc;
    LPCLIENT        lpclient = NULL;

    LPSTR           lpitemname;
    LPSTR           lpopt;
    LPSTR           lpnextarg;
    LPSTR           lpdata = NULL;
    LPSTR           lpverb = NULL;
    UINT            verb;
    WORD            wCmdType;

    // !!!Can we modify the string which has been passed to us
    // rather than duplicating the data. This will get some speed
    // and save some space.

    if(!(hdup = DuplicateData(hdata)))
        goto    errRtn;

    if (!(lpdata  = GlobalLock (hdup)))
        goto    errRtn;

    DEBUG_OUT (lpdata, 0)

    lpdoc = (LPDOC)GetWindowLongPtr (hwnd, 0);

#ifdef   FIREWALLS
    ASSERT (lpdoc, "doc: doc does not exist");
#endif
    lpoledoc = lpdoc->lpoledoc;

    retval = OLE_ERROR_SYNTAX;

    if(*lpdata++ != '[') // commands start with the left sqaure bracket
        goto  errRtn;

    // scan the command and scan upto the first arg.
    if (!(wCmdType = ScanCommand(lpdata, WT_DOC, &lpnextarg, &acmd)))
        goto errRtn;

    if (wCmdType == NON_OLE_COMMAND) {
        LPSRVR  lpsrvr;

        if (lpsrvr =  (LPSRVR) GetWindowLongPtr (GetParent (hwnd), 0)) {
            if (!UtilQueryProtocol (lpsrvr->aClass, PROTOCOL_EXECUTE))
                retval = OLE_ERROR_PROTOCOL;
            else {
#ifdef FIREWALLS
                if (!CheckPointer (lpoledoc, WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLESERVERDOC")
                else if (!CheckPointer (lpoledoc->lpvtbl, WRITE_ACCESS))
                    ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
                else
                    ASSERT (lpoledoc->lpvtbl->Execute,
                        "Invalid pointer to Execute method")
#endif

                retval = (*lpoledoc->lpvtbl->Execute) (lpoledoc, hdata);
            }
        }

        goto errRtn;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // [StdCloseDocument]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd == aStdClose){

        // if not terminated by NULL error
        if (*lpnextarg)
            goto errRtn;

#ifdef FIREWALLS
        if (!CheckPointer (lpoledoc, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOC")
        else if (!CheckPointer (lpoledoc->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLESERVERDOCVTBL")
        else
            ASSERT (lpoledoc->lpvtbl->Close,"Invalid pointer to Close method")
#endif
        lpdoc->fAckClose  = TRUE;
        lpdoc->hwndClose  = hwndClient;
        lpdoc->hDataClose = hdata;
        retval = (*lpoledoc->lpvtbl->Close) (lpoledoc);
        lpdoc->fAckClose  = FALSE;
        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdDoVerbItem("itemname", verb, BOOL, BOOL]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd == aStdDoVerbItem){
        lpitemname = lpnextarg;

        if(!(lpverb = ScanArg(lpnextarg)))
            goto errRtn;


        if(!(lpnextarg = ScanNumArg(lpverb, (LPINT)&verb)))
            goto errRtn;

#ifdef  FIREWALLS
        ASSERT (verb < 9 , "Unexpected verb number");
#endif

        // now scan the show BOOL

        if (!(lpnextarg = ScanBoolArg (lpnextarg, (BOOL FAR *)&fShow)))
            goto errRtn;

        fActivate = FALSE;

        // if activate BOOL is present, scan it.

        if (*lpnextarg) {
            if (!(lpnextarg = ScanBoolArg (lpnextarg, (BOOL FAR *)&fActivate)))
                goto errRtn;
        }

        if (*lpnextarg)
            goto errRtn;


        retval = DocDoVerbItem (lpdoc, lpitemname, verb, fShow, !fActivate);
        goto end;
    }





    //////////////////////////////////////////////////////////////////////////
    //
    // [StdShowItem("itemname"[, "true"])]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd != aStdShowItem)
        goto errRtn;

    lpitemname = lpnextarg;

    if(!(lpopt = ScanArg(lpitemname)))
        goto errRtn;

    // Now scan for optional parameter.

    fActivate = FALSE;

    if (*lpopt) {

        if(!(lpnextarg = ScanBoolArg (lpopt, (BOOL FAR *)&fActivate)))
            goto errRtn;

        if (*lpnextarg)
            goto errRtn;


    }

    retval = DocShowItem (lpdoc, lpitemname, !fActivate);

end:
errRtn:
   if (lpdata)
        GlobalUnlock (hdup);

   if (hdup)
        GlobalFree (hdup);

   return retval;
}

int INTERNAL   DocShowItem (
    LPDOC   lpdoc,
    LPSTR   lpitemname,
    BOOL    fAct
){
    LPCLIENT   lpclient;
    int        retval;

    if ((retval = FindItem (lpdoc, lpitemname, (LPCLIENT FAR *)&lpclient))
           != OLE_OK)
       return retval;

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->Show,
                "Invalid pointer to Show method")
#endif

    // protocol sends false for activating and TRUE for not activating.
    // for api send TRUE for avtivating and FALSE for not activating.

    return (*lpclient->lpoleobject->lpvtbl->Show)(lpclient->lpoleobject, fAct);
}


int INTERNAL   DocDoVerbItem (
    LPDOC   lpdoc,
    LPSTR   lpitemname,
    UINT    verb,
    BOOL    fShow,
    BOOL    fAct
){
    LPCLIENT   lpclient;
    int        retval = OLE_ERROR_PROTOCOL;

    if ((retval = FindItem (lpdoc, lpitemname, (LPCLIENT FAR *)&lpclient))
           != OLE_OK)
       return retval;

#ifdef FIREWALLS
        if (!CheckPointer (lpclient->lpoleobject->lpvtbl, WRITE_ACCESS))
            ASSERT (0, "Invalid LPOLEOBJECTVTBL")
        else
            ASSERT (lpclient->lpoleobject->lpvtbl->DoVerb,
                "Invalid pointer to Run method")
#endif

    // pass TRUE to activate and False not to activate. Differnt from
    // protocol.

    retval = (*lpclient->lpoleobject->lpvtbl->DoVerb)(lpclient->lpoleobject, verb, fShow, fAct);

    return retval;
}



// FreePokeData: Frees the poked dats.
void  INTERNAL FreePokeData (
    HANDLE  hdde
){
    DDEPOKE FAR * lpdde;

    if (hdde) {
        if (lpdde = (DDEPOKE FAR *) GlobalLock (hdde)) {
            if (lpdde->cfFormat == CF_METAFILEPICT)
#ifdef _WIN64
                FreeGDIdata (*(void* _unaligned*)lpdde->Value, lpdde->cfFormat);
#else
                FreeGDIdata (*(LPHANDLE)lpdde->Value, lpdde->cfFormat);
#endif
            else
                FreeGDIdata (LongToHandle(*(LONG*)lpdde->Value), lpdde->cfFormat);
            GlobalUnlock (hdde);
        }

        GlobalFree (hdde);
    }
}



// Returns TRUE if GDI format else returns FALSE

BOOL INTERNAL FreeGDIdata (
    HANDLE          hData,
    OLECLIPFORMAT   cfFormat
){
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpMfp;

        if (lpMfp = (LPMETAFILEPICT) GlobalLock (hData)) {
            GlobalUnlock (hData);
            DeleteMetaFile (lpMfp->hMF);
        }

        GlobalFree (hData);
    }
    else if (cfFormat == CF_BITMAP)
        DeleteObject (hData);
    else if (cfFormat == CF_DIB)
        GlobalFree (hData);
    else if (cfFormat == CF_ENHMETAFILE)
        DeleteEnhMetaFile(hData);
    else
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\server\srvr.h ===
/****************************** Module Header ******************************\
* Module Name: srvr.h
*
* PURPOSE: Private definitions file for server code
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor (../../90,91)  Original
*  curts created portable version for WIN16/32
*
\***************************************************************************/

#include "port1632.h"

#define DEFSTD_ITEM_INDEX   0
#define STDTARGETDEVICE     1
#define STDDOCDIMENSIONS    2
#define STDCOLORSCHEME      3
#define STDHOSTNAMES        4


#define PROTOCOL_EDIT       ((LPSTR)"StdFileEditing")
#define PROTOCOL_EXECUTE    ((LPSTR)"StdExecute")

#define SRVR_CLASS          ((LPSTR)"SrvrWndClass")
#define DOC_CLASS           ((LPSTR)"DocWndClass")
#define ITEM_CLASS          ((LPSTR)"ItemWndClass")


#define   ISATOM(a)     ((a >= 0xC000) && (a <= 0xFFFF))

#define   MAX_STR       124

#define   WW_LPTR       0       // ptr tosrvr/doc/item
#define   WW_HANDLE     WW_LPTR + sizeof(PVOID) // instance handle
#define   WW_LE         WW_HANDLE + sizeof(PVOID) // signature

#define   WC_LE         0x4c45  // LE chars

// If we running under WLO, the HIGHWORD of version number will be >= 0x0A00
#define VER_WLO     0x0A00

extern  WORD CheckPointer (LPVOID, int);

#define READ_ACCESS     0
#define WRITE_ACCESS    1

#define PROBE_READ(lp){\
        if (!CheckPointer((LPVOID)(lp), READ_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define PROBE_WRITE(lp){\
        if (!CheckPointer((LPVOID)(lp), WRITE_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define   OLE_COMMAND       1
#define   NON_OLE_COMMAND   2


#define   WT_SRVR           0       // server window
#define   WT_DOC            1       // document window

#define   PROBE_BLOCK(lpsrvr) {             \
    if (lpsrvr->bBlock)                     \
        return OLE_ERROR_SERVER_BLOCKED;    \
}


#define   SET_MSG_STATUS(retval, status) { \
    if (retval == OLE_OK)                 \
        status |= 0x8000;                  \
    if (retval == OLE_BUSY)                \
        status |= 0x4000;                  \
}


typedef   LHSERVER         LHSRVR;
typedef   LHSERVERDOC       LHDOC;

typedef struct _QUE {       // nodes in Block/Unblock queue
    HWND        hwnd;       //***
    unsigned    msg;        //      window
    WPARAM      wParam;     //      procedure parameters
    LPARAM      lParam;     //***
    HANDLE      hqNext;     // handle to next node
	 int         wType;      // WT_SRVR || WT_DOC
} QUE;

typedef QUE NEAR *  PQUE;
typedef QUE FAR *   LPQUE;


typedef struct _SRVR { /*srvr*/     // private data
    LPOLESERVER     lpolesrvr;          // corresponding server
    char            sig[2];             // signature "SR"
    HANDLE          hsrvr;              // global handle
    ATOM            aClass;             // class atom
    ATOM            aExe;
    HWND            hwnd;               // corresponding window
    BOOL            bTerminate;         // Set if we are terminating.
    int             termNo;             // termination count
    BOOL            relLock;            // ok to release the server.
    BOOL            bnoRelease;         // Block release. call
    OLE_SERVER_USE  useFlags;           // instance usage flags
    int             cClients;           // no of clients;
    BOOL            bBlock;             // blocked if TRUE
    BOOL            bBlockedMsg;        // msg from block queue if TRUE
    HANDLE          hqHead;             // Head and tail of the blocked
    HANDLE          hqTail;             //   messages queue.

    HANDLE          hqPostHead;         // Head and tail of the blocked post msg
    HANDLE          hqPostTail;         // .
    BOOL            fAckExit;
    HWND            hwndExit;
    HANDLE          hDataExit;
} SRVR;

typedef  SRVR FAR   *LPSRVR;


LRESULT FAR  PASCAL DocWndProc (HWND, UINT, WPARAM, LPARAM);
LRESULT FAR  PASCAL ItemWndProc (HWND, UINT, WPARAM, LPARAM);
LRESULT FAR  PASCAL SrvrWndProc (HWND, UINT, WPARAM, LPARAM);
BOOL    FAR  PASCAL TerminateClients (HWND, LPSTR, HANDLE);
void                SendMsgToChildren (HWND, UINT, WPARAM, LPARAM);


OLESTATUS   INTERNAL    RequestDataStd (LPARAM, HANDLE FAR *);
BOOL        INTERNAL    ValidateSrvrClass (LPCSTR, ATOM FAR *);
ATOM        INTERNAL    GetExeAtom (LPSTR);
BOOL        INTERNAL    AddClient (HWND, HANDLE, HANDLE);
BOOL        INTERNAL    DeleteClient (HWND, HANDLE);
HANDLE      INTERNAL    FindClient (HWND, HANDLE);
BOOL        INTERNAL    MakeSrvrStr(LPSTR, int, LPSTR, HANDLE);
int         INTERNAL    RevokeAllDocs (LPSRVR);
int         INTERNAL    ReleaseSrvr (LPSRVR);
void        INTERNAL    WaitForTerminate (LPSRVR);
OLESTATUS   INTERNAL    SrvrExecute (HWND, HANDLE, HWND);
BOOL        INTERNAL    HandleInitMsg (LPSRVR, LPARAM);
BOOL        INTERNAL    QueryRelease (LPSRVR);
BOOL        INTERNAL    IsSingleServerInstance (void);


// doc stuff
typedef struct _DOC { /*doc*/       // private data
    LPOLESERVERDOC  lpoledoc;           // corresponding oledoc
    char            sig[2];             // signature "SD"
    HANDLE          hdoc;               // global handle
    ATOM            aDoc;
    HWND            hwnd;
    BOOL            bTerminate;
    int             termNo;
    int             cClients;           // no of clients;
    BOOL            fEmbed;             // TRUE if embedded document
    BOOL            fAckClose;
    HWND            hwndClose;
    HANDLE          hDataClose;
} DOC;

typedef  DOC  FAR   *LPDOC;


LPDOC       INTERNAL    FindDoc (LPSRVR, LPSTR);
int         INTERNAL    ReleaseDoc (LPDOC);
OLESTATUS   INTERNAL    DocExecute (HWND, HANDLE, HWND);
BOOL        FAR PASCAL  TerminateDocClients (HWND, LPSTR, HANDLE);
int         INTERNAL    DocShowItem (LPDOC, LPSTR, BOOL);
int         INTERNAL    DocDoVerbItem (LPDOC, LPSTR, UINT, BOOL, BOOL);


// client struct definitions.

typedef struct _CLIENT { /*doc*/    // private data
    OLECLIENT   oleClient;          // oleclient structure
    LPOLEOBJECT lpoleobject;        // corresponding oledoc
    HANDLE      hclient;            // global handle
    ATOM        aItem;              // item atom or index for some std items
    HWND        hwnd;               // item window
    HANDLE      hdevInfo;           // latest printer dev info sent
} CLIENT;

typedef  CLIENT FAR   *LPCLIENT;

typedef struct _CLINFO {  /*clInfo*/  // client transaction info
    HWND          hwnd;               // client window handle
    BOOL          bnative;            // doe sthis client require native
    OLECLIPFORMAT format;             // dusplay format
    int           options;            // transaction advise time otipns
    BOOL          bdata;              // need wdat with advise?
    HANDLE        hdevInfo;           // device info handle
    BOOL          bnewDevInfo;        // new device info
} CLINFO;

typedef  CLINFO  *PCLINFO;




BOOL    FAR PASCAL  FindItemWnd (HWND, LONG);
BOOL    FAR PASCAL  SendRenameMsg (HWND, LPSTR, HANDLE);
BOOL    FAR PASCAL  EnumForTerminate (HWND, LPSTR, HANDLE);
BOOL    FAR PASCAL  SendDataMsg(HWND, LPSTR, HANDLE);
BOOL    FAR PASCAL  DeleteClientInfo (HWND, LPSTR, HANDLE);
int     FAR PASCAL  ItemCallBack (LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);

int         INTERNAL    RegisterItem (LHDOC, LPSTR, LPCLIENT FAR *, BOOL);
int         INTERNAL    FindItem (LPDOC, LPSTR, LPCLIENT FAR *);
HWND        INTERNAL    SearchItem (LPDOC, LPSTR);
void        INTERNAL    DeleteFromItemsList (HWND, HWND);
void        INTERNAL    DeleteAllItems (HWND);
OLESTATUS   INTERNAL    PokeData (LPDOC, HWND, LPARAM);
HANDLE      INTERNAL    MakeItemData (DDEPOKE FAR *, HANDLE, OLECLIPFORMAT);
OLESTATUS   INTERNAL    AdviseData (LPDOC, HWND, LPARAM, BOOL FAR *);
OLESTATUS   INTERNAL    AdviseStdItems (LPDOC, HWND, LPARAM, BOOL FAR *);
OLESTATUS   INTERNAL    UnAdviseData (LPDOC, HWND, LPARAM);
OLESTATUS   INTERNAL    RequestData (LPDOC, HWND, LPARAM, HANDLE FAR *);
BOOL        INTERNAL    MakeDDEData (HANDLE, OLECLIPFORMAT, LPHANDLE, BOOL);
HANDLE      INTERNAL    MakeGlobal (LPCSTR);
OLESTATUS   INTERNAL    ScanItemOptions (LPSTR, int far *);
OLESTATUS   INTERNAL    PokeStdItems (LPDOC, HWND, HANDLE, int);
int         INTERNAL    GetStdItemIndex (ATOM);
BOOL        INTERNAL    IsAdviseStdItems (ATOM);
int         INTERNAL    SetStdInfo (LPDOC, HWND, LPSTR, HANDLE);
void        INTERNAL    SendDevInfo (LPCLIENT, LPSTR);
BOOL        INTERNAL    IsFormatAvailable (LPCLIENT, OLECLIPFORMAT);
OLESTATUS   INTERNAL    RevokeObject (LPOLECLIENT, BOOL);


BOOL        INTERNAL    AddMessage (HWND, UINT, WPARAM, LPARAM, int);

#define   ITEM_FIND          1      // find the item
#define   ITEM_DELETECLIENT  2      // delete the client from item clients
#define   ITEM_DELETE        3      // delete th item window itself
#define   ITEM_SAVED         4      // item saved

// host names data structcure
typedef struct _HOSTNAMES {
    WORD    clientNameOffset;
    WORD    documentNameOffset;
    BYTE    data[];
} HOSTNAMES;

typedef HOSTNAMES FAR * LPHOSTNAMES;


// routines in UTILS.C

void    INTERNAL    MapToHexStr (LPSTR, HANDLE);
void    INTERNAL    UtilMemCpy (LPSTR, LPCSTR, DWORD);
HANDLE  INTERNAL    DuplicateData (HANDLE);
LPSTR   INTERNAL    ScanArg(LPSTR);
LPSTR   INTERNAL    ScanBoolArg (LPSTR, BOOL FAR *);
WORD    INTERNAL    ScanCommand(LPSTR, UINT, LPSTR FAR *, ATOM FAR *);
LPSTR   INTERNAL    ScanLastBoolArg (LPSTR);
LPSTR   INTERNAL    ScanNumArg (LPSTR, LPINT);
ATOM    INTERNAL    MakeDataAtom (ATOM, int);
ATOM    INTERNAL    DuplicateAtom (ATOM);
WORD    INTERNAL    StrToInt (LPSTR);
BOOL    INTERNAL    CheckServer (LPSRVR);
BOOL    INTERNAL    CheckServerDoc (LPDOC);
BOOL    INTERNAL    PostMessageToClientWithBlock (HWND, UINT, WPARAM, LPARAM);
BOOL    INTERNAL    PostMessageToClient (HWND, UINT, WPARAM, LPARAM);
BOOL    INTERNAL    IsWindowValid (HWND);
BOOL    INTERNAL    IsOleCommand (ATOM, UINT);
BOOL    INTERNAL    UtilQueryProtocol (ATOM, LPSTR);


// routines for queueing messages and posting them
BOOL INTERNAL  UnblockPostMsgs(HWND, BOOL);
BOOL INTERNAL  BlockPostMsg (HWND, UINT, WPARAM, LPARAM);
BOOL INTERNAL  IsBlockQueueEmpty (HWND);

// routine in GIVE2GDI.ASM
HANDLE  FAR PASCAL   GiveToGDI (HANDLE);


// routine in item.c
HBITMAP INTERNAL DuplicateBitmap (HBITMAP);
HANDLE  INTERNAL DuplicateMetaFile (HANDLE);

// routines in doc.c
void    INTERNAL FreePokeData (HANDLE);
BOOL    INTERNAL FreeGDIdata (HANDLE, OLECLIPFORMAT);

// props stuff
#ifdef WIN16

#define MAKE_DDE_LPARAM(x,y,z) MAKELONG(y,z)

//#define ENUMPROPS EnumProps
//#define REMOVEPROP RemoveProp
//#define GETPROP GetProp
//#define SETPROP SetProp

#endif

#ifdef WIN32

#define MAKE_DDE_LPARAM(x,y,z) PackDDElParam((UINT)x,(UINT_PTR)y,(UINT_PTR)z)

//#define ENUMPROPS OleEnumProps
//#define REMOVEPROP OleRemoveProp
//#define GETPROP OleGetProp
//#define SETPROP OleSetProp

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\server\srvrmain.c ===
/****************************** Module Header ******************************\
* Module Name: Srvrmain.c Server Main module
*
* Purpose: Includes server intialization and termination code.
*
* Created: Oct 1990.
*
* Copyright (c) 1990 - 1992  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*    curts created portable version for WIN16/32
*
\***************************************************************************/

#include "windows.h"
#include "ole.h"
#include "dde.h"
#include "cmacs.h"
#include "srvr.h"

#ifndef WF_WLO
#define WF_WLO  0x8000
#endif

// ordinal number of new Win31 API IsTask
#define ORD_IsTask  320

// ordinal number of new Win31 API SetMetaFileBitsBetter
#define ORD_SetMetaFileBitsBetter   196


#ifdef  FIREWALLS
short   ole_flags;
char    szDebugBuffer[80];
void    SetOleFlags(void);
#endif


// public vars.

// atomes used in the systems
ATOM    aStdExit;                      // "StdExit"
ATOM    aStdCreate;                    // "StdNewDicument"
ATOM    aStdOpen;                      // "StdOpenDocument"
ATOM    aStdEdit;                      // "StdOpenDocument"
ATOM    aStdCreateFromTemplate;        // "StdNewFromTemplate"
ATOM    aStdClose;                     // "StdCloseDocument"
ATOM    aStdShowItem;                  // "StdShowItem"
ATOM    aStdDoVerbItem;                // "StddoVerbItem"
ATOM    aSysTopic;                     // "System"
ATOM    aOLE;                          // "OLE"
ATOM    aStdDocName;                   // "StdDocumentName"

ATOM    cfBinary;                      // "Binary format"
ATOM    cfNative;                      // "NativeFormat"
ATOM    cfLink;                        // "ObjectLink"
ATOM    cfOwnerLink;                   // "Ownerlink"

ATOM    aChange;                       // "Change"
ATOM    aSave;                         // "Save"
ATOM    aClose;                        // "Close"
ATOM    aProtocols;                    // "Protocols"
ATOM    aTopics;                       // "Topics"
ATOM    aFormats;                      // "Formats"
ATOM    aStatus;                       // "Status"
ATOM    aEditItems;                    // "Edit items
ATOM    aTrue;                         // "True"
ATOM    aFalse;                        // "False"





// !!! free the proc instances.
FARPROC lpSendRenameMsg;               // Call back enum props for rename
FARPROC lpSendDataMsg;                 // Call back enum props for data
FARPROC lpFindItemWnd;                 // Callback in enum props of
FARPROC lpItemCallBack;                // CallBack for object
FARPROC lpTerminateClients;            // Callback in Doc enum properties
FARPROC lpTerminateDocClients;         // Callback in Doc enum properties
FARPROC lpDeleteClientInfo;            // proc for deleteing each item client
FARPROC lpEnumForTerminate;            // proc for terminating clients not in rename list

FARPROC lpfnSetMetaFileBitsBetter = NULL;
FARPROC lpfnIsTask = NULL;

HANDLE  hdllInst;

VOID FAR PASCAL WEP(int);

#ifdef WIN16
BOOL    bProtMode;
BOOL    bWLO = FALSE;
BOOL    bWin30 = FALSE;
#pragma alloc_text(WEP_TEXT, WEP)
                                       //DLL entry:
int FAR PASCAL LibMain (
   HANDLE  hInst,
   WORD    wDataSeg,
   WORD    cbHeapSize,
   LPSTR   lpszCmdLine
#endif

#ifdef WIN32                           //WIN32
BOOL LibMain(
   HANDLE hInst,
   ULONG Reason,
   PCONTEXT Context
#endif
){
    WNDCLASS  wc;

    Puts("LibMain");

#ifdef WIN32
    UNREFERENCED_PARAMETER(Context);
    if (Reason == DLL_PROCESS_DETACH)
    {
        WEP(0);
        return TRUE;
    }
    else if (Reason != DLL_PROCESS_ATTACH)
        return TRUE;
#endif

#ifdef  FIREWALLS
    SetOleFlags();
#endif

    hdllInst = hInst;

#ifdef WIN16
    bProtMode = (BOOL) (GetWinFlags() & WF_PMODE & 0x0000FFFF);
    bWLO      = (BOOL) (GetWinFlags() & WF_WLO);
    bWin30    = (!bWLO && ((WORD) GetVersion()) <= 0x0003);
#endif

    // !!! Put all this stuff thru soemkind of table so that we can
    // save code.

    // register all the atoms.
    aStdExit                = GlobalAddAtom ((LPSTR)"StdExit");
    aStdCreate              = GlobalAddAtom ((LPSTR)"StdNewDocument");
    aStdOpen                = GlobalAddAtom ((LPSTR)"StdOpenDocument");
    aStdEdit                = GlobalAddAtom ((LPSTR)"StdEditDocument");
    aStdCreateFromTemplate  = GlobalAddAtom ((LPSTR)"StdNewfromTemplate");

    aStdClose               = GlobalAddAtom ((LPSTR)"StdCloseDocument");
    aStdShowItem            = GlobalAddAtom ((LPSTR)"StdShowItem");
    aStdDoVerbItem          = GlobalAddAtom ((LPSTR)"StdDoVerbItem");
    aSysTopic               = GlobalAddAtom ((LPSTR)"System");
    aOLE                    = GlobalAddAtom ((LPSTR)"OLEsystem");
    aStdDocName             = GlobalAddAtom ((LPSTR)"StdDocumentName");

    aProtocols              = GlobalAddAtom ((LPSTR)"Protocols");
    aTopics                 = GlobalAddAtom ((LPSTR)"Topics");
    aFormats                = GlobalAddAtom ((LPSTR)"Formats");
    aStatus                 = GlobalAddAtom ((LPSTR)"Status");
    aEditItems              = GlobalAddAtom ((LPSTR)"EditEnvItems");

    aTrue                   = GlobalAddAtom ((LPSTR)"True");
    aFalse                  = GlobalAddAtom ((LPSTR)"False");

    aChange                 = GlobalAddAtom ((LPSTR)"Change");
    aSave                   = GlobalAddAtom ((LPSTR)"Save");
    aClose                  = GlobalAddAtom ((LPSTR)"Close");

    // create the proc instances for the required entry pts.
    lpSendRenameMsg         = (FARPROC)MakeProcInstance (SendRenameMsg, hdllInst);
    lpSendDataMsg           = (FARPROC)MakeProcInstance (SendDataMsg, hdllInst);
    lpFindItemWnd           = (FARPROC)MakeProcInstance (FindItemWnd, hdllInst);
    lpItemCallBack          = (FARPROC)MakeProcInstance (ItemCallBack, hdllInst);
    lpTerminateClients      = (FARPROC)MakeProcInstance (TerminateClients, hdllInst);
    lpTerminateDocClients   = (FARPROC)MakeProcInstance (TerminateDocClients, hdllInst);
    lpDeleteClientInfo      = (FARPROC)MakeProcInstance (DeleteClientInfo, hdllInst);
    lpEnumForTerminate      = (FARPROC)MakeProcInstance (EnumForTerminate , hdllInst);

    // register the clipboard formats
    cfNative                = (OLECLIPFORMAT)RegisterClipboardFormat("Native");
    cfBinary                = (OLECLIPFORMAT)RegisterClipboardFormat("Binary");
    cfLink                  = (OLECLIPFORMAT)RegisterClipboardFormat("ObjectLink");
    cfOwnerLink             = (OLECLIPFORMAT)RegisterClipboardFormat("OwnerLink");



    wc.style        = 0;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = sizeof(LONG_PTR) + //Ask for extra space for storing the
                                        //ptr to srvr/doc/iteminfo.
                      sizeof (WORD) +   // for LE chars
                      sizeof (UINT_PTR);    // for keeping the hDLLInst.

    wc.hInstance    = hInst;
    wc.hIcon        = NULL;
    wc.hCursor      = NULL;
    wc.hbrBackground= NULL;
    wc.lpszMenuName =  NULL;


    // Srvr window class
    wc.lpfnWndProc  = SrvrWndProc;
    wc.lpszClassName= SRVR_CLASS;
    if (!RegisterClass(&wc))
         return 0;

    // document window class
    wc.lpfnWndProc = DocWndProc;
    wc.lpszClassName = DOC_CLASS;

    if (!RegisterClass(&wc))
        return 0;

    // Item (object) window class
    wc.lpfnWndProc = ItemWndProc;
    wc.lpszClassName = ITEM_CLASS;

    wc.cbWndExtra   = sizeof(LONG_PTR); // for items do not need extra stuff.
    if (!RegisterClass(&wc))
        return 0;


#ifdef WIN16
    if (!bWin30) {
        HANDLE  hModule;

        if (hModule = GetModuleHandle ("GDI"))
            lpfnSetMetaFileBitsBetter
                = GetProcAddress (hModule,
                        (LPSTR) MAKELONG(ORD_SetMetaFileBitsBetter, 0));

        if (hModule = GetModuleHandle ("KERNEL"))
            lpfnIsTask
                = GetProcAddress (hModule, (LPSTR) MAKELONG(ORD_IsTask, 0));
    }

    if (cbHeapSize != 0)
        UnlockData(0);
#endif

    return 1;
}


VOID APIENTRY WEP (int nParameter)
{

    Puts("LibExit");

#ifdef WIN16
    if (nParameter == WEP_SYSTEM_EXIT)
        DEBUG_OUT ("---L&E DLL EXIT on system exit---",0)

    else {
        if (nParameter == WEP_FREE_DLL)
            DEBUG_OUT ("---L&E DLL EXIT---",0)

        else
            return;
    }
#endif

#ifdef WIN32
    UNREFERENCED_PARAMETER(nParameter);
    DEBUG_OUT ("---L&E DLL EXIT---",0)
#endif

    // free the global atoms.
    if (aStdExit)
        GlobalDeleteAtom (aStdExit);
    if (aStdCreate)
        GlobalDeleteAtom (aStdCreate);
    if (aStdOpen)
        GlobalDeleteAtom (aStdOpen);
    if (aStdEdit)
        GlobalDeleteAtom (aStdEdit);
    if (aStdCreateFromTemplate)
        GlobalDeleteAtom (aStdCreateFromTemplate);
    if (aStdClose)
        GlobalDeleteAtom (aStdClose);
    if (aStdShowItem)
        GlobalDeleteAtom (aStdShowItem);
    if (aStdDoVerbItem)
        GlobalDeleteAtom (aStdDoVerbItem);
    if (aSysTopic)
        GlobalDeleteAtom (aSysTopic);
    if (aOLE)
        GlobalDeleteAtom (aOLE);
    if (aStdDocName)
        GlobalDeleteAtom (aStdDocName);

    if (aProtocols)
        GlobalDeleteAtom (aProtocols);
    if (aTopics)
        GlobalDeleteAtom (aTopics);
    if (aFormats)
        GlobalDeleteAtom (aFormats);
    if (aStatus)
        GlobalDeleteAtom (aStatus);
    if (aEditItems)
        GlobalDeleteAtom (aEditItems);

    if (aTrue)
        GlobalDeleteAtom (aTrue);
    if (aFalse)
        GlobalDeleteAtom (aFalse);

    if (aChange)
        GlobalDeleteAtom (aChange);
    if (aSave)
        GlobalDeleteAtom (aSave);
    if (aClose)
        GlobalDeleteAtom (aClose);

    // !!! for some reason these FreeprocInstances are crashing the system.
#if 0
    FreeProcInstance (lpSendRenameMsg);
    FreeProcInstance (lpSendDataMsg);
    FreeProcInstance (lpFindItemWnd);
    FreeProcInstance (lpItemCallBack);
    FreeProcInstance (lpTerminateClients);
    FreeProcInstance (lpTerminateDocClients);
    FreeProcInstance (lpDeleteClientInfo);
    FreeProcInstance (EnumForTerminate);
#endif

}



#ifdef  FIREWALLS
void SetOleFlags()
{

    char    buffer[80];

    if(GetProfileString ("OleDll",
        "Puts","", (LPSTR)buffer, 80))
        ole_flags = DEBUG_PUTS;
    else
        ole_flags = 0;


    if(GetProfileString ("OleDll",
        "DEBUG_OUT","", (LPSTR)buffer, 80))
        ole_flags |= DEBUG_DEBUG_OUT;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\apm\apmbatt\i386\apmbatt.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ApmBatt.c

Abstract:

    Control Method Battery Miniport Driver - Wacked to work on APM.

Author:

    Bryan Willman
    Ron Mosgrove (Intel)

Environment:

    Kernel mode

Revision History:

--*/

#include "ApmBattp.h"
#include "ntddk.h"
#include "ntapm.h"


ULONG       ApmBattDebug     = APMBATT_ERROR;
//ULONG       ApmBattDebug     = -1;

//
// Prototypes
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

NTSTATUS
ApmBattOpenClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ApmBattIoctl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );


//
// Globals.  Globals are a little odd in a device driver,
// but this is an odd driver
//

//
// Vector used to call NtApm.sys (our PDO) and ask about
// current battery status
//
ULONG (*NtApmGetBatteryLevel)() = NULL;

//
// APM event notifications and SET_POWER ops will cause
// this value to be incremented.
//
ULONG   TagValue = 1;

//
// If somebody tries to claim there is more than 1 APM driver battery
// in the system, somebody somewhere is very confused.  So keep track
// and forbig this.
//
ULONG   DeviceCount = 0;

//
//
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,ApmBattQueryTag)
#pragma alloc_text(PAGE,ApmBattQueryInformation)
#pragma alloc_text(PAGE,ApmBattQueryStatus)
#pragma alloc_text(PAGE,ApmBattSetStatusNotify)
#pragma alloc_text(PAGE,ApmBattDisableStatusNotify)
#pragma alloc_text(PAGE,ApmBattOpenClose)
#pragma alloc_text(PAGE,ApmBattIoctl)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    This routine initializes the ACPI Embedded Controller Driver

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the Unicode name of the registry path
        for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    ApmBattPrint (APMBATT_TRACE, ("ApmBatt DriverEntry - Obj (%08x) Path (%08x)\n",
                                 DriverObject, RegistryPath));
    //
    // Set up the device driver entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = ApmBattIoctl;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = ApmBattOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = ApmBattOpenClose;

    DriverObject->MajorFunction[IRP_MJ_POWER]           = ApmBattPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = ApmBattPnpDispatch;
    DriverObject->DriverExtension->AddDevice            = ApmBattAddDevice;

    return STATUS_SUCCESS;

}


NTSTATUS
ApmBattOpenClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This is the routine called as a result of a Open or Close on the device

Arguments:


    DeviceObject    - Battery for request
    Irp             - IO request

Return Value:

    STATUS_SUCCESS - no way to fail this puppy

--*/
{
    PAGED_CODE();

    ApmBattPrint (APMBATT_TRACE, ("ApmBattOpenClose\n"));

    //
    // Complete the request and return status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}



NTSTATUS
ApmBattIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    IOCTL handler.  As this is an exclusive battery device, send the
    Irp to the battery class driver to handle battery IOCTLs.

Arguments:

    DeviceObject    - Battery for request
    Irp             - IO request

Return Value:

    Status of request

--*/
{
    NTSTATUS        Status;
    PCM_BATT        ApmBatt;


    PAGED_CODE();

    ApmBattPrint (APMBATT_TRACE, ("ApmBattIoctl\n"));

    ApmBatt = (PCM_BATT) DeviceObject->DeviceExtension;
    Status = BatteryClassIoctl (ApmBatt->Class, Irp);

    if (Status == STATUS_NOT_SUPPORTED) {
        //
        // Not for the battery, complete it
        //

        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
    }

    return Status;
}



NTSTATUS
ApmBattQueryTag (
    IN  PVOID       Context,
    OUT PULONG      TagPtr
    )
/*++

Routine Description:

    BATTERY CLASS ENTRY

    Called by the class driver to retrieve the batteries current tag value

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    TagPtr          - Pointer to return current tag

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    ULONG   BatteryLevel;
    UNREFERENCED_PARAMETER(Context);
    PAGED_CODE();
    ApmBattPrint ((APMBATT_TRACE | APMBATT_MINI),
                 ("ApmBattQueryTag - TagValue = %08x\n", TagValue));
    //
    // The code that catches APM event notification, and the code
    // that handles Power IRPs, will both increment the tag.
    // We simply report that.
    //

    *TagPtr = TagValue;

    //
    // Call ntapm, it will return a DWORD with the relevent data in it,
    // crack this DWORD, and fill this stuff in.
    //
    if (NtApmGetBatteryLevel) {
        BatteryLevel = NtApmGetBatteryLevel();
        if ((BatteryLevel & NTAPM_NO_BATT) || (BatteryLevel & NTAPM_NO_SYS_BATT)) {
            return STATUS_NO_SUCH_DEVICE;
        } else {
            return STATUS_SUCCESS;
        }
    } else {
        //
        // if we cannot get battery status, it's likely we don't have
        // a battery, so say we don't have one.
        //
        return STATUS_NO_SUCH_DEVICE;
    }
}



NTSTATUS
ApmBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN ULONG                            AtRate OPTIONAL,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    )
/*++

Routine Description:

    BATTERY CLASS ENTRY

    Called by the class driver to retrieve battery information

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

    We return invalid parameter when we can't handle a request for a
    specific level of information.  This is defined in the battery class spec.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    Level           - type of information required
    AtRate          - Used only when Level==BatteryEstimatedTime
    Buffer          - Location for the information
    BufferLength    - Length in bytes of the buffer
    ReturnedLength  - Length in bytes of the returned data

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    NTSTATUS                Status;
    PVOID                   ReturnBuffer;
    ULONG                   ReturnBufferLength;
    ULONG                   CapabilityVector = (BATTERY_SYSTEM_BATTERY | BATTERY_CAPACITY_RELATIVE);
    BATTERY_INFORMATION     bi;


    PAGED_CODE();

    ApmBattPrint ((APMBATT_TRACE | APMBATT_MINI),
                 ("ApmBattQueryInformation Level=%08xl\n", Level));

    //
    // We cannot tell (reliably/safely) if there is a battery
    // present or not, so always return what the query code tells us
    //

    ReturnBuffer = NULL;
    ReturnBufferLength = 0;
    Status = STATUS_SUCCESS;

    //
    // Get the info requested
    //

    switch (Level) {
        case BatteryInformation:
            ApmBattPrint((APMBATT_TRACE|APMBATT_MINI), ("Batteryinformation\n"));
            RtlZeroMemory(&bi, sizeof(bi));
            bi.Capabilities = CapabilityVector;
            bi.Technology = BATTERY_SECONDARY_CHARGABLE;
            bi.DesignedCapacity = 100;
            bi.FullChargedCapacity = UNKNOWN_CAPACITY;
            ReturnBuffer = (PVOID) &bi;
            ReturnBufferLength = sizeof(bi);
            break;

        case BatteryEstimatedTime:
        case BatteryTemperature:
        case BatteryGranularityInformation:
        case BatteryDeviceName:
        case BatteryManufactureDate:
        case BatteryManufactureName:
        case BatteryUniqueID:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        default:
            Status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Done, return buffer if needed
    //
    *ReturnedLength = ReturnBufferLength;
    if (BufferLength < ReturnBufferLength) {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    if (NT_SUCCESS(Status) && ReturnBuffer) {
        RtlZeroMemory (Buffer, BufferLength);                       // Clear entire user buffer
        RtlCopyMemory (Buffer, ReturnBuffer, ReturnBufferLength);   // Copy what's needed
    }
    return Status;
}



NTSTATUS
ApmBattQueryStatus (
    IN PVOID            Context,
    IN ULONG            BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
    )
/*++

Routine Description:

    BATTERY CLASS ENTRY

    Called by the class driver to retrieve the batteries current status

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    BatteryStatus   - Pointer to structure to return the current battery status

Return Value:

    Success if there is a battery currently installed, else no such device.

--*/
{
    ULONG   BatteryLevel;

    PAGED_CODE();

    ApmBattPrint ((APMBATT_TRACE | APMBATT_MINI), ("ApmBattQueryStatus\n"));

    //
    // Call ntapm, it will return a DWORD with the relevent data in it,
    // crack this DWORD, and fill this stuff in.
    //
    if (NtApmGetBatteryLevel) {
        BatteryLevel = NtApmGetBatteryLevel();
        BatteryStatus->PowerState = ((BatteryLevel & NTAPM_BATTERY_STATE) >> NTAPM_BATTERY_STATE_SHIFT);
        BatteryStatus->Capacity = BatteryLevel & NTAPM_POWER_PERCENT;
        BatteryStatus->Voltage = UNKNOWN_VOLTAGE;
        BatteryStatus->Current = UNKNOWN_RATE;

        ApmBattPrint((APMBATT_MINI), ("ApmBattQueryStatus: BatteryLevel = %08lx\n", BatteryLevel));

        return STATUS_SUCCESS;

    } else {
        ApmBattPrint((APMBATT_ERROR), ("ApmBattQueryStatus: failure NtApmGetBatteryLevel == NULL\n"));
        //
        // return some "safe" values to keep from looping forever
        //
        BatteryStatus->PowerState = 0;
        BatteryStatus->Capacity = 1;
        BatteryStatus->Voltage = UNKNOWN_VOLTAGE;
        BatteryStatus->Current = UNKNOWN_RATE;
        return STATUS_UNSUCCESSFUL;
    }
}



NTSTATUS
ApmBattSetStatusNotify (
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN PBATTERY_NOTIFY Notify
    )
/*++

Routine Description:

    BATTERY CLASS ENTRY

    Called by the class driver to set the batteries current notification
    setting.  When the battery trips the notification, one call to
    BatteryClassStatusNotify is issued.   If an error is returned, the
    class driver will poll the battery status - primarily for capacity
    changes.  Which is to say the miniport should still issue BatteryClass-
    StatusNotify whenever the power state changes.

    The class driver will always set the notification level it needs
    after each call to BatteryClassStatusNotify.

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery
    BatteryTag      - Tag of current battery
    BatteryNotify   - The notification setting

Return Value:

    Status

--*/
{
    //
    // need to fill this in
    //
    ApmBattPrint (APMBATT_TRACE, ("ApmBattSetStatusNotify\n"));
    return STATUS_NOT_IMPLEMENTED;
}



NTSTATUS
ApmBattDisableStatusNotify (
    IN PVOID Context
    )
/*++

Routine Description:

    BATTERY CLASS ENTRY

    Called by the class driver to disable the notification setting
    for the battery supplied by Context.  Note, to disable a setting
    does not require the battery tag.   Any notification is to be
    masked off until a subsequent call to ApmBattSetStatusNotify.

    The battery class driver will serialize all requests it issues to
    the miniport for a given battery.

Arguments:

    Context         - Miniport context value for battery

Return Value:

    Status

--*/
{
    //
    // need to fill this in
    //
    ApmBattPrint (APMBATT_TRACE, ("ApmBattDisableStatusNotify\n"));
    return STATUS_NOT_IMPLEMENTED;
}

VOID
ApmBattPowerNotifyHandler (
    )
/*++

Routine Description:

    NTAPM CALLBACK

    This routine fields power device notifications from the APM driver.

Arguments:


Return Value:

    None

--*/
{
    ApmBattPrint (APMBATT_TRACE, ("ApmBattPowerNotifyHandler\n"));
//    DbgBreakPoint();
    TagValue++;
    BatteryClassStatusNotify(ApmGlobalClass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\winole\server\utils.c ===
/****************************** Module Header ******************************\
* Module Name: utils.c
*
* Purpose: Conatains all the utility routines
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik (../../1990)    Designed and coded
*   curts created portable version for WIN16/32
*
\***************************************************************************/

#include <windows.h>
#include "cmacs.h"
#include <shellapi.h>

#include "ole.h"
#include "dde.h"
#include "srvr.h"

#define KB_64   65536

extern ATOM    aTrue;
extern ATOM    aFalse;
#ifdef WIN16
extern BOOL    bWLO;
extern BOOL    bWin30;
#endif

extern ATOM    aStdCreateFromTemplate;
extern ATOM    aStdCreate;
extern ATOM    aStdOpen;
extern ATOM    aStdEdit;
extern ATOM    aStdShowItem;
extern ATOM    aStdClose;
extern ATOM    aStdExit;
extern ATOM    aStdDoVerbItem;

extern BOOL (FAR PASCAL *lpfnIsTask) (HANDLE);

// MapToHexStr: Converts  WORD to hex string.
void INTERNAL MapToHexStr (
    LPSTR       lpbuf,
    HANDLE      hdata
){
    int     i;
    char    ch;

    *lpbuf++ = '@';
    for ( i = sizeof(HANDLE)*2 - 1; i >= 0; i--) {

	ch = (char) ((((DWORD_PTR)hdata) >> (i * 4)) & 0x0000000f);
	if(ch > '9')
	    ch += 'A' - 10;
	else
	    ch += '0';

	*lpbuf++ = ch;
    }

    *lpbuf++ = '\0';

}


void INTERNAL UtilMemCpy (
    LPSTR   lpdst,
    LPCSTR  lpsrc,
    DWORD   dwCount
){
    UINT HUGE_T * hpdst;
    UINT HUGE_T * hpsrc;
    UINT FAR  * lpwDst;
    UINT FAR  * lpwSrc;
    DWORD       words;
    DWORD       bytes;

    bytes = dwCount %  MAPVALUE(2,4);
    words = dwCount >> MAPVALUE(1,2); //* we compare DWORDS
				      //* in the 32 bit version
#ifdef WIN16
    if (dwCount <= KB_64) {
	lpwDst = (WORD FAR *) lpdst;
	lpwSrc = (WORD FAR *) lpsrc;
	
	while (words--)
	    *lpwDst++ = *lpwSrc++;

	if (bytes)
	    * (char FAR *) lpwDst = * (char FAR *) lpwSrc;
    }
    else
#else
    UNREFERENCED_PARAMETER(lpwDst);
    UNREFERENCED_PARAMETER(lpwSrc);
#endif
    {
	hpdst = (UINT HUGE_T *) lpdst;
	hpsrc = (UINT HUGE_T *) lpsrc;

	for(;words--;)
	    *hpdst++ = *hpsrc++;
			
	lpdst = (LPSTR) hpdst;
	lpsrc = (LPSTR) hpsrc;

	for(;bytes--;)
	    *lpdst++ = *lpsrc++;
    }
}


//DuplicateData: Duplicates a given Global data handle.
HANDLE  INTERNAL    DuplicateData (
    HANDLE  hdata
){
    LPSTR   lpsrc = NULL;
    LPSTR   lpdst = NULL;
    HANDLE  hdup  = NULL;
    DWORD   size;
    BOOL    err   = TRUE;

    if(!(lpsrc =  GlobalLock (hdata)))
	return NULL;

    DEBUG_OUT (lpsrc, 0)

    hdup = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE, (size = (DWORD)GlobalSize(hdata)));

    if(!(lpdst =  GlobalLock (hdup)))
	goto errRtn;;

    err = FALSE;
    UtilMemCpy (lpdst, lpsrc, size);

errRtn:
    if(lpsrc)
	GlobalUnlock (hdata);

    if(lpdst)
	GlobalUnlock (hdup);

    if (err && hdup)
	GlobalFree (hdup);

    return hdup;
}


//ScanBoolArg: scans the argument which is not included in
//the quotes. These args could be only TRUE or FALSE for
//the time being. !!!The scanning routines should be
//merged and it should be generalized.

LPSTR   INTERNAL    ScanBoolArg (
    LPSTR   lpstr,
    BOOL    FAR *lpflag
){
    LPSTR   lpbool;
    ATOM    aShow;
    char    ch;

    lpbool = lpstr;

    // !!! These routines does not take care of quoted quotes.

    while((ch = *lpstr) && (!(ch == ')' || ch == ',')))
	lpstr++;

    if (ch == '\0')
       return NULL;

    *lpstr++ = '\0';       // terminate the arg by null

    // if terminated by paren, then check for end of command
    // syntax.

    // Check for the end of the command string.
    if (ch == ')') {
	if (*lpstr++ != ']')
	    return NULL;

	if (*lpstr != '\0')
	    return NULL;             //finally should be terminated by null.

    }

    aShow = GlobalFindAtom (lpbool);
    if (aShow == aTrue)
	*lpflag = TRUE;

    else {
	if (aShow ==aFalse)
	    *lpflag = FALSE;
	else
	    return NULL;;
    }
    return lpstr;
}




//ScannumArg: Checks for the syntax of num arg in Execute and if
//the arg is syntactically correct, returns the ptr to the
//beginning of the next arg and also, returns the number
//Does not take care of the last num arg in the list.

LPSTR INTERNAL ScanNumArg (
    LPSTR   lpstr,
    LPINT   lpnum
){
    WORD    val = 0;
    char    ch;

    while((ch = *lpstr++) && (ch != ',')) {
	if (ch < '0' || ch >'9')
	    return NULL;
	val += val * 10 + (ch - '0');

    }

    if(!ch)
       return NULL;

    *lpnum = val;
    return lpstr;
}




//ScanArg: Checks for the syntax of arg in Execute and if
//the arg is syntactically correct, returns the ptr to the
//beginning of the next arg or to the end of the excute string.

LPSTR INTERNAL ScanArg (
    LPSTR   lpstr
){


    // !!! These routines does not take care of quoted quotes.

    // first char should be quote.

    if (*(lpstr-1) != '\"')
	return NULL;

    while(*lpstr && *lpstr != '\"')
	lpstr++;

    if(*lpstr == '\0')
       return NULL;

    *lpstr++ = '\0';       // terminate the arg by null

    if(!(*lpstr == ',' || *lpstr == ')'))
	return NULL;


    if(*lpstr++ == ','){

	if(*lpstr == '\"')
	    return ++lpstr;
	// If it is not quote, leave the ptr on the first char
	return lpstr;
    }

    // terminated by paren
    // already skiped right paren

    // Check for the end of the command string.
    if (*lpstr++ != ']')
	return NULL;

    if(*lpstr != '\0')
	return NULL;             //finally should be terminated by null.

    return lpstr;
}

// ScanCommand: scanns the command string for the syntax
// correctness. If syntactically correct, returns the ptr
// to the first arg or to the end of the string.

WORD INTERNAL  ScanCommand (
    LPSTR       lpstr,
    UINT        wType,
    LPSTR FAR * lplpnextcmd,
    ATOM FAR *  lpAtom
){
    // !!! These routines does not take care of quoted quotes.
    // and not taking care of blanks arround the operators

    // !!! We are not allowing blanks after operators.
    // Should be allright! since this is arestricted syntax.

    char    ch;
    LPSTR   lptemp = lpstr;


    while(*lpstr && (!(*lpstr == '(' || *lpstr == ']')))
	lpstr++;

    if(*lpstr == '\0')
       return 0;

    ch = *lpstr;
    *lpstr++ = '\0';       // set the end of command

    *lpAtom = GlobalFindAtom (lptemp);

    if (!IsOleCommand (*lpAtom, wType))
	return NON_OLE_COMMAND;

    if (ch == '(') {
	ch = *lpstr++;

	if (ch == ')') {
	     if (*lpstr++ != ']')
		return 0;
	}
	else {
	    if (ch != '\"')
		return 0;
	}
	
	*lplpnextcmd = lpstr;
	return OLE_COMMAND;
    }

    // terminated by ']'

    if (*(*lplpnextcmd = lpstr)) // if no nul termination, then it is error.
	return 0;

    return OLE_COMMAND;
}


//MakeDataAtom: Creates a data atom from the item string
//and the item data otions.

ATOM INTERNAL MakeDataAtom (
    ATOM    aItem,
    int     options
){
    char    buf[MAX_STR];

    if (options == OLE_CHANGED)
	return DuplicateAtom (aItem);

    if (!aItem)
	buf[0] = '\0';
    else
	GlobalGetAtomName (aItem, (LPSTR)buf, MAX_STR);

    if (options == OLE_CLOSED)
	lstrcat ((LPSTR)buf, (LPSTR) "/Close");
    else {
	if (options == OLE_SAVED)
	   lstrcat ((LPSTR)buf, (LPSTR) "/Save");
    }

    if (buf[0])
	return GlobalAddAtom ((LPSTR)buf);
    else
	return (ATOM)0;
}

//DuplicateAtom: Duplicates an atom
ATOM INTERNAL DuplicateAtom (
    ATOM    atom
){
    char buf[MAX_STR];

    Puts ("DuplicateAtom");

    if (!atom)
	return (ATOM)0;

    GlobalGetAtomName (atom, buf, MAX_STR);
    return GlobalAddAtom (buf);
}

// MakeGlobal: makes global out of strings.
// works only for << 64k

HANDLE  INTERNAL MakeGlobal (
    LPCSTR  lpstr
){

    int     len = 0;
    HANDLE  hdata  = NULL;
    LPSTR   lpdata = NULL;

    len = lstrlen (lpstr) + 1;

    hdata = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE, len);
    if (hdata == NULL || (lpdata = (LPSTR) GlobalLock (hdata)) == NULL)
	goto errRtn;


    UtilMemCpy (lpdata, lpstr, (DWORD)len);
    GlobalUnlock (hdata);
    return hdata;

errRtn:

    if (lpdata)
	GlobalUnlock (hdata);


    if (hdata)
	GlobalFree (hdata);

     return NULL;

}



BOOL INTERNAL CheckServer (
    LPSRVR  lpsrvr
){
    if (!CheckPointer(lpsrvr, WRITE_ACCESS))
	return FALSE;

    if ((lpsrvr->sig[0] == 'S') && (lpsrvr->sig[1] == 'R'))
	return TRUE;

    return FALSE;
}


BOOL INTERNAL CheckServerDoc (
    LPDOC   lpdoc
){
    if (!CheckPointer(lpdoc, WRITE_ACCESS))
	return FALSE;

    if ((lpdoc->sig[0] == 'S') && (lpdoc->sig[1] == 'D'))
	return TRUE;

    return FALSE;
}


BOOL INTERNAL PostMessageToClientWithBlock (
    HWND    hWnd,
    UINT    wMsg,
    WPARAM  wParam,
    LPARAM  lParam
){

    if (!IsWindowValid (hWnd)){
	ASSERT(FALSE, "Client's window is missing");
	return FALSE;
    }

    if (IsBlockQueueEmpty ((HWND)wParam) && PostMessage (hWnd, wMsg, wParam, lParam))
	return TRUE;

    BlockPostMsg (hWnd, wMsg, wParam, lParam);
    return TRUE;
}



BOOL INTERNAL PostMessageToClient (
    HWND    hWnd,
    UINT    wMsg,
    WPARAM  wParam,
    LPARAM  lParam
){
    if (!IsWindowValid (hWnd)){
	ASSERT(FALSE, "Client's window is missing");
	return FALSE;
    }


    if (IsBlockQueueEmpty ((HWND)wParam) && PostMessage (hWnd, wMsg, wParam, lParam))
	return TRUE;

    BlockPostMsg (hWnd, wMsg, wParam, lParam);
    return TRUE;
}


BOOL    INTERNAL IsWindowValid (
    HWND    hwnd
){

#define TASK_OFFSET 0x00FA

    LPSTR   lptask;
    HANDLE  htask;

    if (!IsWindow (hwnd))
	return FALSE;

#ifdef WIN32
   UNREFERENCED_PARAMETER(lptask);
   UNREFERENCED_PARAMETER(htask);
   return TRUE;//HACK
#endif

#ifdef WIN16
    if (bWLO)
	return TRUE;

    // now get the task handle and find out it is valid.
    htask  = GetWindowTask (hwnd);

    if (bWin30 || !lpfnIsTask) {
	lptask = (LPSTR)(MAKELONG (TASK_OFFSET, htask));

	if (!CheckPointer(lptask, READ_ACCESS))
	    return FALSE;

	// now check for the signature bytes of task block in kernel
	if (*lptask++ == 'T' && *lptask == 'D')
	    return TRUE;
    }
    else {
	// From win31 onwards the API IsTask() can be used for task validation
	if ((*lpfnIsTask)(htask))
	    return TRUE;
    }
#endif

    return FALSE;
}



BOOL INTERNAL UtilQueryProtocol (
    ATOM    aClass,
    LPSTR   lpprotocol
){
    HKEY    hKey;
    char    key[MAX_STR];
    char    class[MAX_STR];

    if (!aClass)
	return FALSE;

    if (!GlobalGetAtomName (aClass, class, MAX_STR))
	return FALSE;

    lstrcpy (key, class);
    lstrcat (key, "\\protocol\\");
    lstrcat (key, lpprotocol);
    lstrcat (key, "\\server");

    if (RegOpenKey (HKEY_CLASSES_ROOT, key, &hKey))
	return FALSE;

    RegCloseKey (hKey);
    return TRUE;
}


BOOL INTERNAL IsOleCommand (
    ATOM    aCmd,
    UINT    wType
){
    if (wType == WT_SRVR) {
	if ((aCmd == aStdCreateFromTemplate)
		|| (aCmd == aStdCreate)
		|| (aCmd == aStdOpen)
		|| (aCmd == aStdEdit)
		|| (aCmd == aStdShowItem)
		|| (aCmd == aStdClose)
		|| (aCmd == aStdExit))
	    return TRUE;
    }
    else {
	if ((aCmd == aStdClose)
		|| (aCmd == aStdDoVerbItem)
		|| (aCmd == aStdShowItem))
	    return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\developer\anvil.inc ===
######################################################################
!IF 0

Copyright (c) 2000-2001  Microsoft Corporation.  All Rights Reserved.

Module Name:
    Anvil.inc

Abstract:
    Settings common to the Anvil project.

History:
    21 Mar 2000  SEdmison  Created.

!ENDIF
######################################################################

############################################################
#
# The major component here is Anvil for all subcomponents.
#
############################################################
MAJORCOMP=Anvil


############################################################
#
# Default package dependencies
#
############################################################

#
# Library dependencies
#
!undef CRTLIBS
#undef USE_LIBCMT
!undef USE_MSVCRT
!undef USE_CRTDLL
!undef USE_NTDLL
USE_NOLIBS=1
USE_LIBCMT=1
USE_STL=1
NO_NTDLL=1

#
# Language features
#
USE_RTTI=1
USE_NATIVE_EH=1

#
# Build options
#
!undef USE_INCREMENTAL_COMPILING
BROWSER_INFO=1

#
# Debug info
#
NTDEBUG=ntsd
NTDEBUGTYPE=both
USE_PDB=1
USE_PDB_TO_COMPILE=1
USE_MAPSYM=1


############################################################
#
# Default build flags
#
############################################################

#
# Predefined macros
#
C_DEFINES=$(C_DEFINES) -U_MAC -DANVIL -DANVIL_WINAPP /DWIN32 /DCRTAPI1=_cdecl /DCRTAPI2=_cdecl


#
# Debug flags
#
!if !$(FREEBUILD)
MKTYPLIB_FLAGS  = $(MKTYPLIB_FLAGS) -DDEBUG
C_DEFINES       = $(C_DEFINES) -DDEBUG
DEBUG_CRTS=1
!endif


#
# Default calling convention
#
386_STDCALL=0


#
# Compiler flags and warning levels
#
USER_C_FLAGS=$(USER_C_FLAGS) /MTd

MSC_WARNING_LEVEL=/W3
MSC_CALL_TYPE=/Gd
COMPILER_WARNINGS=-FIWarning.h


#
# Linker flags
#
LINKER_FLAGS = $(LINKER_FLAGS) /NOD

!if $(FREEBUILD)
LINKER_FLAGS = $(LINKER_FLAGS) /OPT:REF
!else
LINKER_FLAGS = $(LINKER_FLAGS) /DEBUG
!endif


############################################################
#
# Paths and locations
#
############################################################

#
# Top-level Anvil project location
#
ANV_PROJ_DIR = $(BASEDIR)\Base\testsrc\Win32\Fusion\Anvil

#
# Location of Anvil version-stamping tool
#
!if "$(PROCESSOR_ARCHITECTURE)"=="x86"
ANV_MAKEVER_DIR = $(ANV_PROJ_DIR)\Utility\MakeVer\$(_OBJ_DIR)\i386
!else
ANV_MAKEVER_DIR = $(ANV_PROJ_DIR)\Utility\MakeVer\$(_OBJ_DIR)\IA64
!endif


############################################################
#
# Anvil version.
#
############################################################
ANV_VERSION_MAJOR=1
ANV_VERSION_MINOR=1


############################################################
#
# Default includes
#
############################################################

INCLUDES=\
         $(ANV_PROJ_DIR)\Core\Inc;                    \
         $(BASEDIR)\Enduser\VC_Binaries\Headers\CRT;  \
         $(BASEDIR)\Public\SDK\Inc;                   \
         $(ANV_PROJ_DIR)\External\Inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\apm\apmbatt\i386\apmbpnp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    apmbpnp.c

Abstract:

    Control Method Battery Plug and Play support

Author:

    Ron Mosgrove

Environment:

    Kernel mode

Revision History:

--*/

#include "ApmBattp.h"
#include <initguid.h>
#include <wdmguid.h>
#include <ntapm.h>

//
// Device Names
//
PCWSTR                      ApmBattDeviceName    = L"\\Device\\ApmBattery";
//PCWSTR                      AcAdapterName       = L"\\Device\\AcAdapter";

//
// This is a special Hack as part of this general APM special hack
//
PVOID   ApmGlobalClass = NULL;

//
// Prototypes
//
NTSTATUS
ApmBattAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );

NTSTATUS
ApmBattAddBattery(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );

#if 0
NTSTATUS
ApmBattAddAcAdapter(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    );
#endif

NTSTATUS
ApmBattCreateFdo(
    IN PDRIVER_OBJECT   DriverObject,
    IN ULONG            DeviceId,
    OUT PDEVICE_OBJECT  *NewDeviceObject
    );

NTSTATUS
ApmBattCompleteRequest(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );


NTSTATUS
ApmBattAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine creates functional device objects for each ApmBatt controller in the
    system and attaches them to the physical device objects for the controllers


Arguments:

    DriverObject            - a pointer to the object for this driver
    PhysicalDeviceObject    - a pointer to the physical object we need to attach to

Return Value:

    Status from device creation and initialization

--*/

{

    PAGED_CODE();


    ApmBattPrint (APMBATT_TRACE, ("ApmBattAddDevice\n"));
    ASSERT(DeviceCount == 0);

    if (DeviceCount != 0) {
        return STATUS_UNSUCCESSFUL;
    }
    DeviceCount = 1;

    ApmBattPrint ((APMBATT_TRACE | APMBATT_PNP), ("ApmBattAddDevice: Entered with pdo %x\n", Pdo));

    if (Pdo == NULL) {

        //
        // Have we been asked to do detection on our own?
        // if so just return no more devices
        //
        ApmBattPrint((APMBATT_WARN | APMBATT_PNP), ("ApmBattAddDevice: Asked to do detection\n"));
        return STATUS_NO_MORE_ENTRIES;

    } else {
        //
        // This device is a control-method battery
        //
        return (ApmBattAddBattery (DriverObject, Pdo));
    }
    return STATUS_UNSUCCESSFUL;
}



NTSTATUS
ApmBattAddBattery(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   Pdo
    )
/*++

Routine Description:

    This routine creates a functional device object for a CM battery,  and attache it
    to the physical device object for the battery.

Arguments:

    DriverObject            - a pointer to the object for this driver
    PhysicalDeviceObject    - a pointer to the physical object we need to attach to

Return Value:

    Status from device creation and initialization

--*/

{
    PDEVICE_OBJECT          Fdo = NULL;
    PDEVICE_OBJECT          lowerDevice = NULL;
    PCM_BATT                ApmBatt;
    NTSTATUS                Status;
    BATTERY_MINIPORT_INFO   BattInit;
    ULONG                   uniqueId;
    PNTAPM_LINK             pparms;
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;

    PAGED_CODE();

    ApmBattPrint ((APMBATT_TRACE | APMBATT_PNP), ("ApmBattAddBattery: pdo %x\n", Pdo));
//DbgBreakPoint();

    uniqueId = 0;

    //
    // Create and initialize the new functional device object
    //
    Status = ApmBattCreateFdo(DriverObject, uniqueId, &Fdo);

    if (!NT_SUCCESS(Status)) {
        ApmBattPrint(APMBATT_ERROR, ("ApmBattAddBattery: error (0x%x) creating Fdo\n", Status));
        return Status;
    }

    //
    // Initialize Fdo device extension data
    //

    ApmBatt = (PCM_BATT) Fdo->DeviceExtension;
    ApmBatt->Fdo = Fdo;
    ApmBatt->Pdo = Pdo;

    //
    // Layer our FDO on top of the PDO
    //

    lowerDevice = IoAttachDeviceToDeviceStack(Fdo,Pdo);

    //
    //  No status. Do the best we can.
    //
    if (!lowerDevice) {
        ApmBattPrint(APMBATT_ERROR, ("ApmBattAddBattery: Could not attach to lower device\n"));
        return STATUS_UNSUCCESSFUL;
    }

    ApmBatt->LowerDeviceObject = lowerDevice;

    //
    //  Attach to the Class Driver
    //

    RtlZeroMemory (&BattInit, sizeof(BattInit));
    BattInit.MajorVersion        = BATTERY_CLASS_MAJOR_VERSION;
    BattInit.MinorVersion        = BATTERY_CLASS_MINOR_VERSION;
    BattInit.Context             = ApmBatt;
    BattInit.QueryTag            = ApmBattQueryTag;
    BattInit.QueryInformation    = ApmBattQueryInformation;
    BattInit.SetInformation      = NULL;                  // tbd
    BattInit.QueryStatus         = ApmBattQueryStatus;
    BattInit.SetStatusNotify     = ApmBattSetStatusNotify;
    BattInit.DisableStatusNotify = ApmBattDisableStatusNotify;

    BattInit.Pdo                 = Pdo;
    BattInit.DeviceName          = ApmBatt->DeviceName;

    Status = BatteryClassInitializeDevice (&BattInit, &ApmBatt->Class);
    ApmGlobalClass = ApmBatt->Class;

    if (!NT_SUCCESS(Status)) {
        //
        //  if we can't attach to class driver we're toast
        //
        ApmBattPrint(APMBATT_ERROR, ("ApmBattAddBattery: error (0x%x) registering with class\n", Status));
        return Status;
    }

    //
    // link up with APM driver (if we can't we're toast)
    //
    // Should be able to just call into Pdo.
    //
    // DO WORK HERE
    //
    Irp = IoAllocateIrp((CCHAR) (Pdo->StackSize+2), FALSE);
    if (!Irp) {
        return STATUS_UNSUCCESSFUL;
    }

    IrpSp = IoGetNextIrpStackLocation(Irp);
    IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    IrpSp->MinorFunction = 0;
    IrpSp->DeviceObject = Pdo;
    pparms = (PNTAPM_LINK) &(IrpSp->Parameters.Others);
    pparms->Signature = NTAPM_LINK_SIGNATURE;
    pparms->Version = NTAPM_LINK_VERSION;
    pparms->BattLevelPtr = (ULONG)(&(NtApmGetBatteryLevel));
    pparms->ChangeNotify = (ULONG)(&(ApmBattPowerNotifyHandler));

    IoSetCompletionRoutine(Irp, ApmBattCompleteRequest, NULL, TRUE, TRUE, TRUE);

    if (IoCallDriver(Pdo, Irp) != STATUS_SUCCESS) {
        return STATUS_UNSUCCESSFUL;
    }

//DbgPrint("apmbatt: NtApmGetBatteryLevel: %08lx\n", NtApmGetBatteryLevel);

    return STATUS_SUCCESS;
}

NTSTATUS
ApmBattCompleteRequest(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++

Routine Description:

    Completion routine for ioctl call to apm.

Arguments:

    DeviceObject      - The target device which the request was sent

    Irp               - The irp completing

    Context           - The requestors completion routine

Return Value:


--*/
{
    IoFreeIrp(Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
ApmBattCreateFdo(
    IN PDRIVER_OBJECT       DriverObject,
    IN ULONG                DeviceId,
    OUT PDEVICE_OBJECT      *NewFdo
    )

/*++

Routine Description:

    This routine will create and initialize a functional device object to
    be attached to a Control Method Battery PDO.

Arguments:

    DriverObject    - a pointer to the driver object this is created under
    NewFdo          - a location to store the pointer to the new device object

Return Value:

    STATUS_SUCCESS if everything was successful
    reason for failure otherwise

--*/

{
    PUNICODE_STRING         unicodeString;
    PDEVICE_OBJECT          Fdo;
    NTSTATUS                Status;
    PCM_BATT                ApmBatt;
    UNICODE_STRING          numberString;
    WCHAR                   numberBuffer[10];

    PAGED_CODE();

    ApmBattPrint ((APMBATT_TRACE | APMBATT_PNP), ("ApmBattCreateFdo, Battery Id=%x\n", DeviceId));

    //
    // Allocate the UNICODE_STRING for the device name
    //

    unicodeString = ExAllocatePoolWithTag (
                        PagedPool,
                        sizeof (UNICODE_STRING) + MAX_DEVICE_NAME_LENGTH,
                        'taBC'
                        );

    if (!unicodeString) {
        ApmBattPrint(APMBATT_ERROR, ("ApmBattCreateFdo: could not allocate unicode string\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    unicodeString->MaximumLength    = MAX_DEVICE_NAME_LENGTH;
    unicodeString->Length           = 0;
    unicodeString->Buffer           = (PWCHAR) (unicodeString + 1);

    //
    // Create the PDO device name based on the battery instance
    //

    numberString.MaximumLength  = 10;
    numberString.Buffer         = &numberBuffer[0];

    RtlIntegerToUnicodeString (DeviceId, 10, &numberString);
    RtlAppendUnicodeToString  (unicodeString, (PWSTR) ApmBattDeviceName);
    RtlAppendUnicodeToString  (unicodeString, &numberString.Buffer[0]);


    Status = IoCreateDevice(
                DriverObject,
                sizeof (CM_BATT),
                unicodeString,
                FILE_DEVICE_BATTERY,
                0,
                FALSE,
                &Fdo
                );

    if (Status != STATUS_SUCCESS) {
        ApmBattPrint(APMBATT_ERROR, ("ApmBattCreateFdo: error (0x%x) creating device object\n", Status));
        ExFreePool (unicodeString);
        return(Status);
    }

    Fdo->Flags |= DO_BUFFERED_IO;
    Fdo->Flags |= DO_POWER_PAGABLE;             // Don't want power Irps at irql 2
    Fdo->Flags &= ~DO_DEVICE_INITIALIZING;
    Fdo->StackSize = 2;

    //
    // Initialize Fdo device extension data
    //

    ApmBatt = (PCM_BATT) Fdo->DeviceExtension;
    RtlZeroMemory(ApmBatt, sizeof(CM_BATT));
    ApmBatt->DeviceName      = unicodeString;
    ApmBatt->DeviceNumber    = (USHORT) DeviceId;
    ApmBatt->DeviceObject    = Fdo;
    *NewFdo = Fdo;

    ApmBattPrint((APMBATT_TRACE | APMBATT_PNP), ("ApmBattCreateFdo: Created FDO %x\n", Fdo));
    return STATUS_SUCCESS;
}



NTSTATUS
ApmBattPnpDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This routine is the dispatch routine for plug and play requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION  irpStack;
    PCM_BATT            ApmBatt;
    NTSTATUS            Status;

    PAGED_CODE();

    ApmBattPrint (APMBATT_TRACE, ("ApmBattPnpDispatch\n"));

    Status = STATUS_NOT_IMPLEMENTED;

    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    ApmBatt = DeviceObject->DeviceExtension;

    //
    // Dispatch minor function
    //
    switch (irpStack->MinorFunction) {

        case IRP_MN_START_DEVICE:
                //
                // if the Add succeeded, we are actually started...
                //
                ApmBattPrint (APMBATT_PNP, ("ApmBattPnpDispatch: IRP_MN_START_DEVICE\n"));
                Status = STATUS_SUCCESS;
                Irp->IoStatus.Status = Status;
                ApmBattCallLowerDriver(Status, ApmBatt->LowerDeviceObject, Irp);
                break;


        case IRP_MN_QUERY_DEVICE_RELATIONS:
                ApmBattPrint (APMBATT_PNP, ("ApmBattPnpDispatch: IRP_MN_QUERY_DEVICE_RELATIONS - type (%d)\n",
                            irpStack->Parameters.QueryDeviceRelations.Type));
                //
                // Just pass it down
                //
                ApmBattCallLowerDriver(Status, ApmBatt->LowerDeviceObject, Irp);
                break;


        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:
                Status = Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                IoCompleteRequest(Irp, 0);
                break;

        default:
                ApmBattPrint (APMBATT_PNP,
                        ("ApmBattPnpDispatch: Unimplemented minor %0x\n",
                        irpStack->MinorFunction));
                //
                // Unimplemented minor, Pass this down to ACPI
                //
                ApmBattCallLowerDriver(Status, ApmBatt->LowerDeviceObject, Irp);
                break;
    }

    return Status;
}



NTSTATUS
ApmBattPowerDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    This routine is the dispatch routine for power requests.

Arguments:

    DeviceObject - Pointer to class device object.
    Irp - Pointer to the request packet.

Return Value:

    Status is returned.

--*/
{
    PIO_STACK_LOCATION  irpStack;
    PCM_BATT            ApmBatt;
    NTSTATUS            Status;

    PAGED_CODE();

    ApmBattPrint ((APMBATT_TRACE | APMBATT_POWER), ("ApmBattPowerDispatch\n"));

    //
    // Get a pointer to the current parameters for this request.  The
    // information is contained in the current stack location.
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    ApmBatt = DeviceObject->DeviceExtension;

    //
    // Dispatch minor function
    //
    switch (irpStack->MinorFunction) {

        case IRP_MN_WAIT_WAKE:
                ApmBattPrint (APMBATT_POWER, ("ApmBattPowerDispatch: IRP_MN_WAIT_WAKE\n"));
                break;

        case IRP_MN_POWER_SEQUENCE:
                ApmBattPrint (APMBATT_POWER, ("ApmBattPowerDispatch: IRP_MN_POWER_SEQUENCE\n"));
                break;

        case IRP_MN_SET_POWER:
                ApmBattPrint (APMBATT_POWER, ("ApmBattPowerDispatch: IRP_MN_SET_POWER\n"));
                TagValue++;
                break;

        case IRP_MN_QUERY_POWER:
                ApmBattPrint (APMBATT_POWER, ("ApmBattPowerDispatch: IRP_MN_QUERY_POWER\n"));
                break;

        default:
                ApmBattPrint(APMBATT_LOW, ("ApmBattPowerDispatch: minor %d\n",
                        irpStack->MinorFunction));
                break;
    }

    //
    // What do we do with the irp?
    //
    PoStartNextPowerIrp( Irp );
    if (ApmBatt->LowerDeviceObject != NULL) {

        //
        // Forward the request along
        //
        IoSkipCurrentIrpStackLocation( Irp );
        Status = PoCallDriver( ApmBatt->LowerDeviceObject, Irp );

    } else {

        //
        // Complete the request with the current status
        //
        Status = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\apm\ntapm\ntapmdmp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntapmdmp.c

Abstract:

    Dump data about whether machine is ACPI or APM, and if
    APM whether APM is usable, good, bad, etc.

Author:

    Byan M. Willman (bryanwi) 24-Aug-1998

Revision History:

--*/
#if 0
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <apmlib.h>

void
DumpApmError();

void
_CRTAPI1 main(
    int argc,
    char *argv[]
    )
{
    if (IsSystemACPI()) {
        printf("ACPI system.  APM is not relevent.\n");
        exit(0);
    }

    switch (IsApmPresent()) {

    case APM_NOT_PRESENT:
        printf("APM not detected on this system.\n");
        exit(1);
        break;

    case APM_PRESENT_BUT_NOT_USABLE:
        printf("APM detected on this system, but not usable.\n");
        DumpApmError();
        exit(2);
        break;

    case APM_ON_GOOD_LIST:
        printf("APM detected on this system, usable, on the Good bios list.\n");
        if (IsApmActive()) {
            printf("APM is active on this machine.\n");
        } else {
            printf("APM is NOT active on this machine.\n");
        }
        exit(3);
        break;

    case APM_NEUTRAL:
        printf("APM detected on this system, usable, NOT on the Good or Bad lists.\n");
        if (IsApmActive()) {
            printf("APM is active on this machine.\n");
        } else {
            printf("APM is NOT active on this machine.\n");
        }
        exit(4);
        break;

    case APM_ON_BAD_LIST:
        printf("APM detected on this system, usable, BUT on the bad bios list.\n");
        if (IsApmActive()) {
            printf("APM is active on this machine.\n");
        } else {
            printf("APM is NOT active on this machine.\n");
        }
        exit(5);
        break;

    default:
        printf("Something very strange has happened.\n");
        exit(99);
        break;
    }
}


VOID
DumpApmError()
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\apm\apmbatt\i386\apmbattp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    apmbattp.h

Abstract:

    Control Method Battery Miniport Driver

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode

Revision History:

--*/

#ifndef FAR
#define FAR
#endif

#include <wdm.h>
#include <poclass.h>
//#include "acpiioct.h"

//
// Debug
//
#define DEBUG   1
#if DEBUG
    extern ULONG ApmBattDebug;
    #define ApmBattPrint(l,m)    if(l & ApmBattDebug) DbgPrint m
#else
    #define ApmBattPrint(l,m)
#endif

#define APMBATT_LOW          0x00000001
#define APMBATT_NOTE         0x00000002
#define APMBATT_WARN         0x00000004
#define APMBATT_ERROR_ONLY   0x00000008
#define APMBATT_ERROR        (APMBATT_ERROR_ONLY | APMBATT_WARN)
#define APMBATT_POWER        0x00000010
#define APMBATT_PNP          0x00000020
#define APMBATT_CM_EXE       0x00000040
#define APMBATT_DATA         0x00000100
#define APMBATT_TRACE        0x00000200
#define APMBATT_BIOS         0x00000400  // Show message to verify BIOS/HW functionality
#define APMBATT_MINI         0x00000800  // Show message to verify miniport retun data


#define MAX_DEVICE_NAME_LENGTH  128


//
//  These definitions are for the Technology field of the BATTERY_INFORMATION structure.
//  They probably ought to be in the poclass.h file, but they've been here
//  a whole release and nothing bad has happened, so leave them here.
//
// BATTERY_INFORMATION.Technology flags
//
#define BATTERY_PRIMARY_NOT_RECHARGABLE     0x00
#define BATTERY_SECONDARY_CHARGABLE         0x01

//
// Use the IoSkipCurrentIrpStackLocation routine because the we
// don't need to change arguments, or a completion routine
//

#define ApmBattCallLowerDriver(Status, DeviceObject, Irp) { \
                  IoSkipCurrentIrpStackLocation(Irp);         \
                  Status = IoCallDriver(DeviceObject,Irp); \
                  }

#define GetTid() PsGetCurrentThread()

//
// Pagable device extension for control battery
//

typedef struct _CM_BATT {

    ULONG                   Type;               // This must be the first entry
                                                // as it is shared with the AC_ACAPTER

    PDEVICE_OBJECT          DeviceObject;       // Battery device object
    PDEVICE_OBJECT          Fdo;                // Functional Device Object
    PDEVICE_OBJECT          Pdo;                // Physical Device Object
    PDEVICE_OBJECT          LowerDeviceObject;  // Detected at AddDevice time
    PVOID                   Class;              // Battery Class handle

    BOOLEAN                 IsStarted;          // if non zero, the device is started
    BOOLEAN                 IsCacheValid;       // Is cached battery info currently valid?

    //
    // Selector
    //
    PVOID                   Selector;           // Selector for battery

    //
    // Battery
    //
    ULONG                   TagCount;           // Tag for next battery
    PUNICODE_STRING         DeviceName;
    USHORT                  DeviceNumber;

} CM_BATT, *PCM_BATT;

//
// Misc globals
//
extern  PVOID   ApmGlobalClass;
extern  ULONG   DeviceCount;
extern  ULONG   TagValue;
extern  ULONG   (*NtApmGetBatteryLevel)();


//
// Prototypes
//

NTSTATUS
ApmBattPnpDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
ApmBattPowerDispatch(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
ApmBattForwardRequest(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp
    );

NTSTATUS
ApmBattAddDevice(
    IN PDRIVER_OBJECT       DriverObject,
    IN PDEVICE_OBJECT       Pdo
    );

NTSTATUS
ApmBattQueryTag (
    IN PVOID                Context,
    OUT PULONG              BatteryTag
    );

NTSTATUS
ApmBattSetStatusNotify (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    IN PBATTERY_NOTIFY      BatteryNotify
    );

NTSTATUS
ApmBattDisableStatusNotify (
    IN PVOID                Context
    );

NTSTATUS
ApmBattQueryStatus (
    IN PVOID                Context,
    IN ULONG                BatteryTag,
    OUT PBATTERY_STATUS     BatteryStatus
    );

NTSTATUS
ApmBattIoCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PKEVENT              pdoIoCompletedEvent
    );

NTSTATUS
ApmBattQueryInformation (
    IN PVOID                            Context,
    IN ULONG                            BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL  Level,
    IN ULONG                            AtRate OPTIONAL,
    OUT PVOID                           Buffer,
    IN  ULONG                           BufferLength,
    OUT PULONG                          ReturnedLength
    );

VOID
ApmBattPowerNotifyHandler(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\apm\ntapm\i386\apmp.h ===
/*++

Module Name:

    apmp.h

Abstract:

Author:

Revision History:

--*/


//
// APM Bios interface information
//

typedef struct _APM_CONNECT {
    KSPIN_LOCK          CallLock;
    ULONG               Code16BitOffset;
    USHORT              Selector[4];
    PVOID               VirtualAddress[4];
} APM_CONNECT, *PAPM_CONNTECT;

///
// Apm.c
//

NTSTATUS
ApmInitializeConnection (
    VOID
    );

ULONG
ApmCallBios (
    IN ULONG ApmFunctionCode,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx
    );


VOID
ApmGetBatteryStatus (
    );

#define  APM_DO_NOTHING 0
#define  APM_DO_SUSPEND 1
#define  APM_DO_STANDBY 2
#define  APM_DO_FIXCLOCK 3
#define  APM_DO_NOTIFY  4
#define  APM_DO_CRITICAL_SUSPEND 5

ULONG
ApmCheckForEvent (
    VOID
    );

NTSTATUS
ApmSuspendSystem (
    VOID
    );

NTSTATUS
ApmStandBySystem (
    VOID
    );

VOID
ApmTurnOffSystem (
    VOID
    );

NTSTATUS
ApmFunction (
    IN ULONG      ApmFunctionCode,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\apm\ntapm\i386\apm.c ===
/*++

Module Name:

    apm.c

Abstract:

    A collection of code that allows NT calls into APM.
    The code in this routine depends on data being set up in the registry

Author:

Environment:

    Kernel mode only.

Revision History:

--*/


#include "ntosp.h"
#include "zwapi.h"
#include "apmp.h"
#include "apm.h"
#include "apmcrib.h"
#include "ntapmdbg.h"
#include "ntapmlog.h"
#include "ntapmp.h"


#define MAX_SEL     30      // attempts before giving up

ULONG   ApmCallActive = 0;
ULONG   ApmCallEax = 0;
ULONG   ApmCallEbx = 0;
ULONG   ApmCallEcx = 0;

WCHAR rgzMultiFunctionAdapter[] =
    L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter";
WCHAR rgzConfigurationData[] = L"Configuration Data";
WCHAR rgzIdentifier[] = L"Identifier";
WCHAR rgzPCIIndetifier[] = L"PCI";

WCHAR rgzApmConnect[]= L"\\Registry\\Machine\\Hardware\\ApmConnect";
WCHAR rgzApmConnectValue[] = L"ApmConnectValue";

APM_CONNECT     Apm;

//
// First time we get any non-recoverable error back
// from APM, record what sort of call hit it and what
// the error code was here
//
ULONG   ApmLogErrorFunction = -1L;
ULONG   ApmLogErrorCode = 0L;

ULONG ApmErrorLogSequence = 0xf3;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,ApmInitializeConnection)
#endif

//
// Internal prototypes
//

BOOLEAN
ApmpBuildGdtEntry (
    IN ULONG Index,
    PKGDTENTRY GdtEntry,
    IN ULONG SegmentBase
    );


VOID
NtApmLogError(
    NTSTATUS    ErrorCode,
    UCHAR       ErrorByte
    );


NTSTATUS
ApmInitializeConnection (
    VOID
    )
/*++

Routine Description:

    Initialize data needed to call APM bios functions -- look in the
    registry to find out if this machine has had its APM capability
    detected.

    NOTE:   If you change the recognition code, change the
            code to IsApmPresent as well!

Arguments:

    None

Return Value:

    STATUS_SUCCESS if we were able to connect to the APM BIOS.

--*/
{
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PDesc;
    PCM_FULL_RESOURCE_DESCRIPTOR Desc;
    PKEY_VALUE_FULL_INFORMATION ValueInfo;
    PAPM_REGISTRY_INFO ApmEntry;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString, ConfigName, IdentName;
    KGDTENTRY GdtEntry;
    NTSTATUS status;
    BOOLEAN Error;
    HANDLE hMFunc, hBus, hApmConnect;
    USHORT Sel[MAX_SEL], TSel;
    UCHAR buffer [sizeof(APM_REGISTRY_INFO) + 99];
    WCHAR wstr[8];
    ULONG i, j, Count, junk;
    PWSTR p;
    USHORT  volatile    Offset;

    //
    // Look in the registery for the "APM bus" data
    //

    RtlInitUnicodeString(&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );


    status = ZwOpenKey(&hMFunc, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        return status;
    }

    unicodeString.Buffer = wstr;
    unicodeString.MaximumLength = sizeof (wstr);

    RtlInitUnicodeString(&ConfigName, rgzConfigurationData);
    RtlInitUnicodeString(&IdentName, rgzIdentifier);

    ValueInfo = (PKEY_VALUE_FULL_INFORMATION) buffer;

    for (i=0; TRUE; i++) {
        RtlIntegerToUnicodeString(i, 10, &unicodeString);
        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL
            );

        status = ZwOpenKey(&hBus, KEY_READ, &objectAttributes);
        if (!NT_SUCCESS(status)) {

            //
            // Out of Multifunction adapter entries...
            //

            ZwClose (hMFunc);
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Check the Indentifier to see if this is a APM entry
        //

        status = ZwQueryValueKey (
                    hBus,
                    &IdentName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        if (!NT_SUCCESS (status)) {
            ZwClose (hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) ValueInfo + ValueInfo->DataOffset);
        if (p[0] != L'A' || p[1] != L'P' || p[2] != L'M' || p[3] != 0) {
            ZwClose (hBus);
            continue;
        }

        status = ZwQueryValueKey(
                    hBus,
                    &ConfigName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        ZwClose (hBus);
        if (!NT_SUCCESS(status)) {
            continue ;
        }

        Desc  = (PCM_FULL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      ValueInfo + ValueInfo->DataOffset);
        PDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      Desc->PartialResourceList.PartialDescriptors);

        if (PDesc->Type == CmResourceTypeDeviceSpecific) {
            // got it..
            ApmEntry = (PAPM_REGISTRY_INFO) (PDesc+1);
            break;
        }
    }

//DbgPrint("ApmEntry: %08lx\n", ApmEntry);
//DbgPrint("Signature: %c%c%c\n", ApmEntry->Signature[0], ApmEntry->Signature[1], ApmEntry->Signature[2]);
    if ( (ApmEntry->Signature[0] != 'A') ||
         (ApmEntry->Signature[1] != 'P') ||
         (ApmEntry->Signature[2] != 'M') )
    {
        return STATUS_UNSUCCESSFUL;
    }

//DbgPrint("ApmEntry->Valid: %0d\n", ApmEntry->Valid);
    if (ApmEntry->Valid != 1) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Apm found - initialize the connection
    //

    KeInitializeSpinLock(&Apm.CallLock);

    //
    // Allocate a bunch of selectors
    //

    for (Count=0; Count < MAX_SEL; Count++) {
        status = KeI386AllocateGdtSelectors (Sel+Count, 1);
        if (!NT_SUCCESS(status)) {
            break;
        }
    }

    //
    // Sort the selctors via bubble sort
    //

    for (i=0; i < Count; i++) {
        for (j = i+1; j < Count; j++) {
            if (Sel[j] < Sel[i]) {
                TSel = Sel[i];
                Sel[i] = Sel[j];
                Sel[j] = TSel;
            }
        }
    }

    //
    // Now look for 3 consecutive values
    //

    for (i=0; i < Count - 3; i++) {
        if (Sel[i]+8 == Sel[i+1]  &&  Sel[i]+16 == Sel[i+2]) {
            break;
        }
    }

    if (i >= Count - 3) {
        DrDebug(APM_INFO,("APM: Could not allocate consecutive selectors\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Save the results
    //

    Apm.Selector[0] = Sel[i+0];
    Apm.Selector[1] = Sel[i+1];
    Apm.Selector[2] = Sel[i+2];
    Sel[i+0] = 0;
    Sel[i+1] = 0;
    Sel[i+2] = 0;

    //
    // Free unused selectors
    //

    for (i=0; i < Count; i++) {
        if (Sel[i]) {
            KeI386ReleaseGdtSelectors (Sel+i, 1);
        }
    }

    //
    // Initialize the selectors to use the APM bios
    //

    Error = FALSE;

    //
    // initialize 16 bit code selector
    //

    GdtEntry.LimitLow                   = 0xFFFF;
    GdtEntry.HighWord.Bytes.Flags1      = 0;
    GdtEntry.HighWord.Bytes.Flags2      = 0;
    GdtEntry.HighWord.Bits.Pres         = 1;
    GdtEntry.HighWord.Bits.Dpl          = DPL_SYSTEM;
    GdtEntry.HighWord.Bits.Granularity  = GRAN_BYTE;
    GdtEntry.HighWord.Bits.Type         = 31;
    GdtEntry.HighWord.Bits.Default_Big  = 0;

    Error |= ApmpBuildGdtEntry (0, &GdtEntry, ApmEntry->Code16BitSegment);

    //
    // initialize 16 bit data selector
    //

    GdtEntry.LimitLow                   = 0xFFFF;
    GdtEntry.HighWord.Bytes.Flags1      = 0;
    GdtEntry.HighWord.Bytes.Flags2      = 0;
    GdtEntry.HighWord.Bits.Pres         = 1;
    GdtEntry.HighWord.Bits.Dpl          = DPL_SYSTEM;
    GdtEntry.HighWord.Bits.Granularity  = GRAN_BYTE;
    GdtEntry.HighWord.Bits.Type         = 19;
    GdtEntry.HighWord.Bits.Default_Big  = 1;

    Error |= ApmpBuildGdtEntry (1, &GdtEntry, ApmEntry->Data16BitSegment);

    //
    // If we leave it like this, the compiler generates incorrect code!!!
    // Apm.Code16BitOffset = ApmEntry->Code16BitOffset;
    // So do this instead.
    //
    Offset = ApmEntry->Code16BitOffset;
    Apm.Code16BitOffset = (ULONG) Offset;

//DbgPrint("Apm@%08lx ApmEntry@%08lx\n", &Apm, ApmEntry);
//DbgBreakPoint();


#if 0
    //
    // to make the poweroff path in the Hal about 20 times simpler,
    // as well as make it work, pass our mappings on to the Hal, so
    // it can use them.
    //
    RtlInitUnicodeString(&unicodeString, rgzApmConnect);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    status = ZwCreateKey(
                &hApmConnect,
                KEY_ALL_ACCESS,
                &objectAttributes,
                0,
                NULL,
                REG_OPTION_VOLATILE,
                &junk
                );
    RtlInitUnicodeString(&unicodeString, rgzApmConnectValue);
    if (NT_SUCCESS(status)) {
        status = ZwSetValueKey(
                    hApmConnect,
                    &unicodeString,
                    0,
                    REG_BINARY,
                    &Apm,
                    sizeof(APM_CONNECT)
                    );
        ZwClose(hApmConnect);
    }
#endif

    return Error ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS;
}


BOOLEAN
ApmpBuildGdtEntry (
    IN ULONG Index,
    PKGDTENTRY GdtEntry,
    IN ULONG SegmentBase
    )

/*++

Routine Description:

    Build the Gdt Entry

Arguments:

    Index           Index of entry
    GdtEntry
    SegmentBase

Return Value:

    TRUE if we encountered any error, FALSE if successful

--*/
{
    PHYSICAL_ADDRESS    PhysAddr;
    ULONG               SegBase;
    PVOID               VirtualAddress;
    ULONG               AddressSpace;
    BOOLEAN             flag;

    //
    // Convert Segment to phyiscal address
    //

    PhysAddr.LowPart  = SegmentBase << 4;
    PhysAddr.HighPart = 0;

    //
    // Translate physical address from ISA bus 0
    //

    AddressSpace = 0;
    flag = HalTranslateBusAddress (
                Isa, 0,
                PhysAddr,
                &AddressSpace,
                &PhysAddr
                );

    if (AddressSpace != 0  ||  !flag) {
        return TRUE;
    }

    //
    // Map into virtual address space
    //

    VirtualAddress = MmMapIoSpace (
                    PhysAddr,
                    0x10000,        // 64k
                    TRUE
                    );
    Apm.VirtualAddress[Index] = VirtualAddress;

    //
    // Map virtual address to selector:0 address
    //

    SegBase = (ULONG) VirtualAddress;
    GdtEntry->BaseLow               = (USHORT) (SegBase & 0xffff);
    GdtEntry->HighWord.Bits.BaseMid = (UCHAR)  (SegBase >> 16) & 0xff;
    GdtEntry->HighWord.Bits.BaseHi  = (UCHAR)  (SegBase >> 24) & 0xff;

    KeI386SetGdtSelector (Apm.Selector[Index], GdtEntry);
    return FALSE;
}


NTSTATUS
ApmFunction (
    IN ULONG      ApmFunctionCode,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx
    )
/*++

Routine Description:

    Call APM BIOS with ApmFunctionCode and appropriate arguments

Arguments:

    ApmFunctionCode     Apm function code
    Ebx                 Ebx param to APM BIOS
    Ecx                 Ecx param to APM BIOS

Return Value:

    STATUS_SUCCESS with Ebx, Ebx
    otherwise an NTSTATUS code

--*/
{
    KIRQL           OldIrql;
    ULONG           ApmStatus;
    CONTEXT         Regs;


    if (!Apm.Selector[0]) {

        //
        // Attempting to call APM BIOS without a sucessfull connection
        //

        DrDebug(APM_INFO,("APM: ApmFunction - APM not initialized\n"));
        DrDebug(APM_INFO,
            ("APM: ApmFunction failing function %x\n", ApmFunctionCode));
        return STATUS_UNSUCCESSFUL;
    }

//DbgPrint("APM: ApmFunction: %08lx Ebx: %08lx Ecx: %08lx\n", ApmFunctionCode, *Ebx, *Ecx);


    //
    // Serialize calls into the APM bios
    //
    KeAcquireSpinLock(&Apm.CallLock, &OldIrql);
    ApmCallActive += 1;

    //
    // ASM interface to call the BIOS
    //

    //
    // Fill in general registers for 16bit bios call.
    // Note: only the following registers are passed.  Specifically,
    // SS and ESP are not passed and are generated by the system.
    //

    Regs.ContextFlags = CONTEXT_INTEGER | CONTEXT_SEGMENTS;

    Regs.Eax    = ApmFunctionCode;
    Regs.Ebx    = *Ebx;
    Regs.Ecx    = *Ecx;
    Regs.Edx    = 0;
    Regs.Esi    = 0;
    Regs.Edi    = 0;
    Regs.SegGs  = 0;
    Regs.SegFs  = 0;
    Regs.SegEs  = Apm.Selector[1];
    Regs.SegDs  = Apm.Selector[1];
    Regs.SegCs  = Apm.Selector[0];
    Regs.Eip    = Apm.Code16BitOffset;
    Regs.EFlags = 0x200;    // interrupts enabled

    ApmCallEax = Regs.Eax;
    ApmCallEbx = Regs.Ebx;
    ApmCallEcx = Regs.Ecx;

    //
    // call the 16:16 bios function
    //

    KeI386Call16BitFunction (&Regs);

    ApmCallActive -= 1;

    //
    // Release serialization
    //
    KeReleaseSpinLock(&Apm.CallLock, OldIrql);

    //
    // Get the results
    //

    ApmStatus = 0;
    if (Regs.EFlags & 0x1) {        // check carry flag
        ApmStatus = (Regs.Eax >> 8) & 0xff;
    }

    *Ebx = Regs.Ebx;
    *Ecx = Regs.Ecx;

    //
    // save for debug use
    //
    if (ApmStatus) {
        if (ApmLogErrorCode != 0) {
            ApmLogErrorFunction = ApmFunctionCode;
            ApmLogErrorCode = ApmStatus;
        }
    }

    //
    // log specific errors of value to the user
    //
    if (ApmFunctionCode == APM_SET_POWER_STATE) {
        if (ApmStatus != 0)
        {
            NtApmLogError(NTAPM_SET_POWER_FAILURE, (UCHAR)ApmStatus);
        }
    }




    DrDebug(APM_INFO,("APM: ApmFunction result is %x\n", ApmStatus));
    return ApmStatus;
}


WCHAR   ApmConvArray[] = {'0', '1','2','3','4','5','6','7','8','9','A','B','C','D','E','F',0};
VOID
NtApmLogError(
    NTSTATUS    ErrorCode,
    UCHAR       ErrorByte
    )
/*++

Routine Description:

    Report the incoming error to the event log.

Arguments:

    ErrorCode - the ntstatus type value which will match the message template
                and get reported to the user.

    ErrorByte - the 1 byte value returned by APM bios

Return Value:

    None.
--*/
{
    PIO_ERROR_LOG_PACKET    errorLogPacket;
    PUCHAR                  p;
    PWCHAR                  pw;

    errorLogPacket = IoAllocateErrorLogEntry(
        NtApmDriverObject,
        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET)+8)
        );

    if (errorLogPacket != NULL) {
        errorLogPacket->ErrorCode = ErrorCode;
        errorLogPacket->SequenceNumber = ApmErrorLogSequence++;
        errorLogPacket->FinalStatus =  STATUS_UNSUCCESSFUL;
        errorLogPacket->UniqueErrorValue = 0;
        errorLogPacket->NumberOfStrings = 1;
        errorLogPacket->RetryCount = 0;
        errorLogPacket->MajorFunctionCode = 0;
        errorLogPacket->DeviceOffset.HighPart = 0;
        errorLogPacket->DeviceOffset.LowPart = 0;
        errorLogPacket->DumpDataSize = 0;

        //
        // why our own conversion code?  because we can't get the fine
        // RTL routines to put the data in the right sized output buffer
        //
        p = (PUCHAR) &(errorLogPacket->DumpData[0]);
        pw = (PWCHAR)p;

        pw[0] = ApmConvArray[(ULONG)((ErrorByte & 0xf0)>>4)];
        pw[1] = ApmConvArray[(ULONG)(ErrorByte & 0xf)];
        pw[2] = L'\0';

        errorLogPacket->StringOffset =
            ((PUCHAR)(&(errorLogPacket->DumpData[0]))) - ((PUCHAR)errorLogPacket);
        IoWriteErrorLogEntry(errorLogPacket);
    }


    return;
}



NTSTATUS
ApmSuspendSystem (
    VOID
    )

/*++

Routine Description:

    Suspend the system

Arguments:

    none

Return Value:

    STATUS_SUCCESS if the computer was suspended & then resumed

--*/
{
    ULONG       Ebx, Ecx;
    NTSTATUS    Status;

    //
    // Use ApmFunction to suspend machine
    //

    DrDebug(APM_L2,("APM: ApmSuspendSystem: enter\n"));
    Ebx = APM_DEVICE_ALL;
    Ecx = APM_SET_SUSPEND;
    Status = ApmFunction (APM_SET_POWER_STATE, &Ebx, &Ecx);
    DrDebug(APM_L2,("APM: ApmSuspendSystem: exit\n"));
    return Status;
}


VOID
ApmTurnOffSystem(
    VOID
    )

/*++

Routine Description:

    Turn the system off.

Arguments:

    none


--*/
{
    ULONG       Ebx, Ecx;
    NTSTATUS    Status;

    //
    // Use ApmFunction to put machine into StandBy mode
    //
    DrDebug(APM_L2,("APM: ApmTurnOffSystem: enter\n"));
    Ebx = APM_DEVICE_ALL;
    Ecx = APM_SET_OFF;
    Status = ApmFunction (APM_SET_POWER_STATE, &Ebx, &Ecx);
    DrDebug(APM_L2,("APM: ApmTurnOffSystem: exit\n"));
    return;
}

VOID
ApmInProgress(
    VOID
    )
/*++

Routine Description:

    This routine informs the BIOS to cool its jets for 5 seconds
    while we continue to operate

Arguments:

    none

Return Value:

    STATUS_SUCCESS if the computer was suspended & then resumed

--*/
{
    ULONG       Ebx, Ecx;
    NTSTATUS    Status;

    //
    // Use ApmFunction to tell BIOS to cool its heals
    //

    Ebx = APM_DEVICE_ALL;
    Ecx = APM_SET_PROCESSING;
    Status = ApmFunction (APM_SET_POWER_STATE, &Ebx, &Ecx);
    return;
}


ULONG
ApmCheckForEvent (
    VOID
    )

/*++

Routine Description:

    Poll for APM event

Arguments:

Return Value:

    We return:
        APM_DO_code from apmp.h

        APM_DO_NOTHING 0
        APM_DO_SUSPEND 1
        APM_DO_STANDBY 2
        APM_DO_FIXCLOCK 3
        APM_DO_NOTIFY  4
        APM_DO_CRITICAL_SUSPEND 5

--*/
{
    NTSTATUS    Status;
    ULONG       Ebx, Ecx;
    ULONG       returnvalue;

    //
    // Read an event.  Might get nothing.
    //

    returnvalue = APM_DO_NOTHING;

    Ebx = 0;
    Ecx = 0;
    Status = ApmFunction (APM_GET_EVENT, &Ebx, &Ecx);

    if (Status != STATUS_SUCCESS) {
        return returnvalue;
    }

    //
    // Handle APM reported event
    //

    DrDebug(APM_L2,("APM: ApmCheckForEvent, code is %d\n", Ebx));

    switch (Ebx) {

        //
        // say wer're working on it and set up for standby
        //
        case APM_SYS_STANDBY_REQUEST:
        case APM_USR_STANDBY_REQUEST:
            DrDebug(APM_L2,("APM: ApmCheckForEvent, standby request\n"));
            ApmInProgress();
            returnvalue = APM_DO_STANDBY;
            break;

        //
        // say we're working on it and set up for suspend
        //
        case APM_SYS_SUSPEND_REQUEST:
        case APM_USR_SUSPEND_REQUEST:
        case APM_BATTERY_LOW_NOTICE:
            DrDebug(APM_L2,
                ("APM: ApmCheckForEvent, suspend or battery low\n"));
            ApmInProgress();
            returnvalue = APM_DO_SUSPEND;
            break;

        //
        // Say we're working on it, and setup for CRITICAL suspend
        //
        case APM_CRITICAL_SYSTEM_SUSPEND_REQUEST:
            DrDebug(APM_L2, ("APM: Apmcheckforevent, critical suspend\n"));
            ApmInProgress();
            returnvalue = APM_DO_CRITICAL_SUSPEND;
            break;

        //
        // ignore this because we have no idea what to do with it
        //
        case APM_CRITICAL_RESUME_NOTICE:
            DrDebug(APM_L2,("APM: ApmCheckForEvent, critical resume\n"));
            break;


        case APM_UPDATE_TIME_EVENT:
            DrDebug(APM_L2,("APM: ApmCheckForEvent, update time\n"));
            returnvalue = APM_DO_FIXCLOCK;
            break;

        case APM_POWER_STATUS_CHANGE_NOTICE:
            DrDebug(APM_L2,("APM: ApmCheckForEvent, update battery\n"));
            returnvalue = APM_DO_NOTIFY;
            break;

        case APM_NORMAL_RESUME_NOTICE:
        case APM_STANDBY_RESUME_NOTICE:
        case APM_CAPABILITIES_CHANGE_NOTICE:

            //
            // ignore these because we don't care and there's nothing to do
            //

            DrDebug(APM_L2,
                ("APM: ApmCheckForEvent, non-interesting event\n"));
            break;

        default:
            DrDebug(APM_L2,("APM: ApmCheckForEvent, out of range event\n"));
            break;
    } //switch

    return returnvalue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\apm\ntapm\i386\apmcrib.h ===
/*++

Module Name:

    apmcrib.h -

Abstract:

    prototypes that aren't in driver visible includes...

Author:


Environment:

    Kernel mode

Notes:

Revision History:

--*/


//
// NT "private" prototypes cribbed in here.  Not for use anywhere
// but in laptop.c
//
NTSTATUS
KeI386AllocateGdtSelectors(
    OUT PUSHORT SelectorArray,
    IN USHORT NumberOfSelectors
    );

VOID
KeI386Call16BitFunction (
    IN OUT PCONTEXT Regs
    );

NTSTATUS
KeI386ReleaseGdtSelectors(
    OUT PUSHORT SelectorArray,
    IN USHORT NumberOfSelectors
    );

NTSTATUS
KeI386SetGdtSelector (
    ULONG       Selector,
    PKGDTENTRY  GdtValue
    );


//
// APM constants that really belong somewhere else...
//
#define APM_SYS_STANDBY_REQUEST             (0x01)
#define APM_SYS_SUSPEND_REQUEST             (0x02)
#define APM_NORMAL_RESUME_NOTICE            (0x03)
#define APM_CRITICAL_RESUME_NOTICE          (0x04)
#define APM_BATTERY_LOW_NOTICE              (0x05)
#define APM_POWER_STATUS_CHANGE_NOTICE      (0x06)
#define APM_UPDATE_TIME_EVENT               (0x07)
#define APM_CRITICAL_SYSTEM_SUSPEND_REQUEST (0x08)
#define APM_USR_STANDBY_REQUEST             (0x09)
#define APM_USR_SUSPEND_REQUEST             (0x0a)
#define APM_STANDBY_RESUME_NOTICE           (0x0b)
#define APM_CAPABILITIES_CHANGE_NOTICE      (0x0c)

#define APM_SET_PROCESSING                  4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\apm\ntapm\i386\ntapmdbg.h ===
/*++

Module Name:

    ntapmdbg.h

Abstract:

    Basic debug print support with granular control

Author:

Environment:

Revision History:

--*/

extern ULONG NtApmDebugFlag;

#if DBG
#define DrDebug(LEVEL,STRING) \
        do { \
            if (NtApmDebugFlag & LEVEL) { \
                DbgPrint STRING; \
            } \
        } while (0)
#else
#define DrDebug(x,y)
#endif

#define SYS_INFO    0x0001
#define SYS_INIT    0x0002
#define SYS_L2      0x0004

#define APM_INFO    0x0010
#define APM_L2      0x0020

#define PNP_INFO    0x0100
#define PNP_L2      0x0200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\apm\ntapm\i386\ntcrib.h ===
/*++

Module Name:

    ntcrib.h

Abstract:

    prototypes that aren't in driver visible includes...

    Yes, we are copying prototypes here.  It would be good to
    get rid of this, but I don't know how to do it right now
    without exposing this stuff to drivers, which I don't want to do.

Author:


Environment:

    Kernel mode

Notes:

Revision History:

--*/


NTSYSAPI
NTSTATUS
NTAPI
ZwInitiatePowerAction(
    IN POWER_ACTION SystemAction,
    IN SYSTEM_POWER_STATE MinSystemState,
    IN ULONG Flags,                 // POWER_ACTION_xxx flags
    IN BOOLEAN Asynchronous
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\apm\ntapm\i386\ntapmp.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    ntapm.h

Abstract:

Author:

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#include <ntapmsdk.h>

#define APM_INSTANCE_IDS L"0000"
#define APM_INSTANCE_IDS_LENGTH 5


#define NTAPM_PDO_NAME_APM_BATTERY L"\\Device\\NtApm_ApmBattery"
#define NTAPM_ID_APM_BATTERY L"NTAPM\\APMBATT\0\0"


#define NTAPM_POOL_TAG (ULONG) ' MPA'
#undef ExAllocatePool
#define ExAllocatePool(type, size) \
            ExAllocatePoolWithTag (type, size, NTAPM_POOL_TAG);



extern  PDRIVER_OBJECT  NtApmDriverObject;

//
// A common header for the device extensions of the PDOs and FDO
//

typedef struct _COMMON_DEVICE_DATA
{
    PDEVICE_OBJECT  Self;
    // A backpointer to the device object for which this is the extension

    CHAR            Reserved[3];
    BOOLEAN         IsFDO;
    // A boolean to distringuish between PDO and FDO.
} COMMON_DEVICE_DATA, *PCOMMON_DEVICE_DATA;

//
// The device extension for the PDOs.
// That is the game ports of which this bus driver enumerates.
// (IE there is a PDO for the 201 game port).
//

typedef struct _PDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    PDEVICE_OBJECT  ParentFdo;
    // A back pointer to the bus

    PWCHAR      HardwareIDs;
    // An array of (zero terminated wide character strings).
    // The array itself also null terminated

    ULONG UniqueID;
    // Globally unique id in the system

} PDO_DEVICE_DATA, *PPDO_DEVICE_DATA;


//
// The device extension of the bus itself.  From whence the PDO's are born.
//

typedef struct _FDO_DEVICE_DATA
{
    COMMON_DEVICE_DATA;

    PDEVICE_OBJECT  UnderlyingPDO;
    PDEVICE_OBJECT  TopOfStack;
    // the underlying bus PDO and the actual device object to which our
    // FDO is attached

} FDO_DEVICE_DATA, *PFDO_DEVICE_DATA;

NTSTATUS
ApmAddHelper();

NTSTATUS
NtApm_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusPhysicalDeviceObject
    );


NTSTATUS
NtApm_PnP (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
NtApm_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
NtApm_PDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PPDO_DEVICE_DATA     DeviceData
    );

NTSTATUS
NtApm_StartFdo (
    IN  PFDO_DEVICE_DATA            FdoData,
    IN  PCM_PARTIAL_RESOURCE_LIST   PartialResourceList,
    IN  PCM_PARTIAL_RESOURCE_LIST   PartialResourceListTranslated
    );

NTSTATUS
NtApm_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtApm_FDO_Power (
    PFDO_DEVICE_DATA    Data,
    PIRP                Irp
    );

NTSTATUS
NtApm_PDO_Power (
    PPDO_DEVICE_DATA    PdoData,
    PIRP                Irp
    );

NTSTATUS
NtApm_CreatePdo (
    PFDO_DEVICE_DATA    FdoData,
    PWCHAR              PdoName,
    PDEVICE_OBJECT *    PDO
    );

VOID
NtApm_InitializePdo(
    PDEVICE_OBJECT      Pdo,
    PFDO_DEVICE_DATA    FdoData,
    PWCHAR              Id
    );

VOID
ApmInProgress();


ULONG
DoApmReportBatteryStatus();



//
// APM extractor values
//

//
// APM_GET_POWER_STATUS
//

//
// EBX
// BH = Ac Line Status
//
#define APM_LINEMASK            0xff00
#define APM_LINEMASK_SHIFT      8
#define APM_GET_LINE_OFFLINE    0
#define APM_GET_LINE_ONLINE     1
#define APM_GET_LINE_BACKUP     2
#define APM_GET_LINE_UNKNOWN    0xff

//
// ECX
// CL = Percentage remaining
// CH = flags
//
#define APM_PERCENT_MASK        0xff
#define APM_BATT_HIGH           0x0100
#define APM_BATT_LOW            0x0200
#define APM_BATT_CRITICAL       0x0400
#define APM_BATT_CHARGING       0x0800
#define APM_NO_BATT             0x1000
#define APM_NO_SYS_BATT         0x8000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\apm\ntapm\i386\apmpnp.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    apmpnp.c

Abstract:

    This module contains contains the plugplay calls
    needed to make ntapm.sys work.

Author:

    Bryan Willman
    Kenneth D. Ray
    Doron J. Holan

Environment:

    kernel mode only

Notes:


Revision History:


--*/

#include <wdm.h>
#include "ntapmp.h"
#include "ntapmdbg.h"
#include "ntapm.h"
//#include "stdio.h"

//
// Globals
//
PDEVICE_OBJECT  NtApm_ApmBatteryPdo = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, NtApm_AddDevice)
#pragma alloc_text (PAGE, NtApm_PnP)
#pragma alloc_text (PAGE, NtApm_FDO_PnP)
#pragma alloc_text (PAGE, NtApm_PDO_PnP)
#pragma alloc_text (PAGE, NtApm_Power)
#pragma alloc_text (PAGE, NtApm_FDO_Power)
#pragma alloc_text (PAGE, NtApm_PDO_Power)
#pragma alloc_text (PAGE, NtApm_CreatePdo)
#pragma alloc_text (PAGE, NtApm_InitializePdo)
#endif

NTSTATUS
NtApm_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT BusPhysicalDeviceObject
    )
/*++
Routine Description.
    A bus has been found.  Attach our FDO to it.
    Allocate any required resources.  Set things up.  And be prepared for the
    first ``start device.''

Arguments:
    BusDeviceObject - Device object representing the bus.  That to which we
                      attach a new FDO.

    DriverObject - This very self referenced driver.

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      deviceObject;
    PFDO_DEVICE_DATA    deviceData;
    UNICODE_STRING      deviceNameUni;
    PWCHAR              deviceName;
    ULONG               nameLength;

    PAGED_CODE ();

    DrDebug(PNP_INFO, ("ntapm Add Device: 0x%x\n", BusPhysicalDeviceObject));

    status = IoCreateDevice (
                    DriverObject,  // our driver object
                    sizeof (FDO_DEVICE_DATA), // device object extension size
                    NULL, // FDOs do not have names
                    FILE_DEVICE_BUS_EXTENDER,
                    0, // No special characteristics
                    TRUE, // our FDO is exclusive
                    &deviceObject); // The device object created

    if (!NT_SUCCESS (status)) {
        return status;
    }

    deviceData = (PFDO_DEVICE_DATA) deviceObject->DeviceExtension;
    RtlFillMemory (deviceData, sizeof (FDO_DEVICE_DATA), 0);

    deviceData->IsFDO = TRUE;
    deviceData->Self = deviceObject;
    deviceData->UnderlyingPDO = BusPhysicalDeviceObject;

    //
    // Attach our filter driver to the device stack.
    // the return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    // Our filter will send IRPs to the top of the stack and use the PDO
    // for all PlugPlay functions.
    //
    deviceData->TopOfStack = IoAttachDeviceToDeviceStack (
                                deviceObject,
                                BusPhysicalDeviceObject
                                );


    if (!deviceData->TopOfStack) {
        IoDeleteDevice(deviceObject);
        return STATUS_UNSUCCESSFUL;
    }

    status = ApmAddHelper();

    if (!NT_SUCCESS(status)) {
        IoDetachDevice(deviceData->TopOfStack);
        IoDeleteDevice(deviceObject);
    }

    deviceObject->Flags |= DO_POWER_PAGABLE;
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}

NTSTATUS
NtApm_FDO_PnPComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Pirp,
    IN PVOID            Context
    );

NTSTATUS
NtApm_PnP (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++
Routine Description:
    Answer the plithera of Irp Major PnP IRPS.
--*/
{
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                status;
    PCOMMON_DEVICE_DATA     commonData;
    KIRQL                   oldIrq;

    PAGED_CODE ();

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_PNP == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
        DrDebug(PNP_INFO, ("ntapm PNP: Functional DO: %x IRP: %x\n", DeviceObject, Irp));

        status = NtApm_FDO_PnP (
                    DeviceObject,
                    Irp,
                    irpStack,
                    (PFDO_DEVICE_DATA) commonData);
    } else {
        DrDebug(PNP_INFO, ("ntapm: PNP: Physical DO: %x IRP: %x\n", DeviceObject, Irp));

        status = NtApm_PDO_PnP (
                    DeviceObject,
                    Irp,
                    irpStack,
                    (PPDO_DEVICE_DATA) commonData);
    }

    return status;
}

NTSTATUS
NtApm_FDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PFDO_DEVICE_DATA     DeviceData
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the BUS itself

    NB: the various Minor functions of the PlugPlay system will not be
    overlapped and do not have to be reentrant

--*/
{
    NTSTATUS    status;
    KIRQL       irql;
    KEVENT      event;
    ULONG       length;
    ULONG       i;
    PLIST_ENTRY entry;
    PPDO_DEVICE_DATA    pdoData;
    PDEVICE_RELATIONS   relations;
    PIO_STACK_LOCATION  stack;
    ULONG       battresult;

    PAGED_CODE ();

    stack = IoGetCurrentIrpStackLocation (Irp);

    switch (IrpStack->MinorFunction) {
    case IRP_MN_START_DEVICE:
        //
        // BEFORE you are allowed to ``touch'' the device object to which
        // the FDO is attached (that send an irp from the bus to the Device
        // object to which the bus is attached).   You must first pass down
        // the start IRP.  It might not be powered on, or able to access or
        // something.
        //


        DrDebug(PNP_INFO, ("ntapm: Start Device\n"));

        KeInitializeEvent (&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine (Irp,
                                NtApm_FDO_PnPComplete,
                                &event,
                                TRUE,
                                TRUE,
                                TRUE);

        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        if (STATUS_PENDING == status) {
            // wait for it...

            status = KeWaitForSingleObject (&event,
                                            Executive,
                                            KernelMode,
                                            FALSE, // Not allertable
                                            NULL); // No timeout structure

            ASSERT (STATUS_SUCCESS == status);

            status = Irp->IoStatus.Status;
        }

        //
        // We must now complete the IRP, since we stopped it in the
        // completetion routine with MORE_PROCESSING_REQUIRED.
        //
        break;


    case IRP_MN_QUERY_DEVICE_RELATIONS:

        if (IrpStack->Parameters.QueryDeviceRelations.Type != BusRelations) {
            //
            // We don't support this
            //
            goto NtApm_FDO_PNP_DEFAULT;
        }

        //
        // In theory, APM should be fired up by now.
        // So call off into it to see if there is any sign
        // of a battery on the box.  If there is NOT, don't
        // export the PDOs for the battery objects
        //
        battresult = DoApmReportBatteryStatus();
        if (battresult & NTAPM_NO_SYS_BATT) {
            //
            // it appears that the machine does not have
            // a battery.  so don't export battery driver PDOs.
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(DeviceData->TopOfStack, Irp);
        }

        DrDebug(PNP_INFO, ("ntapm: Query Relations "));

        //
        // create PDO for apm battery
        //
        if (NtApm_ApmBatteryPdo == NULL) {
            status = NtApm_CreatePdo(
                        DeviceData,
                        NTAPM_PDO_NAME_APM_BATTERY,
                        &NtApm_ApmBatteryPdo
                        );
            if (!NT_SUCCESS(status)) {
                goto NtApm_DONE;
            }
        }

        NtApm_InitializePdo(NtApm_ApmBatteryPdo, DeviceData, NTAPM_ID_APM_BATTERY);

        //
        // Tell PNP about our two child PDOs.
        //
        i = (Irp->IoStatus.Information == 0) ? 0 :
            ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Count;

        //
        // above should be count of PDOs
        // make a new structure and our PDO to the end
        //

        //
        // Need to allocate a new relations structure and add our
        // PDOs to it.
        //
        length = sizeof(DEVICE_RELATIONS) + ((i + 1) * sizeof (PDEVICE_OBJECT));

        relations = (PDEVICE_RELATIONS) ExAllocatePool (NonPagedPool, length);

        if (relations == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto NtApm_DONE;
        }

        //
        // Copy in the device objects so far
        //
        if (i) {
            RtlCopyMemory (
                      relations->Objects,
                      ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Objects,
                      i * sizeof (PDEVICE_OBJECT));
        }
        relations->Count = i + 1;

        //
        // add the apm battery PDO to the list
        //
        ObReferenceObject(NtApm_ApmBatteryPdo);
        relations->Objects[i] = NtApm_ApmBatteryPdo;

        //
        // Replace the relations structure in the IRP with the new
        // one.
        //
        if (Irp->IoStatus.Information != 0) {
            ExFreePool ((PVOID) Irp->IoStatus.Information);
        }
        Irp->IoStatus.Information = (ULONG) relations;

        //
        // Set up and pass the IRP further down the stack
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (DeviceData->TopOfStack, Irp);

        return status;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_STOP_DEVICE:
    case IRP_MN_REMOVE_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
        status = STATUS_UNSUCCESSFUL;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
        Irp->IoStatus.Status = STATUS_SUCCESS;  // we're lying, it's more like noop
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver (DeviceData->TopOfStack, Irp);
        break;

NtApm_FDO_PNP_DEFAULT:
    default:
        //
        // In the default case we merely call the next driver since
        // we don't know what to do.
        //
        IoSkipCurrentIrpStackLocation (Irp);
        return IoCallDriver (DeviceData->TopOfStack, Irp);
    }

NtApm_DONE:
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
NtApm_FDO_PnPComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:
    A completion routine for use when calling the lower device objects to
    which our bus (FDO) is attached.

--*/
{
    UNREFERENCED_PARAMETER (DeviceObject);
    UNREFERENCED_PARAMETER (Irp);

    KeSetEvent ((PKEVENT) Context, 1, FALSE);
    // No special priority
    // No Wait

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}

NTSTATUS
NtApm_PDO_PnP (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpStack,
    IN PPDO_DEVICE_DATA     DeviceData
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the devices on the BUS

--*/
{
    PDEVICE_CAPABILITIES    deviceCapabilities;
    ULONG                   information;
    PWCHAR                  buffer, buffer2;
    ULONG                   length, length2, i, j;
    NTSTATUS                status;
    KIRQL                   oldIrq;
    PDEVICE_RELATIONS       relations;

    PAGED_CODE ();

    status = Irp->IoStatus.Status;

    //
    // NB: since we are a bus enumerator, we have no one to whom we could
    // defer these irps.  Therefore we do not pass them down but merely
    // return them.
    //

    switch (IrpStack->MinorFunction) {
    case IRP_MN_QUERY_CAPABILITIES:

        DrDebug(PNP_INFO, ("ntapm: Query Caps \n"));

        //
        // Get the packet.
        //
        deviceCapabilities = IrpStack->Parameters.DeviceCapabilities.Capabilities;

        deviceCapabilities->UniqueID = FALSE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_ID:
        // Query the IDs of the device
        DrDebug(PNP_INFO, ("ntapm: QueryID: 0x%x\n", IrpStack->Parameters.QueryId.IdType));

        switch (IrpStack->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:
            // this can be the same as the hardware ids (which requires a multi
            // sz) ... we are just allocating more than enough memory
        case BusQueryHardwareIDs:
            // return a multi WCHAR (null terminated) string (null terminated)
            // array for use in matching hardare ids in inf files;
            //

            buffer = DeviceData->HardwareIDs;

            while (*(buffer++)) {
                while (*(buffer++)) {
                    ;
                }
            }
            length = (buffer - DeviceData->HardwareIDs) * sizeof (WCHAR);

            buffer = ExAllocatePool (PagedPool, length);
            if (buffer) {
                RtlCopyMemory (buffer, DeviceData->HardwareIDs, length);
                Irp->IoStatus.Information = (ULONG) buffer;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            break;

        case BusQueryInstanceID:
            //
            // Build an instance ID.  This is what PnP uses to tell if it has
            // seen this thing before or not.
            //
            //
            // return 0000 for all devices and have the flag set to not unique
            //
            length = APM_INSTANCE_IDS_LENGTH * sizeof(WCHAR);
            buffer = ExAllocatePool(PagedPool, length);

            if (buffer != NULL) {
                RtlCopyMemory(buffer, APM_INSTANCE_IDS, length);
                Irp->IoStatus.Information = (ULONG_PTR)buffer;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            break;

        case BusQueryCompatibleIDs:
            // The generic ids for installation of this pdo.
            break;

        }
        break;

    case IRP_MN_START_DEVICE:
        DrDebug(PNP_INFO, ("ntapm: Start Device \n"));
        // Here we do what ever initialization and ``turning on'' that is
        // required to allow others to access this device.
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:
    case IRP_MN_REMOVE_DEVICE:
    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
        DrDebug(PNP_INFO, ("ntapm: remove, stop, or Q remove or Q stop\n"));
        //
        // disallow Stop or Remove, since we don't want to test
        // disengagement from APM if we don't have to
        //
        status = STATUS_UNSUCCESSFUL;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
        DrDebug(PNP_INFO, ("ntapm: Cancel Stop Device or Cancel Remove \n"));
        status = STATUS_SUCCESS;  // more like "noop" than success
        break;

    case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        if (IrpStack->Parameters.QueryDeviceRelations.Type != TargetDeviceRelation) {

            //
            // Somebody else can handle this.
            //
            break;
        }

        ASSERT(((PULONG_PTR)Irp->IoStatus.Information) == NULL);

        relations = (PDEVICE_RELATIONS) ExAllocatePool(PagedPool, sizeof(DEVICE_RELATIONS));

        if (relations == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            Irp->IoStatus.Information = (ULONG_PTR) relations;
            relations->Count = 1;
            relations->Objects[0] = DeviceObject;
            ObReferenceObject(DeviceObject);
            status = STATUS_SUCCESS;
        }

        break;
    case IRP_MN_READ_CONFIG:
    case IRP_MN_WRITE_CONFIG: // we have no config space
    case IRP_MN_EJECT:
    case IRP_MN_SET_LOCK:
    case IRP_MN_QUERY_INTERFACE: // We do not have any non IRP based interfaces.
    default:
        DrDebug(PNP_INFO, ("ntapm: PNP Not handled 0x%x\n", IrpStack->MinorFunction));
        // this is a leaf node
        // status = STATUS_NOT_IMPLEMENTED
        // For PnP requests to the PDO that we do not understand we should
        // return the IRP WITHOUT setting the status or information fields.
        // They may have already been set by a filter (eg acpi).
        break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
}


NTSTATUS
NtApm_CreatePdo (
    PFDO_DEVICE_DATA    FdoData,
    PWCHAR              PdoName,
    PDEVICE_OBJECT *    PDO
    )
{
    UNICODE_STRING      pdoUniName;
    NTSTATUS            status;

    PAGED_CODE ();
//DbgBreakPoint();

    //
    // Create the PDOs
    //
    RtlInitUnicodeString (&pdoUniName, PdoName);
    DrDebug(PNP_INFO, ("ntapm: CreatePdo: PDO Name: %ws\n", PdoName));

    status = IoCreateDevice(
                FdoData->Self->DriverObject,
                sizeof (PDO_DEVICE_DATA),
                &pdoUniName,
                FILE_DEVICE_BUS_EXTENDER,
                0,
                FALSE,
                PDO
                );
    DrDebug(PNP_L2, ("ntapm: CreatePdo: status = %08lx\n", status));

    if (!NT_SUCCESS (status)) {
        *PDO = NULL;
    }

    return status;
}

VOID
NtApm_InitializePdo(
    PDEVICE_OBJECT      Pdo,
    PFDO_DEVICE_DATA    FdoData,
    PWCHAR              Id
    )
{
    PPDO_DEVICE_DATA pdoData;

    PAGED_CODE ();

    pdoData = (PPDO_DEVICE_DATA)  Pdo->DeviceExtension;

    DrDebug(PNP_INFO, ("ntapm: pdo 0x%x, extension 0x%x\n", Pdo, pdoData));

    //
    // Initialize the rest
    //
    pdoData->IsFDO = FALSE;
    pdoData->Self =  Pdo;

    pdoData->ParentFdo = FdoData->Self;

    pdoData->HardwareIDs = Id;

    pdoData->UniqueID = 1;

    Pdo->Flags &= ~DO_DEVICE_INITIALIZING;
    Pdo->Flags |= DO_POWER_PAGABLE;

}

NTSTATUS
NtApm_Power (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
    We do nothing special for power;

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status;
    PCOMMON_DEVICE_DATA commonData;

    PAGED_CODE ();

    status = STATUS_SUCCESS;
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (IRP_MJ_POWER == irpStack->MajorFunction);

    commonData = (PCOMMON_DEVICE_DATA) DeviceObject->DeviceExtension;

    if (commonData->IsFDO) {
        status = NtApm_FDO_Power ((PFDO_DEVICE_DATA) DeviceObject->DeviceExtension,Irp);
    } else {
        status = NtApm_PDO_Power ((PPDO_DEVICE_DATA) DeviceObject->DeviceExtension,Irp);
    }

    return status;
}


NTSTATUS
NtApm_FDO_Power (
    PFDO_DEVICE_DATA    Data,
    PIRP                Irp
    )
{
    PIO_STACK_LOCATION  stack;

    PAGED_CODE ();

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    return PoCallDriver(Data->TopOfStack, Irp);
}

NTSTATUS
NtApm_PDO_Power (
    PPDO_DEVICE_DATA    PdoData,
    PIRP                Irp
    )
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  stack;

    stack = IoGetCurrentIrpStackLocation (Irp);
    switch (stack->MinorFunction) {
        case IRP_MN_SET_POWER:
            if ((stack->Parameters.Power.Type == SystemPowerState)  &&
                (stack->Parameters.Power.State.SystemState == PowerSystemWorking))
            {
                //
                // system has just returned to the working state
                // assert the user is present (they must be for the APM case)
                // so that the display will light up, idle timers behave, etc.
                //
                PoSetSystemState(ES_USER_PRESENT);
            }
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_POWER:
            status = STATUS_SUCCESS;
            break;

        case IRP_MN_WAIT_WAKE:
        case IRP_MN_POWER_SEQUENCE:
        default:
            status = Irp->IoStatus.Status;
            break;
    }

    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\makefile.inc ===
!IFDEF PASS0ONLY
BuildDDK:

!ELSE

#
# Process only on the second pass
#

BuildDDK:
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  ddk_drivers.ini  ddk $(PROJECT_ROOT)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\apm\ntapm\i386\ntapm.c ===
/*++

Module Name:

    ntapm.c

Abstract:

    OS source for ntapm.sys

Author:


Environment:

    Kernel mode

Notes:

Revision History:

--*/



#include "ntddk.h"
#include "ntpoapi.h"
#include "string.h"
#include "ntcrib.h"
#include "ntapmdbg.h"
#include "apm.h"
#include "apmp.h"
#include "ntapmp.h"
#include <ntapm.h>
#include <poclass.h>
#include <ntapmlog.h>

//
// Global debug flag. There are 3 separate groupings, see ntapmdbg.h for
// break out.
//

ULONG   NtApmDebugFlag = 0;

ULONG   ApmWorks = 0;

WCHAR rgzApmActiveFlag[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ApmActive";
WCHAR rgzApmFlag[] =
    L"Active";

WCHAR rgzAcpiKey[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ACPI";
WCHAR rgzAcpiStart[] =
    L"Start";


//
// Define driver entry routine.
//

NTSTATUS DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    );

NTSTATUS ApmDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

BOOLEAN
IsAcpiMachine(
    VOID
    );

ULONG   DoApmPoll();
NTSTATUS DoApmInitMachine();



VOID (*BattChangeNotify)() = NULL;


#define POLL_INTERVAL   (500)       // 500 milliseconds == 1/2 second

#define APM_POLL_MULTIPLY   (4)     // only call ApmInProgress once every 4 Poll intervals
                                    // which with current values is once every 2 seconds

#define APM_SPIN_LIMIT      (6)     // 6 spin passes, each with a call to ApmInProgress,
                                    // at APM_POLL_MULTIPLY * POLL_INTERVAL time spacing.
                                    // Current values (500, 4, 6) should yield APM bios
                                    // waiting from 12s to 17s, depending on how large
                                    // or small their value of 5s is.

volatile BOOLEAN OperationDone = FALSE;      // used to make some sync between SuspendPollThread
                                    // and ApmSleep and ApmOff work.

//
// Our own driver object.  This is rude, but this is a very weird
// and special driver.  We will pass this to our APM library to
// allow error logging to work.  Note that we don't actually have
// an active IRP around when the error occurs.
//
PDRIVER_OBJECT  NtApmDriverObject = NULL;

//
// Define the local routines used by this driver module.
//

VOID SuspendPollThread(PVOID Dummy);
VOID ApmSleep(VOID);
VOID ApmOff(VOID);



KTIMER PollTimer;



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the laptop driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS    status;
    ULONG       MajorVersion;
    ULONG       MinorVersion;


    //
    // refuse to load on machines with more than 1 cpu
    //
    if (KeNumberProcessors != 1) {
        DrDebug(SYS_INFO, ("ntapm: more than 1 cpu, ntapm will exit\n"));
        return STATUS_UNSUCCESSFUL;
    }


    //
    // refuse to load if version number is not 5.1 or 5.0
    // NOTE WELL: This is a manual version check, do NOT put a system
    //            constant in here.  This driver depends on hacks in
    //            the kernel that will someday go away...
    //
    PsGetVersion(&MajorVersion, &MinorVersion, NULL, NULL);
    if (  !
            (
                ((MajorVersion == 5) && (MinorVersion == 0)) ||
                ((MajorVersion == 5) && (MinorVersion == 1))
            )
    )
    {
        DrDebug(SYS_INFO, ("ntapm: system version number != 5.1, exit\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // refuse to load if ACPI.SYS should be running
    //
    if (IsAcpiMachine()) {
        DrDebug(SYS_INFO, ("ntapm: this is an acpi machine apm exiting\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // init the driver object
    //
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = ApmDispatch;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = ApmDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = ApmDispatch;
    DriverObject->MajorFunction[IRP_MJ_PNP] = NtApm_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER] = NtApm_Power;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = ApmDispatch;
    DriverObject->DriverExtension->AddDevice = NtApm_AddDevice;
    NtApmDriverObject = DriverObject;

    return STATUS_SUCCESS;
}

BOOLEAN ApmAddHelperDone = FALSE;

NTSTATUS
ApmAddHelper(
    )
/*++

Routine Description:

    We do these things in the Add routine so that we cannot fail
    and leave the Kernel/Hal/Apm chain in a corrupt state.

    This includes linking up with the Hal.

    Turns out the caller doesn't know if this work has already
    been done, so disallow doing it more than once here.

Arguments:

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    UCHAR   HalTable[HAL_APM_TABLE_SIZE];
    PPM_DISPATCH_TABLE  InTable;
    HANDLE      ThreadHandle;
    HANDLE      hKey;
    NTSTATUS    status;
    ULONG       flagvalue;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      unicodeString;
    ULONG       battresult;

    if (ApmAddHelperDone) {
        return STATUS_SUCCESS;
    }
    ApmAddHelperDone = TRUE;


    //
    // call ApmInitMachine so that Bios, etc, can be engaged
    // no suspends can happen before this call.
    //
    if (! NT_SUCCESS(DoApmInitMachine()) )  {
        DrDebug(SYS_INFO, ("ntapm: DoApmInitMachine failed\n"));
        return STATUS_UNSUCCESSFUL;
    }


    //
    // call the hal
    //
    InTable = (PPM_DISPATCH_TABLE)HalTable;
    InTable->Signature = HAL_APM_SIGNATURE;
    InTable->Version = HAL_APM_VERSION;

    //
    // In theory, APM should be fired up by now.
    // So call off into it to see if there is any sign
    // of a battery on the box.
    //
    // If we do not see a battery, then do NOT enable
    // S3, but do allow S4.  This keeps people's machines
    // from puking on failed S3 calls (almost always desktops)
    // while allowing auto-shutdown at the end of hibernate to work.
    //
    battresult = DoApmReportBatteryStatus();
    if (battresult & NTAPM_NO_SYS_BATT) {
        //
        // it appears that the machine does not have
        // a battery, or least APM doesn't report one.
        //
        InTable->Function[HAL_APM_SLEEP_VECTOR] = NULL;
    } else {
        InTable->Function[HAL_APM_SLEEP_VECTOR] = &ApmSleep;
    }

    InTable->Function[HAL_APM_OFF_VECTOR] = &ApmOff;

    status = HalInitPowerManagement(InTable, NULL);

    if (! NT_SUCCESS(status)) {
        DrDebug(SYS_INFO, ("ntapm: HalInitPowerManagement failed\n"));
        return STATUS_UNSUCCESSFUL;
    }


    //
    // From this point on, INIT MUST succeed, otherwise we'll leave
    // the Hal with hanging pointers.  So long as ApmSleep and ApmOff
    // are present in memory, things will be OK (though suspend may
    // not work, the box won't bugcheck.)
    //
    // init periodic timer, init suspend done event, init suspend dpc,
    // create and start poll thread
    //
    status = PsCreateSystemThread(&ThreadHandle,
                                  (ACCESS_MASK) 0L,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &SuspendPollThread,
                                  NULL
                                  );

    //
    // the create didn't work, turns out that some apm functions
    // will still work, so just keep going.
    //
    if (! NT_SUCCESS(status)) {
        DrDebug(SYS_INFO, ("ntapm: could not create thread, but continunuing\n"));
        //        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeTimerEx(&PollTimer, SynchronizationTimer);

    //
    // set a flag in the registry so that code with special hacks
    // based on apm being active can tell we're here and at least
    // nominally running
    //
    RtlInitUnicodeString(&unicodeString, rgzApmActiveFlag);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );

    status = ZwCreateKey(
                &hKey,
                KEY_WRITE,
                &objectAttributes,
                0,
                NULL,
                REG_OPTION_VOLATILE,
                NULL
                );

    RtlInitUnicodeString(&unicodeString, rgzApmFlag);
    if (NT_SUCCESS(status)) {
        flagvalue = 1;
        ZwSetValueKey(
            hKey,
            &unicodeString,
            0,
            REG_DWORD,
            &flagvalue,
            sizeof(ULONG)
            );
        ZwClose(hKey);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
ApmDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    When an application calls the Laptop driver, it comes here.
    This is NOT the dispatch point for PNP or Power calls.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PVOID outbuffer;
    ULONG outlength;
    PFILE_OBJECT fileObject;
    ULONG   percent;
    BOOLEAN acon;
    PNTAPM_LINK pparms;
    PULONG  p;
    ULONG   t;

    UNREFERENCED_PARAMETER( DeviceObject );


    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
    Irp->IoStatus.Information = 0;
    switch (irpSp->MajorFunction) {

        //
        // device control
        //
        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            //
            // Only one valid command, which is to set (or null out) the
            // the link call pointers.
            //
            if (irpSp->MinorFunction == 0) {
                pparms = (PNTAPM_LINK) &(irpSp->Parameters.Others);
                if ((pparms->Signature == NTAPM_LINK_SIGNATURE) &&
                    (pparms->Version == NTAPM_LINK_VERSION))
                {
                    t = (ULONG) (&DoApmReportBatteryStatus);
                    p = (PULONG)(pparms->BattLevelPtr);
                    *p = t;
                    BattChangeNotify = (PVOID)(pparms->ChangeNotify);
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = 0;
                }
            }
            break;

        default:
            //
            // for all other operations, including create/open and close,
            // simply report failure, no matter what the operation is
            //
            break;
    }

    //
    // Copy the final status into the return status, complete the request and
    // get out of here.
    //
    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, 0 );
    return status;
}

VOID
SuspendPollThread(
    PVOID Dummy
    )
/*++

Routine Description:

    This routine is the laptop suspend polling thread.

Arguments:

    Dummy       Ignored parameter

Return Value:

    None

--*/
{
    LARGE_INTEGER               DueTime;
    ULONG                       LocalSuspendFlag;
    ULONG                       LocalClockFlag;
    KIRQL                       OldIrql;
    POWER_ACTION                SystemAction;
    SYSTEM_POWER_STATE          MinSystemState;
    ULONG                       Flags;
    ULONG                       ApmEvent;
    ULONG                       count, count2;
    LONG                        i,  j;
    ULONG                       BatteryResult, PriorBatteryResult;
    ULONG                       BattPresentMask, PriorBattPresentMask;
    BOOLEAN                     DoANotify;

    PriorBatteryResult = BatteryResult = 0;

    //
    // Start the poll timer going, we'll wait for 1 second,
    // then POLL_INTERVAL milliseconds after that
    //

    DueTime.HighPart = 0;
    DueTime.LowPart = 10*1000*1000; // 10 million * 100nano = 1 second
    KeSetTimerEx(&PollTimer, DueTime, POLL_INTERVAL, NULL);

    while (1) {

        KeWaitForSingleObject(&PollTimer, Executive, KernelMode, TRUE, NULL);

        //
        // Call APM to poll for us
        //

        Flags = 0;  // clear all flags

        switch (DoApmPoll()) {

            case APM_DO_CRITICAL_SUSPEND:
                //
                // Here we force the Flags to have the
                // CRITICAL flag set, other than that it's the same thing
                // as for normal suspend and standby
                //
                Flags = POWER_ACTION_CRITICAL;

                /* FALL FALL FALL */

            case APM_DO_SUSPEND:
            case APM_DO_STANDBY:
                //
                // For either Suspend or Standby, call the
                // the system and tell it to suspend us
                //
                DrDebug(SYS_INFO, ("ntapm: about to call OS to suspend\n"));
                SystemAction = PowerActionSleep;
                MinSystemState = PowerSystemSleeping3;
                OperationDone = FALSE;
                ZwInitiatePowerAction(
                    SystemAction,
                    MinSystemState,
                    Flags,
                    TRUE                // async
                    );

                //
                // If we just call ZwInitiatePowerAction, most machines
                // will work, but a few get impatient and try to suspend
                // out from under us before the OS comes back round and
                // does the suspend.  So, we need to call ApmInProgress
                // every so often to make these bioses wait.
                //
                // BUT, if the system is truly wedged, or the suspend fails,
                // we don't want to spin calling ApmInProgress forever, so
                // limit the number of times we do that.  And once the
                // operation is about to happen, stop.
                //
                // Since we're not polling while we're waiting for something
                // to happen, we'll use the poll timer...
                //

                if (OperationDone) goto Done;

                ApmInProgress();
                for (count = 0; count < APM_SPIN_LIMIT; count++) {
                    for (count2 = 0; count2 < APM_POLL_MULTIPLY; count2++) {
                        KeWaitForSingleObject(&PollTimer, Executive, KernelMode, TRUE, NULL);
                    }
                    if (OperationDone) goto Done;
                    ApmInProgress();
                }

                DrDebug(SYS_INFO, ("ntapm: back from suspend\n"));
Done:
                break;

            case APM_DO_NOTIFY:
                //
                // Call out to battery driver with Notify op here
                //
                if (BattChangeNotify) {
                    //DrDebug(SYS_INFO, ("ntapm: about to make notify call\n"));
                    BattChangeNotify();
                    //DrDebug(SYS_INFO, ("ntapm: back from notify call\n"));
                    PriorBatteryResult = DoApmReportBatteryStatus();
                }
                break;

            case APM_DO_FIXCLOCK:
            case APM_DO_NOTHING:
            default:
                //
                // fixing the clock is too scary with other power
                // code doing it, so we don't do it here.
                //
                // nothing is nothing
                //
                // if we don't understand, do nothing
                // (remember, bios will force op under us if it's critical)
                //

                if (BattChangeNotify) {

                    //
                    // we hereby redefine "nothing" to be "check on the
                    // status of the bleeding battery" since not all bioses
                    // tell us what is going on in a timely fashion
                    //
                    DoANotify = FALSE;
                    BatteryResult = DoApmReportBatteryStatus();

                    if ((BatteryResult & NTAPM_ACON) !=
                        (PriorBatteryResult & NTAPM_ACON))
                    {
                        DoANotify = TRUE;
                    }

                    if ((BatteryResult & NTAPM_BATTERY_STATE) !=
                        (PriorBatteryResult & NTAPM_BATTERY_STATE))
                    {
                        DoANotify = TRUE;
                    }

                    i = BatteryResult & NTAPM_POWER_PERCENT;
                    j = PriorBatteryResult & NTAPM_POWER_PERCENT;

                    if (( (i - j) > 25 ) ||
                        ( (j - i) > 25 ))
                    {
                        DoANotify = TRUE;
                    }

                    PriorBattPresentMask = PriorBatteryResult & (NTAPM_NO_BATT | NTAPM_NO_SYS_BATT);
                    BattPresentMask = BatteryResult & (NTAPM_NO_BATT | NTAPM_NO_SYS_BATT);
                    if (BattPresentMask != PriorBattPresentMask) {
                        //
                        // battery either went or reappeared
                        //
                        DoANotify = TRUE;
                    }

                    PriorBatteryResult = BatteryResult;

                    if (DoANotify) {
                        ASSERT(BattChangeNotify);
                        BattChangeNotify();
                    }
                }

                break;

        } // switch
    } // while
}

VOID
ApmSleep(
    VOID
    )
/*++

Routine Description:

    When the OS calls the Hal's S3 vector, the hal calls us here.
    We call APM to put the box to sleep

--*/
{
    OperationDone = TRUE;
    if (ApmWorks) {

        DrDebug(SYS_L2,("ntapm: apmsleep: calling apm to sleep\n"));

        ApmSuspendSystem();

        DrDebug(SYS_L2,("ntapm: apmsleep: back from apm call\n"));

    } else {  // ApmWorks == FALSE

        DrDebug(SYS_INFO, ("ntapm: ApmSleep: no APM attached, Exit\n"));

    }
}

VOID
ApmOff(
    VOID
    )
/*++

Routine Description:

    When the OS calls the Hal's S4 or S5 routines, the hal calls us here.
    We turn the machine off.

--*/
{
    OperationDone = TRUE;
    if (ApmWorks) {

        DrDebug(SYS_L2,("ntapm: ApmOff: calling APM\n"));

        ApmTurnOffSystem();

        DrDebug(SYS_INFO,("ntapm: ApmOff: we are back from Off, uh oh!\n"));
    }
}

NTSTATUS
DoApmInitMachine(
    )
/*++

Routine Description:

    This routine makes the BIOS ready to interact with laptop.sys.
    This code works with APM.

Return Value:

    None

--*/
{
    NTSTATUS    Status;
    ULONG       Ebx, Ecx;

    DrDebug(SYS_INIT,("ApmInitMachine: enter\n"));

    Status = ApmInitializeConnection ();

    if (NT_SUCCESS(Status)) {

        DrDebug(SYS_INIT,("ApmInitMachine: Connection established!\n"));

        //
        // Note that ntdetect (2nd version) will have set apm bios
        // to min of (machine version) and (1.2)
        // (so a 1.1 bios will be set to 1.1, a 1.2 to 1.2, a 1.3 to 1.2
        //

        ApmWorks = 1;

    } else {

        DrDebug(SYS_INIT,("ApmInitMachine: No connection made!\n"));

        ApmWorks = 0;

    }

    DrDebug(SYS_INIT,("ApmInitMachine: exit\n"));
    return Status;
}

ULONG
DoApmPoll(
    )
/*++

Routine Description:

    This routine is called in the ntapm.sys polling loop to poll
    for APM events.  It returns APM_DO_NOTHING unless there is
    actually something meaningful for us to do.  (That is, things
    we don't want and/or don't understand are filtered down to
    APM_DO_NOTHING)

Return Value:

    APM event code.

--*/
{

    DrDebug(SYS_L2,("ApmPoll: enter\n"));

    if (ApmWorks) {

        return ApmCheckForEvent();

    } else { // ApmWorks == FALSE

        DrDebug(SYS_L2,("ApmPoll: no APM attachment, exit\n"));
        return APM_DO_NOTHING;

    }
}

ULONG
DoApmReportBatteryStatus()
/*++

Routine Description:

    This routine queries the BIOS/HW for the state of the power connection
    and the current battery level.

Arguments:

Return Value:

    ULONG, fields defined by NTAPM_POWER_STATE and NTAPM_POWER_PERCENT

--*/
{
    ULONG percent = 100;
    ULONG ac = 1;
    ULONG Status = 0;
    ULONG Ebx = 0;
    ULONG Ecx = 0;
    ULONG flags = 0;
    ULONG result = 0;


    DrDebug(SYS_L2,("ntapm: DoApmReportBatteryStatus: enter\n"));
    if (ApmWorks) {

        //
        // Call APM BIOS and get power status
        //

        Ebx = 1;
        Ecx = 0;
        Status = ApmFunction (APM_GET_POWER_STATUS, &Ebx, &Ecx);

        if (!NT_SUCCESS(Status)) {

            //
            // If we cannot read the power, jam in 50% and power off!
            //
            DrDebug(SYS_INFO,("ntapm: DoApmReportBatteryStatus: Can't get power!\n"));
            percent = 50;
            ac = 0;

        } else {

            //
            // Get battery/AC state -- anything but full 'on-line' means on
            // battery
            //

            ac = (Ebx & APM_LINEMASK) >> APM_LINEMASK_SHIFT;
            if (ac != APM_GET_LINE_ONLINE) {
                ac = 0;
            }
            percent = Ecx & APM_PERCENT_MASK;
        }

    } else {

        DrDebug(SYS_INFO,("ntapm: DoApmReportBatteryStatus: no APM attachment\n"));
        DrDebug(SYS_INFO,("ntapm: Return AC OFF 50% Life\n"));
        percent = 50;
        ac = FALSE;

    }

    flags = 0;
    result = 0;

    if (Ecx & APM_NO_BATT) {
        result |= NTAPM_NO_BATT;
    }

    if (Ecx & APM_NO_SYS_BATT) {
        result |= NTAPM_NO_SYS_BATT;
    }

    if ((percent == 255) || (Ecx & APM_NO_BATT) || (Ecx & APM_NO_SYS_BATT)) {
        percent = 0;
    } else if (percent > 100) {
        percent = 100;
    }

    if ((Ecx & APM_BATT_CHARGING) && (percent < 100)) {
        flags |= BATTERY_CHARGING;
    } else {
        flags |= BATTERY_DISCHARGING;
    }

    if (Ecx & APM_BATT_CRITICAL) {
        flags |= BATTERY_CRITICAL;
        percent = 1;
    }

    if (ac) {
        result |= NTAPM_ACON;
        flags |= BATTERY_POWER_ON_LINE;
    }

    result |= (flags << NTAPM_BATTERY_STATE_SHIFT);


    result |= percent;

    DrDebug(SYS_L2,("ntapm: BatteryLevel: %08lx  Percent: %d  flags: %1x  ac: %1x\n",
        result, percent, flags, ac));

    return result;
}

BOOLEAN
IsAcpiMachine(
    VOID
    )
/*++

Routine Description:

    IsAcpiMachine reports whether the OS thinks this is an ACPI
    machine or not.

Return Value:

    FALSE - this is NOT an acpi machine

    TRUE - this IS an acpi machine

--*/
{
    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hKey;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION pvpi;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(ULONG)+1];
    ULONG junk;
    PULONG  pdw;
    ULONG   start;


    RtlInitUnicodeString(&unicodeString, rgzAcpiKey);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = ZwOpenKey(&hKey, KEY_READ, &objectAttributes);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    RtlInitUnicodeString(&unicodeString, rgzAcpiStart);
    pvpi = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    status = ZwQueryValueKey(
                hKey,
                &unicodeString,
                KeyValuePartialInformation,
                pvpi,
                sizeof(buffer),
                &junk
                );

    if ( (NT_SUCCESS(status)) &&
         (pvpi->Type == REG_DWORD) &&
         (pvpi->DataLength == sizeof(ULONG)) )
    {
        pdw = (PULONG)&(pvpi->Data[0]);
        if (*pdw == 0) {
            ZwClose(hKey);
            return TRUE;
        }
    }

    ZwClose(hKey);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\ac97reg.h ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

#ifndef _AC97REG_H_
#define _AC97REG_H_

// We use enum types cause the compiler can check variable passing if it is
// an enum (otherwise you could pass any value). That doesn't save us from
// doing reasonable run time checks in that range.
enum AC97Register
{
    AC97REG_RESET = 0,
    AC97REG_MASTER_VOLUME,
    AC97REG_HPHONE_VOLUME,
    AC97REG_MMONO_VOLUME,
    AC97REG_MASTER_TONE,
    AC97REG_BEEP_VOLUME,
    AC97REG_PHONE_VOLUME,
    AC97REG_MIC_VOLUME,
    AC97REG_LINE_IN_VOLUME,
    AC97REG_CD_VOLUME,
    AC97REG_VIDEO_VOLUME,
    AC97REG_AUX_VOLUME,
    AC97REG_PCM_OUT_VOLUME,
    AC97REG_RECORD_SELECT,
    AC97REG_RECORD_GAIN,
    AC97REG_RECORD_GAIN_MIC,
    AC97REG_GENERAL,
    AC97REG_3D_CONTROL,
    AC97REG_RESERVED,
    AC97REG_POWERDOWN,

    // AC97-2.0 registers
    AC97REG_EXT_AUDIO_ID,
    AC97REG_EXT_AUDIO_CTRL,
    AC97REG_FRONT_SAMPLERATE,
    AC97REG_SURROUND_SAMPLERATE,
    AC97REG_LFE_SAMPLERATE,
    AC97REG_RECORD_SAMPLERATE,
    AC97REG_MIC_SAMPLERATE,
    AC97REG_CENTER_LFE_VOLUME,
    AC97REG_SURROUND_VOLUME,
    AC97REG_RESERVED2,

    // Modem registers from 0x3C to 0x58 (next 15 enums)
    // Vendor Reserved = 0x5A-0x7A (next 16 enums)

    // Vendor IDs
    AC97REG_VENDOR_ID1 = 0x3E,      // thats register address 0x7C
    AC97REG_VENDOR_ID2,

    // Defines an invalid register. Likewise, this is the highest
    // possible value that can be used.
    AC97REG_INVALID
};

#if (DBG)
// Note: This array only has the first 29 registers defined.
//       There are many more.
const PCHAR RegStrings[] =
{
    "REG_RESET",
    "REG_MASTER_VOLUME",
    "REG_HPHONE_VOLUME",
    "REG_MMONO_VOLUME",
    "REG_MASTER_TONE",
    "REG_BEEP_VOLUME",
    "REG_PHONE_VOLUME",
    "REG_MIC_VOLUME",
    "REG_LINEIN_VOLUME",
    "REG_CD_VOLUME",
    "REG_VIDEO_VOLUME",
    "REG_AUX_VOLUME",
    "REG_PCMOUT_VOLUME",
    "REG_RECORD_SELECT",
    "REG_RECORD_GAIN",
    "REG_RECORD_GAIN_MIC",
    "REG_GENERAL",
    "REG_3D_CONTROL",
    "REG_RESERVED",
    "REG_POWERDOWN",
    "REG_EXT_AUDIO_ID",
    "REG_EXT_AUDIO_CTRL",
    "REG_FRONT_SAMPLERATE",
    "REG_SURROUND_SAMPLERATE",
    "REG_LFE_SAMPLERATE",
    "REG_RECORD_SAMPLERATE",
    "REG_MIC_SAMPLERATE",
    "REG_CENTER_LFE_VOLUME",
    "REG_SURROUND_VOLUME",
    "REG_RESERVED2"
};
#endif

// This array maps the node controls to the AC97 registers.
// E.g. if you mute the master volume control you should modify AC97
// register AC97REG_MASTER_VOLUME
typedef struct {
    AC97Register    reg;    // we would only need one byte, but enums are int
    WORD            mask;   // registers are 16 bit.
} tMapNodeToReg;

const tMapNodeToReg stMapNodeToReg[] =
{
    // TODO: loopback
    {AC97REG_PCM_OUT_VOLUME, 0x1F1F},   // NODE_WAVEOUT_VOLUME
    {AC97REG_PCM_OUT_VOLUME, 0x8000},   // NODE_WAVEOUT_MUTE
    {AC97REG_GENERAL, 0x8000},          // NODE_VIRT_WAVEOUT_3D_BYPASS
    {AC97REG_BEEP_VOLUME, 0x001E},      // NODE_PCBEEP_VOLUME
    {AC97REG_BEEP_VOLUME, 0x8000},      // NODE_PCBEEP_MUTE
    {AC97REG_PHONE_VOLUME, 0x001F},     // NODE_PHONE_VOLUME
    {AC97REG_PHONE_VOLUME, 0x8000},     // NODE_PHONE_MUTE
    {AC97REG_GENERAL, 0x0100},          // NODE_MIC_SELECT
    {AC97REG_MIC_VOLUME, 0x0040},       // NODE_MIC_BOOST
    {AC97REG_MIC_VOLUME, 0x001F},       // NODE_MIC_VOLUME
    {AC97REG_MIC_VOLUME, 0x8000},       // NODE_MIC_MUTE
    {AC97REG_LINE_IN_VOLUME, 0x1F1F},   // NODE_LINEIN_VOLUME
    {AC97REG_LINE_IN_VOLUME, 0x8000},   // NODE_LINEIN_MUTE
    {AC97REG_CD_VOLUME, 0x1F1F},        // NODE_CD_VOLUME
    {AC97REG_CD_VOLUME, 0x8000},        // NODE_CD_MUTE
    {AC97REG_VIDEO_VOLUME, 0x1F1F},     // NODE_VIDEO_VOLUME
    {AC97REG_VIDEO_VOLUME, 0x8000},     // NODE_VIDEO_MUTE
    {AC97REG_AUX_VOLUME, 0x1F1F},       // NODE_AUX_VOLUME
    {AC97REG_AUX_VOLUME, 0x8000},       // NODE_AUX_MUTE
    {AC97REG_INVALID, 0x0000},          // NODE_MAIN_MIX doesn't has controls
    {AC97REG_3D_CONTROL, 0x0F00},       // NODE_VIRT_3D_CENTER
    {AC97REG_3D_CONTROL, 0x000F},       // NODE_VIRT_3D_DEPTH
    {AC97REG_GENERAL, 0x2000},          // NODE_VIRT_3D_ENABLE
    {AC97REG_INVALID, 0x0000},          // NODE_BEEP_MIX doesn't has controls
    {AC97REG_MASTER_TONE, 0x0F00},      // NODE_BASS
    {AC97REG_MASTER_TONE, 0x000F},      // NODE_TREBLE
    {AC97REG_GENERAL, 0x1000},          // NODE_LOUDNESS
    {AC97REG_GENERAL, 0x4000},          // NODE_SIMUL_STEREO
    {AC97REG_MASTER_VOLUME, 0x3F3F},    // NODE_MASTEROUT_VOLUME
    {AC97REG_MASTER_VOLUME, 0x8000},    // NODE_MASTEROUT_MUTE
    {AC97REG_HPHONE_VOLUME, 0x3F3F},    // NODE_HPHONE_VOLUME
    {AC97REG_HPHONE_VOLUME, 0x8000},    // NODE_HPHONE_MUTE
    {AC97REG_GENERAL, 0x0200},          // NODE_MONOOUT_SELECT
    {AC97REG_MMONO_VOLUME, 0x803F},     // NODE_VIRT_MONOOUT_VOLUME1
    {AC97REG_MMONO_VOLUME, 0x803F},     // NODE_VIRT_MONOOUT_VOLUME2
    {AC97REG_RECORD_SELECT, 0x0707},    // NODE_WAVEIN_SELECT
    {AC97REG_RECORD_GAIN, 0x0F0F},      // NODE_VIRT_MASTER_INPUT_VOLUME1
    {AC97REG_RECORD_GAIN, 0x0F0F},      // NODE_VIRT_MASTER_INPUT_VOLUME2
    {AC97REG_RECORD_GAIN, 0x0F0F},      // NODE_VIRT_MASTER_INPUT_VOLUME3
    {AC97REG_RECORD_GAIN, 0x0F0F},      // NODE_VIRT_MASTER_INPUT_VOLUME4
    {AC97REG_RECORD_GAIN, 0x0F0F},      // NODE_VIRT_MASTER_INPUT_VOLUME5
    {AC97REG_RECORD_GAIN, 0x0F0F},      // NODE_VIRT_MASTER_INPUT_VOLUME6
    {AC97REG_RECORD_GAIN, 0x0F0F},      // NODE_VIRT_MASTER_INPUT_VOLUME7
    {AC97REG_RECORD_GAIN, 0x0F0F},      // NODE_VIRT_MASTER_INPUT_VOLUME8
    {AC97REG_RECORD_GAIN_MIC, 0x000F},  // NODE_MICIN_VOLUME
    {AC97REG_RECORD_GAIN_MIC, 0x8000},  // NODE_MICIN_MUTE
    {AC97REG_SURROUND_VOLUME, 0x3F3F},  // NODE_SURROUND_VOLUME
    {AC97REG_SURROUND_VOLUME, 0x8080},  // NODE_SURROUND_MUTE
    {AC97REG_CENTER_LFE_VOLUME, 0x3F00},// NODE_CENTER_VOLUME
    {AC97REG_CENTER_LFE_VOLUME, 0x8000},// NODE_CENTER_MUTE
    {AC97REG_CENTER_LFE_VOLUME, 0x003F},// NODE_LFE_VOLUME
    {AC97REG_CENTER_LFE_VOLUME, 0x0080},// NODE_LFE_MUTE
    {AC97REG_MASTER_VOLUME, 0x3F3F},    // NODE_FRONT_VOLUME
    {AC97REG_MASTER_VOLUME, 0x8000},    // NODE_FRONT_MUTE
    {AC97REG_INVALID, 0x0000},          // NODE_VIRT_MASTERMONO_VOLUME doesn't have controls
    {AC97REG_INVALID, 0x0000}           // NODE_VIRT_MASTERMONO_MUTE doesn't have controls
};

#endif  //_AC97REG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\cpl\version.h ===
/********************************************************************************
**    Copyright (c) 2000 Microsoft Corporation. All Rights Reserved.
********************************************************************************/

//
//  Version Info.
//
#include <winver.h>
#include <ntverp.h>

#define VER_FILETYPE                   VFT_DLL
#define VER_FILESUBTYPE                VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR        "AC97 Control Panel"
#define VER_INTERNALNAME_STR           "ac97cpl.cpl"
#define VER_LEGALCOPYRIGHT_YEARS       "2000"
#define VER_ORIGINALFILENAME_STR       "ac97cpl.cpl"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\cpl\resource.h ===
/********************************************************************************
**    Copyright (c) 2000 Microsoft Corporation. All Rights Reserved.
********************************************************************************/

#define IDI_AC97CPL             100
#define IDS_AC97CPL             1000
#define IDS_AC97CPLINFO         1100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\prvprop.h ===
//////////////////////////////////////////////////////////////////////////
// This header file is only used if you compile the driver with the switch
// INCLUDE_PRIVATE_PROPERTY defined. Additionally, this header file is
// also used by the property page sample.
//
// This header file defines the private property (the GUID) and the
// "messages" therin. It also defines the structure passed down.
//

//
// The GUID was generated with guidgen.exe
//

// This is the GUID for the private property request.
#define STATIC_KSPROPSETID_Private \
    0x2aa7a0b1L, 0x9f78, 0x4606, 0xb8, 0x82, 0x66, 0xb7, 0xf, 0x2, 0x26, 0x37
DEFINE_GUIDSTRUCT("2AA7A0B1-9F78-4606-B882-66B70F022637", KSPROPSETID_Private);
#define KSPROPSETID_Private DEFINE_GUIDNAMED(KSPROPSETID_Private)


// Define the method in the property. You can have multiple methods defined
// for one private property ...
const int KSPROPERTY_AC97_FEATURES = 1;
#ifdef PROPERTY_SHOW_SET
    const int KSPROPERTY_AC97_SAMPLE_SET = 2;
#endif

// This is the enum for the volume controls.
enum VolumeControl
{
    VolumeDisabled,
    Volume5bit,
    Volume6bit
};

// This is the enum for the DAC or ADC resolution.
enum Resolution
{
   Resolution16bit,
   Resolution18bit,
   Resolution20bit
};

// Structure passed in the private property request with method
// KSPROPERTY_AC97_FEATURES.
typedef struct
{
  VolumeControl MasterVolume;
  VolumeControl HeadphoneVolume;
  VolumeControl MonoOutVolume;
  Resolution    DAC;
  Resolution    ADC;
  int           n3DTechnique;
  BOOLEAN       bMicInPresent;
  BOOLEAN       bVSRPCM;
  BOOLEAN       bDSRPCM;
  BOOLEAN       bVSRMIC;
  BOOLEAN       bCenterDAC;
  BOOLEAN       bSurroundDAC;
  BOOLEAN       bLFEDAC;
} tAC97Features;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\common.cpp ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

// Every debug output has "Modulname text"
static char STR_MODULENAME[] = "ICH Common: ";

#include "common.h"


/*****************************************************************************
 * Static Members
 *****************************************************************************
 */

//
// This is the register cache including registry names and default values. The
// first WORD contains the register value and the second WORD contains a flag.
// Currently, we only set SHREG_INVALID if we have to read the register at
// startup (that's true when there is no constant default value for the
// register).  Note that we cache the registers only to prevent read access to
// the AC97 CoDec during runtime, because this is slow (40us).
// We only set SHREG_INIT if we want to set the register to default at driver
// startup.  If needed, the third field contains the registry name and the
// forth field contains a default value that is used when there is no registry
// entry.
// The flag SHREG_NOCACHE is used when we don't want to cache the register
// at all.  This is neccessary for status registers and sample rate registers.
//
tAC97Registers CAdapterCommon::m_stAC97Registers[] =
{
{0x0000, SHREG_INVALID, NULL,               0},         // AC97REG_RESET
{0x8000, SHREG_INIT,    L"MasterVolume",    0x0000},    // AC97REG_MASTER_VOLUME
{0x8000, SHREG_INIT,    L"HeadphoneVolume", 0x0000},    // AC97REG_HPHONE_VOLUME
{0x8000, SHREG_INIT,    L"MonooutVolume",   0x0000},    // AC97REG_MMONO_VOLUME
{0x0F0F, SHREG_INIT,    L"ToneControls",    0x0F0F},    // AC97REG_MASTER_TONE
{0x0000, SHREG_INVALID |
         SHREG_INIT,    L"BeepVolume",      0x0000},    // AC97REG_BEEP_VOLUME
{0x8008, SHREG_INIT,    L"PhoneVolume",     0x8008},    // AC97REG_PHONE_VOLUME
{0x8008, SHREG_INIT,    L"MicVolume",       0x8008},    // AC97REG_MIC_VOLUME
{0x8808, SHREG_INIT,    L"LineInVolume",    0x0808},    // AC97REG_LINE_IN_VOLUME
{0x8808, SHREG_INIT,    L"CDVolume",        0x0808},    // AC97REG_CD_VOLUME
{0x8808, SHREG_INIT,    L"VideoVolume",     0x0808},    // AC97REG_VIDEO_VOLUME
{0x8808, SHREG_INIT,    L"AUXVolume",       0x0808},    // AC97REG_AUX_VOLUME
{0x8808, SHREG_INIT,    L"WaveOutVolume",   0x0808},    // AC97REG_PCM_OUT_VOLUME
{0x0000, SHREG_INIT,    L"RecordSelect",    0x0404},    // AC97REG_RECORD_SELECT
{0x8000, SHREG_INIT,    L"RecordGain",      0x0000},    // AC97REG_RECORD_GAIN
{0x8000, SHREG_INIT,    L"RecordGainMic",   0x0000},    // AC97REG_RECORD_GAIN_MIC
{0x0000, SHREG_INIT,    L"GeneralPurpose",  0x0000},    // AC97REG_GENERAL
{0x0000, SHREG_INIT,    L"3DControl",       0x0000},    // AC97REG_3D_CONTROL
{0x0000, SHREG_NOCACHE, NULL,               0},         // AC97REG_RESERVED
{0x0000, SHREG_NOCACHE |
         SHREG_INIT,    L"PowerDown",       0},         // AC97REG_POWERDOWN
// AC97-2.0 registers
{0x0000, SHREG_INVALID, NULL,               0},         // AC97REG_EXT_AUDIO_ID
{0x0000, SHREG_NOCACHE |
         SHREG_INIT,    L"ExtAudioCtrl",    0x4001},    // AC97REG_EXT_AUDIO_CTRL
{0xBB80, SHREG_NOCACHE, NULL,               0},         // AC97REG_FRONT_SAMPLERATE
{0xBB80, SHREG_NOCACHE, NULL,               0},         // AC97REG_SURROUND_SAMPLERATE
{0xBB80, SHREG_NOCACHE, NULL,               0},         // AC97REG_LFE_SAMPLERATE
{0xBB80, SHREG_NOCACHE, NULL,               0},         // AC97REG_RECORD_SAMPLERATE
{0xBB80, SHREG_NOCACHE, NULL,               0},         // AC97REG_MIC_SAMPLERATE
{0x8080, SHREG_INIT,    L"CenterLFEVolume", 0x0000},    // AC97REG_CENTER_LFE_VOLUME
{0x8080, SHREG_INIT,    L"SurroundVolume",  0x0000},    // AC97REG_SURROUND_VOLUME
{0x0000, SHREG_NOCACHE, NULL,               0}          // AC97REG_RESERVED2

// We leave the other values blank.  There would be a huge gap with 31
// elements that are currently unused, and then there would be 2 other
// (used) values, the vendor IDs.  We just force a read from the vendor 
// IDs in the end of ProbeHWConfig to fill the cache.
};


//
// This is the hardware configuration information.  The first struct is for 
// nodes, which we default to FALSE.  The second struct is for Pins, which 
// contains the configuration (FALSE) and the registry string which is the
// reason for making a static struct so we can just fill in the name.
//
tHardwareConfig CAdapterCommon::m_stHardwareConfig =
{
    // Nodes
    {{FALSE}, {FALSE}, {FALSE}, {FALSE}, {FALSE}, {FALSE}, {FALSE}, {FALSE},
     {FALSE}, {FALSE}, {FALSE}, {FALSE}, {FALSE}, {FALSE}, {FALSE}, {FALSE},
     {FALSE}},
    // Pins
    {{FALSE, L"DisablePCBeep"},     // PINC_PCBEEP_PRESENT
     {FALSE, L"DisablePhone"},      // PINC_PHONE_PRESENT
     {FALSE, L"DisableMic2"},       // PINC_MIC2_PRESENT
     {FALSE, L"DisableVideo"},      // PINC_VIDEO_PRESENT
     {FALSE, L"DisableAUX"},        // PINC_AUX_PRESENT
     {FALSE, L"DisableHeadphone"},  // PINC_HPOUT_PRESENT
     {FALSE, L"DisableMonoOut"},    // PINC_MONOOUT_PRESENT
     {FALSE, L"DisableMicIn"},      // PINC_MICIN_PRESENT
     {FALSE, L"DisableMic"},        // PINC_MIC_PRESENT
     {FALSE, L"DisableLineIn"},     // PINC_LINEIN_PRESENT
     {FALSE, L"DisableCD"},         // PINC_CD_PRESENT
     {FALSE, L"DisableSurround"},   // PINC_SURROUND_PRESENT
     {FALSE, L"DisableCenterLFE"}}  // PINC_CENTER_LFE_PRESENT
};


#pragma code_seg("PAGE")
/*****************************************************************************
 * NewAdapterCommon
 *****************************************************************************
 * Create a new adapter common object.
 */
NTSTATUS NewAdapterCommon
(
    OUT PUNKNOWN   *Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN    UnknownOuter    OPTIONAL,
    IN  POOL_TYPE   PoolType
)
{
    PAGED_CODE ();

    ASSERT (Unknown);

    DOUT (DBG_PRINT, ("[NewAdapterCommon]"));

    STD_CREATE_BODY_
    (
        CAdapterCommon,
        Unknown,
        UnknownOuter,
        PoolType,
        PADAPTERCOMMON
    );
}   


/*****************************************************************************
 * CAdapterCommon::Init
 *****************************************************************************
 * Initialize the adapter common object -> initialize and probe HW.
 * Pass only checked resources.
 */
STDMETHODIMP_(NTSTATUS) CAdapterCommon::Init
(
    IN  PRESOURCELIST   ResourceList,
    IN  PDEVICE_OBJECT  DeviceObject
)
{
    PAGED_CODE ();

    ASSERT (ResourceList);
    ASSERT (DeviceObject);

    NTSTATUS ntStatus = STATUS_SUCCESS;

    DOUT (DBG_PRINT, ("[CAdapterCommon::Init]"));
        
    //
    // Set the topology pointer to NULL.
    //
    m_Topology = NULL;
    
    //
    // Save the device object
    //
    m_pDeviceObject = DeviceObject;

    //
    // Get the base address for the AC97 codec and bus master.
    //
    ASSERT (ResourceList->FindTranslatedPort (0));
    m_pCodecBase = (PUSHORT)ResourceList->FindTranslatedPort (0)->
                           u.Port.Start.QuadPart;

    ASSERT (ResourceList->FindTranslatedPort (1));
    m_pBusMasterBase = (PUCHAR)ResourceList->FindTranslatedPort (1)->
                              u.Port.Start.QuadPart;

    DOUT (DBG_SYSINFO, ("Configuration:\n"
                        "   Bus Master = 0x%X\n"
                        "   Codec      = 0x%X",
                        m_pBusMasterBase, m_pCodecBase));

    //
    // Set m_bDirectRead to TRUE so that all AC97 register read and
    // writes are going directly to the HW
    //
    m_bDirectRead = TRUE;

    //
    // Initialize the hardware.
    //
    ntStatus = InitAC97 ();
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;
    
    //
    // Probe hardware configuration
    //
    ntStatus = ProbeHWConfig ();
    if (!NT_SUCCESS (ntStatus))
    {
        DOUT (DBG_ERROR, ("Probing of hardware configuration failed!"));
        return ntStatus;
    }

    //
    // Now, every AC97 read access goes to the cache.
    //
    m_bDirectRead = FALSE;

    //
    // Restore the AC97 registers now.
    //
#if (DBG)
    DumpConfig ();
#endif
    ntStatus = SetAC97Default ();

    //
    // Initialize the device state.
    //
    m_PowerState = PowerDeviceD0;

    return ntStatus;
}


/*****************************************************************************
 * CAdapterCommon::~CAdapterCommon
 *****************************************************************************
 * Destructor.
 */
CAdapterCommon::~CAdapterCommon ()
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[CAdapterCommon::~CAdapterCommon]"));
}


#if (DBG)
/*****************************************************************************
 * CAdapterCommon::DumpConfig
 *****************************************************************************
 * Dumps the HW configuration for the AC97 codec.
 */
void CAdapterCommon::DumpConfig (void)
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[CAdapterCommon::DumpConfig]"));

    //
    // Print debug output for MICIN.
    //
    if (GetPinConfig (PINC_MICIN_PRESENT))
    {
        DOUT (DBG_PROBE, ("MICIN found"));
    }
    else
    {
        DOUT (DBG_PROBE, ("No MICIN found"));
    }

    //
    // Print debug output for tone controls.
    //
    if (GetNodeConfig (NODEC_TONE_PRESENT))
    {
        DOUT (DBG_PROBE, ("Tone controls found"));
    }
    else
    {
        DOUT (DBG_PROBE, ("No tone controls found"));
    }

    //
    // Print debug output for mono out.
    //
    if (!GetPinConfig (PINC_MONOOUT_PRESENT))
    {
        DOUT (DBG_PROBE, ("No mono out found"));
    }

    //
    // Print debug output for headphones.
    //
    if (!GetPinConfig (PINC_HPOUT_PRESENT))
    {
        DOUT (DBG_PROBE, ("No headphone out found"));
    }

    //
    // Print debug output for loudness.
    //
    if (GetNodeConfig (NODEC_LOUDNESS_PRESENT))
    {
        DOUT (DBG_PROBE, ("Loudness found"));
    }
    else
    {
        DOUT (DBG_PROBE, ("No Loudness found"));
    }

    //
    // Print debug output for 3D.
    //
    if (GetNodeConfig (NODEC_3D_PRESENT))
    {
        DOUT (DBG_PROBE, ("3D controls found"));
    }
    else
    {
        DOUT (DBG_PROBE, ("No 3D controls found"));
    }

    //
    // Print debug output for pc beep.
    //
    if (GetPinConfig (PINC_PCBEEP_PRESENT))
    {
        DOUT (DBG_PROBE, ("PC beep found"));
    }
    else
    {
        DOUT (DBG_PROBE, ("No PC beep found"));
    }

    //
    // Print debug output for phone line (or mono line input).
    //
    if (GetPinConfig (PINC_PHONE_PRESENT))
    {
        DOUT (DBG_PROBE, ("Phone found"));
    }
    else
    {
        DOUT (DBG_PROBE, ("No Phone found"));
    }

    //
    // Print debug output for video.
    //
    if (GetPinConfig (PINC_VIDEO_PRESENT))
    {
        DOUT (DBG_PROBE, ("Video in found"));
    }
    else
    {
        DOUT (DBG_PROBE, ("No Video in found"));
    }

    //
    // Print debug output for AUX.
    //
    if (GetPinConfig (PINC_AUX_PRESENT))
    {
        DOUT (DBG_PROBE, ("AUX in found"));
    }
    else
    {
        DOUT (DBG_PROBE, ("No AUX in found"));
    }

    //
    // Print debug output for second miorophone.
    //
    if (GetPinConfig (PINC_MIC2_PRESENT))
    {
        DOUT (DBG_PROBE, ("MIC2 found"));
    }
    else
    {
        DOUT (DBG_PROBE, ("No MIC2 found"));
    }
    
    //
    // Print debug output for 3D stuff.
    //
    if (GetNodeConfig (NODEC_3D_PRESENT))
    {
        if (GetNodeConfig (NODEC_3D_CENTER_ADJUSTABLE))
        {
            DOUT (DBG_PROBE, ("Adjustable 3D center control found"));
        }
        if (GetNodeConfig (NODEC_3D_DEPTH_ADJUSTABLE))
        {
            DOUT (DBG_PROBE, ("Nonadjustable 3D depth control found"));
        }
    }

    //
    // Print debug output for quality of master volume.
    //
    if (GetNodeConfig (NODEC_6BIT_MASTER_VOLUME))
    {
        DOUT (DBG_PROBE, ("6bit master out found"));
    }
    else
    {
        DOUT (DBG_PROBE, ("5bit master out found"));
    }

    //
    // Print debug output for quality of headphones volume.
    //
    if (GetPinConfig (PINC_HPOUT_PRESENT))
    {
        if (GetNodeConfig (NODEC_6BIT_HPOUT_VOLUME))
        {
            DOUT (DBG_PROBE, ("6bit headphone out found"));
        }
        else
        {
            DOUT (DBG_PROBE, ("5bit headphone out found"));
        }
    }

    //
    // Print debug output for quality of mono out volume.
    //
    if (GetPinConfig (PINC_MONOOUT_PRESENT))
    {
        if (GetNodeConfig (NODEC_6BIT_MONOOUT_VOLUME))
        {
            DOUT (DBG_PROBE, ("6bit mono out found"));
        }
        else
        {
            DOUT (DBG_PROBE, ("5bit mono out found"));
        }
    }

    //
    // Print sample rate information.
    //
    if (GetNodeConfig (NODEC_PCM_VARIABLERATE_SUPPORTED))
    {
        DOUT (DBG_PROBE, ("PCM variable sample rate supported"));
    }
    else
    {
        DOUT (DBG_PROBE, ("only 48KHz PCM supported"));
    }

    //
    // Print double rate information.
    //
    if (GetNodeConfig (NODEC_PCM_DOUBLERATE_SUPPORTED))
    {
        DOUT (DBG_PROBE, ("PCM double sample rate supported"));
    }

    //
    // Print mic rate information.
    //
    if (GetNodeConfig (NODEC_MIC_VARIABLERATE_SUPPORTED))
    {
        DOUT (DBG_PROBE, ("MIC variable sample rate supported"));
    }
    else
    {
        DOUT (DBG_PROBE, ("only 48KHz MIC supported"));
    }

    // print DAC information
    if (GetNodeConfig (NODEC_CENTER_DAC_PRESENT))
    {
        DOUT (DBG_PROBE, ("center DAC found"));
    }
    if (GetNodeConfig (NODEC_SURROUND_DAC_PRESENT))
    {
        DOUT (DBG_PROBE, ("surround DAC found"));
    }
    if (GetNodeConfig (NODEC_LFE_DAC_PRESENT))
    {
        DOUT (DBG_PROBE, ("LFE DAC found"));
    }
}
#endif

/*****************************************************************************
 * CAdapterCommon::NonDelegatingQueryInterface
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 * We basically just check any GUID we know and return this object in case we
 * know it.
 */
STDMETHODIMP_(NTSTATUS) CAdapterCommon::NonDelegatingQueryInterface
(
    IN  REFIID  Interface,
    OUT PVOID * Object
)
{
    PAGED_CODE ();

    ASSERT (Object);

    DOUT (DBG_PRINT, ("[CAdapterCommon::NonDelegatingQueryInterface]"));

    // Is it IID_IUnknown?
    if (IsEqualGUIDAligned (Interface, IID_IUnknown))
    {
        *Object = (PVOID)(PUNKNOWN)(PADAPTERCOMMON)this;
    }
    else
    // or IID_IAdapterCommon ...
    if (IsEqualGUIDAligned (Interface, IID_IAdapterCommon))
    {
        *Object = (PVOID)(PADAPTERCOMMON)this;
    }
    else
    // or IID_IAdapterPowerManagement ...
    if (IsEqualGUIDAligned (Interface, IID_IAdapterPowerManagement))
    {
        *Object = (PVOID)(PADAPTERPOWERMANAGEMENT)this;
    }
    else
    {
        // nothing found, must be an unknown interface.
        *Object = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    //
    // We reference the interface for the caller.
    //
    ((PUNKNOWN)*Object)->AddRef ();
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CAdapterCommon::InitAC97
 *****************************************************************************
 * Initialize the ICH (without hosing the modem if it got installed first).
 */
NTSTATUS CAdapterCommon::InitAC97 (void)
{
    PAGED_CODE ();
    
    DOUT (DBG_PRINT, ("[CAdapterCommon::InitAC97]"));

    //
    // First check if there is an AC link to the primary CoDec.
    //
    NTSTATUS ntStatus = PrimaryCodecReady ();
    if (NT_SUCCESS (ntStatus))
    {
        //
        // Second, reset this primary CoDec; If this is a AMC97 CoDec, only
        // the audio registers are reset. If this is a MC97 CoDec, the CoDec
        // should ignore the reset (according to the spec).
        //
        WriteCodecRegister (AC97REG_RESET, 0x00, -1);
        
        ntStatus = PowerUpCodec ();
    }
    else
    {
        DOUT (DBG_ERROR, ("Initialization of AC97 CoDec failed."));
    }

    return ntStatus;
}

/*****************************************************************************
 * CAdapterCommon::Check6thBitSupport
 *****************************************************************************
 * Probes for 6th bit volume control support.
 * The passed parameters are the AC97 register that has the volume control and
 * the node config that should be set in this case.
 */
NTSTATUS CAdapterCommon::Check6thBitSupport
(
    IN AC97Register AC97Reg,
    IN TopoNodeConfig Config
)
{
    NTSTATUS    ntStatus;
    WORD        wCodecReg;
    WORD        wOriginal;

    // Read the current value.
    ntStatus = ReadCodecRegister (AC97Reg, &wOriginal);
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;
    
    // Write the 6th bit; for mono controls we write 0x20, for stereo
    // controls 0x2020.
    ntStatus = WriteCodecRegister (AC97Reg,
                    (AC97Reg == AC97REG_MMONO_VOLUME) ? 0x0020 : 0x2020, -1);
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    // And read back.
    ntStatus = ReadCodecRegister (AC97Reg, &wCodecReg);
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    // Check return. For mono 0x20 and for stereo 0x2020.
    if (((wCodecReg & 0x0020) && (AC97Reg == AC97REG_MMONO_VOLUME)) ||
        (wCodecReg & 0x2020))
    {
        SetNodeConfig (Config, TRUE);
    }
    else
    {
        SetNodeConfig (Config, FALSE);
    }

    // Restore original value.
    WriteCodecRegister (AC97Reg, wOriginal, -1);

    return ntStatus;
}

/*****************************************************************************
 * CAdapterCommon::ProbeHWConfig
 *****************************************************************************
 * Probes the hardware configuration.
 * If this function returns with an error, then the configuration is not
 * complete! Probing the registers is done by reading them (and comparing with
 * the HW default value) or when the default is unknown, writing to them and
 * reading back + restoring.
 * Additionally, we read the registry so that a HW vendor can overwrite (means
 * disable) found registers in case the adapter (e.g. video) is not visible to
 * the user (he can't plug in a video audio there).
 *
 * This is a very long function with all of the error checking!
 */
NTSTATUS CAdapterCommon::ProbeHWConfig (void)
{
    PAGED_CODE ();

    NTSTATUS ntStatus = STATUS_SUCCESS;
    DWORD    dwGlobalStatus;
    WORD     wCodecID;
    WORD     wCodecReg;

    DOUT (DBG_PRINT, ("[CAdapterCommon::ProbeHWConfig]"));

    //
    // Wait for the whatever 97 to complete reset and establish a link.
    //
    ntStatus = PrimaryCodecReady ();
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    //
    // Master volume is one of the supported registers on an AC97
    //
    ntStatus = ReadCodecRegister (AC97REG_MASTER_VOLUME, &wCodecReg);
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    // Default is x8000.
    if (wCodecReg != 0x8000)
        return STATUS_NO_SUCH_DEVICE;

    //
    // This gives us information about the AC97 CoDec
    //
    ntStatus = ReadCodecRegister (AC97REG_RESET, &wCodecID);
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    //
    // Fill out the configuration stuff.
    //

    SetPinConfig (PINC_MICIN_PRESENT, wCodecID & 0x0001);
    
    // Check if OEM wants to disable MIC record line.
    if (DisableAC97Pin (PINC_MICIN_PRESENT))
        SetPinConfig (PINC_MICIN_PRESENT, FALSE);

    // If we still have MIC record line, enable the DAC in ext. audio register.
    if (GetPinConfig (PINC_MICIN_PRESENT))
        // Enable ADC MIC.
        WriteCodecRegister (AC97REG_EXT_AUDIO_CTRL, 0, 0x4000);
    else
        // Disable ADC MIC.
        WriteCodecRegister (AC97REG_EXT_AUDIO_CTRL, 0x4000, 0x4000);

    //
    // Continue setting configuration information.
    //

    SetNodeConfig (NODEC_TONE_PRESENT, wCodecID & 0x0004);
    SetNodeConfig (NODEC_SIMUL_STEREO_PRESENT, wCodecID & 0x0008);
    SetPinConfig (PINC_HPOUT_PRESENT, wCodecID & 0x0010);
    
    // Check if OEM wants to disable headphone output.
    if (DisableAC97Pin (PINC_HPOUT_PRESENT))
        SetPinConfig (PINC_HPOUT_PRESENT, FALSE);

    SetNodeConfig (NODEC_LOUDNESS_PRESENT, wCodecID & 0x0020);
    SetNodeConfig (NODEC_3D_PRESENT, wCodecID & 0x7C00);

    //
    // Test for the input pins that are always there but could be disabled
    // by the HW vender
    //

    // Check if OEM wants to disable mic input.
    SetPinConfig (PINC_MIC_PRESENT, !DisableAC97Pin (PINC_MIC_PRESENT));
    
    // Check if OEM wants to disable line input.
    SetPinConfig (PINC_LINEIN_PRESENT, !DisableAC97Pin (PINC_LINEIN_PRESENT));

    // Check if OEM wants to disable CD input.
    SetPinConfig (PINC_CD_PRESENT, !DisableAC97Pin (PINC_CD_PRESENT));


    //
    // For the rest, we have to probe the registers.
    //

    //
    // Test for Mono out.
    //
    ntStatus = ReadCodecRegister (AC97REG_MMONO_VOLUME, &wCodecReg);
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    // Default is x8000.
    SetPinConfig (PINC_MONOOUT_PRESENT, (wCodecReg == 0x8000));

    // Check if OEM wants to disable mono output.
    if (DisableAC97Pin (PINC_MONOOUT_PRESENT))
        SetPinConfig (PINC_MONOOUT_PRESENT, FALSE);

    //
    // Test for PC beeper support.
    //
    ntStatus = ReadCodecRegister (AC97REG_BEEP_VOLUME, &wCodecReg);
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    // default is x0 or x8000. If it's 0x8000 then we know for sure that the
    // CoDec has a PcBeep, otherwise we have to check the register
    if (wCodecReg == 0x8000)
        SetPinConfig (PINC_PCBEEP_PRESENT, TRUE);
    else if (!wCodecReg)
    {
        // mute the pc beeper.
        ntStatus = WriteCodecRegister (AC97REG_BEEP_VOLUME, 0x8000, -1);
        if (!NT_SUCCESS (ntStatus))
            return ntStatus;

        // read back
        ntStatus = ReadCodecRegister (AC97REG_BEEP_VOLUME, &wCodecReg);
        if (!NT_SUCCESS (ntStatus))
            return ntStatus;

        if (wCodecReg == 0x8000)
        {
            // yep, we have support.
            SetPinConfig (PINC_PCBEEP_PRESENT, TRUE);
            // reset to default value.
            WriteCodecRegister (AC97REG_BEEP_VOLUME, 0x0, -1);
        }
        else
            // nope, not present
            SetPinConfig (PINC_PCBEEP_PRESENT, FALSE);
    }
    else
        // any other value then 0x0 and 0x8000.
        SetPinConfig (PINC_PCBEEP_PRESENT, FALSE);

    // Check if OEM wants to disable beeper support.
    if (DisableAC97Pin (PINC_PCBEEP_PRESENT))
        SetPinConfig (PINC_PCBEEP_PRESENT, FALSE);

    //
    // Test for phone support.
    //
    ntStatus = ReadCodecRegister (AC97REG_PHONE_VOLUME, &wCodecReg);
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    // Default is x8008.
    SetPinConfig (PINC_PHONE_PRESENT, (wCodecReg == 0x8008));

    // Check if OEM wants to disable phone input.
    if (DisableAC97Pin (PINC_PHONE_PRESENT))
        SetPinConfig (PINC_PHONE_PRESENT, FALSE);

    //
    // Test for video support.
    //
    ntStatus = ReadCodecRegister (AC97REG_VIDEO_VOLUME, &wCodecReg);
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    // Default is x8808.
    SetPinConfig (PINC_VIDEO_PRESENT, (wCodecReg == 0x8808));

    // Check if OEM wants to disable video input.
    if (DisableAC97Pin (PINC_VIDEO_PRESENT))
        SetPinConfig (PINC_VIDEO_PRESENT, FALSE);

    //
    // Test for Aux support.
    //
    ntStatus = ReadCodecRegister (AC97REG_AUX_VOLUME, &wCodecReg);
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    // Default is 0x8808.
    SetPinConfig (PINC_AUX_PRESENT, (wCodecReg == 0x8808));

    // Check if OEM wants to disable aux input.
    if (DisableAC97Pin (PINC_AUX_PRESENT))
        SetPinConfig (PINC_AUX_PRESENT, FALSE);

    //
    // Test for Mic2 source.
    //
    ntStatus = ReadCodecRegister (AC97REG_GENERAL, &wCodecReg);
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    // Test for Mic2 select bit.
    if (wCodecReg & 0x0100)
        SetPinConfig (PINC_MIC2_PRESENT, TRUE);
    else
    {
        // Select Mic2 as source.
        ntStatus = WriteCodecRegister (AC97REG_GENERAL, 0x0100, 0x0100);
        if (!NT_SUCCESS (ntStatus))
            return ntStatus;

        // Read back.
        ntStatus = ReadCodecRegister (AC97REG_GENERAL, &wCodecReg);
        if (!NT_SUCCESS (ntStatus))
            return ntStatus;

        if (wCodecReg & 0x0100)
        {
            // Yep, we have support so set it to the default value.
            SetPinConfig (PINC_MIC2_PRESENT, TRUE);
            // reset to default value.
            WriteCodecRegister (AC97REG_GENERAL, 0, 0x0100);
        }
        else
            SetPinConfig (PINC_MIC2_PRESENT, FALSE);
    }

    // Check if OEM wants to disable mic2 input.
    if (DisableAC97Pin (PINC_MIC2_PRESENT))
        SetPinConfig (PINC_MIC2_PRESENT, FALSE);

    //
    // Test the 3D controls.
    //
    if (GetNodeConfig (NODEC_3D_PRESENT))
    {
        //
        // First test for fixed 3D controls. Write default value ...
        //
        ntStatus = WriteCodecRegister (AC97REG_3D_CONTROL, 0, -1);
        if (!NT_SUCCESS (ntStatus))
            return ntStatus;

        // Read 3D register. Default is 0 when adjustable, otherwise it is
        // a fixed value.
        ntStatus = ReadCodecRegister (AC97REG_3D_CONTROL, &wCodecReg);
        if (!NT_SUCCESS (ntStatus))
            return ntStatus;

        //
        // Check center and depth separately.
        //

        // For center
        SetNodeConfig (NODEC_3D_CENTER_ADJUSTABLE, !(wCodecReg & 0x0F00));

        // For depth
        SetNodeConfig (NODEC_3D_DEPTH_ADJUSTABLE, !(wCodecReg & 0x000F));

        //
        // Test for adjustable controls.
        //
        WriteCodecRegister (AC97REG_3D_CONTROL, 0x0A0A, -1);

        // Read 3D register. Now it should be 0x0A0A for adjustable controls,
        // otherwise it is a fixed control or simply not there.
        ReadCodecRegister (AC97REG_3D_CONTROL, &wCodecReg);

        // Restore the default value
        WriteCodecRegister (AC97REG_3D_CONTROL, 0, -1);

        // Check the center control for beeing adjustable
        if (GetNodeConfig (NODEC_3D_CENTER_ADJUSTABLE) &&
            (wCodecReg & 0x0F00) != 0x0A00)
        {
            SetNodeConfig (NODEC_3D_CENTER_ADJUSTABLE, FALSE);
        }
        
        // Check the depth control for beeing adjustable
        if (GetNodeConfig (NODEC_3D_DEPTH_ADJUSTABLE) &&
            (wCodecReg & 0x000F) != 0x000A)
        {
            SetNodeConfig (NODEC_3D_DEPTH_ADJUSTABLE, FALSE);
        }
    }

    //
    // Check for 6th bit support in volume controls.  To check the 6th bit, 
    // we first have to write a value (with 6th bit set) and then read it 
    // back.  After that, we should restore the register to its default value.
    //

    //
    // Start with the master volume.
    //
    Check6thBitSupport (AC97REG_MASTER_VOLUME, NODEC_6BIT_MASTER_VOLUME);

    //
    // Check for a headphone volume control.
    //
    if (GetPinConfig (PINC_HPOUT_PRESENT))
    {
        Check6thBitSupport (AC97REG_HPHONE_VOLUME, NODEC_6BIT_HPOUT_VOLUME);
    }

    //
    // Mono out there?
    //
    if (GetPinConfig (PINC_MONOOUT_PRESENT))
    {
        Check6thBitSupport (AC97REG_MMONO_VOLUME, NODEC_6BIT_MONOOUT_VOLUME);
    }

    //
    // Get extended AC97 V2.0 information
    //
    ntStatus = ReadCodecRegister (AC97REG_EXT_AUDIO_ID, &wCodecReg);
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    //
    // Store the information
    //
    SetNodeConfig (NODEC_PCM_VARIABLERATE_SUPPORTED, wCodecReg & 0x0001);
    SetNodeConfig (NODEC_PCM_DOUBLERATE_SUPPORTED, wCodecReg & 0x0002);
    SetNodeConfig (NODEC_MIC_VARIABLERATE_SUPPORTED, wCodecReg & 0x0008);
    SetNodeConfig (NODEC_CENTER_DAC_PRESENT, wCodecReg & 0x0040);
    SetNodeConfig (NODEC_SURROUND_DAC_PRESENT, wCodecReg & 0x0080);
    SetNodeConfig (NODEC_LFE_DAC_PRESENT, wCodecReg & 0x0100);

    //
    // In case we have some features get some more information and program
    // the codec.
    //
    if (wCodecReg)
    {
        //
        // Enable variable sample rate in the control register and disable
        // double rate. Also enable all DACs.
        //
        WriteCodecRegister (AC97REG_EXT_AUDIO_CTRL, wCodecReg & 0x0009, 0x380B);

        //
        // Check for codecs that have only one sample rate converter. These
        // codecs will stick registers AC97REG_FRONT_SAMPLERATE and
        // AC97REG_RECORD_SAMPLERATE together.
        //
        if (GetNodeConfig (NODEC_PCM_VARIABLERATE_SUPPORTED))
        {
            // The default of the sample rate registers should be 0xBB80.
            WriteCodecRegister (AC97REG_FRONT_SAMPLERATE, 0xBB80, 0xFFFF);

            // Write 44.1KHz into record VSR, then check playback again.
            WriteCodecRegister (AC97REG_RECORD_SAMPLERATE, 0xAC44, 0xFFFF);
            ntStatus = ReadCodecRegister (AC97REG_FRONT_SAMPLERATE, &wCodecReg);
            WriteCodecRegister (AC97REG_RECORD_SAMPLERATE, 0xBB80, 0xFFFF);
            if (!NT_SUCCESS (ntStatus))
                return ntStatus;

            //
            // Set the flag accordingly
            //
            SetNodeConfig (NODEC_PCM_VSR_INDEPENDENT_RATES, (wCodecReg == 0xBB80));
        }

        //
        // Check multichanel support on the ICH.
        //
        if (GetNodeConfig (NODEC_SURROUND_DAC_PRESENT))
        {
            dwGlobalStatus = ReadBMControlRegister32 (GLOB_STA);
            
            //
            // Codec supports >2 chanel, does ICH too?
            //
            if ((GetNodeConfig (NODEC_CENTER_DAC_PRESENT) ||
                GetNodeConfig (NODEC_LFE_DAC_PRESENT)) &&
                (dwGlobalStatus & GLOB_STA_MC6))
            {
                SetPinConfig (PINC_CENTER_LFE_PRESENT, TRUE);
            }
            else
            {
                SetPinConfig (PINC_CENTER_LFE_PRESENT, FALSE);
            }

            //
            // Do we support at least 4 channels?
            //
            SetPinConfig (PINC_SURROUND_PRESENT, (dwGlobalStatus & GLOB_STA_MC4));
        }
        else
        {
            //
            // Only 2 channel (stereo) support.
            //
            SetPinConfig (PINC_CENTER_LFE_PRESENT, FALSE);
            SetPinConfig (PINC_SURROUND_PRESENT, FALSE);
        }
    }

    // Check if OEM wants to disable surround output.
    if (DisableAC97Pin (PINC_SURROUND_PRESENT))
        SetPinConfig (PINC_SURROUND_PRESENT, FALSE);
    
    // Check if OEM wants to disable center and LFE output.
    if (DisableAC97Pin (PINC_CENTER_LFE_PRESENT))
        SetPinConfig (PINC_CENTER_LFE_PRESENT, FALSE);

    //
    // Check the 6th bit support for the additional channels.
    //
    if (GetPinConfig (PINC_SURROUND_PRESENT))
        Check6thBitSupport (AC97REG_SURROUND_VOLUME, NODEC_6BIT_SURROUND_VOLUME);
    
    if (GetPinConfig (PINC_CENTER_LFE_PRESENT))
        Check6thBitSupport (AC97REG_CENTER_LFE_VOLUME, NODEC_6BIT_CENTER_LFE_VOLUME);

    //
    // We read these registers because they are dependent on the codec.
    //
    ReadCodecRegister (AC97REG_VENDOR_ID1, &wCodecReg);
    ReadCodecRegister (AC97REG_VENDOR_ID2, &wCodecReg);

    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CAdapterCommon::AcquireCodecSemiphore
 *****************************************************************************
 * Acquires the AC97 semiphore.  This can not be called at dispatch level
 * because it can timeout if a lower IRQL thread has the semaphore.
 */
NTSTATUS CAdapterCommon::AcquireCodecSemiphore ()
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[CAdapterCommon::AcquireCodecSemiphore]"));

    ULONG ulCount = 0;
    while (READ_PORT_UCHAR (m_pBusMasterBase + CAS) & CAS_CAS)
    {
        //
        // Do we want to give up??
        //
        if (ulCount++ > 100)
        {
            DOUT (DBG_ERROR, ("Cannot acquire semaphore."));
            return STATUS_IO_TIMEOUT;
        }

        //
        // Let's wait a little, 40us and then try again.
        //
        KeStallExecutionProcessor (40L);
    }

    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CAdapterCommon::ReadCodecRegister
 *****************************************************************************
 * Reads a AC97 register. Don't call at PASSIVE_LEVEL.
 */
STDMETHODIMP_(NTSTATUS) CAdapterCommon::ReadCodecRegister
(
    IN  AC97Register reg,
    OUT PWORD wData
)
{
    PAGED_CODE ();
    
    ASSERT (wData);
    ASSERT (reg < AC97REG_INVALID);    // audio can only be in the primary codec

    NTSTATUS ntStatus;
    ULONG    Status;

    DOUT (DBG_PRINT, ("[CAdapterCommon::ReadCodecRegister]"));
    
    //
    // Check if we have to access the HW directly.
    //
    if (m_bDirectRead || (m_stAC97Registers[reg].wFlags & SHREG_INVALID) ||
        (m_stAC97Registers[reg].wFlags & SHREG_NOCACHE))
    {
        //
        // Grab the codec access semiphore.
        //
        ntStatus = AcquireCodecSemiphore ();
        if (!NT_SUCCESS (ntStatus))
        {
            DOUT (DBG_ERROR, ("ReadCodecRegister couldn't acquire the semiphore"
                " for reg. %s", reg <= AC97REG_RESERVED2 ? RegStrings[reg] :
                                reg == AC97REG_VENDOR_ID1 ? "REG_VENDOR_ID1" :
                                reg == AC97REG_VENDOR_ID2 ? "REG_VENDOR_ID2" :
                                "REG_INVALID"));
            return ntStatus;
        }

        //
        // Read the data.
        //
        *wData = READ_PORT_USHORT (m_pCodecBase + reg);

        //
        // Check to see if the read was successful.
        //
        Status = READ_PORT_ULONG ((PULONG)(m_pBusMasterBase + GLOB_STA));
        if (Status & GLOB_STA_RCS)
        {
            //
            // clear the timeout bit
            //
            WRITE_PORT_ULONG ((PULONG)(m_pBusMasterBase + GLOB_STA), Status);
            *wData = 0;
            DOUT (DBG_ERROR, ("ReadCodecRegister timed out for register %s",
                    reg <= AC97REG_RESERVED2 ? RegStrings[reg] :
                    reg == AC97REG_VENDOR_ID1 ? "REG_VENDOR_ID1" :
                    reg == AC97REG_VENDOR_ID2 ? "REG_VENDOR_ID2" :
                    "REG_INVALID"));
            return STATUS_IO_TIMEOUT;
        } 
        
        //
        // Clear invalid flag
        //
        m_stAC97Registers[reg].wCache = *wData;
        m_stAC97Registers[reg].wFlags &= ~SHREG_INVALID;
        
        DOUT (DBG_REGS, ("AC97READ: %s = 0x%04x (HW)",
                reg <= AC97REG_RESERVED2 ? RegStrings[reg] :
                reg == AC97REG_VENDOR_ID1 ? "REG_VENDOR_ID1" :
                reg == AC97REG_VENDOR_ID2 ? "REG_VENDOR_ID2" : 
                "REG_INVALID", *wData));
    }
    else
    {
        //
        // Otherwise, use the value in the cache.
        //
        *wData = m_stAC97Registers[reg].wCache;
        DOUT (DBG_REGS, ("AC97READ: %s = 0x%04x (C)",
                reg <= AC97REG_RESERVED2 ? RegStrings[reg] :
                reg == AC97REG_VENDOR_ID1 ? "REG_VENDOR_ID1" :
                reg == AC97REG_VENDOR_ID2 ? "REG_VENDOR_ID2" : 
                "REG_INVALID", *wData));
    }

    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CAdapterCommon::WriteCodecRegister
 *****************************************************************************
 * Writes to a AC97 register.  This can only be done at passive level because
 * the AcquireCodecSemiphore call could fail!
 */
STDMETHODIMP_(NTSTATUS) CAdapterCommon::WriteCodecRegister
(
    IN  AC97Register reg,
    IN  WORD wData,
    IN  WORD wMask
)
{
    PAGED_CODE ();
    
    ASSERT (reg < AC97REG_INVALID);    // audio can only be in the primary codec

    WORD TempData = 0;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    DOUT (DBG_PRINT, ("[CAdapterCommon::WriteCodecRegister]"));

    //
    // No mask?  Could happen when you try to prg. left channel of a
    // mono volume.
    //
    if (!wMask)
        return STATUS_SUCCESS;

    //
    // Check to see if we are only writing specific bits.  If so, we want
    // to leave some bits in the register alone.
    //
    if (wMask != 0xffff)
    {
        //
        // Read the current register contents.
        //
        ntStatus = ReadCodecRegister (reg, &TempData);
        if (!NT_SUCCESS (ntStatus))
        {
            DOUT (DBG_ERROR, ("WriteCodecRegiser read for mask failed"));
            return ntStatus;
        }

        //
        // Do the masking.
        //
        TempData &= ~wMask;
        TempData |= (wMask & wData);
    }
    else
    {
        TempData = wData;
    }
    

    //
    // Grab the codec access semiphore.
    //
    ntStatus = AcquireCodecSemiphore ();
    if (!NT_SUCCESS (ntStatus))
    {
        DOUT (DBG_ERROR, ("WriteCodecRegister failed for register %s",
            reg <= AC97REG_RESERVED2 ? RegStrings[reg] :
            reg == AC97REG_VENDOR_ID1 ? "REG_VENDOR_ID1" :
            reg == AC97REG_VENDOR_ID2 ? "REG_VENDOR_ID2" : "REG_INVALID"));
        return ntStatus;
    }
            
    //
    // Write the data.
    //
    WRITE_PORT_USHORT (m_pCodecBase + reg, TempData);

    //
    // Update cache.
    //
    m_stAC97Registers[reg].wCache = TempData;
    
    DOUT (DBG_REGS, ("AC97WRITE: %s -> 0x%04x", 
                   reg <= AC97REG_RESERVED2 ? RegStrings[reg] :
                   reg == AC97REG_VENDOR_ID1 ? "REG_VENDOR_ID1" :
                   reg == AC97REG_VENDOR_ID2 ? "REG_VENDOR_ID2" : 
                   "REG_INVALID", TempData));
    
    
    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CAdapterCommon::PrimaryCodecReady
 *****************************************************************************
 * Checks whether the primary codec is present and ready.  This may take
 * awhile if we are bringing it up from a cold reset so give it a second
 * before giving up.
 */
NTSTATUS CAdapterCommon::PrimaryCodecReady (void)
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[CAdapterCommon::PrimaryCodecReady]"));

    
    //
    // Enable the AC link and raise the reset line.
    //
    DWORD dwRegValue = ReadBMControlRegister32 (GLOB_CNT);
    
    // If someone enabled GPI Interrupt Enable, then he hopefully handles that
    // too.
    dwRegValue = (dwRegValue | GLOB_CNT_COLD) & ~(GLOB_CNT_ACLOFF | GLOB_CNT_PRIE);
    WriteBMControlRegister (GLOB_CNT, dwRegValue);

    //
    // Wait for the Codec to be ready.
    //
    ULONG           WaitCycles = 200;
    LARGE_INTEGER   WaitTime = RtlConvertLongToLargeInteger (-50000);   // wait 5000us (5ms) relative

    do
    {
        if (READ_PORT_ULONG ((PULONG)(m_pBusMasterBase + GLOB_STA)) & 
            GLOB_STA_PCR)
        {
            return STATUS_SUCCESS;
        }

        KeDelayExecutionThread (KernelMode, FALSE, &WaitTime);
    } while (WaitCycles--);

    DOUT (DBG_ERROR, ("PrimaryCodecReady timed out!"));
    return STATUS_IO_TIMEOUT;
}


/*****************************************************************************
 * CAdapterCommon::PowerUpCodec
 *****************************************************************************
 * Sets the Codec to the highest power state and waits until the Codec reports
 * that the power state is reached.
 */
NTSTATUS CAdapterCommon::PowerUpCodec (void)
{
    PAGED_CODE ();

    WORD        wCodecReg;
    NTSTATUS    ntStatus;

    DOUT (DBG_PRINT, ("[CAdapterCommon::PowerUpCodec]"));

    //
    // Power up the Codec.
    //
    WriteCodecRegister (AC97REG_POWERDOWN, 0x00, -1);

    //
    // Wait for the Codec to be powered up.
    //
    ULONG           WaitCycles = 200;
    LARGE_INTEGER   WaitTime = RtlConvertLongToLargeInteger (-50000);   // wait 5000us (5ms) relative

    do
    {
        //
        // Read the power management register.
        //
        ntStatus = ReadCodecRegister (AC97REG_POWERDOWN, &wCodecReg);
        if (!NT_SUCCESS (ntStatus))
        {
            wCodecReg = 0;      // Will cause an error.
            break;
        }

        //
        // Check the power state. Should be ready.
        //
        if ((wCodecReg & 0x0f) == 0x0f)
            break;

        //
        // Let's wait a little, 5ms and then try again.
        //
        KeDelayExecutionThread (KernelMode, FALSE, &WaitTime);
    } while (WaitCycles--);

    // Check if we timed out.
    if ((wCodecReg & 0x0f) != 0x0f)
    {
        DOUT (DBG_ERROR, ("PowerUpCodec timed out. CoDec not powered up."));
        ntStatus = STATUS_DEVICE_NOT_READY;
    }

    return ntStatus;
}


/*****************************************************************************
 * CAdapterCommon::ProgramSampleRate
 *****************************************************************************
 * Programs the sample rate. If the rate cannot be programmed, the routine
 * restores the register and returns STATUS_UNSUCCESSFUL.
 * We don't handle double rate sample rates here, because the Intel ICH con-
 * troller cannot serve CoDecs with double rate or surround sound. If you want
 * to modify this driver for another AC97 controller, then you might want to
 * change this function too.
 */
STDMETHODIMP_(NTSTATUS) CAdapterCommon::ProgramSampleRate
(
    IN  AC97Register    Register,
    IN  DWORD           dwSampleRate
)
{
    PAGED_CODE ();

    WORD     wOldRateReg, wCodecReg;
    NTSTATUS ntStatus;

    DOUT (DBG_PRINT, ("[CAdapterCommon::ProgramSampleRate]"));

    //
    // Check if we support variable sample rate.
    //
    switch(Register)
    {
        case AC97REG_MIC_SAMPLERATE:
            //
            // Variable sample rate supported?
            //
            if (GetNodeConfig (NODEC_MIC_VARIABLERATE_SUPPORTED))
            {
                // Range supported?
                if (dwSampleRate > 48000ul)
                {
                    // Not possible.
                    DOUT (DBG_VSR, ("Samplerate %d not supported", dwSampleRate));
                    return STATUS_NOT_SUPPORTED;
                }
            }
            else
            {
                // Only 48000KHz possible.
                if (dwSampleRate != 48000ul)
                {
                    DOUT (DBG_VSR, ("Samplerate %d not supported", dwSampleRate));
                    return STATUS_NOT_SUPPORTED;
                }

                return STATUS_SUCCESS;
            }
            break;

        case AC97REG_FRONT_SAMPLERATE:
        case AC97REG_SURROUND_SAMPLERATE:
        case AC97REG_LFE_SAMPLERATE:
        case AC97REG_RECORD_SAMPLERATE:
            //
            // Variable sample rate supported?
            //
            if (GetNodeConfig (NODEC_PCM_VARIABLERATE_SUPPORTED))
            {
                //
                // Check range supported
                //
                if (dwSampleRate > 48000ul)
                {
                    DOUT (DBG_VSR, ("Samplerate %d not supported", dwSampleRate));
                    return STATUS_NOT_SUPPORTED;
                }
            }
            else
            {
                // Only 48KHz possible.
                if (dwSampleRate != 48000ul)
                {
                    DOUT (DBG_VSR, ("Samplerate %d not supported", dwSampleRate));
                    return STATUS_NOT_SUPPORTED;
                }

                return STATUS_SUCCESS;
            }
            break;

        default:
            DOUT (DBG_ERROR, ("Invalid sample rate register!"));
            return STATUS_UNSUCCESSFUL;
    }

    
    //
    // Save the old sample rate register.
    //
    ntStatus = ReadCodecRegister (Register, &wOldRateReg);
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;
    
    //
    // program the rate.
    //
    ntStatus = WriteCodecRegister (Register, (WORD)dwSampleRate, -1);
    if (!NT_SUCCESS (ntStatus))
    {
        DOUT (DBG_ERROR, ("Cannot program sample rate."));
        return ntStatus;
    }

    //
    // Read it back.
    //
    ntStatus = ReadCodecRegister (Register, &wCodecReg);
    if (!NT_SUCCESS (ntStatus))
    {
        DOUT (DBG_ERROR, ("Cannot read sample rate."));
        return ntStatus;
    }

    //
    // Validate.
    //
    if (wCodecReg != dwSampleRate)
    {
        //
        // restore sample rate and ctrl register.
        //
        WriteCodecRegister (Register, wOldRateReg, -1);
        
        DOUT (DBG_VSR, ("Samplerate %d not supported", dwSampleRate));
        return STATUS_NOT_SUPPORTED;
    }
    
    DOUT (DBG_VSR, ("Samplerate changed to %d.", dwSampleRate));
    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CAdapterCommon::PowerChangeState
 *****************************************************************************
 * Change power state for the device.  We handle the codec, PowerChangeNotify 
 * in the wave miniport handles the DMA registers.
 */
STDMETHODIMP_(void) CAdapterCommon::PowerChangeState
(
    IN  POWER_STATE NewState
)
{
    PAGED_CODE ();

    NTSTATUS ntStatus = STATUS_SUCCESS;

    DOUT (DBG_PRINT, ("[CAdapterCommon::PowerChangeNotify]"));

    //
    // Check to see if this is the current power state.
    //
    if (NewState.DeviceState == m_PowerState)
    {
        DOUT (DBG_POWER, ("New device state equals old state."));
        return;
    }

    //
    // Check the new device state.
    //
    if ((NewState.DeviceState < PowerDeviceD0) ||
        (NewState.DeviceState > PowerDeviceD3))
    {
        DOUT (DBG_ERROR, ("Unknown device state: D%d.", 
             (ULONG)NewState.DeviceState - (ULONG)PowerDeviceD0));
        return;
    }

    DOUT (DBG_POWER, ("Changing state to D%d.", (ULONG)NewState.DeviceState -
                    (ULONG)PowerDeviceD0));

    //
    // Switch on new state.
    //
    switch (NewState.DeviceState)
    {
        case PowerDeviceD0:
            //
            // If we are coming from D2 or D3 we have to restore the registers cause
            // there might have been a power loss.
            //
            if ((m_PowerState == PowerDeviceD3) || (m_PowerState == PowerDeviceD2))
            {
                //
                // Reset AD3 to indicate that we are now awake.
                // Because the system has only one power irp at a time, we are sure
                // that the modem driver doesn't get called while we are restoring
                // power.
                //
                WriteBMControlRegister (GLOB_STA,
                    ReadBMControlRegister32 (GLOB_STA) & ~GLOB_STA_AD3);

                //
                // Restore codec registers.
                //
                ntStatus = RestoreCodecRegisters ();
            }
            else        // We are coming from power state D1
            {
                ntStatus = PowerUpCodec ();
            }

            // Print error code.
            if (!NT_SUCCESS (ntStatus))
            {
                DOUT (DBG_ERROR, ("PowerChangeState failed to restore the codec."));
            }
            break;
    
        case PowerDeviceD1:
            //
            // This sleep state is the lowest latency sleep state with respect
            // to the latency time required to return to D0. If the 
            // driver is not being used an inactivity timer in portcls will 
            // place the driver in this state after a timeout period 
            // controllable via the registry.
            //
    
            // Let's power down the DAC/ADC's and analog mixer.
            WriteCodecRegister (AC97REG_POWERDOWN, 0x0700, -1);
            break;

        case PowerDeviceD2:
        case PowerDeviceD3:
            //
            // This is a full hibernation state and is the longest latency sleep
            // state. In this modes the power could be removed or reduced that
            // much that the AC97 controller looses information, so we save
            // whatever we have to save.
            //

            //
            // Powerdown ADC, DAC, Mixer, Vref, HP amp, and Exernal Amp but not
            // AC-link and Clk
            //
            WriteCodecRegister (AC97REG_POWERDOWN, 0xCF00, -1);

            //
            // Only in D3 mode we set the AD3 bit and evtl. shut off the AC link.
            //
            if (NewState.DeviceState == PowerDeviceD3)
            {
                //
                // Set the AD3 bit.
                //
                ULONG ulReg = ReadBMControlRegister32 (GLOB_STA);
                WriteBMControlRegister (GLOB_STA, ulReg | GLOB_STA_AD3);
                
                //
                // We check if the modem is sleeping. If it is, we can shut off the
                // AC link also. We shut off the AC link also if the modem is not
                // there.
                //
                if ((ulReg & GLOB_STA_MD3) || !(ulReg & GLOB_STA_SCR))
                {
                    // Set Codec to super sleep
                    WriteCodecRegister (AC97REG_POWERDOWN, 0xFF00, -1);
    
                    // Disable the AC-link signals
                    ulReg = ReadBMControlRegister32 (GLOB_CNT);
                    WriteBMControlRegister (GLOB_CNT, (ulReg | GLOB_CNT_ACLOFF) & ~GLOB_CNT_COLD);
                }
            }
            break;
    }
    
    //
    // Save the new state.  This local value is used to determine when to 
    // cache property accesses and when to permit the driver from accessing 
    // the hardware.
    //
    m_PowerState = NewState.DeviceState;
    DOUT (DBG_POWER, ("Entering D%d", (ULONG)m_PowerState -
                      (ULONG)PowerDeviceD0));
}


/*****************************************************************************
 * CAdapterCommon::QueryPowerChangeState
 *****************************************************************************
 * Query to see if the device can change to this power state
 */
STDMETHODIMP_(NTSTATUS) CAdapterCommon::QueryPowerChangeState
(
    IN  POWER_STATE NewState
)
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[CAdapterCommon::QueryPowerChangeState]"));

    // Check here to see of a legitimate state is being requested
    // based on the device state and fail the call if the device/driver
    // cannot support the change requested.  Otherwise, return STATUS_SUCCESS.
    // Note: A QueryPowerChangeState() call is not guaranteed to always preceed
    // a PowerChangeState() call.

    // check the new state being requested
    switch (NewState.DeviceState)
    {
        case PowerDeviceD0:
        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
            return STATUS_SUCCESS;
        
        default:
            DOUT (DBG_ERROR, ("Unknown device state: D%d.", 
                 (ULONG)NewState.DeviceState - (ULONG)PowerDeviceD0));
            return STATUS_NOT_IMPLEMENTED;
    }
}


/*****************************************************************************
 * CAdapterCommon::QueryDeviceCapabilities
 *****************************************************************************
 * Called at startup to get the caps for the device.  This structure provides
 * the system with the mappings between system power state and device power
 * state.  This typically will not need modification by the driver.
 * If the driver modifies these mappings then the driver is not allowed to
 * change the mapping to a weaker power state (e.g. from S1->D3 to S1->D1).
 * 
 */
STDMETHODIMP_(NTSTATUS) CAdapterCommon::QueryDeviceCapabilities
(
    IN  PDEVICE_CAPABILITIES PowerDeviceCaps
)
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[CAdapterCommon::QueryDeviceCapabilities]"));

    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CAdapterCommon::RestoreAC97Registers
 *****************************************************************************
 * Preset the AC97 registers with default values. The routine first checks if
 * There are registry entries for the default values. If not, we have hard
 * coded values too ;)
 */
NTSTATUS CAdapterCommon::SetAC97Default (void)
{
    PAGED_CODE ();
    
    PREGISTRYKEY    DriverKey;
    PREGISTRYKEY    SettingsKey;
    UNICODE_STRING  sKeyName;
    ULONG           ulDisposition;
    ULONG           ulResultLength;
    PVOID           KeyInfo = NULL;

    DOUT (DBG_PRINT, ("[CAdapterCommon::SetAC97Default]"));
    
    // open the driver registry key
    NTSTATUS ntStatus = PcNewRegistryKey (&DriverKey,        // IRegistryKey
                                          NULL,              // OuterUnknown
                                          DriverRegistryKey, // Registry key type
                                          KEY_READ,          // Access flags
                                          m_pDeviceObject,   // Device object
                                          NULL,              // Subdevice
                                          NULL,              // ObjectAttributes
                                          0,                 // Create options
                                          NULL);             // Disposition
    if (NT_SUCCESS (ntStatus))
    {
        // make a unicode string for the subkey name
        RtlInitUnicodeString (&sKeyName, L"Settings");

        // open the settings subkey
        ntStatus = DriverKey->NewSubKey (&SettingsKey,            // Subkey
                                         NULL,                    // OuterUnknown
                                         KEY_READ,                // Access flags
                                         &sKeyName,               // Subkey name
                                         REG_OPTION_NON_VOLATILE, // Create options
                                         &ulDisposition);

        if (NT_SUCCESS (ntStatus))
        {
            // allocate data to hold key info
            KeyInfo = ExAllocatePool (PagedPool,
                                      sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                      sizeof(WORD));
            if (NULL != KeyInfo)
            {
                // loop through all mixer settings
                for (AC97Register i = AC97REG_RESET; i <= AC97REG_RESERVED2;
                    i = (AC97Register)(i + 1))
                {
                    if (m_stAC97Registers[i].wFlags & SHREG_INIT)
                    {
                        // init key name
                        RtlInitUnicodeString (&sKeyName,
                                              m_stAC97Registers[i].sRegistryName);
    
                        // query the value key
                        ntStatus = SettingsKey->QueryValueKey (&sKeyName,
                                        KeyValuePartialInformation,
                                        KeyInfo,
                                        sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                            sizeof(WORD),
                                        &ulResultLength);
                        if (NT_SUCCESS (ntStatus))
                        {
                            PKEY_VALUE_PARTIAL_INFORMATION PartialInfo =
                                        (PKEY_VALUE_PARTIAL_INFORMATION)KeyInfo;

                            if (PartialInfo->DataLength == sizeof(WORD))
                            {
                                // set mixer register to registry value
                                WriteCodecRegister
                                    (i, *(PWORD)PartialInfo->Data, -1);
                            }
                            else    // write the hard coded default
                            {
                                // if key access failed, set to default
                                WriteCodecRegister
                                    (i, m_stAC97Registers[i].wWantedDefault, -1);
                            }
                        }
                        else  // write the hard coded default
                        {
                            // if key access failed, set to default
                            WriteCodecRegister
                                (i, m_stAC97Registers[i].wWantedDefault, -1);
                        }
                    }
                }

                // we want to return status success even if the last QueryValueKey
                // failed.
                ntStatus = STATUS_SUCCESS;

                // free the key info
                ExFreePool (KeyInfo);
            }

            // release the settings key
            SettingsKey->Release ();
        }

        // release the driver key
        DriverKey->Release ();
    }


    // in case we did not query the registry (cause of lack of resources)
    // restore default values and return insufficient resources.
    if (!NT_SUCCESS (ntStatus) || !KeyInfo)
    {
        // copy hard coded default settings
        for (AC97Register i = AC97REG_RESET; i < AC97REG_RESERVED2;
             i = (AC97Register)(i + 1))
        {
            if (m_stAC97Registers[i].wFlags & SHREG_INIT)
            {
                WriteCodecRegister (i, m_stAC97Registers[i].wWantedDefault, -1);
            }
        }

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}


/*****************************************************************************
 * CAdapterCommon::DisableAC97Pin
 *****************************************************************************
 * Returns TRUE when the HW vendor wants to disable the pin. A disabled pin is
 * not shown to the user (means it is not included in the topology). The
 * reason for doing this could be that some of the input lines like Aux or
 * Video are not available to the user (to plug in something) but the codec
 * can handle those lines.
 */
BOOL CAdapterCommon::DisableAC97Pin
(
    IN  TopoPinConfig pin
)
{
    PAGED_CODE ();

    PREGISTRYKEY    DriverKey;
    PREGISTRYKEY    SettingsKey;
    UNICODE_STRING  sKeyName;
    ULONG           ulDisposition;
    ULONG           ulResultLength;
    PVOID           KeyInfo = NULL;
    BOOL            bDisable = FALSE;

    DOUT (DBG_PRINT, ("[CAdapterCommon::DisableAC97Pin]"));
    
    // open the driver registry key
    NTSTATUS ntStatus = PcNewRegistryKey (&DriverKey,        // IRegistryKey
                                          NULL,              // OuterUnknown
                                          DriverRegistryKey, // Registry key type
                                          KEY_READ,          // Access flags
                                          m_pDeviceObject,   // Device object
                                          NULL,              // Subdevice
                                          NULL,              // ObjectAttributes
                                          0,                 // Create options
                                          NULL);             // Disposition
    if (NT_SUCCESS (ntStatus))
    {
        // make a unicode string for the subkey name
        RtlInitUnicodeString (&sKeyName, L"Settings");

        // open the settings subkey
        ntStatus = DriverKey->NewSubKey (&SettingsKey,            // Subkey
                                         NULL,                    // OuterUnknown
                                         KEY_READ,                // Access flags
                                         &sKeyName,               // Subkey name
                                         REG_OPTION_NON_VOLATILE, // Create options
                                         &ulDisposition);

        if (NT_SUCCESS (ntStatus))
        {
            // allocate data to hold key info
            KeyInfo = ExAllocatePool (PagedPool,
                                      sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                      sizeof(BYTE));
            if (NULL != KeyInfo)
            {
                // init key name
                RtlInitUnicodeString (&sKeyName, m_stHardwareConfig.
                                            Pins[pin].sRegistryName);
    
                // query the value key
                ntStatus = SettingsKey->QueryValueKey (&sKeyName,
                                   KeyValuePartialInformation,
                                   KeyInfo,
                                   sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                        sizeof(BYTE),
                                   &ulResultLength );
                if (NT_SUCCESS (ntStatus))
                {
                    PKEY_VALUE_PARTIAL_INFORMATION PartialInfo =
                                (PKEY_VALUE_PARTIAL_INFORMATION)KeyInfo;

                    if (PartialInfo->DataLength == sizeof(BYTE))
                    {
                        // store the value
                        if (*(PBYTE)PartialInfo->Data)
                            bDisable = TRUE;
                        else
                            bDisable = FALSE;
                    }
                }

                // free the key info
                ExFreePool (KeyInfo);
            }

            // release the settings key
            SettingsKey->Release ();
        }

        // release the driver key
        DriverKey->Release ();
    }

    // if one of the stuff above fails we return the default, which is FALSE.
    return bDisable;
}


/*****************************************************************************
 * CAdapterCommon::RestoreCodecRegisters
 *****************************************************************************
 * write back cached mixer values to codec registers
 */
NTSTATUS CAdapterCommon::RestoreCodecRegisters (void)
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[CAdapterCommon::RestoreCodecRegisters]"));

    //
    // Initialize the AC97 codec.
    //
    NTSTATUS ntStatus = InitAC97 ();
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    //
    // Restore all codec registers.  Failure is not critical.
    //
    for (AC97Register i = AC97REG_MASTER_VOLUME; i < AC97REG_RESERVED2; 
        i = (AC97Register)(i + 1))
    {
        WriteCodecRegister (i, m_stAC97Registers[i].wCache, -1);
    }

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CAdapterCommon::ReadChannelConfigDefault
 *****************************************************************************
 * This function reads the default channel config from the registry. The
 * registry entry "ChannelConfig" is set every every time we get a
 * KSPROPERTY_AUDIO_CHANNEL_CONFIG for the DAC node.
 * In case the key doesn't exist we assume a channel config of stereo speakers,
 * cause that is the default of DSOUND.
 */
STDMETHODIMP_(void) CAdapterCommon::ReadChannelConfigDefault
(
    PDWORD  pdwChannelConfig,
    PWORD   pwChannels
)
{
    PAGED_CODE ();

    PREGISTRYKEY    DriverKey;
    PREGISTRYKEY    SettingsKey;
    UNICODE_STRING  sKeyName;
    ULONG           ulDisposition;
    ULONG           ulResultLength;
    PVOID           KeyInfo = NULL;

    DOUT (DBG_PRINT, ("[CAdapterCommon::ReadChannelConfigDefault]"));
    
    // This is the default: 2 speakers, stereo.
    *pdwChannelConfig = KSAUDIO_SPEAKER_STEREO;
    *pwChannels = 2;
    
    // open the driver registry key
    NTSTATUS ntStatus = PcNewRegistryKey (&DriverKey,        // IRegistryKey
                                          NULL,              // OuterUnknown
                                          DriverRegistryKey, // Registry key type
                                          KEY_READ,          // Access flags
                                          m_pDeviceObject,   // Device object
                                          NULL,              // Subdevice
                                          NULL,              // ObjectAttributes
                                          0,                 // Create options
                                          NULL);             // Disposition
    if (NT_SUCCESS (ntStatus))
    {
        // make a unicode string for the subkey name
        RtlInitUnicodeString (&sKeyName, L"Settings");

        // open the settings subkey
        ntStatus = DriverKey->NewSubKey (&SettingsKey,            // Subkey
                                         NULL,                    // OuterUnknown
                                         KEY_READ,                // Access flags
                                         &sKeyName,               // Subkey name
                                         REG_OPTION_NON_VOLATILE, // Create options
                                         &ulDisposition);

        if (NT_SUCCESS (ntStatus))
        {
            // allocate data to hold key info
            KeyInfo = ExAllocatePool (PagedPool,
                                      sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                      sizeof(DWORD));
            if (NULL != KeyInfo)
            {
                // init key name
                RtlInitUnicodeString (&sKeyName, L"ChannelConfig");
    
                // query the value key
                ntStatus = SettingsKey->QueryValueKey (&sKeyName,
                                   KeyValuePartialInformation,
                                   KeyInfo,
                                   sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                                        sizeof(DWORD),
                                   &ulResultLength );
                if (NT_SUCCESS (ntStatus))
                {
                    PKEY_VALUE_PARTIAL_INFORMATION PartialInfo =
                                (PKEY_VALUE_PARTIAL_INFORMATION)KeyInfo;

                    if (PartialInfo->DataLength == sizeof(DWORD))
                    {
                        switch (*(PLONG)PartialInfo->Data)
                        {
                        case KSAUDIO_SPEAKER_QUAD:
                        case KSAUDIO_SPEAKER_SURROUND:
                            if (GetPinConfig (PINC_SURROUND_PRESENT))
                            {
                                *pdwChannelConfig = *(PDWORD)PartialInfo->Data;
                                *pwChannels = 4;
                            }
                            break;

                        case KSAUDIO_SPEAKER_5POINT1:
                            if (GetPinConfig (PINC_SURROUND_PRESENT) &&
                                GetPinConfig (PINC_CENTER_LFE_PRESENT))
                            {
                                *pdwChannelConfig = *(PDWORD)PartialInfo->Data;
                                *pwChannels = 6;
                            }
                            break;
                        }
                    }
                }

                // free the key info
                ExFreePool (KeyInfo);
            }

            // release the settings key
            SettingsKey->Release ();
        }

        // release the driver key
        DriverKey->Release ();
    }
}

/*****************************************************************************
 * CAdapterCommon::WriteChannelConfigDefault
 *****************************************************************************
 * This function writes the default channel config to the registry. The
 * registry entry "ChannelConfig" is set every every time we get a
 * KSPROPERTY_AUDIO_CHANNEL_CONFIG for the DAC node.
 */
STDMETHODIMP_(void) CAdapterCommon::WriteChannelConfigDefault (DWORD dwChannelConfig)
{
    PAGED_CODE ();

    PREGISTRYKEY    DriverKey;
    PREGISTRYKEY    SettingsKey;
    UNICODE_STRING  sKeyName;
    ULONG           ulDisposition;

    DOUT (DBG_PRINT, ("[CAdapterCommon::WriteChannelConfigDefault]"));
    
    // open the driver registry key
    NTSTATUS ntStatus = PcNewRegistryKey (&DriverKey,        // IRegistryKey
                                          NULL,              // OuterUnknown
                                          DriverRegistryKey, // Registry key type
                                          KEY_WRITE,         // Access flags
                                          m_pDeviceObject,   // Device object
                                          NULL,              // Subdevice
                                          NULL,              // ObjectAttributes
                                          0,                 // Create options
                                          NULL);             // Disposition
    if (NT_SUCCESS (ntStatus))
    {
        // make a unicode string for the subkey name
        RtlInitUnicodeString (&sKeyName, L"Settings");

        // open the settings subkey
        ntStatus = DriverKey->NewSubKey (&SettingsKey,            // Subkey
                                         NULL,                    // OuterUnknown
                                         KEY_WRITE,               // Access flags
                                         &sKeyName,               // Subkey name
                                         REG_OPTION_NON_VOLATILE, // Create options
                                         &ulDisposition);

        if (NT_SUCCESS (ntStatus))
        {
            // init key name
            RtlInitUnicodeString (&sKeyName, L"ChannelConfig");

            // query the value key
            ntStatus = SettingsKey->SetValueKey (&sKeyName,
                                                 REG_DWORD,
                                                 &dwChannelConfig,
                                                 sizeof (DWORD));
            if (!NT_SUCCESS (ntStatus))
            {
                DOUT (DBG_ERROR, ("Could not write the ChannelConfig to registry."));
            }

            // release the settings key
            SettingsKey->Release ();
        }

        // release the driver key
        DriverKey->Release ();
    }
}

/*****************************************************************************
 * Non paged code begins here
 *****************************************************************************
 */ 

#pragma code_seg()
/*****************************************************************************
 * CAdapterCommon::WriteBMControlRegister
 *****************************************************************************
 * Writes a byte (UCHAR) to BusMaster Control register.
 */
STDMETHODIMP_(void) CAdapterCommon::WriteBMControlRegister
(
    IN  ULONG ulOffset,
    IN  UCHAR ucValue
)
{
    DOUT (DBG_PRINT, ("[CAdapterCommon::WriteBMControlRegister] (UCHAR)"));
    
    WRITE_PORT_UCHAR ((PUCHAR)(m_pBusMasterBase + ulOffset), ucValue);

    DOUT (DBG_REGS, ("WriteBMControlRegister wrote 0x%2x to 0x%4x.", 
                   ucValue, m_pBusMasterBase + ulOffset));
}

/*****************************************************************************
 * CAdapterCommon::WriteBMControlRegister
 *****************************************************************************
 * Writes a word (USHORT) to BusMaster Control register.
 */
STDMETHODIMP_(void) CAdapterCommon::WriteBMControlRegister
(
    IN  ULONG ulOffset,
    IN  USHORT usValue
)
{
    DOUT (DBG_PRINT, ("[CAdapterCommon::WriteBMControlRegister (USHORT)]"));

    WRITE_PORT_USHORT ((PUSHORT)(m_pBusMasterBase + ulOffset), usValue);

    DOUT (DBG_REGS, ("WriteBMControlRegister wrote 0x%4x to 0x%4x", 
                   usValue, m_pBusMasterBase + ulOffset));
}

/*****************************************************************************
 * CAdapterCommon::WriteBMControlRegister
 *****************************************************************************
 * Writes a DWORD (ULONG) to BusMaster Control register.
 */
STDMETHODIMP_(void) CAdapterCommon::WriteBMControlRegister
(
    IN  ULONG ulOffset,
    IN  ULONG ulValue
)
{
    DOUT (DBG_PRINT, ("[CAdapterCommon::WriteBMControlRegister (ULONG)]"));

    WRITE_PORT_ULONG ((PULONG)(m_pBusMasterBase + ulOffset), ulValue);

    DOUT (DBG_REGS, ("WriteBMControlRegister wrote 0x%8x to 0x%4x.", 
                   ulValue, m_pBusMasterBase + ulOffset));
}

/*****************************************************************************
 * CAdapterCommon::ReadBMControlRegister8
 *****************************************************************************
 * Read a byte (UCHAR) from BusMaster Control register.
 */
STDMETHODIMP_(UCHAR) CAdapterCommon::ReadBMControlRegister8
(
    IN  ULONG ulOffset
)
{
    UCHAR ucValue = UCHAR(-1);

    DOUT (DBG_PRINT, ("[CAdapterCommon::ReadBMControlRegister8]"));

    ucValue = READ_PORT_UCHAR ((PUCHAR)(m_pBusMasterBase + ulOffset));

    DOUT (DBG_REGS, ("ReadBMControlRegister read 0x%2x from 0x%4x.", ucValue,
                   m_pBusMasterBase + ulOffset));

    return ucValue;
}

/*****************************************************************************
 * CAdapterCommon::ReadBMControlRegister16
 *****************************************************************************
 * Read a word (USHORT) from BusMaster Control register.
 */
STDMETHODIMP_(USHORT) CAdapterCommon::ReadBMControlRegister16
(
    IN  ULONG ulOffset
)
{
    USHORT usValue = USHORT(-1);

    DOUT (DBG_PRINT, ("[CAdapterCommon::ReadBMControlRegister16]"));

    usValue = READ_PORT_USHORT ((PUSHORT)(m_pBusMasterBase + ulOffset));

    DOUT (DBG_REGS, ("ReadBMControlRegister read 0x%4x = 0x%4x", usValue,
                   m_pBusMasterBase + ulOffset));

    return usValue;
}

/*****************************************************************************
 * CAdapterCommon::ReadBMControlRegister32
 *****************************************************************************
 * Read a dword (ULONG) from BusMaster Control register.
 */
STDMETHODIMP_(ULONG) CAdapterCommon::ReadBMControlRegister32
(
    IN  ULONG ulOffset
)
{
    ULONG ulValue = ULONG(-1);

    DOUT (DBG_PRINT, ("[CAdapterCommon::ReadBMControlRegister32]"));

    ulValue = READ_PORT_ULONG ((PULONG)(m_pBusMasterBase + ulOffset));

    DOUT (DBG_REGS, ("ReadBMControlRegister read 0x%8x = 0x%4x", ulValue,
                   m_pBusMasterBase + ulOffset));

    return ulValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\cpl\ac97cpl.cpp ===
/********************************************************************************
**    Copyright (c) 2000 Microsoft Corporation. All Rights Reserved.
********************************************************************************/

#include <windows.h>
#include <cpl.h>
#include <ks.h>
#include <ksmedia.h>
#include <setupapi.h>
#include "resource.h"
#include "prvprop.h"

//
//  Global Variables.
//
HINSTANCE                   ghInstance = NULL;      // module handle.
const TCHAR AppletName[] = TEXT("AC97 control panel");


#if (DBG)
/////////////////////////////////////////////////////////////////////////////////
// dbgError
/////////////////////////////////////////////////////////////////////////////////
// This function prints an error message.
// It prints first the string passed and then the error that it gets with
// GetLastError as a string.
//
// Arguments:
//    szMsg - message to print.
//
// Return Value:
//    None.
//
void dbgError (LPCTSTR szMsg)
{
    LPTSTR errorMessage;
    DWORD  count;

    // Get the error message from the system.
    count = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_SYSTEM |
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError (),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&errorMessage,
                0,
                NULL);

    // Print the msg + error + \n\r.
    if (count)
    {
        OutputDebugString (szMsg);
        OutputDebugString (errorMessage);
        OutputDebugString (TEXT("\n\r"));

        // This is for those without a debugger.
        // MessageBox (NULL, szErrorMessage, szMsg, MB_OK | MB_ICONSTOP);

        LocalFree (errorMessage);
    }
    else
    {
        OutputDebugString (AppletName);
        OutputDebugString (TEXT(": Low memory condition. Cannot ")
                TEXT("print error message.\n\r"));
    }
}
#else
#define dbgError(a) 0;
#endif


/////////////////////////////////////////////////////////////////////////////////
// DllMain
/////////////////////////////////////////////////////////////////////////////////
// Main enty point of the DLL.
// Save the instance handle; it is needed for property sheet creation.
//
// Arguments:
//    hModule            - instance data, is equal to module handle
//    ul_reason_for_call - the reason for the call
//    lpReserved         - some additional parameter.
//
// Return Value:
//    BOOL: FALSE if DLL should fail, TRUE on success
//
BOOL APIENTRY DllMain (HANDLE hModule, ULONG ul_reason_for_call, LPVOID lpReserved)
{
    ghInstance = (HINSTANCE) hModule;
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////////
// FindAC97Device
/////////////////////////////////////////////////////////////////////////////////
// This function stores the device info and device data of the "ac97smpl" driver.
// It first creates a list of all devices that have a topology filter exposed
// and then searches through the list to find the device with the service
// "ac97smpl". The information is stored in pspRequest.
//
// For simplicity we search for the service name "ac97smpl".
// Alternately, one could get more information about the device or driver, 
// then decide if it is suitable (regardless of its name).
//
// Arguments:
//    pspRequest        pointer to Property sheet page request structure.
//    DeviceInfoData    pointer to Device info data structure.
//
// Return Value:
//    TRUE on success, otherwise FALSE.
//    Note: on success that we have the device list still open - we have to destroy
//    the list later. The handle is stored at pspRequest->DeviceInfoSet.
//
BOOL FindAC97Device (PSP_PROPSHEETPAGE_REQUEST  pspRequest,
                     PSP_DEVINFO_DATA DeviceInfoData)
{
    TCHAR           szServiceName[128];

    //
    // Prepare the pspRequest structure...
    //
    pspRequest->cbSize = sizeof (SP_PROPSHEETPAGE_REQUEST);
    pspRequest->DeviceInfoData = DeviceInfoData;
    pspRequest->PageRequested = SPPSR_ENUM_ADV_DEVICE_PROPERTIES;

    // ...and the DeviceInfoData structure.
    DeviceInfoData->cbSize = sizeof (SP_DEVINFO_DATA);

    // Create a list of devices with Topology interface.
    pspRequest->DeviceInfoSet = SetupDiGetClassDevs (&KSCATEGORY_TOPOLOGY,
                                     NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

    // None found?
    if (pspRequest->DeviceInfoSet == INVALID_HANDLE_VALUE)
    {
        dbgError (TEXT("Test: SetupDiGetClassDevs: "));
        return FALSE;
    }

    //
    // Go through the list of all devices found.
    //
    int nIndex = 0;
    
    while (SetupDiEnumDeviceInfo (pspRequest->DeviceInfoSet, nIndex, DeviceInfoData))
    {
        //
        // Get the service name for that device.
        //
        if (!SetupDiGetDeviceRegistryProperty (pspRequest->DeviceInfoSet, DeviceInfoData,
                                               SPDRP_SERVICE, NULL, (PBYTE)szServiceName,
                                               sizeof (szServiceName), NULL))
        {
            dbgError (TEXT("Test: SetupDiGetDeviceRegistryProperty: "));
            SetupDiDestroyDeviceInfoList (pspRequest->DeviceInfoSet);
            return FALSE;
        }

        //
        // We only care about service "ac97smpl"
        //
        DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
        if (CompareString (lcid, NORM_IGNORECASE, szServiceName,
                            -1, TEXT("AC97SMPL"), -1) == CSTR_EQUAL)
        {
            //
            // We found it! The information is already stored, just return.
            // Note that we have the device list still open - we have to destroy
            // the list later.
            //
            return TRUE;
        }

        // Take the next in the list.
        nIndex++;
    }
    
    //
    // We did not find the service.
    //
    SetupDiDestroyDeviceInfoList (pspRequest->DeviceInfoSet);
    return FALSE;
}


/////////////////////////////////////////////////////////////////////////////////
// AddPropSheet
/////////////////////////////////////////////////////////////////////////////////
// This function is a callback that is passed to the "AC97PropPageProvider"
// function of "ac97prop.dll". It is used to add the property page sheet 
// to the property dialog.
// What we do here is store the property sheet handle and return.
//
// Arguments:
//    hPSP       property sheet handle
//    lParam     parameter that we passed to "AC97PropPageProvider".
//
// Return Value:
//    TRUE on success, otherwise FALSE.
//
BOOL APIENTRY AddPropSheet (HPROPSHEETPAGE hPSP, LPARAM lParam)
{
    HPROPSHEETPAGE **pphPropSheet = (HPROPSHEETPAGE **)lParam;
    HPROPSHEETPAGE *phPropSheetPage;

    // Check the parameters
    if (!pphPropSheet)
        return FALSE;

    // Allocate the space for the handle.
    phPropSheetPage = (HPROPSHEETPAGE *)LocalAlloc (LPTR, sizeof(HPROPSHEETPAGE));
    if (!phPropSheetPage)
        return FALSE;

    *phPropSheetPage = hPSP;
    *pphPropSheet = phPropSheetPage;
    
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////////
// GetDLLInfo
/////////////////////////////////////////////////////////////////////////////////
// This function loads the library and gets the entry point address.
// With the information returned we can create the property dialog.
//
// For simplicity reasons we load the DLL "ac97prop" and call the function
// "AC97PropPageProvider". A more flexible course of action is to get this
// information from the registry.  To do this, we read the "EnumPropPages32" 
// entry in the drivers section to obtain a registry path (read the "drivers"
// entry in the device section to get the registry path of the drivers section)
// -- this path leads to a key and entry which specifies the DLL and entry point.
//
// Arguments:
//    *phDLL                     pointer to module handle of loaded DLL.
//    *pAC97PropPageProvider     pointer to "AC97PropPageProvider" in loaded DLL
//
// Return Value:
//    TRUE on success, otherwise FALSE.
//    Note: on success the library is still loaded.
//
BOOL GetDLLInfo (HMODULE *phDLL, LPFNADDPROPSHEETPAGES *pAC97PropPageProvider)
{
    // Load the library.
    *phDLL = LoadLibrary (TEXT("ac97prop.dll"));
    if (!*phDLL)
    {
        dbgError (TEXT("DisplayPropertySheet: LoadLibrary"));
        return FALSE;
    }

    // Get the address of the function.
    *pAC97PropPageProvider = (LPFNADDPROPSHEETPAGES)GetProcAddress (*phDLL,
                                                      "AC97PropPageProvider");
    if (!*pAC97PropPageProvider)
    {
        dbgError (TEXT("DisplayPropertySheet: GetProcAddress"));
        FreeLibrary (*phDLL);
        return FALSE;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////////
// DisplayPropertySheet
/////////////////////////////////////////////////////////////////////////////////
// This function displays the property dialog.
// It is called by CPlApplet when the ac97cpl icon gets a double click.
//
// Arguments:
//    hWnd      parent window handle
//
// Return Value:
//    None.
//
void DisplayPropertySheet (HWND hWnd)
{
    SP_PROPSHEETPAGE_REQUEST    pspRequest;         // structure passed to ac97prop
    SP_DEVINFO_DATA             DeviceInfoData;     // pspRequest points to it.
    HMODULE                     hDLL;               // Module handle of library
    LPFNADDPROPSHEETPAGES       AC97PropPageProvider; // function to be called.
    PROPSHEETHEADER             psh;


    // You could move this to CPL_INIT, then it would be called
    // before the control panel window appears.
    // In case of an failure the icon would not be displayed. In our sample
    // however, the icon will be displayed and when the user clicks on it he
    // gets the error message.
    if (!FindAC97Device(&pspRequest, &DeviceInfoData))
    {
        MessageBox (hWnd, TEXT("You must install the ac97 sample driver."),
                    AppletName, MB_ICONSTOP | MB_OK);
        return;
    }

    // Load the library and get the function pointer.
    if (!GetDLLInfo (&hDLL, &AC97PropPageProvider))
    {
        MessageBox (hWnd, TEXT("The ac97 property page DLL could not load."),
                    AppletName, MB_ICONSTOP | MB_OK);
        SetupDiDestroyDeviceInfoList (pspRequest.DeviceInfoSet);
        return;
    }

    //
    // Prepare the header for the property sheet.
    //
    psh.nStartPage = 0;
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_PROPTITLE | PSH_NOAPPLYNOW;
    psh.hwndParent = hWnd;
    psh.hInstance = ghInstance;
    psh.pszIcon = NULL;
    psh.pszCaption = MAKEINTRESOURCE(IDS_AC97CPL);
    psh.nPages = 1;

    // Call the function to request the property sheet page.
    if (!(*AC97PropPageProvider) ((LPVOID)&pspRequest, AddPropSheet, (LPARAM)&psh.phpage))
    {
        MessageBox (hWnd, TEXT("\"AC97PropPageProvider\" had a failure."),
                    AppletName, MB_ICONSTOP | MB_OK);
        FreeLibrary (hDLL);
        SetupDiDestroyDeviceInfoList (pspRequest.DeviceInfoSet);
        return;
    }

    // Create the dialog. The function returns when the dialog is closed.
    if (PropertySheet (&psh) < 0)
    {
        //
        // Dialog closed abnormally. This might be a system failure.
        //
        MessageBox (hWnd, TEXT("Please reinstall the ac97 sample driver."),
                    AppletName, MB_ICONSTOP | MB_OK);
    }

    // Clean up.
    FreeLibrary (hDLL);
    LocalFree (psh.phpage);
    SetupDiDestroyDeviceInfoList (pspRequest.DeviceInfoSet);
}


/////////////////////////////////////////////////////////////////////////////////
// CPlApplet
/////////////////////////////////////////////////////////////////////////////////
// This function is called by the control panel manager. It is very similar to
// a Windows message handler (search for CplApplet in MSDN for description).
//
// Arguments:
//    HWND hWnd         Parent window handle
//    UINT uMsg         The message
//    LPARAM lParam1    depends on message
//    LPARAM lParam2    depends on message
//
// Return Value:
//    LONG (depends on message; in general 0 means failure).
//
LONG APIENTRY CPlApplet (HWND hWnd, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    switch (uMsg)
    {
        // Initialize. You can allocate memory here.
        case CPL_INIT:
            return TRUE;
        
        //  How many applets are in this DLL?
        case CPL_GETCOUNT:
            return 1;
        
        // Requesting information about the dialog box.
        // lParam1 is the dialog box number (we have only one) and 
        // lParam2 is the pointer to a CPLINFO structure.
        // There is no return value.
        case CPL_INQUIRE:
        {
            UINT      uAppNum = (UINT)lParam1;
            LPCPLINFO pCplInfo = (LPCPLINFO)lParam2;

            if (!pCplInfo)
                return TRUE;    // unsuccessful
                
            if (uAppNum == 0)   // first Applet?
            {
                pCplInfo->idIcon = IDI_AC97CPL;
                pCplInfo->idName = IDS_AC97CPL;
                pCplInfo->idInfo = IDS_AC97CPLINFO;
            }
            break;
        }
        
        // This is basically the same as CPL_INQUIRE, but passes a pointer
        // to a different structure.
        // This function is called before CPL_INQUIRE and if we return zero
        // here, then CPL_INQUIRE is called.
        case CPL_NEWINQUIRE:
            break;
        
        // One of these messages are sent when we should display the dialog box.
        // There is no return value.
        // lParam1 is the dialog box number (we have only one)
        case CPL_DBLCLK:
        case CPL_STARTWPARMS:
        {
            UINT    uAppNum = (UINT)lParam1;

            if (uAppNum == 0)   // first Applet?
                DisplayPropertySheet (hWnd);
            break;
        }
        
        // We get unloaded in a second.
        // There is no return value.
        case CPL_EXIT:
            break;
        
        default:    // Who knows?
            break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\adapter.h ===
/********************************************************************************
**    Copyright (c) 1998-1999 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

#ifndef _ADAPTER_H_
#define _ADAPTER_H_

#include "shared.h"

/*****************************************************************************
 * Defines
 *****************************************************************************
 */
const ULONG MAX_MINIPORTS = 2;

/*****************************************************************************
 * Externals
 *****************************************************************************
 */
extern NTSTATUS CreateMiniportWaveICH
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);

extern NTSTATUS CreateMiniportTopologyICH
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);

#endif  //_ADAPTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\adapter.cpp ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

//
// The name that is printed in debug output messages
//
static char STR_MODULENAME[] = "ICH Adapter: ";

//
// All the GUIDs from portcls and your own defined GUIDs end up in this object.
//
#define PUT_GUIDS_HERE

//
// We want the global debug variables here.
//
#define DEFINE_DEBUG_VARS

#include "adapter.h"


#pragma code_seg("PAGE")
/*****************************************************************************
 * InstallSubdevice
 *****************************************************************************
 * This function creates and registers a subdevice consisting of a port
 * driver, a minport driver and a set of resources bound together.  It will
 * also optionally place a pointer to an interface on the port driver in a
 * specified location before initializing the port driver.  This is done so
 * that a common ISR can have access to the port driver during initialization,
 * when the ISR might fire.
 * This function is internally used and validates no parameters.
 */
NTSTATUS InstallSubdevice
(
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    IN      PWCHAR              Name,
    IN      REFGUID             PortClassId,
    IN      REFGUID             MiniportClassId,
    IN      PFNCREATEINSTANCE   MiniportCreate      OPTIONAL,
    IN      PUNKNOWN            UnknownAdapter      OPTIONAL,
    IN      PRESOURCELIST       ResourceList,
    IN      REFGUID             PortInterfaceId,
    OUT     PMINIPORT *         OutMiniport         OPTIONAL,
    OUT     PUNKNOWN *          OutPortUnknown      OPTIONAL
)
{
    PAGED_CODE ();

    NTSTATUS    ntStatus;
    PPORT       port;
    PMINIPORT   miniport;

    DOUT (DBG_PRINT, ("[InstallSubdevice]"));

    //
    // Create the port driver object
    //
    ntStatus = PcNewPort (&port,PortClassId);
   
    //
    // return immediately in case of an error
    //
    if (!NT_SUCCESS (ntStatus))
       return ntStatus;
    
    //
    // Create the miniport object
    //
    if (MiniportCreate)
    {
        ntStatus = MiniportCreate ((PUNKNOWN*)&miniport, MiniportClassId,
                                   NULL, NonPagedPool);
    }
    else
    {
        ntStatus = PcNewMiniport (&miniport,MiniportClassId);
    }

    //
    // return immediately in case of an error
    //
    if (!NT_SUCCESS (ntStatus))
    {
        port->Release ();
        return ntStatus;
    }

    //
    // Init the port driver and miniport in one go.
    //
    ntStatus = port->Init (DeviceObject, Irp, miniport, UnknownAdapter,
                           ResourceList);

    if (NT_SUCCESS (ntStatus))
    {
        //
        // Register the subdevice (port/miniport combination).
        //
        ntStatus = PcRegisterSubdevice (DeviceObject, Name, port);

        //
        // Deposit the port as an unknown if it's needed.
        //
        if (OutPortUnknown && NT_SUCCESS (ntStatus))
        {
            ntStatus = port->QueryInterface (IID_IUnknown,
                                             (PVOID *)OutPortUnknown);
        }

        //
        // Deposit the miniport as an IMiniport if it's needed.
        //
        if ( OutMiniport && NT_SUCCESS (ntStatus) )
        {
            ntStatus = miniport->QueryInterface (IID_IMiniport,
                                                (PVOID *)OutMiniport);
        }
    }

    //
    // Release the reference for the port and miniport. This is the right
    // thing to do, regardless of the outcome.
    //
    miniport->Release ();
    port->Release ();


    return ntStatus;
}


/*****************************************************************************
 * ValidateResources
 *****************************************************************************
 * This function validates the list of resources for the various functions on
 * the card.  This code is specific to the adapter.
 * This function doesn't check the ResourceList parameter and returns
 * STATUS_SUCCESS when the resources are valid.
 */
NTSTATUS ValidateResources
(
    IN      PRESOURCELIST   ResourceList    // All resources.
)
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[ValidateResources]"));
    
    //
    // Get counts for the types of resources.
    //
    ULONG countIO  = ResourceList->NumberOfPorts ();
    ULONG countIRQ = ResourceList->NumberOfInterrupts ();
    ULONG countDMA = ResourceList->NumberOfDmas ();

    // validate resources
    if ((countIO != 2) || (countIRQ != 1) || (countDMA != 0))
    {
        DOUT (DBG_ERROR, ("Unknown configuration:\n"
                          "   IO  count: %d\n"
                          "   IRQ count: %d\n"
                          "   DMA count: %d",
                          countIO, countIRQ, countDMA));
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * StartDevice
 *****************************************************************************
 * This function is called by the operating system when the device is started.
 * It is responsible for starting the miniports.  This code is specific to
 * the adapter because it calls out miniports for functions that are specific
 * to the adapter.
 */
NTSTATUS StartDevice
(
    IN  PDEVICE_OBJECT  DeviceObject,   // Device object.
    IN  PIRP            Irp,            // IO request packet.
    IN  PRESOURCELIST   ResourceList    // List of hardware resources.
)
{
    PAGED_CODE ();

    ASSERT (DeviceObject);
    ASSERT (Irp);
    ASSERT (ResourceList);

    NTSTATUS ntStatus;

    DOUT (DBG_PRINT, ("[StartDevice]"));

    //
    // Determine which version of the OS we are running under.  We don't want
    // to run under Win98G.
    //
    
    // create a wave cyclic port
    PPORT pPort = 0;
    ntStatus = PcNewPort (&pPort,CLSID_PortWaveCyclic);
    
    // check error code
    if (NT_SUCCESS (ntStatus))
    {
        // query for the event interface which is not supported in Win98 gold.
        PPORTEVENTS pPortEvents = 0;
        ntStatus = pPort->QueryInterface (IID_IPortEvents, 
                                         (PVOID *)&pPortEvents);
        if (!NT_SUCCESS (ntStatus))
        {
            DOUT (DBG_ERROR, ("This driver is not for Win98 Gold!"));
            ntStatus = STATUS_UNSUCCESSFUL;     // change error code.
        }
        else
        {
            pPortEvents->Release ();
        }
        pPort->Release ();
    }

    // now return in case it was Win98 Gold.
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    //
    // Validate the resources.
    // We don't have to split the resources into several resource lists cause
    // the topology miniport doesn't need a resource list, the wave pci miniport
    // needs all resources like the adapter common object.
    //
    ntStatus = ValidateResources (ResourceList);

    //
    // return immediately in case of an error
    //
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    //
    // If the adapter has the right resources...
    //
    PADAPTERCOMMON pAdapterCommon = NULL;
    PUNKNOWN       pUnknownCommon;

    // create a new adapter common object
    ntStatus = NewAdapterCommon (&pUnknownCommon, IID_IAdapterCommon,
                                 NULL, NonPagedPool);

    if (NT_SUCCESS (ntStatus))
    {
        // query for the IAdapterCommon interface
        ntStatus = pUnknownCommon->QueryInterface (IID_IAdapterCommon,
                                                   (PVOID *)&pAdapterCommon);
        if (NT_SUCCESS (ntStatus))
        {
            // Initialize the object
            ntStatus = pAdapterCommon->Init (ResourceList, DeviceObject);

            if (NT_SUCCESS (ntStatus))
            {
                // register with PortCls for power-management services
                ntStatus = PcRegisterAdapterPowerManagement ((PUNKNOWN)pAdapterCommon,
                                                             DeviceObject);
            }
        }

        // release the IID_IAdapterCommon on adapter common
        pUnknownCommon->Release ();
    }

    // print error message.
    if (!NT_SUCCESS (ntStatus))
    {
        DOUT (DBG_ERROR, ("Could not create or query AdapterCommon."));
    }

    //
    // These are the port driver pointers we are keeping around for registering
    // physical connections.
    //
    PMINIPORT               miniWave                = NULL;
    PMINIPORT               miniTopology            = NULL;
    PUNKNOWN                unknownWave             = NULL;
    PUNKNOWN                unknownTopology         = NULL;
    PMINIPORTTOPOLOGYICH    pMiniportTopologyICH    = NULL;

    //
    // Start the topology miniport.
    //
    if (NT_SUCCESS (ntStatus))
    {
        ntStatus = InstallSubdevice (DeviceObject,
                                     Irp,
                                     L"Topology",
                                     CLSID_PortTopology,
                                     CLSID_PortTopology, // not used
                                     CreateMiniportTopologyICH,
                                     pAdapterCommon,
                                     NULL,
                                     GUID_NULL,
                                     &miniTopology,
                                     &unknownTopology);

        if (NT_SUCCESS (ntStatus))
        {
            // query for the IMiniportTopologyICH interface
            ntStatus = miniTopology->QueryInterface (IID_IMiniportTopologyICH,
                                                    (PVOID *)&pMiniportTopologyICH);
            miniTopology->Release ();
            miniTopology = NULL;
        }
        
        // print error message.
        if (!NT_SUCCESS (ntStatus))
        {
            DOUT (DBG_ERROR, ("Could not create or query TopologyICH"));
        }
    }

    //
    // Start the wave miniport.
    //
    if (NT_SUCCESS (ntStatus))
    {
        ntStatus = InstallSubdevice (DeviceObject,
                                     Irp,
                                     L"Wave",
                                     CLSID_PortWavePci,
                                     CLSID_PortWavePci,   // not used
                                     CreateMiniportWaveICH,
                                     pAdapterCommon,
                                     ResourceList,
                                     IID_IPortWavePci,
                                     NULL,
                                     &unknownWave);
  
        // print error message.
        if (!NT_SUCCESS (ntStatus))
        {
            DOUT (DBG_ERROR, ("WavePCI miniport installation failed!"));
        }
    }

    //
    // Establish physical connections between filters as shown.
    //
    //              +------+    +------+
    //              | Wave |    | Topo |
    //  Capture <---|2    3|<===|x     |<--- CD
    //              |      |    |      |
    //   Render --->|0    1|===>|y     |<--- Line In
    //              |      |    |      |
    //      Mic <---|4    5|<===|z     |<--- Mic
    //              +------+    |      |
    //                          |      |---> Line Out
    //                          +------+
    //
    // Note that the pin numbers for the nodes to be connected
    // vary depending on the hardware/codec configuration.
    // Also, the mic input may or may not be present.
    //
    // So,
    //      Do a QI on unknownTopology to get an interface to call
    //          a method on to get the topology miniport pin IDs.

    if (NT_SUCCESS (ntStatus))
    {
        ULONG ulWaveOut, ulWaveIn, ulMicIn;

        // get the pin numbers.
        DOUT (DBG_PRINT, ("Connecting topo and wave."));
        ntStatus = pMiniportTopologyICH->GetPhysicalConnectionPins (&ulWaveOut,
                                            &ulWaveIn, &ulMicIn);

        // register wave render connection
        if (NT_SUCCESS (ntStatus))
        {
            ntStatus = PcRegisterPhysicalConnection (DeviceObject,
                                                     unknownWave,
                                                     PIN_WAVEOUT_BRIDGE,
                                                     unknownTopology,
                                                     ulWaveOut);
            // print error message.
            if (!NT_SUCCESS (ntStatus))
            {
                DOUT (DBG_ERROR, ("Cannot connect topology and wave miniport"
                                  " (render)!"));
            }
        }


        if (NT_SUCCESS (ntStatus))
        {
            // register wave capture connection
            ntStatus = PcRegisterPhysicalConnection (DeviceObject,
                                                     unknownTopology,
                                                     ulWaveIn,
                                                     unknownWave,
                                                     PIN_WAVEIN_BRIDGE);
            // print error message.
            if (!NT_SUCCESS (ntStatus))
            {
                DOUT (DBG_ERROR, ("Cannot connect topology and wave miniport"
                                  " (capture)!"));
            }
        }

        if (NT_SUCCESS (ntStatus))
        {
            // register mic capture connection
            if (pAdapterCommon->GetPinConfig (PINC_MICIN_PRESENT))
            {
                ntStatus = PcRegisterPhysicalConnection (DeviceObject,
                                                         unknownTopology,
                                                         ulMicIn,
                                                         unknownWave,
                                                         PIN_MICIN_BRIDGE);
                // print error message.
                if (!NT_SUCCESS (ntStatus))
                {
                    DOUT (DBG_ERROR, ("Cannot connect topology and wave miniport"
                                      " (MIC)!"));
                }
            }
        }
    }

    //
    // Release the adapter common object.  It either has other references,
    // or we need to delete it anyway.
    //
    if (pAdapterCommon)
        pAdapterCommon->Release ();

    //
    // Release the unknowns.
    //
    if (unknownTopology)
        unknownTopology->Release ();
    if (unknownWave)
        unknownWave->Release ();

    // and the ICH miniport.
    if (pMiniportTopologyICH)
        pMiniportTopologyICH->Release ();


    return ntStatus;    // whatever this is ...
}

/*****************************************************************************
 * AddDevice
 *****************************************************************************
 * This function is called by the operating system when the device is added.
 * All adapter drivers can use this code without change.
 */
extern "C" NTSTATUS AddDevice
(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
)
{
    PAGED_CODE ();
    
    DOUT (DBG_PRINT, ("[AddDevice]"));


    //
    // Tell portcls (the class driver) to add the device.
    //
    return PcAddAdapterDevice (DriverObject,
                               PhysicalDeviceObject,
                               (PCPFNSTARTDEVICE)StartDevice,
                               MAX_MINIPORTS,
                               0);
}

/*****************************************************************************
 * DriverEntry
 *****************************************************************************
 * This function is called by the operating system when the driver is loaded.
 * All adapter drivers can use this code without change.
 */
extern "C" NTSTATUS DriverEntry
(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
)
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[DriverEntry]"));

    //
    // Tell the class driver to initialize the driver.
    //
    NTSTATUS RetValue = PcInitializeAdapterDriver (DriverObject,
                                          RegistryPathName,
                                          AddDevice);


    return RetValue;
}

#pragma code_seg()
/*****************************************************************************
 * _purecall()
 *****************************************************************************
 * The C++ compiler loves me.
 */
int __cdecl _purecall (void)
{
    ASSERT (!"Pure virtual function called");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\guids.h ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

#ifndef _ICH_GUIDS_H_
#define _ICH_GUIDS_H_


/*****************************************************************************
 * GUIDs
 *****************************************************************************
 * GUIDs for friendly names.
 */

// PHONE Volume Name
#define STATIC_ICHFNAME_PHONE_VOLUME\
    0x0A8C1A87, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1A87-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_PHONE_VOLUME);
#define ICHFNAME_PHONE_VOLUME DEFINE_GUIDNAMED(_ICHFNAME_PHONE_VOLUME)

// PHONE Mute Name
#define STATIC_ICHFNAME_PHONE_MUTE\
    0x0A8C1A88, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1A88-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_PHONE_MUTE);
#define ICHFNAME_PHONE_MUTE DEFINE_GUIDNAMED(_ICHFNAME_PHONE_MUTE)

// LINEIN Mute Name
#define STATIC_ICHFNAME_LINEIN_MUTE\
    0x0A8C1A91, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1A91-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_LINEIN_MUTE);
#define ICHFNAME_LINEIN_MUTE DEFINE_GUIDNAMED(_ICHFNAME_LINEIN_MUTE)

// Main Mix Name
#define STATIC_ICHFNAME_MAIN_MIX\
    0x0A8C1A9B, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1A9B-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_MAIN_MIX);
#define ICHFNAME_MAIN_MIX DEFINE_GUIDNAMED(_ICHFNAME_MAIN_MIX)

// 3D Bypass Name
#define STATIC_ICHFNAME_WAVEOUT_3D_BYPASS\
    0x0A8C1A9E, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1A9E-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_WAVEOUT_3D_BYPASS);
#define ICHFNAME_WAVEOUT_3D_BYPASS DEFINE_GUIDNAMED(_ICHFNAME_WAVEOUT_3D_BYPASS)

// 3D Enable Name
#define STATIC_ICHFNAME_3D_ENABLE\
    0x766db5a4, 0x6e94, 0x11d2, 0x9a, 0xde, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("766DB5A4-6E94-11d2-9ADE-00C04F8EFB68", _ICHFNAME_3D_ENABLE);
#define ICHFNAME_3D_ENABLE DEFINE_GUIDNAMED(_ICHFNAME_3D_ENABLE)

// Beep Mix Name
#define STATIC_ICHFNAME_BEEP_MIX\
    0x0A8C1A9F, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1A9F-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_BEEP_MIX);
#define ICHFNAME_BEEP_MIX DEFINE_GUIDNAMED(_ICHFNAME_BEEP_MIX)

// HPOUT Volume Name
#define STATIC_ICHFNAME_HPOUT_VOLUME\
    0x0A8C1AA5, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1AA5-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_HPOUT_VOLUME);
#define ICHFNAME_HPOUT_VOLUME DEFINE_GUIDNAMED(_ICHFNAME_HPOUT_VOLUME)

// HPOUT Mute Name
#define STATIC_ICHFNAME_HPOUT_MUTE\
    0x0A8C1AA6, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1AA6-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_HPOUT_MUTE);
#define ICHFNAME_HPOUT_MUTE DEFINE_GUIDNAMED(_ICHFNAME_HPOUT_MUTE)

// MONOOUT Select Name
#define STATIC_ICHFNAME_MONOOUT_SELECT\
    0x0A8C1AA9, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1AA9-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_MONOOUT_SELECT);
#define ICHFNAME_MONOOUT_SELECT DEFINE_GUIDNAMED(_ICHFNAME_MONOOUT_SELECT)

// WAVEIN Select Name
#define STATIC_ICHFNAME_WAVEIN_SELECT\
    0x0A8C1AAE, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1AAE-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_WAVEIN_SELECT);
#define ICHFNAME_WAVEIN_SELECT DEFINE_GUIDNAMED(_ICHFNAME_WAVEIN_SELECT)

// MASTER INPUT Volume Name
#define STATIC_ICHFNAME_MASTER_INPUT_VOLUME\
    0x0A8C1AAF, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1AAF-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_MASTER_INPUT_VOLUME);
#define ICHFNAME_MASTER_INPUT_VOLUME DEFINE_GUIDNAMED(_ICHFNAME_MASTER_INPUT_VOLUME)

// MASTER INPUT Mute Name
#define STATIC_ICHFNAME_MASTER_INPUT_MUTE\
    0x0A8C1AB0, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1AB0-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_MASTER_INPUT_MUTE);
#define ICHFNAME_MASTER_INPUT_MUTE DEFINE_GUIDNAMED(_ICHFNAME_MASTER_INPUT_MUTE)

// MICIN Volume Name
#define STATIC_ICHFNAME_MICIN_VOLUME\
    0x0A8C1AB2, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1AB2-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_MICIN_VOLUME);
#define ICHFNAME_MICIN_VOLUME DEFINE_GUIDNAMED(_ICHFNAME_MICIN_VOLUME)

// MICIN Mute Name
#define STATIC_ICHFNAME_MICIN_MUTE\
    0x0A8C1AB3, 0x42B0, 0x11D2, 0x95, 0xD2, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("0A8C1AB3-42B0-11D2-95D2-00C04FB925D3", _ICHFNAME_MICIN_MUTE);
#define ICHFNAME_MICIN_MUTE DEFINE_GUIDNAMED(_ICHFNAME_MICIN_MUTE)

// Simulated Stereo Name
#define STATIC_ICHFNAME_SIMUL_STEREO\
    0xB3AD50B5, 0x3849, 0x4983, 0xAD, 0xD7, 0x25, 0xE6, 0x26, 0x8F, 0x91, 0x2D
DEFINE_GUIDSTRUCT("B3AD50B5-3849-4983-ADD7-25E6268F912D", _ICHFNAME_SIMUL_STEREO);
#define ICHFNAME_SIMUL_STEREO DEFINE_GUIDNAMED(_ICHFNAME_SIMUL_STEREO)

// Surround Volume Name
#define STATIC_ICHFNAME_SURROUND_VOLUME\
    0xa4b68ba4, 0x6958, 0x4ab4, 0xbb, 0x1, 0xe2, 0x3c, 0x6f, 0x2, 0x7c, 0x88
DEFINE_GUIDSTRUCT("A4B68BA4-6958-4ab4-BB01-E23C6F027C88", _ICHFNAME_SURROUND_VOLUME);
#define ICHFNAME_SURROUND_VOLUME DEFINE_GUIDNAMED(_ICHFNAME_SURROUND_VOLUME)

// Surround Mute Name
#define STATIC_ICHFNAME_SURROUND_MUTE\
    0x22654fbc, 0xac8f, 0x4224, 0xb1, 0x9f, 0xd8, 0x58, 0xd2, 0xe1, 0xb, 0xdd
DEFINE_GUIDSTRUCT("22654FBC-AC8F-4224-B19F-D858D2E10BDD", _ICHFNAME_SURROUND_MUTE);
#define ICHFNAME_SURROUND_MUTE DEFINE_GUIDNAMED(_ICHFNAME_SURROUND_MUTE)

// Center Volume Name
#define STATIC_ICHFNAME_CENTER_VOLUME\
    0x9b0f1946, 0xabd2, 0x47a8, 0xa7, 0x78, 0xbb, 0x86, 0xcd, 0xe1, 0xa1, 0x67
DEFINE_GUIDSTRUCT("9B0F1946-ABD2-47a8-A778-BB86CDE1A167", _ICHFNAME_CENTER_VOLUME);
#define ICHFNAME_CENTER_VOLUME DEFINE_GUIDNAMED(_ICHFNAME_CENTER_VOLUME)

// Center Mute Name
#define STATIC_ICHFNAME_CENTER_MUTE\
    0xbeef51ed, 0x1041, 0x43f8, 0x9b, 0x96, 0x58, 0x63, 0xd0, 0xa9, 0x34, 0x2d
DEFINE_GUIDSTRUCT("BEEF51ED-1041-43f8-9B96-5863D0A9342D", _ICHFNAME_CENTER_MUTE);
#define ICHFNAME_CENTER_MUTE DEFINE_GUIDNAMED(_ICHFNAME_CENTER_MUTE)

// LFE Volume Name
#define STATIC_ICHFNAME_LFE_VOLUME\
    0x455fa6f2, 0x21ec, 0x4df4, 0xb1, 0xe4, 0x31, 0x55, 0x20, 0x97, 0x97, 0xf3
DEFINE_GUIDSTRUCT("455FA6F2-21EC-4df4-B1E4-3155209797F3", _ICHFNAME_LFE_VOLUME);
#define ICHFNAME_LFE_VOLUME DEFINE_GUIDNAMED(_ICHFNAME_LFE_VOLUME)

// LFE Mute Name
#define STATIC_ICHFNAME_LFE_MUTE\
    0x4a4d9210, 0xc780, 0x4768, 0xbf, 0xd2, 0x52, 0x5f, 0xdb, 0xf4, 0xfc, 0xb4
DEFINE_GUIDSTRUCT("4A4D9210-C780-4768-BFD2-525FDBF4FCB4", _ICHFNAME_LFE_MUTE);
#define ICHFNAME_LFE_MUTE DEFINE_GUIDNAMED(_ICHFNAME_LFE_MUTE)

// Front Volume Name
#define STATIC_ICHFNAME_FRONT_VOLUME\
    0x9f4801bd, 0xf746, 0x4c7a, 0x8a, 0x9d, 0xf6, 0xe9, 0x90, 0x4, 0xcc, 0x98
DEFINE_GUIDSTRUCT("9F4801BD-F746-4c7a-8A9D-F6E99004CC98", _ICHFNAME_FRONT_VOLUME);
#define ICHFNAME_FRONT_VOLUME DEFINE_GUIDNAMED(_ICHFNAME_FRONT_VOLUME)

// Front Mute Name
#define STATIC_ICHFNAME_FRONT_MUTE\
    0xc8e03b2a, 0xebd9, 0x4554, 0xa7, 0x50, 0x8e, 0x44, 0x72, 0x75, 0xa, 0x5b
DEFINE_GUIDSTRUCT("C8E03B2A-EBD9-4554-A750-8E4472750A5B", _ICHFNAME_FRONT_MUTE);
#define ICHFNAME_FRONT_MUTE DEFINE_GUIDNAMED(_ICHFNAME_FRONT_MUTE)

// Surround Pin Name
#define STATIC_ICHFNAME_SURROUND\
    0x81fbb14b, 0x1bee, 0x4bf5, 0x92, 0xee, 0xff, 0xc4, 0xf7, 0x5f, 0x32, 0x6d
DEFINE_GUIDSTRUCT("81FBB14B-1BEE-4bf5-92EE-FFC4F75F326D", _ICHFNAME_SURROUND);
#define ICHFNAME_SURROUND DEFINE_GUIDNAMED(_ICHFNAME_SURROUND)

// Center Pin Name
#define STATIC_ICHFNAME_CENTER\
    0x2d97372f, 0x9cf6, 0x4fd6, 0x9e, 0x56, 0xc6, 0x8b, 0xac, 0xdf, 0x36, 0xd
DEFINE_GUIDSTRUCT("2D97372F-9CF6-4fd6-9E56-C68BACDF360D", _ICHFNAME_CENTER);
#define ICHFNAME_CENTER DEFINE_GUIDNAMED(_ICHFNAME_CENTER)

// LFE Pin Name
#define STATIC_ICHFNAME_LFE\
    0xb60c4274, 0x3bfd, 0x430b, 0x83, 0x64, 0xd9, 0x47, 0xe7, 0xd3, 0x4, 0xb1
DEFINE_GUIDSTRUCT("B60C4274-3BFD-430b-8364-D947E7D304B1", _ICHFNAME_LFE);
#define ICHFNAME_LFE DEFINE_GUIDNAMED(_ICHFNAME_LFE)

// Front Pin Name
#define STATIC_ICHFNAME_FRONT\
    0x70395e2, 0xbe7c, 0x4b4d, 0xb5, 0x29, 0x40, 0xcb, 0x9b, 0xfc, 0xf9, 0x95
DEFINE_GUIDSTRUCT("070395E2-BE7C-4b4d-B529-40CB9BFCF995", _ICHFNAME_FRONT);
#define ICHFNAME_FRONT DEFINE_GUIDNAMED(_ICHFNAME_FRONT)

#endif  // _ICH_GUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\common.h ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

#ifndef _COMMON_H_
#define _COMMON_H_

#include "shared.h"

/*****************************************************************************
 * Structs
 *****************************************************************************
 */
 
//                                              
// Contains pin and node configuration of the AC97 codec.
//
typedef struct
{
    // For nodes.
    struct
    {
        BOOL    bNodeConfig;
    } Nodes[NODEC_TOP_ELEMENT];

    // For pins.
    struct
    {
        BOOL    bPinConfig;
        PWCHAR  sRegistryName;
    } Pins[PINC_TOP_ELEMENT];
} tHardwareConfig;

//
// We cache the AC97 registers.  Additionally, we want some default values
// when the driver comes up first that are different from the HW default
// values. The string in the structure is the name of the registry entry
// that can be used instead of the hard coded default value.
//
typedef struct
{
    WORD    wCache;
    WORD    wFlags;
    PWCHAR  sRegistryName;
    WORD    wWantedDefault;
} tAC97Registers;


/*****************************************************************************
 * Constants
 *****************************************************************************
 */

//
// This means shadow register are to be read at least once to initialize.
//
const WORD SHREG_INVALID = 0x0001;

//
// This means shadow register should be overwritten with default value at
// driver init.
//
const WORD SHREG_INIT = 0x0002;

//
// This constant is used to prevent register caching.
//
const WORD SHREG_NOCACHE = 0x0004;


/*****************************************************************************
 * Classes
 *****************************************************************************
 */

/*****************************************************************************
 * CAdapterCommon
 *****************************************************************************
 * This is the common adapter object shared by all miniports to access the
 * hardware.
 */
class CAdapterCommon : public IAdapterCommon, 
                       public IAdapterPowerManagement,
                       public CUnknown
{
private:
    static tAC97Registers m_stAC97Registers[64];    // The shadow registers.
    static tHardwareConfig m_stHardwareConfig;      // The hardware configuration.
    PDEVICE_OBJECT m_pDeviceObject;     // Device object used for registry access.
    PWORD          m_pCodecBase;        // The AC97 I/O port address.
    PUCHAR         m_pBusMasterBase;    // The Bus Master base address.
    BOOL           m_bDirectRead;       // Used during init time.
    DEVICE_POWER_STATE   m_PowerState;  // Current power state of the device.
    PMINIPORTTOPOLOGYICH m_Topology;    // Miniport Topology pointer.


    /*************************************************************************
     * CAdapterCommon methods
     *************************************************************************
     */
    
    //
    // Resets AC97 audio registers.
    //
    NTSTATUS InitAC97 (void);
    
    //
    // Checks for existance of registers.
    //
    NTSTATUS ProbeHWConfig (void);

    //
    // Checks for 6th bit support in the volume control.
    //
    NTSTATUS Check6thBitSupport (IN AC97Register, IN TopoNodeConfig);

    //
    // Returns true if you should disable the input or output pin.
    //
    BOOL DisableAC97Pin (IN  TopoPinConfig);

#if (DBG)
    //
    // Dumps the probed configuration.
    //
    void DumpConfig (void);
#endif

    //
    // Sets AC97 registers to default.
    //
    NTSTATUS SetAC97Default (void);

    //
    // Aquires the semaphore for AC97 register access.
    //
    NTSTATUS AcquireCodecSemiphore (void);

    //
    // Checks if there is a AC97 link between ICH and codec.
    //
    NTSTATUS PrimaryCodecReady (void);

    //
    // Powers up the Codec.
    //
    NTSTATUS PowerUpCodec (void);
    
    //
    // Saves native audio bus master control registers values to be used 
    // upon suspend.
    //
    NTSTATUS ReadNABMCtrlRegs (void);

    //
    // Writes back native audio bus master control resgister to be used upon 
    // resume.
    //
    NTSTATUS RestoreNABMCtrlRegs (void);

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CAdapterCommon);
    ~CAdapterCommon();

    /*************************************************************************
     * IAdapterPowerManagement methods
     *************************************************************************
     */
    IMP_IAdapterPowerManagement;

    /*************************************************************************
     * IAdapterCommon methods
     *************************************************************************
     */
    
    //
    // Initialize the adapter common object -> initialize and probe HW.
    //
    STDMETHODIMP_(NTSTATUS) Init
    (
        IN  PRESOURCELIST ResourceList,
        IN  PDEVICE_OBJECT DeviceObject
    );
    
    //
    // Returns if pin exists.
    //
    STDMETHODIMP_(BOOL) GetPinConfig
    (
        IN  TopoPinConfig pin
    )
    {
        return m_stHardwareConfig.Pins[pin].bPinConfig;
    };

    //
    // Sets the pin configuration (exist/not exist).
    //
    STDMETHODIMP_(void) SetPinConfig
    (
        IN  TopoPinConfig pin,
        IN  BOOL config
    )
    {
        m_stHardwareConfig.Pins[pin].bPinConfig = config;
    };

    //
    // Return if node exists.
    //
    STDMETHODIMP_(BOOL) GetNodeConfig
    (
        IN  TopoNodeConfig node
    )
    {
        return m_stHardwareConfig.Nodes[node].bNodeConfig;
    };

    //
    // Sets the node configuration (exist/not exist).
    //
    STDMETHODIMP_(void) SetNodeConfig
    (
        IN  TopoNodeConfig node,
        IN  BOOL config
    )
    {
        m_stHardwareConfig.Nodes[node].bNodeConfig = config;
    };

    //
    // Returns the AC97 register that is assosiated with the node.
    //
    STDMETHODIMP_(AC97Register) GetNodeReg
    (   IN  TopoNodes node
    )
    {
        return stMapNodeToReg[node].reg;
    };

    //
    // Returns the AC97 register mask that is assosiated with the node.
    //
    STDMETHODIMP_(WORD) GetNodeMask
    (
        IN  TopoNodes node
    )
    {
        return stMapNodeToReg[node].mask;
    };

    //
    // Reads a AC97 register.
    //
    STDMETHODIMP_(NTSTATUS) ReadCodecRegister
    (
        IN  AC97Register Register,
        OUT PWORD wData
    );

    //
    // Writes a AC97 register.
    //
    STDMETHODIMP_(NTSTATUS) WriteCodecRegister
    (
        IN  AC97Register Register,
        IN  WORD wData,
        IN  WORD wMask
    );

    //
    // Reads a 8 bit ICH bus master register.
    //
    STDMETHODIMP_(UCHAR) ReadBMControlRegister8
    (
        IN  ULONG ulOffset
    );

    //
    // Reads a 16 bit ICH bus master register.
    //
    STDMETHODIMP_(USHORT) ReadBMControlRegister16
    (
        IN  ULONG ulOffset
    );

    //
    // Reads a 32 bit ICH bus master register.
    //
    STDMETHODIMP_(ULONG) ReadBMControlRegister32
    (
        IN  ULONG ulOffset
    );

    //
    // Writes a 8 bit ICH bus master register.
    //                                        
    STDMETHODIMP_(void) WriteBMControlRegister
    (
        IN  ULONG ulOffset,
        IN  UCHAR Value
    );

    //
    // writes a 16 bit ICH bus master register.
    //
    STDMETHODIMP_(void) WriteBMControlRegister
    (
        IN  ULONG ulOffset,
        IN  USHORT Value
    );

    // writes a 32 bit ICH bus master register.
    STDMETHODIMP_(void) WriteBMControlRegister
    (
        IN  ULONG ulOffset,
        IN  ULONG Value
    );

    //
    // Write back cached mixer values to codec registers.
    //
    STDMETHODIMP_(NTSTATUS) RestoreCodecRegisters();

    //
    // Programs a sample rate.
    //
    STDMETHODIMP_(NTSTATUS) ProgramSampleRate
    (
        IN  AC97Register Register,
        IN  DWORD dwSampleRate
    );

    //
    // Stores the topology pointer. Used for DRM only.
    //
    STDMETHODIMP_(void) SetMiniportTopology (PMINIPORTTOPOLOGYICH topo)
    {
        m_Topology = topo;
    };

    //
    // Returns the topology pointer. Used for DRM only.
    //
    STDMETHODIMP_(PMINIPORTTOPOLOGYICH) GetMiniportTopology (void)
    {
        return m_Topology;
    };
    
    //
    // This function reads the default channel config and is called only by the
    // wave miniport.
    //
    STDMETHODIMP_(void) ReadChannelConfigDefault
    (
        PDWORD  pdwChannelConfig,
        PWORD   pwChannels
    );
    
    //
    // This function writes the default channel config and is called only by the
    // wave miniport.
    //
    STDMETHODIMP_(void) WriteChannelConfigDefault
    (
        DWORD   dwChannelConfig
    );
    
    /*************************************************************************
     * Friends
     *************************************************************************
     */
    
    friend NTSTATUS NewAdapterCommon
    (
        OUT PADAPTERCOMMON *OutAdapterCommon,
        IN  PRESOURCELIST ResourceList
    );
};

#endif  //_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\debug.h ===
/********************************************************************************
**    Copyright (c) 1998-1999 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

#ifndef _DEBUG_H_
#define _DEBUG_H_

//
// Modified version of ksdebug.h to support runtime debug level changes.
//
const int DBG_NONE     = 0x00000000;
const int DBG_PRINT    = 0x00000001; // Blabla. Function entries for example
const int DBG_WARNING  = 0x00000002; // warning level
const int DBG_ERROR    = 0x00000004; // this doesn't generate a breakpoint

// specific debug output; you don't have to enable DBG_PRINT for this.
const int DBG_STREAM   = 0x00000010; // Enables stream output.
const int DBG_POWER    = 0x00000020; // Enables power management output.
const int DBG_DMA      = 0x00000040; // Enables DMA engine output.
const int DBG_REGS     = 0x00000080; // Enables register outout.
const int DBG_PROBE    = 0x00000100; // Enables hardware probing output.
const int DBG_SYSINFO  = 0x00000200; // Enables system info output.
const int DBG_VSR      = 0x00000400; // Enables variable sample rate output.
const int DBG_PROPERTY = 0x00000800; // Enables property handler output
const int DBG_POSITION = 0x00001000; // Enables printing of position on GetPosition
const int DBG_PINS     = 0x10000000; // Enables dump of created pins in topology
const int DBG_NODES    = 0x20000000; // Enables dump of created nodes in topology
const int DBG_CONNS    = 0x40000000; // Enables dump of the connections in topology
                                    
const int DBG_ALL      = 0xFFFFFFFF;

//
// The default statements that will print are warnings (DBG_WARNING) and
// errors (DBG_ERROR).
//
const int DBG_DEFAULT = 0x00000004;  // Errors only.

    
//
// Define global debug variable.
//
#ifdef DEFINE_DEBUG_VARS
#if (DBG)
unsigned long ulDebugOut = DBG_DEFAULT;
#endif

#else // !DEFINED_DEBUG_VARS
#if (DBG)
extern unsigned long ulDebugOut;
#endif
#endif


//
// Define the print statement.
//
#if defined(__cplusplus)
extern "C" {
#endif // #if defined(__cplusplus)

//
// DBG is 1 in checked builds
//
#if (DBG)
#define DOUT(lvl, strings)          \
    if ((lvl) & ulDebugOut)         \
    {                               \
        DbgPrint(STR_MODULENAME);   \
        DbgPrint##strings;          \
        DbgPrint("\n");             \
    }

#define BREAK()                     \
    DbgBreakPoint()

#else // if (!DBG)
#define DOUT(lvl, strings)
#define BREAK()
#endif // !DBG    


#if defined(__cplusplus)
}
#endif // #if defined(__cplusplus)



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\ichwave.cpp ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

// Every debug output has "Modulname text"
static char STR_MODULENAME[] = "ICH Stream: ";

#include "minwave.h"
#include "ichwave.h"

/*****************************************************************************
 * General Info
 *****************************************************************************
 * To protect the stBDList structure that is used to store mappings, we use a
 * spin lock called MapLock. This spin lock is also acquired when we change
 * the DMA registers. Normally, changes in stBDList and the DMA registers go
 * hand in hand. In case we only want to change the DMA registers, we need
 * to acquire the spin lock!
 */

#pragma code_seg("PAGE")
/*****************************************************************************
 * CreateMiniportWaveICHStream
 *****************************************************************************
 * Creates a wave miniport stream object for the ICH audio adapter. This is
 * (nearly) like the macro STD_CREATE_BODY_ from STDUNK.H.
 */
NTSTATUS CreateMiniportWaveICHStream
(
    OUT CMiniportWaveICHStream  **WaveIchStream,
    IN  PUNKNOWN                pUnknownOuter,
    IN  POOL_TYPE               PoolType
)
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[CreateMiniportWaveICHStream]"));

    //
    // This is basically like the macro at stdunk with the change that we
    // don't cast to interface unknown but to interface WaveIchStream.
    //
    *WaveIchStream = new (PoolType, 'rCcP')
                        CMiniportWaveICHStream (pUnknownOuter);
    if (*WaveIchStream)
    {
        (*WaveIchStream)->AddRef ();
        return STATUS_SUCCESS;
    }

    return STATUS_INSUFFICIENT_RESOURCES;
}
   

/*****************************************************************************
 * CMiniportWaveICHStream::~CMiniportWaveICHStream
 *****************************************************************************
 * Destructor
 */
CMiniportWaveICHStream::~CMiniportWaveICHStream ()
{
    PAGED_CODE ();


    DOUT (DBG_PRINT, ("[CMiniportWaveICHStream::~CMiniportWaveICHStream]"));

    //
    // Print information about the scatter gather list.
    //
    DOUT (DBG_DMA, ("Head %d, Tail %d, Tag counter %d, Entries %d.",
                   stBDList.nHead, stBDList.nTail, stBDList.ulTagCounter, 
                   stBDList.nBDEntries));

    if (Wave)
    {
        //
        // Disable interrupts and stop DMA just in case.
        //
        if (Wave->AdapterCommon)
        {
            Wave->AdapterCommon->WriteBMControlRegister (m_ulBDAddr + X_CR, (UCHAR)0);
            
            //
            // Update also the topology miniport if this was the render stream.
            //
            if (Wave->AdapterCommon->GetMiniportTopology () &&
                (Channel == PIN_WAVEOUT_OFFSET))
            {
                Wave->AdapterCommon->GetMiniportTopology ()->SetCopyProtectFlag (FALSE);
            }
        }
        
        //
        // Remove stream from miniport Streams array.
        //
        if (Wave->Streams[Channel] == this)
        {
            Wave->Streams[Channel] = NULL;
        }
        
        //
        // Release the scatter/gather table.
        //
        if (stBDList.pBDEntry)
        {
            HalFreeCommonBuffer (Wave->AdapterObject,
                                 PAGE_SIZE,
                                 stBDList.PhysAddr,
                                 (PVOID)stBDList.pBDEntry,
                                 FALSE);
            stBDList.pBDEntry = NULL;
        }

        //
        // Release the miniport.
        //
        Wave->Release ();
        Wave = NULL;
    }

    //
    // Release the service group.
    //
    if (ServiceGroup)
    {
        ServiceGroup->Release ();
        ServiceGroup = NULL;
    }

    //
    // Release the mapping table.
    //
    if (stBDList.pMapData)
    {
        ExFreePool (stBDList.pMapData);
        stBDList.pMapData = NULL;
    }

    //
    // Release the port stream.
    //
    if (PortStream)
    {
        PortStream->Release ();
        PortStream = NULL;
    }

}


/*****************************************************************************
 * CMiniportWaveICHStream::Init
 *****************************************************************************
 * This routine initializes the stream object, sets up the BDL, and programs
 * the buffer descriptor list base address register for the pin being
 * initialized.
 */
NTSTATUS CMiniportWaveICHStream::Init
(
    IN  CMiniportWaveICH        *Miniport_,
    IN  PPORTWAVEPCISTREAM      PortStream_,
    IN  ULONG                   Channel_,
    IN  BOOLEAN                 Capture_,
    IN  PKSDATAFORMAT           DataFormat_,
    OUT PSERVICEGROUP           *ServiceGroup_
)
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[CMiniportWaveICHStream::Init]"));

    ASSERT (Miniport_);
    ASSERT (PortStream_);
    ASSERT (DataFormat_);
    ASSERT (ServiceGroup_);

    //
    // The rule here is that we return when we fail without a cleanup.
    // The destructor will relase the allocated memory.
    //
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Initialize BDL info.
    //
    stBDList.pBDEntry = NULL;
    stBDList.pMapData = NULL;
    stBDList.nHead = 0;
    stBDList.nTail = 0;
    stBDList.ulTagCounter = 0;
    stBDList.nBDEntries = 0;

    //
    // Save miniport pointer and addref it.
    //
    Wave = Miniport_;
    Wave->AddRef ();

    //
    // Save portstream interface pointer and addref it.
    //
    PortStream = PortStream_;
    PortStream->AddRef ();

    //
    // Save channel ID and capture flag.
    //
    Channel = Channel_;
    Capture = Capture_;

    //
    // Save data format and current sample rate.
    //
    DataFormat = (PKSDATAFORMAT_WAVEFORMATEX)DataFormat_;
    CurrentRate = DataFormat->WaveFormatEx.nSamplesPerSec;
    NumberOfChannels = DataFormat->WaveFormatEx.nChannels;

    //
    // Initialize the BDL spinlock.
    //
    KeInitializeSpinLock (&MapLock);

    //
    // Create a service group (a DPC abstraction/helper) to help with 
    // interrupts.
    //
    ntStatus = PcNewServiceGroup (&ServiceGroup, NULL);
    if (!NT_SUCCESS (ntStatus))
    {
        DOUT (DBG_ERROR, ("Failed to create a service group!"));
        return ntStatus;
    }

    //
    // Pass the ServiceGroup pointer to portcls.
    //
    *ServiceGroup_ = ServiceGroup;
    ServiceGroup->AddRef ();

    // 
    // Setup the Buffer Descriptor List (BDL)
    // Allocate 32 entries of 8 bytes (one BDL entry). We allocate two tables
    // because we need one table as a backup.
    // The pointer is aligned on a 8 byte boundary (that's what we need).
    //
    stBDList.pBDEntry = (tBDEntry *)HalAllocateCommonBuffer (Wave->AdapterObject,
                               MAX_BDL_ENTRIES * sizeof (tBDEntry) * 2,
                               &stBDList.PhysAddr,
                               FALSE);

    if (!stBDList.pBDEntry)
    {
        DOUT (DBG_ERROR, ("Failed HalAllocateCommonBuffer!"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // calculate the (backup) pointer.
    stBDList.pBDEntryBackup = (tBDEntry *)stBDList.pBDEntry + MAX_BDL_ENTRIES;

    //
    // Allocate a buffer for the 32 possible mappings. We allocate two tables
    // because we need one table as a backup
    //
    stBDList.pMapData = 
        (tMapData *)ExAllocatePool (NonPagedPool, sizeof(tMapData) * 
                                    MAX_BDL_ENTRIES * 2);
    if (!stBDList.pMapData)
    {
        DOUT (DBG_ERROR, ("Failed to allocate the back up buffer!"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // calculate the (backup) pointer.
    stBDList.pMapDataBackup = stBDList.pMapData + MAX_BDL_ENTRIES;
        
    //
    // Store the base address of this DMA engine.
    //
    if (Capture)
    {
        //
        // could be PCM or MIC capture
        //
        if (Channel == PIN_WAVEIN_OFFSET)
        {
            // Base address for DMA registers.
            m_ulBDAddr = PI_BDBAR;
        }
        else
        {
            // Base address for DMA registers.
            m_ulBDAddr = MC_BDBAR;
        }
    }
    else    // render
    {
        // Base address for DMA registers.
        m_ulBDAddr = PO_BDBAR;
    }

    //
    // Reset the DMA and set the BD list pointer.
    //
    ResetDMA ();

    //
    // Reset the position pointers.
    //
    TotalBytesMapped   = 0;
    TotalBytesReleased = 0;

    //
    // Now set the requested sample rate. In case of a failure, the object
    // gets destroyed and releases all memory etc.
    //
    ntStatus = SetFormat (DataFormat_);
    if (!NT_SUCCESS (ntStatus))
    {
        DOUT (DBG_ERROR, ("Stream init SetFormat call failed!"));
        return ntStatus;
    }

    //
    // Initialize the device state.
    //
    m_PowerState = PowerDeviceD0;


    PPREFETCHOFFSET PreFetchOffset;
    //
    // Query for the new interface "PreFetchOffset" and use
    // function offered there in case the interface is offered.
    //
    if (NT_SUCCESS(PortStream->QueryInterface(IID_IPreFetchOffset, (PVOID *)&PreFetchOffset)))
    {
        // why don't we pad by 32 sample frames
        PreFetchOffset->SetPreFetchOffset(32 * (DataFormat->WaveFormatEx.nChannels * 2)); 
        PreFetchOffset->Release();
    }

    //
    // Store the stream pointer, it is used by the ISR.
    //
    Wave->Streams[Channel] = this;

    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICHStream::NonDelegatingQueryInterface
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP_(NTSTATUS) CMiniportWaveICHStream::NonDelegatingQueryInterface
(
    IN  REFIID  Interface,
    OUT PVOID * Object
)
{
    PAGED_CODE ();

    ASSERT (Object);

    DOUT (DBG_PRINT, ("[CMiniportWaveICHStream::NonDelegatingQueryInterface]"));

    //
    // Convert for IID_IMiniportWavePciStream
    //
    if (IsEqualGUIDAligned (Interface, IID_IMiniportWavePciStream))
    {
        *Object = (PVOID)(PMINIPORTWAVEPCISTREAM)this;
    }
    //
    // Convert for IID_IServiceSink
    //
    else if (IsEqualGUIDAligned (Interface, IID_IServiceSink))
    {
        *Object = (PVOID)(PSERVICESINK)this;
    }
    //
    // Convert for IID_IDrmAudioStream
    //
    else if (IsEqualGUIDAligned (Interface, IID_IDrmAudioStream))
    {
        *Object = (PVOID)(PDRMAUDIOSTREAM)this;
    }
    //
    // Convert for IID_IUnknown
    //
    else if (IsEqualGUIDAligned (Interface, IID_IUnknown))
    {
        *Object = (PVOID)(PUNKNOWN)(PMINIPORTWAVEPCISTREAM)this;
    }
    else
    {
        *Object = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    ((PUNKNOWN)*Object)->AddRef ();
    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICHStream::GetAllocatorFraming
 *****************************************************************************
 * Returns the framing requirements for this device.
 * That is sample size (for one sample) and preferred frame (buffer) size.
 */
STDMETHODIMP_(NTSTATUS) CMiniportWaveICHStream::GetAllocatorFraming
(
    OUT PKSALLOCATOR_FRAMING AllocatorFraming
)
{
    PAGED_CODE ();

    ULONG SampleSize;

    DOUT (DBG_PRINT, ("[CMiniportWaveICHStream::GetAllocatorFraming]"));
    
    //
    // Determine sample size in bytes.  Always number of 
    // channels * 2 (because 16-bit).
    //
    SampleSize = DataFormat->WaveFormatEx.nChannels * 2;

    //
    // Report the suggested requirements.
    //
    AllocatorFraming->RequirementsFlags =
        KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY | 
        KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
    AllocatorFraming->Frames = 8;

    //
    // Currently, arbitrarily selecting 10ms as the frame target size.
    //
    //  This value needs to be sample block aligned for ICH to work correctly.
    //  Assumes 100Hz minimum sample rate (otherwise FrameSize is 0 bytes)
    //
    AllocatorFraming->FrameSize = SampleSize * (DataFormat->WaveFormatEx.nSamplesPerSec / 100);
    AllocatorFraming->FileAlignment = FILE_LONG_ALIGNMENT;
    AllocatorFraming->PoolType = NonPagedPool;

    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICHStream::SetFormat
 *****************************************************************************    
 * This routine tests for proper data format (calls wave miniport) and sets
 * or changes the stream data format.
 * To figure out if the codec supports the sample rate, we just program the
 * sample rate and read it back. If it matches we return happy, if not then
 * we restore the sample rate and return unhappy.
 * We fail this routine if we are currently running (playing or recording).
 */
STDMETHODIMP_(NTSTATUS) CMiniportWaveICHStream::SetFormat
(
    IN  PKSDATAFORMAT   Format
)
{
    PAGED_CODE ();

    ASSERT (Format);

    ULONG   TempRate;
    DWORD   dwControlReg;

    DOUT (DBG_PRINT, ("[CMiniportWaveICHStream::SetFormat]"));
    
    //
    // Change sample rate when we are in the stop or pause states - not 
    // while running!
    //
    if (DMAEngineState & DMA_ENGINE_ON)
    {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Ensure format falls in proper range and is supported.
    //
    NTSTATUS ntStatus = Wave->TestDataFormat (Format, (WavePins)(Channel << 1));
    if (!NT_SUCCESS (ntStatus))
        return ntStatus;

    //
    // Retrieve wave format portion.
    //
    PWAVEFORMATPCMEX waveFormat = (PWAVEFORMATPCMEX)(Format + 1);
    
    //
    // Save current rate in this context.
    //
    TempRate = waveFormat->Format.nSamplesPerSec;
    
    //
    // Check if we have a codec with one sample rate converter and there are streams
    // already open.
    //
    if (Wave->Streams[PIN_WAVEIN_OFFSET] && Wave->Streams[PIN_WAVEOUT_OFFSET] &&
        !Wave->AdapterCommon->GetNodeConfig (NODEC_PCM_VSR_INDEPENDENT_RATES))
    {
        //
        // Figure out at which sample rate the other stream is running.
        //
        ULONG   ulFrequency;

        if (Wave->Streams[PIN_WAVEIN_OFFSET] == this)
            ulFrequency = Wave->Streams[PIN_WAVEOUT_OFFSET]->CurrentRate;
        else
            ulFrequency = Wave->Streams[PIN_WAVEIN_OFFSET]->CurrentRate;

        //
        // Check if this sample rate is requested sample rate.
        //
        if (ulFrequency != TempRate)
        {
            return STATUS_UNSUCCESSFUL;
        }
    }

    //
    // Program the ICH to support n channels.
    //
    if (Channel == PIN_WAVEOUT_OFFSET)
    {
        dwControlReg = Wave->AdapterCommon->ReadBMControlRegister32 (GLOB_CNT);
        dwControlReg = (dwControlReg & 0x03F) |
                       (((waveFormat->Format.nChannels >> 1) - 1) * GLOB_CNT_PCM4);
        Wave->AdapterCommon->WriteBMControlRegister (GLOB_CNT, dwControlReg);
    }
    
    //
    // Check for rate support by hardware.  If it is supported, then update 
    // hardware registers else return not implemented and audio stack will 
    // handle it.
    //
    if (Capture)
    {
        if (Channel == PIN_WAVEIN_OFFSET)
        {
            ntStatus = Wave->AdapterCommon->
                ProgramSampleRate (AC97REG_RECORD_SAMPLERATE, TempRate);
        }
        else
        {
            ntStatus = Wave->AdapterCommon->
                ProgramSampleRate (AC97REG_MIC_SAMPLERATE, TempRate);
        }
    }
    else
    {
        //
        // In the playback case we might need to update several DACs
        // with the new sample rate.
        //
        ntStatus = Wave->AdapterCommon->
            ProgramSampleRate (AC97REG_FRONT_SAMPLERATE, TempRate);

        if (Wave->AdapterCommon->GetNodeConfig (NODEC_SURROUND_DAC_PRESENT))
        {
            ntStatus = Wave->AdapterCommon->
                ProgramSampleRate (AC97REG_SURROUND_SAMPLERATE, TempRate);
        }
        if (Wave->AdapterCommon->GetNodeConfig (NODEC_LFE_DAC_PRESENT))
        {
            ntStatus = Wave->AdapterCommon->
                ProgramSampleRate (AC97REG_LFE_SAMPLERATE, TempRate);
        }
    }
        
    if (NT_SUCCESS (ntStatus))
    {
        //
        // print information and save the format information.
        //
        DataFormat = (PKSDATAFORMAT_WAVEFORMATEX)Format;
        CurrentRate = TempRate;
        NumberOfChannels = waveFormat->Format.nChannels;
    }
    
    return ntStatus;
}
    
/*****************************************************************************
 * CMiniportWaveICHStream::SetContentId
 *****************************************************************************
 * This routine gets called by drmk.sys to pass the content to the driver.
 * The driver has to enforce the rights passed.
 */
STDMETHODIMP_(NTSTATUS) CMiniportWaveICHStream::SetContentId
(
    IN  ULONG       contentId,
    IN  PCDRMRIGHTS drmRights
)
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[CMiniportWaveICHStream::SetContentId]"));

    //
    // If "drmRights->DigitalOutputDisable" is set, we need to disable S/P-DIF.
    // Currently, we don't have knowledge about the S/P-DIF interface. However,
    // in case you expanded the driver with S/P-DIF features you need to disable
    // S/P-DIF or fail SetContentId. If you have HW that has S/P-DIF turned on
    // by default and you don't know how to turn off (or you cannot do that)
    // then you must fail SetContentId.
    //
    // In our case, we assume the codec has no S/P-DIF or disabled S/P-DIF by
    // default, so we can ignore the flag.
    //
    // Store the copyright flag. We have to disable PCM recording if it's set.
    //
    if (!Wave->AdapterCommon->GetMiniportTopology ())
    {
        DOUT (DBG_ERROR, ("Topology pointer not set!"));
        return STATUS_UNSUCCESSFUL;
    }
    else
    {
        Wave->AdapterCommon->GetMiniportTopology ()->
            SetCopyProtectFlag (drmRights->CopyProtect);
    }

    //
    // We assume that if we can enforce the rights, that the old content
    // will be destroyed. We don't need to store the content id since we
    // have only one playback channel, so we are finished here.
    //
    
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * Non paged code begins here
 *****************************************************************************
 */

#pragma code_seg()
/*****************************************************************************
 * CMiniportWaveICHStream::PowerChangeNotify
 *****************************************************************************
 * This functions saves and maintains the stream state through power changes.
 */
NTSTATUS CMiniportWaveICHStream::PowerChangeNotify
(
    IN  POWER_STATE NewState
)
{
    PAGED_CODE ();

    KIRQL       OldIrql;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    
    DOUT (DBG_PRINT, ("[CMiniportWaveICHStream::PowerChangeNotify]"));
    
    //
    // We don't have to check the power state, that's already done by the wave
    // miniport.
    //

    DOUT (DBG_POWER, ("Changing state to D%d.",
                     (ULONG)NewState.DeviceState - (ULONG)PowerDeviceD0));
    
    switch (NewState.DeviceState)
    {
        case PowerDeviceD0:
            //
            // If we are coming from D2 or D3 we have to restore the registers cause
            // there might have been a power loss.
            //
            if ((m_PowerState == PowerDeviceD3) || (m_PowerState == PowerDeviceD2))
            {
                //
                // The scatter gather list is already arranged. A reset of the DMA
                // brings all pointers to the default state. From there we can start.
                //
                
                // Acquire the mapping spin lock
                KeAcquireSpinLock (&MapLock,&OldIrql);
                
                ntStatus = ResetDMA ();

                // Restore the remaining DMA registers, that is last valid index
                // only if the index is not pointing to 0. Note that the index is
                // equal to head + entries.
                if (stBDList.nTail)
                {
                    Wave->AdapterCommon->WriteBMControlRegister (m_ulBDAddr + X_LVI,
                                            (UCHAR)((stBDList.nTail - 1) & BDL_MASK));
                }

                // Release the mapping spin lock
                KeReleaseSpinLock (&MapLock,OldIrql);
            }
            break;

        case PowerDeviceD1:
            // Here we do nothing. The device has still enough power to keep all
            // it's register values.
            break;

        case PowerDeviceD2:
        case PowerDeviceD3:
            //
            // If we power down to D2 or D3 we might loose power, so we have to be
            // aware of the DMA engine resetting. In that case a play would start
            // with scatter gather entry 0 (the current index is read only).
            // We just rearrange the scatter gather list (like we do on
            // RevokeMappings) so that the current buffer which is played is at
            // entry 0.
            //
                
            // Acquire the mapping spin lock
            KeAcquireSpinLock (&MapLock,&OldIrql);

            // Disable interrupts and stop DMA just in case.
            Wave->AdapterCommon->WriteBMControlRegister (m_ulBDAddr + X_CR, (UCHAR)0);
    
            // Get current index 
            int nCurrentIndex = (int)Wave->AdapterCommon->
                ReadBMControlRegister8 (m_ulBDAddr + X_CIV);
    
            //
            // First move the BD list to the beginning.
            //
            // In case the DMA engine was stopped, current index may point to an
            // empty BD entry. When we start the DMA engine it would then play this
            // (undefined) entry, so we check here for that condition.
            //
            if ((nCurrentIndex == ((stBDList.nHead - 1) & BDL_MASK)) &&
               (stBDList.nBDEntries != MAX_BDL_ENTRIES - 1))
            {
                nCurrentIndex = stBDList.nHead;     // point to head
            }
    
            //
            // Move BD list to (0-((current - head) & mask)) & mask, where
            // ((current - head) & mask) is the difference between head and
            // current index, no matter where they are :)
            //
            MoveBDList (stBDList.nHead, (stBDList.nTail - 1) & BDL_MASK,
                    (0 - ((nCurrentIndex - stBDList.nHead) & BDL_MASK)) & BDL_MASK);
        
            //
            // Update structure.
            //
            stBDList.nHead = (0 - ((nCurrentIndex - stBDList.nHead) & BDL_MASK)) & 
                BDL_MASK;
            stBDList.nTail = (stBDList.nHead + stBDList.nBDEntries) & BDL_MASK;
            
            // release the mapping spin lock
            KeReleaseSpinLock (&MapLock,OldIrql);
            break;
    }
    
    //
    // Save the new state.  This local value is used to determine when to 
    // cache property accesses and when to permit the driver from accessing 
    // the hardware.
    //
    m_PowerState = NewState.DeviceState;
    DOUT (DBG_POWER, ("Entering D%d",
                      (ULONG)m_PowerState - (ULONG)PowerDeviceD0));

    return ntStatus;
}

/*****************************************************************************
 * CMiniportWaveICHStream::SetState
 *****************************************************************************
 * This routine sets/changes the DMA engine state to play, stop, or pause
 */
STDMETHODIMP_(NTSTATUS) CMiniportWaveICHStream::SetState
(
    IN  KSSTATE State
)
{
    PAGED_CODE ();      // Gets called at PASSIVE_LEVEL
    
    KIRQL OldIrql;
    
    DOUT (DBG_PRINT, ("[CMiniportWaveICHStream::SetState]"));
    DOUT (DBG_STREAM, ("SetState to %d", State));


    //
    // Start or stop the DMA engine dependent of the state.
    //
    switch (State)
    {
        case KSSTATE_STOP:
            // acquire the mapping spin lock
            KeAcquireSpinLock (&MapLock,&OldIrql);

            // Just pause DMA. If we have mappings left in our queue,
            // portcls will call RevokeMappings to destroy them.
            PauseDMA ();

            // release the mapping spin lock
            KeReleaseSpinLock (&MapLock,OldIrql);

            // Release processed mappings
            ReleaseUsedMappings ();

            // Reset the position counters.
            TotalBytesMapped = TotalBytesReleased = 0;
            break;
    
        case KSSTATE_ACQUIRE:
        case KSSTATE_PAUSE:
            // acquire the mapping spin lock
            KeAcquireSpinLock (&MapLock,&OldIrql);
            
            // pause now.
            PauseDMA ();

            // release the mapping spin lock
            KeReleaseSpinLock (&MapLock,OldIrql);
            
            // Release processed mappings
            ReleaseUsedMappings ();

            break;
    
        case KSSTATE_RUN:
            //
            // Let's rock.
            //
            
            
            // Make sure we are not running already.
            if (DMAEngineState & DMA_ENGINE_ON)
            {
                return STATUS_SUCCESS;
            }

            // Release processed mappings.
            ReleaseUsedMappings ();

            // Get new mappings.
            GetNewMappings ();

            // acquire the mapping spin lock
            KeAcquireSpinLock (&MapLock,&OldIrql);
            
            // Kick DMA again just in case.
            ResumeDMA ();
            
            // release the mapping spin lock
            KeReleaseSpinLock (&MapLock,OldIrql);
            break;
    }
    
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportWaveICHStream::MoveBDList
 *****************************************************************************
 * Moves the BDList.
 * This function is used to remove entries from the scatter gather list or to
 * move the valid entries to the top. The mapping table which is hard linked
 * to the scatter gather entries is moved too.
 * The function does not change any variables in tBDList.
 * The mapping spin lock must be held when calling this routine.
 * We use this function to remove mappings (RevokeMappings) or to rearrange the
 * list for powerdown/up management (the DMA starts at position zero again).
 * Note that there is a simple way of doing this also. When you zero the buffer
 * length in the scatter gather, the DMA engine ignores the entry and continues
 * with the next. But our way is more generic and if you ever want to port the
 * driver to another DMA engine you might be thankful for this code.
 */
void CMiniportWaveICHStream::MoveBDList
(
    IN  int nFirst, 
    IN  int nLast, 
    IN  int nNewPos
)
{
    DOUT (DBG_PRINT, ("[CMiniportWaveICHStream::MoveBDList]"));
    
    //
    // Print information about the scatter gather list.
    //
    DOUT (DBG_DMA, ("Moving BD entry %d-%d to %d.", nFirst, nLast, nNewPos));

    //
    // First copy the tables to a save place.
    //
    RtlCopyMemory ((PVOID)stBDList.pBDEntryBackup,
                   (PVOID)stBDList.pBDEntry,
                   sizeof (tBDEntry) * MAX_BDL_ENTRIES);
    RtlCopyMemory ((PVOID)stBDList.pMapDataBackup,
                   (PVOID)stBDList.pMapData,
                   sizeof (tMapData) * MAX_BDL_ENTRIES);

    //
    // We move all the entries in blocks to the new position.
    //
    int nBlockCounter = 0;
    do
    {
        nBlockCounter++;
        //
        // We must copy the block when the index wraps around (ring buffer)
        // or we are at the last entry.
        //
        if (((nNewPos + nBlockCounter) == MAX_BDL_ENTRIES) ||   // wrap around
            ((nFirst + nBlockCounter) == MAX_BDL_ENTRIES) ||    // wrap around
            ((nFirst + nBlockCounter) == (nLast + 1)))          // last entry
        {
            //
            // copy one block (multiple entries).
            //
            RtlCopyMemory ((PVOID)&stBDList.pBDEntry[nNewPos],
                           (PVOID)&stBDList.pBDEntryBackup[nFirst],
                           sizeof (tBDEntry) * nBlockCounter);
            RtlCopyMemory ((PVOID)&stBDList.pMapData[nNewPos],
                           (PVOID)&stBDList.pMapDataBackup[nFirst],
                           sizeof (tMapData) * nBlockCounter);
            // adjust the index
            nNewPos = (nNewPos + nBlockCounter) & BDL_MASK;
            nFirst = (nFirst + nBlockCounter) & BDL_MASK;
            nBlockCounter = 0;
        }
    // nBlockCounter should be zero when the end condition hits.
    } while (((nFirst + nBlockCounter - 1) & BDL_MASK) != nLast);
}


/*****************************************************************************
 * CMiniportWaveICHStream::Service
 *****************************************************************************
 * This routine is called by the port driver in response to the interrupt
 * service routine requesting service on the stream's service group.
 * Requesting service on the service group results in a DPC being scheduled
 * that calls this routine when it runs.
 */
STDMETHODIMP_(void) CMiniportWaveICHStream::Service (void)
{

    DOUT (DBG_PRINT, ("Service"));

    // release all mappings
    ReleaseUsedMappings ();

    // get new mappings
    GetNewMappings ();
}


/*****************************************************************************
 * CMiniportWaveICHStream::NormalizePhysicalPosition
 *****************************************************************************
 * Given a physical position based on the actual number of bytes transferred,
 * this function converts the position to a time-based value of 100ns units.
 */
STDMETHODIMP_(NTSTATUS) CMiniportWaveICHStream::NormalizePhysicalPosition
(
    IN OUT PLONGLONG PhysicalPosition
)
{
    ULONG SampleSize;

    DOUT (DBG_PRINT, ("NormalizePhysicalPosition"));

    //
    // Determine the sample size in bytes
    //
    SampleSize = DataFormat->WaveFormatEx.nChannels * 2;

    //
    // Calculate the time in 100ns steps.
    //
    *PhysicalPosition = (_100NS_UNITS_PER_SECOND / SampleSize * 
                         *PhysicalPosition) / CurrentRate;

    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICHStream::GetPosition
 *****************************************************************************
 * Gets the stream position. This is a byte count of the current position of
 * a stream running on a particular DMA engine.  We must return a sample
 * accurate count or the WaveDrv32 wave drift tests (35.2 & 36.2) will fail.
 *
 * The position is the sum of three parts:
 *     1) The total number of bytes in released buffers
 *     2) The position in the current buffer.
 *     3) The total number of bytes in played but not yet released buffers
 */
STDMETHODIMP_(NTSTATUS) CMiniportWaveICHStream::GetPosition
(
    OUT PULONGLONG   Position
)
{
    KIRQL   OldIrql;
    UCHAR   nCurrentIndex = 0;
    DWORD   RegisterX_PICB;

    ASSERT (Position);
               
    //
    // Acquire the mapping spin lock.
    //
    KeAcquireSpinLock (&MapLock, &OldIrql);

    //
    // Start with TotalBytesReleased (mappings released).
    //
    *Position = TotalBytesReleased;
    
    //
    // If we have entries in the list, we may have buffers that have not been
    // released but have been at least partially played.
    //
    if (stBDList.nBDEntries)
    {
        //
        // Repeat this until we get the same reading twice.  This will prevent
        // jumps when we are near the end of the buffer.
        //
        do
        {
            nCurrentIndex = Wave->AdapterCommon->
                ReadBMControlRegister8 (m_ulBDAddr + X_CIV);
            
            RegisterX_PICB = (DWORD)Wave->AdapterCommon->ReadBMControlRegister16 (m_ulBDAddr + X_PICB);
        } while (nCurrentIndex != (int)Wave->AdapterCommon->
                ReadBMControlRegister8 (m_ulBDAddr + X_CIV));
        
        //
        // If we never released a buffer and register X_PICB is zero then the DMA was not
        // initialized yet and the position should be zero.
        //
        if (RegisterX_PICB || nCurrentIndex || TotalBytesReleased)
        {
            //
            // Add in our position in the current buffer.  The read returns the 
            // amount left in the buffer.
            //
            *Position += (stBDList.pMapData[nCurrentIndex].ulBufferLength - (RegisterX_PICB << 1));
            
            //
            // Total any buffers that have been played and not released.
            //
            if (nCurrentIndex != ((stBDList.nHead -1) & BDL_MASK))
            {
                int i = stBDList.nHead;
                while (i != nCurrentIndex)
                {
                    *Position += (ULONGLONG)stBDList.pMapData[i].ulBufferLength;
                    i = (i + 1) & BDL_MASK;
                }
            }
        }
    }

    DOUT (DBG_POSITION, ("[GetPosition] POS: %08x'%08x\n", (DWORD)(*Position >> 32), (DWORD)*Position));

    //
    // Release the mapping spin lock.
    //
    KeReleaseSpinLock (&MapLock, OldIrql);


    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICHStream::RevokeMappings
 *****************************************************************************
 * This routine is used by the port to revoke mappings previously delivered 
 * to the miniport stream that have not yet been unmapped.  This would 
 * typically be called in response to an I/O cancellation request.
 */
STDMETHODIMP_(NTSTATUS) CMiniportWaveICHStream::RevokeMappings
(
    IN  PVOID     FirstTag,
    IN  PVOID     LastTag,
    OUT PULONG    MappingsRevoked
)
{
    ASSERT (MappingsRevoked);

    KIRQL   OldIrql;
    ULONG   ulOldDMAEngineState;
    int     nCurrentIndex, nSearchIndex, nFirst, nLast, nNumMappings;

    DOUT (DBG_PRINT, ("[CMiniportWaveICHStream::RevokeMappings]"));
    
    //
    // print information about the scatter gather list.
    //
    DOUT (DBG_DMA, ("Head %d, Tail %d, Tag counter %d, Entries %d.",
                   stBDList.nHead, stBDList.nTail, stBDList.ulTagCounter, 
                   stBDList.nBDEntries));

    //
    // Start accessing the mappings.
    //
    KeAcquireSpinLock (&MapLock, &OldIrql);

    //
    // Save old DMA engine state.
    //
    ulOldDMAEngineState = DMAEngineState;
    
    //
    // First stop the DMA engine so it won't process the next buffer in the
    // scatter gather list which might be one of the revoked buffers.
    //
    PauseDMA ();

    // Get current index 
    nCurrentIndex = Wave->AdapterCommon->
        ReadBMControlRegister8 (m_ulBDAddr + X_CIV);

    //
    // We always rearrange the scatter gather list. That means we reset the DMA
    // engine and move the BD list so that the entry where the current index
    // pointed to is located at position 0.
    //
    ResetDMA ();

    //
    // Return immediately if we just have 1 entry in our BD list.
    //
    if (!stBDList.nBDEntries || (stBDList.nBDEntries == 1))
    {
        *MappingsRevoked = stBDList.nBDEntries;
        stBDList.nHead = stBDList.nTail = stBDList.nBDEntries = 0;
        
        //
        // CIV and LVI of DMA registers are set to 0 already.
        //
        KeReleaseSpinLock (&MapLock, OldIrql);
        return STATUS_SUCCESS;
    }

    //
    // First move the BD list to the beginning.  In case the DMA engine was 
    // stopped, current index may point to an empty BD entry.
    //
    if ((nCurrentIndex == ((stBDList.nHead - 1) & BDL_MASK)) &&
       (stBDList.nBDEntries != MAX_BDL_ENTRIES - 1))
    {
        nCurrentIndex = stBDList.nHead;     // point to head
    }

    //
    // Move BD list to (0-((current - head) & mask)) & mask
    // where ((current - head) & mask) is the difference between head and
    // current index, no matter where they are :)
    //
    MoveBDList (stBDList.nHead, (stBDList.nTail - 1) & BDL_MASK,
            (0 - ((nCurrentIndex - stBDList.nHead) & BDL_MASK)) & BDL_MASK);
    
    //
    // Update structure.
    //
    stBDList.nHead = (0 - ((nCurrentIndex - stBDList.nHead) & BDL_MASK)) & 
        BDL_MASK;
    stBDList.nTail = (stBDList.nHead + stBDList.nBDEntries) & BDL_MASK;

    //
    // Then we have to search for the tags. If we wouldn't have to rearrange the
    // scatter gather list all the time, then we could use the tag as an index
    // to the array, but the only way to clear DMA caches is a reset which has
    // the side-effect that we have to rearrange the BD list (see above).
    //
    // search for first...
    //
    nSearchIndex = stBDList.nHead;
    do
    {
        if ((void *)ULongToPtr(stBDList.pMapData[nSearchIndex].ulTag) == FirstTag)
            break;
        nSearchIndex = (nSearchIndex + 1) & BDL_MASK;
    } while (nSearchIndex != stBDList.nTail);
    nFirst = nSearchIndex;
    
    //
    // Search for last...
    //
    nSearchIndex = stBDList.nHead;
    do
    {
        if ((void *)ULongToPtr(stBDList.pMapData[nSearchIndex].ulTag) == LastTag)
            break;
        nSearchIndex = (nSearchIndex + 1) & BDL_MASK;
    } while (nSearchIndex != stBDList.nTail);
    nLast = nSearchIndex;


    //
    // Check search result.
    //
    if ((nFirst == stBDList.nTail) || (nLast == stBDList.nTail))
    {
        DOUT (DBG_ERROR, ("!!! Entry not found !!!"));
        
        //
        // restart DMA in case it was running
        //
        if ((ulOldDMAEngineState & DMA_ENGINE_ON) && stBDList.nBDEntries)
            ResumeDMA ();
        *MappingsRevoked = 0;
        KeReleaseSpinLock (&MapLock, OldIrql);
        return STATUS_UNSUCCESSFUL;         // one of the tags not found
    }

    // Print the index numbers found.
    DOUT (DBG_DMA, ("Removing entries %d (%d) to %d (%d).", nFirst, FirstTag,
                  nLast, LastTag));

    //
    // Calculate the entries between the indizes.
    //
    if (nLast < nFirst)
    {
        nNumMappings = ((nLast + MAX_BDL_ENTRIES) - nFirst) + 1;
    }
    else
    {
        nNumMappings = (nLast - nFirst) + 1;
    }

    //
    // Print debug inormation.
    //
    DOUT (DBG_DMA, ("Found entries: %d-%d, %d entries.", nFirst, nLast, 
                   nNumMappings));
    
    //
    // Now remove the revoked buffers.  Move the BD list and modify the 
    // status information.
    //
    if (nFirst < stBDList.nTail)
    {
        //
        // In this case, both first and last are >= the current index (0)
        //
        if (nLast != ((stBDList.nTail - 1) & BDL_MASK))
        {
            //
            // Not the last entry, so move the BD list + mappings.
            //
            MoveBDList ((nLast + 1) & BDL_MASK, (stBDList.nTail - 1) & BDL_MASK,
                        nFirst);
        }
        stBDList.nTail = (stBDList.nTail - nNumMappings) & BDL_MASK;
    }

    //
    // In this case, at least first is "<" than current index (0)
    //
    else    
    {
        //
        // Check for last.
        //
        if (nLast < stBDList.nTail)
        {                 
            //
            // Last is ">=" current index and first is "<" current index (0).
            // Remove MAX_DBL_ENTRIES - first entries in front of current index.
            //
            if (nFirst != stBDList.nHead)
            {
                //
                // Move from head towards current index.
                //
                MoveBDList (stBDList.nHead, nFirst - 1, 
                           (stBDList.nHead + (MAX_BDL_ENTRIES - nFirst)) & 
                           BDL_MASK);
            }

            //
            // Adjust head.
            //
            stBDList.nHead = (stBDList.nHead + (MAX_BDL_ENTRIES - nFirst)) & 
                BDL_MASK;

            //
            // Remove nLast entries from CIV to tail.
            //
            if (nLast != ((stBDList.nTail - 1) & BDL_MASK))
            {
                //
                // Not the last entry, so move the BD list + mappings.
                //
                MoveBDList (nLast + 1, (stBDList.nTail - 1) & BDL_MASK, 0);
            }

            //
            // Adjust tail.
            //
            stBDList.nTail = (stBDList.nTail - (nLast + 1)) & BDL_MASK;
        }

        //
        // Last is "<" current index and first is "<" current index (0).
        //
        else
        {
            //
            // Remove nNumMappings entries in front of current index.
            //
            if (nFirst != stBDList.nHead)
            {
                //
                // Move from head towards current index.
                //
                MoveBDList (stBDList.nHead, nFirst - 1, 
                           (nLast - nNumMappings) + 1);
            }
            
            //
            // Adjust head.
            //
            stBDList.nHead = (stBDList.nHead + nNumMappings) & BDL_MASK;
        }
    }

    //
    // In all cases, reduce the number of mappings.
    //
    stBDList.nBDEntries -= nNumMappings;

    //
    // Print debug information.
    //
    DOUT (DBG_DMA, ("Number of mappings is now %d, Head is %d, Tail is %d",
            stBDList.nBDEntries, stBDList.nHead, stBDList.nTail));
    
    //
    // Reprogram the last valid index only when tail != 0
    //
    if (stBDList.nTail)
    {
        Wave->AdapterCommon->WriteBMControlRegister (m_ulBDAddr + X_LVI,
                    (UCHAR)(stBDList.nTail - 1 & BDL_MASK));
    }

    //
    // Just un-pause the DMA engine if it was running before and there are 
    // still entries left and tail != 0.
    //
    if ((ulOldDMAEngineState & DMA_ENGINE_ON) && stBDList.nBDEntries 
       && stBDList.nTail)
    {
        ResumeDMA ();
    }

    //
    // Release the mapping spin lock and return the number of mappings we 
    // revoked.
    //
    KeReleaseSpinLock (&MapLock, OldIrql);
    *MappingsRevoked = nNumMappings;
    
    
    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICHStream::MappingAvailable
 *****************************************************************************
 * This routine is called by the port driver to notify the stream that there
 * are new mappings available.  Note that this is ONLY called after the stream
 * has previously had a GetMapping() call fail due to lack of available
 * mappings.
 */
STDMETHODIMP_(void) CMiniportWaveICHStream::MappingAvailable (void)
{
    DOUT (DBG_PRINT, ("MappingAvailable"));

    //
    // Release processed mappings.
    //
    ReleaseUsedMappings ();

    //
    // Process the new mappings.
    //
    GetNewMappings ();
}


/*****************************************************************************
 * CMiniportWaveICHStream::GetNewMappings
 *****************************************************************************
 * This routine is called when new mappings are available from the port driver.
 * The routine places mappings into the input mapping queue. ICH can handle up
 * to 32 entries (descriptors). We program the DMA registers if we have at least
 * one mapping in the queue. The mapping spin lock must be held when calling
 * this routine.
 */
NTSTATUS CMiniportWaveICHStream::GetNewMappings (void)
{
    KIRQL OldIrql;
    
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    ULONG       ulBytesMapped = 0;
    int         nInsertMappings = 0;
    int         nTail;                  // aut. variable

    DOUT (DBG_PRINT, ("[CMiniportWaveICHStream::GetNewMappings]"));

    // acquire the mapping spin lock
    KeAcquireSpinLock (&MapLock,&OldIrql);

#if (DBG)
    if (Wave->AdapterCommon->ReadBMControlRegister16 (m_ulBDAddr + X_SR) & SR_CELV)
    {
        //
        // We starve.  :-(
        //
        DOUT (DBG_DMA, ("[GetNewMappings] We starved ... Head %d, Tail %d, Entries %d.",
                stBDList.nHead, stBDList.nTail, stBDList.nBDEntries));
    }
#endif

    //
    // Get available mappings up to the max of 31 that we can hold in the BDL.
    //
    while (stBDList.nBDEntries < (MAX_BDL_ENTRIES - 1))
    {
        //
        // Get the information from the list.
        //
        ULONG               Flags;
        ULONG               ulTag = stBDList.ulTagCounter++;
        ULONG               ulBufferLength;
        PHYSICAL_ADDRESS    PhysAddr;
        PVOID               VirtAddr;


        // Release the mapping spin lock
        KeReleaseSpinLock (&MapLock,OldIrql);

        //
        // Try to get the mapping from the port.
        // Here comes the problem: When calling GetMapping or ReleaseMapping we
        // cannot hold our spin lock. So we need to buffer the return values and
        // stick the information into the structure later when we have the spin
        // lock acquired.
        //
        ntStatus = PortStream->GetMapping ((PVOID)ULongToPtr(ulTag),
                                           (PPHYSICAL_ADDRESS)&PhysAddr,
                                           &VirtAddr,
                                           &ulBufferLength,
                                           &Flags);
    
        // Acquire the mapping spin lock
        KeAcquireSpinLock (&MapLock,&OldIrql);
        
        //
        // Quit this loop when we run out of mappings.
        //
        if (!NT_SUCCESS (ntStatus))
        {
            break;
        }

        // Sanity check: The audio stack will not give you data
        // that you cannot handle, but an application could use
        // DirectKS and send bad buffer down.

        // One mapping needs to be <0x1FFFF bytes for mono
        // streams on the ICH.
        if (ulBufferLength > 0x1FFFE)
        {
            // That is a little too long. That should never happen.
            DOUT (DBG_ERROR, ("[GetNewMappings] Buffer length too long!"));
            ulBufferLength = 0x1FFFE;
        }

        // The ICH can only handle WORD aligned buffers.
        if (PhysAddr.LowPart & 0x01)
        {
            // we cannot play that! Set the buffer length to 0 so
            // that the HW will skip the buffer.
            DOUT (DBG_WARNING, ("[GetNewMappings] Buffer address unaligned!"));
            ulBufferLength = 0;
        }

        // The ICH cannot handle unaligned mappings with respect
        // to the frame size (eg. 42 bytes on 4ch playback).
        if (ulBufferLength % NumberOfChannels)
        {
            // modify the length (don't play the rest of the bytes)
            DOUT (DBG_WARNING, ("[GetNewMappings] Buffer length unaligned!"));
            ulBufferLength -= ulBufferLength % NumberOfChannels;
        }

        //
        // Save the mapping.
        //
        nTail = stBDList.nTail;
        stBDList.pMapData[nTail].ulTag = ulTag;
        stBDList.pMapData[nTail].PhysAddr = PhysAddr;
        stBDList.pMapData[nTail].pVirtAddr = VirtAddr;
        stBDList.pMapData[nTail].ulBufferLength = ulBufferLength;
        ulBytesMapped += ulBufferLength;

        //
        // Fill in the BDL entry with pointer to physical address and length.
        //
        stBDList.pBDEntry[nTail].dwPtrToPhyAddress = PhysAddr.LowPart;
        stBDList.pBDEntry[nTail].wLength = (WORD)(ulBufferLength >> 1);
        stBDList.pBDEntry[nTail].wPolicyBits = BUP_SET;

        //
        // Generate an interrupt when portcls tells us to or roughly every 10ms.
        //
        if (Flags || (ulBytesMapped > (CurrentRate * NumberOfChannels * 2) / 100))
        {
            stBDList.pBDEntry[nTail].wPolicyBits |= IOC_ENABLE; 
            ulBytesMapped = 0;
        }

        //
        // Take the new mapping into account.
        //
        stBDList.nTail = (stBDList.nTail + 1) & BDL_MASK;
        stBDList.nBDEntries++;
        TotalBytesMapped += (ULONGLONG)ulBufferLength;
        nInsertMappings++;

        //
        // Set last valid index (LVI) register! We need to do this here to avoid inconsistency
        // of the BDList with the HW. Note that we need to release spin locks every time
        // we call into portcls, that means we can be interrupted by ReleaseUsedMappings.
        //
        Wave->AdapterCommon->WriteBMControlRegister (m_ulBDAddr + X_LVI, (UCHAR)nTail);
    }

    //
    // If there were processed mappings, print out some debug messages and eventually try to
    // restart DMA engine.
    //
    if (nInsertMappings)
    {
        //
        // Print debug information ...
        //
        DOUT (DBG_DMA, ("[GetNewMappings] Got %d mappings.", nInsertMappings));
        DOUT (DBG_DMA, ("[GetNewMappings] Head %d, Tail %d, Entries %d.",
                stBDList.nHead, stBDList.nTail, stBDList.nBDEntries));


        if (DMAEngineState & DMA_ENGINE_NEED_START)
            ResumeDMA ();
    }

    // Release the mapping spin lock
    KeReleaseSpinLock (&MapLock,OldIrql);
    
    return ntStatus;
}


/*****************************************************************************
 * CMiniportWaveICHStream::ReleaseUsedMappings
 *****************************************************************************
 * This routine unmaps previously mapped memory that the hardware has 
 * completed processing on.  This routine is typically called at DPC level 
 * from the stream deferred procedure call that results from a stream 
 * interrupt. The mapping spin lock must be held when calling this routine.
 */
NTSTATUS CMiniportWaveICHStream::ReleaseUsedMappings (void)
{
    KIRQL OldIrql;
    int   nMappingsReleased = 0;
    
    DOUT (DBG_PRINT, ("[CMiniportWaveICHStream::ReleaseUsedMappings]"));

    // acquire the mapping spin lock
    KeAcquireSpinLock (&MapLock,&OldIrql);

    //
    // Clean up everything to that index.
    //
    while (stBDList.nBDEntries)
    {
        //
        // Get current index 
        //
        int nCurrentIndex = (int)Wave->AdapterCommon->
            ReadBMControlRegister8 (m_ulBDAddr + X_CIV);

        //
        // When CIV is == Head -1 we released all mappings.
        //
        if (nCurrentIndex == ((stBDList.nHead - 1) & BDL_MASK))
        {
           break;
        }
        
        //
        // Check if CIV is between head and tail.
        //
        if (nCurrentIndex < stBDList.nHead)
        {
            //
            // Check for CIV being outside range.
            //
            if ((nCurrentIndex + MAX_BDL_ENTRIES) >=
                (stBDList.nHead + stBDList.nBDEntries))
            {
                DOUT (DBG_ERROR, ("[ReleaseUsedMappings] CIV out of range!"));
                break;
            }
        }
        else
        {
            //
            // Check for CIV being outside range.
            //
            if (nCurrentIndex >= (stBDList.nHead + stBDList.nBDEntries))
            {
                DOUT (DBG_ERROR, ("[ReleaseUsedMappings] CIV out of range!"));
                break;
            }
        }

        //
        // Check to see if we've released all the buffers.
        //
        if (stBDList.nHead == nCurrentIndex)
        {
            if (nCurrentIndex == ((stBDList.nTail - 1) & BDL_MASK))
            {
                //
                // A special case is starvation or stop of stream, when the 
                // DMA engine finished playing the buffers, CVI is equal LVI 
                // and SR_CELV is set.
                //
                if (!(Wave->AdapterCommon->
                     ReadBMControlRegister16 (m_ulBDAddr + X_SR) & SR_CELV))
                {
                    // It is still playing the last buffer.
                    break;
                }

                //
                // In case the CVI=LVI bit is set, nBDEntries should be 1
                //
                if (stBDList.nBDEntries != 1)
                {
                    DOUT (DBG_ERROR, ("[ReleaseUsedMappings] Inconsitency: Tail reached and Entries != 1."));
                }
            }
            else
            {
                //
                // Bail out. Current Index did not move.
                //
                break;
            }
        }

        //
        // Save the tag and remove the entry from the list.
        //
        ULONG   ulTag = stBDList.pMapData[stBDList.nHead].ulTag;
        TotalBytesReleased += (ULONGLONG)stBDList.pMapData[stBDList.nHead].ulBufferLength;
        stBDList.nBDEntries--;
        stBDList.nHead = (stBDList.nHead + 1) & BDL_MASK;
        nMappingsReleased++;

        // Release the mapping spin lock
        KeReleaseSpinLock (&MapLock,OldIrql);

        //
        // Release this entry.
        //
        PortStream->ReleaseMapping ((PVOID)ULongToPtr(ulTag));
        
        // acquire the mapping spin lock
        KeAcquireSpinLock (&MapLock,&OldIrql);
    }


    // Print some debug information in case we released mappings.
    if (nMappingsReleased)
    {
        //
        // Print release information and return.
        //
        DOUT (DBG_DMA, ("[ReleaseUsedMappings] Head %d, Tail %d, Entries %d.",
                       stBDList.nHead, stBDList.nTail, stBDList.nBDEntries));
    }        

    // Release the mapping spin lock
    KeReleaseSpinLock (&MapLock,OldIrql);
    
    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICHStream::ResetDMA
 *****************************************************************************
 * This routine resets the Run/Pause bit in the control register. In addition, it
 * resets all DMA registers contents.
 * You need to have the spin lock "MapLock" acquired.
 */
NTSTATUS CMiniportWaveICHStream::ResetDMA (void)
{
    DOUT (DBG_PRINT, ("ResetDMA"));

    //
    // Turn off DMA engine (or make sure it's turned off)
    //
    UCHAR RegisterValue = Wave->AdapterCommon->
        ReadBMControlRegister8 (m_ulBDAddr + X_CR) & ~CR_RPBM;
    Wave->AdapterCommon->
        WriteBMControlRegister (m_ulBDAddr + X_CR, RegisterValue);

    //
    // Reset all register contents.
    //
    RegisterValue |= CR_RR;
    Wave->AdapterCommon->
        WriteBMControlRegister (m_ulBDAddr + X_CR, RegisterValue);
    
    //
    // Wait until reset condition is cleared by HW; should not take long.
    //
    ULONGLONG ullStartTime = PcGetTimeInterval (0);
    BOOL bTimedOut = TRUE;
    do
    {
        if (!(Wave->AdapterCommon->
           ReadBMControlRegister8 (m_ulBDAddr + X_CR) & CR_RR))
        {
            bTimedOut = FALSE;
            break;
        }
    } while (PcGetTimeInterval (ullStartTime) < GTI_MILLISECONDS (1000));

    if (bTimedOut)
    {
        DOUT (DBG_ERROR, ("ResetDMA TIMEOUT!!"));
    }
    
    //
    // We only want interrupts upon completion.
    //
    RegisterValue = CR_IOCE | CR_LVBIE;
    Wave->AdapterCommon->
        WriteBMControlRegister (m_ulBDAddr + X_CR, RegisterValue);
    
    //
    // Setup the Buffer Descriptor Base Address (BDBA) register.
    //
    Wave->AdapterCommon->
        WriteBMControlRegister (m_ulBDAddr,
                               stBDList.PhysAddr.u.LowPart);

    //
    // Set the DMA engine state.
    //
    DMAEngineState = DMA_ENGINE_RESET;


    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICHStream::PauseDMA
 *****************************************************************************
 * This routine pauses a hardware stream by reseting the Run/Pause bit in the
 * control registers, leaving DMA registers content intact so that the stream
 * can later be resumed.
 * You need to have the spin lock "MapLock" acquired.
 */
NTSTATUS CMiniportWaveICHStream::PauseDMA (void)
{
    DOUT (DBG_PRINT, ("PauseDMA"));

    //
    // Only pause if we're actually "ON" (DMA_ENGINE_ON or DMA_ENGINE_NEED_START)
    //
    if (!(DMAEngineState & DMA_ENGINE_ON))
    {
        return STATUS_SUCCESS;
    }

    //
    // Turn off DMA engine by resetting the RPBM bit to 0. Don't reset any 
    // registers.
    //
    UCHAR RegisterValue = Wave->AdapterCommon->
        ReadBMControlRegister8 (m_ulBDAddr + X_CR);
    RegisterValue &= ~CR_RPBM;
    Wave->AdapterCommon->
        WriteBMControlRegister (m_ulBDAddr + X_CR, RegisterValue);

    //
    // DMA_ENGINE_NEED_START transitions to DMA_ENGINE_RESET.
    // DMA_ENGINE_ON transitions to DMA_ENGINE_OFF.
    //
    DMAEngineState &= DMA_ENGINE_RESET;

    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICHStream::ResumeDMA
 *****************************************************************************
 * This routine sets the Run/Pause bit for the particular DMA engine to resume
 * it after it's been paused. This assumes that DMA registers content have 
 * been preserved.
 * You need to have the spin lock "MapLock" acquired.
 */
NTSTATUS CMiniportWaveICHStream::ResumeDMA (void)
{
    DOUT (DBG_PRINT, ("ResumeDMA"));

    //
    // Before we can turn on the DMA engine the first time, we need to check
    // if we have at least 2 mappings in the scatter gather table.
    //
    if ((DMAEngineState & DMA_ENGINE_RESET) && (stBDList.nBDEntries < 2))
    {
        //
        // That won't work. Set engine state to DMA_ENGINE_NEED_START so that
        // we don't forget to call here regularly.
        //
        DMAEngineState = DMA_ENGINE_NEED_START;
        return STATUS_SUCCESS;
    }

    //
    // Turn DMA engine on by setting the RPBM bit to 1. Don't do anything to 
    // the registers.
    //
    UCHAR RegisterValue = Wave->AdapterCommon->
        ReadBMControlRegister8 (m_ulBDAddr + X_CR) | CR_RPBM;
    Wave->AdapterCommon->
        WriteBMControlRegister (m_ulBDAddr + X_CR, RegisterValue);

    //
    // Set the DMA engine state.
    //
    DMAEngineState = DMA_ENGINE_ON;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\ichwave.h ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

#ifndef _ICHWAVE_H_
#define _ICHWAVE_H_

#include "shared.h"

//*****************************************************************************
// Defines
//*****************************************************************************

//
// The scatter gather can (only) handle 32 entries
//
const int MAX_BDL_ENTRIES = 32;

//
// Mask for accessing the scatter gather entries with a counter.
//
const int BDL_MASK = 31;

//
// These are the differnet DMA engine states. The HW can only be in two states
// (on or off) but there are also 2 transition states.
// From DMA_ENGINE_RESET a failed start transitions to DMA_ENGINE_NEED_START, a
// successful start transitions to DMA_ENGINE_ON. From DMA_ENGINE_NEED_START a
// successful restart transitions to DMA_ENGINE_ON, a pause or stop transitions
// to DMA_ENGINE_RESET. From DMA_ENGINE_ON a pause or stop transitions to
// DMA_ENGINE_OFF. From DMA_ENGINE_OFF a start transitions to DMA_ENGINE_ON,
// a reset would transitions to DMA_ENGINE_RESET.
//
const int DMA_ENGINE_OFF        = 0;
const int DMA_ENGINE_ON         = 1;
const int DMA_ENGINE_RESET      = 2;
const int DMA_ENGINE_NEED_START = 3; // DMA_ENGINE_RESET | DMA_ENGINE_ON


 
//*****************************************************************************
// Data Structures and Typedefs
//*****************************************************************************

//
// This is a description of one mapping entry. It contains information
// about the buffer and a tag which is used for "cancel mappings".
// For one mapping that is described here, there is an entry in the
// scatter gather engine.
//
typedef struct tagMapData
{
    ULONG               ulTag;                  //tag, a simple counter.
    PHYSICAL_ADDRESS    PhysAddr;               //phys. addr. of buffer
    PVOID               pVirtAddr;              //virt. addr. of buffer
    ULONG               ulBufferLength;         //buffer length
} tMapData;

//
// Structure to describe the ICH Buffer Descriptor List (BDL).
// The ICH can handle 32 entries, they are allocated at once in common
// memory (non-cached memory). To avoid slow-down of CPU, the additional
// information for handling this structure is stored in tBDList.
//
typedef struct tagBDEntry
{
    DWORD   dwPtrToPhyAddress;
    WORD    wLength;
    WORD    wPolicyBits;
} tBDEntry;

//
// Structure needed to keep track of the BDL tables.
// This structure is seperated from tBDEntry because we want to
// have it in cached memory (and not along with tBDEntry in non-
// cached memory).
//
typedef struct tagBDList
{
    PHYSICAL_ADDRESS        PhysAddr;       // Physical address of BDList
    volatile tBDEntry       *pBDEntry;      // Virtual Address of BDList
    tBDEntry                *pBDEntryBackup;// needed for rearranging the BDList
    tMapData                *pMapData;      // mapping list
    tMapData                *pMapDataBackup;// needed for rearranging the BDList
    int                     nHead;          // index for the BDL Head
    int                     nTail;          // index for the BDL Tail
    ULONG                   ulTagCounter;   // the tag is a simple counter.
    int                     nBDEntries;     // number of entries.
} tBDList;



//*****************************************************************************
// Classes
//*****************************************************************************

/*****************************************************************************
 * CMiniportWaveICHStream
 *****************************************************************************
 * ICH wave miniport stream.
 */
class CMiniportWaveICHStream : public IMiniportWavePciStream,
                               public IDrmAudioStream,
                               public CUnknown
{
private:
    //
    // CMiniportWaveICHStream private variables
    //
    CMiniportWaveICH *          Wave;           // Miniport Object
    ULONG                       Channel;        // channel this stream handles.
    BOOL                        Capture;        // TRUE=Capture,FALSE=Render
    ULONG                       CurrentRate;    // Current Sample Rate
    WORD                        NumberOfChannels; // Number of channels
    PSERVICEGROUP               ServiceGroup;   // service group helps with DPCs
    tBDList                     stBDList;       // needed for scatter gather org.
    PPORTWAVEPCISTREAM          PortStream;     // Port Stream Interface
    PKSDATAFORMAT_WAVEFORMATEX  DataFormat;     // Data Format
    KSPIN_LOCK                  MapLock;        // for processing mappings.
    ULONG               m_ulBDAddr;         // Offset of the stream's DMA registers.
    ULONG               DMAEngineState;     // DMA engine state (STOP, PAUSE, RUN)
    ULONGLONG           TotalBytesMapped;   // factor in position calculation
    ULONGLONG           TotalBytesReleased; // factor in position calculation
    DEVICE_POWER_STATE  m_PowerState;       // Current power state of the device.


    /*************************************************************************
     * CMiniportWaveICHStream methods
     *************************************************************************
     *
     * These are private member functions used internally by the object.  See
     * ICHWAVE.CPP for specific descriptions.
     */

    //
    // Moves the BDL and associated mappings list around.
    //
    void MoveBDList
    (
        IN  int nFirst, 
        IN  int nLast, 
        IN  int nNewPos
    );

    //
    // Called when new mappings have to be processed.
    //
    NTSTATUS GetNewMappings (void);

    //
    // Called when we want to release some mappings.
    //
    NTSTATUS ReleaseUsedMappings (void);

    //
    // DMA start/stop/pause/reset routines.
    //
    NTSTATUS ResetDMA (void);
    NTSTATUS PauseDMA (void);
    NTSTATUS ResumeDMA (void);
    

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in ICHWAVE.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in ICHWAVE.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN ();
    DEFINE_STD_CONSTRUCTOR (CMiniportWaveICHStream);

    ~CMiniportWaveICHStream ();
    
    /*************************************************************************
     * Include IMiniportWavePciStream (public/exported) methods.
     *************************************************************************
     */
    IMP_IMiniportWavePciStream;

    /*************************************************************************
     * Include IDrmAudioStream (public/exported) methods.
     *************************************************************************
     */
    IMP_IDrmAudioStream;
    
    /*************************************************************************
     * CMiniportWaveICHStream methods
     *************************************************************************
     */
    
    //
    // Initializes the Stream object.
    //
    NTSTATUS Init
    (
        IN  CMiniportWaveICH    *Miniport_,
        IN  PPORTWAVEPCISTREAM  PortStream,
        IN  ULONG               Channel,
        IN  BOOLEAN             Capture,
        IN  PKSDATAFORMAT       DataFormat,
        OUT PSERVICEGROUP *     ServiceGroup
    );

    //
    // This method is called when the device changes power states.
    //
    NTSTATUS PowerChangeNotify
    (
        IN  POWER_STATE NewState
    );

    //
    // Return the current sample rate.
    //
    ULONG GetCurrentSampleRate (void)
    {
        return CurrentRate;
    }

    //
    // Friends
    //
    friend
    NTSTATUS CMiniportWaveICH::InterruptServiceRoutine
    (
        IN  PINTERRUPTSYNC  InterruptSync,
        IN  PVOID           StaticContext
    );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\mintopo.cpp ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

// Every debug output has "Modulname text".
static char STR_MODULENAME[] = "ICH Topology: ";

#include "mintopo.h"

/*****************************************************************************
 * AC97 topology miniport tables
 */

/*****************************************************************************
 * PinDataRangesBridge
 *****************************************************************************
 * Structures indicating range of valid format values for bridge pins.
 */
static KSDATARANGE PinDataRangesAnalogBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

/*****************************************************************************
 * PinDataRangePointersBridge
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for audio bridge pins.
 */
static PKSDATARANGE PinDataRangePointersAnalogBridge[] =
{
    (PKSDATARANGE)&PinDataRangesAnalogBridge[0]
};


/*****************************************************************************
 * PropertiesVolume
 *****************************************************************************
 * Properties for volume controls.
 */
static PCPROPERTY_ITEM PropertiesVolume[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_VOLUMELEVEL,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        CMiniportTopologyICH::PropertyHandler_Level
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET,
        CMiniportTopologyICH::PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationVolume
 *****************************************************************************
 * Automation table for volume controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP (AutomationVolume, PropertiesVolume);

/*****************************************************************************
 * PropertiesMute
 *****************************************************************************
 * Properties for mute controls.
 */
static PCPROPERTY_ITEM PropertiesMute[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_MUTE,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET,
        CMiniportTopologyICH::PropertyHandler_OnOff
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET,
        CMiniportTopologyICH::PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationMute
 *****************************************************************************
 * Automation table for mute controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP (AutomationMute, PropertiesMute);

/*****************************************************************************
 * PropertiesMux
 *****************************************************************************
 * Properties for mux controls.
 */
static PCPROPERTY_ITEM PropertiesMux[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_MUX_SOURCE,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET,
        CMiniportTopologyICH::PropertyHandler_Ulong
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET,
        CMiniportTopologyICH::PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationMux
 *****************************************************************************
 * Automation table for mux controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP (AutomationMux, PropertiesMux);

/*****************************************************************************
 * PropertiesSpecial
 *****************************************************************************
 * Properties for Special controls like fake loudness and fake agc.
 */
static PCPROPERTY_ITEM PropertiesSpecial[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_AGC,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET,
        CMiniportTopologyICH::PropertyHandler_OnOff
    },
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_LOUDNESS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET,
        CMiniportTopologyICH::PropertyHandler_OnOff
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET,
        CMiniportTopologyICH::PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationAgc
 *****************************************************************************
 * Automation table for agc controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP (AutomationSpecial, PropertiesSpecial);

/*****************************************************************************
 * PropertiesTone
 *****************************************************************************
 * Properties for tone controls.
 */
static PCPROPERTY_ITEM PropertiesTone[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_BASS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        CMiniportTopologyICH::PropertyHandler_Tone
    },
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_TREBLE,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        CMiniportTopologyICH::PropertyHandler_Tone
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET,
        CMiniportTopologyICH::PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationTone
 *****************************************************************************
 * Automation table for tone controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP (AutomationTone, PropertiesTone);

/*****************************************************************************
 * Properties3D
 *****************************************************************************
 * Properties for 3D controls.
 */
static PCPROPERTY_ITEM Properties3D[] =
{
    // are faky volume controls.
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_VOLUMELEVEL,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        CMiniportTopologyICH::PropertyHandler_Tone
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET,
        CMiniportTopologyICH::PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * Automation3D
 *****************************************************************************
 * Automation table for 3D controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP (Automation3D, Properties3D);

#ifdef INCLUDE_PRIVATE_PROPERTY
/*****************************************************************************
 * FilterPropertiesPrivate
 *****************************************************************************
 * Properties for AC97 features.
 */
static PCPROPERTY_ITEM FilterPropertiesPrivate[] =
{
    // This is a private property for getting the AC97 codec features.
    { 
        &KSPROPSETID_Private,
        KSPROPERTY_AC97_FEATURES,
        KSPROPERTY_TYPE_GET,
        CMiniportTopologyICH::PropertyHandler_Private
    }
#ifdef PROPERTY_SHOW_SET
    ,
    // This is a private property for getting the AC97 codec features.
    { 
        &KSPROPSETID_Private,
        KSPROPERTY_AC97_SAMPLE_SET,
        KSPROPERTY_TYPE_SET,
        CMiniportTopologyICH::PropertyHandler_Private
    }
#endif
};

/*****************************************************************************
 * FilterAutomationPrivate
 *****************************************************************************
 * Filter's automation table for private property controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP (FilterAutomationPrivate, FilterPropertiesPrivate);
#endif

#pragma code_seg("PAGE")

/*****************************************************************************
 * CreateMiniportTopologyICH
 *****************************************************************************
 * Creates a topology miniport object for the ICH audio adapter.  This uses a
 * macro from STDUNK.H to do all the work.
 */
NTSTATUS CreateMiniportTopologyICH
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE ();

    ASSERT (Unknown);

    STD_CREATE_BODY (CMiniportTopologyICH, Unknown, UnknownOuter, PoolType);
}

/*****************************************************************************
 * CMiniportTopologyICH::NonDelegatingQueryInterface
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 * We basically just check any GUID we know and return this object in case we
 * know it.
 */
STDMETHODIMP_(NTSTATUS) CMiniportTopologyICH::NonDelegatingQueryInterface
(
    IN      REFIID  Interface,
    OUT     PVOID * Object
)
{
    PAGED_CODE ();

    ASSERT (Object);

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::NonDelegatingQueryInterface]"));

    // Is it IID_IUnknown?
    if (IsEqualGUIDAligned (Interface, IID_IUnknown))
    {
        *Object = (PVOID)(PUNKNOWN)this;
    }
    else
    // or IID_IMiniport ...
    if (IsEqualGUIDAligned (Interface, IID_IMiniport))
    {
        *Object = (PVOID)(PMINIPORT)this;
    }
    else
    // or IID_IMiniportTopology ...
    if (IsEqualGUIDAligned (Interface, IID_IMiniportTopology))
    {
        *Object = (PVOID)(PMINIPORTTOPOLOGY)this;
    }
    else
    // or maybe our IID_IMiniportTopologyICH ...
    if (IsEqualGUIDAligned (Interface, IID_IMiniportTopologyICH))
    {
        *Object = (PVOID)(PMINIPORTTOPOLOGYICH)this;
    }
    else
    {
        // nothing found, must be an unknown interface.
        *Object = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    //
    // We reference the interface for the caller.
    //
    ((PUNKNOWN)(*Object))->AddRef ();
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportTopologyICH::~CMiniportTopologyICH
 *****************************************************************************
 * Destructor.
 */
CMiniportTopologyICH::~CMiniportTopologyICH ()
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::~CMiniportTopologyICH]"));

    // release all the stuff that we had referenced or allocated.
    if (AdapterCommon)
    {
        // Notify the AdapterCommon that we go away.
        AdapterCommon->SetMiniportTopology (NULL);
        AdapterCommon->Release ();
        AdapterCommon = NULL;
    }

    if (FilterDescriptor)
    {
        ExFreePool (FilterDescriptor);
        FilterDescriptor = NULL;
    }

    if (ConnectionDescriptors)
    {
        ExFreePool (ConnectionDescriptors);
        ConnectionDescriptors = NULL;
    }

    if (NodeDescriptors)
    {
        ExFreePool (NodeDescriptors);
        NodeDescriptors = NULL;
    }

    if (PinDescriptors)
    {
        ExFreePool (PinDescriptors);
        PinDescriptors = NULL;
    }
}

/*****************************************************************************
 * CMiniportTopologyICH::DataRangeIntersection
 *****************************************************************************
 * Is defined in the IMiniportTopology interface. We just return
 * STATUS_NOT_IMPLEMENTED and portcls will use a default handler for this.
 */
STDMETHODIMP_(NTSTATUS) CMiniportTopologyICH::DataRangeIntersection
(
    IN      ULONG           PinId,
    IN      PKSDATARANGE    DataRange,
    IN      PKSDATARANGE    MatchingDataRange,
    IN      ULONG           OutputBufferLength,
    OUT     PVOID           ResultantFormat     OPTIONAL,
    OUT     PULONG          ResultantFormatLength
)
{
    return STATUS_NOT_IMPLEMENTED;
};

/*****************************************************************************
 * CMiniportTopologyICH::Init
 *****************************************************************************
 * Initializes the miniport.
 * We initialize the translation tables, add reference to the port driver and
 * build the topology.
 */
STDMETHODIMP_(NTSTATUS) CMiniportTopologyICH::Init
(
    IN      PUNKNOWN        UnknownAdapter,
    IN      PRESOURCELIST   ResourceList,
    IN      PPORTTOPOLOGY   Port_
)
{
    PAGED_CODE ();

    ASSERT (UnknownAdapter);
    ASSERT (Port_);

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::Init]"));

    //
    // Set the copy protect flag to FALSE.
    //
    m_bCopyProtectFlag = FALSE;

    // 
    // get the IAdapterCommon interface from the adapter.
    //
    NTSTATUS ntStatus = UnknownAdapter->QueryInterface (IID_IAdapterCommon,
                                                       (PVOID *) &AdapterCommon);

    //
    // initialize translation tables
    //
    for (int i = 0; i < PIN_TOP_ELEMENT; i++)
    {
        stPinTrans[i].PinDef = PIN_INVALID;
        stPinTrans[i].PinNr = -1;
    }

    for (i = 0; i < NODE_TOP_ELEMENT; i++)
    {
        stNodeTrans[i].NodeDef = NODE_INVALID;
        stNodeTrans[i].NodeNr = -1;
    }

    // build the topology (means register pins, nodes, connections).
    if (NT_SUCCESS (ntStatus))
    {
        ntStatus = BuildTopology ();
    }
    
    if (NT_SUCCESS (ntStatus))
    {
        //
        // Notify AdapterCommon that we are ready now.
        //
        AdapterCommon->SetMiniportTopology (this);
    }
    else
    {
        //
        // clean up our mess
        //

        // clean up AdapterCommon
        if (AdapterCommon)
        {
            AdapterCommon->Release ();
            AdapterCommon = NULL;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportTopologyICH::GetDescription
 *****************************************************************************
 * Gets/returns the topology to the system.
 */
STDMETHODIMP_(NTSTATUS) CMiniportTopologyICH::GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE ();

    ASSERT (OutFilterDescriptor);

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::GetDescription]"));

#if (DBG)
    // Dump it here. The system requests the topology only once.
    DumpTopology ();
#endif

    if (FilterDescriptor)
    {
        *OutFilterDescriptor = FilterDescriptor;
        return STATUS_SUCCESS;
    }
    else
        return STATUS_DEVICE_CONFIGURATION_ERROR;
}

#if (DBG)
/*****************************************************************************
 * CMiniportTopologyICH::DumpTopology
 *****************************************************************************
 * Dumps the topology for debugging.
 * See the defines at the beginning of this file?
 */
void CMiniportTopologyICH::DumpTopology (void)
{
    PAGED_CODE ();

    if (FilterDescriptor)
    {
        // dump the pins
        DOUT (DBG_PINS, ("TOPOLOGY MINIPORT PINS"));
        for(ULONG index = 0; index < FilterDescriptor->PinCount; index++)
        {
            DOUT (DBG_PINS, ("  %2d %s", index,
                             TopoPinStrings[TransPinNrToPinDef (index)]));
        }

        // dump the nodes
        DOUT (DBG_NODES, ("TOPOLOGY MINIPORT NODES"));
        for(index = 0; index < FilterDescriptor->NodeCount; index++)
        {
            DOUT (DBG_NODES, ("  %2d %s", index,
                              NodeStrings[TransNodeNrToNodeDef (index)]));
        }

        // dump the connections
        DOUT (DBG_CONNS, ("TOPOLOGY MINIPORT CONNECTIONS"));
        for(index = 0; index < FilterDescriptor->ConnectionCount; index++)
        {
            DOUT (DBG_CONNS, ("  %2d (%d,%d)->(%d,%d)", index,
                FilterDescriptor->Connections[index].FromNode,
                FilterDescriptor->Connections[index].FromNodePin,
                FilterDescriptor->Connections[index].ToNode,
                FilterDescriptor->Connections[index].ToNodePin));
        }
    }
}
#endif


/*****************************************************************************
 * Miniport Topology               V = Volume, M = Mute, L = Loudness, A = AGC
 *====================             T = Treble, B = Bass, 0-9 = PinNr of node
 *
 * PCBEEP ---> V ---> M -----------------------------\
 * PHONE  ---> V ---> M ----------------------------\ \
 *                                                   \ \
 * WaveOut -------> V --> M --------------> 1+-----+  \ \
 * MIC1 or MIC2 --> L --> A --> V --> M --> 2| SUM |   \ \
 * LineIn  -------> V --> M --------------> 3|     |    \ \
 * CD      -------> V --> M --------------> 4|     |0--->SUM--> T --> B --> L --> V --> M (MasterOut)
 * Video   -------> V --> M --------------> 5|     |
 * AUX     -------> V --> M --------------> 6|     |
 * 3D Depth  -----> V --> L --> A --------> 7|     |
 * 3D Center -----> V --> L --> A --------> 8|     |
 * Headphone -----> V --> M --------------> 9|     |
 * Front Speaker -> V --> M -------------->10|     |
 * Surround ------> V --> M -------------->11|     |
 * Center   ------> V --> M -------------->12|     |
 * LFE      ------> V --> M -------------->13+-----+
 *
 * 
 * virt. Pin: Tone mix mono   ---> V --> M ---> 7+-------+
 * virt. Pin: Tone mix stereo ---> V --> M ---> 6|       |
 * Phone                      ---> V --> M ---> 8|   M   |
 * Mic (after AGC)            ---> V --> M ---> 1|       |0-----> (WaveIn)
 * LineIn                     ---> V --> M ---> 5|   U   |
 * CD                         ---> V --> M ---> 2|       |
 * Video                      ---> V --> M ---> 3|   X   |
 * AUX                        ---> V --> M ---> 4+-------+
 *
 *
 * virt. Pin: 3D mix mono ---> V ---> M ---> 1+-----+
 *                                            | MUX |0----> (MonoOut)
 * Mic (after AGC)        ---> V ---> M ---> 2+-----+
 *
 *
 * Mic (after AGC) ----> V ----> M -----> (MicIn)
 *
 *----------------------------------------------------------------------------
 *
 * As you can see, the exposed topology is somewhat different from the real AC97
 * topology. This is because the system that translates the topology to "mixer
 * lines" gets confused if it has to deal with all the mess. So we have to make it
 * plain and simple for the system.
 * Some issues block us from exposing a nice plain and simple topology. The prg.
 * which displayes the "Volume Control Panel" (sndvol32) does _only_ display
 * Volumes, Mutes (only one "in a row"), Treble, Bass, Loudness and AGC under
 * Advanced control panel. We don't have 3D controls, and before we go into a
 * Muxer, there has to be Volume controls in front.
 * So what do we do?
 * 1) We fake 3D controls as Volume controls. The Mutes represent 3D bypass and
 *    3D on/off
 * 2) All inputs (including the 3D controls) go staight into a SUM. Important is
 *    that there are not 2 Volumes, Mutes in a row, e.g. ---> V ---> M ---> V ---> M
 *    In that case, only one Volume/Mute would be displayed.
 * 3) We can't make a connection from the tone controls to the Wave In muxer (even
 *    with Volumes in front), so we create fake pins that we name user friendly.
 *    Same with the connection from the 3D mixer to the Mono output.
 * 4) We discard all supermixer controls that would convert stereo to mono or vice
 *    versa. Instead, we just connect the lines and when the control is queried we
 *    fail a right channel request (mono has only left channel).
 * 5) We have to make virtual volume and mute controls in front of each muxer.
 *    As you can see, these controls can be mono or stereo and there is only one
 *    HW register for them, so we have to cache the values and prg. the register
 *    each time the select changes or the selected volume control changes.
 */

/*****************************************************************************
 * CMiniportTopologyICH::BuildTopology
 *****************************************************************************
 * Builds the topology descriptors based on hardware configuration info
 * obtained from the adapter.
 */
NTSTATUS CMiniportTopologyICH::BuildTopology (void)
{
    PAGED_CODE ();

    NTSTATUS ntStatus = STATUS_SUCCESS;

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::BuildTopology]"));

    // allocate our filter descriptor
    FilterDescriptor = (PPCFILTER_DESCRIPTOR) ExAllocatePool (PagedPool,
                        sizeof(PCFILTER_DESCRIPTOR));
    if (FilterDescriptor)
    {
        // clear out the filter descriptor
        RtlZeroMemory (FilterDescriptor, sizeof(PCFILTER_DESCRIPTOR));

#ifdef INCLUDE_PRIVATE_PROPERTY
        // Set the Filter automation table.
        FilterDescriptor->AutomationTable = &FilterAutomationPrivate;
#endif

        // build the pin list
        ntStatus = BuildPinDescriptors ();
        if (NT_SUCCESS (ntStatus))
        {
            // build the node list
            ntStatus = BuildNodeDescriptors ();
            if (NT_SUCCESS (ntStatus))
            {
                // build the connection list
                ntStatus = BuildConnectionDescriptors ();
            }
        }
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    // that's whatever one of these build... functions returned.
    return ntStatus;
}

/*****************************************************************************
 * CMiniportTopologyICH::BuildPinDescriptors
 *****************************************************************************
 * Builds the topology pin descriptors.
 */
NTSTATUS CMiniportTopologyICH::BuildPinDescriptors (void)
{
// Improvement would be to not use a Macro, use (inline) function instead.
#define INIT_PIN( pin, pinptr, category, name, index )      \
    pinptr->KsPinDescriptor.Category = (GUID*) category;    \
    pinptr->KsPinDescriptor.Name = (GUID*) name;            \
    SetPinTranslation (index++, pin);                       \
    pinptr++   

    PAGED_CODE ();

    ULONG               Index;
    PPCPIN_DESCRIPTOR   CurrentPin;

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::BuildPinDescriptors]"));

    // allocate our descriptor memory
    PinDescriptors = PPCPIN_DESCRIPTOR (ExAllocatePool (PagedPool,
                                PIN_TOP_ELEMENT * sizeof(PCPIN_DESCRIPTOR)));
    if (!PinDescriptors)
        return STATUS_INSUFFICIENT_RESOURCES;

    //
    // set default pin descriptor parameters
    //
    RtlZeroMemory (PinDescriptors, PIN_TOP_ELEMENT * sizeof(PCPIN_DESCRIPTOR));
    
    // spend some more time and set the pin descriptors to expected values.
    for (CurrentPin = PinDescriptors, Index = 0; Index < PIN_TOP_ELEMENT;
         CurrentPin++, Index++)
    {
        CurrentPin->KsPinDescriptor.DataRangesCount = SIZEOF_ARRAY(PinDataRangePointersAnalogBridge);
        CurrentPin->KsPinDescriptor.DataRanges      = PinDataRangePointersAnalogBridge;
        CurrentPin->KsPinDescriptor.DataFlow        = KSPIN_DATAFLOW_IN;
        CurrentPin->KsPinDescriptor.Communication   = KSPIN_COMMUNICATION_NONE;
    }

    //
    // modify the individual pin descriptors
    //
    CurrentPin  = PinDescriptors;
    Index       = 0;

    // add the PIN_WAVEOUT_SOURCE pin descriptor (not optional)
    INIT_PIN (PIN_WAVEOUT_SOURCE,
              CurrentPin,
              &KSCATEGORY_AUDIO,
              NULL,
              Index);

    // add the PIN_PCBEEP_SOURCE pin descriptor (optional)
    if (AdapterCommon->GetPinConfig (PINC_PCBEEP_PRESENT))
    {
        INIT_PIN (PIN_PCBEEP_SOURCE,
                  CurrentPin,
                  &KSNODETYPE_SPEAKER,
                  &KSAUDFNAME_PC_SPEAKER,
                  Index);
    }

    // add the PIN_PHONE_SOURCE pin descriptor (optional)
    if (AdapterCommon->GetPinConfig (PINC_PHONE_PRESENT))
    {
        INIT_PIN (PIN_PHONE_SOURCE,
                  CurrentPin,
                  &KSNODETYPE_PHONE_LINE,
                  NULL,
                  Index);
    }

    // add the PIN_MIC_SOURCE pin descriptor (could be disabled)
    if (AdapterCommon->GetPinConfig (PINC_MIC_PRESENT))
    {
        INIT_PIN (PIN_MIC_SOURCE,
                  CurrentPin,
                  &KSNODETYPE_MICROPHONE,
                  NULL,
                  Index);
    }

    // add the PIN_LINEIN_SOURCE pin descriptor (could be disabled)
    if (AdapterCommon->GetPinConfig (PINC_LINEIN_PRESENT))
    {
        INIT_PIN (PIN_LINEIN_SOURCE,
                  CurrentPin,
                  &KSNODETYPE_LINE_CONNECTOR,
                  &KSAUDFNAME_LINE_IN,
                  Index);
    }

    // add the PIN_CD_SOURCE pin descriptor (could be disabled)
    if (AdapterCommon->GetPinConfig (PINC_CD_PRESENT))
    {
        INIT_PIN (PIN_CD_SOURCE,
                  CurrentPin,
                  &KSNODETYPE_CD_PLAYER,
                  &KSAUDFNAME_CD_AUDIO,
                  Index);
    }

    // add the PIN_VIDEO_SOURCE pin descriptor (optional)
    if (AdapterCommon->GetPinConfig (PINC_VIDEO_PRESENT))
    {
        INIT_PIN (PIN_VIDEO_SOURCE,
                  CurrentPin,
                  &KSNODETYPE_ANALOG_CONNECTOR,
                  &KSAUDFNAME_VIDEO,
                  Index);
    }

    // add the PIN_AUX_SOURCE pin descriptor (optional)
    if (AdapterCommon->GetPinConfig (PINC_AUX_PRESENT))
    {
        INIT_PIN (PIN_AUX_SOURCE,
                  CurrentPin,
                  &KSNODETYPE_ANALOG_CONNECTOR,
                  &KSAUDFNAME_AUX,
                  Index);
    }

    // add the PIN_VIRT_TONE_MIX_SOURCE pin descriptor (not optional)
    INIT_PIN (PIN_VIRT_TONE_MIX_SOURCE,
              CurrentPin,
              &KSNODETYPE_ANALOG_CONNECTOR,
              &KSAUDFNAME_STEREO_MIX,
              Index);

    // add the PIN_VIRT_TONE_MIX_MONO_SOURCE pin descriptor (not optional)
    INIT_PIN (PIN_VIRT_TONE_MIX_MONO_SOURCE,
              CurrentPin,
              &KSNODETYPE_ANALOG_CONNECTOR,
              &KSAUDFNAME_MONO_MIX,
              Index);

    // create a virt. pin for the 3D controls
    if (AdapterCommon->GetNodeConfig (NODEC_3D_PRESENT))
    {
        if (AdapterCommon->GetNodeConfig (NODEC_3D_CENTER_ADJUSTABLE))
        {
            INIT_PIN (PIN_VIRT_3D_CENTER_SOURCE,
                      CurrentPin,
                      &KSNODETYPE_ANALOG_CONNECTOR,
                      &KSAUDFNAME_3D_CENTER,
                      Index);
        }

        // A weird way would be to have 3D but only fixed sliders. In that case,
        // display one fixed slider (3D depth).
        if (AdapterCommon->GetNodeConfig (NODEC_3D_DEPTH_ADJUSTABLE) ||
           (!AdapterCommon->GetNodeConfig (NODEC_3D_CENTER_ADJUSTABLE) &&
            !AdapterCommon->GetNodeConfig (NODEC_3D_DEPTH_ADJUSTABLE)))
        {
            INIT_PIN (PIN_VIRT_3D_DEPTH_SOURCE,
                      CurrentPin,
                      &KSNODETYPE_ANALOG_CONNECTOR,
                      &KSAUDFNAME_3D_DEPTH,
                      Index);
        }
    }

    // Add a "Front speaker" pin if we have multichannel or headphones.
    // We use a master mono then ...
    if (AdapterCommon->GetPinConfig (PINC_SURROUND_PRESENT) ||
        AdapterCommon->GetPinConfig (PINC_HPOUT_PRESENT))
    {
        // Add a "Front speaker" pin, because in multichannel we want
        // to display a master mono that effects all channels.
        INIT_PIN (PIN_VIRT_FRONT_SOURCE,
                  CurrentPin,
                  &KSNODETYPE_ANALOG_CONNECTOR,
                  &ICHFNAME_FRONT,
                  Index);
    }
    
    // check for multichannel
    if (AdapterCommon->GetPinConfig (PINC_SURROUND_PRESENT))
    {
        // Add the Rear Speaker Volume pin.
        INIT_PIN (PIN_VIRT_SURROUND_SOURCE,
                  CurrentPin,
                  &KSNODETYPE_ANALOG_CONNECTOR,
                  &ICHFNAME_SURROUND,
                  Index);

        // add the Center Volume pin if we support at least 6 channel.
        if (AdapterCommon->GetPinConfig (PINC_CENTER_LFE_PRESENT))
        {
            INIT_PIN (PIN_VIRT_CENTER_SOURCE,
                      CurrentPin,
                      &KSNODETYPE_ANALOG_CONNECTOR,
                      &ICHFNAME_CENTER,
                      Index);
    
            INIT_PIN (PIN_VIRT_LFE_SOURCE,
                      CurrentPin,
                      &KSNODETYPE_ANALOG_CONNECTOR,
                      &ICHFNAME_LFE,
                      Index);
        }
    }
    
    // add the PIN_MASTEROUT_DEST pin descriptor (not optional)
    CurrentPin->KsPinDescriptor.DataFlow = KSPIN_DATAFLOW_OUT;
    INIT_PIN (PIN_MASTEROUT_DEST,
              CurrentPin,
              &KSNODETYPE_SPEAKER,
              &KSAUDFNAME_VOLUME_CONTROL,
              Index);

    // add the PIN_HPOUT_SOURCE pin descriptor (optional)
    if (AdapterCommon->GetPinConfig (PINC_HPOUT_PRESENT))
    {
        INIT_PIN (PIN_HPOUT_SOURCE,
                  CurrentPin,
                  &KSNODETYPE_HEADPHONES,
                  NULL,
                  Index);
    }

    // add the PIN_WAVEIN_DEST pin descriptor (not optional)
    CurrentPin->KsPinDescriptor.DataFlow = KSPIN_DATAFLOW_OUT;
    INIT_PIN (PIN_WAVEIN_DEST,
              CurrentPin,
              &KSCATEGORY_AUDIO,
              NULL,
              Index);

    // add the PIN_MICIN_DEST pin descriptor (optional)
    if (AdapterCommon->GetPinConfig (PINC_MICIN_PRESENT) &&
        AdapterCommon->GetPinConfig (PINC_MIC_PRESENT))
    {
        CurrentPin->KsPinDescriptor.DataFlow = KSPIN_DATAFLOW_OUT;
        INIT_PIN (PIN_MICIN_DEST,
                  CurrentPin,
                  &KSCATEGORY_AUDIO,
                  NULL,
                  Index);
    }

    // add the PIN_MONOOUT_DEST pin descriptor (optional)
    if (AdapterCommon->GetPinConfig (PINC_MONOOUT_PRESENT))
    {
        // add the PIN_VIRT_3D_MIX_MONO_SOURCE pin descriptor
        INIT_PIN (PIN_VIRT_3D_MIX_MONO_SOURCE,
                  CurrentPin,
                  &KSNODETYPE_ANALOG_CONNECTOR,
                  &KSAUDFNAME_MONO_MIX,
                  Index);

        CurrentPin->KsPinDescriptor.DataFlow = KSPIN_DATAFLOW_OUT;
        // and the normal output pin
        INIT_PIN (PIN_MONOOUT_DEST,
                  CurrentPin,
                  &KSNODETYPE_PHONE_LINE,
                  &KSAUDFNAME_MONO_OUT,
                  Index);
    }

    // add the pin descriptor informatin to the filter descriptor
    FilterDescriptor->PinCount = Index;
    FilterDescriptor->PinSize = sizeof (PCPIN_DESCRIPTOR);
    FilterDescriptor->Pins = PinDescriptors;


    return STATUS_SUCCESS;

#undef INIT_PIN
}

/*****************************************************************************
 * CMiniportTopologyICH::BuildNodeDescriptors
 *****************************************************************************
 * Builds the topology node descriptors.
 */
NTSTATUS CMiniportTopologyICH::BuildNodeDescriptors (void)
{
// Improvement would be to not use a Macro, use (inline) function instead.
#define INIT_NODE( node, nodeptr, type, name, automation, index )   \
    nodeptr->Type = (GUID*) type;                                   \
    nodeptr->Name = (GUID*) name;                                   \
    nodeptr->AutomationTable = automation;                          \
    SetNodeTranslation (index++, node);                             \
    nodeptr++   

    PAGED_CODE ();

    NTSTATUS ntStatus = STATUS_SUCCESS;
    
    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::BuildNodeDescriptors]"));

    // allocate our descriptor memory
    NodeDescriptors = PPCNODE_DESCRIPTOR (ExAllocatePool (PagedPool,
                                NODE_TOP_ELEMENT * sizeof(PCNODE_DESCRIPTOR)));
    if (NodeDescriptors)
    {
        PPCNODE_DESCRIPTOR  CurrentNode = NodeDescriptors;
        ULONG               Index = 0;

        //
        // set default node descriptor parameters
        //
        RtlZeroMemory (NodeDescriptors, NODE_TOP_ELEMENT *
                       sizeof(PCNODE_DESCRIPTOR));

        // We don't have loopback mode currently. It is only used for testing anyway.

        // Add the NODE_WAVEOUT_VOLUME node
        INIT_NODE (NODE_WAVEOUT_VOLUME,
                   CurrentNode,
                   &KSNODETYPE_VOLUME,
                   &KSAUDFNAME_WAVE_VOLUME,
                   &AutomationVolume,
                   Index);

        // add the NODE_WAVEOUT_MUTE node
        INIT_NODE (NODE_WAVEOUT_MUTE,
                   CurrentNode,
                   &KSNODETYPE_MUTE,
                   &KSAUDFNAME_WAVE_MUTE,
                   &AutomationMute,
                   Index);

        // add the PCBEEP nodes
        if (AdapterCommon->GetPinConfig (PINC_PCBEEP_PRESENT))
        {
            // add the NODE_PCBEEP_VOLUME node
            INIT_NODE (NODE_PCBEEP_VOLUME,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_PC_SPEAKER_VOLUME,
                       &AutomationVolume,
                       Index);

            // add the NODE_PCBEEP_MUTE node
            INIT_NODE (NODE_PCBEEP_MUTE,
                       CurrentNode,
                       &KSNODETYPE_MUTE,
                       &KSAUDFNAME_PC_SPEAKER_MUTE,
                       &AutomationMute,
                       Index);
        }

        // add the PHONE nodes
        if (AdapterCommon->GetPinConfig (PINC_PHONE_PRESENT))
        {
            // add the NODE_PHONE_VOLUME node
            INIT_NODE (NODE_PHONE_VOLUME,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &ICHFNAME_PHONE_VOLUME,
                       &AutomationVolume,
                       Index);

            // add the NODE_PHONE_MUTE node
            INIT_NODE (NODE_PHONE_MUTE,
                       CurrentNode,
                       &KSNODETYPE_MUTE,
                       &ICHFNAME_PHONE_MUTE,
                       &AutomationMute,
                       Index);
        }

        // add the MIC nodes
        if (AdapterCommon->GetPinConfig (PINC_MIC_PRESENT))
        {
            if (AdapterCommon->GetPinConfig (PINC_MIC2_PRESENT))
            {
                // add the NODE_MIC_SELECT node
                INIT_NODE (NODE_MIC_SELECT,
                           CurrentNode,
                           &KSNODETYPE_LOUDNESS,
                           &KSAUDFNAME_ALTERNATE_MICROPHONE,
                           &AutomationSpecial,
                           Index);
            }

            // add the NODE_MIC_BOOST node
            INIT_NODE (NODE_MIC_BOOST,
                       CurrentNode,
                       &KSNODETYPE_AGC,
                       &KSAUDFNAME_MICROPHONE_BOOST,
                       &AutomationSpecial,
                       Index);

            // add the NODE_MIC_VOLUME node
            INIT_NODE (NODE_MIC_VOLUME,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_MIC_VOLUME,
                       &AutomationVolume,
                       Index);

            // add the NODE_MIC_MUTE node
            INIT_NODE (NODE_MIC_MUTE,
                       CurrentNode,
                       &KSNODETYPE_MUTE,
                       &KSAUDFNAME_MIC_MUTE,
                       &AutomationMute,
                       Index);
        }

        if (AdapterCommon->GetPinConfig (PINC_LINEIN_PRESENT))
        {
            // add the NODE_LINEIN_VOLUME node
            INIT_NODE (NODE_LINEIN_VOLUME,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_LINE_IN_VOLUME,
                       &AutomationVolume,
                       Index);

            // add the NODE_LINEIN_MUTE node
            INIT_NODE (NODE_LINEIN_MUTE,
                       CurrentNode,
                       &KSNODETYPE_MUTE,
                       &ICHFNAME_LINEIN_MUTE,
                       &AutomationMute,
                       Index);
        }

        if (AdapterCommon->GetPinConfig (PINC_CD_PRESENT))
        {
            // add the NODE_CD_VOLUME node
            INIT_NODE (NODE_CD_VOLUME,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_CD_VOLUME,
                       &AutomationVolume,
                       Index);

            // add the NODE_CD_MUTE node
            INIT_NODE (NODE_CD_MUTE,
                       CurrentNode,
                       &KSNODETYPE_MUTE,
                       &KSAUDFNAME_CD_MUTE,
                       &AutomationMute,
                       Index);
        }

        // add the VIDEO nodes
        if (AdapterCommon->GetPinConfig (PINC_VIDEO_PRESENT))
        {
            // add the NODE_VIDEO_VOLUME node
            INIT_NODE (NODE_VIDEO_VOLUME,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_VIDEO_VOLUME,
                       &AutomationVolume,
                       Index);

            // add the NODE_VIDEO_MUTE node
            INIT_NODE (NODE_VIDEO_MUTE,
                       CurrentNode,
                       &KSNODETYPE_MUTE,
                       &KSAUDFNAME_VIDEO_MUTE,
                       &AutomationMute,
                       Index);
        }

        // add the AUX nodes
        if (AdapterCommon->GetPinConfig (PINC_AUX_PRESENT))
        {
            // add the NODE_AUX_VOLUME node
            INIT_NODE (NODE_AUX_VOLUME,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_AUX_VOLUME,
                       &AutomationVolume,
                       Index);

            // add the NODE_AUX_MUTE node
            INIT_NODE (NODE_AUX_MUTE,
                       CurrentNode,
                       &KSNODETYPE_MUTE,
                       &KSAUDFNAME_AUX_MUTE,
                       &AutomationMute,
                       Index);
        }

        // add the NODE_MAIN_MIX node
        INIT_NODE (NODE_MAIN_MIX,
                   CurrentNode,
                   &KSNODETYPE_SUM,
                   &ICHFNAME_MAIN_MIX,
                   NULL,
                   Index);

        // add the 3D nodes
        if (AdapterCommon->GetNodeConfig (NODEC_3D_PRESENT))
        {
            if (AdapterCommon->GetNodeConfig (NODEC_3D_CENTER_ADJUSTABLE))
            {
                // add the NODE_VIRT_3D_CENTER node
                INIT_NODE (NODE_VIRT_3D_CENTER,
                           CurrentNode,
                           &KSNODETYPE_VOLUME,
                           &KSAUDFNAME_3D_CENTER,
                           &Automation3D,
                           Index);
            }

            if (AdapterCommon->GetNodeConfig (NODEC_3D_DEPTH_ADJUSTABLE) ||
               (!AdapterCommon->GetNodeConfig (NODEC_3D_DEPTH_ADJUSTABLE) &&
                !AdapterCommon->GetNodeConfig (NODEC_3D_CENTER_ADJUSTABLE)))
            {
                // add the NODE_VIRT_3D_DEPTH node
                INIT_NODE (NODE_VIRT_3D_DEPTH,
                           CurrentNode,
                           &KSNODETYPE_VOLUME,
                           &KSAUDFNAME_3D_DEPTH,
                           &Automation3D,
                           Index);
            }
            
            // add the NODE_VIRT_3D_ENABLE node
            INIT_NODE (NODE_VIRT_3D_ENABLE,
                       CurrentNode,
                       &KSNODETYPE_LOUDNESS,
                       &ICHFNAME_3D_ENABLE,
                       &AutomationSpecial,
                       Index);

            // add the NODE_VIRT_WAVEOUT_3D_BYPASS node
            INIT_NODE (NODE_VIRT_WAVEOUT_3D_BYPASS,
                       CurrentNode,
                       &KSNODETYPE_AGC,
                       &ICHFNAME_WAVEOUT_3D_BYPASS,
                       &AutomationSpecial,
                       Index);
        }

        if (AdapterCommon->GetPinConfig (PINC_PCBEEP_PRESENT) ||
            AdapterCommon->GetPinConfig (PINC_PHONE_PRESENT))
        {
            // add the NODE_BEEP_MIX node
            INIT_NODE (NODE_BEEP_MIX,
                       CurrentNode,
                       &KSNODETYPE_SUM,
                       &ICHFNAME_BEEP_MIX,
                       NULL,
                       Index);
        }

        // add the tone nodes
        if (AdapterCommon->GetNodeConfig (NODEC_TONE_PRESENT))
        {
            // add the NODE_BASS node
            INIT_NODE (NODE_BASS,
                       CurrentNode,
                       &KSNODETYPE_TONE,
                       &KSAUDFNAME_BASS,
                       &AutomationTone,
                       Index);

            // add the NODE_TREBLE node
            INIT_NODE (NODE_TREBLE,
                       CurrentNode,
                       &KSNODETYPE_TONE,
                       &KSAUDFNAME_TREBLE,
                       &AutomationTone,
                       Index);

            if (AdapterCommon->GetNodeConfig (NODEC_LOUDNESS_PRESENT))
            {
                // add the NODE_LOUDNESS node
                INIT_NODE (NODE_LOUDNESS,
                           CurrentNode,
                           &KSNODETYPE_LOUDNESS,
                           NULL,
                           &AutomationSpecial,
                           Index);
            }
            
            if (AdapterCommon->GetNodeConfig (NODEC_SIMUL_STEREO_PRESENT))
            {
                // add the NODE_SIMUL_STEREO node
                INIT_NODE (NODE_SIMUL_STEREO,
                           CurrentNode,
                           &KSNODETYPE_AGC,
                           &ICHFNAME_SIMUL_STEREO,
                           &AutomationSpecial,
                           Index);
            }
        }

        // Add a "Front Speaker" volume/mute if we have surround or headphones.
        // The "Master" volume/mute will be mono then
        if (AdapterCommon->GetPinConfig (PINC_SURROUND_PRESENT) ||
            AdapterCommon->GetPinConfig (PINC_HPOUT_PRESENT))
        {
            // Add the front speaker volume.
            INIT_NODE (NODE_FRONT_VOLUME,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &ICHFNAME_FRONT_VOLUME,
                       &AutomationVolume,
                       Index);
            
            // Add the front speaker mute.
            INIT_NODE (NODE_FRONT_MUTE,
                       CurrentNode,
                       &KSNODETYPE_MUTE,
                       &ICHFNAME_FRONT_MUTE,
                       &AutomationMute,
                       Index);
        
            // Add the master mono out volume.
            INIT_NODE (NODE_VIRT_MASTERMONO_VOLUME,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_MASTER_VOLUME,
                       &AutomationVolume,
                       Index);
            
            // Add the master mono out volume.
            INIT_NODE (NODE_VIRT_MASTERMONO_MUTE,
                       CurrentNode,
                       &KSNODETYPE_MUTE,
                       &KSAUDFNAME_MASTER_MUTE,
                       &AutomationMute,
                       Index);
        }
        else
        {
            // add the NODE_MASTEROUT_VOLUME node
            INIT_NODE (NODE_MASTEROUT_VOLUME,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_MASTER_VOLUME,
                       &AutomationVolume,
                       Index);

            // add the NODE_MASTEROUT_MUTE node
            INIT_NODE (NODE_MASTEROUT_MUTE,
                       CurrentNode,
                       &KSNODETYPE_MUTE,
                       &KSAUDFNAME_MASTER_MUTE,
                       &AutomationMute,
                       Index);
        }

        // Add the surround control if we have one.
        if (AdapterCommon->GetPinConfig (PINC_SURROUND_PRESENT))
        {
            // Add the surround volume.
            INIT_NODE (NODE_SURROUND_VOLUME,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &ICHFNAME_SURROUND_VOLUME,
                       &AutomationVolume,
                       Index);
            
            // Add the surround mute.
            INIT_NODE (NODE_SURROUND_MUTE,
                       CurrentNode,
                       &KSNODETYPE_MUTE,
                       &ICHFNAME_SURROUND_MUTE,
                       &AutomationMute,
                       Index);

            // Add the center and LFE control if we have one.
            if (AdapterCommon->GetPinConfig (PINC_CENTER_LFE_PRESENT))
            {
                // Add the center volume.
                INIT_NODE (NODE_CENTER_VOLUME,
                           CurrentNode,
                           &KSNODETYPE_VOLUME,
                           &ICHFNAME_CENTER_VOLUME,
                           &AutomationVolume,
                           Index);
                
                // Add the center mute.
                INIT_NODE (NODE_CENTER_MUTE,
                           CurrentNode,
                           &KSNODETYPE_MUTE,
                           &ICHFNAME_CENTER_MUTE,
                           &AutomationMute,
                           Index);
            
                // Add the LFE volume.
                INIT_NODE (NODE_LFE_VOLUME,
                           CurrentNode,
                           &KSNODETYPE_VOLUME,
                           &ICHFNAME_LFE_VOLUME,
                           &AutomationVolume,
                           Index);
                
                // Add the LFE mute.
                INIT_NODE (NODE_LFE_MUTE,
                           CurrentNode,
                           &KSNODETYPE_MUTE,
                           &ICHFNAME_LFE_MUTE,
                           &AutomationMute,
                           Index);
            }
        }

        // add the HPOUT nodes
        if (AdapterCommon->GetPinConfig (PINC_HPOUT_PRESENT))
        {
            // add the NODE_HPOUT_VOLUME node
            INIT_NODE (NODE_HPOUT_VOLUME,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &ICHFNAME_HPOUT_VOLUME,
                       &AutomationVolume,
                       Index);
    
            // add the NODE_HPOUT_MUTE node
            INIT_NODE (NODE_HPOUT_MUTE,
                       CurrentNode,
                       &KSNODETYPE_MUTE,
                       &ICHFNAME_HPOUT_MUTE,
                       &AutomationMute,
                       Index);
        }

        // add the NODE_WAVEIN_SELECT node
        INIT_NODE (NODE_WAVEIN_SELECT,
                   CurrentNode,
                   &KSNODETYPE_MUX,
                   &ICHFNAME_WAVEIN_SELECT,
                   &AutomationMux,
                   Index);

        if (AdapterCommon->GetPinConfig (PINC_MIC_PRESENT))
        {
            // add the NODE_VIRT_MASTER_INPUT_VOLUME1 node
            INIT_NODE (NODE_VIRT_MASTER_INPUT_VOLUME1,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_MIC_VOLUME,
                       &AutomationVolume,
                       Index);
        }

        if (AdapterCommon->GetPinConfig (PINC_CD_PRESENT))
        {
            // add the NODE_VIRT_MASTER_INPUT_VOLUME2 node
            INIT_NODE (NODE_VIRT_MASTER_INPUT_VOLUME2,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_CD_VOLUME,
                       &AutomationVolume,
                       Index);
        }

        if (AdapterCommon->GetPinConfig (PINC_VIDEO_PRESENT))
        {
            // add the NODE_VIRT_MASTER_INPUT_VOLUME3 node
            INIT_NODE (NODE_VIRT_MASTER_INPUT_VOLUME3,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_VIDEO_VOLUME,
                       &AutomationVolume,
                       Index);
        }

        if (AdapterCommon->GetPinConfig (PINC_AUX_PRESENT))
        {
            // add the NODE_VIRT_MASTER_INPUT_VOLUME4 node
            INIT_NODE (NODE_VIRT_MASTER_INPUT_VOLUME4,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_AUX_VOLUME,
                       &AutomationVolume,
                       Index);
        }

        if (AdapterCommon->GetPinConfig (PINC_LINEIN_PRESENT))
        {
            // add the NODE_VIRT_MASTER_INPUT_VOLUME5 node
            INIT_NODE (NODE_VIRT_MASTER_INPUT_VOLUME5,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_LINE_IN_VOLUME,
                       &AutomationVolume,
                       Index);
        }

        // add the NODE_VIRT_MASTER_INPUT_VOLUME6 node
        INIT_NODE (NODE_VIRT_MASTER_INPUT_VOLUME6,
                   CurrentNode,
                   &KSNODETYPE_VOLUME,
                   &KSAUDFNAME_STEREO_MIX_VOLUME,
                   &AutomationVolume,
                   Index);

        // add the NODE_VIRT_MASTER_INPUT_VOLUME7 node
        INIT_NODE (NODE_VIRT_MASTER_INPUT_VOLUME7,
                   CurrentNode,
                   &KSNODETYPE_VOLUME,
                   &KSAUDFNAME_MONO_MIX_VOLUME,
                   &AutomationVolume,
                   Index);

        if (AdapterCommon->GetPinConfig (PINC_PHONE_PRESENT))
        {
            // add the NODE_VIRT_MASTER_INPUT_VOLUME8 node
            INIT_NODE (NODE_VIRT_MASTER_INPUT_VOLUME8,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &ICHFNAME_MASTER_INPUT_VOLUME,
                       &AutomationVolume,
                       Index);
        }

        // add the MICIN nodes
        if (AdapterCommon->GetPinConfig (PINC_MIC_PRESENT) &&
            AdapterCommon->GetPinConfig (PINC_MICIN_PRESENT))
        {
            // add the NODE_MICIN_VOLUME node
            INIT_NODE (NODE_MICIN_VOLUME,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &ICHFNAME_MICIN_VOLUME,
                       &AutomationVolume,
                       Index);
    
            // add the NODE_MICIN_MUTE node
            INIT_NODE (NODE_MICIN_MUTE,
                       CurrentNode,
                       &KSNODETYPE_MUTE,
                       &ICHFNAME_MICIN_MUTE,
                       &AutomationMute,
                       Index);
        }

        // add the MONOOUT nodes
        if (AdapterCommon->GetPinConfig (PINC_MONOOUT_PRESENT))
        {
            // add the NODE_MONOOUT_SELECT node
            INIT_NODE (NODE_MONOOUT_SELECT,
                       CurrentNode,
                       &KSNODETYPE_MUX,
                       &ICHFNAME_MONOOUT_SELECT,
                       &AutomationMux,
                       Index);

            // add the NODE_VIRT_MONOOUT_VOLUME1 node
            INIT_NODE (NODE_VIRT_MONOOUT_VOLUME1,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_MONO_MIX_VOLUME,
                       &AutomationVolume,
                       Index);
    
            // add the NODE_VIRT_MONOOUT_VOLUME2 node
            INIT_NODE (NODE_VIRT_MONOOUT_VOLUME2,
                       CurrentNode,
                       &KSNODETYPE_VOLUME,
                       &KSAUDFNAME_MIC_VOLUME,
                       &AutomationVolume,
                       Index);
        }

        // add the nodes to the filter descriptor
        FilterDescriptor->NodeCount = Index;
        FilterDescriptor->NodeSize = sizeof(PCNODE_DESCRIPTOR);
        FilterDescriptor->Nodes = NodeDescriptors;
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;

#undef INIT_NODE
}

/*****************************************************************************
 * CMiniportTopologyICH::BuildConnectionDescriptors
 *****************************************************************************
 * Builds the topology connection descriptors.
 */
NTSTATUS CMiniportTopologyICH::BuildConnectionDescriptors (void)
{
// Improvement would be to not use a Macro, use (inline) function instead.

// for node to node connections
#define INIT_NN_CONN( cptr, fnode, fpin, tnode, tpin )  \
    cptr->FromNode = TransNodeDefToNodeNr (fnode);      \
    cptr->FromNodePin = fpin;                           \
    cptr->ToNode = TransNodeDefToNodeNr (tnode);        \
    cptr->ToNodePin = tpin;                             \
    cptr++,ConnectionCount++

// for filter pin to node connections
#define INIT_FN_CONN( cptr, fpin, tnode, tpin )         \
    cptr->FromNode = KSFILTER_NODE;                     \
    cptr->FromNodePin = TransPinDefToPinNr (fpin);      \
    cptr->ToNode = TransNodeDefToNodeNr (tnode);        \
    cptr->ToNodePin = tpin;                             \
    cptr++,ConnectionCount++

// for node to filter pin connections
#define INIT_NF_CONN( cptr, fnode, fpin, tpin )         \
    cptr->FromNode = TransNodeDefToNodeNr (fnode);      \
    cptr->FromNodePin = fpin;                           \
    cptr->ToNode = KSFILTER_NODE;                       \
    cptr->ToNodePin = TransPinDefToPinNr (tpin);        \
    cptr++,ConnectionCount++

    PAGED_CODE ();

    NTSTATUS    ntStatus            = STATUS_SUCCESS;
    ULONG       ConnectionCount     = 0;

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::BuildConnectionDescriptors]"));
    
    // allocate our descriptor memory
    ConnectionDescriptors = PPCCONNECTION_DESCRIPTOR (ExAllocatePool (PagedPool,
                            TOPO_MAX_CONNECTIONS * sizeof(PCCONNECTION_DESCRIPTOR)));
    if (ConnectionDescriptors)
    {
        PPCCONNECTION_DESCRIPTOR  CurrentConnection = ConnectionDescriptors;

        // build the wave out (coming in) path

        // PIN_WAVEOUT_SOURCE -> NODE_WAVEOUT_VOLUME
        INIT_FN_CONN (CurrentConnection, PIN_WAVEOUT_SOURCE, NODE_WAVEOUT_VOLUME, 1);

        // NODE_WAVEOUT_VOLUME -> NODE_WAVEOUT_MUTE
        INIT_NN_CONN (CurrentConnection, NODE_WAVEOUT_VOLUME, 0, NODE_WAVEOUT_MUTE, 1);

        // NODE_WAVEOUT_MUTE -> NODE_MAIN_MIX
        INIT_NN_CONN (CurrentConnection, NODE_WAVEOUT_MUTE, 0, NODE_MAIN_MIX, 1);

        // build the PC beeper path
        if (AdapterCommon->GetPinConfig (PINC_PCBEEP_PRESENT))
        {
            // PIN_PCBEEP_SOURCE -> NODE_PCBEEP_VOLUME
            INIT_FN_CONN (CurrentConnection, PIN_PCBEEP_SOURCE, NODE_PCBEEP_VOLUME, 1);
            
            // NODE_PCBEEP_VOLUME -> NODE_PCBEEP_MUTE
            INIT_NN_CONN (CurrentConnection, NODE_PCBEEP_VOLUME, 0, NODE_PCBEEP_MUTE, 1);

            // NODE_PCBEEP_MUTE -> NODE_BEEP_MIX
            INIT_NN_CONN (CurrentConnection, NODE_PCBEEP_MUTE, 0, NODE_BEEP_MIX, 2);
        }

        // build the phone path
        if (AdapterCommon->GetPinConfig (PINC_PHONE_PRESENT))
        {
            // PIN_PHONE_SOURCE -> NODE_PHONE_VOLUME
            INIT_FN_CONN (CurrentConnection, PIN_PHONE_SOURCE, NODE_PHONE_VOLUME, 1);
            
            // NODE_PHONE_VOLUME -> NODE_PHONE_MUTE
            INIT_NN_CONN (CurrentConnection, NODE_PHONE_VOLUME, 0, NODE_PHONE_MUTE, 1);

            // NODE_PHONE_MUTE -> LINEOUT_BEEP_MIX
            INIT_NN_CONN (CurrentConnection, NODE_PHONE_MUTE, 0, NODE_BEEP_MIX, 3);
            
            // PIN_PHONE_SOURCE pin -> NODE_VIRT_MASTER_INPUT_VOLUME8
            INIT_FN_CONN (CurrentConnection, PIN_PHONE_SOURCE, NODE_VIRT_MASTER_INPUT_VOLUME8, 1);

            // NODE_VIRT_MASTER_INPUT_VOLUME8 -> NODE_WAVEIN_SELECT
            INIT_NN_CONN (CurrentConnection, NODE_VIRT_MASTER_INPUT_VOLUME8, 0, NODE_WAVEIN_SELECT, 8);
        }

        // build MIC path
        if (AdapterCommon->GetPinConfig (PINC_MIC_PRESENT))
        {
            // build the MIC selector in case we have 2 MICs
            if (AdapterCommon->GetPinConfig (PINC_MIC2_PRESENT))
            {
                // PIN_MIC_SOURCE pin -> NODE_MIC_SELECT
                INIT_FN_CONN (CurrentConnection, PIN_MIC_SOURCE, NODE_MIC_SELECT, 1);

                // NODE_MIC_SELECT -> NODE_MIC_BOOST
                INIT_NN_CONN (CurrentConnection, NODE_MIC_SELECT, 0, NODE_MIC_BOOST, 1);
            }
            else
            {
                // PIN_MIC_SOURCE pin -> NODE_MIC_SELECT
                INIT_FN_CONN (CurrentConnection, PIN_MIC_SOURCE, NODE_MIC_BOOST, 1);
            }

            // NODE_MIC_BOOST -> NODE_MIC_VOLUME
            INIT_NN_CONN (CurrentConnection, NODE_MIC_BOOST, 0, NODE_MIC_VOLUME, 1);

            // NODE_MIC_VOLUME -> NODE_MIC_MUTE
            INIT_NN_CONN (CurrentConnection, NODE_MIC_VOLUME, 0, NODE_MIC_MUTE, 1);

            // NODE_MIC_MUTE -> NODE_MAIN_MIX
            INIT_NN_CONN (CurrentConnection, NODE_MIC_MUTE, 0, NODE_MAIN_MIX, 2);

            // NODE_MIC_BOOST -> NODE_VIRT_MASTER_INPUT_VOLUME1
            INIT_NN_CONN (CurrentConnection, NODE_MIC_BOOST, 0, NODE_VIRT_MASTER_INPUT_VOLUME1, 1);

            // NODE_VIRT_MASTER_INPUT_VOLUME1 -> NODE_WAVEIN_SELECT
            INIT_NN_CONN (CurrentConnection, NODE_VIRT_MASTER_INPUT_VOLUME1, 0, NODE_WAVEIN_SELECT, 1);
        }

        // build the line in path
        if (AdapterCommon->GetPinConfig (PINC_LINEIN_PRESENT))
        {
            // PIN_LINEIN_SOURCE -> NODE_LINEIN_VOLUME
            INIT_FN_CONN (CurrentConnection, PIN_LINEIN_SOURCE, NODE_LINEIN_VOLUME, 1);

            // NODE_LINEIN_VOLUME -> NODE_LINEIN_MUTE
            INIT_NN_CONN (CurrentConnection, NODE_LINEIN_VOLUME, 0, NODE_LINEIN_MUTE, 1);

            // NODE_LINEIN_MUTE -> NODE_MAIN_MIX
            INIT_NN_CONN (CurrentConnection, NODE_LINEIN_MUTE, 0, NODE_MAIN_MIX, 3);

            // PIN_LINEIN_SOURCE pin -> NODE_VIRT_MASTER_INPUT_VOLUME5
            INIT_FN_CONN (CurrentConnection, PIN_LINEIN_SOURCE, NODE_VIRT_MASTER_INPUT_VOLUME5, 1);

            // NODE_VIRT_MASTER_INPUT_VOLUME5 -> NODE_WAVEIN_SELECT
            INIT_NN_CONN (CurrentConnection, NODE_VIRT_MASTER_INPUT_VOLUME5, 0, NODE_WAVEIN_SELECT, 5);
        }

        // build the CD path
        if (AdapterCommon->GetPinConfig (PINC_CD_PRESENT))
        {
            // PIN_CD_SOURCE -> NODE_CD_VOLUME
            INIT_FN_CONN (CurrentConnection, PIN_CD_SOURCE, NODE_CD_VOLUME, 1);

            // NODE_CD_VOLUME -> NODE_CD_MUTE
            INIT_NN_CONN (CurrentConnection, NODE_CD_VOLUME, 0, NODE_CD_MUTE, 1);

            // NODE_CD_MUTE -> NODE_MAIN_MIX
            INIT_NN_CONN (CurrentConnection, NODE_CD_MUTE, 0, NODE_MAIN_MIX, 4);

            // PIN_CD_SOURCE pin -> NODE_VIRT_MASTER_INPUT_VOLUME2
            INIT_FN_CONN (CurrentConnection, PIN_CD_SOURCE, NODE_VIRT_MASTER_INPUT_VOLUME2, 1);

            // NODE_VIRT_MASTER_INPUT_VOLUME2 -> NODE_WAVEIN_SELECT
            INIT_NN_CONN (CurrentConnection, NODE_VIRT_MASTER_INPUT_VOLUME2, 0, NODE_WAVEIN_SELECT, 2);
        }

        // build the video path
        if (AdapterCommon->GetPinConfig (PINC_VIDEO_PRESENT))
        {
            // PIN_VIDEO_SOURCE -> NODE_VIDEO_VOLUME
            INIT_FN_CONN (CurrentConnection, PIN_VIDEO_SOURCE, NODE_VIDEO_VOLUME, 1);
    
            // NODE_VIDEO_VOLUME -> NODE_VIDEO_MUTE
            INIT_NN_CONN (CurrentConnection, NODE_VIDEO_VOLUME, 0, NODE_VIDEO_MUTE, 1);
    
            // NODE_VIDEO_MUTE -> NODE_MAIN_MIX
            INIT_NN_CONN (CurrentConnection, NODE_VIDEO_MUTE, 0, NODE_MAIN_MIX, 5);
            
            // PIN_VIDEO_SOURCE pin -> NODE_VIRT_MASTER_INPUT_VOLUME3
            INIT_FN_CONN (CurrentConnection, PIN_VIDEO_SOURCE, NODE_VIRT_MASTER_INPUT_VOLUME3, 1);

            // NODE_VIRT_MASTER_INPUT_VOLUME3 -> NODE_WAVEIN_SELECT
            INIT_NN_CONN (CurrentConnection, NODE_VIRT_MASTER_INPUT_VOLUME3, 0, NODE_WAVEIN_SELECT, 3);
        }

        // build the AUX path
        if (AdapterCommon->GetPinConfig (PINC_AUX_PRESENT))
        {
            // PIN_AUX_SOURCE pin -> NODE_AUX_VOLUME
            INIT_FN_CONN (CurrentConnection, PIN_AUX_SOURCE, NODE_AUX_VOLUME, 1);
    
            // NODE_AUX_VOLUME -> NODE_AUX_MUTE
            INIT_NN_CONN (CurrentConnection, NODE_AUX_VOLUME, 0, NODE_AUX_MUTE, 1);
    
            // NODE_AUX_MUTE -> NODE_MAIN_MIX
            INIT_NN_CONN (CurrentConnection, NODE_AUX_MUTE, 0, NODE_MAIN_MIX, 6);
            
            // PIN_AUX_SOURCE pin -> NODE_VIRT_MASTER_INPUT_VOLUME4
            INIT_FN_CONN (CurrentConnection, PIN_AUX_SOURCE, NODE_VIRT_MASTER_INPUT_VOLUME4, 1);

            // NODE_VIRT_MASTER_INPUT_VOLUME4 -> NODE_WAVEIN_SELECT
            INIT_NN_CONN (CurrentConnection, NODE_VIRT_MASTER_INPUT_VOLUME4, 0, NODE_WAVEIN_SELECT, 4);
        }
        
        // and build the head phone output.
        // we connect the headphones like an input so that it's in the playback panel.
        if (AdapterCommon->GetPinConfig (PINC_HPOUT_PRESENT))
        {
            // from whatever -> NODE_HPOUT_VOLUME
            INIT_FN_CONN (CurrentConnection, PIN_HPOUT_SOURCE, NODE_HPOUT_VOLUME, 1);

            // NODE_HPOUT_VOLUME -> NODE_HPOUT_MUTE
            INIT_NN_CONN (CurrentConnection, NODE_HPOUT_VOLUME, 0, NODE_HPOUT_MUTE, 1);

            // NODE_HPOUT_MUTE -> PIN_HPOUT_DEST pin
            INIT_NN_CONN( CurrentConnection, NODE_HPOUT_MUTE, 0, NODE_MAIN_MIX, 9);
        }

        // build the 3D path
        if (AdapterCommon->GetNodeConfig (NODEC_3D_PRESENT))
        {
            // Figure out what the main 3D line is.
            if (AdapterCommon->GetNodeConfig (NODEC_3D_CENTER_ADJUSTABLE))
            {
                if (AdapterCommon->GetNodeConfig (NODEC_3D_DEPTH_ADJUSTABLE))
                {
                    // PIN_VIRT_3D_DEPTH_SOURCE -> NODE_VIRT_3D_ENABLE
                    INIT_FN_CONN (CurrentConnection, PIN_VIRT_3D_DEPTH_SOURCE, NODE_VIRT_3D_ENABLE, 1);

                    // NODE_VIRT_3D_ENABLE -> NODE_VIRT_WAVEOUT_3D_BYPASS
                    INIT_NN_CONN (CurrentConnection, NODE_VIRT_3D_ENABLE, 0, NODE_VIRT_WAVEOUT_3D_BYPASS, 1);
                    
                    // NODE_VIRT_WAVEOUT_3D_BYPASS -> NODE_VIRT_3D_DEPTH
                    INIT_NN_CONN (CurrentConnection, NODE_VIRT_WAVEOUT_3D_BYPASS, 0, NODE_VIRT_3D_DEPTH, 1);
                                  
                    // NODE_VIRT_3D_DEPTH -> NODE_MAIN_MIX              
                    INIT_NN_CONN (CurrentConnection, NODE_VIRT_3D_DEPTH, 0, NODE_MAIN_MIX, 7);

                    // PIN_VIRT_3D_CENTER_SOURCE -> NODE_VIRT_3D_CENTER
                    INIT_FN_CONN (CurrentConnection, PIN_VIRT_3D_CENTER_SOURCE, NODE_VIRT_3D_CENTER, 1);
                    
                    // NODE_VIRT_3D_CENTER -> NODE_MAIN_MIX              
                    INIT_NN_CONN (CurrentConnection, NODE_VIRT_3D_CENTER, 0, NODE_MAIN_MIX, 8);
                }
                else
                {
                    // PIN_VIRT_3D_CENTER_SOURCE -> NODE_VIRT_3D_ENABLE
                    INIT_FN_CONN (CurrentConnection, PIN_VIRT_3D_CENTER_SOURCE, NODE_VIRT_3D_ENABLE, 1);

                    // NODE_VIRT_3D_ENABLE -> NODE_VIRT_WAVEOUT_3D_BYPASS
                    INIT_NN_CONN (CurrentConnection, NODE_VIRT_3D_ENABLE, 0, NODE_VIRT_WAVEOUT_3D_BYPASS, 1);
                    
                    // NODE_VIRT_WAVEOUT_3D_BYPASS -> NODE_VIRT_3D_CENTER
                    INIT_NN_CONN (CurrentConnection, NODE_VIRT_WAVEOUT_3D_BYPASS, 0, NODE_VIRT_3D_CENTER, 1);
                                  
                    // NODE_VIRT_3D_CENTER -> NODE_MAIN_MIX              
                    INIT_NN_CONN (CurrentConnection, NODE_VIRT_3D_CENTER, 0, NODE_MAIN_MIX, 8);
                }
            }
            else
            {
                // PIN_VIRT_3D_DEPTH_SOURCE -> NODE_VIRT_3D_ENABLE
                INIT_FN_CONN (CurrentConnection, PIN_VIRT_3D_DEPTH_SOURCE, NODE_VIRT_3D_ENABLE, 1);

                // NODE_VIRT_3D_ENABLE -> NODE_VIRT_WAVEOUT_3D_BYPASS
                INIT_NN_CONN (CurrentConnection, NODE_VIRT_3D_ENABLE, 0, NODE_VIRT_WAVEOUT_3D_BYPASS, 1);

                // NODE_VIRT_WAVEOUT_3D_BYPASS -> NODE_VIRT_3D_DEPTH
                INIT_NN_CONN (CurrentConnection, NODE_VIRT_WAVEOUT_3D_BYPASS, 0, NODE_VIRT_3D_DEPTH, 1);

                // NODE_VIRT_3D_DEPTH -> NODE_MAIN_MIX              
                INIT_NN_CONN (CurrentConnection, NODE_VIRT_3D_DEPTH, 0, NODE_MAIN_MIX, 7);
            }
        }

        // build the 4 or 6 channel controls

        // In case of multichannel or headphone we have "front speakers" volume/mute.
        if (AdapterCommon->GetPinConfig (PINC_SURROUND_PRESENT) ||
            AdapterCommon->GetPinConfig (PINC_HPOUT_PRESENT))
        {
            // PIN_VIRT_FRONT_SOURCE -> NODE_FRONT_VOLUME
            INIT_FN_CONN (CurrentConnection, PIN_VIRT_FRONT_SOURCE, NODE_FRONT_VOLUME, 1);

            // NODE_FRONT_VOLUME -> NODE_FRONT_MUTE
            INIT_NN_CONN (CurrentConnection, NODE_FRONT_VOLUME, 0, NODE_FRONT_MUTE, 1);

            // NODE_FRONT_MUTE -> NODE_MAIN_MIX
            INIT_NN_CONN (CurrentConnection, NODE_FRONT_MUTE, 0, NODE_MAIN_MIX, 10);
        }

        // Check for surround volumes
        if (AdapterCommon->GetPinConfig (PINC_SURROUND_PRESENT))
        {
            // PIN_VIRT_SURROUND -> NODE_SURROUND_VOLUME
            INIT_FN_CONN (CurrentConnection, PIN_VIRT_SURROUND_SOURCE, NODE_SURROUND_VOLUME, 1);

            // NODE_SURROUND_VOLUME -> NODE_SURROUND_MUTE
            INIT_NN_CONN (CurrentConnection, NODE_SURROUND_VOLUME, 0, NODE_SURROUND_MUTE, 1);

            // NODE_SURROUND_MUTE -> NODE_MAIN_MIX
            INIT_NN_CONN (CurrentConnection, NODE_SURROUND_MUTE, 0, NODE_MAIN_MIX, 11);

            // check also for the center and LFE volumes
            if (AdapterCommon->GetPinConfig (PINC_CENTER_LFE_PRESENT))
            {
                // PIN_VIRT_CENTER -> NODE_CENTER_VOLUME
                INIT_FN_CONN (CurrentConnection, PIN_VIRT_CENTER_SOURCE, NODE_CENTER_VOLUME, 1);
    
                // NODE_CENTER_VOLUME -> NODE_CENTER_MUTE
                INIT_NN_CONN (CurrentConnection, NODE_CENTER_VOLUME, 0, NODE_CENTER_MUTE, 1);
    
                // NODE_CENTER_MUTE -> NODE_MAIN_MIX
                INIT_NN_CONN (CurrentConnection, NODE_CENTER_MUTE, 0, NODE_MAIN_MIX, 12);
            
                // PIN_VIRT_LFE -> NODE_LFE_VOLUME
                INIT_FN_CONN (CurrentConnection, PIN_VIRT_LFE_SOURCE, NODE_LFE_VOLUME, 1);
    
                // NODE_LFE_VOLUME -> NODE_LFE_MUTE
                INIT_NN_CONN (CurrentConnection, NODE_LFE_VOLUME, 0, NODE_LFE_MUTE, 1);
    
                // NODE_LFE_MUTE -> NODE_MAIN_MIX
                INIT_NN_CONN (CurrentConnection, NODE_LFE_MUTE, 0, NODE_MAIN_MIX, 13);
            }
        }

        // helper node variable.
        TopoNodes     ConnectFromNode;

        // all connections go from this one
        ConnectFromNode = NODE_MAIN_MIX;

        // build the beeper & phone mix
        if (AdapterCommon->GetPinConfig (PINC_PCBEEP_PRESENT) ||
            AdapterCommon->GetPinConfig (PINC_PHONE_PRESENT))
        {
            // last node -> NODE_BEEP_MIX
            INIT_NN_CONN (CurrentConnection, ConnectFromNode, 0, NODE_BEEP_MIX, 1);

            // next connection from this point.
            ConnectFromNode = NODE_BEEP_MIX;
        }

        // build the tone control path
        if (AdapterCommon->GetNodeConfig (NODEC_TONE_PRESENT))
        {
            // last node -> NODE_BASS
            INIT_NN_CONN (CurrentConnection, ConnectFromNode, 0, NODE_BASS, 1);

            // NODE_BASS -> NODE_TREBLE
            INIT_NN_CONN (CurrentConnection, NODE_BASS, 0, NODE_TREBLE, 1);

            // remember the last node
            ConnectFromNode = NODE_TREBLE;

            // build the loudness control
            if (AdapterCommon->GetNodeConfig (NODEC_LOUDNESS_PRESENT))
            {
                // last node -> NODE_LOUDNESS
                INIT_NN_CONN (CurrentConnection, ConnectFromNode, 0, NODE_LOUDNESS, 1);

                // remember the last node
                ConnectFromNode = NODE_LOUDNESS;
            }
            
            // build the simulated stereo control
            if (AdapterCommon->GetNodeConfig (NODEC_SIMUL_STEREO_PRESENT))
            {
                // last node -> NODE_SIMUL_STEREO
                INIT_NN_CONN (CurrentConnection, ConnectFromNode, 0, NODE_SIMUL_STEREO, 1);

                // remember the last node
                ConnectFromNode = NODE_SIMUL_STEREO;
            }
        }

        //build the master volume output.

        // In case of multichannel or headphone we use a master mono control.
        if (AdapterCommon->GetPinConfig (PINC_SURROUND_PRESENT) ||
            AdapterCommon->GetPinConfig (PINC_HPOUT_PRESENT))
        {
            // build the connection from whatever to NODE_VIRT_MASTERMONO_VOLUME
            INIT_NN_CONN (CurrentConnection, ConnectFromNode, 0, NODE_VIRT_MASTERMONO_VOLUME, 1);

            // NODE_VIRT_MASTERMONO_VOLUME -> NODE_VIRT_MASTERMONO_MUTE
            INIT_NN_CONN (CurrentConnection, NODE_VIRT_MASTERMONO_VOLUME, 0, NODE_VIRT_MASTERMONO_MUTE, 1);

            // NODE_VIRT_MASTERMONO_MUTE -> PIN_MASTEROUT_DEST pin
            INIT_NF_CONN( CurrentConnection, NODE_VIRT_MASTERMONO_MUTE, 0, PIN_MASTEROUT_DEST);
        }
        else
        {
            // build the connection from whatever to NODE_MASTEROUT_VOLUME
            INIT_NN_CONN (CurrentConnection, ConnectFromNode, 0, NODE_MASTEROUT_VOLUME, 1);

            // NODE_MASTEROUT_VOLUME -> NODE_MASTEROUT_MUTE
            INIT_NN_CONN (CurrentConnection, NODE_MASTEROUT_VOLUME, 0, NODE_MASTEROUT_MUTE, 1);

            // NODE_MASTEROUT_MUTE -> PIN_MASTEROUT_DEST pin
            INIT_NF_CONN( CurrentConnection, NODE_MASTEROUT_MUTE, 0, PIN_MASTEROUT_DEST);
        }

        // now complete the input muxer path

        // PIN_VIRT_TONE_MIX_MONO_SOURCE -> NODE_VIRT_MASTER_INPUT_VOLUME7
        INIT_FN_CONN (CurrentConnection, PIN_VIRT_TONE_MIX_MONO_SOURCE, NODE_VIRT_MASTER_INPUT_VOLUME7, 1);

        // NODE_VIRT_MASTER_INPUT_VOLUME7 -> NODE_WAVEIN_SELECT
        INIT_NN_CONN (CurrentConnection, NODE_VIRT_MASTER_INPUT_VOLUME7, 0, NODE_WAVEIN_SELECT, 7);

        // PIN_VIRT_TONE_MIX_SOURCE -> NODE_VIRT_MASTER_INPUT_VOLUME6
        INIT_FN_CONN (CurrentConnection, PIN_VIRT_TONE_MIX_SOURCE, NODE_VIRT_MASTER_INPUT_VOLUME6, 1);

        // NODE_VIRT_MASTER_INPUT_VOLUME6 -> NODE_WAVEIN_SELECT
        INIT_NN_CONN (CurrentConnection, NODE_VIRT_MASTER_INPUT_VOLUME6, 0, NODE_WAVEIN_SELECT, 6);

        // NODE_WAVEIN_SELECT -> PIN_WAVEIN_DEST
        INIT_NF_CONN( CurrentConnection, NODE_WAVEIN_SELECT, 0, PIN_WAVEIN_DEST);

        // build the mic output path (for record control)
        if (AdapterCommon->GetPinConfig (PINC_MIC_PRESENT) &&
            AdapterCommon->GetPinConfig (PINC_MICIN_PRESENT))
        {
            // NODE_MIC_BOOST -> NODE_MICIN_VOLUME
            INIT_NN_CONN (CurrentConnection, NODE_MIC_BOOST, 0, NODE_MICIN_VOLUME, 1);

            // NODE_MICIN_VOLUME -> NODE_MICIN_MUTE
            INIT_NN_CONN (CurrentConnection, NODE_MICIN_VOLUME, 0, NODE_MICIN_MUTE, 1);

            // NODE_MICIN_MUTE -> PIN_MICIN_DEST
            INIT_NF_CONN( CurrentConnection, NODE_MICIN_MUTE, 0, PIN_MICIN_DEST);
        }

        // build the mono path
        if (AdapterCommon->GetPinConfig (PINC_MONOOUT_PRESENT))
        {
            // PIN_VIRT_3D_MIX_MONO_SOURCE -> NODE_MONOOUT_SMIX
            INIT_FN_CONN (CurrentConnection, PIN_VIRT_3D_MIX_MONO_SOURCE, NODE_VIRT_MONOOUT_VOLUME1, 1);

            // NODE_VIRT_MONOOUT_VOLUME1 -> NODE_MONOOUT_SELECT
            INIT_NN_CONN (CurrentConnection, NODE_VIRT_MONOOUT_VOLUME1, 0, NODE_MONOOUT_SELECT, 1);

            if (AdapterCommon->GetPinConfig (PINC_MIC_PRESENT))
            {
                // NODE_MIC_BOOST -> NODE_VIRT_MONOOUT_VOLUME2
                INIT_NN_CONN (CurrentConnection, NODE_MIC_BOOST, 0, NODE_VIRT_MONOOUT_VOLUME2, 1);

                // NODE_VIRT_MONOOUT_VOLUME2 -> NODE_MONOOUT_SELECT
                INIT_NN_CONN (CurrentConnection, NODE_VIRT_MONOOUT_VOLUME2, 0, NODE_MONOOUT_SELECT, 2);
            }

            // NODE_MONOOUT_SELECT -> PIN_MONOOUT_DEST
            INIT_NF_CONN( CurrentConnection, NODE_MONOOUT_SELECT, 0, PIN_MONOOUT_DEST);
        }

        // add the connections to the filter descriptor
        FilterDescriptor->ConnectionCount = ConnectionCount;
        FilterDescriptor->Connections = ConnectionDescriptors;
    } else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;

#undef INIT_NN_CONN
#undef INIT_FN_CONN
#undef INIT_NF_CONN
}


/*****************************************************************************
 * CMiniportTopologyICH::UpdateRecordMute
 *****************************************************************************
 * Updates the record mute control. This is used to have DRM functionality.
 * In the case that we play a DRM file that is copy protected, we have to
 * mute the record if stereo or mono mix is selected. We also have to update
 * the record mute every time the DRM content changes or the playback stream
 * goes away. The property handler also calls this function to update the
 * record mute in case stereo or mono mix is selected.
 */
void CMiniportTopologyICH::UpdateRecordMute (void)
{
    PAGED_CODE ();

    WORD        wRegister;
    TopoNodes   Node;

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::UpdateRecordMute]"));
    
    // Get the record muxer setting.
    if (!NT_SUCCESS (AdapterCommon->ReadCodecRegister (
                     AdapterCommon->GetNodeReg (NODE_WAVEIN_SELECT), &wRegister)))
        return;

    // Mask out every unused bit.
    wRegister &= (AdapterCommon->GetNodeMask (NODE_WAVEIN_SELECT) & AC97REG_MASK_RIGHT);

    // Calculate how we would program the mute.
    switch (wRegister)
    {
        // This is stereo mix.
        case 5:
            Node = NODE_VIRT_MASTER_INPUT_VOLUME6;
            break;
        
        // This is mono mix.
        case 6:
            Node = NODE_VIRT_MASTER_INPUT_VOLUME7;
            break;
        
        // Something else selected than stereo mix or mono mix.
        default:
            return;
    }
    
    // Program the mute.
    AdapterCommon->WriteCodecRegister (AC97REG_RECORD_GAIN,
                                      (m_bCopyProtectFlag ? AC97REG_MASK_MUTE : 0), AC97REG_MASK_MUTE);
}

    
/*****************************************************************************
 * CMiniportTopologyICH::GetPhysicalConnectionPins
 *****************************************************************************
 * Returns the system pin IDs of the bridge pins that are connected with the
 * wave miniport.
 * If one pin is not used, the value is -1, that could only happen for MinInDest.
 */
STDMETHODIMP CMiniportTopologyICH::GetPhysicalConnectionPins
(
    OUT PULONG  WaveOutSource,
    OUT PULONG  WaveInDest,
    OUT PULONG  MicInDest
)
{
    PAGED_CODE ();

    ASSERT (WaveOutSource);
    ASSERT (WaveInDest);
    ASSERT (MicInDest);

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::GetPhysicalConnectionPins]"));

    // set the pin IDs.
    *WaveOutSource = TransPinDefToPinNr (PIN_WAVEOUT_SOURCE);
    *WaveInDest = TransPinDefToPinNr (PIN_WAVEIN_DEST);
    // this is optional
    if (AdapterCommon->GetPinConfig (PINC_MICIN_PRESENT))
        *MicInDest = TransPinDefToPinNr (PIN_MICIN_DEST);
    else
        *MicInDest = -1;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\minwave.cpp ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

// Every debug output has "Modulname text"
static char STR_MODULENAME[] = "ICH Wave: ";

#include "minwave.h"
#include "ichwave.h"

/*****************************************************************************
 * PinDataRangesPCMStream
 *****************************************************************************
 * The next 3 arrays contain information about the data ranges of the pin for
 * wave capture, wave render and mic capture.
 * These arrays are filled dynamically by BuildDataRangeInformation().
 */

static KSDATARANGE_AUDIO PinDataRangesPCMStreamRender[WAVE_SAMPLERATES_TESTED];
static KSDATARANGE_AUDIO PinDataRangesPCMStreamCapture[WAVE_SAMPLERATES_TESTED];
static KSDATARANGE_AUDIO PinDataRangesMicStream[MIC_SAMPLERATES_TESTED];

static KSDATARANGE PinDataRangesAnalogBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

/*****************************************************************************
 * PinDataRangesPointersPCMStream
 *****************************************************************************
 * The next 3 arrays contain the pointers to the data range information of
 * the pin for wave capture, wave render and mic capture.
 * These arrays are filled dynamically by BuildDataRangeInformation().
 */
static PKSDATARANGE PinDataRangePointersPCMStreamRender[WAVE_SAMPLERATES_TESTED];
static PKSDATARANGE PinDataRangePointersPCMStreamCapture[WAVE_SAMPLERATES_TESTED];
static PKSDATARANGE PinDataRangePointersMicStream[MIC_SAMPLERATES_TESTED];

/*****************************************************************************
 * PinDataRangePointerAnalogStream
 *****************************************************************************
 * This structure pointers to the data range structures for the wave pins.
 */
static PKSDATARANGE PinDataRangePointersAnalogBridge[] =
{
    (PKSDATARANGE) PinDataRangesAnalogBridge
};


/*****************************************************************************
 * Wave Miniport Topology
 *========================
 *
 *                              +-----------+    
 *                              |           |    
 *    Capture (PIN_WAVEIN)  <---|2 --ADC-- 3|<=== (PIN_WAVEIN_BRIDGE)
 *                              |           |    
 *     Render (PIN_WAVEOUT) --->|0 --DAC-- 1|===> (PIN_WAVEOUT_BRIDGE)
 *                              |           |    
 *        Mic (PIN_MICIN)   <---|4 --ADC-- 5|<=== (PIN_MICIN_BRIDGE)
 *                              +-----------+    
 *
 * Note that the exposed pins (left side) have to be a multiple of 2
 * since there are some dependencies in the stream object.
 */

/*****************************************************************************
 * MiniportPins
 *****************************************************************************
 * This structure describes pin (stream) types provided by this miniport.
 * The field that sets the number of data range entries (SIZEOF_ARRAY) is
 * overwritten by BuildDataRangeInformation().
 */
static PCPIN_DESCRIPTOR MiniportPins[] =
{
    // PIN_WAVEOUT
    {
        1,1,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersPCMStreamRender),  // DataRangesCount
            PinDataRangePointersPCMStreamRender,                // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved            
        }
    },

    // PIN_WAVEOUT_BRIDGE
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersAnalogBridge),    // DataRangesCount
            PinDataRangePointersAnalogBridge,                  // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved            
        }
    },

    // PIN_WAVEIN
    {
        1,1,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersPCMStreamCapture), // DataRangesCount
            PinDataRangePointersPCMStreamCapture,               // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            (GUID *) &PINNAME_CAPTURE,                  // Category
            &KSAUDFNAME_RECORDING_CONTROL,              // Name
            0                                           // Reserved
        }
    },

    // PIN_WAVEIN_BRIDGE
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersAnalogBridge),    // DataRangesCount
            PinDataRangePointersAnalogBridge,                  // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },

    //
    // The Microphone pins are not used if PINC_MICIN_PRESENT is not set.
    // To remove them, Init() will reduce the "PinCount" in the
    // MiniportFilterDescriptor.
    //
    // PIN_MICIN
    {
        1,1,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersMicStream),// DataRangesCount
            PinDataRangePointersMicStream,              // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },

    // PIN_MICIN_BRIDGE
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersAnalogBridge),    // DataRangesCount
            PinDataRangePointersAnalogBridge,                  // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
};

/*****************************************************************************
 * PropertiesDAC
 *****************************************************************************
 * Properties for the DAC node.
 */
static PCPROPERTY_ITEM PropertiesDAC[] =
{
    { 
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CHANNEL_CONFIG,
        KSPROPERTY_TYPE_SET,
        CMiniportWaveICH::PropertyChannelConfig
    }
};

/*****************************************************************************
 * AutomationVolume
 *****************************************************************************
 * Automation table for volume controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP (AutomationDAC, PropertiesDAC);

/*****************************************************************************
 * TopologyNodes
 *****************************************************************************
 * List of nodes.
 */
static PCNODE_DESCRIPTOR MiniportNodes[] =
{
    // NODE_WAVEOUT_DAC
    {
        0,                      // Flags
        &AutomationDAC,         // AutomationTable
        &KSNODETYPE_DAC,        // Type
        NULL                    // Name
    },
    // NODE_WAVEIN_ADC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_ADC,        // Type
        NULL                    // Name
    },
    //
    // The Microphone node is not used if PINC_MICIN_PRESENT is not set.
    // To remove them, Init() will reduce the "NodeCount" in the
    // MiniportFilterDescriptor.
    //
    //  NODE_MICIN_ADC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_ADC,        // Type
        NULL                    // Name
    }
};

/*****************************************************************************
 * MiniportConnections
 *****************************************************************************
 * This structure identifies the connections between filter pins and
 * node pins.
 */
static PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    //from_node             from_pin            to_node             to_pin
    { PCFILTER_NODE,        PIN_WAVEOUT,        NODE_WAVEOUT_DAC,   1},
    { NODE_WAVEOUT_DAC,     0,                  PCFILTER_NODE,      PIN_WAVEOUT_BRIDGE},
    { PCFILTER_NODE,        PIN_WAVEIN_BRIDGE,  NODE_WAVEIN_ADC,    1},
    { NODE_WAVEIN_ADC,      0,                  PCFILTER_NODE,      PIN_WAVEIN},
    //
    // The Microphone connection is not used if PINC_MICIN_PRESENT is not set.
    // To remove them, Init() will reduce the "ConnectionCount" in the
    // MiniportFilterDescriptor.
    //
    { PCFILTER_NODE,        PIN_MICIN_BRIDGE,   NODE_MICIN_ADC,     1},
    { NODE_MICIN_ADC,       0,                  PCFILTER_NODE,      PIN_MICIN}
};

/*****************************************************************************
 * MiniportFilterDescriptor
 *****************************************************************************
 * Complete miniport description.
 * Init() modifies the pin count, node count and connection count in absence
 * of the MicIn recording line.
 */
static PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories: NULL->use defaults (audio, render, capture)
};

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportWaveICH::PropertyChannelConfig
 *****************************************************************************
 * This is the property handler for KSPROPERTY_AUDIO_CHANNEL_CONFIG of the
 * DAC node. It sets the channel configuration (how many channels, how user
 * was setting up the speakers).
 */
NTSTATUS CMiniportWaveICH::PropertyChannelConfig
(
    IN      PPCPROPERTY_REQUEST PropertyRequest
)
{
    PAGED_CODE ();

    ASSERT (PropertyRequest);

    DOUT (DBG_PRINT, ("[CMiniportWaveICH::PropertyChannelConfig]"));

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    // The major target is the object pointer to the wave miniport.
    CMiniportWaveICH *that =
        (CMiniportWaveICH *) (PMINIPORTWAVEPCI)PropertyRequest->MajorTarget;

    ASSERT (that);

    // We only have a set defined.
    if (PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
    {
        // validate buffer size.
        if (PropertyRequest->ValueSize < sizeof(LONG))
            return ntStatus;

        // The "Value" is the input buffer with the channel config.
        if (PropertyRequest->Value)
        {
            // We can accept different channel configurations, depending
            // on the number of channels we can play.
            if (that->AdapterCommon->GetPinConfig (PINC_SURROUND_PRESENT))
            {
                if (that->AdapterCommon->GetPinConfig (PINC_CENTER_LFE_PRESENT))
                {
                    // we accept 5.1
                    if (*(PLONG)PropertyRequest->Value == KSAUDIO_SPEAKER_5POINT1)
                    {
                        that->m_dwChannelMask =  *(PLONG)PropertyRequest->Value;
                        that->m_wChannels = 6;
                        that->AdapterCommon->WriteChannelConfigDefault (that->m_dwChannelMask);
                        ntStatus = STATUS_SUCCESS;
                    }
                }
                
                // accept also surround or quad.
                if ((*(PLONG)PropertyRequest->Value == KSAUDIO_SPEAKER_QUAD) ||
                    (*(PLONG)PropertyRequest->Value == KSAUDIO_SPEAKER_SURROUND))
                {
                    that->m_dwChannelMask =  *(PLONG)PropertyRequest->Value;
                    that->m_wChannels = 4;
                    that->AdapterCommon->WriteChannelConfigDefault (that->m_dwChannelMask);
                    ntStatus = STATUS_SUCCESS;
                }
            }
            
            // accept also stereo speakers.
            if (*(PLONG)PropertyRequest->Value == KSAUDIO_SPEAKER_STEREO)
            {
                that->m_dwChannelMask =  *(PLONG)PropertyRequest->Value;
                that->m_wChannels = 2;
                that->AdapterCommon->WriteChannelConfigDefault (that->m_dwChannelMask);
                ntStatus = STATUS_SUCCESS;
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CreateMiniportWaveICH
 *****************************************************************************
 * Creates a ICH wave miniport object for the ICH adapter.
 * This uses a macro from STDUNK.H to do all the work.
 */
NTSTATUS CreateMiniportWaveICH
(
    OUT PUNKNOWN   *Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN    UnknownOuter    OPTIONAL,
    IN  POOL_TYPE   PoolType
)
{
    PAGED_CODE ();

    ASSERT (Unknown);

    DOUT (DBG_PRINT, ("[CreateMiniportWaveICH]"));

    STD_CREATE_BODY_(CMiniportWaveICH,Unknown,UnknownOuter,PoolType,
                     PMINIPORTWAVEPCI);
}


/*****************************************************************************
 * CMiniportWaveICH::NonDelegatingQueryInterface
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP_(NTSTATUS) CMiniportWaveICH::NonDelegatingQueryInterface
(
    IN  REFIID  Interface,
    OUT PVOID  *Object
)
{
    PAGED_CODE ();

    ASSERT (Object);

    DOUT (DBG_PRINT, ("[CMiniportWaveICH::NonDelegatingQueryInterface]"));

    // Is it IID_IUnknown?
    if (IsEqualGUIDAligned (Interface, IID_IUnknown))
    {
        *Object = (PVOID)(PUNKNOWN)(PMINIPORTWAVEPCI)this;
    } 
    // or IID_IMiniport ...
    else if (IsEqualGUIDAligned (Interface, IID_IMiniport))
    {
        *Object = (PVOID)(PMINIPORT)this;
    } 
    // or IID_IMiniportWavePci ...
    else if (IsEqualGUIDAligned (Interface, IID_IMiniportWavePci))
    {
        *Object = (PVOID)(PMINIPORTWAVEPCI)this;
    } 
    // or IID_IPowerNotify ...
    else if (IsEqualGUIDAligned (Interface, IID_IPowerNotify))
    {
        *Object = (PVOID)(PPOWERNOTIFY)this;
    } 
    else
    {
        // nothing found, must be an unknown interface.
        *Object = NULL;
        return STATUS_INVALID_PARAMETER;
    }

    //
    // We reference the interface for the caller.
    //
    ((PUNKNOWN)(*Object))->AddRef();
    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICH::~CMiniportWaveICH
 *****************************************************************************
 * Destructor.
 */
CMiniportWaveICH::~CMiniportWaveICH ()
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[CMiniportWaveICH::~CMiniportWaveICH]"));

    //
    // Release the DMA channel.
    //
    if (DmaChannel)
    {
        DmaChannel->Release ();
        DmaChannel = NULL;
    }

    //
    // Release the interrupt sync.
    //
    if (InterruptSync)
    {
        InterruptSync->Release ();
        InterruptSync = NULL;
    }

    //
    // Release adapter common object.
    //
    if (AdapterCommon)
    {
        AdapterCommon->Release ();
        AdapterCommon = NULL;
    }

    //
    // Release the port.
    //
    if (Port)
    {
        Port->Release ();
        Port = NULL;
    }
}


/*****************************************************************************
 * CMiniportWaveICH::Init
 *****************************************************************************
 * Initializes the miniport.
 * Initializes variables and modifies the wave topology if needed.
 */
STDMETHODIMP_(NTSTATUS) CMiniportWaveICH::Init
(
    IN  PUNKNOWN       UnknownAdapter,
    IN  PRESOURCELIST  ResourceList,
    IN  PPORTWAVEPCI   Port_,
    OUT PSERVICEGROUP *ServiceGroup_
)
{
    PAGED_CODE ();

    ASSERT (UnknownAdapter);
    ASSERT (ResourceList);
    ASSERT (Port_);

    DOUT (DBG_PRINT, ("[CMiniportWaveICH::Init]"));

    //
    // AddRef() is required because we are keeping this pointer.
    //
    Port = Port_;
    Port->AddRef ();

    //
    // No miniport service group
    //
    *ServiceGroup_ = NULL;

    //
    // Set initial device power state
    //
    m_PowerState = PowerDeviceD0;

    NTSTATUS ntStatus = UnknownAdapter->
        QueryInterface (IID_IAdapterCommon, (PVOID *)&AdapterCommon);
    if (NT_SUCCESS (ntStatus))
    {
        //
        // Alter the topology for the wave miniport.
        //
        if (!(AdapterCommon->GetPinConfig (PINC_MICIN_PRESENT) &&
              AdapterCommon->GetPinConfig (PINC_MIC_PRESENT)))
        {
            //
            // Remove the pins, nodes and connections for the MICIN.
            //
            MiniportFilterDescriptor.PinCount = SIZEOF_ARRAY(MiniportPins) - 2;
            MiniportFilterDescriptor.NodeCount = SIZEOF_ARRAY(MiniportNodes) - 1;
            MiniportFilterDescriptor.ConnectionCount = SIZEOF_ARRAY(MiniportConnections) - 2;
        }

        //
        // Process the resources.
        //
        ntStatus = ProcessResources (ResourceList);

        //
        // Get the default channel config
        //
        AdapterCommon->ReadChannelConfigDefault (&m_dwChannelMask, &m_wChannels);

        //
        // If we came till that point, check the CoDec for supported standard
        // sample rates. This function will then fill the data range information
        //
        if (NT_SUCCESS (ntStatus))
            ntStatus = BuildDataRangeInformation ();
    }

    //
    // If we fail we get destroyed anyway (that's where we clean up).
    //
    return ntStatus;
}


/*****************************************************************************
 * CMiniportWaveICH::ProcessResources
 *****************************************************************************
 * Processes the resource list, setting up helper objects accordingly.
 * Sets up the Interrupt + Service routine and DMA.
 */
NTSTATUS CMiniportWaveICH::ProcessResources
(
    IN  PRESOURCELIST ResourceList
)
{
    PAGED_CODE ();

    ASSERT (ResourceList);


    DOUT (DBG_PRINT, ("[CMiniportWaveICH::ProcessResources]"));


    ULONG countIRQ = ResourceList->NumberOfInterrupts ();
    if (countIRQ < 1)
    {
        DOUT (DBG_ERROR, ("Unknown configuration for wave miniport!"));
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }
    
    //
    // Create an interrupt sync object
    //
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ntStatus = PcNewInterruptSync (&InterruptSync,
                                   NULL,
                                   ResourceList,
                                   0,
                                   InterruptSyncModeNormal);

    if (!NT_SUCCESS (ntStatus) || !InterruptSync)
    {
        DOUT (DBG_ERROR, ("Failed to create an interrupt sync!"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Register our ISR.
    //
    ntStatus = InterruptSync->RegisterServiceRoutine (InterruptServiceRoutine,
                                                      (PVOID)this, FALSE);
    if (!NT_SUCCESS (ntStatus))
    {
        DOUT (DBG_ERROR, ("Failed to register ISR!"));
        return ntStatus;
    }

    //
    // Connect the interrupt.
    //
    ntStatus = InterruptSync->Connect ();
    if (!NT_SUCCESS (ntStatus))
    {
        DOUT (DBG_ERROR, ("Failed to connect the ISR with InterruptSync!"));
        return ntStatus;
    }

    //
    // Create the DMA Channel object.
    //
    ntStatus = Port->NewMasterDmaChannel (&DmaChannel,      // OutDmaChannel
                                          NULL,             // OuterUnknown (opt)
                                          NonPagedPool,     // Pool Type
                                          NULL,             // ResourceList (opt)
                                          TRUE,             // ScatterGather
                                          TRUE,             // Dma32BitAddresses
                                          FALSE,            // Dma64BitAddresses
                                          FALSE,            // IgnoreCount
                                          Width32Bits,      // DmaWidth
                                          MaximumDmaSpeed,  // DmaSpeed
                                          0x1FFFE,          // MaximumLength (128KByte -2)
                                          0);               // DmaPort
    if (!NT_SUCCESS (ntStatus))
    {
        DOUT (DBG_ERROR, ("Failed on NewMasterDmaChannel!"));
        return ntStatus;
    }

    //
    // Get the DMA adapter.
    //
    AdapterObject = DmaChannel->GetAdapterObject ();

    //
    // On failure object is destroyed which cleans up.
    //
    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CAdapterCommon::BuildDataRangeInformation
 *****************************************************************************
 * This function dynamically build the data range information for the pins.
 * It also connects the static arrays with the data range information
 * structure.
 * If this function returns with an error the miniport should be destroyed.
 *
 * To build the data range information, we test the most popular sample rates,
 * the functions calls ProgramSampleRate in AdapterCommon object to actually
 * program the sample rate. After probing that way for multiple sample rates,
 * the original value, which is 48KHz is, gets restored.
 * We have to test the sample rates for playback, capture and microphone
 * separately. Every time we succeed, we update the data range information and
 * the pointers that point to it.
 */
NTSTATUS CMiniportWaveICH::BuildDataRangeInformation (void)
{
    PAGED_CODE ();

    NTSTATUS    ntStatus;
    int nWavePlaybackEntries = 0;
    int nWaveRecordingEntries = 0;
    int nMicEntries = 0;
    int nChannels;
    int nLoop;

    DOUT (DBG_PRINT, ("[CMiniportWaveICH::BuildDataRangeInformation]"));

    //
    // Calculate the number of max. channels available in the codec.
    //
    if (AdapterCommon->GetPinConfig (PINC_SURROUND_PRESENT))
    {
        if (AdapterCommon->GetPinConfig (PINC_CENTER_LFE_PRESENT))
        {
            nChannels = 6;
        }
        else
        {
            nChannels = 4;
        }
    }
    else
    {
        nChannels = 2;
    }

    // Check for the render sample rates.
    for (nLoop = 0; nLoop < WAVE_SAMPLERATES_TESTED; nLoop++)
    {
        ntStatus = AdapterCommon->ProgramSampleRate (AC97REG_FRONT_SAMPLERATE,
                                                     dwWaveSampleRates[nLoop]);

        // We support the sample rate?
        if (NT_SUCCESS (ntStatus))
        {
            // Add it to the PinDataRange
            PinDataRangesPCMStreamRender[nWavePlaybackEntries].DataRange.FormatSize = sizeof(KSDATARANGE_AUDIO);
            PinDataRangesPCMStreamRender[nWavePlaybackEntries].DataRange.Flags      = 0;
            PinDataRangesPCMStreamRender[nWavePlaybackEntries].DataRange.SampleSize = nChannels * 2;
            PinDataRangesPCMStreamRender[nWavePlaybackEntries].DataRange.Reserved   = 0;
            PinDataRangesPCMStreamRender[nWavePlaybackEntries].DataRange.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
            PinDataRangesPCMStreamRender[nWavePlaybackEntries].DataRange.SubFormat   = KSDATAFORMAT_SUBTYPE_PCM;
            PinDataRangesPCMStreamRender[nWavePlaybackEntries].DataRange.Specifier   = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;
            PinDataRangesPCMStreamRender[nWavePlaybackEntries].MaximumChannels = nChannels;
            PinDataRangesPCMStreamRender[nWavePlaybackEntries].MinimumBitsPerSample = 16;
            PinDataRangesPCMStreamRender[nWavePlaybackEntries].MaximumBitsPerSample = 16;
            PinDataRangesPCMStreamRender[nWavePlaybackEntries].MinimumSampleFrequency = dwWaveSampleRates[nLoop];
            PinDataRangesPCMStreamRender[nWavePlaybackEntries].MaximumSampleFrequency = dwWaveSampleRates[nLoop];

            // Add it to the PinDataRangePointer
            PinDataRangePointersPCMStreamRender[nWavePlaybackEntries] = (PKSDATARANGE)&PinDataRangesPCMStreamRender[nWavePlaybackEntries];

            // Increase count
            nWavePlaybackEntries++;
        }
    }

    // Check for the capture sample rates.
    for (nLoop = 0; nLoop < WAVE_SAMPLERATES_TESTED; nLoop++)
    {
        ntStatus = AdapterCommon->ProgramSampleRate (AC97REG_RECORD_SAMPLERATE, dwWaveSampleRates[nLoop]);

        // We support the sample rate?
        if (NT_SUCCESS (ntStatus))
        {
            // Add it to the PinDataRange
            PinDataRangesPCMStreamCapture[nWaveRecordingEntries].DataRange.FormatSize = sizeof(KSDATARANGE_AUDIO);
            PinDataRangesPCMStreamCapture[nWaveRecordingEntries].DataRange.Flags      = 0;
            PinDataRangesPCMStreamCapture[nWaveRecordingEntries].DataRange.SampleSize = 4;
            PinDataRangesPCMStreamCapture[nWaveRecordingEntries].DataRange.Reserved   = 0;
            PinDataRangesPCMStreamCapture[nWaveRecordingEntries].DataRange.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
            PinDataRangesPCMStreamCapture[nWaveRecordingEntries].DataRange.SubFormat   = KSDATAFORMAT_SUBTYPE_PCM;
            PinDataRangesPCMStreamCapture[nWaveRecordingEntries].DataRange.Specifier   = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;
            PinDataRangesPCMStreamCapture[nWaveRecordingEntries].MaximumChannels = 2;
            PinDataRangesPCMStreamCapture[nWaveRecordingEntries].MinimumBitsPerSample = 16;
            PinDataRangesPCMStreamCapture[nWaveRecordingEntries].MaximumBitsPerSample = 16;
            PinDataRangesPCMStreamCapture[nWaveRecordingEntries].MinimumSampleFrequency = dwWaveSampleRates[nLoop];
            PinDataRangesPCMStreamCapture[nWaveRecordingEntries].MaximumSampleFrequency = dwWaveSampleRates[nLoop];

            // Add it to the PinDataRangePointer
            PinDataRangePointersPCMStreamCapture[nWaveRecordingEntries] = (PKSDATARANGE)&PinDataRangesPCMStreamCapture[nWaveRecordingEntries];

            // Increase count
            nWaveRecordingEntries++;
        }
    }

    // Check for the MIC sample rates.
    for (nLoop = 0; nLoop < MIC_SAMPLERATES_TESTED; nLoop++)
    {
        ntStatus = AdapterCommon->ProgramSampleRate (AC97REG_MIC_SAMPLERATE, dwMicSampleRates[nLoop]);

        // We support the sample rate?
        if (NT_SUCCESS (ntStatus))
        {
            // Add it to the PinDataRange
            PinDataRangesMicStream[nMicEntries].DataRange.FormatSize = sizeof(KSDATARANGE_AUDIO);
            PinDataRangesMicStream[nMicEntries].DataRange.Flags      = 0;
            PinDataRangesMicStream[nMicEntries].DataRange.SampleSize = 2;
            PinDataRangesMicStream[nMicEntries].DataRange.Reserved   = 0;
            PinDataRangesMicStream[nMicEntries].DataRange.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
            PinDataRangesMicStream[nMicEntries].DataRange.SubFormat   = KSDATAFORMAT_SUBTYPE_PCM;
            PinDataRangesMicStream[nMicEntries].DataRange.Specifier   = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;
            PinDataRangesMicStream[nMicEntries].MaximumChannels = 1;
            PinDataRangesMicStream[nMicEntries].MinimumBitsPerSample = 16;
            PinDataRangesMicStream[nMicEntries].MaximumBitsPerSample = 16;
            PinDataRangesMicStream[nMicEntries].MinimumSampleFrequency = dwMicSampleRates[nLoop];
            PinDataRangesMicStream[nMicEntries].MaximumSampleFrequency = dwMicSampleRates[nLoop];

            // Add it to the PinDataRangePointer
            PinDataRangePointersMicStream[nMicEntries] = (PKSDATARANGE)&PinDataRangesMicStream[nMicEntries];

            // Increase count
            nMicEntries++;
        }
    }

    // Now go through the pin descriptor list and change the data range entries to the actual number.
    for (nLoop = 0; nLoop < SIZEOF_ARRAY(MiniportPins); nLoop++)
    {
        if (MiniportPins[nLoop].KsPinDescriptor.DataRanges == PinDataRangePointersPCMStreamRender)
            MiniportPins[nLoop].KsPinDescriptor.DataRangesCount = nWavePlaybackEntries;
        if (MiniportPins[nLoop].KsPinDescriptor.DataRanges == PinDataRangePointersPCMStreamCapture)
            MiniportPins[nLoop].KsPinDescriptor.DataRangesCount = nWaveRecordingEntries;
        if (MiniportPins[nLoop].KsPinDescriptor.DataRanges == PinDataRangePointersMicStream)
            MiniportPins[nLoop].KsPinDescriptor.DataRangesCount = nMicEntries;
    }

    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICH::NewStream
 *****************************************************************************
 * Creates a new stream.
 * This function is called when a streaming pin is created.
 * It checks if the channel is already in use, tests the data format, creates
 * and initializes the stream object.
 */
STDMETHODIMP CMiniportWaveICH::NewStream
(
    OUT PMINIPORTWAVEPCISTREAM *Stream,
    IN  PUNKNOWN                OuterUnknown,
    IN  POOL_TYPE               PoolType,
    IN  PPORTWAVEPCISTREAM      PortStream,
    IN  ULONG                   Channel_,
    IN  BOOLEAN                 Capture,
    IN  PKSDATAFORMAT           DataFormat,
    OUT PDMACHANNEL            *DmaChannel_,
    OUT PSERVICEGROUP          *ServiceGroup
)
{
    PAGED_CODE ();

    ASSERT (Stream);
    ASSERT (PortStream);
    ASSERT (DataFormat);
    ASSERT (DmaChannel_);
    ASSERT (ServiceGroup);

    CMiniportWaveICHStream *pWaveICHStream = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    DOUT (DBG_PRINT, ("[CMiniportWaveICH::NewStream]"));

    //
    // Validate the channel (pin id).
    //
    if ((Channel_ != PIN_WAVEOUT) && (Channel_ != PIN_WAVEIN) &&
       (Channel_ != PIN_MICIN))
    {
        DOUT (DBG_ERROR, ("[NewStream] Invalid channel passed!"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check if the pin is already in use
    //
    ULONG Channel = Channel_ >> 1;
    if (Streams[Channel])
    {
        DOUT (DBG_ERROR, ("[NewStream] Pin is already in use!"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Check parameters.
    //
    ntStatus = TestDataFormat (DataFormat, (WavePins)Channel_);
    if (!NT_SUCCESS (ntStatus))
    {
        DOUT (DBG_VSR, ("[NewStream] TestDataFormat failed!"));
        return ntStatus;
    }
        
    //
    // Create a new stream.
    //
    ntStatus = CreateMiniportWaveICHStream (&pWaveICHStream, OuterUnknown,
                                            PoolType);

    //
    // Return in case of an error.
    //
    if (!NT_SUCCESS (ntStatus))
    {
        DOUT (DBG_ERROR, ("[NewStream] Failed to create stream!"));
        return ntStatus;
    }

    //
    // Initialize the stream.
    //
    ntStatus = pWaveICHStream->Init (this,
                                    PortStream,
                                    Channel,
                                    Capture,
                                    DataFormat,
                                    ServiceGroup);
    if (!NT_SUCCESS (ntStatus))
    {
        //
        // Release the stream and clean up.
        //
        DOUT (DBG_ERROR, ("[NewStream] Failed to init stream!"));
        pWaveICHStream->Release ();
        // In case the stream passed us a ServiceGroup, portcls will ignore all parameters
        // on a failure, so we have to release it here.
        if (*ServiceGroup)
            (*ServiceGroup)->Release();
        *ServiceGroup = NULL;
        *Stream = NULL;
        *DmaChannel_ = NULL;
        return ntStatus;
    }

    // 
    // Save the pointers.
    //
    *Stream = (PMINIPORTWAVEPCISTREAM)pWaveICHStream;
    *DmaChannel_ = DmaChannel;
    
    
    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICH::GetDescription
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP_(NTSTATUS) CMiniportWaveICH::GetDescription
(
    OUT PPCFILTER_DESCRIPTOR *OutFilterDescriptor
)
{
    PAGED_CODE ();

    ASSERT (OutFilterDescriptor);

    DOUT (DBG_PRINT, ("[CMiniportWaveICH::GetDescription]"));

    *OutFilterDescriptor = &MiniportFilterDescriptor;


    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICH::DataRangeIntersection
 *****************************************************************************
 * Tests a data range intersection.
 * Cause the AC97 controller does not support mono render or capture, we have
 * to check the max. channel field (unfortunately, there is no MinimumChannel
 * and MaximumChannel field, just a MaximumChannel field).
 * If the MaximumChannel is 2, then we can pass this to the default handler of
 * portcls which always chooses the most (SampleFrequency, Channel, Bits etc.)
 *
 * This DataRangeIntersection function is strictly only for the exposed formats
 * in this sample driver. If you intend to add other formats like AC3 then
 * you have to be make sure that you check the GUIDs and the data range, since
 * portcls only checks the data range for waveformatex.
 */
STDMETHODIMP_(NTSTATUS) CMiniportWaveICH::DataRangeIntersection
(
    IN      ULONG           PinId,
    IN      PKSDATARANGE    ClientsDataRange,
    IN      PKSDATARANGE    MyDataRange,
    IN      ULONG           OutputBufferLength,
    OUT     PVOID           ResultantFormat,
    OUT     PULONG          ResultantFormatLength
)
{
    PAGED_CODE ();

    DOUT (DBG_PRINT, ("[CMiniportWaveICH::DataRangeIntersection]"));

    //
    // This function gets only called if the GUIDS in the KSDATARANGE_AUDIO
    // structure that we attached to the pin are equal with the requested
    // format (see "BuildDataRangeInformation).
    // Additionally, for waveformatex portcls checks that the requested sample
    // frequency range fits into our exposed sample frequency range. Since we
    // only have discrete sample frequencies in the pin's data range, we don't
    // have to check that either.
    // There is one exception to this rule: portcls clones all WAVEFORMATEX
    // data ranges to DSOUND dataranges, so we might get a data range
    // intersection that has a DSOUND specifier. We don't support that
    // since this is only used for HW acceleration
    //
    if (IsEqualGUIDAligned (ClientsDataRange->Specifier, KSDATAFORMAT_SPECIFIER_DSOUND))
    {
        DOUT (DBG_PRINT, ("[DataRangeIntersection] We don't support DSOUND specifier"));
        return STATUS_NOT_SUPPORTED;
    }
    
    //
    // Start with checking the size of the output buffer.
    //
    if (!OutputBufferLength) 
    {
        *ResultantFormatLength = sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
        return STATUS_BUFFER_OVERFLOW;
    } 
    
    if (OutputBufferLength < (sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX))) 
    {
        DOUT (DBG_WARNING, ("[DataRangeIntersection] Buffer too small"));
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    //
    // We can only play or record multichannel (>=2 channels) except for the MIC
    // recording channel where we can only record mono. Portcls checked the channels
    // already, however, since we have no minimum channels field, the KSDATARANGE_AUDIO
    // could have MaximumChannels = 1.
    //
    if (PinId != PIN_MICIN)
    {
        // reject mono format for normal wave playback or capture.
        if (((PKSDATARANGE_AUDIO)ClientsDataRange)->MaximumChannels < 2)
        {
            DOUT (DBG_WARNING, ("[DataRangeIntersection] Mono requested for WaveIn or WaveOut"));
            return STATUS_NO_MATCH;
        }
    }

    //
    // Fill in the structure the datarange structure.
    // KSDATARANGE and KSDATAFORMAT are the same.
    //
    *(PKSDATAFORMAT)ResultantFormat = *MyDataRange;

    //
    // Modify the size of the data format structure to fit the WAVEFORMATPCMEX
    // structure.
    //
    ((PKSDATAFORMAT)ResultantFormat)->FormatSize =
        sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);

    //
    // Append the WAVEFORMATPCMEX structur.
    //
    PWAVEFORMATPCMEX WaveFormat = (PWAVEFORMATPCMEX)((PKSDATAFORMAT)ResultantFormat + 1);

    // We want a WAFEFORMATEXTENSIBLE which is equal to WAVEFORMATPCMEX.
    WaveFormat->Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
    // Set the number of channels
    if (PinId == PIN_WAVEOUT)
    {
        // Get the max. possible channels for playback.
        ULONG nMaxChannels = min (((PKSDATARANGE_AUDIO)ClientsDataRange)->MaximumChannels, m_wChannels);

        // We cannot play uneven number of channels
        if (nMaxChannels & 0x01)
            nMaxChannels--;
        // ... and also 0 channels wouldn't be a good request.
        if (!nMaxChannels)
            return STATUS_NO_MATCH;

        WaveFormat->Format.nChannels = (WORD)nMaxChannels;
    }
    else
        // This will be 2 for normal record and 1 for MIC record.
        WaveFormat->Format.nChannels = (WORD)((PKSDATARANGE_AUDIO)MyDataRange)->MaximumChannels;
    
    //
    // Hack for codecs that have only one sample rate converter that has both
    // playback and recording data.
    //
    if ((Streams[PIN_WAVEIN_OFFSET] || Streams[PIN_WAVEOUT_OFFSET]) &&
        !AdapterCommon->GetNodeConfig (NODEC_PCM_VSR_INDEPENDENT_RATES))
    {
        //
        // We have to return this sample rate that is used in the open stream.
        //
        ULONG   ulFrequency;

        if (Streams[PIN_WAVEIN_OFFSET])
            ulFrequency = Streams[PIN_WAVEIN_OFFSET]->GetCurrentSampleRate();
        else
            ulFrequency = Streams[PIN_WAVEOUT_OFFSET]->GetCurrentSampleRate();

        //
        // Check if this sample rate is in the requested data range of the client.
        //
        if ((((PKSDATARANGE_AUDIO)ClientsDataRange)->MaximumSampleFrequency < ulFrequency) ||
            (((PKSDATARANGE_AUDIO)ClientsDataRange)->MinimumSampleFrequency > ulFrequency))
        {
            return STATUS_NO_MATCH;
        }

        WaveFormat->Format.nSamplesPerSec = ulFrequency;
    }
    else
    {
        // Since we have discrete frequencies in the data range, min = max.
        WaveFormat->Format.nSamplesPerSec = ((PKSDATARANGE_AUDIO)MyDataRange)->MaximumSampleFrequency;
    }
    
    // Will be 16.
    WaveFormat->Format.wBitsPerSample = (WORD)((PKSDATARANGE_AUDIO)MyDataRange)->MaximumBitsPerSample;
    // Will be 2 * channels.
    WaveFormat->Format.nBlockAlign = (WaveFormat->Format.wBitsPerSample * WaveFormat->Format.nChannels) / 8;
    // That is played in a sec.
    WaveFormat->Format.nAvgBytesPerSec = WaveFormat->Format.nSamplesPerSec * WaveFormat->Format.nBlockAlign;
    // WAVEFORMATPCMEX
    WaveFormat->Format.cbSize = 22;
    // We have as many valid bits as the bit depth is (16).
    WaveFormat->Samples.wValidBitsPerSample = WaveFormat->Format.wBitsPerSample;
    // Set the channel mask
    if (PinId == PIN_WAVEOUT)
    {
        // If we can play in our configuration, then set the channel mask
        if (WaveFormat->Format.nChannels == m_wChannels)
            // Set the playback channel mask to the current speaker config.
            WaveFormat->dwChannelMask = m_dwChannelMask;
        else
        {
            //
            // We have to set a channel mask.
            // nChannles can only be 4 if we are in 6 channel mode. In that
            // case it must be a QUAD configurations. The only other value
            // allowed is 2 channels, which defaults to stereo.
            //
            if (WaveFormat->Format.nChannels == 4)
                WaveFormat->dwChannelMask = KSAUDIO_SPEAKER_QUAD;
            else
                WaveFormat->dwChannelMask = KSAUDIO_SPEAKER_STEREO;
        }
    }
    else
    {
        // This will be KSAUDIO_SPEAKER_STEREO for normal record and KSAUDIO_SPEAKER_MONO
        // for MIC record.
        if (PinId == PIN_MICIN)
            // MicIn -> 1 channel
            WaveFormat->dwChannelMask = KSAUDIO_SPEAKER_MONO;
        else
            // normal record -> 2 channels
            WaveFormat->dwChannelMask = KSAUDIO_SPEAKER_STEREO;
    }
    // Here we specify the subtype of the WAVEFORMATEXTENSIBLE.
    WaveFormat->SubFormat = KSDATAFORMAT_SUBTYPE_PCM;

    // Now overwrite also the sample size in the ksdataformat structure.
    ((PKSDATAFORMAT)ResultantFormat)->SampleSize = WaveFormat->Format.nBlockAlign;
    
    //
    // That we will return.
    //
    *ResultantFormatLength = sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
    
    DOUT (DBG_STREAM, ("[DataRangeIntersection] Frequency: %d, Channels: %d, bps: %d, ChannelMask: %X",
          WaveFormat->Format.nSamplesPerSec, WaveFormat->Format.nChannels,
          WaveFormat->Format.wBitsPerSample, WaveFormat->dwChannelMask));

    // Let portcls do some work ...
    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICH::TestDataFormat
 *****************************************************************************
 * Checks if the passed data format is known to the driver and verifies that
 * the number of channels, the width of one sample match to the AC97
 * specification.
 */
NTSTATUS CMiniportWaveICH::TestDataFormat
(
    IN  PKSDATAFORMAT Format,
    IN  WavePins      Pin
)
{
    PAGED_CODE ();

    ASSERT (Format);

    DOUT (DBG_PRINT, ("[CMiniportWaveICH::TestDataFormat]"));

    //
    // KSDATAFORMAT contains three GUIDs to support extensible format.  The
    // first two GUIDs identify the type of data.  The third indicates the
    // type of specifier used to indicate format specifics.  We are only
    // supporting PCM audio formats that use WAVEFORMATEX.
    //
    if (!IsEqualGUIDAligned (Format->MajorFormat, KSDATAFORMAT_TYPE_AUDIO) ||
        !IsEqualGUIDAligned (Format->SubFormat, KSDATAFORMAT_SUBTYPE_PCM)  ||
        !IsEqualGUIDAligned (Format->Specifier, KSDATAFORMAT_SPECIFIER_WAVEFORMATEX))
    {
        DOUT (DBG_ERROR, ("[TestDataFormat] Invalid format type!"));
        return STATUS_INVALID_PARAMETER;
    }

    PWAVEFORMATPCMEX waveFormat = (PWAVEFORMATPCMEX)(Format + 1);

    //
    // If the size doesn't match, then something is messed up.
    //
    if (Format->FormatSize < (sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATEX)))
    {
        DOUT (DBG_WARNING, ("[TestDataFormat] Invalid FormatSize!"));
        return STATUS_INVALID_PARAMETER;
    }
            
    //
    // We only support PCM, 16-bit.
    //
    if (waveFormat->Format.wBitsPerSample != 16)
    {
        DOUT (DBG_WARNING, ("[TestDataFormat] Bits Per Sample must be 16!"));
        return STATUS_INVALID_PARAMETER;
    }
    
    //
    // We support WaveFormatPCMEX (=WAVEFORMATEXTENSIBLE) or WaveFormatPCM.
    //
    if ((waveFormat->Format.wFormatTag != WAVE_FORMAT_EXTENSIBLE) &&
        (waveFormat->Format.wFormatTag != WAVE_FORMAT_PCM))
    {
        DOUT (DBG_WARNING, ("[TestDataFormat] Invalid Format Tag!"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make additional checks for the WAVEFORMATEXTENSIBLE
    //
    if (waveFormat->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE)
    {
        //
        // If the size doesn't match, then something is messed up.
        //
        if (Format->FormatSize < (sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX)))
        {
            DOUT (DBG_WARNING, ("[TestDataFormat] Invalid FormatSize!"));
            return STATUS_INVALID_PARAMETER;
        }
        
        //
        // Check also the subtype (PCM) and the size of the extended data.
        //
        if (!IsEqualGUIDAligned (waveFormat->SubFormat, KSDATAFORMAT_SUBTYPE_PCM) ||
            (waveFormat->Format.cbSize < (sizeof(WAVEFORMATPCMEX) - sizeof(WAVEFORMATEX))))
        {
            DOUT (DBG_WARNING, ("[TestDataFormat] Unsupported WAVEFORMATEXTENSIBLE!"));
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Check the channel mask. We support 1, 2 channels or whatever was set
        // with the Speaker config dialog.
        //
        if (((waveFormat->Format.nChannels == 1) &&
             (waveFormat->dwChannelMask != KSAUDIO_SPEAKER_MONO)) ||
            ((waveFormat->Format.nChannels == 2) &&
             (waveFormat->dwChannelMask != KSAUDIO_SPEAKER_STEREO)) ||
            ((waveFormat->Format.nChannels == m_wChannels) &&
             (waveFormat->dwChannelMask != m_dwChannelMask)))
        {
            DOUT (DBG_WARNING, ("[TestDataFormat] Channel Mask!"));
            return STATUS_INVALID_PARAMETER;
        }
    }
        
    //
    // Check the number of channels.
    //
    switch (Pin)
    {
        case PIN_MICIN:     // 1 channel
            if (waveFormat->Format.nChannels != 1)
            {
                DOUT (DBG_WARNING, ("[TestDataFormat] Invalid Number of Channels for PIN_MICIN!"));
                return STATUS_INVALID_PARAMETER;
            }
            break;
        case PIN_WAVEIN:    // 2 channels
            if (waveFormat->Format.nChannels != 2)
            {
                DOUT (DBG_WARNING, ("[TestDataFormat] Invalid Number of Channels for PIN_WAVEIN!"));
                return STATUS_INVALID_PARAMETER;
            }
            break;
        case PIN_WAVEOUT:   // channel and mask from PropertyChannelConfig or standard.
            if (waveFormat->Format.nChannels != m_wChannels)
            {
                DOUT (DBG_WARNING, ("[TestDataFormat] Invalid Number of Channels for PIN_WAVEOUT!"));
                return STATUS_INVALID_PARAMETER;
            }
            break;
    }
    
    //
    // Print the information.
    //
    if (waveFormat->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE)
    {
        DOUT (DBG_STREAM, ("[TestDataFormat] PCMEX - Frequency: %d, Channels: %d, bps: %d, ChannelMask: %X",
              waveFormat->Format.nSamplesPerSec, waveFormat->Format.nChannels,
              waveFormat->Format.wBitsPerSample, waveFormat->dwChannelMask));
    }
    else
    {
        DOUT (DBG_STREAM, ("[TestDataFormat] PCM - Frequency: %d, Channels: %d, bps: %d",
              waveFormat->Format.nSamplesPerSec, waveFormat->Format.nChannels,
              waveFormat->Format.wBitsPerSample));
    }
    
    return STATUS_SUCCESS;
}


/*****************************************************************************
 * CMiniportWaveICH::PowerChangeNotify
 *****************************************************************************
 * This routine gets called as a result of hooking up the IPowerNotify 
 * interface. This interface indicates the driver's desire to receive explicit
 * notification of power state changes. The interface provides a single method
 * (or callback) that is called by the miniport's corresponding port driver in
 * response to a power state change. Using wave audio as an example, when the
 * device is requested to go to a sleep state the port driver pauses any 
 * active streams and then calls the power notify callback to inform the
 * miniport of the impending power down. The miniport then has an opportunity
 * to save any necessary context before the adapter's PowerChangeState method
 * is called. The process is reversed when the device is powering up. PortCls
 * first calls the adapter's PowerChangeState method to power up the adapter.
 * The port driver then calls the miniport's callback to allow the miniport to
 * restore its context. Finally, the port driver unpauses any previously paused
 * active audio streams.
 */
STDMETHODIMP_(void) CMiniportWaveICH::PowerChangeNotify
(
    IN  POWER_STATE NewState
) 
{
    PAGED_CODE ();
    NTSTATUS ntStatus = STATUS_SUCCESS;

    DOUT (DBG_PRINT, ("[CMiniportWaveICH::PowerChangeNotify]"));
    
    //
    // Check to see if this is the current power state.
    //
    if (NewState.DeviceState == m_PowerState)
    {
        DOUT (DBG_POWER, ("New device state equals old state."));
        return;
    }
    
    //
    // Check the new device state.
    //
    if ((NewState.DeviceState < PowerDeviceD0) ||
        (NewState.DeviceState > PowerDeviceD3))
    {
        DOUT (DBG_ERROR, ("Unknown device state: D%d.", 
             (ULONG)NewState.DeviceState - (ULONG)PowerDeviceD0));
        return;
    }

    DOUT (DBG_POWER, ("Changing state to D%d.", (ULONG)NewState.DeviceState -
                    (ULONG)PowerDeviceD0));

    //
    // In case we return to D0 power state from a D3 state, restore the
    // interrupt connection.
    //
    if (NewState.DeviceState == PowerDeviceD0)
    {
        ntStatus = InterruptSync->Connect ();
        if (!NT_SUCCESS (ntStatus))
        {
            DOUT (DBG_ERROR, ("Failed to connect the ISR with InterruptSync!"));
            // We can do nothing else than just continue ...
        }
    }
    
    //
    // Call the stream routine which takes care of the DMA engine.
    // That's all we have to do.
    //
    for (int loop = PIN_WAVEOUT_OFFSET; loop < PIN_MICIN_OFFSET; loop++)
    {
        if (Streams[loop])
        {
            ntStatus = Streams[loop]->PowerChangeNotify (NewState);
            if (!NT_SUCCESS (ntStatus))
            {
                DOUT (DBG_ERROR, ("PowerChangeNotify D%d for the stream failed",
                              (ULONG)NewState.DeviceState - (ULONG)PowerDeviceD0));
            }
        }
    }

    //
    // In case we go to any sleep state we disconnect the interrupt service
    // reoutine from the interrupt.
    // Normally this is not required to do, but for some reason this fixes
    // a problem where we won't have any interrupts on specific motherboards
    // after resume.
    //
    if (NewState.DeviceState != PowerDeviceD0)
    {
        InterruptSync->Disconnect ();
    }

    //
    // Save the new state.  This local value is used to determine when to 
    // cache property accesses and when to permit the driver from accessing 
    // the hardware.
    //
    m_PowerState = NewState.DeviceState;
    DOUT (DBG_POWER, ("Entering D%d",
            (ULONG)m_PowerState - (ULONG)PowerDeviceD0));
}

/*****************************************************************************
 * Non paged code begins here
 *****************************************************************************
 */

#pragma code_seg()
/*****************************************************************************
 * CMiniportWaveICH::Service
 *****************************************************************************
 * Processing routine for dealing with miniport interrupts.  This routine is
 * called at DISPATCH_LEVEL.
 */
STDMETHODIMP_(void) CMiniportWaveICH::Service (void)
{
    // not needed
}


/*****************************************************************************
 * InterruptServiceRoutine
 *****************************************************************************
 * The task of the ISR is to clear an interrupt from this device so we don't
 * get an interrupt storm and schedule a DPC which actually does the 
 * real work.
 */
NTSTATUS CMiniportWaveICH::InterruptServiceRoutine
(
    IN  PINTERRUPTSYNC  InterruptSync,
    IN  PVOID           DynamicContext
)
{
    ASSERT (InterruptSync);
    ASSERT (DynamicContext);

    ULONG   GlobalStatus;
    USHORT  DMAStatusRegister;

    //
    // Get our context which is a pointer to class CMiniportWaveICH.
    //
    CMiniportWaveICH *that = (CMiniportWaveICH *)DynamicContext;

    //
    // Check for a valid AdapterCommon pointer.
    //
    if (!that->AdapterCommon)
    {
        //
        // In case we didn't handle the interrupt, unsuccessful tells the system
        // to call the next interrupt handler in the chain.
        //
        return STATUS_UNSUCCESSFUL;
    }

    //
    // From this point down, basically in the complete ISR, we cannot use
    // relative addresses (stream class base address + X_CR for example)
    // cause we might get called when the stream class is destroyed or
    // not existent. This doesn't make too much sense (that there is an
    // interrupt for a non-existing stream) but could happen and we have
    // to deal with the interrupt.
    //
    
    //
    // Read the global register to check the interrupt bits
    //
    GlobalStatus = that->AdapterCommon->ReadBMControlRegister32 (GLOB_STA);
    
    //
    // Check for weird return values. Could happen if the PCI device is already
    // disabled and another device that shares this interrupt generated an
    // interrupt.
    // The register should never have all bits cleared or set.
    //
    if (!GlobalStatus || (GlobalStatus == 0xFFFFFFFF))
    {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Check for PCM out interrupt.
    //
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    if (GlobalStatus & GLOB_STA_POINT)
    {
        //
        // Read PCM out DMA status registers.
        //
        DMAStatusRegister = (USHORT)that->AdapterCommon->
            ReadBMControlRegister16 (PO_SR);


        //
        // We could now check for every possible error condition
        // (like FIFO error) and monitor the different errors, but currently
        // we have the same action for every INT and therefore we simplify
        // this routine enormous with just clearing the bits.
        //
        if (that->Streams[PIN_WAVEOUT_OFFSET])
        {
            //
            // ACK the interrupt.
            //
            that->AdapterCommon->WriteBMControlRegister (PO_SR, DMAStatusRegister);
            ntStatus = STATUS_SUCCESS;


            //
            // Request DPC service for PCM out.
            //
            if ((that->Port) && (that->Streams[PIN_WAVEOUT_OFFSET]->ServiceGroup))
            {
                that->Port->Notify (that->Streams[PIN_WAVEOUT_OFFSET]->ServiceGroup);
            }
            else
            {
                //
                // Bad, bad.  Shouldn't print in an ISR!
                //
                DOUT (DBG_ERROR, ("WaveOut INT fired but no stream object there."));
            }
        }
    }
    
    //
    // Check for PCM in interrupt.
    //
    if (GlobalStatus & GLOB_STA_PIINT)
    {
        //
        // Read PCM in DMA status registers.
        //
        DMAStatusRegister = (USHORT)that->AdapterCommon->
            ReadBMControlRegister16 (PI_SR);

        //
        // We could now check for every possible error condition
        // (like FIFO error) and monitor the different errors, but currently
        // we have the same action for every INT and therefore we simplify
        // this routine enormous with just clearing the bits.
        //
        if (that->Streams[PIN_WAVEIN_OFFSET])
        {
            //
            // ACK the interrupt.
            //
            that->AdapterCommon->WriteBMControlRegister (PI_SR, DMAStatusRegister);
            ntStatus = STATUS_SUCCESS;

            
            //
            // Request DPC service for PCM in.
            //
            if ((that->Port) && (that->Streams[PIN_WAVEIN_OFFSET]->ServiceGroup))
            {
                that->Port->Notify (that->Streams[PIN_WAVEIN_OFFSET]->ServiceGroup);
            }
            else
            {
                //
                // Bad, bad.  Shouldn't print in an ISR!
                //
                DOUT (DBG_ERROR, ("WaveIn INT fired but no stream object there."));
            }
        }
    }

    //
    // Check for MIC in interrupt.
    //
    if (GlobalStatus & GLOB_STA_MINT)
    {
        //
        // Read MIC in DMA status registers.
        //
        DMAStatusRegister = (USHORT)that->AdapterCommon->
            ReadBMControlRegister16 (MC_SR);

        //
        // We could now check for every possible error condition
        // (like FIFO error) and monitor the different errors, but currently
        // we have the same action for every INT and therefore we simplify
        // this routine enormous with just clearing the bits.
        //
        if (that->Streams[PIN_MICIN_OFFSET])
        {
            //
            // ACK the interrupt.
            //
            that->AdapterCommon->WriteBMControlRegister (MC_SR, DMAStatusRegister);
            ntStatus = STATUS_SUCCESS;

            
            //
            // Request DPC service for PCM out.
            //
            if ((that->Port) && (that->Streams[PIN_MICIN_OFFSET]->ServiceGroup))
            {
                that->Port->Notify (that->Streams[PIN_MICIN_OFFSET]->ServiceGroup);
            }
            else
            {
                //
                // Bad, bad.  Shouldn't print in an ISR!
                //
                DOUT (DBG_ERROR, ("MicIn INT fired but no stream object there."));
            }
        }
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\minwave.h ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

#ifndef _MINWAVE_H_
#define _MINWAVE_H_

#include "shared.h"

/*****************************************************************************
 * Constants
 *****************************************************************************
 */
const int WAVE_SAMPLERATES_TESTED = 7;
const int MIC_SAMPLERATES_TESTED = 4;

const DWORD dwWaveSampleRates[WAVE_SAMPLERATES_TESTED] =
    {48000, 44100, 32000, 22050, 16000, 11025, 8000};
const DWORD dwMicSampleRates[MIC_SAMPLERATES_TESTED] =
    {48000, 32000, 16000, 8000};

const int PIN_WAVEOUT_OFFSET = (PIN_WAVEOUT / 2);
const int PIN_WAVEIN_OFFSET  = (PIN_WAVEIN / 2);
const int PIN_MICIN_OFFSET   = (PIN_MICIN / 2);

/*****************************************************************************
 * Forward References
 *****************************************************************************
 */
class CMiniportWaveICHStream;

extern NTSTATUS CreateMiniportWaveICHStream
(
    OUT     CMiniportWaveICHStream **   pWaveIchStream,
    IN      PUNKNOWN                    pUnknown,
    IN      POOL_TYPE                   PoolType
);

/*****************************************************************************
 * Classes
 *****************************************************************************
 */

/*****************************************************************************
 * CMiniportWaveICH
 *****************************************************************************
 * ICH wave PCI miniport.  This object is associated with the device and is
 * created when the device is started.  The class inherits IMiniportWavePci
 * so it can expose this interface, CUnknown so it automatically gets
 * reference counting and aggregation support, and IPowerNotify for ACPI 
 * power management notification.
 */
class CMiniportWaveICH : public IMiniportWavePci,
                                public IPowerNotify,
                                public CUnknown
{
private:
    // The stream class accesses a lot of private member variables.
    // A better way would be to abstract the access through member
    // functions which on the other hand would produce more overhead
    // both in CPU time and programming time.
    friend class CMiniportWaveICHStream;

    //
    // CMiniportWaveICH private variables
    //
    CMiniportWaveICHStream *Streams[PIN_MICIN_OFFSET + 1];
    PPORTWAVEPCI        Port;           // Port driver object.
    PADAPTERCOMMON      AdapterCommon;  // Adapter common object.
    PADAPTER_OBJECT     AdapterObject;
    PINTERRUPTSYNC      InterruptSync;  // Interrupt Sync.
    PDMACHANNEL         DmaChannel;     // Bus master support.
    DEVICE_POWER_STATE  m_PowerState;   // advanced power control.
    DWORD               m_dwChannelMask; // Channel config for speaker positions.
    WORD                m_wChannels;      // Number of channels.

    /*************************************************************************
     * CMiniportWaveICH methods
     *************************************************************************
     * These are private member functions used internally by the object.  See
     * MINWAVE.CPP for specific descriptions.
     */

    //
    // Checks and connects the miniport to the resources.
    //
    NTSTATUS ProcessResources
    (
        IN   PRESOURCELIST     ResourceList
    );

    //
    // Tests the data format but not the sample rate.
    //
    NTSTATUS TestDataFormat
    (
        IN PKSDATAFORMAT Format,
        IN WavePins      Pin
    );

    // Test for standard sample rate support and fill the data range information
    // in the structures below.
    NTSTATUS BuildDataRangeInformation (void);

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINWAVE.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINWAVE.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN ();
    DEFINE_STD_CONSTRUCTOR (CMiniportWaveICH);
    ~CMiniportWaveICH ();

    //
    // Include IMiniportWavePci (public/exported) methods
    //
    IMP_IMiniportWavePci;

    //
    // IPowerNotify methods
    //
    IMP_IPowerNotify;

    //
    // This static functions is the interrupt service routine which is
    // not stream related, but services all streams at once.
    //
    static NTSTATUS InterruptServiceRoutine
    (
        IN      PINTERRUPTSYNC  InterruptSync,
        IN      PVOID           StaticContext
    );

    //
    // This is the property handler for KSPROPERTY_AUDIO_CHANNEL_CONFIG of the
    // DAC node.
    //
    static NTSTATUS PropertyChannelConfig
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );
};

#endif          // _MINWAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\ichreg.h ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

#ifndef _ICHREG_H_
#define _ICHREG_H_

// We define the offsets like PI_BDBAR as ULONG (instead of UCHAR) for run
// time efficiency.

// CoDec AC97 register space offsets
const ULONG PRIMARY_CODEC   = 0x00;
const ULONG SECONDARY_CODEC = 0x80;

// Native audio bus master control registers (offsets)
const ULONG PI_BDBAR        = 0x00; // PCM In Buffer Descriptor Base Address Register
const ULONG PI_CIV          = 0x04; // PCM In Current Index Value
const ULONG PI_LVI          = 0x05; // PCM In Last Valid Index
const ULONG PI_SR           = 0x06; // PCM In Status Register
const ULONG PI_PICB         = 0x08; // PCM In Position In Current Buffer
const ULONG PI_PIV          = 0x0A; // PCM In Prefetch Index Value
const ULONG PI_CR           = 0x0B; // PCM In Control Register
const ULONG PO_BDBAR        = 0x10; // PCM Out Buffer Descriptor Base Address Register
const ULONG PO_CIV          = 0x14; // PCM Out Current Index Value
const ULONG PO_LVI          = 0x15; // PCM Out Last Valid Index
const ULONG PO_SR           = 0x16; // PCM Out Status Register
const ULONG PO_PICB         = 0x18; // PCM Out Position In Current Buffer
const ULONG PO_PIV          = 0x1A; // PCM Out Prefetch Index Value
const ULONG PO_CR           = 0x1B; // PCM Out Control Register
const ULONG MC_BDBAR        = 0x20; // Mic In Buffer Descriptor Base Address Register
const ULONG MC_CIV          = 0x24; // Mic In Current Index Value
const ULONG MC_LVI          = 0x25; // Mic In Last Valid Index
const ULONG MC_SR           = 0x26; // Mic In Status Register
const ULONG MC_PICB         = 0x28; // Mic In Position In Current Buffer
const ULONG MC_PIV          = 0x2A; // Mic In Prefetch Index Value
const ULONG MC_CR           = 0x2B; // Mic In Control Register
const ULONG GLOB_CNT        = 0x2C; // Global Control
const ULONG GLOB_STA        = 0x30; // Global Status
const ULONG CAS             = 0x34; // Codec Access Semiphore

// Defines for relative accesses (offsets)
const ULONG X_PI_BASE       = 0x00; // PCM In Base
const ULONG X_PO_BASE       = 0x10; // PCM Out Base
const ULONG X_MC_BASE       = 0x20; // Mic In Base
const ULONG X_BDBAR         = 0x00; // Buffer Descriptor Base Address Register
const ULONG X_CIV           = 0x04; // Current Index Value
const ULONG X_LVI           = 0x05; // Last Valid Index
const ULONG X_SR            = 0x06; // Status Register
const ULONG X_PICB          = 0x08; // Position In Current Buffer
const ULONG X_PIV           = 0x0A; // Prefetch Index Value
const ULONG X_CR            = 0x0B; // Control Register

// Bits defined in satatus register (*_SR)
const USHORT SR_FIFOE       = 0x0010;   // FIFO error
const USHORT SR_BCIS        = 0x0008;   // Buffer Completeion Interrupt Status
const USHORT SR_LVBCI       = 0x0004;   // Last Valid Buffer Completion Interrupt
const USHORT SR_CELV        = 0x0002;   // Last Valid Buffer Completion Interrupt

// Global Control bit defines (GLOB_CNT)
const ULONG GLOB_CNT_PCM6   = 0x00200000;   // 6 Channel Mode bit
const ULONG GLOB_CNT_PCM4   = 0x00100000;   // 4 Channel Mode bit
const ULONG GLOB_CNT_SRIE   = 0x00000020;   // Secondary Resume Interrupt Enable
const ULONG GLOB_CNT_PRIE   = 0x00000010;   // Primary Resume Interrupt Enable
const ULONG GLOB_CNT_ACLOFF = 0x00000008;   // ACLINK Off
const ULONG GLOB_CNT_WARM   = 0x00000004;   // AC97 Warm Reset
const ULONG GLOB_CNT_COLD   = 0x00000002;   // AC97 Cold Reset
const ULONG GLOB_CNT_GIE    = 0x00000001;   // GPI Interrupt Enable

// Global Status bit defines (GLOB_STA)
const ULONG GLOB_STA_MC6    = 0x00200000;   // Multichannel Capability 6 channel
const ULONG GLOB_STA_MC4    = 0x00100000;   // Multichannel Capability 4 channel
const ULONG GLOB_STA_MD3    = 0x00020000;   // Modem Power Down Semiphore
const ULONG GLOB_STA_AD3    = 0x00010000;   // Audio Power Down Semiphore
const ULONG GLOB_STA_RCS    = 0x00008000;   // Read Completion Status
const ULONG GLOB_STA_B3S12  = 0x00004000;   // Bit 3 Slot 12
const ULONG GLOB_STA_B2S12  = 0x00002000;   // Bit 2 Slot 12
const ULONG GLOB_STA_B1S12  = 0x00001000;   // Bit 1 Slot 12
const ULONG GLOB_STA_SRI    = 0x00000800;   // Secondary Resume Interrupt
const ULONG GLOB_STA_PRI    = 0x00000400;   // Primary Resume Interrupt
const ULONG GLOB_STA_SCR    = 0x00000200;   // Secondary Codec Ready
const ULONG GLOB_STA_PCR    = 0x00000100;   // Primary Codec Ready
const ULONG GLOB_STA_MINT   = 0x00000080;   // Mic In Interrupt
const ULONG GLOB_STA_POINT  = 0x00000040;   // PCM Out Interrupt
const ULONG GLOB_STA_PIINT  = 0x00000020;   // PCM In Interrupt
const ULONG GLOB_STA_MOINT  = 0x00000004;   // Modem Out Interrupt

// CoDec Access Semiphore bit defines (CAS)
const UCHAR CAS_CAS         = 0x01; // Codec Access Semiphore Bit

// DMA Engine Control Register (*_CR) bit defines
const UCHAR CR_IOCE         = 0x10; // Interrupt On Completion Enable
const UCHAR CR_FEIE         = 0x08; // FIFO Error Interrupt Enable
const UCHAR CR_LVBIE        = 0x04; // Last Valid Buffer Interrupt Enable
const UCHAR CR_RPBM         = 0x01; // Run/Pause Bus Master
const UCHAR CR_RR           = 0x02; // Reset Registers (RR)

// BDL policy bits
const USHORT IOC_ENABLE     = 0x8000;
const USHORT BUP_SET        = 0x4000;

#endif  //_ICHREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\mintopo.h ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

#ifndef _MINTOPO_H_
#define _MINTOPO_H_

#include "shared.h"
#include "guids.h"
#ifdef INCLUDE_PRIVATE_PROPERTY
#include "prvprop.h"
#endif


/*****************************************************************************
 * Structures and Definitions
 */

// This structure is used to translate the TopoPins member to a (registered)
// system pin member or vice versa.
typedef struct
{
    TopoPins    PinDef;
    int         PinNr;
} tPinTranslationTable;


// This structure is used to translate the TopoNodes member to a (registered)
// system node member or vice versa.
typedef struct
{
    TopoNodes   NodeDef;
    int         NodeNr;
} tNodeTranslationTable;

// max. number of connections
const int TOPO_MAX_CONNECTIONS = 0x80;

// Looking at the structure stMapNodeToReg, it defines a mask for a node.
// A volume node for instance could be used to prg. the left or right channel,
// so we have to mask the mask in stMapNodeToReg with a "left channel mask"
// or a "right channel mask" to only prg. the left or right channel.
const WORD AC97REG_MASK_LEFT  = 0x3F00;
const WORD AC97REG_MASK_RIGHT = 0x003F;
const WORD AC97REG_MASK_MUTE  = 0x8000;

// When the user moves the fader of a volume control to the bottom, the
// system calls the property handler with a -MAXIMUM dB value. That's not
// what you returned at a basic support "data range", but the most negative
// value you can represent with a long.
const long PROP_MOST_NEGATIVE = (long)0x80000000;

// We must cache the values for the volume and tone controls. If we don't,
// the controls will "jump".
// We have around 50% volume controls in the nodes. One way would be to
// create a separate structure for the node cache and a second array for
// the mapping. But we just use one big array (that could cache mute controls
// too) and in that way simplify the code a little.
// We use the bLeftValid and bRightValid to indicate whether the values stored
// in lLeft and lRight are true - remember at startup we only write and
// initialize the AC97 registers and not this structure. But as soon as there
// is a property get or a property set, this element (node) will be stored here
// and marked valid.
// We don't have to save/restore the virtual controls for WaveIn and MonoOut
// in the registry, cause WDMAUD will do this for every node that is exposed
// in the topology. We can also be sure that this structure gets initialized at
// startup because WDMAUD will query every node that it finds.
typedef struct
{
    long    lLeft;
    long    lRight;
    BYTE    bLeftValid;
    BYTE    bRightValid;
} tNodeCache;


/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CMiniportTopologyICH
 *****************************************************************************
 * ICH topology miniport.  This object is associated with the device and is
 * created when the device is started.  The class inherits IMiniportTopology
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportTopologyICH : public IMiniportTopologyICH,
                             public CUnknown
{
private:
    PADAPTERCOMMON           AdapterCommon;          // Adapter common object
    PPCFILTER_DESCRIPTOR     FilterDescriptor;       // Filter Descriptor
    PPCPIN_DESCRIPTOR        PinDescriptors;         // Pin Descriptors
    PPCNODE_DESCRIPTOR       NodeDescriptors;        // Node Descriptors
    PPCCONNECTION_DESCRIPTOR ConnectionDescriptors;  // Connection Descriptors

    tPinTranslationTable  stPinTrans[PIN_TOP_ELEMENT];   // pin translation table
    tNodeTranslationTable stNodeTrans[NODE_TOP_ELEMENT]; // node translation table
    tNodeCache            stNodeCache[NODE_TOP_ELEMENT]; // cache for nodes.
    BOOL                  m_bCopyProtectFlag;            // Copy protect flag for DRM.

    /*************************************************************************
     * CMiniportTopologyICH methods
     *
     * These are private member functions used internally by the object.  See
     * MINIPORT.CPP for specific descriptions.
     */

    // builds the topology.
    NTSTATUS BuildTopology (void);

    // registers (builds) the pins
    NTSTATUS BuildPinDescriptors (void);

    // registers (builds) the nodes
    NTSTATUS BuildNodeDescriptors (void);

    // registers (builds) the connection between the pin, nodes.
    NTSTATUS BuildConnectionDescriptors (void);

#if (DBG)
    // dumps the topology. you can specify if you want to dump pins, nodes,
    // connections (see debug.h).
    void DumpTopology (void);
#endif

    // translates the system node id to a TopoNode.
    TopoNodes TransNodeNrToNodeDef (IN int Node)
    {
#if (DBG)
        TopoNodes   n;

        n = stNodeTrans[Node].NodeDef;
        // check for invalid translation. could be caused by a connection
        // to a not registered node or wrong use of nodes.
        if (n == NODE_INVALID)
            DOUT (DBG_ERROR, ("Invalid node nr %u.", Node));
        return n;
#else
        return stNodeTrans[Node].NodeDef;
#endif
    };

    // translates a TopoNode to a system node id.
    int TransNodeDefToNodeNr (IN TopoNodes Node)
    {
#if (DBG)
        int n;

        // check for invalid translation. could be caused by a connection
        // to a not registered node or wrong use of nodes.
        n = stNodeTrans[Node].NodeNr;
        if (n == -1)
            DOUT (DBG_ERROR, ("Invalid TopoNode %u.", Node));
        return n;
#else
        return stNodeTrans[Node].NodeNr;
#endif
    };

    // translates a system pin id to a TopoPin.
    TopoPins TransPinNrToPinDef (IN int Pin)
    {
#if (DBG)
        TopoPins p;

        p = stPinTrans[Pin].PinDef;
        // check for invalid translation. could be caused by a connection
        // to a not registered pin or wrong use of pins.
        if (p == PIN_INVALID)
            DOUT (DBG_ERROR, ("Invalid pin nr %u.", Pin));
        return p;
#else
        return stPinTrans[Pin].PinDef;
#endif
    };

    // translates a TopoPin to a system pin id.
    int TransPinDefToPinNr (IN TopoPins Pin)
    {
#if (DBG)
        int p;

        p = stPinTrans[Pin].PinNr;
        // check for invalid translation. could be caused by a connection
        // to a not registered pin or wrong use of pins.
        if (p == -1)
            DOUT (DBG_ERROR, ("Invalid TopoPin %u.", Pin));
        return p;
#else
        return stPinTrans[Pin].PinNr;
#endif
    };

    // sets one table entry for translation.
    void SetNodeTranslation (IN int NodeNr, IN TopoNodes NodeDef)
    {
        stNodeTrans[NodeNr].NodeDef = NodeDef;
        stNodeTrans[NodeDef].NodeNr = NodeNr;
    };

    // sets one table entry for translation.
    void SetPinTranslation (IN int PinNr, IN TopoPins PinDef)
    {
        stPinTrans[PinNr].PinDef = PinDef;
        stPinTrans[PinDef].PinNr = PinNr;
    };

    // Updates the record mute - used for DRM.
    void UpdateRecordMute (void);

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN ();
    DEFINE_STD_CONSTRUCTOR (CMiniportTopologyICH);

    ~CMiniportTopologyICH ();

    /*************************************************************************
     * include IMiniportTopology (public/exported) methods
     */
    IMP_IMiniportTopology;

    /*************************************************************************
     * IMiniportTopologyICH methods
     */
    // returns the system pin id's for wave out, wave in and mic in.
    STDMETHODIMP_(NTSTATUS) GetPhysicalConnectionPins
    (
        OUT PULONG              WaveOutSource,
        OUT PULONG              WaveInDest,
        OUT PULONG              MicInDest
    );

    // sets the copy protect flag.
    STDMETHODIMP_(void) SetCopyProtectFlag (BOOL flag)
    {
        if (m_bCopyProtectFlag != flag)
        {
            m_bCopyProtectFlag = flag;
            UpdateRecordMute ();
        }
    };

    /*************************************************************************
     * static functions for the property handler.
     * They are not part of an COM interface and are called directly.
     */

    // Get the data range of volume or tone controls in dB.
    // Called by the property handler.
    static NTSTATUS GetDBValues
    (
        IN  PADAPTERCOMMON,
        IN  TopoNodes       Node,
        OUT LONG            *plMinimum,
        OUT LONG            *plMaximum,
        OUT ULONG           *puStep
    );

    // Calculates the speaker mute with respect to master mono.
    // Called by the property handler.
    static NTSTATUS SetMultichannelMute
    (
        IN CMiniportTopologyICH *that,
        IN TopoNodes Mute
    );

    // Calculates the speaker volume with respect to master mono.
    // Called by the property handler.
    static NTSTATUS SetMultichannelVolume
    (
        IN CMiniportTopologyICH *that,
        IN TopoNodes Volume
    );

    // property handler for mute controls of checkboxes like Loudness.
    static NTSTATUS PropertyHandler_OnOff
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );

    // This routine is the basic support handler for volume or tone controls.
    static NTSTATUS BasicSupportHandler
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );

    // property handler for all volume controls.
    static NTSTATUS PropertyHandler_Level
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );

    // property handler for tone controls.
    static NTSTATUS PropertyHandler_Tone
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );

    // property handler for muxer. we have just two muxer, one for recording
    // and one for mono out.
    static NTSTATUS PropertyHandler_Ulong
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );

    // this says that audio is played and processed without CPU resources.
    static NTSTATUS PropertyHandler_CpuResources
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );

#ifdef INCLUDE_PRIVATE_PROPERTY
    // property handler for private properties. we currently have only
    // one request defined (KSPROPERTY_AC97_FEATURES).
    static NTSTATUS PropertyHandler_Private
    (
        IN      PPCPROPERTY_REQUEST PropertyRequest
    );
#endif
};

#endif  // _MINTOPO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\prophnd.cpp ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

// Every debug output has "Modulname text".
static char STR_MODULENAME[] = "prophnd: ";

#include <limits.h>
#include "mintopo.h"

// These are the values passed to the property handler in the instance
// parameter that normally represents the channel.
const LONG CHAN_LEFT   = 0;
const LONG CHAN_RIGHT  = 1;
const LONG CHAN_MASTER = -1;


// paged code goes here.
#pragma code_seg("PAGE")


/*****************************************************************************
 * CMiniportTopologyICH::SetMultichannelMute
 *****************************************************************************
 * This function is used to set one of the multichannel mutes.
 * It takes the master mono into account when calculating the mute.
 * Make sure that you updated the stNodeCache before calling this function.
 */
NTSTATUS CMiniportTopologyICH::SetMultichannelMute
(
    IN CMiniportTopologyICH *that,
    IN TopoNodes             Mute
)
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    BOOL        bMute;

    // The first calls to SetMultichannelMute could be without valid
    // cache information because WDMAUD might currently query the nodes
    // (this is at system startup). When WDMAUD queried all nodes then
    // all cache information will be valid.
    if (that->stNodeCache[NODE_VIRT_MASTERMONO_MUTE].bLeftValid &&
        that->stNodeCache[Mute].bLeftValid)
    {
        // We get the master mono mute and the mute that is to change.
        // Then we "or" them and write the value to the register.
        bMute = that->stNodeCache[NODE_VIRT_MASTERMONO_MUTE].lLeft ||
                that->stNodeCache[Mute].lLeft;

        ntStatus = that->AdapterCommon->WriteCodecRegister (
                that->AdapterCommon->GetNodeReg (Mute),
                bMute ? -1 : 0,
                that->AdapterCommon->GetNodeMask (Mute));

        DOUT (DBG_PROPERTY, ("SET: %s -> 0x%x", NodeStrings[Mute], (int)bMute));
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportTopologyICH::SetMultichannelVolume
 *****************************************************************************
 * This function is used to set one of the multichannel volumes.
 * It takes the master mono into account when calculating the volume.
 * Make sure that you updated the stNodeCache before calling this function.
 */
NTSTATUS CMiniportTopologyICH::SetMultichannelVolume
(
    IN CMiniportTopologyICH *that,
    IN TopoNodes             Volume
)
{
    NTSTATUS        ntStatus = STATUS_SUCCESS;
    LONG            lMinimum, lMaximum;
    ULONG           uStep;
    LONG            lLevel;
    WORD            wRegister;
    
    // The first calls to SetMultichannelMute could be without valid
    // cache information because WDMAUD might currently query the nodes
    // (this is at system startup). When WDMAUD queried all nodes then
    // all cache information will be valid.
    if (that->stNodeCache[NODE_VIRT_MASTERMONO_VOLUME].bLeftValid &&
        that->stNodeCache[NODE_VIRT_MASTERMONO_VOLUME].bRightValid &&
        that->stNodeCache[Volume].bLeftValid &&
        that->stNodeCache[Volume].bRightValid)
    {
        // We get the master mono volume and the volume that is to change.
        // Then we substract master mono from it and write the value to the
        // register.
        lLevel = that->stNodeCache[Volume].lLeft +
                 that->stNodeCache[NODE_VIRT_MASTERMONO_VOLUME].lLeft;

        // Translate the dB value into a register value.

        // Get the registered DB values
        ntStatus = GetDBValues (that->AdapterCommon, Volume,
                                &lMinimum, &lMaximum, &uStep);
        if (!NT_SUCCESS(ntStatus))
            return ntStatus;

        // Check borders.
        if (lLevel < lMinimum) lLevel = lMinimum;
        if (lLevel > lMaximum) lLevel = lMaximum;

        // Calculate the register value
        wRegister = (WORD)(((lMaximum + uStep / 2) - lLevel) / uStep) << 8;

        // Get the right value too.
        lLevel = that->stNodeCache[Volume].lRight +
                 that->stNodeCache[NODE_VIRT_MASTERMONO_VOLUME].lRight;

        // Check borders.
        if (lLevel < lMinimum) lLevel = lMinimum;
        if (lLevel > lMaximum) lLevel = lMaximum;

        // Add it to the register value.
        wRegister += (WORD)(((lMaximum + uStep / 2) - lLevel) / uStep);

        // Write it.
        ntStatus = that->AdapterCommon->WriteCodecRegister (
                that->AdapterCommon->GetNodeReg (Volume),
                wRegister,
                that->AdapterCommon->GetNodeMask (Volume));

        DOUT (DBG_PROPERTY, ("SET: %s -> 0x%x/0x%x", NodeStrings[Volume],
                             that->stNodeCache[Volume].lLeft +
                             that->stNodeCache[NODE_VIRT_MASTERMONO_VOLUME].lLeft,
                             lLevel));
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportTopologyICH::GetDBValues
 *****************************************************************************
 * This function is used internally and does no parameter checking. The only
 * parameter that could be invalid is the node.
 * It returns the dB values (means minimum, maximum, step) of the node control,
 * mainly for the property call "basic support". Sure, the node must be a
 * volume or tone control node, not a mute or mux node.
 */
NTSTATUS CMiniportTopologyICH::GetDBValues
(
    IN PADAPTERCOMMON AdapterCommon,
    IN TopoNodes Node,
    OUT LONG *plMinimum,
    OUT LONG *plMaximum,
    OUT ULONG *puStep
)
{
    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::GetDBValues]"));
    
    // This is going to be simple. Check the node and return the parameters.
    switch (Node)
    {
        // These nodes could have 5bit or 6bit controls, so we first
        // have to check this.
        case NODE_MASTEROUT_VOLUME:
        case NODE_FRONT_VOLUME:
        case NODE_HPOUT_VOLUME:
        case NODE_SURROUND_VOLUME:
        case NODE_CENTER_VOLUME:
        case NODE_LFE_VOLUME:
        case NODE_VIRT_MONOOUT_VOLUME1:
        case NODE_VIRT_MONOOUT_VOLUME2:
            // needed for the config query
            TopoNodeConfig  config;

            // which node to query?
            config = NODEC_6BIT_MONOOUT_VOLUME;
            if ((Node == NODE_MASTEROUT_VOLUME) || (Node == NODE_FRONT_VOLUME))
                config = NODEC_6BIT_MASTER_VOLUME;
            if (Node == NODE_HPOUT_VOLUME)
                config = NODEC_6BIT_HPOUT_VOLUME;
            if (Node == NODE_SURROUND_VOLUME)
                config = NODEC_6BIT_SURROUND_VOLUME;
            if ((Node == NODE_CENTER_VOLUME) || (Node == NODE_LFE_VOLUME))
                config = NODEC_6BIT_CENTER_LFE_VOLUME;

            // check if we have 6th bit support.
            if (AdapterCommon->GetNodeConfig (config))
            {
                // 6bit control
                *plMaximum = 0;            // 0 dB
                *plMinimum = 0xFFA18000;   // -94.5 dB
                *puStep    = 0x00018000;   // 1.5 dB
            }
            else
            {
                // 5bit control
                *plMaximum = 0;            // 0 dB
                *plMinimum = 0xFFD18000;   // -46.5 dB
                *puStep    = 0x00018000;   // 1.5 dB
            }
            break;

        case NODE_VIRT_MASTERMONO_VOLUME:
            // This virtual control gets added to the speaker volumes.
            // We assume 5-bit volumes.
            *plMaximum = 0;            // 0 dB
            *plMinimum = 0xFFD18000;   // -46.5 dB
            *puStep    = 0x00018000;   // 1.5 dB
            break;

        case NODE_PCBEEP_VOLUME:
            *plMaximum = 0;            // 0 dB
            *plMinimum = 0xFFD30000;   // -45 dB
            *puStep    = 0x00030000;   // 3 dB
            break;

        case NODE_PHONE_VOLUME:
        case NODE_MICIN_VOLUME:
        case NODE_LINEIN_VOLUME:
        case NODE_CD_VOLUME:
        case NODE_VIDEO_VOLUME:
        case NODE_AUX_VOLUME:
        case NODE_WAVEOUT_VOLUME:
            *plMaximum = 0x000C0000;   // 12 dB
            *plMinimum = 0xFFDD8000;   // -34.5 dB
            *puStep    = 0x00018000;   // 1.5 dB
            break;

    
        case NODE_VIRT_MASTER_INPUT_VOLUME1:
        case NODE_VIRT_MASTER_INPUT_VOLUME2:
        case NODE_VIRT_MASTER_INPUT_VOLUME3:
        case NODE_VIRT_MASTER_INPUT_VOLUME4:
        case NODE_VIRT_MASTER_INPUT_VOLUME5:
        case NODE_VIRT_MASTER_INPUT_VOLUME6:
        case NODE_VIRT_MASTER_INPUT_VOLUME7:
        case NODE_VIRT_MASTER_INPUT_VOLUME8:
        case NODE_MIC_VOLUME:
            *plMaximum = 0x00168000;   // 22.5 dB
            *plMinimum = 0;            // 0 dB
            *puStep    = 0x00018000;   // 1.5 dB
            break;

        case NODE_BASS:
        case NODE_TREBLE:
            *plMaximum = 0x000A8000;   // 10.5 dB
            *plMinimum = 0xFFF58000;   // -10.5 dB
            *puStep    = 0x00018000;   // 1.5 dB
            break;

        // These nodes can be fixed or variable.
        // Normally we won't display a fixed volume slider, but if 3D is
        // supported and both sliders are fixed, we have to display one fixed
        // slider for the advanced control panel.
        case NODE_VIRT_3D_CENTER:
        case NODE_VIRT_3D_DEPTH:
            if (AdapterCommon->GetNodeConfig (NODEC_3D_CENTER_ADJUSTABLE) &&
               (Node == NODE_VIRT_3D_CENTER))
            {
                *plMaximum = 0x000F0000;   // +15 dB
                *plMinimum = 0x00000000;   // 0 dB
                *puStep    = 0x00010000;   // 1 dB
            }
            else
            if (AdapterCommon->GetNodeConfig (NODEC_3D_DEPTH_ADJUSTABLE) &&
               (Node == NODE_VIRT_3D_DEPTH))
            {
                *plMaximum = 0x000F0000;   // +15 dB
                *plMinimum = 0x00000000;   // 0 dB
                *puStep    = 0x00010000;   // 1 dB
            }
            else
            {
                // In case it is fixed, read the value and return it.
                WORD wRegister;

                // read the register
                if (!NT_SUCCESS (AdapterCommon->ReadCodecRegister (
                            AdapterCommon->GetNodeReg (Node), &wRegister)))
                    wRegister = 0;      // in case we fail.

                // mask out the control
                wRegister &= AdapterCommon->GetNodeMask (Node);
                if (Node == NODE_VIRT_3D_CENTER)
                {
                    wRegister >>= 8;
                }
                // calculate the dB value.
                *plMaximum = (DWORD)(-wRegister) << 16;    // fixed value
                *plMinimum = (DWORD)(-wRegister) << 16;    // fixed value
                *puStep    = 0x00010000;   // 1 dB
            }
            break;

        case NODE_INVALID:
        default:
            // poeser pupe, tu.
            DOUT (DBG_ERROR, ("GetDBValues: Invalid node requested."));
            return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}
 
/*****************************************************************************
 * CMiniportTopologyICH::PropertyHandler_OnOff
 *****************************************************************************
 * Accesses a KSAUDIO_ONOFF value property.
 * This function (property handler) is called by portcls every time there is a
 * get or a set request for the node. The connection between the node type and
 * the property handler is made in the automation table which is referenced
 * when you register the node.
 * We use this property handler for all nodes that have a checkbox, means mute
 * controls and the special checkbox controls under advanced properties, which
 * are AGC and LOUDNESS.
 */
NTSTATUS CMiniportTopologyICH::PropertyHandler_OnOff
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE ();

    ASSERT (PropertyRequest);

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    LONG            channel;
    TopoNodes       NodeDef;
    // The major target is the object pointer to the topology miniport.
    CMiniportTopologyICH *that =
        (CMiniportTopologyICH *) PropertyRequest->MajorTarget;

    ASSERT (that);

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::PropertyHandler_OnOff]"));

    // validate node
    if (PropertyRequest->Node == (ULONG)-1)
        return ntStatus;

    // do the appropriate action for the request.

    // we should do a get or a set?
    if ((PropertyRequest->Verb & KSPROPERTY_TYPE_GET) ||
        (PropertyRequest->Verb & KSPROPERTY_TYPE_SET))
    {
        // validate parameters
        if ((PropertyRequest->InstanceSize < sizeof(LONG)) ||
            (PropertyRequest->ValueSize < sizeof(BOOL)))
            return ntStatus;

        // get channel
        channel = *(PLONG)PropertyRequest->Instance;

        // check channel types, return when unknown
        // as you can see, we have no multichannel support.
        if ((channel != CHAN_LEFT) &&
            (channel != CHAN_RIGHT) &&
            (channel != CHAN_MASTER))
            return ntStatus;

        // We have only mono mutes or On/Off checkboxes although they might control
        // a stereo path. For example, we have a 1-bit mute for CD Volume. This
        // mute controls both CD Volume channels.
        if (channel == CHAN_RIGHT)
            return ntStatus;
        
        // get the buffer
        PBOOL OnOff = (PBOOL)PropertyRequest->Value;

        // Switch on the node id. This is just for parameter checking.
        // If something goes wrong, we will immediately return with
        // ntStatus, which is STATUS_INVALID_PARAMETER.
        switch (NodeDef = that->TransNodeNrToNodeDef (PropertyRequest->Node))
        {
            // These are mutes for mono volumes.
            case NODE_PCBEEP_MUTE:
            case NODE_PHONE_MUTE:
            case NODE_MIC_MUTE:
            case NODE_MICIN_MUTE:
            case NODE_CENTER_MUTE:
            case NODE_LFE_MUTE:
            case NODE_VIRT_MASTERMONO_MUTE:
                // check type
                if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AUDIO_MUTE)
                    return ntStatus;
                break;

            // Well, this one is a AGC, although there is no _automatic_ gain
            // control, but we have a mic boost (which is some kind of manual
            // gain control).
            // The 3D Bypass is a real fake, but that's how you get check boxes
            // on the advanced control panel.
            // Both controls are in a mono path.
            case NODE_VIRT_WAVEOUT_3D_BYPASS:
            case NODE_MIC_BOOST:
                // check type
                if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AUDIO_AGC)
                    return ntStatus;
                break;

            // Simulated Stereo is a AGC control in a stereo path.
            case NODE_SIMUL_STEREO:
                // check type
                if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AUDIO_AGC)
                    return ntStatus;
                break;

            // This is a loudness control in a stereo path. We have to check the
            // type.
            case NODE_LOUDNESS:
                // check type
                if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AUDIO_LOUDNESS)
                    return ntStatus;
                break;

            // For 3D Enable and Mic are exposed as loudness in a mono path.
            case NODE_VIRT_3D_ENABLE:
            case NODE_MIC_SELECT:
                // check type
                if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AUDIO_LOUDNESS)
                    return ntStatus;
                break;

            // These are mutes in a stereo path.
            // Because the HW has only one mute-bit for the stereo channel, we
            // expose the mute as mono. this works in current OS and hopefully
            // will work in future OS.
            case NODE_WAVEOUT_MUTE:
            case NODE_LINEIN_MUTE:
            case NODE_CD_MUTE:
            case NODE_VIDEO_MUTE:
            case NODE_AUX_MUTE:
            case NODE_MASTEROUT_MUTE:
            case NODE_FRONT_MUTE:
            case NODE_SURROUND_MUTE:
            case NODE_HPOUT_MUTE:
                // just check the type.
                if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AUDIO_MUTE)
                    return ntStatus;
                break;

            case NODE_INVALID:
            default:
                // Ooops.
                DOUT (DBG_ERROR, ("PropertyHandler_OnOff: Invalid node requested."));
                return ntStatus;
        }

        // Now, do some action!

        if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            WORD    wRegister;

            // Read the HW register for the node except NODE_VIRT_MASTERMONO_MUTE,
            // since this is pure virtual.
            if (NodeDef != NODE_VIRT_MASTERMONO_MUTE)
            {
                // get the register and read it.
                ntStatus = that->AdapterCommon->ReadCodecRegister (
                        that->AdapterCommon->GetNodeReg (NodeDef), &wRegister);
                if (!NT_SUCCESS (ntStatus))
                    return ntStatus;
                // Mask out every unused bit.
                wRegister &= that->AdapterCommon->GetNodeMask (NodeDef);
                // Store the value.
                *OnOff = wRegister ? TRUE : FALSE;
            }
            else
            {
                // Assume no mute for master mono.
                *OnOff = FALSE;
            }

            // When we have cache information then return this instead of the
            // calculated value. If we don't, store the calculated value.
            if (that->stNodeCache[NodeDef].bLeftValid)
                *OnOff = that->stNodeCache[NodeDef].lLeft;
            else
            {
                that->stNodeCache[NodeDef].lLeft = *OnOff;
                that->stNodeCache[NodeDef].bLeftValid = -1;
            }
            
            PropertyRequest->ValueSize = sizeof(BOOL);
            DOUT (DBG_PROPERTY, ("GET: %s = 0x%x", NodeStrings[NodeDef], *OnOff));
            
            // Set the return code here.
            ntStatus = STATUS_SUCCESS;
        }
        else    // this must be a set.
        {
            // First update the node cache.
            that->stNodeCache[NodeDef].bLeftValid = -1;
            that->stNodeCache[NodeDef].lLeft = (*OnOff) ? TRUE : FALSE;
            
            //
            // If we have a master mono, then we have to program the speaker
            // mutes a little different.
            // Check for master mono (surround or headphone present) and
            // if one of the speaker mutes is requested.
            //
            if ((that->AdapterCommon->GetPinConfig (PINC_SURROUND_PRESENT) ||
                 that->AdapterCommon->GetPinConfig (PINC_HPOUT_PRESENT)) &&
                ((NodeDef == NODE_VIRT_MASTERMONO_MUTE) || (NodeDef == NODE_LFE_MUTE) ||
                 (NodeDef == NODE_CENTER_MUTE) || (NodeDef == NODE_FRONT_MUTE) ||
                 (NodeDef == NODE_SURROUND_MUTE) || (NodeDef == NODE_HPOUT_MUTE)))
            {
                //
                // For master mono we have to update all speakers.
                //
                if (NodeDef == NODE_VIRT_MASTERMONO_MUTE)
                {
                    // Update all speaker mutes.
                    ntStatus = SetMultichannelMute (that, NODE_FRONT_MUTE);
                    if (that->AdapterCommon->GetPinConfig (PINC_HPOUT_PRESENT))
                        ntStatus = SetMultichannelMute (that, NODE_HPOUT_MUTE);
                    if (that->AdapterCommon->GetPinConfig (PINC_SURROUND_PRESENT))
                        ntStatus = SetMultichannelMute (that, NODE_SURROUND_MUTE);
                    if (that->AdapterCommon->GetPinConfig (PINC_CENTER_LFE_PRESENT))
                    {
                        ntStatus = SetMultichannelMute (that, NODE_CENTER_MUTE);
                        ntStatus = SetMultichannelMute (that, NODE_LFE_MUTE);
                    }
                }
                else    // Update the individual speaker mute.
                {
                    ntStatus = SetMultichannelMute (that, NodeDef);
                }
            }
            else
            {
                //
                // For all other mutes/checkboxes just write the value to the HW.
                //
                ntStatus = that->AdapterCommon->WriteCodecRegister (
                        that->AdapterCommon->GetNodeReg (NodeDef),
                        (*OnOff) ? -1 : 0,
                        that->AdapterCommon->GetNodeMask (NodeDef));
            }

            DOUT (DBG_PROPERTY, ("SET: %s -> 0x%x", NodeStrings[NodeDef], *OnOff));

            // ntStatus was set with the write call! whatever this is, return it.
        }
    }
    
    return ntStatus;
}

/*****************************************************************************
 * CMiniportTopologyICH::BasicSupportHandler
 *****************************************************************************
 * Assists in BASICSUPPORT accesses on level properties.
 * This function is called internally every time there is a "basic support"
 * request on a volume or tone control. The basic support is used to retrieve
 * some information about the range of the control (from - to dB, steps) and
 * which type of control (tone, volume).
 * Basically, this function just calls GetDBValues to get the range information
 * and fills the rest of the structure with some constants.
 */
NTSTATUS CMiniportTopologyICH::BasicSupportHandler
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE ();

    ASSERT (PropertyRequest);

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::BasicSupportHandler]"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    // The major target is the object pointer to the topology miniport.
    CMiniportTopologyICH *that =
        (CMiniportTopologyICH *) PropertyRequest->MajorTarget;

    ASSERT (that);


    // if there is enough space for a KSPROPERTY_DESCRIPTION information
    if (PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
    {
        // we return a KSPROPERTY_DESCRIPTION structure.
        PKSPROPERTY_DESCRIPTION PropDesc = (PKSPROPERTY_DESCRIPTION)PropertyRequest->Value;

        PropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                KSPROPERTY_TYPE_GET |
                                KSPROPERTY_TYPE_SET;
        PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION) +
                                      sizeof(KSPROPERTY_MEMBERSHEADER) +
                                      sizeof(KSPROPERTY_STEPPING_LONG);
        PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        PropDesc->PropTypeSet.Id    = VT_I4;
        PropDesc->PropTypeSet.Flags = 0;
        PropDesc->MembersListCount  = 1;
        PropDesc->Reserved          = 0;

        // if return buffer can also hold a range description, return it too
        if (PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION) +
            sizeof(KSPROPERTY_MEMBERSHEADER) + sizeof(KSPROPERTY_STEPPING_LONG)))
        {
            // fill in the members header
            PKSPROPERTY_MEMBERSHEADER Members = (PKSPROPERTY_MEMBERSHEADER)(PropDesc + 1);

            Members->MembersFlags   = KSPROPERTY_MEMBER_STEPPEDRANGES;
            Members->MembersSize    = sizeof(KSPROPERTY_STEPPING_LONG);
            Members->MembersCount   = 1;
            Members->Flags          = 0;

            // fill in the stepped range
            PKSPROPERTY_STEPPING_LONG Range = (PKSPROPERTY_STEPPING_LONG)(Members + 1);

            ntStatus = GetDBValues (that->AdapterCommon,
                                    that->TransNodeNrToNodeDef (PropertyRequest->Node),
                                    &Range->Bounds.SignedMinimum,
                                    &Range->Bounds.SignedMaximum,
                                    &Range->SteppingDelta);

            Range->Reserved         = 0;

            // set the return value size
            PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION) +
                                         sizeof(KSPROPERTY_MEMBERSHEADER) +
                                         sizeof(KSPROPERTY_STEPPING_LONG);

            DOUT (DBG_PROPERTY, ("BASIC_SUPPORT: %s max=0x%x min=0x%x step=0x%x",
                NodeStrings[that->TransNodeNrToNodeDef (PropertyRequest->Node)],
                Range->Bounds.SignedMaximum, Range->Bounds.SignedMinimum,
                Range->SteppingDelta));
        } else
        {
            // we hadn't enough space for the range information; 
            // set the return value size
            PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
        }

        ntStatus = STATUS_SUCCESS;
    }
    else if (PropertyRequest->ValueSize >= sizeof(ULONG))
    {
        // if return buffer can hold a ULONG, return the access flags
        PULONG AccessFlags = (PULONG)PropertyRequest->Value;

        *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                       KSPROPERTY_TYPE_GET |
                       KSPROPERTY_TYPE_SET;

        // set the return value size
        PropertyRequest->ValueSize = sizeof(ULONG);
        ntStatus = STATUS_SUCCESS;
    }

    // In case there was not even enough space for a ULONG in the return buffer,
    // we fail this request with STATUS_INVALID_DEVICE_REQUEST.
    // Any other case will return STATUS_SUCCESS.
    return ntStatus;
}

/*****************************************************************************
 * CMiniportTopologyICH::PropertyHandler_Level
 *****************************************************************************
 * Accesses a KSAUDIO_LEVEL property.
 * This function (property handler) is called by portcls every time there is a
 * get, set or basic support request for the node. The connection between the
 * node type and the property handler is made in the automation table which is
 * referenced when you register the node.
 * We use this property handler for all volume controls (and virtual volume
 * controls for recording).
 */
NTSTATUS CMiniportTopologyICH::PropertyHandler_Level
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE ();

    ASSERT (PropertyRequest);

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::PropertyHandler_Level]"));

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    TopoNodes       NodeDef;
    LONG            channel;
    LONG            lMinimum, lMaximum;
    ULONG           uStep;
    // The major target is the object pointer to the topology miniport.
    CMiniportTopologyICH *that =
        (CMiniportTopologyICH *) PropertyRequest->MajorTarget;

    ASSERT (that);

    // validate node
    if (PropertyRequest->Node == (ULONG)-1)
        return ntStatus;

    // do the appropriate action for the request.

    // we should do a get or a set?
    if ((PropertyRequest->Verb & KSPROPERTY_TYPE_GET) ||
        (PropertyRequest->Verb & KSPROPERTY_TYPE_SET))
    {
        // validate parameters
        if ((PropertyRequest->InstanceSize < sizeof(LONG)) ||
            (PropertyRequest->ValueSize < sizeof(LONG)))
            return ntStatus;

        // get channel information
        channel = *((PLONG)PropertyRequest->Instance);

        // check channel types, return when unknown
        // as you can see, we have no multichannel support.
        if ((channel != CHAN_LEFT) &&
            (channel != CHAN_RIGHT) &&
            (channel != CHAN_MASTER))
            return ntStatus;

        // get the buffer
        PLONG Level = (PLONG)PropertyRequest->Value;

        // Switch on the node id. This is just for parameter checking.
        // If something goes wrong, we will immideately return with
        // ntStatus, which is STATUS_INVALID_PARAMETER.
        switch(NodeDef = that->TransNodeNrToNodeDef (PropertyRequest->Node))
        {
            // these are mono channels, don't respond to a right channel
            // request.
            case NODE_PCBEEP_VOLUME:
            case NODE_PHONE_VOLUME:
            case NODE_MIC_VOLUME:
            case NODE_VIRT_MONOOUT_VOLUME1:
            case NODE_VIRT_MONOOUT_VOLUME2:
            case NODE_VIRT_MASTER_INPUT_VOLUME1:
            case NODE_VIRT_MASTER_INPUT_VOLUME7:
            case NODE_VIRT_MASTER_INPUT_VOLUME8:
            case NODE_MICIN_VOLUME:
            case NODE_VIRT_MASTERMONO_VOLUME:
            case NODE_CENTER_VOLUME:
            case NODE_LFE_VOLUME:
                // check type
                if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AUDIO_VOLUMELEVEL)
                    return ntStatus;
                // check channel
                if (channel == CHAN_RIGHT)
                    return ntStatus;
                // Well, this is a fake for the routine below that should work
                // for all nodes ... On AC97 the right channel are the LSBs and
                // mono channels have only LSBs used. Windows however thinks that
                // mono channels are left channels (only). So we could say here
                // we have a right channel request (to prg. the LSBs) instead of
                // a left channel request. But we have some controls that are HW-
                // stereo, but exposed to the system as mono. These are the virtual
                // volume controls in front of the wave-in muxer for the MIC, PHONE
                // and MONO MIX signals (see to the switch:
                // NODE_VIRT_MASTER_INPUT_VOLUME1, 7 and 8). Saying we have a MASTER
                // request makes sure the value is prg. for left and right channel,
                // but on HW-mono controls the right channel is prg. only, cause the
                // mask in ac97reg.h leads to a 0-mask for left channel prg. which
                // just does nothing ;)
                channel = CHAN_MASTER;
                break;
            
            // These are stereo channels.
            case NODE_MASTEROUT_VOLUME:
            case NODE_FRONT_VOLUME:
            case NODE_SURROUND_VOLUME:
            case NODE_HPOUT_VOLUME:
            case NODE_LINEIN_VOLUME:
            case NODE_CD_VOLUME:
            case NODE_VIDEO_VOLUME:
            case NODE_AUX_VOLUME:
            case NODE_WAVEOUT_VOLUME:
            case NODE_VIRT_MASTER_INPUT_VOLUME2:
            case NODE_VIRT_MASTER_INPUT_VOLUME3:
            case NODE_VIRT_MASTER_INPUT_VOLUME4:
            case NODE_VIRT_MASTER_INPUT_VOLUME5:
            case NODE_VIRT_MASTER_INPUT_VOLUME6:
                // check type
                if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AUDIO_VOLUMELEVEL)
                    return ntStatus;
                // check channel; we don't support a get with master
                if ((channel == CHAN_MASTER) &&
                    (PropertyRequest->Verb & KSPROPERTY_TYPE_GET))
                    return ntStatus;
                break;

            case NODE_INVALID:
            default:
                // Ooops
                DOUT (DBG_ERROR, ("PropertyHandler_Level: Invalid node requested."));
                return ntStatus;
        }

        // Now, do some action!

        // get the registered dB values.
        ntStatus = GetDBValues (that->AdapterCommon, NodeDef, &lMinimum,
                                &lMaximum, &uStep);
        if (!NT_SUCCESS (ntStatus))
            return ntStatus;

        // do a get
        if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            WORD    wRegister;

            // Read the HW register for the node except NODE_VIRT_MASTERMONO_VOLUME
            // since this is pure virtual.
            if (NodeDef != NODE_VIRT_MASTERMONO_VOLUME)
            {
                // Get the register and read it.
                ntStatus = that->AdapterCommon->ReadCodecRegister (
                        that->AdapterCommon->GetNodeReg (NodeDef), &wRegister);
                if (!NT_SUCCESS (ntStatus))
                    return ntStatus;
                
                // mask out every unused bit and rotate.
                if (channel == CHAN_LEFT)
                {
                    wRegister = (wRegister & (that->AdapterCommon->GetNodeMask (NodeDef)
                                & AC97REG_MASK_LEFT)) >> 8;
                }
                else    // here goes mono or stereo-right
                {
                    wRegister &= (that->AdapterCommon->GetNodeMask (NodeDef) &
                                  AC97REG_MASK_RIGHT);
                }
            
                // Oops - NODE_PCBEEP_VOLUME doesn't use bit0. We have to adjust.
                if (NodeDef == NODE_PCBEEP_VOLUME)
                    wRegister >>= 1;

                // we have to translate the reg to dB.dB value.

                switch (NodeDef)
                {
                    // for record, we calculate it reverse.
                    case NODE_VIRT_MASTER_INPUT_VOLUME1:
                    case NODE_VIRT_MASTER_INPUT_VOLUME2:
                    case NODE_VIRT_MASTER_INPUT_VOLUME3:
                    case NODE_VIRT_MASTER_INPUT_VOLUME4:
                    case NODE_VIRT_MASTER_INPUT_VOLUME5:
                    case NODE_VIRT_MASTER_INPUT_VOLUME6:
                    case NODE_VIRT_MASTER_INPUT_VOLUME7:
                    case NODE_VIRT_MASTER_INPUT_VOLUME8:
                    case NODE_MICIN_VOLUME:
                        *Level = lMinimum + uStep * wRegister;
                        break;
                    default:
                        *Level = lMaximum - uStep * wRegister;
                        break;
                }
                
                // For the virtual controls, which are in front of a muxer, there
                // is no mute control displayed. But we have a HW mute control, so
                // what we do is enabling this mute when the user moves the slider
                // down to the bottom and disabling it on every other position.
                // We will return a PROP_MOST_NEGATIVE value in case the slider
                // is moved to the bottom.
                // We do this only for the "mono muxer" since the volume there ranges
                // from 0 to -46.5dB. The record volumes only have a range from
                // 0 to +22.5dB and we cannot mute them when the slider is down.
                if ((NodeDef == NODE_VIRT_MONOOUT_VOLUME1) ||
                    (NodeDef == NODE_VIRT_MONOOUT_VOLUME2))
                {
                    // read the register again.
                    ntStatus = that->AdapterCommon->ReadCodecRegister (
                               that->AdapterCommon->GetNodeReg (NodeDef), &wRegister);
                    if (!NT_SUCCESS (ntStatus))
                        return ntStatus;
                    // return most negative value in case it is checked.
                    if (wRegister & AC97REG_MASK_MUTE)
                        *Level = PROP_MOST_NEGATIVE;
                }
            }
            else    // This is master mono volume.
            {
                // Assume 0dB for master mono volume.
                *Level = 0;
            }

            // when we have cache information then return this instead
            // of the calculated value. if we don't, store the calculated
            // value.
            // We do that twice for master because in case we didn't set
            // the NodeCache yet it will be set then.
            if ((channel == CHAN_LEFT) || (channel == CHAN_MASTER))
            {
                if (that->stNodeCache[NodeDef].bLeftValid)
                    *Level = that->stNodeCache[NodeDef].lLeft;
                else
                {
                    that->stNodeCache[NodeDef].lLeft = *Level;
                    that->stNodeCache[NodeDef].bLeftValid = -1;
                }
            }

            if ((channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
            {
                if (that->stNodeCache[NodeDef].bRightValid)
                    *Level = that->stNodeCache[NodeDef].lRight;
                else
                {
                    that->stNodeCache[NodeDef].lRight = *Level;
                    that->stNodeCache[NodeDef].bRightValid = -1;
                }
            }

            // thats all, good bye.
            PropertyRequest->ValueSize = sizeof(LONG);
            DOUT (DBG_PROPERTY, ("GET: %s(%s) = 0x%x",NodeStrings[NodeDef],
                    channel==CHAN_LEFT ? "L" : "R", *Level));
            
            // ntStatus was set with the read call! whatever this is, return it.
        }
        else        // this must be a set
        {
            WORD    wRegister;
            LONG    lLevel = *Level;

            //
            // Check borders.
            //
            // These 2 lines will have a special effect on sndvol32.
            // Whenever you move the balance slider on a volume, one channel
            // keeps the same and the other volume channel gets descreased.
            // With ac97 on recording controls, the default slider position
            // is at 0dB and the range of the volume is 0dB till +22.5dB.
            // That means that panning (moving the balance slider) is simply
            // impossible. If you would store the volume like sndvol gives it
            // to you and you return it on a get, then the balance slider
            // moves and stays at the position the user wanted it. However,
            // if you return the actual volume the balance slider will jump
            // back to the position that the HW can do (play with it to see
            // how it works).
            //
            if (lLevel > lMaximum) lLevel = lMaximum;
            if (lLevel < lMinimum) lLevel = lMinimum;
            
            // First update the node cache.
            if ((channel == CHAN_LEFT) || (channel == CHAN_MASTER))
            {
                that->stNodeCache[NodeDef].bLeftValid = -1;
                that->stNodeCache[NodeDef].lLeft = lLevel;
            }
            if ((channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
            {
                that->stNodeCache[NodeDef].bRightValid = -1;
                that->stNodeCache[NodeDef].lRight = lLevel;
            }
            
            //
            // If we have a master mono, then we have to program the speaker
            // volumes a little different.
            // Check for master mono (surround or headphone present) and
            // if one of the speaker volumes is requested.
            //
            if ((that->AdapterCommon->GetPinConfig (PINC_SURROUND_PRESENT) ||
                 that->AdapterCommon->GetPinConfig (PINC_HPOUT_PRESENT)) &&
                ((NodeDef == NODE_VIRT_MASTERMONO_VOLUME) || (NodeDef == NODE_LFE_VOLUME) ||
                 (NodeDef == NODE_CENTER_VOLUME) || (NodeDef == NODE_FRONT_VOLUME) ||
                 (NodeDef == NODE_SURROUND_VOLUME) || (NodeDef == NODE_HPOUT_VOLUME)))
            {
                //
                // For master mono we have to update all speaker volumes.
                //
                if (NodeDef == NODE_VIRT_MASTERMONO_VOLUME)
                {
                    // Update all speaker volumes.
                    ntStatus = SetMultichannelVolume (that, NODE_FRONT_VOLUME);
                    if (that->AdapterCommon->GetPinConfig (PINC_HPOUT_PRESENT))
                        ntStatus = SetMultichannelVolume (that, NODE_HPOUT_VOLUME);
                    if (that->AdapterCommon->GetPinConfig (PINC_SURROUND_PRESENT))
                        ntStatus = SetMultichannelVolume (that, NODE_SURROUND_VOLUME);
                    if (that->AdapterCommon->GetPinConfig (PINC_CENTER_LFE_PRESENT))
                    {
                        ntStatus = SetMultichannelVolume (that, NODE_CENTER_VOLUME);
                        ntStatus = SetMultichannelVolume (that, NODE_LFE_VOLUME);
                    }
                }
                else    // update the individual speaker volume only.
                {
                    ntStatus = SetMultichannelVolume (that, NodeDef);
                }
            }
            else    // This is for all other volumes (or no master mono present).
            {
                // calculate the dB.dB value.

                // The nodes are calculated differently.
                switch (NodeDef)
                {
                    // for record controls we calculate it 'reverse'.
                    case NODE_VIRT_MASTER_INPUT_VOLUME1:
                    case NODE_VIRT_MASTER_INPUT_VOLUME2:
                    case NODE_VIRT_MASTER_INPUT_VOLUME3:
                    case NODE_VIRT_MASTER_INPUT_VOLUME4:
                    case NODE_VIRT_MASTER_INPUT_VOLUME5:
                    case NODE_VIRT_MASTER_INPUT_VOLUME6:
                    case NODE_VIRT_MASTER_INPUT_VOLUME7:
                    case NODE_VIRT_MASTER_INPUT_VOLUME8:
                        // read the wavein selector.
                        ntStatus = that->AdapterCommon->ReadCodecRegister (
                                that->AdapterCommon->GetNodeReg (NODE_WAVEIN_SELECT),
                                &wRegister);
                        if (!NT_SUCCESS (ntStatus))
                            return ntStatus;
    
                        // mask out every unused bit.
                        wRegister &= (that->AdapterCommon->GetNodeMask (
                                NODE_WAVEIN_SELECT) & AC97REG_MASK_RIGHT);
    
                        // check if the volume that we change belongs to the active
                        // (selected) virtual channel.
                        // Tricky: If the virtual nodes are not defined consecutively
                        // this comparision will fail.
                        if ((NodeDef - NODE_VIRT_MASTER_INPUT_VOLUME1) != wRegister)
                            return ntStatus;
                        
                        // fall through for calculation.

                    case NODE_MICIN_VOLUME:
                        wRegister = (WORD)(((lLevel + uStep / 2) - lMinimum) / uStep);
                        break;

                    case NODE_VIRT_MONOOUT_VOLUME1:
                    case NODE_VIRT_MONOOUT_VOLUME2:
                        // read the monoout selector.
                        ntStatus = that->AdapterCommon->ReadCodecRegister (
                                that->AdapterCommon->GetNodeReg (NODE_MONOOUT_SELECT),
                                &wRegister);
                        if (!NT_SUCCESS (ntStatus))
                            return ntStatus;
    
                        // mask out every unused bit.
                        wRegister &= that->AdapterCommon->GetNodeMask (NODE_MONOOUT_SELECT);
    
                        // check if the volume that we change belongs to the active
                        // (selected) virtual channel.
                        // Note: Monout select is set if we want to prg. MIC (Volume2).
                        if ((!wRegister && (NodeDef == NODE_VIRT_MONOOUT_VOLUME2)) ||
                            (wRegister && (NodeDef == NODE_VIRT_MONOOUT_VOLUME1)))
                            return ntStatus;
                    
                        // fall through for calculation.
                    default:
                        wRegister = (WORD)(((lMaximum + uStep / 2) - lLevel) / uStep);
                        break;
                }

                // Oops - NODE_PCBEEP_VOLUME doesn't use bit0. We have to adjust.
                if (NodeDef == NODE_PCBEEP_VOLUME)
                    wRegister <<= 1;
    
                // write the stuff (with mask!).
                // Note: mono channels are 'master' here (see fake above).
                // this makes sure that left and right channel is prg. for the virt.
                // controls. On controls that only have the right channel, the left
                // channel programming does nothing cause the mask will be zero.
                if ((channel == CHAN_LEFT) || (channel == CHAN_MASTER))
                {
                    // write only left.
                    ntStatus = that->AdapterCommon->WriteCodecRegister (
                        that->AdapterCommon->GetNodeReg (NodeDef),
                        wRegister << 8,
                        that->AdapterCommon->GetNodeMask (NodeDef) & AC97REG_MASK_LEFT);
                    // immediately return on error
                    if (!NT_SUCCESS (ntStatus))
                        return ntStatus;
                }
    
                if ((channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
                {
                    // write only right.
                    ntStatus = that->AdapterCommon->WriteCodecRegister (
                        that->AdapterCommon->GetNodeReg (NodeDef),
                        wRegister,
                        that->AdapterCommon->GetNodeMask (NodeDef) & AC97REG_MASK_RIGHT);
                    // immediately return on error
                    if (!NT_SUCCESS (ntStatus))
                        return ntStatus;
                }

                // For the virtual controls, which are in front of a muxer, there
                // is no mute control displayed. But we have a HW mute control, so
                // what we do is enabling this mute when the user moves the slider
                // down to the bottom and disabling it on every other position.
                // We do this only for the "mono muxer", the recording mutes will
                // never be muted.
                // Tricky: Master input virtual controls must be defined consecutively.
                if ((NodeDef >= NODE_VIRT_MASTER_INPUT_VOLUME1) &&
                    (NodeDef <= NODE_VIRT_MASTER_INPUT_VOLUME8))
                {
                    // disable the mute; this only works because the mute and volume
                    // share the same register.
                    ntStatus = that->AdapterCommon->WriteCodecRegister (
                        that->AdapterCommon->GetNodeReg (NodeDef),
                        0, AC97REG_MASK_MUTE);
    
                    // Just in case.
                    that->UpdateRecordMute ();
                }

                if ((NodeDef == NODE_VIRT_MONOOUT_VOLUME1) ||
                    (NodeDef == NODE_VIRT_MONOOUT_VOLUME2))
                {
                    // these are only mono controls so checking one entry is enough.
                    if ( that->stNodeCache[NodeDef].bLeftValid &&
                        (that->stNodeCache[NodeDef].lLeft <= lMinimum))
                    {
                        // set the mute; this only works because the mute and volume
                        // share the same register.
                        ntStatus = that->AdapterCommon->WriteCodecRegister (
                            that->AdapterCommon->GetNodeReg (NodeDef),
                            AC97REG_MASK_MUTE, AC97REG_MASK_MUTE);
                    }
                    else
                    {
                        // clear the mute; this only works because the mute and volume
                        // share the same register.
                        ntStatus = that->AdapterCommon->WriteCodecRegister (
                            that->AdapterCommon->GetNodeReg (NodeDef),
                            0, AC97REG_MASK_MUTE);
                    }
                }
            }
            
            DOUT (DBG_PROPERTY, ("SET: %s(%s) -> 0x%x", NodeStrings[NodeDef],
                    channel==CHAN_LEFT ? "L" : channel==CHAN_RIGHT ? "R" : "M",
                    *Level));
            
            // ntStatus was set with the read call! whatever this is, return it.
        }
    }
    else
    {
        if (PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            ntStatus = BasicSupportHandler (PropertyRequest);
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportTopologyICH::PropertyHandler_Tone
 *****************************************************************************
 * Accesses a KSAUDIO_TONE property.
 * This function (property handler) is called by portcls every time there is a
 * get, set or basic support request for the node. The connection between the
 * node type and the property handler is made in the automation table which is
 * referenced when you register the node.
 * We use this property handler for all tone controls displayed at the advanced
 * property dialog in sndvol32 and the 3D controls displayed and exposed as
 * normal volume controls.
 */
NTSTATUS CMiniportTopologyICH::PropertyHandler_Tone
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE ();

    ASSERT (PropertyRequest);

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::PropertyHandler_Tone]"));

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    TopoNodes       NodeDef;
    LONG            lMinimum, lMaximum;
    ULONG           uStep;
     // The major target is the object pointer to the topology miniport.
   CMiniportTopologyICH *that =
        (CMiniportTopologyICH *) PropertyRequest->MajorTarget;

    ASSERT (that);

    // validate node
    if (PropertyRequest->Node == (ULONG)-1)
        return ntStatus;

    // do the appropriate action for the request.

    // we should do a get or a set?
    if ((PropertyRequest->Verb & KSPROPERTY_TYPE_GET) ||
        (PropertyRequest->Verb & KSPROPERTY_TYPE_SET))
    {
        // validate parameters
        if ((PropertyRequest->InstanceSize < sizeof(LONG)) ||
            (PropertyRequest->ValueSize < sizeof(LONG)))
            return ntStatus;

        // get the buffer
        PLONG Level = (PLONG)PropertyRequest->Value;

        // Switch on the node id. This is just for parameter checking.
        // If something goes wrong, we will immideately return with
        // ntStatus, which is STATUS_INVALID_PARAMETER.
        switch(NodeDef = that->TransNodeNrToNodeDef (PropertyRequest->Node))
        {
            case NODE_BASS:
                // check type.
                if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AUDIO_BASS)
                    return ntStatus;
                break;

            case NODE_TREBLE:
                // check type.
                if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AUDIO_TREBLE)
                    return ntStatus;
                break;

            case NODE_VIRT_3D_CENTER:
            case NODE_VIRT_3D_DEPTH:
                // check 3D control
                if (!that->AdapterCommon->GetNodeConfig (NODEC_3D_CENTER_ADJUSTABLE)
                    && (NodeDef == NODE_VIRT_3D_CENTER))
                    return ntStatus;
                if (!that->AdapterCommon->GetNodeConfig (NODEC_3D_DEPTH_ADJUSTABLE)
                    && (NodeDef == NODE_VIRT_3D_DEPTH))
                    return ntStatus;
                // check type
                if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AUDIO_VOLUMELEVEL)
                    return ntStatus;
                // check channel
                if (*(PLONG(PropertyRequest->Instance)) == CHAN_RIGHT)
                    return ntStatus;
                break;
            
            case NODE_INVALID:
            default:
                // Ooops
                DOUT (DBG_ERROR, ("PropertyHandler_Tone: Invalid node requested."));
                return ntStatus;
        }

        // Now, do some action!

        // get the registered DB values
        ntStatus = GetDBValues (that->AdapterCommon, NodeDef, &lMinimum,
                                &lMaximum, &uStep);
        if (!NT_SUCCESS (ntStatus))
            return ntStatus;

        // do a get
        if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            WORD    wRegister;

            // first get the stuff.
            ntStatus = that->AdapterCommon->ReadCodecRegister (
                    that->AdapterCommon->GetNodeReg (NodeDef), &wRegister);
            if (!NT_SUCCESS (ntStatus))
                return ntStatus;

            // mask out every unused bit.
            wRegister &= that->AdapterCommon->GetNodeMask (NodeDef);

            // rotate if bass tone control or 3D center control
            if ((NodeDef == NODE_BASS) || (NodeDef == NODE_VIRT_3D_CENTER))
                wRegister >>= 8;

            // convert from reg to dB.dB value.
            if ((NodeDef == NODE_VIRT_3D_CENTER) ||
                (NodeDef == NODE_VIRT_3D_DEPTH))
            {
                // That's for the 3D controls
                *Level = lMinimum + uStep * wRegister;
            }
            else
            {
                if (wRegister == 0x000F)
                    *Level = 0;     // bypass
                else
                    // And that's for the tone controls
                    *Level = lMaximum - uStep * wRegister;
            }
            
            // when we have cache information then return this instead
            // of the calculated value. if we don't, store the calculated
            // value.
            if (that->stNodeCache[NodeDef].bLeftValid)
                *Level = that->stNodeCache[NodeDef].lLeft;
            else
            {
                that->stNodeCache[NodeDef].lLeft = *Level;
                that->stNodeCache[NodeDef].bLeftValid = -1;
            }

            // we return a LONG
            PropertyRequest->ValueSize = sizeof(LONG);
            DOUT (DBG_PROPERTY, ("GET: %s = 0x%x", NodeStrings[NodeDef], *Level));
            // ntStatus was set with the read call! whatever this is, return it.
        }
        else        // that must be a set
        {
            WORD    wRegister;
            LONG    lLevel = *Level;

            // calculate the dB.dB value.
            // check borders.
            if (lLevel > lMaximum) lLevel = lMaximum;
            if (lLevel < lMinimum) lLevel = lMinimum;
            
            // write the value to the node cache.
            that->stNodeCache[NodeDef].lLeft = *Level;
            that->stNodeCache[NodeDef].bLeftValid = -1;

            // convert from dB.dB value to reg.
            if ((NodeDef == NODE_VIRT_3D_CENTER) ||
                (NodeDef == NODE_VIRT_3D_DEPTH))
            {
                // For 3D controls
                wRegister = (WORD)(((lLevel + uStep / 2) - lMinimum) / uStep);
            }
            else
            {
                // For tone controls
                wRegister = (WORD)(((lMaximum + uStep / 2) - lLevel) / uStep);
                // We don't prg. 0dB Bass or 0dB Treble, instead we smartly prg.
                // a bypass which is reg. value 0x0F.
                if (wRegister == 7)             // 0 dB
                    wRegister = 0x000F;         // bypass
            }

            // rotate if bass tone control or 3D center control
            if ((NodeDef == NODE_BASS) || (NodeDef == NODE_VIRT_3D_CENTER))
                wRegister <<= 8;

            // write the stuff.
            ntStatus = that->AdapterCommon->WriteCodecRegister (
                    that->AdapterCommon->GetNodeReg (NodeDef),
                    wRegister,
                    that->AdapterCommon->GetNodeMask (NodeDef));

            DOUT (DBG_PROPERTY,("SET: %s -> 0x%x", NodeStrings[NodeDef], *Level));
            // ntStatus was set with the write call! whatever this is, return in.
        }
    }
    else
    {
        if (PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            ntStatus = BasicSupportHandler (PropertyRequest);
        }
    }

    return ntStatus;
}
            
/*****************************************************************************
 * CMiniportTopologyICH::PropertyHandler_Ulong
 *****************************************************************************
 * Accesses a ULONG value property. For MUX and DEMUX.
 * This function (property handler) is called by portcls every time there is a
 * get, set or basic support request for the node. The connection between the
 * node type and the property handler is made in the automation table which is
 * referenced when you register the node.
 * We use this property handler for all muxer controls.
 */
NTSTATUS CMiniportTopologyICH::PropertyHandler_Ulong
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE ();

    ASSERT (PropertyRequest);

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::PropertyHandler_Ulong]"));

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    TopoNodes       NodeDef;
    LONG            lMinimum, lMaximum;
    ULONG           uStep;
    // The major target is the object pointer to the topology miniport.
    CMiniportTopologyICH *that =
        (CMiniportTopologyICH *) PropertyRequest->MajorTarget;

    ASSERT (that);


    // validate node instance
    if (PropertyRequest->Node == (ULONG)-1)
        return ntStatus;

    // if we should do a get or set.
    if ((PropertyRequest->Verb & KSPROPERTY_TYPE_GET) ||
        (PropertyRequest->Verb & KSPROPERTY_TYPE_SET))
    {
        // validate buffer size.
        if (PropertyRequest->ValueSize < sizeof(ULONG))
            return ntStatus;

        // get the pointer to the buffer.
        PULONG PropValue = (PULONG)PropertyRequest->Value;

        // Switch on the node id. This is just for parameter checking.
        // If something goes wrong, we will immideately return with
        // ntStatus, which is STATUS_INVALID_PARAMETER.
        switch(NodeDef = that->TransNodeNrToNodeDef (PropertyRequest->Node))
        {
            case NODE_MONOOUT_SELECT:
            case NODE_WAVEIN_SELECT:
                // check the type
                if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AUDIO_MUX_SOURCE)
                    return ntStatus;
                break;
                
            case NODE_INVALID:
            default:
                // Ooops
                DOUT (DBG_ERROR, ("PropertyHandler_Tone: Invalid node requested."));
                return ntStatus;
        }

        // Now do some action!

        // should we return the value?
        if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            WORD    wRegister;

            // first get the stuff.
            ntStatus = that->AdapterCommon->ReadCodecRegister (
                    that->AdapterCommon->GetNodeReg (NodeDef), &wRegister);
            if (!NT_SUCCESS (ntStatus))
                return ntStatus;

            // mask out every unused bit.
            wRegister &= that->AdapterCommon->GetNodeMask (NodeDef);

            // calculate the selected pin
            if (NodeDef == NODE_MONOOUT_SELECT)
            {
                // for mono out we have just one bit
                if (wRegister)
                    *PropValue = 2;
                else
                    *PropValue = 1;
            }
            else
            {
                // the wave in muxer is a stereo muxer, so just return the
                // right channel (gives values 0-7) and adjust it by adding 1.
                *PropValue = (wRegister & AC97REG_MASK_RIGHT) + 1;
            }

            // we return a LONG
            PropertyRequest->ValueSize = sizeof(LONG);
            DOUT (DBG_PROPERTY, ("GET: %s = 0x%x", NodeStrings[NodeDef],
                    *PropValue));
            // ntStatus was set with the read call! whatever this is, return it.
        }
        else        // that must be a set
        {
            TopoNodes   VirtNode;
            WORD        wRegister;
            ULONG       ulSelect = *PropValue;
            LONG        lLevel;

            // Check the selection first.
            if (NodeDef == NODE_MONOOUT_SELECT)
            {
                if ((ulSelect < 1) || (ulSelect > 2))
                    return ntStatus;    // STATUS_INVALID_PARAMETER
            }
            else
            {
                if ((ulSelect < 1) || (ulSelect > 8))
                    return ntStatus;    // STATUS_INVALID_PARAMETER
            }

            // calculate the register value for programming.
            if (NodeDef == NODE_MONOOUT_SELECT)
            {
                // for mono out we have just one bit
                if (ulSelect == 2)
                    // the mask will make sure we only prg. one bit.
                    wRegister = -1;
                else
                    // ulSelect == 1
                    wRegister = 0;
            }
            else
            {
                // *257 is the same as: (ulSelect << 8) + ulSelect
                wRegister = (WORD)(ulSelect - 1) * 257;
            }

            // write the stuff.
            ntStatus = that->AdapterCommon->WriteCodecRegister (
                    that->AdapterCommon->GetNodeReg (NodeDef),
                    wRegister,
                    that->AdapterCommon->GetNodeMask (NodeDef));

            // Store the virt. node for later use.
            // Tricky: Master input virtual controls must be defined consecutively.
            if (NodeDef == NODE_MONOOUT_SELECT)
                VirtNode = (TopoNodes)(NODE_VIRT_MONOOUT_VOLUME1 + (ulSelect - 1));
            else
                VirtNode = (TopoNodes)(NODE_VIRT_MASTER_INPUT_VOLUME1 + (ulSelect - 1));

            // Virtual controls make our life more complicated. When the user
            // changes the input source say from CD to LiniIn, then the system just
            // sends a message to the input muxer that the selection changed.
            // Cause we have only one HW register for the input muxer, all volumes
            // displayed for the user are "virtualized", means they are not there,
            // and when the selection changes, we have to prg. the volume of the
            // selected input to the HW register. That's what we do now.
            
            // get the registered DB values
            ntStatus = GetDBValues (that->AdapterCommon, VirtNode,
                                    &lMinimum, &lMaximum, &uStep);
            if (!NT_SUCCESS (ntStatus))
                return ntStatus;

            // We can be lazy here and don't check for mono controls. Reason
            // is that the level handler writes the volume value for mono
            // controls into both the left and right node cache ;))
            
            if (that->stNodeCache[VirtNode].bLeftValid &&
                that->stNodeCache[VirtNode].bRightValid)
            {
                // prg. left channel
                lLevel = that->stNodeCache[VirtNode].lLeft;

                // calculate the dB.dB value.
                if (NodeDef == NODE_MONOOUT_SELECT)
                    wRegister = (WORD)(((lMaximum + uStep / 2) - lLevel) / uStep);
                else
                    wRegister = (WORD)(((lLevel + uStep / 2) - lMinimum) / uStep);

                // write left channel.
                ntStatus = that->AdapterCommon->WriteCodecRegister (
                    that->AdapterCommon->GetNodeReg (VirtNode),
                    wRegister << 8,
                    that->AdapterCommon->GetNodeMask (VirtNode) & AC97REG_MASK_LEFT);

                // prg. right channel
                lLevel = that->stNodeCache[VirtNode].lRight;

                // calculate the dB.dB value.
                if (NodeDef == NODE_MONOOUT_SELECT)
                    wRegister = (WORD)(((lMaximum + uStep / 2) - lLevel) / uStep);
                else
                    wRegister = (WORD)(((lLevel + uStep / 2) - lMinimum) / uStep);

                // write right channel.
                ntStatus = that->AdapterCommon->WriteCodecRegister (
                    that->AdapterCommon->GetNodeReg (VirtNode),
                    wRegister,
                    that->AdapterCommon->GetNodeMask (VirtNode) & AC97REG_MASK_RIGHT);
                
                // For the virtual controls, which are in front of a muxer, there
                // is no mute control displayed. But we have a HW mute control, so
                // what we do is enabling this mute when the user moves the slider
                // down to the bottom and disabling it on every other position.
                // We do this only for the "mono muxer", the recording mutes will
                // never be muted.
                if (NodeDef == NODE_WAVEIN_SELECT)
                {
                    // disable the mute; this only works because the mute and volume
                    // share the same register.
                    ntStatus = that->AdapterCommon->WriteCodecRegister (
                        that->AdapterCommon->GetNodeReg (VirtNode),
                        0, AC97REG_MASK_MUTE);
            
                    that->UpdateRecordMute ();
                }

                if (NodeDef == NODE_MONOOUT_SELECT)
                {
                    // these are only mono controls so checking one entry is enough.
                    if ( that->stNodeCache[VirtNode].bLeftValid &&
                        (that->stNodeCache[VirtNode].lLeft <= lMinimum))
                    {
                        // set the mute; this only works because the mute and volume
                        // share the same register.
                        ntStatus = that->AdapterCommon->WriteCodecRegister (
                            that->AdapterCommon->GetNodeReg (VirtNode),
                            AC97REG_MASK_MUTE, AC97REG_MASK_MUTE);
                    }
                    else
                    {
                        // clear the mute; this only works because the mute and volume
                        // share the same register.
                        ntStatus = that->AdapterCommon->WriteCodecRegister (
                            that->AdapterCommon->GetNodeReg (VirtNode),
                            0, AC97REG_MASK_MUTE);
                    }
                }
            }                
            
            DOUT (DBG_PROPERTY, ("SET: %s -> 0x%x", NodeStrings[NodeDef],
                    *PropValue));
            // ntStatus was set with the write call! whatever this is, return it.
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CMiniportTopologyICH::PropertyHandler_CpuResources
 *****************************************************************************
 * Propcesses a KSPROPERTY_AUDIO_CPU_RESOURCES request
 * This property handler is called by the system for every node and every node
 * must support this property. Basically, this property is for performance
 * monitoring and we just say here that every function we claim to have has HW
 * support (which by the way is true).
 */
NTSTATUS CMiniportTopologyICH::PropertyHandler_CpuResources
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE ();

    ASSERT (PropertyRequest);

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::PropertyHandler_CpuResources]"));

    CMiniportTopologyICH *that =
        (CMiniportTopologyICH *) PropertyRequest->MajorTarget;
    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    ASSERT (that);

    // validate node
    if (PropertyRequest->Node == (ULONG)-1)
        return ntStatus;

    // validate the node def.
    if (that->TransNodeNrToNodeDef (PropertyRequest->Node) == NODE_INVALID)
        return ntStatus;
    
    // we should do a get
    if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
    {
        // just return the flag.
        if (PropertyRequest->ValueSize >= sizeof(LONG))
        {
            *((PLONG)PropertyRequest->Value) = KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU;
            PropertyRequest->ValueSize = sizeof(LONG);
            ntStatus = STATUS_SUCCESS;
        }
        else    // not enough buffer.
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
    }

    return ntStatus;
}

#ifdef INCLUDE_PRIVATE_PROPERTY
/*****************************************************************************
 * CMiniportTopologyICH::PropertyHandler_Private
 *****************************************************************************
 * This is a private property that returns some AC97 codec features.
 * This routine gets called whenever the topology filter gets a property
 * request with KSPROSETPID_Private and KSPROPERTY_AC97_FEATURES set. It is not
 * a node property but a filter property (you don't have to specify a node).
 */
NTSTATUS CMiniportTopologyICH::PropertyHandler_Private
(
    IN      PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE ();

    ASSERT (PropertyRequest);

    DOUT (DBG_PRINT, ("[CMiniportTopologyICH::PropertyHandler_Private]"));

    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    // The major target is the object pointer to the topology miniport.
    CMiniportTopologyICH *that =
        (CMiniportTopologyICH *) PropertyRequest->MajorTarget;


    ASSERT (that);


    // We only have a get defined.
    if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
    {
        // Check the ID ("function" in "group").
        if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AC97_FEATURES)
            return ntStatus;

        // validate buffer size.
        if (PropertyRequest->ValueSize < sizeof (tAC97Features))
            return ntStatus;

        // The "Value" is the out buffer that you pass in DeviceIoControl call.
        tAC97Features *pAC97Features = (tAC97Features *) PropertyRequest->Value;
        
        // Check the buffer.
        if (!pAC97Features)
            return ntStatus;

        //
        // Fill the AC97Features structure.
        //

        // Set the volumes.
        pAC97Features->MasterVolume = Volume5bit;
        if (that->AdapterCommon->GetNodeConfig (NODEC_6BIT_MASTER_VOLUME))
            pAC97Features->MasterVolume = Volume6bit;
        
        pAC97Features->HeadphoneVolume = Volume5bit;
        if (!that->AdapterCommon->GetPinConfig (PINC_HPOUT_PRESENT))
            pAC97Features->HeadphoneVolume = VolumeDisabled;
        else if (that->AdapterCommon->GetNodeConfig (NODEC_6BIT_HPOUT_VOLUME))
            pAC97Features->HeadphoneVolume = Volume6bit;
        
        pAC97Features->MonoOutVolume = Volume5bit;
        if (!that->AdapterCommon->GetPinConfig (PINC_MONOOUT_PRESENT))
            pAC97Features->MonoOutVolume = VolumeDisabled;
        else if (that->AdapterCommon->GetNodeConfig (NODEC_6BIT_MONOOUT_VOLUME))
            pAC97Features->MonoOutVolume = Volume6bit;

        // The 18/20bit Resolution information.
        WORD wCodecID;

        // Read the reset register.
        ntStatus = that->AdapterCommon->ReadCodecRegister (AC97REG_RESET, &wCodecID);
        if (!NT_SUCCESS (ntStatus))
            return ntStatus;

        //
        // Now check the DAC and ADC resolution.
        //

        // First the DAC.
        pAC97Features->DAC = Resolution16bit;
        if (wCodecID & 0x0040)
            pAC97Features->DAC = Resolution18bit;
        if (wCodecID & 0x0080)
            pAC97Features->DAC = Resolution20bit;

        // Then the ADC.
        pAC97Features->ADC = Resolution16bit;
        if (wCodecID & 0x0100)
            pAC97Features->ADC = Resolution18bit;
        if (wCodecID & 0x0200)
            pAC97Features->ADC = Resolution20bit;

        // 3D technique
        pAC97Features->n3DTechnique = ((wCodecID & 0x7C00) >> 10);

        // Set the flag for MicIn.
        pAC97Features->bMicInPresent = that->AdapterCommon->
            GetPinConfig (PINC_MICIN_PRESENT) ? TRUE : FALSE;

        // Variable sample rate info.
        pAC97Features->bVSRPCM = that->AdapterCommon->
            GetNodeConfig (NODEC_PCM_VARIABLERATE_SUPPORTED) ? TRUE : FALSE;
        pAC97Features->bDSRPCM = that->AdapterCommon->
            GetNodeConfig (NODEC_PCM_DOUBLERATE_SUPPORTED) ? TRUE : FALSE;
        pAC97Features->bVSRMIC = that->AdapterCommon->
            GetNodeConfig (NODEC_MIC_VARIABLERATE_SUPPORTED) ? TRUE : FALSE;

        // Additional DAC's
        pAC97Features->bCenterDAC = that->AdapterCommon->
            GetNodeConfig (NODEC_CENTER_DAC_PRESENT) ? TRUE : FALSE;
        pAC97Features->bSurroundDAC = that->AdapterCommon->
            GetNodeConfig (NODEC_SURROUND_DAC_PRESENT) ? TRUE : FALSE;
        pAC97Features->bLFEDAC = that->AdapterCommon->
            GetNodeConfig (NODEC_LFE_DAC_PRESENT) ? TRUE : FALSE;


        // We filled out the structure.
        PropertyRequest->ValueSize = sizeof (tAC97Features);
        DOUT (DBG_PROPERTY, ("Get AC97Features succeeded."));

        // ntStatus was set with the read call! whatever this is, return it.
    }
#ifdef PROPERTY_SHOW_SET
    else
    {
        // Just to show, we have a SET also.
        if (PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
        {
            // This is the only property for a SET.
            if (PropertyRequest->PropertyItem->Id != KSPROPERTY_AC97_SAMPLE_SET)
                return ntStatus;

            // validate buffer size.
            if (PropertyRequest->ValueSize < sizeof (DWORD))
                return ntStatus;

            // Get the pointer to the DWORD.
            DWORD   *pTimerTick = (DWORD *)PropertyRequest->Value;

            // Check the buffer.
            if (!pTimerTick)
                return ntStatus;

            // Print the message.
            DOUT (DBG_ALL, ("This computer is already %d ms running Windows!", *pTimerTick));
            ntStatus = STATUS_SUCCESS;
        }
    }
#endif

    return ntStatus;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\proppage\version.h ===
/********************************************************************************
**    Copyright (c) 1999-2000 Microsoft Corporation. All Rights Reserved.
********************************************************************************/

#include <windows.h>
#include <ntverp.h>

#define VER_FILETYPE                 VFT_DLL
#define VER_FILESUBTYPE              VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "AC97 Property Page"
#define VER_INTERNALNAME_STR        "AC97Prop\0"
#define VER_ORIGINALFILENAME_STR    "Ac97Prop.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\driver\shared.h ===
/********************************************************************************
**    Copyright (c) 1998-2000 Microsoft Corporation. All Rights Reserved.
**
**       Portions Copyright (c) 1998-1999 Intel Corporation
**
********************************************************************************/

#ifndef _SHARED_H_
#define _SHARED_H_

#define PC_IMPLEMENTATION 1

#include <portcls.h>
#include <stdunk.h>
#include "ichreg.h"
#include "ac97reg.h"
#include "debug.h"


/*****************************************************************************
 * Structures and Typedefs 
 */

// This enum defines all the possible pin configurations. It is pretty easy,
// cause a pin can be there or not, depending if the CoDec supports it (like
// Headphone output (PINC_HPOUT_PRESENT)) or if the OEM disabled the feature
// with a private inf file.
// Look at common.h file for the registry string names.
// ATTN: Don't change without changing the static struct in common.cpp too.
enum TopoPinConfig
{
    PINC_PCBEEP_PRESENT = 0,
    PINC_PHONE_PRESENT,
    PINC_MIC2_PRESENT,
    PINC_VIDEO_PRESENT,
    PINC_AUX_PRESENT,
    PINC_HPOUT_PRESENT,
    PINC_MONOOUT_PRESENT,
    PINC_MICIN_PRESENT,
    PINC_MIC_PRESENT,
    PINC_LINEIN_PRESENT,
    PINC_CD_PRESENT,
    PINC_SURROUND_PRESENT,
    PINC_CENTER_LFE_PRESENT,
    PINC_TOP_ELEMENT            // number of PINC's
};

// This enum defines the functional configuration, called nodes. Nodes are
// black boxes that implement a functionality like 3d (NODEC_3D_PRESENT).
// At startup, we probe the Codec for features (like the pins above) and
// initialize an array which holds the configuration.
enum TopoNodeConfig
{
    NODEC_3D_PRESENT = 0,
    NODEC_TONE_PRESENT,
    NODEC_LOUDNESS_PRESENT,
    NODEC_SIMUL_STEREO_PRESENT,
    NODEC_6BIT_MASTER_VOLUME,
    NODEC_6BIT_HPOUT_VOLUME,
    NODEC_6BIT_MONOOUT_VOLUME,
    NODEC_6BIT_SURROUND_VOLUME,
    NODEC_6BIT_CENTER_LFE_VOLUME,
    NODEC_3D_CENTER_ADJUSTABLE,
    NODEC_3D_DEPTH_ADJUSTABLE,
    NODEC_PCM_VARIABLERATE_SUPPORTED,
    NODEC_PCM_VSR_INDEPENDENT_RATES,
    NODEC_PCM_DOUBLERATE_SUPPORTED,
    NODEC_MIC_VARIABLERATE_SUPPORTED,
    NODEC_CENTER_DAC_PRESENT,
    NODEC_SURROUND_DAC_PRESENT,
    NODEC_LFE_DAC_PRESENT,
    NODEC_TOP_ELEMENT           // number of NODES's
};

//
// Pin Defininition goes here
// We define all the possible pins in the AC97 CoDec and some "virtual" pins
// that are used for the topology to connect special functionality like 3D.
//
enum TopoPins
{
    // Source is something that goes into the AC97, dest goes out.
    PIN_WAVEOUT_SOURCE  = 0,
    PIN_PCBEEP_SOURCE,
    PIN_PHONE_SOURCE,
    PIN_MIC_SOURCE,
    PIN_LINEIN_SOURCE,
    PIN_CD_SOURCE,
    PIN_VIDEO_SOURCE,
    PIN_AUX_SOURCE,
    PIN_VIRT_3D_CENTER_SOURCE,
    PIN_VIRT_3D_DEPTH_SOURCE,
    PIN_VIRT_3D_MIX_MONO_SOURCE,
    PIN_VIRT_TONE_MIX_SOURCE,
    PIN_VIRT_TONE_MIX_MONO_SOURCE,
    PIN_VIRT_SURROUND_SOURCE,
    PIN_VIRT_CENTER_SOURCE,
    PIN_VIRT_LFE_SOURCE,
    PIN_VIRT_FRONT_SOURCE,
    PIN_MASTEROUT_DEST,
    PIN_HPOUT_SOURCE,
    PIN_MONOOUT_DEST,
    PIN_WAVEIN_DEST,
    PIN_MICIN_DEST,
    PIN_TOP_ELEMENT,            // number of pins
    PIN_INVALID
};

#if (DBG)
// In case we print some debug information about the pins, we use the names
// defined here.
const PCHAR TopoPinStrings[] =
{
    "PIN_WAVEOUT_SOURCE",
    "PIN_PCBEEP_SOURCE",
    "PIN_PHONE_SOURCE",
    "PIN_MIC_SOURCE",
    "PIN_LINEIN_SOURCE",
    "PIN_CD_SOURCE",
    "PIN_VIDEO_SOURCE",
    "PIN_AUX_SOURCE",
    "PIN_VIRT_3D_CENTER_SOURCE",
    "PIN_VIRT_3D_DEPTH_SOURCE",
    "PIN_VIRT_3D_MIX_MONO_SOURCE",
    "PIN_VIRT_TONE_MIX_SOURCE",
    "PIN_VIRT_TONE_MIX_MONO_SOURCE",
    "PIN_VIRT_SURROUND_SOURCE",
    "PIN_VIRT_CENTER_SOURCE",
    "PIN_VIRT_LFE_SOURCE",
    "PIN_VIRT_FRONT_SOURCE",
    "PIN_MASTEROUT_DEST",
    "PIN_HPOUT_SOURCE",
    "PIN_MONOOUT_DEST",
    "PIN_WAVEIN_DEST",
    "PIN_MICIN_DEST",
    "TOP_ELEMENT",              // should never dump this
    "INVALID"                   // or this either
};
#endif


//
// Node Definition goes here.
// We define all the possible nodes here (nodes are black boxes that represent
// a functional block like bass volume) and some virtual nodes, mainly volume
// controls, that are used to represent special functionality in the topology
// like 3D controls (exposed as volumes) or to give the user volume controls
// for each possible record line. In that case, the volume is placed in front
// of the record selector (mux). The topology is not parsed correctly if there
// are no volume controls between the pins and a muxer. Also, these virtual
// controls only represent volumes and no mutes, cause mutes wouldn't be dis-
// played by sndvol32.
// ATTN: DON'T  change without first looking at the table in ac97reg.h!!!
enum TopoNodes
{
    NODE_WAVEOUT_VOLUME = 0,
    NODE_WAVEOUT_MUTE,
    NODE_VIRT_WAVEOUT_3D_BYPASS,        // exposed as AGC control
    NODE_PCBEEP_VOLUME,
    NODE_PCBEEP_MUTE,
    NODE_PHONE_VOLUME,
    NODE_PHONE_MUTE,
    NODE_MIC_SELECT,
    NODE_MIC_BOOST,
    NODE_MIC_VOLUME,
    NODE_MIC_MUTE,
    NODE_LINEIN_VOLUME,
    NODE_LINEIN_MUTE,
    NODE_CD_VOLUME,
    NODE_CD_MUTE,
    NODE_VIDEO_VOLUME,
    NODE_VIDEO_MUTE,
    NODE_AUX_VOLUME,
    NODE_AUX_MUTE,
    NODE_MAIN_MIX,
    NODE_VIRT_3D_CENTER,                // we have no 3D control type, so we
    NODE_VIRT_3D_DEPTH,                 // expose 2 volume controls and 2 mute
    NODE_VIRT_3D_ENABLE,                // checkboxs (the other is bypass).
    NODE_BEEP_MIX,
    NODE_BASS,
    NODE_TREBLE,
    NODE_LOUDNESS,
    NODE_SIMUL_STEREO,
    NODE_MASTEROUT_VOLUME,
    NODE_MASTEROUT_MUTE,
    NODE_HPOUT_VOLUME,
    NODE_HPOUT_MUTE,
    NODE_MONOOUT_SELECT,
    NODE_VIRT_MONOOUT_VOLUME1,          // each mono out must have volume
    NODE_VIRT_MONOOUT_VOLUME2,
    NODE_WAVEIN_SELECT,
    NODE_VIRT_MASTER_INPUT_VOLUME1,     // boy, each master input must have a
    NODE_VIRT_MASTER_INPUT_VOLUME2,     // volume
    NODE_VIRT_MASTER_INPUT_VOLUME3,
    NODE_VIRT_MASTER_INPUT_VOLUME4,
    NODE_VIRT_MASTER_INPUT_VOLUME5,
    NODE_VIRT_MASTER_INPUT_VOLUME6,
    NODE_VIRT_MASTER_INPUT_VOLUME7,
    NODE_VIRT_MASTER_INPUT_VOLUME8,
    NODE_MICIN_VOLUME,
    NODE_MICIN_MUTE,
    NODE_SURROUND_VOLUME,
    NODE_SURROUND_MUTE,
    NODE_CENTER_VOLUME,
    NODE_CENTER_MUTE,
    NODE_LFE_VOLUME,
    NODE_LFE_MUTE,
    NODE_FRONT_VOLUME,
    NODE_FRONT_MUTE,
    NODE_VIRT_MASTERMONO_VOLUME,        // used for multichannel or headphone
    NODE_VIRT_MASTERMONO_MUTE,
    NODE_TOP_ELEMENT,                   // number of nodes
    NODE_INVALID
};

#if (DBG)
// In case we print some debug information about the nodes, we use names
// defined here.
const PCHAR NodeStrings[] =
{
    "WAVEOUT_VOLUME",
    "WAVEOUT_MUTE",
    "WAVEOUT_3D_BYPASS",
    "PCBEEP_VOLUME",
    "PCBEEP_MUTE",
    "PHONE_VOLUME",
    "PHONE_MUTE",
    "MIC_SELECT",
    "MIC_BOOST",
    "MIC_VOLUME",
    "MIC_MUTE",
    "LINEIN_VOLUME",
    "LINEIN_MUTE",
    "CD_VOLUME",
    "CD_MUTE",
    "VIDEO_VOLUME",
    "VIDEO_MUTE",
    "AUX_VOLUME",
    "AUX_MUTE",
    "MAIN_MIX",
    "3D_CENTER",
    "3D_DEPTH",
    "3D_ENABLE",
    "BEEP_MIX",
    "BASS",
    "TREBLE",
    "LOUDNESS",
    "SIMUL_STEREO",
    "MASTER_VOLUME",
    "MASTER_MUTE",
    "HPOUT_VOLUME",
    "HPOUT_MUTE",
    "MONOOUT_SELECT",
    "MONOOUT_VOLUME_3D_MIX",
    "MONOOUT_VOLUME_MIC",
    "WAVEIN_SELECT",
    "MASTER_INPUT_VOLUME_MIC",
    "MASTER_INPUT_VOLUME_CD",
    "MASTER_INPUT_VOLUME_VIDEO",
    "MASTER_INPUT_VOLUME_AUX",
    "MASTER_INPUT_VOLUME_LINEIN",
    "MASTER_INPUT_VOLUME_TONE_MIX",
    "MASTER_INPUT_VOLUME_TONE_MIX_MONO",
    "MASTER_INPUT_VOLUME_PHONE",
    "MICIN_VOLUME",
    "MICIN_MUTE",
    "SURROUND_VOLUME",
    "SURROUND_MUTE",
    "CENTER_VOLUME",
    "CENTER_MUTE",
    "LFE_VOLUME",
    "LFE_MUTE",
    "FRONT_VOLUME",
    "FRONT_MUTE",
    "VIRT_MASTERMONO_VOLUME",
    "VIRT_MASTERMONO_MUTE",
    "TOP_ELEMENT",      // should never dump this
    "INVALID"           // or this
};
#endif

//
// The pins used for the wave miniport connection.
//
enum WavePins
{
    PIN_WAVEOUT = 0,
    PIN_WAVEOUT_BRIDGE,
    PIN_WAVEIN,
    PIN_WAVEIN_BRIDGE,
    PIN_MICIN,
    PIN_MICIN_BRIDGE
};

//
// The nodes used for the wave miniport connection.
//
enum WaveNodes
{
    NODE_WAVEOUT_DAC,
    NODE_WAVEIN_ADC,
    NODE_MICIN_ADC
};

/*****************************************************************************
 * Function prototypes
 */

class CMiniportWaveICH;

/*****************************************************************************
 * NewAdapterCommon()
 *****************************************************************************
 * Create a new adapter common object.
 */
NTSTATUS NewAdapterCommon
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
);

/*****************************************************************************
 * Class definitions
 */

/*****************************************************************************
 * IMiniportTopologyICH
 *****************************************************************************
 * Interface for topology miniport.
 */
DECLARE_INTERFACE_(IMiniportTopologyICH,IMiniportTopology)
{
    STDMETHOD_(NTSTATUS,GetPhysicalConnectionPins)
    (   THIS_
        OUT     PULONG  WaveOutSource,
        OUT     PULONG  WaveInDest,
        OUT     PULONG  MicInDest
    )   PURE;
    // Used for DRM:
    STDMETHOD_(void, SetCopyProtectFlag)
    (   THIS_
        IN      BOOL
    )   PURE;
};

typedef IMiniportTopologyICH *PMINIPORTTOPOLOGYICH;

/*****************************************************************************
 * IAdapterCommon
 *****************************************************************************
 * Interface for adapter common object.
 */
DECLARE_INTERFACE_(IAdapterCommon,IUnknown)
{
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PRESOURCELIST   ResourceList,
        IN      PDEVICE_OBJECT  DeviceObject
    )   PURE;
    STDMETHOD_(BOOL,GetPinConfig)
    (   THIS_
        IN      TopoPinConfig
    )   PURE;
    STDMETHOD_(void,SetPinConfig)
    (   THIS_
        IN      TopoPinConfig,
        IN      BOOL
    )   PURE;
    STDMETHOD_(BOOL,GetNodeConfig)
    (   THIS_
        IN      TopoNodeConfig
    )   PURE;
    STDMETHOD_(void,SetNodeConfig)
    (   THIS_
        IN      TopoNodeConfig,
        IN      BOOL
    )   PURE;
    STDMETHOD_(AC97Register,GetNodeReg)
    (   THIS_
        IN      TopoNodes
    )   PURE;
    STDMETHOD_(WORD,GetNodeMask)
    (   THIS_
        IN      TopoNodes
    )   PURE;
    STDMETHOD_(NTSTATUS,ReadCodecRegister)
    (   THIS_
        IN      AC97Register    Register,
        OUT     PWORD           wData
    )   PURE;
    STDMETHOD_(NTSTATUS,WriteCodecRegister)
    (   THIS_
        IN      AC97Register    Register,
        IN      WORD            wData,
        IN      WORD            wMask
    )   PURE;
    STDMETHOD_(UCHAR,ReadBMControlRegister8)
    (   THIS_
        IN      ULONG   Offset
    )   PURE;
    STDMETHOD_(USHORT,ReadBMControlRegister16)
    (   THIS_
        IN      ULONG   Offset
    )   PURE;
    STDMETHOD_(ULONG,ReadBMControlRegister32)
    (   THIS_
        IN      ULONG   Offset
    )   PURE;    
    STDMETHOD_(void,WriteBMControlRegister)
    (   THIS_
        IN      ULONG   Offset,
        IN      UCHAR   Value
    )   PURE;
    STDMETHOD_(void,WriteBMControlRegister)
    (   THIS_
        IN      ULONG   Offset,
        IN      USHORT  Value
    )   PURE;
    STDMETHOD_(void,WriteBMControlRegister)
    (   THIS_
        IN      ULONG   Offset,
        IN      ULONG   Value
    )   PURE;
    STDMETHOD_(NTSTATUS, RestoreCodecRegisters)
    (   THIS_
        void
    )   PURE;
    STDMETHOD_(NTSTATUS, ProgramSampleRate)
    (   THIS_
        IN      AC97Register  Register,
        IN      DWORD         dwSampleRate
    )   PURE;
    // Used for DRM:
    STDMETHOD_(void, SetMiniportTopology)
    (   THIS_
        IN      PMINIPORTTOPOLOGYICH
    )   PURE;
    STDMETHOD_(PMINIPORTTOPOLOGYICH, GetMiniportTopology)
    (   THIS_
        void
    )   PURE;
    // These are used by the wave miniport.
    STDMETHOD_(void, ReadChannelConfigDefault)
    (   THIS_
        PDWORD  pwChannelConfig,
        PWORD   pwChannels
    )   PURE;
    STDMETHOD_(void, WriteChannelConfigDefault)
    (   THIS_
        DWORD   dwChannelConfig
    )   PURE;
};

typedef IAdapterCommon *PADAPTERCOMMON;

/*****************************************************************************
 * Guids for the Interfaces
 *****************************************************************************
 */

// {77481FA0-1EF2-11d2-883A-0080C765647D}
DEFINE_GUID(IID_IAdapterCommon, 
0x77481fa0, 0x1ef2, 0x11d2, 0x88, 0x3a, 0x0, 0x80, 0xc7, 0x65, 0x64, 0x7d);

// {245AE964-49C8-11d2-95D7-00C04FB925D3}
DEFINE_GUID(IID_IMiniportTopologyICH, 
0x245ae964, 0x49c8, 0x11d2, 0x95, 0xd7, 0x0, 0xc0, 0x4f, 0xb9, 0x25, 0xd3);

#endif  //_SHARED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\common.h ===
/*
    Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
*/

#ifndef _COMMON_H_
#define _COMMON_H_


#if (DBG)
#if !defined(DEBUG_LEVEL)
#define DEBUG_LEVEL DEBUGLVL_TERSE
#endif
#endif

#include <winerror.h>

/*****************************************************************************
 * Includes common to all implementation files
 *****************************************************************************/

#define PC_NEW_NAMES    1

#include <stdunk.h>
#include <portcls.h>
#include <ksdebug.h>
#include <dmusicks.h>       // Ks defines
#include <dmerror.h>        // Error codes
#include <dmdls.h>          // DLS definitions

#include "kernhelp.h"
#include "CSynth.h"
#include "synth.h"
#include "muldiv32.h"

#endif  //_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\adapter.cpp ===
/*****************************************************************************
 * adapter.cpp - DMusic adapter implementation
 *
 *  This includes the adapter driver for the
 *  kernel mode DirectMusic DLS 1.0 SW synthesizer
 *
 *****************************************************************************
 * Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.
 *
 *  06/08/98    MartinP
 *
 */

//
// All the GUIDS for all the miniports end up in this object.
//
#define PUT_GUIDS_HERE

#define STR_MODULENAME "DDKSynth.sys:Adapter: "

#define PC_NEW_NAMES 1

#include "common.h"
#include "private.h"


/*****************************************************************************
 * Defines
 */

#define MAX_MINIPORTS 1

#if (DBG)
#define SUCCEEDS(s) ASSERT(NT_SUCCESS(s))
#else
#define SUCCEEDS(s) (s)
#endif

/*****************************************************************************
 * Referenced forward
 */
NTSTATUS
AddDevice
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
);

NTSTATUS
StartDevice
(
    IN      PDEVICE_OBJECT  pDeviceObject,  // Context for the class driver.
    IN      PIRP            pIrp,           // Context for the class driver.
    IN      PRESOURCELIST   ResourceList    // List of hardware resources.
);


#pragma code_seg("INIT")
/*****************************************************************************
 * DriverEntry()
 *****************************************************************************
 * This function is called by the operating system when the driver is loaded.
 * All adapter drivers can use this code without change.
 */
extern "C"
NTSTATUS
DriverEntry
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE, ("DriverEntry"));

    //
    // Tell the class driver to initialize the driver.
    //
    return PcInitializeAdapterDriver((PDRIVER_OBJECT)Context1,
                                     (PUNICODE_STRING)Context2,
                                     (PDRIVER_ADD_DEVICE)AddDevice);
}


#pragma code_seg()
/*****************************************************************************
 * AddDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is added.
 * All adapter drivers can use this code without change.
 */
NTSTATUS
AddDevice
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE, ("AddDevice"));

    //
    // Tell the class driver to add the device.
    //
    return PcAddAdapterDevice((PDRIVER_OBJECT)Context1, (PDEVICE_OBJECT)Context2, StartDevice, MAX_MINIPORTS, 0);
}


/*****************************************************************************
 * StartDevice()
 *****************************************************************************
 *
 *  This function is called by the operating system when the device is started.
 *  It is responsible for starting the miniports.  This code is specific to
 *  the adapter because it calls out miniports for functions that are specific
 *  to the adapter.  A list of no resources is not the same as a NULL list ptr.
 *
 */
NTSTATUS
StartDevice
(
    IN      PDEVICE_OBJECT  pDeviceObject,  // Context for the class driver.
    IN      PIRP            pIrp,           // Context for the class driver.
    IN      PRESOURCELIST   ResourceList    // List of hardware resources.
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("StartDevice"));

    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_INVALID_PARAMETER;
    }

    PPORT       port;
    NTSTATUS    ntStatus = PcNewPort(&port, CLSID_PortDMus);

    if (!NT_SUCCESS(ntStatus))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("StartDevice PcNewPort failed (0x%08x)", ntStatus));
        return ntStatus;
    }
    ASSERT(port);

    PUNKNOWN miniport;
#ifdef USE_OBSOLETE_FUNCS
    ntStatus = CreateMiniportDmSynth(&miniport, NULL, NonPagedPool);
#else
    ntStatus = CreateMiniportDmSynth(&miniport, NULL, NonPagedPool, pDeviceObject);
#endif

    if (!NT_SUCCESS(ntStatus))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("StartDevice CreateMiniportDmSynth failed (0x%08x)", ntStatus));
        port->Release();
        return ntStatus;
    }
    ASSERT(miniport);

    ntStatus =
        port->Init
        (
            pDeviceObject,
            pIrp,
            miniport,
            NULL,
            ResourceList
        );

    if (!NT_SUCCESS(ntStatus))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("StartDevice port Init failed (0x%08x)", ntStatus));
        port->Release();
        miniport->Release();
        return ntStatus;
    }

    ntStatus = PcRegisterSubdevice( pDeviceObject,
                                    L"DDKSynth",
                                    port);
    if (!NT_SUCCESS(ntStatus))
    {
        _DbgPrintF(DEBUGLVL_TERSE,("StartDevice PcRegisterSubdevice failed (0x%08x)", ntStatus));
    }

    //
    // We don't need the miniport any more.  Either the port has it,
    // or we've failed, and it should be deleted.
    //
    miniport->Release();

    //
    // Release the reference which existed when PcNewPort() gave us the
    // pointer in the first place.  This is the right thing to do
    // regardless of the outcome.
    //
    port->Release();

    return ntStatus;
}

/*****************************************************************************
 * _purecall()
 *****************************************************************************
 * The C++ compiler loves me.
 * TODO: Figure out how to put this into portcls.sys
 */
int __cdecl
_purecall( void )
{
    ASSERT( !"Pure virtual function called" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\clist.cpp ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//
//      clist.cpp
//
//

#define STR_MODULENAME "DDKSynth.sys:CList: "

#include "common.h"

#pragma code_seg()
/*****************************************************************************
 * CListItem::GetCount()
 *****************************************************************************
 * Returns number of items in the list.
 */
LONG CListItem::GetCount(void) const
{
    LONG l;
    const CListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

/*****************************************************************************
 * CListItem::IsMember()
 *****************************************************************************
 * Returns whether the given list item is a member of the list.
 */
BOOL CListItem::IsMember(CListItem *pItem)
{
    CListItem *li = this;
    for (;li != NULL; li=li->m_pNext)
    {
        if (li == pItem) return (TRUE);
    }
    return (FALSE);
}

/*****************************************************************************
 * CListItem::Cat()
 *****************************************************************************
 * Append the given list item to the list.
 */
CListItem* CListItem::Cat(CListItem *pItem)
{
    CListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

/*****************************************************************************
 * CListItem::Remove()
 *****************************************************************************
 * Remove the given list item from the list.
 */
CListItem* CListItem::Remove(CListItem *pItem)
{
    CListItem *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    ASSERT(prev != li->m_pNext); 
    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

/*****************************************************************************
 * CListItem::GetPrev()
 *****************************************************************************
 * Get the list item that precedes the given list item (if any).
 */
CListItem* CListItem::GetPrev(CListItem *pItem) const
{
    const CListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (CListItem*)prev;
}

/*****************************************************************************
 * CListItem::GetItem()
 *****************************************************************************
 * Returns nth the list item, where n is the given list index.
 */
CListItem * CListItem::GetItem(LONG index)
{
	CListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) index--;
	return (scan);
}

/*****************************************************************************
 * CList::InsertBefore()
 *****************************************************************************
 * Inserts a given list item before a second list item (which is presumed to
 * be a list member).  Inserts the given list item at the head if there is
 * no preceding list item.
 */
void CList::InsertBefore(CListItem *pItem,CListItem *pInsert)
{
	CListItem *prev = GetPrev(pItem);
	ASSERT(pInsert != pItem);
    pInsert->SetNext(pItem);
	if (prev)
    {
        ASSERT(pInsert != prev);
        prev->SetNext(pInsert);
    }
	else 
    {
        m_pHead = pInsert;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\proppage\resource.h ===
/********************************************************************************
**    Copyright (c) 1999-2000 Microsoft Corporation. All Rights Reserved.
********************************************************************************/

#define DLG_AC97FEATURES                102
#define IDC_6BIT_MASTER_OUT             1001
#define IDC_6BIT_HEADPHONE              1002
#define IDC_6BIT_MONO_OUT               1003
#define IDC_DAC_RESOLUTION              1004
#define IDC_ADC_RESOLUTION              1005
#define IDC_3D_TECHNIQUE                1006
#define IDC_VSR_PCM                     1007
#define IDC_DSR_PCM                     1008
#define IDC_VSR_MIC                     1009
#define IDC_CENTER_DAC                  1010
#define IDC_SURROUND_DAC                1011
#define IDC_LFE_DAC                     1012
#define IDC_HEADPHONE_TEXT              1014
#define IDC_MONOOUT_TEXT                1015
#define IDC_3D_TECHNIQUE_BOX            1016
#define IDC_VSRMIC_TEXT                 1017

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ac97\proppage\ac97prop.cpp ===
/********************************************************************************
**    Copyright (c) 1999-2000 Microsoft Corporation. All Rights Reserved.
********************************************************************************/

#include <windows.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <setupapi.h>
#include "resource.h"
#include "prvprop.h"

HINSTANCE   ghInstance;


#if (DBG)
/////////////////////////////////////////////////////////////////////////////////
// dbgError
/////////////////////////////////////////////////////////////////////////////////
// This function prints an error message.
// It prints first the string passed and then the error that it gets with
// GetLastError as a string.
//
// Arguments:
//    szMsg - message to print.
//
// Return Value:
//    None.
void dbgError (LPCTSTR szMsg)
{
    LPTSTR errorMessage;
    DWORD  count;

    // Get the error message from the system.
    count = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_SYSTEM |
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError (),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&errorMessage,
                0,
                NULL);

    // Print the msg + error + \n\r.
    if (count)
    {
        OutputDebugString (szMsg);
        OutputDebugString (errorMessage);
        OutputDebugString (TEXT("\n\r"));

        // This is for those without a debugger.
        // MessageBox (NULL, szErrorMessage, szMsg, MB_OK | MB_ICONSTOP);

        LocalFree (errorMessage);
    }
    else
    {
        OutputDebugString (TEXT("AC97 Property Page"));
        OutputDebugString (TEXT(": Low memory condition. Cannot ")
                TEXT("print error message.\n\r"));
    }
}
#else
#define dbgError(a) 0;
#endif


/////////////////////////////////////////////////////////////////////////////////
// DllMain
/////////////////////////////////////////////////////////////////////////////////
// Main enty point of the DLL.
// We safe only the instance handle that we need for the creation of the
// property sheet. There is nothing else to do.
//
// Arguments:
//    hModule            - instance data, is equal to module handle
//    ul_reason_for_call - the reason for the call
//    lpReserved         - some additional parameter.
//
// Return Value:
//    BOOL: FALSE if DLL should fail, TRUE on success
BOOL APIENTRY DllMain
(
    HANDLE hModule, 
    DWORD  ul_reason_for_call, 
    LPVOID lpReserved
)
{
    ghInstance = (HINSTANCE) hModule;
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////////
// SetDlgControls 
/////////////////////////////////////////////////////////////////////////////////
// This function gets called when the property sheet page gets created by
// "AC97PropPage_OnInitDialog". It initializes the different dialog controls that
// get displayed.
// By default all dlg items are set to "Yes", so we only change to "No" if it
// applies.
//
//
// Arguments:
//    hWnd           - handle to the dialog window
//    pAC97Features  - pointer to AC97Features structure
//
// Return Value:
//    None.
void SetDlgControls (HWND hWnd, tAC97Features *pAC97Features)
{
    const TCHAR No[4] = TEXT("No");
    const TCHAR NA[4] = TEXT("N/A");
    // DAC or ADC resolution
    const TCHAR R18[4] = TEXT("18");
    const TCHAR R20[4] = TEXT("20");
    // The different 3D Technologies.
    const TCHAR T[][40] = {TEXT("No 3D Stereo Enhancement"), TEXT("Analog Devices Phat Stereo"),
        TEXT("Creative Stereo Enhancement"), TEXT("National Semi 3D Stereo Enhancement"),
        TEXT("Yamaha Ymersion"), TEXT("BBE 3D Stereo Enhancement"),
        TEXT("Crystal Semi 3D Stereo Enhancement"), TEXT("Qsound QXpander"),
        TEXT("Spatializer 3D Stereo Enhancement"), TEXT("SRS 3D Stereo Enhancement"),
        TEXT("Platform Tech 3D Stereo Enhancement"), TEXT("AKM 3D Audio"),
        TEXT("Aureal Stereo Enhancement"), TEXT("Aztech 3D Enhancement"),
        TEXT("Binaura 3D Audio Enhancement"), TEXT("ESS Technology (stereo enhancement)"),
        TEXT("Harman International VMAx"), TEXT("Nvidea 3D Stereo Enhancement"),
        TEXT("Philips Incredible Sound"), TEXT("Texas Instrument 3D Stereo Enhancement"),
        TEXT("VLSI Technology 3D Stereo Enhancement"), TEXT("TriTech 3D Stereo Enhancement"),
        TEXT("Realtek 3D Stereo Enhancement"), TEXT("Samsung 3D Stereo Enhancement"),
        TEXT("Wolfson Microelectronics 3D Enhancement"), TEXT("Delta Integration 3D Enhancement"),
        TEXT("SigmaTel 3D Enhancement"), TEXT("Rockwell 3D Stereo Enhancement"),
        TEXT("Unknown"), TEXT("Unknown"), TEXT("Unknown"), TEXT("Unknown")};

    //
    // Set the Volume information.
    //
    if (hWnd == NULL)
        return;
    
    // Set the Yes/No flags.
    if (pAC97Features->MasterVolume == Volume5bit)
        SetWindowText (GetDlgItem (hWnd, IDC_6BIT_MASTER_OUT), No);
    if (pAC97Features->HeadphoneVolume == Volume5bit)
        SetWindowText (GetDlgItem (hWnd, IDC_6BIT_HEADPHONE), No);
    if (pAC97Features->MonoOutVolume == Volume5bit)
        SetWindowText (GetDlgItem (hWnd, IDC_6BIT_MONO_OUT), No);

    // Evtl disable controls if they are not there.
    if (pAC97Features->HeadphoneVolume == VolumeDisabled)
    {
        SetWindowText (GetDlgItem (hWnd, IDC_6BIT_HEADPHONE), NA);
        EnableWindow (GetDlgItem (hWnd, IDC_6BIT_HEADPHONE), FALSE);
        EnableWindow (GetDlgItem (hWnd, IDC_HEADPHONE_TEXT), FALSE);
    }
    if (pAC97Features->MonoOutVolume == VolumeDisabled)
    {
        SetWindowText (GetDlgItem (hWnd, IDC_6BIT_MONO_OUT), NA);
        EnableWindow (GetDlgItem (hWnd, IDC_6BIT_MONO_OUT), FALSE);
        EnableWindow (GetDlgItem (hWnd, IDC_MONOOUT_TEXT), FALSE);
    }

    //
    // Set the ConverterResolution. The fields are set be default to "16".
    //

    if (pAC97Features->DAC == Resolution18bit)
        SetWindowText (GetDlgItem (hWnd, IDC_DAC_RESOLUTION), R18);
    else if (pAC97Features->DAC == Resolution20bit)
        SetWindowText (GetDlgItem (hWnd, IDC_DAC_RESOLUTION), R20);

    if (pAC97Features->ADC == Resolution18bit)
        SetWindowText (GetDlgItem (hWnd, IDC_ADC_RESOLUTION), R18);
    else if (pAC97Features->ADC == Resolution20bit)
        SetWindowText (GetDlgItem (hWnd, IDC_ADC_RESOLUTION), R20);

    //
    // Set the 3D Technique.
    //

    SetWindowText (GetDlgItem (hWnd, IDC_3D_TECHNIQUE), T[pAC97Features->n3DTechnique & 0x1F]);
    // Evtl. disable the text box ...
    if (pAC97Features->n3DTechnique == 0)
    {
        EnableWindow (GetDlgItem (hWnd, IDC_3D_TECHNIQUE), FALSE);
        EnableWindow (GetDlgItem (hWnd, IDC_3D_TECHNIQUE_BOX), FALSE);
    }

    //
    // Set the variable sample rate support. Set to "Yes" by default.
    //

    if (!pAC97Features->bVSRPCM)
        SetWindowText (GetDlgItem (hWnd, IDC_VSR_PCM), No);
    if (!pAC97Features->bDSRPCM)
        SetWindowText (GetDlgItem (hWnd, IDC_DSR_PCM), No);
    if (!pAC97Features->bVSRMIC)
        SetWindowText (GetDlgItem (hWnd, IDC_VSR_MIC), No);
    // Evtl. disable MicIn sample rate text.
    if (!pAC97Features->bMicInPresent)
    {
        SetWindowText (GetDlgItem (hWnd, IDC_VSR_MIC), NA);
        EnableWindow (GetDlgItem (hWnd, IDC_VSR_MIC), FALSE);
        EnableWindow (GetDlgItem (hWnd, IDC_VSRMIC_TEXT), FALSE);
    }

    //
    // Set the additional DACs support. Default is "Yes".
    //

    if (!pAC97Features->bCenterDAC)
        SetWindowText (GetDlgItem (hWnd, IDC_CENTER_DAC), No);
    if (!pAC97Features->bSurroundDAC)
        SetWindowText (GetDlgItem (hWnd, IDC_SURROUND_DAC), No);
    if (!pAC97Features->bLFEDAC)
        SetWindowText (GetDlgItem (hWnd, IDC_LFE_DAC), No);
}


/////////////////////////////////////////////////////////////////////////////////
// AC97PropPage_OnInitDialog
/////////////////////////////////////////////////////////////////////////////////
// This function gets called when the property sheet page gets created.  This
// is the perfect opportunity to initialize the dialog items that get displayed.
//
// Arguments:
//    ParentHwnd - handle to the dialog window
//    FocusHwnd  - handle to the control that would get the focus.
//    lParam     - initialization parameter (pAC97Features).
//
// Return Value:
//    TRUE if focus should be set to FocusHwnd, FALSE if you set the focus yourself.
BOOL AC97PropPage_OnInitDialog (HWND ParentHwnd, HWND FocusHwnd, LPARAM lParam)
{
    tAC97Features   *pAC97Features;
    HCURSOR         hCursor;

    // Check the parameters (lParam is tAC97Features pointer)
    if (!lParam)
        return FALSE;
    
    // put up the wait cursor
    hCursor = SetCursor (LoadCursor (NULL, IDC_WAIT));

    pAC97Features = (tAC97Features *)((LPPROPSHEETPAGE)lParam)->lParam;

    SetDlgControls (ParentHwnd, pAC97Features);

    // We don't need the private structure anymore.
    LocalFree (pAC97Features);

    // remove the wait cursor
    SetCursor(hCursor);

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////////
// AC97DlgProc
/////////////////////////////////////////////////////////////////////////////////
// This callback function gets called by the system whenever something happens
// with the dialog sheet. Please take a look at the SDK for further information
// on dialog messages.
//
// Arguments:
//    hDlg     - handle to the dialog window
//    uMessage - the message
//    wParam   - depending on message sent
//    lParam   - depending on message sent
//
// Return Value:
//    int (depends on message).
INT_PTR APIENTRY AC97DlgProc (HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage)
    {
        // We don't do anything for these messages.
        case WM_COMMAND:
        case WM_CONTEXTMENU:
        case WM_HELP:
        case WM_NOTIFY:
        case WM_DESTROY:
            break;

        case WM_INITDIALOG:
            return AC97PropPage_OnInitDialog (hDlg, (HWND) wParam, lParam);
    }

    return FALSE;
}


#ifdef PROPERTY_SHOW_SET
/////////////////////////////////////////////////////////////////////////////////
// AC97ShowSet
/////////////////////////////////////////////////////////////////////////////////
// This function gets called by the property page provider (in this module) to
// show how we could set properties in the driver.  Note that this is only an
// example and doesn't really do anything useful.
// We pass down a DWORD and the driver will simply print this DWORD out on the
// debugger.
//
// Arguments:
//    pDeviceInterfaceDetailData - device interface details (path to device driver)
//
// Return Value:
//    None (we don't care).
void AC97ShowSet (PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceInterfaceDetailData)
{
    HANDLE          hTopology;
    KSPROPERTY      AC97Property;
    ULONG           ulBytesReturned;
    BOOL            fSuccess;
    DWORD           dwData;

    // Open the topology filter.
    hTopology = CreateFile (pDeviceInterfaceDetailData->DevicePath,
                            GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, 0, NULL);
    // Check for error.
    if (hTopology == INVALID_HANDLE_VALUE)
    {
        dbgError (TEXT("AC97ShowSet: CreateFile: "));
        return;
    }

    // Set the dword to something random.
    dwData = GetTickCount ();
    
    // Prepare the property structure sent down.
    AC97Property.Set = KSPROPSETID_Private;
    AC97Property.Flags = KSPROPERTY_TYPE_SET;
    AC97Property.Id = KSPROPERTY_AC97_SAMPLE_SET;

    // Make the final call.
    fSuccess = DeviceIoControl (hTopology, IOCTL_KS_PROPERTY,
                                &AC97Property, sizeof (AC97Property),
                                &dwData, sizeof (dwData),
                                &ulBytesReturned, NULL);
    // We don't need the handle anymore.
    CloseHandle (hTopology);
    
    // Check for error.
    if (!fSuccess)
    {
        dbgError (TEXT("AC97ShowSet: DeviceIoControl: "));
    }

    return;     // We don't care about the return value.
}
#endif

    
/////////////////////////////////////////////////////////////////////////////////
// GetAC97Features
/////////////////////////////////////////////////////////////////////////////////
// This function gets called by the property page provider (in this module) to
// get all the AC97 features that are normally not displayed by the drivers.
// To get the AC97Features structure we pass down the private property. As you
// can see this is fairly easy.
//
// Arguments:
//    pDeviceInterfaceDetailData - device interface details (path to device driver)
//    pAC97Features              - pointer to AC97 features structure.
//
// Return Value:
//    BOOL: FALSE if we couldn't get the information, TRUE on success.
BOOL GetAC97Features (PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceInterfaceDetailData,
                      tAC97Features *pAC97Features)
{
    HANDLE          hTopology;
    KSPROPERTY      AC97Property;
    ULONG           ulBytesReturned;
    BOOL            fSuccess;

    // Open the topology filter.
    hTopology = CreateFile (pDeviceInterfaceDetailData->DevicePath,
                            GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, 0, NULL);
    // Check for error.
    if (hTopology == INVALID_HANDLE_VALUE)
    {
        dbgError (TEXT("GetAC97Features: CreateFile: "));
        return FALSE;
    }

    // Fill the KSPROPERTY structure.
    AC97Property.Set = KSPROPSETID_Private;
    AC97Property.Flags = KSPROPERTY_TYPE_GET;
    AC97Property.Id = KSPROPERTY_AC97_FEATURES;

    fSuccess = DeviceIoControl (hTopology, IOCTL_KS_PROPERTY,
                                &AC97Property, sizeof (AC97Property),
                                pAC97Features, sizeof (tAC97Features),
                                &ulBytesReturned, NULL);
    // We don't need the handle anymore.
    CloseHandle (hTopology);
    
    // Check for error.
    if (!fSuccess)
    {
        dbgError (TEXT("GetAC97Features: DeviceIoControl: "));
        return FALSE;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////////
// GetDeviceInterfaceDetail
/////////////////////////////////////////////////////////////////////////////////
// This function gets called by the property page provider (in this module) to
// get the device interface details. The device interface detail contains a
// path to the device driver that can be used to open the device driver.
// When we parse the driver we look for the topology interface since this
// interface exposes the private property.
//
// Arguments:
//    pPropPageRequest           - points to SP_PROPSHEETPAGE_REQUEST
//    pDeviceInterfaceDetailData - device interface details returned.
//
// Return Value:
//    BOOL: FALSE if something went wrong, TRUE on success.
BOOL GetDeviceInterfaceDetail (PSP_PROPSHEETPAGE_REQUEST pPropPageRequest,
                               PSP_DEVICE_INTERFACE_DETAIL_DATA *ppDeviceInterfaceDetailData)
{
    BOOL                        fSuccess;
    ULONG                       ulDeviceInstanceIdSize = 0;
    PTSTR                       pDeviceInstanceID = NULL;
    HDEVINFO                    hDevInfoWithInterface;
    SP_DEVICE_INTERFACE_DATA    DeviceInterfaceData;
    ULONG                       ulDeviceInterfaceDetailDataSize = 0;

    // Get the device instance id (PnP string).  The first call will retrieve
    // the buffer length in characters.  fSuccess will be FALSE.
    fSuccess = SetupDiGetDeviceInstanceId (pPropPageRequest->DeviceInfoSet,
                                           pPropPageRequest->DeviceInfoData,
                                           NULL,
                                           0,
                                           &ulDeviceInstanceIdSize);
    // Check for error.
    if ((GetLastError () != ERROR_INSUFFICIENT_BUFFER) || (!ulDeviceInstanceIdSize))
    {
        dbgError (TEXT("GetDeviceInterfaceDetail: SetupDiGetDeviceInstanceId: "));
        return FALSE;
    }

    // Allocate the buffer for the device instance ID (PnP string).
    pDeviceInstanceID = (PTSTR)LocalAlloc (LPTR, ulDeviceInstanceIdSize * sizeof (TCHAR));
    if (!pDeviceInstanceID)
    {
        dbgError (TEXT("GetDeviceInterfaceDetail: LocalAlloc: "));
        return FALSE;
    }
    
    // Now call again, this time with all parameters.
    fSuccess = SetupDiGetDeviceInstanceId (pPropPageRequest->DeviceInfoSet,
                                           pPropPageRequest->DeviceInfoData,
                                           pDeviceInstanceID,
                                           ulDeviceInstanceIdSize,
                                           NULL);
    // Check for error.
    if (!fSuccess)
    {
        dbgError (TEXT("GetDeviceInterfaceDetail: SetupDiGetDeviceInstanceId: "));
        LocalFree (pDeviceInstanceID);
        return FALSE;
    }

    // Now we can get the handle to the dev info with interface.
    // We parse the device specifically for topology interfaces.
    hDevInfoWithInterface = SetupDiGetClassDevs (&KSCATEGORY_TOPOLOGY,
                                                 pDeviceInstanceID,
                                                 NULL,
                                                 DIGCF_DEVICEINTERFACE);
    // We don't need pDeviceInstanceID anymore.
    LocalFree (pDeviceInstanceID);

    // Check for error.
    if (hDevInfoWithInterface == INVALID_HANDLE_VALUE)
    {
        dbgError (TEXT("GetDeviceInterfaceDetail: SetupDiGetClassDevs: "));
        return FALSE;
    }

    // Go through the list of topology device interface of this device.
    // We assume that there is only one topology device interface and
    // we will store the device details in our private structure.
    DeviceInterfaceData.cbSize = sizeof (DeviceInterfaceData);
    fSuccess = SetupDiEnumDeviceInterfaces (hDevInfoWithInterface,
                                            NULL,
                                            &KSCATEGORY_TOPOLOGY,
                                            0,
                                            &DeviceInterfaceData);
    // Check for error.
    if (!fSuccess)
    {
        dbgError (TEXT("GetDeviceInterfaceDetail: SetupDiEnumDeviceInterfaces: "));
        SetupDiDestroyDeviceInfoList (hDevInfoWithInterface);
        return FALSE;
    }

    // Get the details for this device interface.  The first call will retrieve
    // the buffer length in characters.  fSuccess will be FALSE.
    fSuccess = SetupDiGetDeviceInterfaceDetail (hDevInfoWithInterface,
                                                &DeviceInterfaceData,
                                                NULL,
                                                0,
                                                &ulDeviceInterfaceDetailDataSize,
                                                NULL);
    // Check for error.
    if ((GetLastError () != ERROR_INSUFFICIENT_BUFFER) || (!ulDeviceInterfaceDetailDataSize))
    {
        dbgError (TEXT("GetDeviceInterfaceDetail: SetupDiGetDeviceInterfaceDetail: "));
        SetupDiDestroyDeviceInfoList (hDevInfoWithInterface);
        return FALSE;
    }

    // Allocate the buffer for the device interface detail data.
    if (!(*ppDeviceInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)
            LocalAlloc (LPTR, ulDeviceInterfaceDetailDataSize)))
    {
        dbgError (TEXT("GetDeviceInterfaceDetail: LocalAlloc: "));
        SetupDiDestroyDeviceInfoList (hDevInfoWithInterface);
        return FALSE;
    }
    // The size contains only the structure, not the additional path.
    (*ppDeviceInterfaceDetailData)->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);

    // Get the details for this device interface, this time with all paramters.
    fSuccess = SetupDiGetDeviceInterfaceDetail (hDevInfoWithInterface,
                                                &DeviceInterfaceData,
                                                *ppDeviceInterfaceDetailData,
                                                ulDeviceInterfaceDetailDataSize,
                                                NULL,
                                                NULL);
    // We don't need the handle anymore.
    SetupDiDestroyDeviceInfoList (hDevInfoWithInterface);

    if (!fSuccess)
    {
        dbgError (TEXT("GetDeviceInterfaceDetail: SetupDiGetDeviceInterfaceDetail: "));
        LocalFree (*ppDeviceInterfaceDetailData), *ppDeviceInterfaceDetailData = NULL;
        return FALSE;
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////////
// AC97PropPageProvider
/////////////////////////////////////////////////////////////////////////////////
// This function gets called by the device manager when it asks for additional
// property sheet pages. The parameter fAddFunc is the function that we call to
// add the sheet page to the dialog.
// This routine gets called because the registry entry "EnumPropPage32" tells
// the device manager that there is a dll with a exported function that will add
// a property sheet page.
// Because we want to fail this function (not create the sheet) if the driver
// doesn't support the private property, we have to do all the work here, that
// means we open the device and get all the information, then we close the
// device and return.
//
// Arguments:
//    pPropPageRequest - points to SP_PROPSHEETPAGE_REQUEST
//    fAddFunc         - function ptr to call to add sheet.
//    lparam           - add sheet functions private data handle.
//
// Return Value:
//    BOOL: FALSE if pages could not be added, TRUE on success
BOOL APIENTRY AC97PropPageProvider
(
    PSP_PROPSHEETPAGE_REQUEST   pPropPageRequest,
    LPFNADDPROPSHEETPAGE        fAddFunc,
    LPARAM                      lParam
)
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA pDeviceInterfaceDetailData;
    tAC97Features                    *pAC97Features;
    PROPSHEETPAGE                    PropSheetPage;
    HPROPSHEETPAGE                   hPropSheetPage;

    // Check page requested
    if (pPropPageRequest->PageRequested != SPPSR_ENUM_ADV_DEVICE_PROPERTIES)
    {
        return FALSE;
    }

    // Check device info set and data
    if ((!pPropPageRequest->DeviceInfoSet) || (!pPropPageRequest->DeviceInfoData))
    {
        return FALSE;
    }

    // Allocate the memory for the AC97 features.
    pAC97Features = (tAC97Features *) LocalAlloc (LPTR, sizeof (tAC97Features));
    if (!pAC97Features)
    {
        dbgError (TEXT("AC97PropPageProvider: LocalAlloc: "));
        return FALSE;
    }
    
    // Get the device interface detail which return a path to the device
    // driver that we need to open the device.
    if (!GetDeviceInterfaceDetail (pPropPageRequest, &pDeviceInterfaceDetailData))
    {
        LocalFree (pAC97Features);
        return FALSE;
    }

    // Get the AC97 features through the private property call.
    if (!GetAC97Features (pDeviceInterfaceDetailData, pAC97Features))
    {
        LocalFree (pDeviceInterfaceDetailData);
        LocalFree (pAC97Features);
        return FALSE;
    }

#ifdef PROPERTY_SHOW_SET
    // Show how we would set something in the driver
    AC97ShowSet (pDeviceInterfaceDetailData);
#endif
    
    // We don't need the device interface details any more, get rid of it now!
    LocalFree (pDeviceInterfaceDetailData);

    // initialize the property page
    PropSheetPage.dwSize        = sizeof(PROPSHEETPAGE);
    PropSheetPage.dwFlags       = 0;
    PropSheetPage.hInstance     = ghInstance;
    PropSheetPage.pszTemplate   = MAKEINTRESOURCE(DLG_AC97FEATURES);
    PropSheetPage.pfnDlgProc    = AC97DlgProc;
    PropSheetPage.lParam        = (LPARAM)pAC97Features;
    PropSheetPage.pfnCallback   = NULL;

    // create the page and get back a handle
    hPropSheetPage = CreatePropertySheetPage (&PropSheetPage);
    if (!hPropSheetPage)
    {
        LocalFree (pAC97Features);
        return FALSE;
    }

    // add the property page
    if (!(*fAddFunc)(hPropSheetPage, lParam))
    {
        DestroyPropertySheetPage (hPropSheetPage);
        LocalFree (pAC97Features);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\clist.h ===
//      Copyright (c) Microsoft Corporation	1996-1999.  All rights reserved.
//
//      clist.h
//

#ifndef __CLIST_H__
#define __CLIST_H__

/*****************************************************************************
 * class CListItem
 *****************************************************************************
 * Generic item within a CList class.
 */
class CListItem
{
public:
    CListItem() { m_pNext=NULL; };

    CListItem *GetNext() const {return m_pNext;};
    void SetNext(CListItem *pNext) {m_pNext=pNext;};
    
    LONG GetCount() const;
    BOOL IsMember(CListItem *pItem);
    
    CListItem* Cat(CListItem* pItem);
    CListItem* AddTail(CListItem* pItem) {pItem->SetNext(NULL); return Cat(pItem);};
    CListItem* Remove(CListItem* pItem);
    
    CListItem* GetPrev(CListItem *pItem) const;
    CListItem* GetItem(LONG index);

private:
    CListItem *m_pNext;
};

/*****************************************************************************
 * class CList
 *****************************************************************************
 * Generic list object (containing CListItem objects).
 */
class CList
{
public:
    CList() {m_pHead=NULL;};
    CListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    
    LONG GetCount() const {return m_pHead->GetCount();}; 
    CListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(CListItem *pItem,CListItem *pInsert);
    
    void Cat(CListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(CList *pList)
    {
        m_pHead=m_pHead->Cat(pList->GetHead());
    };
    
    void AddHead(CListItem *pItem)
    {
        ASSERT(m_pHead != pItem);
        pItem->SetNext(m_pHead);
        m_pHead=pItem;
    }
    void AddTail(CListItem *pItem) {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(CListItem *pItem) {m_pHead=m_pHead->Remove(pItem);};
    
    CListItem *GetPrev(CListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    CListItem *GetTail() const {return GetPrev(NULL);};
    
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    BOOL IsMember(CListItem *pItem) {return (m_pHead->IsMember(pItem));};

    CListItem *RemoveHead(void)
    {
        CListItem *li;
        li=m_pHead;
        if(m_pHead)
            m_pHead=m_pHead->GetNext();
        if (li)
            li->SetNext(NULL);
        return li;
    }

protected:
    CListItem *m_pHead;
};

#endif // __CLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\csynth.cpp ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//      CSynth.cpp
//

#include "common.h"
#include "fltsafe.h"

#define STR_MODULENAME "DDKSynth.sys:CSynth: "

#pragma code_seg()
/*****************************************************************************
 * CSynth::CSynth()
 *****************************************************************************
 * Contructor for CSynth object.  Initialize the voice list, the stereo mode,
 * sample rate, performance statistics, etc.
 */
CSynth::CSynth()
{
    FLOATSAFE fs;

    DWORD nIndex;
    CVoice *pVoice;

    m_fCSInitialized = FALSE;
    ::InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;

    for (nIndex = 0;nIndex < MAX_NUM_VOICES;nIndex++)
    {
        pVoice = new CVoice;
        if (pVoice != NULL)
        {
            m_VoicesFree.AddHead(pVoice);
        }
    }
    for (nIndex = 0;nIndex < NUM_EXTRA_VOICES;nIndex++)
    {
        pVoice = new CVoice;
        if (pVoice != NULL)
        {
            m_VoicesExtra.AddHead(pVoice);
        }
    }
	m_ppControl = NULL;
	m_dwControlCount = 0;
    m_nMaxVoices = MAX_NUM_VOICES;
    m_nExtraVoices = NUM_EXTRA_VOICES; 
    m_stLastStats = 0;
    m_fAllowPanWhilePlayingNote = TRUE;
    m_fAllowVolumeChangeWhilePlayingNote = TRUE;
    ResetPerformanceStats();
    m_dwSampleRate = 22050;
    m_dwStereo = 1;
	m_stLastTime = 0;    
	SetSampleRate(SAMPLE_RATE_22);
    SetStereoMode(2);
    SetGainAdjust(600);
}

/*****************************************************************************
 * CSynth::~CSynth()
 *****************************************************************************
 * Destructor for CSynth object.  Delete the voices in the lists.
 */
CSynth::~CSynth()
{
    CVoice *pVoice;
    if (m_fCSInitialized)
    {
        // If CS never initialized, nothing else will have been set up
        //
        Close();

        while (pVoice = m_VoicesInUse.RemoveHead())
        {
            delete pVoice;
        }
        while (pVoice = m_VoicesFree.RemoveHead())
        {
            delete pVoice;
        }
        while (pVoice = m_VoicesExtra.RemoveHead())
        {
            delete pVoice;
        }
        DeleteCriticalSection(&m_CriticalSection);
    }
}

/*****************************************************************************
 * ChangeVoiceCount()
 *****************************************************************************
 * Change the number of voices in a given voice list.
 */
static short ChangeVoiceCount(CVoiceList *pList,short nOld,short nCount)
{
    if (nCount > nOld)
    {
        short nNew = nCount - nOld;
        for (;nNew != 0; nNew--)
        {
            CVoice *pVoice = new CVoice;
            if (pVoice != NULL)
            {
                pList->AddHead(pVoice);
            }
        }
    }
    else
    {
        short nNew = nOld - nCount;
        for (;nNew > 0; nNew--)
        {
            CVoice *pVoice = pList->RemoveHead();
            if (pVoice != NULL)
            {
                delete pVoice;
            }
            else 
            {
                nCount += nNew;
                break;
            }
        }
    }
    return nCount;
}

/*****************************************************************************
 * CSynth::SetMaxVoices()
 *****************************************************************************
 * Set the maximum number of voices available.
 */
HRESULT CSynth::SetMaxVoices(short nVoices,short nTempVoices)
{
    if (nVoices < 1)
    {
        nVoices = 1;
    }
    if (nTempVoices < 1)
    {
        nTempVoices = 1;
    }
    ::EnterCriticalSection(&m_CriticalSection);
    m_nMaxVoices = ChangeVoiceCount(&m_VoicesFree,m_nMaxVoices,nVoices);
    m_nExtraVoices = ChangeVoiceCount(&m_VoicesExtra,m_nExtraVoices,nTempVoices);
    ::LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

/*****************************************************************************
 * CSynth::SetNumChannelGroups()
 *****************************************************************************
 * Set the number of channel groups (virtual MIDI cables).  For each channel 
 * group, there is a separate CControlLogic object.
 */
HRESULT CSynth::SetNumChannelGroups(DWORD dwCableCount)
{
	HRESULT hr = S_OK;
	CControlLogic **ppControl;
	if ((dwCableCount < 1) || (dwCableCount > MAX_CHANNEL_GROUPS))
	{
		return E_INVALIDARG;
	}

    ::EnterCriticalSection(&m_CriticalSection);
	if (m_dwControlCount != dwCableCount)
	{
		ppControl = new(NonPagedPool,'PSmD') CControlLogic *[dwCableCount]; //  DmSP
		if (ppControl)
		{
			DWORD dwX;
			for (dwX = 0; dwX < dwCableCount; dwX++)
			{
				ppControl[dwX] = NULL;
			}
			if (m_dwControlCount < dwCableCount)
			{
				for (dwX = 0; dwX < m_dwControlCount; dwX++)
				{
					ppControl[dwX] = m_ppControl[dwX];
				}
				for (;dwX < dwCableCount; dwX++)
				{
					ppControl[dwX] = new(NonPagedPool,'CSmD') CControlLogic;    //  DmSC
					if (ppControl[dwX])
					{
						hr = ppControl[dwX]->Init(&m_Instruments, this);
						if (FAILED(hr))
						{
							delete ppControl[dwX];
							ppControl[dwX] = NULL;
							dwCableCount = dwX;
							break;
						}

                        ppControl[dwX]->SetGainAdjust(m_vrGainAdjust);
					}
					else
					{
						dwCableCount = dwX;
						break;
					}
				}
			}
			else
			{
				AllNotesOff();
				for (dwX = 0; dwX < dwCableCount; dwX++)
				{
					ppControl[dwX] = m_ppControl[dwX];
				}
				for (; dwX < m_dwControlCount; dwX++)
				{
					if (m_ppControl[dwX])
					{
						delete m_ppControl[dwX];
					}
				}
			}
			if (m_ppControl)
			{
				delete m_ppControl;
			}
			m_ppControl = ppControl;
			m_dwControlCount = dwCableCount;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
    ::LeaveCriticalSection(&m_CriticalSection);
    
	return hr;
}

/*****************************************************************************
 * CSynth::SetGainAdjust()
 *****************************************************************************
 * Set the gain for the overall synth.  Set gain on each CControlLogic object.
 */
void CSynth::SetGainAdjust(VREL vrGainAdjust)
{
    DWORD idx;

    m_vrGainAdjust = vrGainAdjust;
	::EnterCriticalSection(&m_CriticalSection);
    
    for (idx = 0; idx < m_dwControlCount; idx++)
    {
        m_ppControl[idx]->SetGainAdjust(m_vrGainAdjust);
    }

    ::LeaveCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CSynth::Open()
 *****************************************************************************
 * Open the synth with the given number of channel groups.
 */
HRESULT CSynth::Open(DWORD dwCableCount, DWORD dwVoices)
{
	HRESULT hr = S_OK;
	if ((dwCableCount < 1) || (dwCableCount > MAX_CHANNEL_GROUPS))
	{
		return E_INVALIDARG;
	}
    ::EnterCriticalSection(&m_CriticalSection);
	hr = SetNumChannelGroups(dwCableCount);
	if (SUCCEEDED(hr))
	{
		short nTemp = (short) dwVoices / 4;
		if (nTemp < 4) nTemp = 4;
		SetMaxVoices((short) dwVoices, nTemp);
	}


    m_vrGainAdjust = 0;
    ::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}

/*****************************************************************************
 * CSynth::Close()
 *****************************************************************************
 * Close down the synth:, silence it, delete the list of CControlLogic objects.
 */
HRESULT CSynth::Close()
{
    ::EnterCriticalSection(&m_CriticalSection);
	AllNotesOff();
	DWORD dwX;
	for (dwX = 0; dwX < m_dwControlCount; dwX++)
	{
		if (m_ppControl[dwX])
		{
			delete m_ppControl[dwX];
		}
	}
	m_dwControlCount = 0;
	if (m_ppControl)
	{
		delete [] m_ppControl;
		m_ppControl = NULL;
	}
    m_stLastStats = 0;
	m_stLastTime = 0;


    ::LeaveCriticalSection(&m_CriticalSection);
	return S_OK;
}
   
/*****************************************************************************
 * CSynth::GetMaxVoices()
 *****************************************************************************
 * Returns the maximum number of voices available.
 */
HRESULT CSynth::GetMaxVoices( 
    short * pnMaxVoices,    // Returns maximum number of allowed voices for continuous play.
    short * pnTempVoices )  // Returns number of extra voices for voice overflow.
{
    if (pnMaxVoices != NULL)
    {
        *pnMaxVoices = m_nMaxVoices;
    }
    if (pnTempVoices != NULL)
    {
        *pnTempVoices = m_nExtraVoices;
    }
    return S_OK;
}

/*****************************************************************************
 * CSynth::SetSampleRate()
 *****************************************************************************
 * Set the sample rate of the synth.  This silences the synth.  The SR is 
 * forwarded to the instrument manager.
 */
HRESULT CSynth::SetSampleRate(DWORD dwSampleRate)     
{
    HRESULT hr = S_OK;
	::EnterCriticalSection(&m_CriticalSection);
	AllNotesOff();
	m_stLastTime *= dwSampleRate;
	m_stLastTime /= m_dwSampleRate;
	// m_stLastTime = MulDiv(m_stLastTime,dwSampleRate,m_dwSampleRate);
	m_stLastStats = 0;
	m_dwSampleRate = dwSampleRate;
	m_stMinSpan = dwSampleRate / 100;   // 10 ms.
	m_stMaxSpan = (dwSampleRate + 19) / 20;    // 50 ms.
	::LeaveCriticalSection(&m_CriticalSection);
	m_Instruments.SetSampleRate(dwSampleRate);
    return hr;
}

/*****************************************************************************
 * CSynth::Activate()
 *****************************************************************************
 * Make the synth active.
 */
HRESULT CSynth::Activate(DWORD dwSampleRate, DWORD dwChannels )
{
	m_stLastTime = 0;
	SetSampleRate(dwSampleRate);
	SetStereoMode(dwChannels);
	ResetPerformanceStats();
	return S_OK;
}

/*****************************************************************************
 * CSynth::Deactivate()
 *****************************************************************************
 * Gag the synth.
 */
HRESULT CSynth::Deactivate()
{
	AllNotesOff();
	return S_OK;
}

/*****************************************************************************
 * CSynth::GetPerformanceStats()
 *****************************************************************************
 * Get the latest perf statistics.
 */
HRESULT CSynth::GetPerformanceStats(PerfStats *pStats)
{
    if (pStats == NULL)
    {
        return E_POINTER;
    }
    *pStats = m_CopyStats;
    return (S_OK);
}

/*****************************************************************************
 * CSynth::Mix()
 *****************************************************************************
 * Mix into the given buffer.  This is called by Render in the software
 * synth case, or this could be called by a request from hardware.
 */
void CSynth::Mix(short *pBuffer,DWORD dwLength,LONGLONG llPosition)
{
    PAGED_CODE();

    FLOATSAFE fs;

    STIME stEndTime;
    CVoice *pVoice;
    CVoice *pNextVoice;
    long lNumVoices = 0;
    ::EnterCriticalSection(&m_CriticalSection);

    LONG    lTime = - (LONG)::GetTheCurrentTime();

    stEndTime = llPosition + dwLength;
	StealNotes(stEndTime);
	DWORD dwX;
	for (dwX = 0; dwX < m_dwControlCount; dwX++)
	{
		m_ppControl[dwX]->QueueNotes(stEndTime);
	}
    pVoice = m_VoicesInUse.GetHead();
    for (;pVoice != NULL;pVoice = pNextVoice)
    {
        pNextVoice = pVoice->GetNext();

        pVoice->Mix(pBuffer,dwLength,llPosition,stEndTime);
        lNumVoices++;

        if (pVoice->m_fInUse == FALSE) 
        {
            m_VoicesInUse.Remove(pVoice);
            m_VoicesFree.AddHead(pVoice);
           // m_BuildStats.dwTotalSamples += (pVoice->m_stStopTime - pVoice->m_stStartTime);
			if (pVoice->m_stStartTime < m_stLastStats)
			{
				m_BuildStats.dwTotalSamples += (long) (pVoice->m_stStopTime - m_stLastStats);
			}
			else
			{
				m_BuildStats.dwTotalSamples += (long) (pVoice->m_stStopTime - pVoice->m_stStartTime);
			}
        }
    }
	for (dwX = 0; dwX < m_dwControlCount; dwX++)
	{
		m_ppControl[dwX]->ClearMIDI(stEndTime);
	}
    FinishMix(pBuffer,dwLength);
    if (stEndTime > m_stLastTime)
    {
        m_stLastTime = stEndTime;
    }
    lTime += ::GetTheCurrentTime();

    m_BuildStats.dwTotalTime += lTime;

    if ((m_stLastStats + m_dwSampleRate) <= m_stLastTime)
    {
        DWORD dwElapsed = (DWORD) (m_stLastTime - m_stLastStats);
		pVoice = m_VoicesInUse.GetHead();
		for (;pVoice != NULL;pVoice = pVoice->GetNext())
		{
			if (pVoice->m_stStartTime < m_stLastStats)
			{
				m_BuildStats.dwTotalSamples += dwElapsed;
			}
			else
			{
				m_BuildStats.dwTotalSamples += (long) (m_stLastTime - pVoice->m_stStartTime);
			}
		}
        if (dwElapsed == 0) dwElapsed = 1;
        if (m_BuildStats.dwTotalSamples == 0) m_BuildStats.dwTotalSamples = 1;
        m_BuildStats.dwVoices = 
            (m_BuildStats.dwTotalSamples + (dwElapsed >> 1)) / dwElapsed;
		{
			m_BuildStats.dwCPU = MulDiv(m_BuildStats.dwTotalTime,
				m_dwSampleRate, dwElapsed);
		}
        m_CopyStats = m_BuildStats;
        RtlZeroMemory(&m_BuildStats, sizeof(m_BuildStats));
        m_stLastStats = m_stLastTime;
    }
    ::LeaveCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CSynth::OldestVoice()
 *****************************************************************************
 * Get the most likely candidate to be shut down, to support voice stealing.
 * Priority is looked at first, then age.
 */
CVoice *CSynth::OldestVoice()
{
    CVoice *pVoice;
    CVoice *pBest = NULL;
    pVoice = m_VoicesInUse.GetHead();
    pBest = pVoice;
    if (pBest)
    {
        pVoice = pVoice->GetNext();
        for (;pVoice;pVoice = pVoice->GetNext())
        {
		    if (!pVoice->m_fTag)
		    {
			    if (pBest->m_fTag)
			    {
				    pBest = pVoice;
			    }
			    else
			    {
                    if (pVoice->m_dwPriority <= pBest->m_dwPriority)
                    {
				        if (pVoice->m_fNoteOn) 
				        {
					        if (pBest->m_fNoteOn)
					        {
						        if (pBest->m_stStartTime > pVoice->m_stStartTime)
						        {
							        pBest = pVoice;
						        }
					        }
				        }
				        else
				        {
					        if (pBest->m_fNoteOn ||
						        (pBest->m_vrVolume > pVoice->m_vrVolume))
					        {
						        pBest = pVoice;
					        }
				        }
                    }
			    }
		    }
        }
        if (pBest->m_fTag)
        {
            pBest = NULL;
        }
    }
    return pBest;
}

/*****************************************************************************
 * CSynth::StealVoice()
 *****************************************************************************
 * Steal a voice, if possible.  If none are at or below this priority, then
 * return NULL, and this voice will go unheard.  If there IS a voice to be 
 * stolen, silence it first.
 */
CVoice *CSynth::StealVoice(DWORD dwPriority)
{
    CVoice *pVoice;
    CVoice *pBest = NULL;
    pVoice = m_VoicesInUse.GetHead();
    for (;pVoice != NULL;pVoice = pVoice->GetNext())
    {
        if (pVoice->m_dwPriority <= dwPriority)
        {
            if (!pBest)
            {
                pBest = pVoice;
            }
            else
            {
                if (pVoice->m_fNoteOn == FALSE) 
                {
                    if ((pBest->m_fNoteOn == TRUE) ||
                        (pBest->m_vrVolume > pVoice->m_vrVolume))
                    {
                        pBest = pVoice;
                    }
                }
                else
                {
                    if (pBest->m_stStartTime > pVoice->m_stStartTime)
                    {
                        pBest = pVoice;
                    }
                }
            }
        }
    }
    if (pBest != NULL)
    {
        pBest->ClearVoice();
        pBest->m_fInUse = FALSE; 
        m_VoicesInUse.Remove(pBest);
        pBest->SetNext(NULL);
    }
    return pBest;
}

/*****************************************************************************
 * CSynth::QueueVoice()
 *****************************************************************************
 * This method queues a voice in the list of currently 
 * synthesizing voices. It places them in the queue so that
 * the higher priority voices are later in the queue. This
 * allows the note stealing algorithm to take off the top of
 * the queue.
 * And, we want older playing notes to be later in the queue
 * so the note ons and offs overlap properly. So, the queue is
 * sorted in priority order with older notes later within one
 * priority level.
 */
void CSynth::QueueVoice(CVoice *pVoice)
{
    CVoice *pScan = m_VoicesInUse.GetHead();
    CVoice *pNext = NULL;
    if (!pScan) // Empty list?
    {
        m_VoicesInUse.AddHead(pVoice);
        return;
    }
    if (pScan->m_dwPriority > pVoice->m_dwPriority)
    {   // Are we lower priority than the head of the list?
        m_VoicesInUse.AddHead(pVoice);
        return;
    }

    pNext = pScan->GetNext();
    for (;pNext;)
    {
        if (pNext->m_dwPriority > pVoice->m_dwPriority)
        {
            // Lower priority than next in the list.
            pScan->SetNext(pVoice);
            pVoice->SetNext(pNext);
            return;
        }
        pScan = pNext;
        pNext = pNext->GetNext();
    }
    // Reached the end of the list.
    pScan->SetNext(pVoice);
    pVoice->SetNext(NULL);
}

/*****************************************************************************
 * CSynth::StealNotes()
 *****************************************************************************
 * Clear out notes at a given time.
 */
void CSynth::StealNotes(STIME stTime)
{
    CVoice *pVoice;
    long lToMove = m_nExtraVoices - m_VoicesExtra.GetCount();
    if (lToMove > 0)
    {
        for (;lToMove > 0;)
        {
            pVoice = m_VoicesFree.RemoveHead();
            if (pVoice != NULL)
            {
                m_VoicesExtra.AddHead(pVoice);
                lToMove--;
            }
            else break;
        }
        if (lToMove > 0)
        {
            pVoice = m_VoicesInUse.GetHead();
            for (;pVoice;pVoice = pVoice->GetNext())
            {
                if (pVoice->m_fTag) // Voice is already slated to be returned.
                {
                    lToMove--;
                }
            }
            for (;lToMove > 0;lToMove--)
            {
                pVoice = OldestVoice();
                if (pVoice != NULL)
                {
                    pVoice->QuickStopVoice(stTime);
				    m_BuildStats.dwNotesLost++;
                }
                else break;
            }
        }
    }
}


/*****************************************************************************
 * CSynth::FinishMix()
 *****************************************************************************
 * Cleanup after the mix.
 */
void CSynth::FinishMix(short *pBuffer,DWORD dwLength)
{
    DWORD dwIndex;
	long lMax = (long) m_BuildStats.dwMaxAmplitude;
	long lTemp;
    for (dwIndex = 0; dwIndex < (dwLength << m_dwStereo); dwIndex++)
    {
		lTemp = pBuffer[dwIndex];
		lTemp <<= 1;
		if (lTemp < -32767) lTemp = -32767;
		if (lTemp > 32767) lTemp = 32767;
		pBuffer[dwIndex] = (short) lTemp;
		if (lTemp > lMax)
		{
			lMax = lTemp;
		}
    }
	m_BuildStats.dwMaxAmplitude = lMax;
}

/*****************************************************************************
 * CSynth::Unload()
 *****************************************************************************
 * Unload a previous download.  Forward the request to the instrument manager.
 */
HRESULT CSynth::Unload(HANDLE hDownload,
					   HRESULT ( CALLBACK *lpFreeMemory)(HANDLE,HANDLE),
					   HANDLE hUserData)
{
	return m_Instruments.Unload( hDownload, lpFreeMemory, hUserData);
}

/*****************************************************************************
 * CSynth::Download()
 *****************************************************************************
 * Handle a download.  Forward the request to the instrument manager.
 */
HRESULT CSynth::Download(LPHANDLE phDownload, void * pdwData, LPBOOL bpFree) 
{
    FLOATSAFE fs;

	return m_Instruments.Download( phDownload, (DWORD *) pdwData,  bpFree);
}

/*****************************************************************************
 * CSynth::PlayBuffer()
 *****************************************************************************
 * This receives one MIDI message in the form of a buffer of data and
 * ulCable, which indicates which Channel Group the message is addressed 
 * to. Each channel group is implemented with an instance of a CControlLogic
 * object, so this chooses which CControlLogic object to send the message
 * to. If ulCable is 0, this is a broadcast message and should be sent to all
 * CControlLogics.
 * 
 * PlayBuffer() analyzes the message and, depending on the size, either
 * sends to CControlLogic::RecordMIDI() or CControlLogic::RecordSysEx().
 * 
 * In order to properly associate the time stamp of the MIDI 
 * message in the buffer, the synth needs to convert from the
 * REFERENCE_TIME format to its internal sample based time. Since
 * the wave out stream is actually managed by IDirectMusicSynthSink,
 * the synth calls IDirectMusicSynthSink::RefTimeToSample
 * for each MIDI message to convert its time stamp into sample time.
 *
 * So, typically, the synthesizer pulls each MIDI message from the
 * buffer, stamps it in sample time, then places it in its own
 * internal queue. The queue is emptied later by the rendering
 * process, which is managed by CDmSynthStream::Render and
 * called by IDirectMusicSynthSink.
 */
HRESULT	CSynth::PlayBuffer(IDirectMusicSynthSink *pSynthSink,REFERENCE_TIME rt, 
                           LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable)
{
	STIME stTime;

	::EnterCriticalSection(&m_CriticalSection);

	if ( rt == 0 ) // Special case of time == 0.
	{
		stTime = m_stLastTime;
	}
	else
	{
		pSynthSink->RefTimeToSample(rt, &stTime);
	}

    if (cbBuffer <= sizeof(DWORD))
    {
		if (ulCable <= m_dwControlCount)
		{
			if (ulCable == 0) // Play all groups if 0.
			{
				for (; ulCable < m_dwControlCount; ulCable++)
				{
					m_ppControl[ulCable]->RecordMIDI(stTime,lpBuffer[0], 
						lpBuffer[1], lpBuffer[2]);
				}
			}
			else
			{
				m_ppControl[ulCable - 1]->RecordMIDI(stTime,lpBuffer[0], 
				lpBuffer[1], lpBuffer[2]);

			}
		}
        else
        {
            Trace(1,"MIDI event on channel group %ld is beyond range of %ld opened channel groups\n",
                ulCable, m_dwControlCount);
        }
    }
    else
    {
		if (ulCable <= m_dwControlCount)
		{
			if (ulCable == 0)
			{
				for (; ulCable < m_dwControlCount; ulCable++)
				{
					m_ppControl[ulCable]->RecordSysEx(cbBuffer,
						&lpBuffer[0], stTime);
				}
			}
			else
			{
				m_ppControl[ulCable-1]->RecordSysEx(cbBuffer,
					&lpBuffer[0], stTime);
			}
		}
	}

	::LeaveCriticalSection(&m_CriticalSection);
	return S_OK;
}

/*****************************************************************************
 * CSynth::SetStereoMode()
 *****************************************************************************
 * Set the stereo/mono mode for this synth.
 */
HRESULT CSynth::SetStereoMode(DWORD dwChannels)   // 1 for Mono, 2 for Stereo.
{
    HRESULT hr = S_OK;
    if ((m_dwStereo + 1) != dwChannels)
    {
		DWORD dwStereo;
		if (dwChannels > 1) dwStereo = 1;
		else dwStereo = 0;
		if (dwStereo != m_dwStereo)
		{
			m_dwStereo = dwStereo;
		}
    }
    return hr;
}

/*****************************************************************************
 * CSynth::ResetPerformanceStats()
 *****************************************************************************
 * Reset the running performance statistics.
 */
void CSynth::ResetPerformanceStats()
{
    m_BuildStats.dwNotesLost = 0;
    m_BuildStats.dwTotalTime = 0;
    m_BuildStats.dwVoices = 0;
    m_BuildStats.dwTotalSamples = 0;
    m_BuildStats.dwCPU = 0;
    m_BuildStats.dwMaxAmplitude = 0;
    m_CopyStats = m_BuildStats;
}

/*****************************************************************************
 * CSynth::AllNotesOff()
 *****************************************************************************
 * Stop all voices.
 */
HRESULT CSynth::AllNotesOff()
{
    CVoice *pVoice;
    ::EnterCriticalSection(&m_CriticalSection);
    while (pVoice = m_VoicesInUse.RemoveHead())
    {
        pVoice->ClearVoice();
        pVoice->m_fInUse = FALSE; 
        m_VoicesFree.AddHead(pVoice);

        long lSamples;

        if (pVoice->m_stStartTime < m_stLastStats)
        {
            lSamples = (long) (pVoice->m_stStopTime - m_stLastStats);
        }
        else
        {
            lSamples = (long) (pVoice->m_stStopTime - pVoice->m_stStartTime);
        }
        if (lSamples < 0) 
        {
            lSamples = 0;
        }
        m_BuildStats.dwTotalSamples += lSamples;
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    return (S_OK);
}

/*****************************************************************************
 * CSynth::SetChannelPriority()
 *****************************************************************************
 * Set the priority for a given channel, to be used in voice stealing.
 */
HRESULT CSynth::SetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,
                                   DWORD dwPriority)
{
	HRESULT hr = S_OK;

	::EnterCriticalSection(&m_CriticalSection);
    
    dwChannelGroup--;
	if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
	{
		hr = E_INVALIDARG;
	}
	else
	{
		if (m_ppControl)
		{
			hr = m_ppControl[dwChannelGroup]->SetChannelPriority(dwChannel,dwPriority);
		}
	}
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

/*****************************************************************************
 * CSynth::GetChannelPriority()
 *****************************************************************************
 * Retrieve the priority of a given channel/channel group, to be used to
 * facilitate correct voice stealing.
 */
HRESULT CSynth::GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, 
                                   LPDWORD pdwPriority)
{
	HRESULT hr = S_OK;

	::EnterCriticalSection(&m_CriticalSection);

    dwChannelGroup--;
	if ((dwChannelGroup >= m_dwControlCount) || (dwChannel > 15))
	{
		hr = E_INVALIDARG;
	}
	else
	{
		if (m_ppControl)
		{
			hr = m_ppControl[dwChannelGroup]->GetChannelPriority(dwChannel,pdwPriority);
		}
	}
    ::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\kernhelp.cpp ===
/*
    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.
*/

//
// KernHelp.cpp
//
// Wrappers for kernel functions to make synth core cross compilable
//

#define STR_MODULENAME "DDKSynth.sys:KernHelp: "

extern "C" {
#include <wdm.h>
};

#include "ksdebug.h"
#include "KernHelp.h"

#pragma code_seg()
/*****************************************************************************
 * InitializeCriticalSection()
 *****************************************************************************
 * In kernel mode, we use a KMUTEX to implement our critical section.
 * Initialize the KMUTEX.
 */
VOID InitializeCriticalSection(LPCRITICAL_SECTION CritSect)
{
    KeInitializeMutex((PKMUTEX)CritSect, 1);
}

/*****************************************************************************
 * EnterCriticalSection()
 *****************************************************************************
 * In kernel mode, we use a KMUTEX to implement our critical section.
 * Grab (wait for) the KMUTEX.
 */
VOID EnterCriticalSection(LPCRITICAL_SECTION CritSect)
{
    KeWaitForSingleObject((PKMUTEX)CritSect,
                          Executive,
                          KernelMode,
                          FALSE,
                          0);

}

/*****************************************************************************
 * LeaveCriticalSection()
 *****************************************************************************
 * In kernel mode, we use a KMUTEX to implement our critical section.
 * Release the KMUTEX.
 */
VOID LeaveCriticalSection(LPCRITICAL_SECTION CritSect)
{
    KeReleaseMutex((PKMUTEX)CritSect, FALSE);
}

/*****************************************************************************
 * DeleteCriticalSection()
 *****************************************************************************
 * In kernel mode, we use a KMUTEX to implement our critical section.
 * No need to delete anything.
 */
VOID DeleteCriticalSection(LPCRITICAL_SECTION CritSect)
{
    // NOP in kernel
    //
}

// GetRegValueDword
//
// Must be called at passive level
//
/*****************************************************************************
 * GetRegValueDword()
 *****************************************************************************
 * Convenience function to encapsulate registry reads.
 */
int GetRegValueDword(LPTSTR RegPath,LPTSTR ValueName,PULONG Value)
{
    int                             ReturnValue = 0;
    NTSTATUS                        Status;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    HANDLE                          KeyHandle;
    KEY_VALUE_PARTIAL_INFORMATION   *Information;
    ULONG                           InformationSize;
    UNICODE_STRING                  UnicodeRegPath;
    UNICODE_STRING                  UnicodeValueName;

    RtlInitUnicodeString(&UnicodeRegPath, RegPath);
    RtlInitUnicodeString(&UnicodeValueName, ValueName);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeRegPath,
                               OBJ_KERNEL_HANDLE,           // Flags
                               NULL,        // Root directory
                               NULL);       // Security descriptor

    Status = ZwOpenKey(&KeyHandle,
                       KEY_QUERY_VALUE,
                       &ObjectAttributes);
    if (Status != STATUS_SUCCESS)
    {
        return 0;
    }

    InformationSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG);
    Information = (KEY_VALUE_PARTIAL_INFORMATION*)ExAllocatePoolWithTag(PagedPool, InformationSize,'ISmD'); //  DmSI

    if (Information == NULL)
    {
        ZwClose(KeyHandle);
        return 0;
    }

    Status = ZwQueryValueKey(KeyHandle,
                             &UnicodeValueName,
                             KeyValuePartialInformation,
                             Information,
                             sizeof(Information),
                             &InformationSize);
    if (Status == STATUS_SUCCESS)
    {
        if (Information->Type == REG_DWORD && Information->DataLength == sizeof(ULONG))
        {
            RtlCopyMemory(Value, Information->Data, sizeof(ULONG));
            ReturnValue = 1;
        }
    }

    ExFreePool(Information);
    ZwClose(KeyHandle);

    return ReturnValue;
}

/*****************************************************************************
 * GetTheCurrentTime()
 *****************************************************************************
 * Get the current time, in milliseconds (KeQuerySystemTime returns units of
 * 100ns each).
 */
ULONG GetTheCurrentTime()
{
    LARGE_INTEGER Time;

    KeQuerySystemTime(&Time);

    return (ULONG)(Time.QuadPart / (10 * 1000));
}


/*****************************************************************************
 * KernHelpGetSysAddrForMdl()
 *****************************************************************************
 * Safely map the MDL to system address space. This mapping
 * may fail "when the system runs out of system PTEs", and
 * without the flag set below, this condition causes a bugcheck
 * rather than a NULL return.
 */
PVOID KernHelpGetSysAddrForMdl(PMDL pMdl)
{
    PVOID MappedAddress;

#if UNDER_NT

    MappedAddress = MmGetSystemAddressForMdlSafe(pMdl,NormalPagePriority);

#else // !UNDER_NT

    CSHORT LocalCopyOfMdlFlagBit;
    //
    // Note the manipulation of the MDL flags is only done if needed.
    // The driver is responsible for ensuring that it is not simultaneously
    // modifying this field anywhere else and synchronizing if needed.
    //
    LocalCopyOfMdlFlagBit = (pMdl->MdlFlags & MDL_MAPPING_CAN_FAIL);

    if (LocalCopyOfMdlFlagBit == 0)
    {
        pMdl->MdlFlags |= MDL_MAPPING_CAN_FAIL;
    }

    MappedAddress = MmGetSystemAddressForMdl(pMdl);

    //
    // Carefully restore only the single "can-fail" bit state.  This is
    // because the call above will change the state of other flag bits and
    // we don't want this restore to wipe out those changes.  Wiping out the
    // other changes will cause not-so-obvious effects like eventually
    // exhausting the system PTE pool and other resources, which will crash
    // the entire system.
    //
    if (LocalCopyOfMdlFlagBit == 0)
    {
        pMdl->MdlFlags &= ~MDL_MAPPING_CAN_FAIL;
    }

#endif // !UNDER_NT

    return MappedAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\kernhelp.h ===
/*
    Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.
*/

#ifndef _KernHelp_
#define _KernHelp_

// Use kernel mutex to implement critical section
//
typedef KMUTEX CRITICAL_SECTION;
typedef CRITICAL_SECTION *LPCRITICAL_SECTION;

VOID InitializeCriticalSection( LPCRITICAL_SECTION);
VOID EnterCriticalSection(      LPCRITICAL_SECTION);
VOID LeaveCriticalSection(      LPCRITICAL_SECTION);
VOID DeleteCriticalSection(     LPCRITICAL_SECTION);

// We have very little registry work to do, so just encapsulate the
// entire process
//
int GetRegValueDword(LPTSTR RegPath,LPTSTR ValueName,PULONG Value);

ULONG GetTheCurrentTime();

PVOID KernHelpGetSysAddrForMdl(PMDL pMdl);


#ifndef _NEW_DELETE_OPERATORS_
#define _NEW_DELETE_OPERATORS_

/*****************************************************************************
 * operator new()
 *****************************************************************************
 * Overload new to allocate from PagedPool, with our pooltag.
 */
inline void* __cdecl operator new
(
    size_t    iSize
)
{
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    PVOID result = ExAllocatePoolWithTag(PagedPool, iSize, 'ySmD');
#if 0 // The following section will only take effect in the DDK sample.
// @@END_DDKSPLIT
    //  Replace 'ySkD' with a tag appropriate to your product.
    PVOID result = ExAllocatePoolWithTag(PagedPool, iSize, 'ySkD');
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

    if (result)
    {
        RtlZeroMemory(result, iSize);
    }
#if DBG
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("Couldn't allocate paged pool: %d bytes", iSize));
    }
#endif // DBG
    return result;
}

/*****************************************************************************
 * operator new
 *****************************************************************************
 * Overload new to allocate with our pooltag.
 * Allocates from PagedPool or NonPagedPool, as specified.
 */
inline PVOID operator new
(
    size_t    iSize,
    POOL_TYPE poolType
)
{
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
    PVOID result = ExAllocatePoolWithTag(poolType, iSize, 'ySmD');
#if 0 // The following section will only take effect in the DDK sample.
// @@END_DDKSPLIT
    //  Replace 'ySkD' with a tag appropriate to your product.
    PVOID result = ExAllocatePoolWithTag(PagedPool, iSize, 'ySkD');
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT
    if (result)
    {
        RtlZeroMemory(result, iSize);
    }
#if DBG
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("Couldn't allocate poolType(%d): %d bytes", (ULONG)poolType, iSize));
    }
#endif // DBG

    return result;
}

/*****************************************************************************
 * operator new()
 *****************************************************************************
 * Overload new to allocate with a specified allocation tag.
 * Allocates from PagedPool or NonPagedPool, as specified.
 */
inline PVOID operator new
(
    size_t      iSize,
    POOL_TYPE   poolType,
    ULONG       tag
)
{
    PVOID result = ExAllocatePoolWithTag(poolType, iSize, tag);

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }
#if DBG
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("Couldn't allocate tagged poolType(%d): %d bytes", 
            (ULONG)poolType, iSize));
    }
#endif // DBG

    return result;
}

/*****************************************************************************
 * operator delete()
 *****************************************************************************
 * Delete function.
 */
inline void __cdecl operator delete
(
    PVOID pVoid
)
{
    ExFreePool(pVoid);
}


#endif //!_NEW_DELETE_OPERATORS_

// Debug trace facility
//
#define DM_DEBUG_CRITICAL       DEBUGLVL_ERROR   // Used to include critical messages
#define DM_DEBUG_NON_CRITICAL   DEBUGLVL_TERSE   // Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS         DEBUGLVL_VERBOSE // Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW      DEBUGLVL_BLAB    // Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL            DEBUGLVL_BLAB    // Used to include all debug messages

#if DBG
#define Trace 
#define Trace0(lvl, fstr) \
    _DbgPrintF(lvl, (fstr))
#define Trace1(lvl, fstr, arg1) \
    _DbgPrintF(lvl, (fstr, arg1))
#define Trace2(lvl, fstr, arg1, arg2) \
    _DbgPrintF(lvl, (fstr, arg1, arg2))
#define Trace3(lvl, fstr, arg1, arg2, arg3) \
    _DbgPrintF(lvl, (fstr, arg1, arg2, arg3))
#define Trace4(lvl, fstr, arg1, arg2, arg3, arg4) \
    _DbgPrintF(lvl, (fstr, arg1, arg2, arg3, arg4))
#else
#define Trace
#define Trace0
#define Trace1
#define Trace2
#define Trace3
#define Trace4
#endif

#define assert ASSERT

// Paramter validation unused
//
#define V_INAME(x)
#define V_BUFPTR_READ(p,cb)


#endif // _KernHelp_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\csynth.h ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//
//      CSynth.h
//

#ifndef __CSYNTH_H__
#define __CSYNTH_H__


#include "synth.h"

#define MAX_CHANNEL_GROUPS      1000
#define MAX_VOICES              1000

#define DEFAULT_CHANNEL_GROUPS  32
#define DEFAULT_VOICES          32

#ifndef IDirectMusicSynthSink
#define IDirectMusicSynthSink ISynthSinkDMus
#endif // IDirectMusicSynthSink


struct IDirectMusicSynthSink;

/*****************************************************************************
 * class CSynth
 *****************************************************************************
 * Class declaration for the synth object itself.
 * Manages the CControlLogic and CInstManager objects.
 */
class CSynth : public CListItem
{
friend class CControlLogic;
public: 
                    CSynth();
                    ~CSynth();
    CSynth *        GetNext() {return(CSynth *)CListItem::GetNext();};

    HRESULT         SetStereoMode(DWORD dwChannels) ;
    HRESULT         SetSampleRate(DWORD dwSampleRate) ;
    HRESULT         Activate(DWORD dwSampleRate, DWORD dwChannels);
    HRESULT         Deactivate();
    HRESULT         Download(LPHANDLE phDownload, void * pdwData, LPBOOL bpFree);
    HRESULT         Unload(HANDLE hDownload,HRESULT ( CALLBACK *lpFreeMemory)(HANDLE,HANDLE),HANDLE hUserData);
    HRESULT         PlayBuffer(IDirectMusicSynthSink *pSynthSink,REFERENCE_TIME rt, LPBYTE lpBuffer, DWORD cbBuffer, ULONG ulCable);
    HRESULT         SetNumChannelGroups(DWORD dwCableCount);
    void            SetGainAdjust(VREL vrGainAdjust);
    HRESULT         Open(DWORD dwCableCount, DWORD dwVoices);
    HRESULT         Close();
    void            ResetPerformanceStats();
    HRESULT         AllNotesOff();
    HRESULT         SetMaxVoices(short nMaxVoices,short nTempVoices);
    HRESULT         GetMaxVoices(short * pnMaxVoices,short * pnTempVoices);
    HRESULT         GetPerformanceStats(PerfStats *pStats);
    void            Mix(short *pBuffer,DWORD dwLength,LONGLONG llPosition);
    HRESULT         SetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,DWORD dwPriority);
    HRESULT         GetChannelPriority(DWORD dwChannelGroup,DWORD dwChannel,LPDWORD pdwPriority);

private:
    void            StealNotes(STIME stTime);
    void            FinishMix(short *pBuffer,DWORD dwlength);
    CVoice *        OldestVoice();
    void            QueueVoice(CVoice *pVoice);
    CVoice *        StealVoice(DWORD dwPriority);

    STIME           m_stLastTime;       // Sample time of last mix.
    CVoiceList      m_VoicesFree;       // List of available voices.
    CVoiceList      m_VoicesExtra;      // Extra voices for temporary overload.
    CVoiceList      m_VoicesInUse;      // List of voices currently in use.
    short           m_nMaxVoices;       // Number of allowed voices.
    short           m_nExtraVoices;     // Number of voices over the limit that can be used in a pinch.
    
    STIME           m_stLastStats;      // Last perfstats refresh.
    PerfStats       m_BuildStats;       // Performance info accumulator.
    PerfStats       m_CopyStats;        // Performance information for display.

public: 
    // DLS-1 compatibility parameters: set these off to emulate hardware
    // which can't vary volume/pan during playing of a note.
    VREL             m_vrGainAdjust;    // Final output gain adjust
    BOOL             m_fAllowPanWhilePlayingNote;
    BOOL             m_fAllowVolumeChangeWhilePlayingNote;

    STIME            m_stMinSpan;       // Minimum time allowed for mix time span.
    STIME            m_stMaxSpan;       // Maximum time allowed for mix time span.
    DWORD            m_dwSampleRate;
    DWORD            m_dwStereo;
    
    CInstManager     m_Instruments;     // Instrument manager.
    CControlLogic ** m_ppControl;       // Array of open ControlLogics.
    DWORD            m_dwControlCount;  // # of open CLs.

    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    BOOL             m_fCSInitialized;   
};

#endif// __CSYNTH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\instr.cpp ===
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//      Instrument.cpp

#include "common.h"

#define STR_MODULENAME "DDKSynth.sys:Instr: "

#include "math.h"

void MemDump(char * prompt);

#pragma code_seg()
/*****************************************************************************
 * CSourceLFO::CSourceLFO()
 *****************************************************************************
 * Constructor for CSourceLFO.
 */
CSourceLFO::CSourceLFO()
{
    m_pfFrequency = 3804; // f = (256*4096*16*5hz)/(samplerate)
    m_stDelay = 0;
    m_prMWPitchScale = 0;
    m_vrMWVolumeScale = 0;
    m_vrVolumeScale = 0;
    m_prPitchScale = 0;
}

/*****************************************************************************
 * CSourceLFO::Init()
 *****************************************************************************
 * Initialize the CSourceLFO object.
 */
void CSourceLFO::Init(DWORD dwSampleRate)
{
    m_pfFrequency = (256 * 4096 * 16 * 5) / dwSampleRate;
    m_stDelay = 0;
    m_prMWPitchScale = 0;
    m_vrMWVolumeScale = 0;
    m_vrVolumeScale = 0;
    m_prPitchScale = 0;
}

/*****************************************************************************
 * CSourceLFO::SetSampleRate()
 *****************************************************************************
 * Set the sample rate delta.
 */
void CSourceLFO::SetSampleRate(long lChange)
{
    if (lChange > 0)
    {
        m_stDelay <<= lChange;
        m_pfFrequency <<= lChange;
    }
    else
    {
        m_stDelay >>= -lChange;
        m_pfFrequency >>= -lChange;
    }
}

/*****************************************************************************
 * CSourceLFO::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CSourceLFO::Verify()
{
    FORCEBOUNDS(m_pfFrequency,64,7600);
    FORCEBOUNDS(m_stDelay,0,441000);
    FORCEBOUNDS(m_vrVolumeScale,-1200,1200);
    FORCEBOUNDS(m_vrMWVolumeScale,-1200,1200);
    FORCEBOUNDS(m_prPitchScale,-1200,1200);
    FORCEBOUNDS(m_prMWPitchScale,-1200,1200);
}

/*****************************************************************************
 * CSourceEG::CSourceEG()
 *****************************************************************************
 * Constructor for this object.
 */
CSourceEG::CSourceEG()
{
    Init();
}

/*****************************************************************************
 * CSourceEG::Init()
 *****************************************************************************
 * Initialize the CSourceEG object.
 */
void CSourceEG::Init()
{
    m_stAttack = 0;
    m_stDecay = 0;
    m_pcSustain = 1000;
    m_stRelease = 0;
    m_trVelAttackScale = 0;
    m_trKeyDecayScale = 0;
    m_sScale = 0;
}

/*****************************************************************************
 * CSourceEG::SetSampleRate()
 *****************************************************************************
 * Set the sample rate delta.
 */
void CSourceEG::SetSampleRate(long lChange)
{
    if (lChange > 0)
    {
        m_stAttack <<= lChange;
        m_stDecay <<= lChange;
        m_stRelease <<= lChange;
    }
    else
    {
        m_stAttack >>= -lChange;
        m_stDecay >>= -lChange;
        m_stRelease >>= -lChange;
    }
}

/*****************************************************************************
 * CSourceEG::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CSourceEG::Verify()
{
    FORCEBOUNDS(m_stAttack,0,1764000);
    FORCEBOUNDS(m_stDecay,0,1764000);
    FORCEBOUNDS(m_pcSustain,0,1000);
    FORCEBOUNDS(m_stRelease,0,1764000);

    FORCEBOUNDS(m_sScale,-1200,1200);
    FORCEBOUNDS(m_trKeyDecayScale,-12000,12000);
    FORCEBOUNDS(m_trVelAttackScale,-12000,12000);
}

/*****************************************************************************
 * CSourceArticulation::CSourceArticulation()
 *****************************************************************************
 * Constructor for this object.
 */
CSourceArticulation::CSourceArticulation()
{
    m_wUsageCount = 0;
    m_sDefaultPan = 0;
    m_dwSampleRate = 22050;
    m_PitchEG.m_sScale = 0; // pitch envelope defaults to off
}

/*****************************************************************************
 * CSourceArticulation::Init()
 *****************************************************************************
 * Initialize the CSourceArticulation object.
 */
void CSourceArticulation::Init(DWORD dwSampleRate)
{
    m_dwSampleRate = dwSampleRate;
    m_LFO.Init(dwSampleRate);       //  Set to default values.
    m_PitchEG.Init();
    m_VolumeEG.Init();
}

/*****************************************************************************
 * CSourceArticulation::SetSampleRate()
 *****************************************************************************
 * Set the sample rate for this articulation.
 */
void CSourceArticulation::SetSampleRate(DWORD dwSampleRate)
{
    if (dwSampleRate != m_dwSampleRate)
    {
        long lChange;
        if (dwSampleRate > (m_dwSampleRate * 2))
        {
            lChange = 2;        // going from 11 to 44.
        }
        else if (dwSampleRate > m_dwSampleRate)
        {
            lChange = 1;        // must be doubling
        }
        else if ((dwSampleRate * 2) < m_dwSampleRate)
        {
            lChange = -2;       // going from 44 to 11
        }
        else
        {
            lChange = -1;       // that leaves halving.
        }
        m_dwSampleRate = dwSampleRate;
        m_LFO.SetSampleRate(lChange);
        m_PitchEG.SetSampleRate(lChange);
        m_VolumeEG.SetSampleRate(lChange);
    }
}

/*****************************************************************************
 * CSourceArticulation::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CSourceArticulation::Verify()
{
    m_LFO.Verify();
    m_PitchEG.Verify();
    m_VolumeEG.Verify();
}

/*****************************************************************************
 * CSourceArticulation::AddRef()
 *****************************************************************************
 * Implementation of standard COM interface.
 */
void CSourceArticulation::AddRef()
{
    m_wUsageCount++;
}

/*****************************************************************************
 * CSourceArticulation::Release()
 *****************************************************************************
 * Implementation of standard COM interface.
 */
void CSourceArticulation::Release()
{
    m_wUsageCount--;
    if (m_wUsageCount == 0)
    {
        delete this;
    }
}

/*****************************************************************************
 * CSourceSample::CSourceSample()
 *****************************************************************************
 * Constructor for this object.
 */
CSourceSample::CSourceSample()
{
    m_pWave = NULL;
    m_dwLoopStart = 0;
    m_dwLoopEnd = 1;
    m_dwSampleLength = 0;
    m_prFineTune = 0;
    m_dwSampleRate = 22050;
    m_bMIDIRootKey = 60;
    m_bOneShot = TRUE;
    m_bSampleType = 0;
}

/*****************************************************************************
 * CSourceSample::~CSourceSample()
 *****************************************************************************
 * Destructor for this object.
 */
CSourceSample::~CSourceSample()
{
    if (m_pWave != NULL)
    {
        m_pWave->Release();
    }
}

/*****************************************************************************
 * CSourceSample::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CSourceSample::Verify()
{
    if (m_pWave != NULL)
    {
        FORCEUPPERBOUNDS(m_dwSampleLength,m_pWave->m_dwSampleLength);
        FORCEBOUNDS(m_dwLoopEnd,1,m_dwSampleLength);
        FORCEUPPERBOUNDS(m_dwLoopStart,m_dwLoopEnd);
        if ((m_dwLoopEnd - m_dwLoopStart) < 6)
        {
            m_bOneShot = TRUE;
        }
    }
    FORCEBOUNDS(m_dwSampleRate,3000,80000);
    FORCEBOUNDS(m_bMIDIRootKey,0,127);
    FORCEBOUNDS(m_prFineTune,-1200,1200);
}

/*****************************************************************************
 * CSourceSample::CopyFromWave()
 *****************************************************************************
 * Duplicate a wave that is already referenced elsewhere.
 */
BOOL CSourceSample::CopyFromWave()
{
    if (m_pWave == NULL)
    {
        return FALSE;
    }
    m_dwSampleLength = m_pWave->m_dwSampleLength;
    m_dwSampleRate = m_pWave->m_dwSampleRate;
    m_bSampleType = m_pWave->m_bSampleType;
    if (m_bOneShot)
    {
        m_dwSampleLength--;
        if (m_pWave->m_bSampleType & SFORMAT_16)
        {
            m_pWave->m_pnWave[m_dwSampleLength] = 0;
        }
        else
        {
            char *pBuffer = (char *) m_pWave->m_pnWave;
            pBuffer[m_dwSampleLength] = 0;
        }
    }
    else
    {
        if (m_dwLoopStart >= m_dwSampleLength)
        {
            m_dwLoopStart = 0;
        }
        if (m_pWave->m_bSampleType & SFORMAT_16)
        {
            m_pWave->m_pnWave[m_dwSampleLength-1] =
                m_pWave->m_pnWave[m_dwLoopStart];
        }
        else
        {
            char *pBuffer = (char *) m_pWave->m_pnWave;
            pBuffer[m_dwSampleLength-1] =
                pBuffer[m_dwLoopStart];
        }
    }
    Verify();
    return (TRUE);
}


/*****************************************************************************
 * CWave::CWave()
 *****************************************************************************
 * Constructor for this object.
 */
CWave::CWave()
{
    m_hUserData = NULL;
    m_lpFreeHandle = NULL;
    m_pnWave = NULL;
    m_dwSampleRate = 22050;
    m_bSampleType = SFORMAT_16;
    m_dwSampleLength = 0;
    m_wUsageCount = 0;
    m_dwID = 0;
    m_wPlayCount = 0;
    m_pWaveMem = NULL;
}

/*****************************************************************************
 * CWave::~CWave()
 *****************************************************************************
 * Destructor for this object.
 */
CWave::~CWave()
{
    if (m_pWaveMem)
    {
        if (m_lpFreeHandle)
        {
            m_lpFreeHandle((HANDLE) this,m_hUserData);
        }
        else
        {
            delete m_pWaveMem;
        }
        m_pWaveMem = NULL;
    }
    m_pnWave = NULL;
}

/*****************************************************************************
 * CWave::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CWave::Verify()
{
    FORCEBOUNDS(m_dwSampleRate,3000,80000);
}

/*****************************************************************************
 * CWave::PlayOn()
 *****************************************************************************
 * Increment the play count.
 */
void CWave::PlayOn()
{
    m_wPlayCount++;
    AddRef();
}

/*****************************************************************************
 * CWave::PlayOff()
 *****************************************************************************
 * Decrement the play count.
 */
void CWave::PlayOff()
{
    m_wPlayCount--;
    Release();
}

/*****************************************************************************
 * CWave::IsPlaying()
 *****************************************************************************
 * Return whether the wave is currently playing.
 */
BOOL CWave::IsPlaying()
{
    return (m_wPlayCount);
}

/*****************************************************************************
 * CWave::AddRef()
 *****************************************************************************
 * Implementation of standard COM interface.
 */
void CWave::AddRef()
{
    m_wUsageCount++;
}

/*****************************************************************************
 * CWave::Release()
 *****************************************************************************
 * Implementation of standard COM interface.
 */
void CWave::Release()
{
    m_wUsageCount--;
    if (m_wUsageCount == 0)
    {
        delete this;
    }
}

/*****************************************************************************
 * CSourceRegion::CSourceRegion()
 *****************************************************************************
 * Constructor for this object.
 */
CSourceRegion::CSourceRegion()
{
    m_pArticulation = NULL;
    m_vrAttenuation = 0;
    m_prTuning = 0;
    m_bKeyHigh = 127;
    m_bKeyLow = 0;
    m_bGroup = 0;
    m_bAllowOverlap = FALSE;
}

/*****************************************************************************
 * CSourceRegion::~CSourceRegion()
 *****************************************************************************
 * Destructor for this object.
 */
CSourceRegion::~CSourceRegion()
{
    if (m_pArticulation)
    {
        m_pArticulation->Release();
    }
}

/*****************************************************************************
 * CSourceRegion::SetSampleRate()
 *****************************************************************************
 * Set the sample rate for this region.  Forward this to the articulation.
 */
void CSourceRegion::SetSampleRate(DWORD dwSampleRate)
{
    if (m_pArticulation != NULL)
    {
        m_pArticulation->SetSampleRate(dwSampleRate);
    }
}

/*****************************************************************************
 * CSourceRegion::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CSourceRegion::Verify()
{
    FORCEBOUNDS(m_bKeyHigh,0,127);
    FORCEBOUNDS(m_bKeyLow,0,127);
    FORCEBOUNDS(m_prTuning,-12000,12000);
    FORCEBOUNDS(m_vrAttenuation,-9600,0);
    m_Sample.Verify();
    if (m_pArticulation != NULL)
    {
        m_pArticulation->Verify();
    }
}

/*****************************************************************************
 * CInstrument::CInstrument()
 *****************************************************************************
 * Constructor for this object.
 */
CInstrument::CInstrument()
{
    m_dwProgram = 0;
}

/*****************************************************************************
 * CInstrument::~CInstrument()
 *****************************************************************************
 * Destructor for this object.
 */
CInstrument::~CInstrument()
{
    while (!m_RegionList.IsEmpty())
    {
        CSourceRegion *pRegion = m_RegionList.RemoveHead();
        delete pRegion;
    }
}

/*****************************************************************************
 * CInstrument::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CInstrument::Verify()
{
    CSourceRegion *pRegion = m_RegionList.GetHead();
    CSourceArticulation *pArticulation = NULL;
    for (;pRegion != NULL;pRegion = pRegion->GetNext())
    {
        if (pRegion->m_pArticulation != NULL)
        {
            pArticulation = pRegion->m_pArticulation;
        }
        pRegion->Verify();
    }
    if (pArticulation)
    {
        pRegion = m_RegionList.GetHead();
        for (;pRegion != NULL;pRegion = pRegion->GetNext())
        {
            if (pRegion->m_pArticulation == NULL)
            {
                pRegion->m_pArticulation = pArticulation;
                pArticulation->AddRef();
            }
        }
    }
}

/*****************************************************************************
 * CInstrument::SetSampleRate()
 *****************************************************************************
 * Set the sample rate for this instrument (forward to region).
 */
void CInstrument::SetSampleRate(DWORD dwSampleRate)
{
    CSourceRegion *pRegion = m_RegionList.GetHead();
    for (;pRegion;pRegion = pRegion->GetNext())
    {
        pRegion->SetSampleRate(dwSampleRate);
    }
}

/*****************************************************************************
 * CInstrument::ScanForRegion()
 *****************************************************************************
 * Retrieve the region with the given note value from the list.
 */
CSourceRegion * CInstrument::ScanForRegion(DWORD dwNoteValue)
{
    CSourceRegion *pRegion = m_RegionList.GetHead();
    for (;pRegion;pRegion = pRegion->GetNext())
    {
        if (dwNoteValue >= pRegion->m_bKeyLow &&
            dwNoteValue <= pRegion->m_bKeyHigh)
        {
            break ;
        }
    }
    return pRegion;
}

/*****************************************************************************
 * CInstManager::SetSampleRate()
 *****************************************************************************
 * Set the sample rate for this instrument manager (forward to instruments).
 */
void CInstManager::SetSampleRate(DWORD dwSampleRate)
{
    DWORD dwIndex;

    m_dwSampleRate = dwSampleRate;
    EnterCriticalSection(&m_CriticalSection);

    for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
        for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
        {
            pInstrument->SetSampleRate(dwSampleRate);
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CInstManager::CInstManager()
 *****************************************************************************
 * Constructor for this object.
 */
CInstManager::CInstManager()
{
    m_fCSInitialized = FALSE;
    m_dwSampleRate = 22050;
    InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;
}

/*****************************************************************************
 * CInstManager::~CInstManager()
 *****************************************************************************
 * Destructor for this object.
 */
CInstManager::~CInstManager()
{
    if (m_fCSInitialized)
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
        {
            while (!m_InstrumentList[dwIndex].IsEmpty())
            {
                CInstrument *pInstrument = m_InstrumentList[dwIndex].RemoveHead();
                delete pInstrument;
            }
        }
        for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
        {
            while (!m_WavePool[dwIndex].IsEmpty())
            {
                CWave *pWave = m_WavePool[dwIndex].RemoveHead();
                pWave->Release();
            }
        }
        while (!m_FreeWavePool.IsEmpty())
        {
            CWave *pWave = m_FreeWavePool.RemoveHead();
            pWave->Release();
        }
        DeleteCriticalSection(&m_CriticalSection);
    }
}

/*****************************************************************************
 * CInstManager::Verify()
 *****************************************************************************
 * Sanity check on the object.
 */
void CInstManager::Verify()
{
    DWORD dwIndex;
    EnterCriticalSection(&m_CriticalSection);
    for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
        for (;pInstrument != NULL;pInstrument = pInstrument->GetNext())
        {
            pInstrument->Verify();
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CInstManager::GetInstrument()
 *****************************************************************************
 * Get the instrument that matches this program/key.
 */
CInstrument * CInstManager::GetInstrument(DWORD dwProgram,DWORD dwKey)
{
    EnterCriticalSection(&m_CriticalSection);
    CInstrument *pInstrument = m_InstrumentList[dwProgram % INSTRUMENT_HASH_SIZE].GetHead();
    for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
    {
        if (pInstrument->m_dwProgram == dwProgram)
        {
            if (pInstrument->ScanForRegion(dwKey) != NULL)
            {
                break;
            }
            else
            {
                Trace(1,"No region was found in instrument 0x%lx that matched note 0x%lx\n",
                    dwProgram, dwKey);
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return (pInstrument);
}


/*****************************************************************************
 * TimeCents2Samples()
 *****************************************************************************
 * Translate from time cents to samples.
 */
DWORD TimeCents2Samples(long tcTime, DWORD dwSampleRate)
{
    if (tcTime ==  0x80000000) return (0);
    double flTemp = tcTime;
    flTemp /= (65536 * 1200);
    flTemp = pow(2.0,flTemp);
    flTemp *= dwSampleRate;
    return (DWORD) flTemp;
}

/*****************************************************************************
 * PitchCents2PitchFract()
 *****************************************************************************
 * Translate from pitch cents to fractional pitch.
 */
DWORD PitchCents2PitchFract(long pcRate,DWORD dwSampleRate)
{
    double fTemp = pcRate;
    fTemp /= 65536;
    fTemp -= 6900;
    fTemp /= 1200;
    fTemp = pow(2.0,fTemp);
    fTemp *= 7381975040.0;  // (440*256*16*4096);
    fTemp /= dwSampleRate;
    return (DWORD) (fTemp);
}

/*****************************************************************************
 * CSourceArticulation::Download()
 *****************************************************************************
 * Download an articulation to this object.
 */
HRESULT
CSourceArticulation::Download(DMUS_DOWNLOADINFO * pInfo,void * pvOffsetTable[],
                              DWORD dwIndex,            DWORD dwSampleRate,
                              BOOL fNewFormat)
{
    // Depending on whether this is the new DX7 format, we either are reading
    // a fixed set of parameters or parsing an articulation chunk directly
    // copied from the DLS file. The latter is obviously more flexible and it
    // turns out to make much more sense once we get to DLS2.
    if (fNewFormat)
    {
        DMUS_ARTICULATION2 * pdmArtic =
            (DMUS_ARTICULATION2 *) pvOffsetTable[dwIndex];

        while (pdmArtic)
        {
            if (pdmArtic->ulArtIdx)
            {
                if (pdmArtic->ulArtIdx >= pInfo->dwNumOffsetTableEntries)
                {
                    return DMUS_E_BADARTICULATION;
                }
                DWORD dwPosition;
                void *pData = pvOffsetTable[pdmArtic->ulArtIdx];
                CONNECTIONLIST * pConnectionList =
                    (CONNECTIONLIST *) pData;
                CONNECTION *pConnection;
                dwPosition = sizeof(CONNECTIONLIST);
                for (dwIndex = 0; dwIndex < pConnectionList->cConnections; dwIndex++)
                {
                    pConnection = (CONNECTION *) ((BYTE *)pData + dwPosition);
                    dwPosition += sizeof(CONNECTION);
                    switch (pConnection->usSource)
                    {
                    case CONN_SRC_NONE :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_LFO_FREQUENCY :
                            m_LFO.m_pfFrequency = PitchCents2PitchFract(
                                pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_LFO_STARTDELAY :
                            m_LFO.m_stDelay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_ATTACKTIME :
                            m_VolumeEG.m_stAttack = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_DECAYTIME :
                            m_VolumeEG.m_stDecay = TimeCents2Samples(
                            (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG1_SUSTAINLEVEL :
                            m_VolumeEG.m_pcSustain =
                                (SPERCENT) ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG1_RELEASETIME :
                            m_VolumeEG.m_stRelease = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_ATTACKTIME :
                            m_PitchEG.m_stAttack = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_DECAYTIME :
                            m_PitchEG.m_stDecay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_EG2_SUSTAINLEVEL :
                            m_PitchEG.m_pcSustain =
                                (SPERCENT) ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_RELEASETIME :
                            m_PitchEG.m_stRelease = TimeCents2Samples(
                                (TCENT) pConnection->lScale,dwSampleRate);
                            break;
                        case CONN_DST_PAN :
                            m_sDefaultPan = (short)
                                ((long) ((long) pConnection->lScale >> 12) / 125);
                            break;
                        }
                        break;
                    case CONN_SRC_LFO :
                        switch (pConnection->usControl)
                        {
                        case CONN_SRC_NONE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_ATTENUATION :
                                m_LFO.m_vrVolumeScale = (VRELS)
                                    ((long) ((pConnection->lScale * 10) >> 16));
                                break;
                            case CONN_DST_PITCH :
                                m_LFO.m_prPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            }
                            break;
                        case CONN_SRC_CC1 :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_ATTENUATION :
                                m_LFO.m_vrMWVolumeScale = (VRELS)
                                    ((long) ((pConnection->lScale * 10) >> 16));
                                break;
                            case CONN_DST_PITCH :
                                m_LFO.m_prMWPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16));
                                break;
                            }
                            break;
                        }
                        break;
                    case CONN_SRC_KEYONVELOCITY :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_EG1_ATTACKTIME :
                            m_VolumeEG.m_trVelAttackScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_ATTACKTIME :
                            m_PitchEG.m_trVelAttackScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_ATTENUATION :
                            break;
                        }
                        break;
                    case CONN_SRC_KEYNUMBER :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_EG1_DECAYTIME :
                            m_VolumeEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_DECAYTIME :
                            m_PitchEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        }
                        break;
                    case CONN_SRC_EG2 :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_PITCH :
                            m_PitchEG.m_sScale = (short)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        }
                        break;
                    }
                }
            }
            if (pdmArtic->ulNextArtIdx)
            {
                if (pdmArtic->ulNextArtIdx >= pInfo->dwNumOffsetTableEntries)
                {
                    return DMUS_E_BADARTICULATION;
                }
                pdmArtic = (DMUS_ARTICULATION2 *) pvOffsetTable[pdmArtic->ulNextArtIdx];
            }
            else
            {
                pdmArtic = NULL;
            }
        }
    }
    else
    {
        DMUS_ARTICULATION * pdmArtic =
            (DMUS_ARTICULATION *) pvOffsetTable[dwIndex];

        if (pdmArtic->ulArt1Idx)
        {
            if (pdmArtic->ulArt1Idx >= pInfo->dwNumOffsetTableEntries)
            {
                return DMUS_E_BADARTICULATION;
            }
            DMUS_ARTICPARAMS * pdmArticParams =
                (DMUS_ARTICPARAMS *) pvOffsetTable[pdmArtic->ulArt1Idx];

            m_LFO.m_pfFrequency = PitchCents2PitchFract(
                pdmArticParams->LFO.pcFrequency,dwSampleRate);
            m_LFO.m_stDelay = TimeCents2Samples(
                (TCENT) pdmArticParams->LFO.tcDelay,dwSampleRate);
            m_LFO.m_vrVolumeScale = (VRELS)
                ((long) ((pdmArticParams->LFO.gcVolumeScale * 10) >> 16));
            m_LFO.m_prPitchScale = (PRELS)
                ((long) (pdmArticParams->LFO.pcPitchScale >> 16));
            m_LFO.m_vrMWVolumeScale = (VRELS)
                ((long) ((pdmArticParams->LFO.gcMWToVolume * 10) >> 16));
            m_LFO.m_prMWPitchScale = (PRELS)
                ((long) (pdmArticParams->LFO.pcMWToPitch >> 16));

            m_VolumeEG.m_stAttack = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcAttack,dwSampleRate);
            m_VolumeEG.m_stDecay = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcDecay,dwSampleRate);
            m_VolumeEG.m_pcSustain =
                (SPERCENT) ((long) (pdmArticParams->VolEG.ptSustain >> 16));
            m_VolumeEG.m_stRelease = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcRelease,dwSampleRate);
            m_VolumeEG.m_trVelAttackScale = (TRELS)
                ((long) (pdmArticParams->VolEG.tcVel2Attack >> 16));
            m_VolumeEG.m_trKeyDecayScale = (TRELS)
                ((long) (pdmArticParams->VolEG.tcKey2Decay >> 16));

            m_PitchEG.m_trKeyDecayScale = (TRELS)
                ((long) (pdmArticParams->PitchEG.tcKey2Decay >> 16));
            m_PitchEG.m_sScale = (short)
                ((long) (pdmArticParams->PitchEG.pcRange >> 16));
            m_PitchEG.m_trVelAttackScale = (TRELS)
                ((long) (pdmArticParams->PitchEG.tcVel2Attack >> 16));
            m_PitchEG.m_stAttack = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcAttack,dwSampleRate);
            m_PitchEG.m_stDecay = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcDecay,dwSampleRate);
            m_PitchEG.m_pcSustain =
                (SPERCENT) ((long) (pdmArticParams->PitchEG.ptSustain >> 16));
            m_PitchEG.m_stRelease = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcRelease,dwSampleRate);

            m_sDefaultPan = (short)
                            ((long) ((long) pdmArticParams->Misc.ptDefaultPan >> 12) / 125);
        }
    }

    Verify();   // Make sure all parameters are legal.
    return S_OK;
}

/*****************************************************************************
 * CSourceRegion::Download()
 *****************************************************************************
 * Download a region to this object.
 * Parse through the region chunks, including any embedded articulation.
 */
HRESULT CSourceRegion::Download(DMUS_DOWNLOADINFO * pInfo, // DMUS_DOWNLOADINFO header struct.
                                void * pvOffsetTable[],    // Offset table with embedded struct addresses.
                                DWORD *pdwRegionIX,        // Region index for first region.
                                DWORD dwSampleRate,        // Sample rate, used to convert time parameters.
                                BOOL fNewFormat)           // DMUS_DOWNLOADINFO_INSTRUMENT2 format?
{
    DMUS_REGION * pdmRegion = (DMUS_REGION *) pvOffsetTable[*pdwRegionIX];
    *pdwRegionIX = pdmRegion->ulNextRegionIdx;  // Clear to avoid loops.
    pdmRegion->ulNextRegionIdx = 0;
    // Read the Region chunk...
    m_bKeyHigh = (BYTE) pdmRegion->RangeKey.usHigh;
    m_bKeyLow = (BYTE) pdmRegion->RangeKey.usLow;
    if (pdmRegion->fusOptions & F_RGN_OPTION_SELFNONEXCLUSIVE)
    {
        m_bAllowOverlap = TRUE;
    }
    else
    {
        m_bAllowOverlap = FALSE;
    }
    m_bGroup = (BYTE) pdmRegion->usKeyGroup;

    // Now, the WSMP and WLOOP chunks...
    m_vrAttenuation = (short) ((long) ((pdmRegion->WSMP.lAttenuation) * 10) >> 16);
    m_Sample.m_prFineTune = pdmRegion->WSMP.sFineTune;
    m_Sample.m_bMIDIRootKey = (BYTE) pdmRegion->WSMP.usUnityNote;

    if (pdmRegion->WSMP.cSampleLoops == 0)
    {
        m_Sample.m_bOneShot = TRUE;
    }
    else
    {
        m_Sample.m_dwLoopStart = pdmRegion->WLOOP[0].ulStart;
        m_Sample.m_dwLoopEnd = m_Sample.m_dwLoopStart + pdmRegion->WLOOP[0].ulLength;
        m_Sample.m_bOneShot = FALSE;
    }
    m_Sample.m_dwSampleRate = dwSampleRate;
    // Then the WAVELINK...
    if (pdmRegion->WaveLink.ulChannel != WAVELINK_CHANNEL_LEFT)
    {
        return DMUS_E_NOTMONO;
    }
    m_Sample.m_dwID = (DWORD) pdmRegion->WaveLink.ulTableIndex;
    // Does it have its own articulation?
    if (pdmRegion->ulRegionArtIdx )
    {
        if (pdmRegion->ulRegionArtIdx >= pInfo->dwNumOffsetTableEntries)
        {
            return DMUS_E_BADARTICULATION;
        }

        CSourceArticulation *pArticulation = new CSourceArticulation;
        if (pArticulation)
        {
            pArticulation->Init(dwSampleRate);

            HRESULT hr = pArticulation->Download( pInfo, pvOffsetTable,
                                                  pdmRegion->ulRegionArtIdx, dwSampleRate, fNewFormat);
            if (FAILED(hr))
            {
                delete pArticulation;
                return hr;
            }
            m_pArticulation = pArticulation;
            m_pArticulation->AddRef();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}



/*****************************************************************************
 * CInstManager::DownloadInstrument()
 *****************************************************************************
 * Download an instrument to this instrument manager.  This is dispatched
 * to the various appropriate objects.
 *
 * This is called by Download() when an instrument chunk is encountered.
 * Using the offset table to resolve linkages, it scans through the instrument,
 * parsing out regions and articulations, then finally linking the regions in the
 * instrument to the waves, which should have been previously downloaded.
*/
HRESULT CInstManager::DownloadInstrument(
    LPHANDLE phDownload,        // Pointer to download handle, to be created by synth.
    DMUS_DOWNLOADINFO *pInfo,   // DMUS_DOWNLOADINFO structure from the download chunk's head.
                                // This provides the total size of data, among other things.
    void *pvOffsetTable[],      // Offset table with addresses of all embedded structures.
    void *pvData,               // Pointer to start of download data.
    BOOL fNewFormat)            // Is this DMUS_DOWNLOADINFO_INSTRUMENT2 format download?
{
    HRESULT hr = E_FAIL;
    // The download data must start with the DMUS_INSTRUMENT chunk, so cast to that.
    DMUS_INSTRUMENT *pdmInstrument = (DMUS_INSTRUMENT *) pvData;
    CSourceArticulation *pArticulation = NULL;

    // Create a new CInstrument structure. This stores everything that describes an instrument, including
    // the articulations and regions.
    CInstrument *pInstrument = new CInstrument;
    if (pInstrument)
    {
        hr = S_OK;

        // For debugging purposes, print a trace statement to show that the instrument has actually been downloaded.
        // This only occurs in debug builds.
        Trace(1,"Downloading instrument %lx\n",pdmInstrument->ulPatch);
        pInstrument->m_dwProgram = pdmInstrument->ulPatch;

        // Start by scanning through the regions.
        DWORD dwRegionIX = pdmInstrument->ulFirstRegionIdx;
        pdmInstrument->ulFirstRegionIdx = 0; // Clear to avoid loops.
        while (dwRegionIX)
        {
            // For each region, verify that the index number is actually legal.
            if (dwRegionIX >= pInfo->dwNumOffsetTableEntries)
            {
                hr = DMUS_E_BADINSTRUMENT;
                goto ExitError;
            }
            CSourceRegion *pRegion = new CSourceRegion;
            if (!pRegion)
            {
                hr = E_OUTOFMEMORY;
                goto ExitError;
            }
            pInstrument->m_RegionList.AddHead(pRegion);
            // Call the region's Download method to parse the region structure and optional embedded articulation.
            hr = pRegion->Download(pInfo, pvOffsetTable, &dwRegionIX, m_dwSampleRate, fNewFormat);
            if (FAILED(hr))
            {
                goto ExitError;
            }
            EnterCriticalSection(&m_CriticalSection);
            // Once the region is parsed, we need to connect it to the wave, that should have been
            // previously downloaded into the wavepool.
            // Because of the hash table, the linked list is never very long, so the search is quick.
            CWave *pWave = m_WavePool[pRegion->m_Sample.m_dwID % WAVE_HASH_SIZE].GetHead();
            for (;pWave;pWave = pWave->GetNext())
            {
                // Each wave has a unique ID, which the regions match up with.
                if (pRegion->m_Sample.m_dwID == pWave->m_dwID)
                {
                    pRegion->m_Sample.m_pWave = pWave;
                    pWave->AddRef();
                    pRegion->m_Sample.CopyFromWave();
                    break;
                }
            }
            LeaveCriticalSection(&m_CriticalSection);
        }
        // Once all the regions are loaded, see if we have a global articulation.
        if (pdmInstrument->ulGlobalArtIdx)
        {
            // If so load it. First check that it's a valid index.
            if (pdmInstrument->ulGlobalArtIdx >= pInfo->dwNumOffsetTableEntries)
            {
                hr = DMUS_E_BADARTICULATION;
                goto ExitError;
            }

            // Create an articulation and have it parse the data.
            pArticulation = new CSourceArticulation;
            if (pArticulation)
            {
                // The articulation will convert all time parameters into sample times, so it needs to know the sample rate.
                pArticulation->Init(m_dwSampleRate);

                // Parse the articulation data. Note that the fNewFormat flag indicates whether this is in the DX6 fixed
                // format articulation or the DX7 dynamic format (which is actually the same as the file format.)
                hr = pArticulation->Download( pInfo, pvOffsetTable,
                                              pdmInstrument->ulGlobalArtIdx, m_dwSampleRate, fNewFormat);
                if (FAILED(hr))
                {
                    goto ExitError;
                }

                // Once the global articulation is read, scan all regions and assign the articulation to all
                // regions that don't have articulations yet.
                for (CSourceRegion *pr = pInstrument->m_RegionList.GetHead();
                     pr != NULL;
                     pr = pr->GetNext())
                {
                    if (pr->m_pArticulation == NULL)
                    {
                        pr->m_pArticulation = pArticulation;
                        pArticulation->AddRef();
                    }
                }
                if (!pArticulation->m_wUsageCount)
                {
                    delete pArticulation;
                    pArticulation = NULL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                goto ExitError;
            }
        }
        else
        {
            for (CSourceRegion *pr = pInstrument->m_RegionList.GetHead();
                 pr != NULL;
                 pr = pr->GetNext())
            {
                if (pr->m_pArticulation == NULL)
                {
                    hr = DMUS_E_NOARTICULATION;
                    goto ExitError;
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            EnterCriticalSection(&m_CriticalSection);
            // If this is a GM instrument, make sure that it will be searched for last by placing it at
            // the end of the list. The DLS spec states that
            // a DLS collection with the same patch as a GM instrument will always override the GM instrument.
            if (pdmInstrument->ulFlags & DMUS_INSTRUMENT_GM_INSTRUMENT)
            {
                pInstrument->SetNext(NULL);
                m_InstrumentList[pInstrument->m_dwProgram % INSTRUMENT_HASH_SIZE].AddTail(pInstrument);
            }
            else
            {
                m_InstrumentList[pInstrument->m_dwProgram % INSTRUMENT_HASH_SIZE].AddHead(pInstrument);
            }
            LeaveCriticalSection(&m_CriticalSection);
            *phDownload = (HANDLE) pInstrument;
        }
    }

ExitError:
    // Clean-up code.
    if (FAILED(hr))
    {
        if (pArticulation)
        {
            delete pArticulation;
        }

        if (pInstrument)
        {
            delete pInstrument;
        }
    }

    return hr;
}

/*****************************************************************************
 * CInstManager::DownloadWave()
 *****************************************************************************
 * Download a wave to this instrument manager.  It is put in the pool.
 *
 * This is called by Download when it receives a wave download chunk.
 * DownloadWave parses the wave, converts the wave data if necessary, and
 * places the wave in the wave pool, where it can subsequentley be
 * connected to instruments. (All the waves referenced by an instrument
 * are downloaded prior to downloading the instrument itself. This makes the
 * whole process simpler and more reliable. Conversely, on unload, all
 * waves are unloaded after the instruments that reference them.)
 */
HRESULT CInstManager::DownloadWave(
    LPHANDLE phDownload,        // Download handle, to be returned.  This will be
                                // used by a later Unload call to reference the wave.
    DMUS_DOWNLOADINFO *pInfo,   // DMUS_DOWNLOADINFO structure from the download chunk's head.
                                // This provides the total size of data, among other things.
    void *pvOffsetTable[],      // The table of offsets in the download data.
    void *pvData)               // Finally, the data itself.
{
    // The start of the data should align with a DMUS_WAVE header.
    DMUS_WAVE *pdmWave = (DMUS_WAVE *) pvData;

    // Make sure that the wave data is properly uncompressed PCM data.
    if (pdmWave->WaveformatEx.wFormatTag != WAVE_FORMAT_PCM)
    {
        return DMUS_E_NOTPCM;
    }

    // The data can only be mono format.
    if (pdmWave->WaveformatEx.nChannels != 1)
    {
        return DMUS_E_NOTMONO;
    }

    // The data can be only 8 or 16 bit.
    if (pdmWave->WaveformatEx.wBitsPerSample != 8 &&
        pdmWave->WaveformatEx.wBitsPerSample != 16)
    {
        return DMUS_E_BADWAVE;
    }

    // Ensure that the index to the wave data is a legal value in the offset table.
    if (pdmWave->ulWaveDataIdx >= pInfo->dwNumOffsetTableEntries)
    {
        return DMUS_E_BADWAVE;
    }

    // Create a wave object and parse the data into it.
    CWave *pWave = new CWave;
    if (pWave)
    {
        // We've already verified that the wave data index is a valid index, so go ahead
        // and use the offset table to convert that into a valid DMUS_WAVEDATA structure pointer.
        DMUS_WAVEDATA *pdmWaveData= (DMUS_WAVEDATA *)
            pvOffsetTable[pdmWave->ulWaveDataIdx];
        Trace(3,"Downloading wave %ld\n",pInfo->dwDLId);
        // Now initialize the CWave structure.
        pWave->m_dwID = pInfo->dwDLId;
        pWave->m_pWaveMem = pInfo;
        pWave->m_hUserData = NULL;
        pWave->m_lpFreeHandle = NULL;
        pWave->m_dwSampleLength = pdmWaveData->cbSize;
        pWave->m_pnWave = (short *) &pdmWaveData->byData[0];
        pWave->m_dwSampleRate = pdmWave->WaveformatEx.nSamplesPerSec;

        // If the wave data is 8 bit, the data needs to be converted to
        // two's complement representation.
        if (pdmWave->WaveformatEx.wBitsPerSample == 8)
        {
            pWave->m_bSampleType = SFORMAT_8;
            DWORD dwX;
            char *pData = (char *) &pdmWaveData->byData[0];
            for (dwX = 0; dwX < pWave->m_dwSampleLength; dwX++)
            {
                pData[dwX] -= (char) 128;
            }
        }
        else if (pdmWave->WaveformatEx.wBitsPerSample == 16)
        {
            pWave->m_dwSampleLength >>= 1;
            pWave->m_bSampleType = SFORMAT_16;
        }

        pWave->m_dwSampleLength++;  // We always add one sample to the end for interpolation.
        EnterCriticalSection(&m_CriticalSection);

        // Place the wave in a hash table of wave lists to increase access speed.
        m_WavePool[pWave->m_dwID % WAVE_HASH_SIZE].AddHead(pWave);
        LeaveCriticalSection(&m_CriticalSection);

        // Return the pointer to the internal CWave object as the handle. This will
        // be used in a subsequant call to unload the wave object.
        *phDownload = (HANDLE) pWave;
        pWave->AddRef();
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

/*****************************************************************************
 * CInstManager::Download()
 *****************************************************************************
 * Download to this instrument manager.
 *
 * This is the heart of the DLS download mechanism, and is called from CSynth::Download().
 * It verifies the offset table and converts it into physical addresses. Then,
 * depending on whether this is a wave or instrument download, it calls the
 * appropriate method.
 *
 * The data is stored in a continuous chunk of memory,
 * pointed to by pvData. However, at the head of the chunk are two data
 * structures, which define the nature of the data to follow. These are
 * the DMUS_DOWNLOADINFO and DMUS_OFFSETTABLE structures. DMUS_DOWNLOADINFO
 * is a header which describes how to parse the data, including
 * its size and intention (wave or instrument.) DMUS_OFFSETTABLE provides
 * a set of indexes into the data segment which follows. All parsing through the data
 * is managed through this table. Whenever a structure in the data references
 * another structure, it describes it by an index into the offset table.
 * The offset table then converts it into a physical address in the memory.
 * This allows the synthesizer to do bounds checking on all
 * references, making the implementation more robust. In kernel mode
 * implementations, the driver can make its own private copy of the offset
 * table, and so ensure that an application in user mode can not mess with
 * its referencing and cause a crash. This implementation also makes a unique copy.
 *
 * Looking closer at DMUS_DOWNLOADINFO, DMUS_DOWNLOADINFO.dwDLType
 * determines the type of data being downloaded. It is set to
 * DMUS_DOWNLOADINFO_INSTRUMENT or DMUS_DOWNLOADINFO_INSTRUMENT2
 * for an instrument, DMUS_DOWNLOADINFO_WAVE for a wave. As new data types emerge,
 * identifiers will be allocated for them.
 * DMUS_DOWNLOADINFO.dwDLId holds a unique 32 bit identifier for the object.
 * This identifier is used to connect objects together. For example, it is used
 * to connect waves to instruments.
 * DMUS_DOWNLOADINFO.dwNumOffsetTableEntries describes the number of entries in
 * the DMUS_OFFSETTABLE structure, which follows.
 * Finally, DMUS_DOWNLOADINFO.cbSizeData states the total size of the
 * memory chunk, which follows the offset table.
 *
 * Depending on the synthesizer implementation, it may decide to use the memory
 * in the download chunk. This reduces memory allocation and freeing, since, if enough
 * memory has been allocated to store a wave, that same memory can be used by
 * the synthesizer to store it for playback. So, the synthesizer has the option
 * of hanging on to the memory, returning its decision in the pbFree parameter.
 * If it does keep the memory, then the caller must not free it. Later, the
 * CSynth::Unload command has a callback mechanism to handle asynchronous
 * freeing of the memory once the unload request has been made.
 */
HRESULT CInstManager::Download(LPHANDLE phDownload, // Download handle, to be returned.
                               void * pvData,       // Pointer to download data chunk.
                               LPBOOL pbFree)       // Pointer to boolean whether data can
                                                    // be freed now or held until unload.
{
    V_INAME(IDirectMusicSynth::Download);
    V_BUFPTR_READ(pvData,sizeof(DMUS_DOWNLOADINFO));

    HRESULT hr = DMUS_E_UNKNOWNDOWNLOAD;

    // We need an array of pointers to reproduce the offset table, which is used to link to
    // specific structures in the download chunk.
    void ** ppvOffsetTable;     // Array of pointers to chunks in data.

    // At the head of the download chunk is the download header, in the form of a DMUS_DOWNLOADINFO structure.
    DMUS_DOWNLOADINFO * pInfo = (DMUS_DOWNLOADINFO *) pvData;

    // It is immediately followed by the offset table, so we cast a pointer to that.
    DMUS_OFFSETTABLE* pOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvData) + sizeof(DMUS_DOWNLOADINFO));
    char *pcData = (char *) pvData;

    V_BUFPTR_READ(pvData,pInfo->cbSize);

    // Return the error code immediately.
    if (0 == pInfo->dwNumOffsetTableEntries)
    {
        return hr;
    }

    // Create a copy of the offset table.
    ppvOffsetTable = new void *[pInfo->dwNumOffsetTableEntries];
    if (ppvOffsetTable) // Create the pointer array and validate.
    {
        // Each index in the offset table is an offset from the beginning of the download chunk to
        // a position in the memory where a specific structure resides.
        // Scan through the table and convert these offsets into actual memory
        // addresses, and store these in the ppvOfsetTable array. These
        // will be used by the parsing code to resolve indexes to actual
        // memory addresses.
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < pInfo->dwNumOffsetTableEntries; dwIndex++)
        {
            // First, make sure the offset is not out of bounds.
            if (pOffsetTable->ulOffsetTable[dwIndex] >= pInfo->cbSize)
            {
                delete [] ppvOffsetTable;
                return DMUS_E_BADOFFSETTABLE;   // Bad!
            }
            // Go ahead and calculate the actual memory address and store it.
            ppvOffsetTable[dwIndex] = (void *) &pcData[pOffsetTable->ulOffsetTable[dwIndex]];
        }

        // Once the offset table is constructed, we can pass it to the appropriate parsing routine.
        // There are three types of download chunks: DMUS_DOWNLOADINFO_INSTRUMENT,
        // DMUS_DOWNLOADINFO_INSTRUMENT2, and DMUS_DOWNLOADINFO_WAVE.
        // The two instrument formats exist because DMUS_DOWNLOADINFO_INSTRUMENT was changed to
        // support a variable articulation to support DLS2 in the DX7 timeframe. In truth,
        // only DMUS_DOWNLOADINFO_INSTRUMENT2 and DMUS_DOWNLOADINFO_WAVE need be supported,
        // but we continue with DMUS_DOWNLOADINFO_INSTRUMENT support in this example.
        // Depending on the type of download, we call the appropriate method, which then
        // parses the data.
        // To let dmusic understand that it does support the DMUS_DOWNLOADINFO_INSTRUMENT2,
        // the synth must respond positively to the KsProperty Query GUID_DMUS_PROP_INSTRUMENT2,
        // request (please see CUserModeSynth::KsProperty() for implementation details.)
        if (pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT) // Instrument.
        {
            // Instrument does not need to keep the  download chunk allocated, so indicate that
            // the caller can free it.
            *pbFree = TRUE;

            // Call the download instrument method, indicating that this is a DX6 format download.
            hr = DownloadInstrument(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0],FALSE);
        }
        if (pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT2) // New instrument format.
        {
            *pbFree = TRUE;

            // Call the download instrument method, indicating that this is a DX7 or up format download.
            hr = DownloadInstrument(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0],TRUE);
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_WAVE) // Wave.
        {
            // Wave does need to keep the  download chunk allocated, because it includes the
            // wave data buffer, which it will play directly out of, so indicate that
            // the caller must not free it until it is unloaded.
            *pbFree = FALSE;
            hr = DownloadWave(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]);
        }
        delete [] ppvOffsetTable;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

/*****************************************************************************
 * CInstManager::Unload()
 *****************************************************************************
 * Unload the given previous download.  Delete the instruments and waves.
 *
 * The unload method is called when it is unloading a previously downloaded
 * instrument or wave chunk. This instructs the synthesizer to find the object that
 * was downloaded (identified by the handle, hDownload, that was generated by the
 * call to Download) and remove it.
 *
 * If the object was using the original download chunk, it needs to notify the caller
 * when it is done using it so the memory can then be freed. This is not necessarily
 * at the time of the download call because wave data may currently be in use by a
 * performing note. So, a pointer to a callback function is also provided and the
 * synthesizer must call this function at the time the memory is no longer in use.
 */
HRESULT CInstManager::Unload(
    HANDLE hDownload,                                   // Handle of previously downloaded
                                                        // wave or instrument.
    HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),   // Callback function for releasing
                                                        // downloaded memory
    HANDLE hUserData)                                   // Parameter to pass to callback,
                                                        // to indicate which download is freed.
{
    DWORD dwIndex;
    EnterCriticalSection(&m_CriticalSection);

    // First, check to see if this is an instrument.
    // We keep all the instruments in a hash table to speed up access.
    for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
        for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
        {
            // If the instrument matches the download handle, remove it from the list
            // and delete it. There is no need to callback for releasing the memory because
            // the synthesizer did not hang on to the original downloaded instrument memory.
            if (pInstrument == (CInstrument *) hDownload)
            {
                // To help debug, print the patch number of the unloaded instrument.
                Trace(1,"Unloading instrument %lx\n",pInstrument->m_dwProgram);
                m_InstrumentList[dwIndex].Remove(pInstrument);
                delete pInstrument;
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }

    // If it wasn't an instrument, try the wave list.
    // Again, they are arranged in a hash table to increase access speed.
    for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
    {
        CWave *pWave = m_WavePool[dwIndex].GetHead();
        for (;pWave != NULL;pWave = pWave->GetNext())
        {
            // If the wave matches the download handle, remove it from the list.
            // Also, store the callback function, lpFreeHandle, and associated instance
            // parameter, hUserData, in the wave. Remove the wave from the wave pool, so
            // it can no longer be connected with another instrument.
            //
            // When the last instance of a voice that is playing the wave finishes,
            // lpFreeHandle will be called and the caller will be able to free the memory.
            // Usually, the wave is not currently being played and this happens instantly.
            if (pWave == (CWave *) hDownload)
            {
                Trace(3,"Unloading wave %ld\n",pWave->m_dwID);
                m_WavePool[dwIndex].Remove(pWave);
                pWave->m_hUserData = hUserData;
                pWave->m_lpFreeHandle = lpFreeHandle;
                pWave->Release();
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\control.cpp ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//      CControlLogic.cpp
//

#define STR_MODULENAME "DDKSynth.sys:Control: "

#include "common.h"

#pragma code_seg()
/*****************************************************************************
 * CControlLogic::CControlLogic()
 *****************************************************************************
 * Constructor for CControlLogic object.
 */
CControlLogic::CControlLogic()
{
    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;

    m_pSynth = NULL;
	m_pInstruments = NULL;

    DWORD nIndex;
	GMReset();
	m_fGSActive = FALSE;
	m_fXGActive = FALSE;
    for (nIndex = 0;nIndex < 16;nIndex++)
    {
        m_fSustain[nIndex] = FALSE;
        m_dwProgram[nIndex] = 0;
    }
    m_fEmpty = TRUE;
}

/*****************************************************************************
 * CControlLogic::~CControlLogic()
 *****************************************************************************
 * Destructor for CControlLogic object.
 */
CControlLogic::~CControlLogic()
{
    if (m_fCSInitialized)
    {
        DeleteCriticalSection(&m_CriticalSection);
    }
}

/*****************************************************************************
 * CControlLogic::GMReset()
 *****************************************************************************
 * Performs a General MIDI reset, including resetting all the voice priorities,
 * GS, XG, master volume, etc.
 */
void CControlLogic::GMReset()
{
    static const int nPartToChannel[16] = { 
		9,0,1,2,3,4,5,6,7,8,10,11,12,13,14,15 
	};
	int nX;
	for (nX = 0; nX < 16; nX++)
	{
		int nY;
		m_nData[nX] = 0;
		m_prFineTune[nX] = 0;
		m_bDrums[nX] = 0;
		for (nY = 0; nY < 12; nY++)
		{
			m_prScaleTune[nX][nY] = 0;
		}
		m_nCurrentRPN[nX] = (short) 0x3FFF;
		m_prCoarseTune[nX] = 0;	
		m_bPartToChannel[nX] = (BYTE)nPartToChannel[nX];
		m_fMono[nX] = FALSE;
		m_dwPriority[nX] = DAUD_STANDARD_VOICE_PRIORITY + 
			((16 - nX) * DAUD_CHAN15_VOICE_PRIORITY_OFFSET);
        m_bBankH[nX] = 0;
        m_bBankL[nX] = 0;
	}
	m_bDrums[0] = 1;
	m_vrMasterVolume = 0;
	m_fGSActive = FALSE;
	m_fXGActive = FALSE;
}

/*****************************************************************************
 * CControlLogic::Init()
 *****************************************************************************
 * Initialize the CControlLogic object, and initialize all the child objects --
 * Note recorders, ModWheels, Volumes, Pan, Expression, PitchBend.
 */
HRESULT CControlLogic::Init(CInstManager *pInstruments, CSynth *pSynth)
{
	m_pSynth = pSynth;
	m_pInstruments = pInstruments;
    m_vrGainAdjust = 0;

    m_Notes.Init();

    int iRecIdx;
    for (iRecIdx = 0; iRecIdx < sizeof(m_ModWheel) / sizeof(*m_ModWheel); iRecIdx++)
    {
        m_ModWheel[iRecIdx].Init();
    }
    for (iRecIdx = 0; iRecIdx < sizeof(m_PitchBend) / sizeof(*m_PitchBend); iRecIdx++)
    {
        m_PitchBend[iRecIdx].Init();
    }
    for (iRecIdx = 0; iRecIdx < sizeof(m_Volume) / sizeof(*m_Volume); iRecIdx++)
    {
        m_Volume[iRecIdx].Init();
    }
    for (iRecIdx = 0; iRecIdx < sizeof(m_Expression) / sizeof(*m_Expression); iRecIdx++)
    {
        m_Expression[iRecIdx].Init();
    }
    for (iRecIdx = 0; iRecIdx < sizeof(m_Pan) / sizeof(*m_Pan); iRecIdx++)
    {
        m_Pan[iRecIdx].Init();
    }

	return S_OK;
}

/*****************************************************************************
 * CControlLogic::ClearMIDI()
 *****************************************************************************
 * Clears MIDI up to a certain time, and updates m_fEmpty.
 */
void CControlLogic::ClearMIDI(STIME stEndTime)
{
	DWORD dwIndex;
	::EnterCriticalSection(&m_CriticalSection);
    if (!m_fEmpty)
    {        
        m_fEmpty = TRUE;
        for (dwIndex = 0;dwIndex < 16; dwIndex++)
        {
            m_fEmpty = m_ModWheel[dwIndex].ClearMIDI(stEndTime)
                && m_PitchBend[dwIndex].ClearMIDI(stEndTime)
                && m_Volume[dwIndex].ClearMIDI(stEndTime)
                && m_Expression[dwIndex].ClearMIDI(stEndTime)
                && m_Pan[dwIndex].ClearMIDI(stEndTime);
        }
    }
	::LeaveCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CControlLogic::SetGainAdjust()
 *****************************************************************************
 * Sets the overall gain for this CControlLogic.
 */
void CControlLogic::SetGainAdjust(VREL vrGainAdjust)
{
    m_vrGainAdjust = vrGainAdjust;
}

/*****************************************************************************
 * CControlLogic::QueueNotes()
 *****************************************************************************
 * Retrieves notes from the note recorders, and dispatches them appropriately.
 * Called during the Mix.
 */
void CControlLogic::QueueNotes(STIME stEndTime)
{
    CNote note;
    
    while (m_Notes.GetNote(stEndTime,&note))
    {
		if (note.m_bKey > 0x7F)	// Special command events.
		{
			long lTemp;
			DWORD dwPart = note.m_bPart;
			DWORD dwCommand = note.m_bKey;
			BYTE bData = note.m_bVelocity;
			switch (dwCommand)
			{
            case NOTE_PROGRAMCHANGE:
                m_dwProgram[dwPart] = bData |
                    (m_bBankH[dwPart] << 16) | 
                    (m_bBankL[dwPart] << 8);
                break;
			case NOTE_CC_BANKSELECTH:
				m_bBankH[dwPart] = bData;
				break;
			case NOTE_CC_BANKSELECTL:
				m_bBankL[dwPart] = bData;
				break;
			case NOTE_CC_POLYMODE:
				m_fMono[dwPart] = FALSE;
				break;
			case NOTE_CC_MONOMODE:
				m_fMono[dwPart] = TRUE;
				break;
			case NOTE_CC_RPN_MSB:
				m_nCurrentRPN[dwPart] = (m_nCurrentRPN[dwPart] & 0x7f) + (bData << 7);
				break;
			case NOTE_CC_RPN_LSB:
				m_nCurrentRPN[dwPart] = (m_nCurrentRPN[dwPart] & 0x3f80) + bData;
				break;
			case NOTE_CC_NRPN:
				m_nCurrentRPN[dwPart] = 0x3FFF;
				break;
			case NOTE_CC_DATAENTRYLSB:
				m_nData[dwPart] &= ~0x7F;
				m_nData[dwPart] |= bData;
				switch (m_nCurrentRPN[dwPart])
				{
				case RPN_PITCHBEND: // Don't do anything, Roland ignores lsb
					break;
				case RPN_FINETUNE:
					lTemp = m_nData[dwPart];
					lTemp -= 8192;
					lTemp *= 100;
					lTemp /= 8192;
					m_prFineTune[dwPart] = lTemp;
					break;
				case RPN_COARSETUNE: // Ignore lsb
					break;            
				}
				break;
			case NOTE_CC_DATAENTRYMSB:
				m_nData[dwPart] &= ~(0x7F << 7);
				m_nData[dwPart] |= bData << 7;
				switch (m_nCurrentRPN[dwPart])
				{
				case RPN_PITCHBEND:
					m_PitchBend[dwPart].m_prRange = bData * 100;
					break;
				case RPN_FINETUNE:
					lTemp = m_nData[dwPart];
					lTemp -= 8192;
					lTemp *= 100;
					lTemp /= 8192;
					m_prFineTune[dwPart] = lTemp;
					break;
				case RPN_COARSETUNE:
					m_prCoarseTune[dwPart] = 100 * (bData - 64);
					break;        
				}
				break;
			case NOTE_SUSTAIN: // special sustain marker
	            m_fSustain[dwPart] = (BOOL) bData;
				if (bData == FALSE)
				{
					CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
					for (;pVoice != NULL;pVoice = pVoice->GetNext())
					{
						if (pVoice->m_fSustainOn &&
							(pVoice->m_nPart == dwPart) &&
							(pVoice->m_pControl == this))
						{
							pVoice->StopVoice(note.m_stTime);
						}
					}
				} 
				break;
			case NOTE_ALLOFF:
				{
					CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
					for (;pVoice != NULL; pVoice = pVoice->GetNext())
					{
						if (pVoice->m_fNoteOn && !pVoice->m_fSustainOn &&
							(pVoice->m_nPart == dwPart) &&
							(pVoice->m_pControl == this))
						{
							if (m_fSustain[dwPart])
							{
								pVoice->m_fSustainOn = TRUE;
							}
							else
							{
								pVoice->StopVoice(note.m_stTime);
							}
						}
					}
				}
				break;
			case NOTE_SOUNDSOFF:
				{
					CVoice *pVoice = m_pSynth->m_VoicesInUse.GetHead();
					for (;pVoice != NULL; pVoice = pVoice->GetNext())
					{
						if (pVoice->m_fNoteOn &&
							(pVoice->m_nPart == dwPart) &&
							(pVoice->m_pControl == this))
						{
							pVoice->StopVoice(note.m_stTime);
						}
					}
				}
				break;
			case NOTE_ASSIGNRECEIVE:
				m_bPartToChannel[dwPart] = (BYTE) bData;
				break;
			case NOTE_MASTERVOLUME:
				m_vrMasterVolume = CMIDIRecorder::VelocityToVolume(bData);
				break;
			}
		}
        else if (note.m_bVelocity == 0)  // Note Off.
        {
            CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
            WORD nPart = note.m_bPart;
            for (;pVoice != NULL;pVoice = pVoice->GetNext())
            {
                if (pVoice->m_fNoteOn && !pVoice->m_fSustainOn &&
                    (pVoice->m_nKey == (WORD) note.m_bKey) &&
                    (pVoice->m_nPart == nPart) &&
					(pVoice->m_pControl == this)) 
                {
                    if (m_fSustain[nPart])
                    {
                        pVoice->m_fSustainOn = TRUE;
                    }
                    else
                    {
                        pVoice->StopVoice(note.m_stTime);
                    }
                    break;
                }
            }
        }
        else   // Note On.
        {
            DWORD dwProgram = m_dwProgram[note.m_bPart];
            if (m_bDrums[note.m_bPart])
            {
                dwProgram |= F_INSTRUMENT_DRUMS;
            }
			if (m_fMono[note.m_bPart])
			{
				CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
				WORD nPart = note.m_bPart;
				for (;pVoice != NULL;pVoice = pVoice->GetNext())
				{
					if (pVoice->m_fNoteOn && (pVoice->m_nPart == nPart) &&
						(pVoice->m_pControl == this)) 
					{
						pVoice->StopVoice(note.m_stTime);
					}
				}
			}
			// While we are working with the instrument, including copying
			// the data over from the region, we have to make sure it
			// can not be removed from the instrument list.
			EnterCriticalSection(&m_pInstruments->m_CriticalSection);
            CInstrument * pInstrument = 
                m_pInstruments->GetInstrument(dwProgram,note.m_bKey);
            if (!pInstrument) 
			{
				if (dwProgram & F_INSTRUMENT_DRUMS)
				{
					dwProgram = F_INSTRUMENT_DRUMS;
					pInstrument = 
						m_pInstruments->GetInstrument(dwProgram,note.m_bKey);
				}
				else if (m_fXGActive)
				{
					if ((dwProgram & 0x7F0000) == 0x7F0000)	// Drum?
					{
						dwProgram &= 0x7F007F;				// Enforce 0 LSB
						pInstrument = 
							m_pInstruments->GetInstrument(dwProgram,note.m_bKey);
                        if (!pInstrument)
                        {
                            dwProgram = 0x7F0000;
						    pInstrument = 
							    m_pInstruments->GetInstrument(dwProgram,note.m_bKey);
                        }
					}
                    else
                    {
						dwProgram &= 0x7F;	// Fall back to GM set.
						pInstrument = 
							m_pInstruments->GetInstrument(dwProgram,note.m_bKey);
					}
				}
			}
            if (pInstrument != NULL)
            {
                CSourceRegion * pRegion = 
                    pInstrument->ScanForRegion(note.m_bKey);
                if (pRegion != NULL)
                {
                    WORD nPart = note.m_bPart;
                    CVoice * pVoice = m_pSynth->m_VoicesInUse.GetHead();
                    if (!pRegion->m_bAllowOverlap)
                    {
                        for (;pVoice != NULL; pVoice = pVoice->GetNext())
                        {
                            if ((pVoice->m_nPart == nPart) &&
                                (pVoice->m_nKey == note.m_bKey) &&
								(pVoice->m_pControl == this))
                            {
                                pVoice->QuickStopVoice(note.m_stTime);
                            }
                        }    
                    }

                    if (pRegion->m_bGroup != 0)
                    {
                        pVoice = m_pSynth->m_VoicesInUse.GetHead();
                        for (;pVoice != NULL;pVoice = pVoice->GetNext())
                        {
                            if ((pVoice->m_dwGroup == pRegion->m_bGroup) &&
                                (pVoice->m_nPart == nPart) &&
                                (pVoice->m_dwProgram == dwProgram) &&
								(pVoice->m_pControl == this))
                            {
                                pVoice->QuickStopVoice(note.m_stTime);
                            }
                        }
                    }
                    
                    pVoice = m_pSynth->m_VoicesFree.RemoveHead();
                    if (pVoice == NULL)
                    {
                        pVoice = m_pSynth->m_VoicesExtra.RemoveHead();
                    }

                    if (pVoice == NULL)
                    {
                        pVoice = m_pSynth->StealVoice(m_dwPriority[nPart]);
                    }

                    if (pVoice != NULL)
                    {
						PREL prPitch = m_prFineTune[nPart] + m_prScaleTune[nPart][note.m_bKey % 12];
						if (!m_bDrums[nPart]) 
						{
							if (m_fXGActive)
							{
								if ((dwProgram & 0x7F0000) != 0x7F0000)
								{
									prPitch += m_prCoarseTune[nPart];
								}
							}
							else
							{
								prPitch += m_prCoarseTune[nPart];
							}
                        }
						pVoice->m_nKey = note.m_bKey;
                        pVoice->m_nPart = nPart;
                        pVoice->m_dwProgram = dwProgram;
                        pVoice->m_dwPriority = m_dwPriority[nPart];
						pVoice->m_pControl = this;

                        if (pVoice->StartVoice( m_pSynth,
                                                pRegion, note.m_stTime, 
                                                &m_ModWheel[nPart],     
                                                &m_PitchBend[nPart],
                                                &m_Expression[nPart],   
                                                &m_Volume[nPart],
                                                &m_Pan[nPart],          
                                                (WORD)note.m_bKey,
							                    (WORD)note.m_bVelocity, 
                                                m_vrMasterVolume, 
							                    prPitch))
                        {
                            pVoice->m_fInUse = TRUE;

                            m_pSynth->QueueVoice(pVoice);
                        }
                        else
                        {
                            m_pSynth->m_VoicesFree.AddHead(pVoice);
                        }
                    } 
                    else 
                    {
                        m_pSynth->m_BuildStats.dwNotesLost++;
                    }
                } 
                else 
                {
                    m_pSynth->m_BuildStats.dwNotesLost++;
                }
            } 
            else 
            {
                Trace(1, "No instrument/region was found for patch # %lx, note %ld\n",
                          dwProgram, (long) note.m_bKey);
            }
			LeaveCriticalSection(&m_pInstruments->m_CriticalSection);
        }
    }
}

/*****************************************************************************
 * CControlLogic::Flush()
 *****************************************************************************
 * Clears events and notes up to a given time.
 */
void CControlLogic::Flush(STIME stTime)
{
    DWORD dwIndex;
    ::EnterCriticalSection(&m_CriticalSection);
    if (!m_fEmpty)
    {        
        m_fEmpty = TRUE;
        for (dwIndex = 0;dwIndex < 16; dwIndex++)
        {
            m_fEmpty = m_ModWheel[dwIndex].FlushMIDI(stTime)
                && m_PitchBend[dwIndex].FlushMIDI(stTime)
                && m_Volume[dwIndex].FlushMIDI(stTime)
                && m_Expression[dwIndex].FlushMIDI(stTime)
                && m_Pan[dwIndex].FlushMIDI(stTime);
        }
        m_Notes.FlushMIDI(stTime);
    }
    ::LeaveCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CControlLogic::RecordMIDI()
 *****************************************************************************
 * Record a MIDI short message into this channel group.  
 * This dispatches the different MIDI
 * messages to the different receptor objects.
 */
BOOL CControlLogic::RecordMIDI(STIME stTime,BYTE bStatus, BYTE bData1, BYTE bData2)
{
    WORD nPreChannel = bStatus & 0xF; 
    CNote note;
    bStatus = bStatus & 0xF0;
    BOOL bReturn = TRUE;
	WORD nPart;

    ::EnterCriticalSection(&m_CriticalSection);

    for (nPart = 0;nPart < 16; nPart++)
	{
		if (nPreChannel == m_bPartToChannel[nPart])
		{
			switch (bStatus)
			{
			case MIDI_NOTEOFF :
				bData2 = 0;
			case MIDI_NOTEON :
				note.m_bPart = (BYTE) nPart;
				note.m_bKey = bData1;
				note.m_bVelocity = bData2;
				bReturn = m_Notes.RecordNote(stTime,&note);
				break;
			case MIDI_CCHANGE :
				switch (bData1)
				{
				case CC_BANKSELECTH :
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_BANKSELECTH, bData2);
					break;
				case CC_MODWHEEL :
                    m_fEmpty = FALSE;
					bReturn = m_ModWheel[nPart].RecordMIDI(stTime,(long) bData2);
					break;
				case CC_VOLUME :
                    m_fEmpty = FALSE;
					bReturn = m_Volume[nPart].RecordMIDI(stTime,(long) bData2);
					break;
				case CC_PAN :
                    m_fEmpty = FALSE;
					bReturn = m_Pan[nPart].RecordMIDI(stTime,(long) bData2);
					break;
				case CC_EXPRESSION :
                    m_fEmpty = FALSE;
					bReturn = m_Expression[nPart].RecordMIDI(stTime,(long)bData2);
					break;
				case CC_BANKSELECTL :
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_BANKSELECTL, bData2);
					break;
				case CC_RESETALL:
                    m_fEmpty = FALSE;
					if (bData2)
					{
						bReturn = bReturn && m_Volume[nPart].RecordMIDI(stTime, 100);
						bReturn = bReturn && m_Pan[nPart].RecordMIDI(stTime, 64);
					}
					bReturn = bReturn && m_Expression[nPart].RecordMIDI(stTime, 127);
					bReturn = bReturn && m_PitchBend[nPart].RecordMIDI(stTime, 0x2000);
					bReturn = m_ModWheel[nPart].RecordMIDI(stTime, 0);
					bData2 = 0;
					// fall through into Sustain Off case....
        
				case CC_SUSTAIN :
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SUSTAIN, bData2);
					break;
				case CC_ALLSOUNDSOFF:
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
					break;
				case CC_ALLNOTESOFF:
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_ALLOFF, 0);
					break;
				case CC_DATAENTRYMSB:
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_DATAENTRYMSB, bData2);
					break;
				case CC_DATAENTRYLSB:
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_DATAENTRYLSB, bData2);
					break;
				case CC_NRPN_LSB :
				case CC_NRPN_MSB :
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_NRPN, bData2);
					break;
				case CC_RPN_LSB:
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_RPN_LSB, bData2);
					break; 
				case CC_RPN_MSB:
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_RPN_MSB, bData2);
					break;
				case CC_MONOMODE :
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_MONOMODE, bData2);
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
					break;
				case CC_POLYMODE :
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_CC_POLYMODE, bData2);
					bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_SOUNDSOFF, 0);
					break;
				default:
					break;
				}
				break;

			case MIDI_PCHANGE :
				bReturn = m_Notes.RecordEvent(stTime, nPart, NOTE_PROGRAMCHANGE, bData1);
				break;
        
			case MIDI_PBEND :
                m_fEmpty = FALSE;
				{
					WORD nBend;
					nBend = bData2 << 7;
					nBend |= bData1;
					bReturn = m_PitchBend[nPart].RecordMIDI(stTime,(long)nBend);
				}
				break;
			}
		}
	}
    ::LeaveCriticalSection(&m_CriticalSection);

    return bReturn;
}

/*****************************************************************************
 * CControlLogic::RecordSysEx()
 *****************************************************************************
 * Record a MIDI SysEx message into this channel group.  
 * This dispatches the different MIDI
 * messages to the different receptor objects.
 */
HRESULT	CControlLogic::RecordSysEx(DWORD dwSysExLength,BYTE *pSysExData, STIME stTime)
{
	HRESULT hSuccess = S_OK;
	int nPart;
	int nTune;
	DWORD dwAddress;
	
    BOOL fClearAll = FALSE;
	BOOL fResetPatches = FALSE;
	if (dwSysExLength < 6)
    {
        return E_FAIL;
    }

	switch (pSysExData[1])	// ID number
	{
	case 0x7E :	// General purpose ID
		if (pSysExData[3] == 0x09) 
		{
			GMReset();
			fClearAll = TRUE;
			fResetPatches = TRUE;
		}
		break;
	case 0x7F : // Real time ID
		if (pSysExData[3] == 0x04)
		{
			if (pSysExData[4] == 1)	// Master Volume
			{
				m_Notes.RecordEvent(stTime, 0, NOTE_MASTERVOLUME, pSysExData[6]);
			}
		}
		break;
	case 0x41 : // Roland
		if (dwSysExLength < 11)
        {
            return E_FAIL;
        }
		if (pSysExData[3] != 0x42) break;
		if (pSysExData[4] != 0x12) break;
		nPart = pSysExData[6] & 0xF;
		dwAddress = (pSysExData[5] << 16) |
			((pSysExData[6] & 0xF0) << 8) | pSysExData[7];
		switch (dwAddress)
		{
		case 0x40007F :		// GS Reset.
			GMReset();
			m_fXGActive = FALSE;
			fClearAll = TRUE;
			m_fGSActive = TRUE;
			fResetPatches = TRUE;
			break;
		case 0x401002 :		// Set Receive Channel.
			if (m_fGSActive)
			{
				if (pSysExData[8])
				{
					m_Notes.RecordEvent(stTime, nPart, NOTE_ASSIGNRECEIVE, pSysExData[8] - 1);
				}
			}
			break;
		case 0x401015 :		// Use for Rhythm.
			if (m_fGSActive)
			{
				m_bDrums[nPart] = pSysExData[8];
				fClearAll = TRUE;
			}
			break;
		case 0x401040 :		// Scale Tuning.
			if (m_fGSActive)
			{
				for (nTune = 0;nTune < 12; nTune++)
				{
					if (pSysExData[9 + nTune] & 0x80) break;
					m_prScaleTune[nPart][nTune] = 
						(PREL) pSysExData[8 + nTune] - (PREL) 64;
				}
			}
			break;
		}
		break;
	case 0x43 : // Yamaha
		if ((pSysExData[3] == 0x4C) &&
			(pSysExData[4] == 0) &&
			(pSysExData[5] == 0) &&
			(pSysExData[6] == 0x7E) &&
			(pSysExData[7] == 0))
		{	// XG System On
			m_fXGActive = TRUE;
			m_fGSActive = FALSE;
			GMReset();
			m_fXGActive = TRUE;
			m_bDrums[0] = 0;
			m_bBankH[0] = 127;
			fClearAll = TRUE;
			fResetPatches = TRUE;
		}
		break;
	}
	if (fClearAll)
	{
		m_pSynth->AllNotesOff();
		Flush(0);
		for (nPart = 0;nPart < 16;nPart++)
		{        
			m_Notes.RecordEvent(stTime, nPart, NOTE_SUSTAIN, 0);
			m_Volume[nPart].RecordMIDI(stTime, 100);
			m_Pan[nPart].RecordMIDI(stTime, 64);
			m_Expression[nPart].RecordMIDI(stTime, 127);
			m_PitchBend[nPart].RecordMIDI(stTime, 0x2000);
			m_ModWheel[nPart].RecordMIDI(stTime, 0);
		}
	}
	if (fResetPatches)
	{
		for (nPart = 0;nPart < 16;nPart++)
		{     
			if ((nPart == 0) && (m_fXGActive))
			{
				m_Notes.RecordEvent(stTime-1, nPart, NOTE_CC_BANKSELECTH, 127);
			}
			else
			{
				m_Notes.RecordEvent(stTime-1, nPart, NOTE_CC_BANKSELECTH, 0);
			}
			m_Notes.RecordEvent(stTime-1, nPart, NOTE_CC_BANKSELECTL, 0);
			m_Notes.RecordEvent(stTime, nPart, NOTE_PROGRAMCHANGE, 0);
		}
	}

	return hSuccess;
}

/*****************************************************************************
 * CControlLogic::SetChannelPriority()
 *****************************************************************************
 * Set the priority for a given channel, within this channel group.
 */
HRESULT	CControlLogic::SetChannelPriority(DWORD dwChannel,DWORD dwPriority)
{
    DWORD dwPart;
	for (dwPart = 0;dwPart < 16; dwPart++)
	{
		if (m_bPartToChannel[dwPart] == dwChannel)
		{
        	m_dwPriority[dwPart] = dwPriority;
        }
	}
	return S_OK;
}

/*****************************************************************************
 * CControlLogic::GetChannelPriority()
 *****************************************************************************
 * Retrieve the priority for a given channel, within this channel group.
 */
HRESULT	CControlLogic::GetChannelPriority(DWORD dwChannel,LPDWORD pdwPriority)
{
    DWORD dwPart;
	for (dwPart = 0;dwPart < 16; dwPart++)
	{
		if (m_bPartToChannel[dwPart] == dwChannel)
		{
        	*pdwPriority = m_dwPriority[dwPart];
			break;
        }
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\midi.cpp ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//      MIDI.cpp
//

#include "common.h"

#define STR_MODULENAME "DDKSynth.sys:Midi: "

#include "math.h"

#pragma code_seg()
#pragma data_seg()

CMIDIDataList * CMIDIRecorder::m_sFreeList = (CMIDIDataList *) NULL;
ULONG CMIDIRecorder::sm_cRefCnt = 0;

//
// Array for converting MIDI to volume.
// value = log10((index/127)^4)*1000 where index = 0..127
//
const VREL vrMIDIToVREL[] = {
//  0       1       2       3       4       5       6       7
    -9600,  -8415,  -7211,  -6506,  -6006,  -5619,  -5302,  -5034,
    -4802,  -4598,  -4415,  -4249,  -4098,  -3959,  -3830,  -3710,
    -3598,  -3493,  -3394,  -3300,  -3211,  -3126,  -3045,  -2968,
    -2894,  -2823,  -2755,  -2689,  -2626,  -2565,  -2506,  -2449,
    -2394,  -2341,  -2289,  -2238,  -2190,  -2142,  -2096,  -2050,
    -2006,  -1964,  -1922,  -1881,  -1841,  -1802,  -1764,  -1726,
    -1690,  -1654,  -1619,  -1584,  -1551,  -1518,  -1485,  -1453,
    -1422,  -1391,  -1361,  -1331,  -1302,  -1273,  -1245,  -1217,
    -1190,  -1163,  -1137,  -1110,  -1085,  -1059,  -1034,  -1010,
    -985,   -961,   -938,   -914,   -891,   -869,   -846,   -824,
    -802,   -781,   -759,   -738,   -718,   -697,   -677,   -657,
    -637,   -617,   -598,   -579,   -560,   -541,   -522,   -504,
    -486,   -468,   -450,   -432,   -415,   -397,   -380,   -363,
    -347,   -330,   -313,   -297,   -281,   -265,   -249,   -233,
    -218,   -202,   -187,   -172,   -157,   -142,   -127,   -113,
    -98,    -84,    -69,    -55,    -41,    -27,    -13,    0
};

/*****************************************************************************
 * Constructor for CMidiData object
 *****************************************************************************/
/*****************************************************************************
 * CMIDIData::CMIDIData()
 *****************************************************************************
 * Constructor for this object.
 */
CMIDIData::CMIDIData()
{
    m_stTime = 0;
    m_lData = 0;
}

/*****************************************************************************
 * CMIDIRecorder::CMIDIRecorder()
 *****************************************************************************
 * Constructor for this object.
 */
CMIDIRecorder::CMIDIRecorder()
{
    m_lCurrentData = 0;
    m_stCurrentTime = 0;
    KeInitializeSpinLock(&m_SpinLock);
    ++sm_cRefCnt;
}

/*****************************************************************************
 * CMIDIRecorder::~CMIDIRecorder()
 *****************************************************************************
 * Destructor for this object.
 */
CMIDIRecorder::~CMIDIRecorder()
{
    ClearMIDI(0x7FFFFFFF);

    --sm_cRefCnt;
    if(sm_cRefCnt == 0)
    {
        if(CMIDIRecorder::m_sFreeList != NULL)
        {
            while(!CMIDIRecorder::m_sFreeList->IsEmpty())
            {
                CMIDIData *event;
                event = CMIDIRecorder::m_sFreeList->RemoveHead();
                delete event;
            }
            delete CMIDIRecorder::m_sFreeList;
            CMIDIRecorder::m_sFreeList = NULL;
        }
    }
}

/*****************************************************************************
 * CMIDIRecorder::Init()
 *****************************************************************************
 * Initialize the CMIDIRecorder object.  Make a list of CMIDIData objects for later.
 */
void CMIDIRecorder::Init()
{
    int nIndex;

    if(CMIDIRecorder::m_sFreeList == NULL)
    {
        CMIDIRecorder::m_sFreeList = new(NonPagedPool,'LSmD') CMIDIDataList;    //  DmSL
        if(CMIDIRecorder::m_sFreeList != NULL)
        {
            CMIDIRecorder::m_sFreeList->RemoveAll();
            for(nIndex = 0; nIndex < MAX_MIDI_EVENTS; nIndex++)
            {
                CMIDIData* pEvent;

                pEvent = new(NonPagedPool,'MSmD') CMIDIData;         //  DmSM
                if(pEvent != NULL)
                {
                    CMIDIRecorder::m_sFreeList->AddHead(pEvent);
                }
            }
        }
    }
}

/*****************************************************************************
 * CMIDIRecorder::GrabSpinLock()
 *****************************************************************************
 * In kernel mode, acquire the spinlock.
 */
inline void CMIDIRecorder::GrabSpinLock()
{
    KeAcquireSpinLock(&m_SpinLock, &m_OldIrql);
}

/*****************************************************************************
 * CMIDIRecorder::ReleaseSpinLock()
 *****************************************************************************
 * In kernel mode, release the spinlock.
 */
inline void CMIDIRecorder::ReleaseSpinLock()
{
    KeReleaseSpinLock(&m_SpinLock, m_OldIrql);
}

/*****************************************************************************
 * CMIDIRecorder::FlushMIDI()
 *****************************************************************************
 * Remove all events from the event list, and put them back on the free list.
 */
BOOL CMIDIRecorder::FlushMIDI(STIME stTime)
{
    GrabSpinLock();

    CMIDIData *pMD;
    CMIDIData *pLast = NULL;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            if (pLast == NULL)
            {
                m_EventList.RemoveAll();
            }
            else
            {
                pLast->SetNext(NULL);
            }
            if (CMIDIRecorder::m_sFreeList)
            {
                CMIDIRecorder::m_sFreeList->Cat(pMD);
            }
            break;
        }
        pLast = pMD;
    }

    BOOL fIsEmpty = m_EventList.IsEmpty();

    ReleaseSpinLock();

    return fIsEmpty;
}

/*****************************************************************************
 * CMIDIRecorder::ClearMIDI()
 *****************************************************************************
 * Clear out any MIDI that is before the given time.
 */
BOOL CMIDIRecorder::ClearMIDI(STIME stTime)
{
    GrabSpinLock();

    CMIDIData *pMD;
    for (;pMD = m_EventList.GetHead();)
    {
        if (pMD->m_stTime < stTime)
        {
            m_EventList.RemoveHead();
            m_stCurrentTime = pMD->m_stTime;
            m_lCurrentData = pMD->m_lData;
            if (CMIDIRecorder::m_sFreeList)
            {
                CMIDIRecorder::m_sFreeList->AddHead(pMD);
            }
            else
            {
                delete pMD;
            }
        }
        else break;
    }

    BOOL fIsEmpty = m_EventList.IsEmpty();

    ReleaseSpinLock();

    return fIsEmpty;
}

/*****************************************************************************
 * CMIDIRecorder::VelocityToVolume()
 *****************************************************************************
 * Translate from 16-bit velocity to a VREL volume (dB).
 */
VREL CMIDIRecorder::VelocityToVolume(WORD nVelocity)
{
    return (::vrMIDIToVREL[nVelocity]);
}

/*****************************************************************************
 * CMIDIRecorder::RecordMIDI()
 *****************************************************************************
 * Queue up a given note at a given time.  Use an element from the free pool,
 * or allocate a new one if the pool is exhausted.
 */
BOOL CMIDIRecorder::RecordMIDI(STIME stTime, long lData)
{
    GrabSpinLock();

    CMIDIData *pMD = NULL;
    if (CMIDIRecorder::m_sFreeList)
    {
        pMD = CMIDIRecorder::m_sFreeList->RemoveHead();
    }

    if (pMD == NULL)
    {
        pMD = new(NonPagedPool,'MSmD') CMIDIData;   //  DmSM
    }

    if (pMD != NULL)
    {
        CMIDIData *pScan = m_EventList.GetHead();
        CMIDIData *pNext;

        pMD->m_stTime = stTime;
        pMD->m_lData = lData;
        if (pScan == NULL)
        {
            m_EventList.AddHead(pMD);
        }
        else
        {
            if (pScan->m_stTime > stTime)
            {
                m_EventList.AddHead(pMD);
            }
            else
            {
                for (;pScan != NULL; pScan = pNext)
                {
                    pNext = pScan->GetNext();
                    if (pNext == NULL)
                    {
                        pScan->SetNext(pMD);
                    }
                    else
                    {
                        if (pNext->m_stTime > stTime)
                        {
                            pMD->SetNext(pNext);
                            pScan->SetNext(pMD);
                            break;
                        }
                    }
                }
            }
        }
        ReleaseSpinLock();
        return (TRUE);
    }

    ReleaseSpinLock();
    Trace(1,"MIDI Event pool empty.\n");
    return (FALSE);
}

/*****************************************************************************
 * CMIDIRecorder::GetData()
 *****************************************************************************
 * Retrieve any data that is at or before the given time.
 */
long CMIDIRecorder::GetData(STIME stTime)
{
    GrabSpinLock();

    CMIDIData *pMD = m_EventList.GetHead();
    long lData = m_lCurrentData;
    for (;pMD;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime > stTime)
        {
            break;
        }
        lData = pMD->m_lData;
    }

    ReleaseSpinLock();

    return (lData);
}

/*****************************************************************************
 * CNoteIn::RecordNote()
 *****************************************************************************
 * Record the given note object into the NoteIn receptor.
 */
BOOL CNoteIn::RecordNote(STIME stTime, CNote * pNote)
{
    long lData = pNote->m_bPart << 16;
    lData |= pNote->m_bKey << 8;
    lData |= pNote->m_bVelocity;
    return (RecordMIDI(stTime,lData));
}

/*****************************************************************************
 * CNoteIn::RecordEvent()
 *****************************************************************************
 * Record the given note object into the NoteIn receptor.
 */
BOOL CNoteIn::RecordEvent(STIME stTime, DWORD dwPart, DWORD dwCommand, BYTE bData)
{
    long lData = dwPart;
    lData <<= 8;
    lData |= dwCommand;
    lData <<= 8;
    lData |= bData;
    return (RecordMIDI(stTime,lData));
}

/*****************************************************************************
 * CNoteIn::GetNote()
 *****************************************************************************
 * Retrieve the first note at or before the given time.
 */
BOOL CNoteIn::GetNote(STIME stTime, CNote * pNote)
{
    GrabSpinLock();

    CMIDIData *pMD = m_EventList.GetHead();
    if (pMD != NULL)
    {
        if (pMD->m_stTime <= stTime)
        {
            pNote->m_stTime = pMD->m_stTime;
            pNote->m_bPart = (BYTE) (pMD->m_lData >> 16);
            pNote->m_bKey = (BYTE) (pMD->m_lData >> 8) & 0xFF;
            pNote->m_bVelocity = (BYTE) pMD->m_lData & 0xFF;
            m_EventList.RemoveHead();
            if (CMIDIRecorder::m_sFreeList)
            {
                CMIDIRecorder::m_sFreeList->AddHead(pMD);
            }
            else
            {
                delete pMD;
            }
            ReleaseSpinLock();
            return (TRUE);
        }
    }

    ReleaseSpinLock();
    return (FALSE);
}

/*****************************************************************************
 * CNoteIn::FlushMIDI()
 *****************************************************************************
 * Flush out any MIDI after the given time, with attention given
 * to special events.
 */
void CNoteIn::FlushMIDI(STIME stTime)
{
    GrabSpinLock();

    CMIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            pMD->m_stTime = stTime;     // Play now.

            BYTE command = (BYTE) ((pMD->m_lData & 0x0000FF00) >> 8);
            if (command < NOTE_PROGRAMCHANGE)
            {
                pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
            }
            //  otherwise it is a special command
            //  so don't mess with the velocity
        }
    }

    ReleaseSpinLock();
}


/*****************************************************************************
 * CNoteIn::FlushPart()
 *****************************************************************************
 * Flush the given channel, with attention given to special events.
 */
void CNoteIn::FlushPart(STIME stTime, BYTE bChannel)
{
    GrabSpinLock();

    CMIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            if (bChannel == (BYTE) (pMD->m_lData >> 16))
            {
                pMD->m_stTime = stTime;     // Play now.

                BYTE command = (BYTE) ((pMD->m_lData & 0x0000FF00) >> 8);
                if (command < NOTE_PROGRAMCHANGE)
                {
                    pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
                }
                //  otherwise it is a special command
                //  so don't mess with the velocity
            }
        }
    }

    ReleaseSpinLock();
}

/*****************************************************************************
 * CModWheelIn::GetModulation()
 *****************************************************************************
 * Get the modulation data.
 */
DWORD CModWheelIn::GetModulation(STIME stTime)
{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}

/*****************************************************************************
 * CPitchBendIn::CPitchBendIn()
 *****************************************************************************
 * Constructor for this object.
 */
CPitchBendIn::CPitchBendIn()
{
    m_lCurrentData = 0x2000;    // initially at midpoint, no bend
    m_prRange = 200;           // whole tone range by default.
}

/*****************************************************************************
 * CPitchBendIn::GetPitch()
 *****************************************************************************
 * Get the pitch data.
 * Note: we don't keep a time-stamped range.
 * If people are changing the pitch bend range often, this won't work right,
 * but that didn't seem likely enough to warrant a new list.
 */
PREL CPitchBendIn::GetPitch(STIME stTime)
{
    PREL prResult = (PREL) CMIDIRecorder::GetData(stTime);
    prResult -= 0x2000;         // Subtract MIDI Midpoint.
    prResult *= m_prRange;  // adjust by current range
    prResult >>= 13;
    return (prResult);
}

/*****************************************************************************
 * CVolumeIn::CVolumeIn()
 *****************************************************************************
 * Constructor for this object.
 */
CVolumeIn::CVolumeIn()
{
    m_lCurrentData = 100;
}

/*****************************************************************************
 * CVolumeIn::GetVolume()
 *****************************************************************************
 * Get the volume data.
 */
VREL CVolumeIn::GetVolume(STIME stTime)
{
    long lResult = CMIDIRecorder::GetData(stTime);
    return (::vrMIDIToVREL[lResult]);
}

/*****************************************************************************
 * CExpressionIn::CExpressionIn()
 *****************************************************************************
 * Constructor for this object.
 */
CExpressionIn::CExpressionIn()
{
    m_lCurrentData = 127;
}

/*****************************************************************************
 * CExpressionIn::GetVolume()
 *****************************************************************************
 * Get the volume data.
 */
VREL CExpressionIn::GetVolume(STIME stTime)
{
    long lResult = CMIDIRecorder::GetData(stTime);
    return (::vrMIDIToVREL[lResult]);
}

/*****************************************************************************
 * CPanIn::CPanIn()
 *****************************************************************************
 * Constructor for this object.
 */
CPanIn::CPanIn()
{
    m_lCurrentData = 64;
}

/*****************************************************************************
 * CPanIn::GetPan()
 *****************************************************************************
 * Get the pan data.
 */
long CPanIn::GetPan(STIME stTime)
{
    long lResult = (long) CMIDIRecorder::GetData(stTime);
    return (lResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\mix.cpp ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//      Mix.cpp
//      Mix engines for MSSynth

#include "common.h"

#define STR_MODULENAME "DDKSynth.sys:Mix: "

#pragma warning(disable : 4101 4102 4146)  

#ifdef _ALPHA_

extern "C" {
	int __ADAWI(short, short *);
};
#pragma intrinsic(__ADAWI)

#define ALPHA_OVERFLOW 2 
#define ALPHA_NEGATIVE 8

#else // !_ALPHA_
//  TODO -- overflow detection for ia64? (+ axp64?)
#endif // !_ALPHA_

#pragma code_seg()
/*****************************************************************************
 * CDigitalAudio::Mix8()
 *****************************************************************************
 * Implement a stereo eight-bit mix.
 * Heavily optimized for x86 non-MMX, plus C code for non-x86.
 */
DWORD CDigitalAudio::Mix8(short * pBuffer,      DWORD dwLength, 
                          DWORD dwDeltaPeriod,  VFRACT vfDeltaLVolume,
                          VFRACT vfDeltaRVolume,PFRACT pfDeltaPitch, 
                          PFRACT pfSampleLength,PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM, lLM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8;  
	dwLength <<= 1;

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lLM = pcWave[dwPosition];
        lM = ((pcWave[dwPosition + 1] - lLM) * dwFract) >> 12;
        lM += lLM;
        lLM = lM;

        lLM *= vfLVolume;
        lLM >>= 5;         // Signal bumps up to 15 bits.
        lM *= vfRVolume;
        lM >>= 5;

#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lLM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else // !_ALPHA_
    // TODO -- overflow detection on ia64 (+ axp64?)
#endif // !_ALPHA_

#else // _X86_  (dead code)
      //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lLM;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:
#endif // _X86_  (dead code)

		dwI += 2;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;

// esi = b == dwIncDelta

; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = (dwLength - dwI) / 2;	// Remaining span.

	mov	edx, edi
	neg	edx
	shr	edx, 1		// edx = a

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543	

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI >> 1);
; 1094 : }

	lea	edx, [edx*2+2]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

; 1018 : 				lLM = lM;
; 1019 : 				lLM *= vfLVolume;
; 1020 : 				lLM >>= 5;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lLM;
; 1028 : 						lM *= vfRVolume;
; 1029 : 						lM >>= 5;
; 1030 : 				pBuffer[dwI+1] += (short) lM;
; 1036 : 
; 1037 : 				dwI += 2;
	sub	edx, eax

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_lx
no_oflowlx:

	imul	esi, edx

; 1038 : 			} while (--dwIncDelta);

	sar	esi, 5					; 00000005H
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	jo	overflow_rx

no_oflowrx:

	add	edi, 2
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:

; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 984  : 			{
; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaLVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfLVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfLVFract += vfDeltaLVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;
; 998  :             vfRVFract += vfDeltaRVolume;

	sar	ecx, 8
	mov	DWORD PTR vfLVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR vfDeltaRVolume

	mov	DWORD PTR vfLVolume, edx
	mov	edx, DWORD PTR vfRVFract

	add	edx, esi
	mov	DWORD PTR pfPitch, ecx

	mov	DWORD PTR vfRVFract, edx
	mov	esi, DWORD PTR dwDeltaPeriod

; 999  :             vfRVolume = vfRVFract >> 8;

	sar	edx, 8
	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	mov	DWORD PTR vfRVolume, edx
	jmp	$L30541

// Handle truncation.

overflow_l:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowl
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflowl

overflow_r:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowr
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowr

overflow_lx:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowlx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowlx

overflow_rx:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowrx
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowrx

$L30543:
; 1041 : 		}
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	add	ebx, ecx
	and	esi, 4095				; 00000fffH

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1049 :         lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

    sub	edx, eax
	
    imul	edx, esi

; 1052 :         lLM = lM;
; 1053 :         lLM *= vfLVolume;
; 1054 :         lLM >>= 5;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lLM;

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_l
no_oflowl:

; 1078 :         lM *= vfRVolume;
; 1079 : 		lM >>= 5;

	imul	esi, edx

; 1080 : 		pBuffer[dwI+1] += (short) lM;
; 1085 : no_oflowr:
; 1087 : 		dwI += 2;

	sar	esi, 5					; 00000005H
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	mov	edx, DWORD PTR pfPFract

	jo	overflow_r

no_oflowr:
; 978  : 
; 979  :     for (dwI = 0; dwI < dwLength; )

	add	edi, 2
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}

/*****************************************************************************
 * CDigitalAudio::MixMono8()
 *****************************************************************************
 * Implement a mono eight-bit mix.
 * Heavily optimized for x86 non-MMX, plus C code for non-x86.
 */
DWORD CDigitalAudio::MixMono8(short * pBuffer,    DWORD dwLength,
                              DWORD dwDeltaPeriod,VFRACT vfDeltaVolume,
                              PFRACT pfDeltaPitch,PFRACT pfSampleLength, 
                              PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = m_vfLastLVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around. 

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lM = pcWave[dwPosition];
	    lM += ((pcWave[dwPosition + 1] - lM) * dwFract) >> 12;
		lM *= vfVolume;
		lM >>= 5;

#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#else // !_ALPHA_
    //  TODO -- overflow code on ia64 (+ axp64?)
#endif // !_ALPHA_

#else // _X86_  (dead code)
      // Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:
#endif  // _X86_  (dead code)
		dwI++;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:

; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta

; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;

; 1009 : 	a = dwLength - dwI;	// Remaining span.

	mov	edx, edi
	neg	edx

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI);
; 1094 : }

	lea	edx, [edx+1]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
		
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

	sub	edx, eax

; 1018 : 				lLM = lM;
; 1019 : 				lLM *= vfLVolume;
; 1020 : 				lLM >>= 5;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lLM;
; 1027 : no_oflowx:	
; 1037 : 				++dwI;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	mov	ecx, DWORD PTR pfPitch
	add	edx, eax

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	jo	overflow_x

no_oflowx:

	inc	edi
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 984  : 			{
; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfVFract += vfDeltaVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;

	sar	ecx, 8
	mov	DWORD PTR vfVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR dwDeltaPeriod


	mov	DWORD PTR vfVolume, edx
	mov	DWORD PTR pfPitch, ecx


	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	jmp	$L30541

// Handle truncation.

overflow_:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflow
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflow

overflow_x:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	add	ebx, ecx
	and	esi, 4095				; 00000fffH

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1049 :         lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lLM = lM;
; 1053 :         lLM *= vfLVolume;
; 1054 :         lLM >>= 5;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lLM;

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	jo	overflow_
no_oflow:
	inc	edi
	mov	edx, DWORD PTR pfPFract

; 979  :     for (dwI = 0; dwI < dwLength; )

	mov	ecx, DWORD PTR pfPitch
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    m_vfLastLVolume = vfVolume;
    m_vfLastRVolume = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}


/*****************************************************************************
 * CDigitalAudio::Mix16()
 *****************************************************************************
 * Implement a stereo sixteen-bit mix.
 * Heavily optimized for x86 non-MMX, plus C code for non-x86.
 */
DWORD CDigitalAudio::Mix16(short * pBuffer,      DWORD dwLength, 
                           DWORD dwDeltaPeriod,  VFRACT vfDeltaLVolume, 
                           VFRACT vfDeltaRVolume,PFRACT pfDeltaPitch, 
                           PFRACT pfSampleLength,PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8; 
	dwLength <<= 1;

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
				pfSamplePos -= pfLoopLength;
			}
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = ((pcWave[dwPosition+1] - lA) * dwFract);
        lM >>= 12;
        lM += lA;
        lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;
#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lA, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else // !_ALPHA_
    //  TODO -- overflow detection on ia64 (+ axp64?)
#endif // !_ALPHA_
#else // _X86_  (dead code)
      //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lA;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:

#endif // _X86_  (dead code)
		dwI += 2;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta
; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = (dwLength - dwI) / 2;	// Remaining span.

	mov	edx, edi
	neg	edx
	shr	edx, 1		// edx = a

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI >> 1);
; 1094 : }

	lea	edx, [edx*2+2]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
		
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1014 : 				lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]
	sub	edx, eax

; 1018 : 				lA = lM;
; 1019 : 				lA *= vfLVolume;
; 1020 : 				lA >>= 13;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lA;
; 1027 : no_oflowlx:	
; 1028 : 						lM *= vfRVolume;
; 1029 : 						lM >>= 13;
; 1030 : 				pBuffer[dwI+1] += (short) lM;
; 1035 : no_oflowrx:
; 1037 : 				dwI += 2;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax
	mov	eax, DWORD PTR pBufX

	imul	esi, edx

	sar	esi, 13					; 0000000dH

	add	WORD PTR [eax+edi*2], si

	mov	esi, DWORD PTR vfRVolume
	jo	overflow_lx
no_oflowlx:

	imul	esi, edx

; 1038 : 			} while (--dwIncDelta);

	sar	esi, 13					; 0000000dH
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	jo	overflow_rx

no_oflowrx:

	add	edi, 2
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaLVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfLVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfLVFract += vfDeltaLVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;
; 998  :             vfRVFract += vfDeltaRVolume;

	sar	ecx, 8
	mov	DWORD PTR vfLVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR vfDeltaRVolume

	mov	DWORD PTR vfLVolume, edx
	mov	edx, DWORD PTR vfRVFract

	add	edx, esi
	mov	DWORD PTR pfPitch, ecx

	mov	DWORD PTR vfRVFract, edx
	mov	esi, DWORD PTR dwDeltaPeriod

; 999  :             vfRVolume = vfRVFract >> 8;

	sar	edx, 8
	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	mov	DWORD PTR vfRVolume, edx
	jmp	$L30541

// Handle truncation.
overflow_l:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowl
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflowl

overflow_r:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowr
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowr

overflow_lx:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowlx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowlx

overflow_rx:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowrx
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowrx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	and	esi, 4095				; 00000fffH
	add	ebx, ecx

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1049 :         lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lA = lM;
; 1053 :         lA *= vfLVolume;
; 1054 :         lA >>= 13;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lA;

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_l
no_oflowl:

; 1077 : no_oflowl:	
; 1078 :         lM *= vfRVolume;
; 1079 : 		lM >>= 13;

	imul	esi, edx

; 1080 : 		pBuffer[dwI+1] += (short) lM;
; 1085 : no_oflowr:
; 1086 : #endif  /* _ALPHA */
; 1087 : 		dwI += 2;

	sar	esi, 13					; 0000000dH
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	mov	edx, DWORD PTR pfPFract

	jo	overflow_r
no_oflowr:

	add	edi, 2

; 978  : 
; 979  :     for (dwI = 0; dwI < dwLength; )

	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    m_vfLastLVolume = vfLVolume;
    m_vfLastRVolume = vfRVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}



/*****************************************************************************
 * CDigitalAudio::MixMono16()
 *****************************************************************************
 * Implement a mono sixteen-bit mix.
 * Heavily optimized for x86 non-MMX, plus C code for non-x86.
 */
DWORD CDigitalAudio::MixMono16(short * pBuffer,    DWORD dwLength,
                               DWORD dwDeltaPeriod,VFRACT vfDeltaVolume,
                               PFRACT pfDeltaPitch,PFRACT pfSampleLength, 
                               PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = m_vfLastLVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.

#ifndef _X86_
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        lM *= vfVolume; 
        lM >>= 13;         // Signal bumps up to 12 bits.

#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#else // !_ALPHA_
    // TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#else // _X86_  (dead code)
        // Keep this around so we can use it to generate new assembly code (see below...)
        pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:	
#endif // _X86  (dead code)
		dwI++;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta
; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = dwLength - dwI;	// Remaining span.

	mov	edx, edi
	neg	edx

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:
	push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI);
; 1094 : }

	lea	edx, [edx+1]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

; 1018 : 				lA = lM;
; 1019 : 				lA *= vfLVolume;
; 1020 : 				lA >>= 13;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lA;
; 1027 : no_oflowx:	
; 1037 : 				++dwI;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax
	mov	ecx, DWORD PTR pfPitch

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	jo	overflow_x
no_oflowx:

; 1038 : 			} while (--dwIncDelta);

	inc	edi
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfVFract += vfDeltaVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfVolume = vfVFract >> 8;

	sar	ecx, 8
	mov	DWORD PTR vfVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR dwDeltaPeriod

	mov	DWORD PTR vfVolume, edx
	mov	DWORD PTR pfPitch, ecx


	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	jmp	$L30541

// Handle truncation.
overflow_:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflow
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflow

overflow_x:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	and	esi, 4095				; 00000fffH
	add	ebx, ecx

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1049 :         lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lA = lM;
; 1053 :         lA *= vfVolume;
; 1054 :         lA >>= 13;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lA;

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	jo	overflow_
no_oflow:
; 1077 : no_oflowl:	
; 1087 : 		++dwI;

	inc	edi
	mov	edx, DWORD PTR pfPFract

; 979  :     for (dwI = 0; dwI < dwLength; )

	mov	ecx, DWORD PTR pfPitch
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}
	dwI += dwLength;

#endif // _X86_
    m_vfLastLVolume = vfVolume;
    m_vfLastRVolume = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\plclock.cpp ===
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.

/*      CPhaseLockClock

*/

#include "common.h"

#define STR_MODULENAME "DDKSynth.sys:PLClock: "

#include "plclock.h"

#define MILS_TO_REF 10000

#pragma code_seg()
/*****************************************************************************
 * CPhaseLockClock::CPhaseLockClock()
 *****************************************************************************
 * Constructor for the CPhaseLockClock object.
 */
CPhaseLockClock::CPhaseLockClock()
{
    m_rfOffset = 0;
}

/*****************************************************************************
 * CPhaseLockClock::Start()
 *****************************************************************************
 * Start this clock.  When the clock starts, it needs to mark down the 
 * difference between the time it is given and its concept of time. 
 */
void CPhaseLockClock::Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime)
{
    m_rfOffset = rfMasterTime - rfSlaveTime;
}   

/*****************************************************************************
 * CPhaseLockClock::GetSlaveTime()
 *****************************************************************************
 * Convert the passed time to use the same base as the master clock.
 */
void CPhaseLockClock::GetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)
{
    rfSlaveTime += m_rfOffset;
    *prfTime = rfSlaveTime;
}

/*****************************************************************************
 * CPhaseLockClock::SetSlaveTime()
 *****************************************************************************
 * Reset the relationship between the two clocks.
 */
void CPhaseLockClock::SetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)
{
    rfSlaveTime -= m_rfOffset;
    *prfTime = rfSlaveTime;
}

/*****************************************************************************
 * CPhaseLockClock::SyncToMaster()
 *****************************************************************************
 * SyncToTime provides the needed magic to keep the clock
 * in sync. Since the clock uses its own clock (rfSlaveTime)
 * to increment, it can drift. This call provides a reference
 * time which the clock compares with its internal 
 * concept of time. The difference between the two is
 * considered the drift. Since the sync time may increment in
 * a lurching way, the correction has to be subtle. 
 * So, the difference between the two is divided by
 * 100 and added to the offset.
 */
void CPhaseLockClock::SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime)
{
    rfSlaveTime += m_rfOffset;
    rfSlaveTime -= rfMasterTime;    // Find difference between calculated and expected time.
    rfSlaveTime /= 100;             // Reduce in magnitude.
    m_rfOffset -= rfSlaveTime;      // Subtract that from the original offset.
}

/*****************************************************************************
 * CSampleClock::CSampleClock()
 *****************************************************************************
 * Constructor for CSampleClock object.
 */
CSampleClock::CSampleClock()
{
    m_llStart = 0;
    m_dwSampleRate = 22050;
}

/*****************************************************************************
 * CSampleClock::Start()
 *****************************************************************************
 * Start the sample clock.  Start any corresponding phase lock clock.
 */
void CSampleClock::Start(IReferenceClock *pIClock, DWORD dwSampleRate, LONGLONG llSampleTime)
{
    REFERENCE_TIME rfStart;
    m_llStart = llSampleTime;
    m_dwSampleRate = dwSampleRate;
    if (pIClock)
    {
        pIClock->GetTime(&rfStart);
        m_PLClock.Start(rfStart,0);
    }

    llSampleTime *= (MILS_TO_REF * 1000);
    llSampleTime /= m_dwSampleRate;
    m_rfStart = llSampleTime;
}

/*****************************************************************************
 * CSampleClock::SampleToRefTime()
 *****************************************************************************
 * Convert between sample time and reference time (100ns units).
 */
void CSampleClock::SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime)
{
    llSampleTime -= m_llStart;
    llSampleTime *= (MILS_TO_REF * 1000);
    llSampleTime /= m_dwSampleRate;
    m_PLClock.GetSlaveTime(llSampleTime, prfTime);
}

/*****************************************************************************
 * CSampleClock::RefTimeToSample()
 *****************************************************************************
 * Convert between sample time and reference time (100ns units).
 */
LONGLONG CSampleClock::RefTimeToSample(REFERENCE_TIME rfTime)
{
    m_PLClock.SetSlaveTime(rfTime, &rfTime);
    rfTime *= m_dwSampleRate;
    rfTime /= (MILS_TO_REF * 1000);
    return rfTime + m_llStart;
}

/*****************************************************************************
 * CSampleClock::SyncToMaster()
 *****************************************************************************
 * Sync this clock to the given sample time and the given reference clock.
 */
void CSampleClock::SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock)
{
    llSampleTime -= m_llStart;
    llSampleTime *= (MILS_TO_REF * 1000);
    llSampleTime /= m_dwSampleRate;
    if (pIClock)
    {
        REFERENCE_TIME rfMasterTime;
        pIClock->GetTime(&rfMasterTime);
        m_PLClock.SyncToMaster(llSampleTime, rfMasterTime);
    }
}

/*****************************************************************************
 * CSampleClock::SyncToMaster()
 *****************************************************************************
 * Sync the two given reference times, using our phase lock clock.
 */
void CSampleClock::SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime)
{
    rfSlaveTime -= m_rfStart;
    m_PLClock.SyncToMaster(rfSlaveTime, rfMasterTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\plclock.h ===
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.

/*      PLClock.h

*/

#ifndef __PLCLOCK_H__
#define __PLCLOCK_H__

#define IReferenceClock IMasterClock

/*****************************************************************************
 * class CPhaseLockClock
 *****************************************************************************
 * This implements a clock that phase locks two reference clocks.
 */
class CPhaseLockClock
{
public:
                    CPhaseLockClock();
    void            Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime);
    void            GetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
    void            SetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
    void            SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime);

private:
    REFERENCE_TIME  m_rfOffset;
};

/*****************************************************************************
 * class CSampleClock
 *****************************************************************************
 * This implements a clock that translates between a sample time and a 
 * reference time, doing any phase locking in a child CPhaseLockClock object.
 */
class CSampleClock
{
public:
                    CSampleClock();
    void            Start(IReferenceClock *pIClock, DWORD dwSampleRate, LONGLONG llSampleTime);
    void            SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
    void            SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock);
    void            SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime);
    LONGLONG        RefTimeToSample(REFERENCE_TIME rfTime);

private:
    CPhaseLockClock m_PLClock;
    LONGLONG        m_llStart;      // Initial sample offset.
    REFERENCE_TIME  m_rfStart;
    DWORD           m_dwSampleRate;
};


#endif  // __PLCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\miniport.cpp ===
/*

    DirectMusic Software Synthesizer Miniport

    Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
*/

#include "common.h"
#include "private.h"
#include "fltsafe.h"
#include <math.h>

#define STR_MODULENAME "DDKSynth.sys:Miniport: "

/* NYI:
    more sample rates?
*/
#ifdef USE_OBSOLETE_FUNCS
VOID PutMessageWorker(PVOID Param);
#endif

// Property handler
//
NTSTATUS PropertyHandler_Support(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_Effects(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_Synth(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_SynthCaps(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_SynthDls(IN PPCPROPERTY_REQUEST);

// Misc.
NTSTATUS DefaultSynthBasicPropertyHandler(IN PPCPROPERTY_REQUEST pRequest);
NTSTATUS DefaultBasicPropertyHandler(IN PPCPROPERTY_REQUEST pRequest, IN DWORD dwSupportVerb);
NTSTATUS ValidatePropertyParams(IN PPCPROPERTY_REQUEST pRequest, IN ULONG cbSize, IN DWORD dwExcludeVerb);



/*****************************************************************************
 * PinDataRangesStream[]
 *****************************************************************************
 * Structures indicating range of valid format values for streaming pins.
 * If your device can also support legacy MIDI, include a second data range
 * here that supports KSDATAFORMAT_SUBTYPE_MIDI.
 */
static const
    KSDATARANGE_MUSIC
    PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_MUSIC),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
        },
        STATICGUIDOF(KSMUSIC_TECHNOLOGY_WAVETABLE),
        0,                                      // Channels
        0,                                      // Notes
        0x0000ffff                              // ChannelMask
    }
};

/*****************************************************************************
 * PinDataRangePointersStream[]
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for streaming pins.
 */
static const
    PKSDATARANGE
    PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

/*****************************************************************************
 * PinDataRangesAudio[]
 *****************************************************************************
 * Structures indicating range of valid format values for audio pins.
 *
 * Do not include this if you are building a hardware device that does not
 * output audio back into the system.
 */
static const
    KSDATARANGE_AUDIO
    PinDataRangesAudio[] =
{
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        2,
        16,
        16,
        22050,
        22050
    }
};

/*****************************************************************************
 * PinDataRangePointersAudio[]
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for audio pins.
 *
 * Do not include this if you are building a hardware device that does not
 * output audio back into the system.
 */
static const
    PKSDATARANGE
    PinDataRangePointersAudio[] =
{
    PKSDATARANGE(&PinDataRangesAudio[0])
};

/*****************************************************************************
 * SynthProperties[]
 *****************************************************************************
 * Array of properties supported.
 */
static const
    PCPROPERTY_ITEM
    SynthProperties[] =
{
    ///////////////////////////////////////////////////////////////////
    // Support items
    {
        &GUID_DMUS_PROP_GM_Hardware,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Support
    },
    {
        &GUID_DMUS_PROP_GS_Hardware,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Support
    },
    {
        &GUID_DMUS_PROP_XG_Hardware,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Support
    },
    {
        &GUID_DMUS_PROP_XG_Capable,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Support
    },
    {
        &GUID_DMUS_PROP_GS_Capable,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Support
    },
    {
        &GUID_DMUS_PROP_DLS1,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Support
    },
    {
        &GUID_DMUS_PROP_Effects,
        0,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Effects
    },

    ///////////////////////////////////////////////////////////////////
    // Configuration items
    // Global: Synth caps
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CAPS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SynthCaps
    },
    // Per Stream: Synth port parameters
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_PORTPARAMETERS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per Stream: Volume
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUME,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per Stream: Volume boost value
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUMEBOOST,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per Stream: Channel groups
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CHANNELGROUPS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per stream: Voice priority
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOICEPRIORITY,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per Stream: Running Stats
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_RUNNINGSTATS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },

    ///////////////////////////////////////////////////////////////////
    // Clock items

    // Per stream: Get current latency time
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_LATENCYCLOCK,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },

    ///////////////////////////////////////////////////////////////////
    // DLS items

    // Per stream: Download DLS sample
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DLS_DOWNLOAD,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SynthDls
    },
    // Per stream: Unload DLS sample
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DLS_UNLOAD,
        KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SynthDls
    },
    // Per stream: append
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DLS_APPEND,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SynthDls
    },
    // Per stream: format
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DLS_WAVEFORMAT,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_SynthDls
    }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSynth, SynthProperties);

/*****************************************************************************
 * MiniportPins[]
 *****************************************************************************
 * List of pins.  Do not expose a wave pin if you are writing a driver for a
 * hardware device that does not inject wave data back into the system.
 */
static const
    PCPIN_DESCRIPTOR
    MiniportPins[] =
{
    {
        1,1,1,  // InstanceCount
        NULL,
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStream),   // DataRangesCount
            PinDataRangePointersStream,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            &KSCATEGORY_WDMAUD_USE_PIN_NAME,            // Category
            &KSNODETYPE_DMDDKSYNTH,                     // Name
            0                                           // Reserved
        }
    },
    {
        1,1,1,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersAudio),    // DataRangesCount
            PinDataRangePointersAudio,                  // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_SOURCE,                 // Communication
            &KSCATEGORY_AUDIO,                          // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
};

/*****************************************************************************
 * MiniportNodes[]
 *****************************************************************************
 * List of nodes
 */
static const
    PCNODE_DESCRIPTOR
    MiniportNodes[] =
{
    { 0, &AutomationSynth, &KSNODETYPE_SYNTHESIZER, &KSNODETYPE_DMSYNTH}
};

/*****************************************************************************
 * MiniportConnections[]
 *****************************************************************************
 * List of connections.
 */
static const
    PCCONNECTION_DESCRIPTOR
    MiniportConnections[] =
{
    // From node            From pin        To node                 To pin
    //
    { PCFILTER_NODE,        0,              0,                      1},     // Stream in to synth.
    { 0,                    0,              PCFILTER_NODE,          1}      // Synth to audio out
};

/*****************************************************************************
 * TopologyCategories[]
 *****************************************************************************
 * List of categories.  If your driver runs a hardware device that performs
 * actual audio output (i.e. contains a DAC) and does not register a physical
 * connection to a topology miniport, then you can use KSCATEGORY_RENDER instead
 * of KSCATEGORY_DATATRANSFORM.
 *
 * Note that if you use CATEGORY_RENDER instead of CATEGORY_DATATRANSFORM,
 * you must list _AUDIO category before _RENDER, so that SysAudio and DMusic.DLL
 * will agree upon what to label your device (DMusic currently expects _AUDIO).
 *
 */
static const
    GUID TopologyCategories[] =
{
    STATICGUIDOF(KSCATEGORY_DATATRANSFORM),
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_SYNTHESIZER)
};

/*****************************************************************************
 * MiniportFilterDescriptor
 *****************************************************************************
 * Complete miniport description.
 */
static const
    PCFILTER_DESCRIPTOR
    MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    SIZEOF_ARRAY(TopologyCategories),   // CategoryCount
    TopologyCategories,                 // Categories
};

#pragma code_seg()
/*****************************************************************************
 * MapHRESULT()
 *****************************************************************************
 * Maps DMusic HRESULT to NTSTATUS
 */
NTSTATUS MapHRESULT(IN  HRESULT   hr)
{
    PAGED_CODE();

    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    // NYI: map hr to ntStatus

    return ntStatus;
}

/*****************************************************************************
 * CreateMiniportDmSynth()
 *****************************************************************************
 * Creates a DMus_Synth miniport driver for the adapter.
 * This uses a macro from STDUNK.H to do all the work.
 */
NTSTATUS CreateMiniportDmSynth
#ifdef USE_OBSOLETE_FUNCS
(
    OUT PUNKNOWN *  Unknown,
    IN  PUNKNOWN    UnknownOuter OPTIONAL,
    IN  POOL_TYPE   PoolType
)
#else
(
    OUT PUNKNOWN *  Unknown,
    IN  PUNKNOWN    UnknownOuter OPTIONAL,
    IN  POOL_TYPE   PoolType,
    IN  PDEVICE_OBJECT pDeviceObject
)
#endif
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CreateMiniportDmSynth"));
    ASSERT(Unknown);

#ifdef USE_OBSOLETE_FUNCS
    STD_CREATE_BODY_WITH_TAG(CMiniportDmSynth, Unknown, UnknownOuter, PoolType,'pMmD'); //  DmMp
#else
    NTSTATUS ntStatus;
    CMiniportDmSynth *p = new(PoolType, 'pMmD') CMiniportDmSynth(UnknownOuter);
    if(p != NULL)
    {
        // the following line is the only difference between this code and
        // STD_CREATE_BODY_WITH_TAG and is necessary to handle passing the
        // DeviceObject pointer down without changing PortCls.
        p->m_pDeviceObject = pDeviceObject;

        *Unknown = reinterpret_cast<PUNKNOWN>(p);
        (*Unknown)->AddRef();
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    return ntStatus;
#endif
}

/*****************************************************************************
 * CMiniportDmSynth::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This method works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CMiniportDmSynth::NonDelegatingQueryInterface(IN  REFIID  Interface,
                                              OUT PVOID * Object)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDmSynth::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportDMus))
    {
        *Object = PVOID(PMINIPORTDMUS(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CMiniportDmSynth::~CMiniportDmSynth()
 *****************************************************************************
 * Destructor for miniport object.  Let go of the port reference.
 */
CMiniportDmSynth::~CMiniportDmSynth()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDmSynth::~CMiniportDmSynth"));

    if (m_pPort)
    {
        m_pPort->Release();
        m_pPort = NULL;
    }

    DeleteCriticalSection(&m_CriticalSection);
}

/*****************************************************************************
 * CMiniportDmSynth::GetDescription()
 *****************************************************************************
 * Gets the topology for this miniport.
 */
STDMETHODIMP
CMiniportDmSynth::GetDescription(OUT PPCFILTER_DESCRIPTOR * OutFilterDescriptor)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDmSynth::GetDescription"));

    *OutFilterDescriptor = PPCFILTER_DESCRIPTOR(&MiniportFilterDescriptor);
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportDmSynth::DataRangeIntersection()
 *****************************************************************************
 * No data range for this miniport.
 */
STDMETHODIMP
CMiniportDmSynth::DataRangeIntersection(IN  ULONG        PinId,
                                        IN  PKSDATARANGE DataRange,
                                        IN  PKSDATARANGE MatchingDataRange,
                                        IN  ULONG        OutputBufferLength,
                                        OUT PVOID        ResultantFormat OPTIONAL,
                                        OUT PULONG       ResultantFormatLength)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDmSynth::DataRangeIntersection"));

    return STATUS_NOT_IMPLEMENTED;
}

/*****************************************************************************
 * CMiniportDmSynth::Init()
 *****************************************************************************
 * Initializes the miniport.
 */
STDMETHODIMP
CMiniportDmSynth::Init
(
    IN  PUNKNOWN            Unknown OPTIONAL,
    IN  PRESOURCELIST       ResourceList,
    IN  PPORTDMUS           Port,
    OUT PSERVICEGROUP*      ServiceGroup
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDmSynth::Init"));
    ASSERT(ResourceList);
    ASSERT(Port);
    ASSERT(ServiceGroup);

    m_pPort = Port;
    m_pPort->AddRef();

    *ServiceGroup = NULL;

    InitializeCriticalSection(&m_CriticalSection);

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportDmSynth::Service()
 *****************************************************************************
 * Not used.
 */
STDMETHODIMP_(void)
CMiniportDmSynth::Service()
{
}

/*****************************************************************************
 * CMiniportDmSynth::NewStream()
 *****************************************************************************
 * Create a new stream.  SchedulePreFetch tells the sequencer how far in
 * advance to deliver events.  Allocator and master clock are required.
 */
STDMETHODIMP
CMiniportDmSynth::NewStream
(
    OUT     PMXF                  * MXF,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      POOL_TYPE               PoolType,
    IN      ULONG                   PinID,
    IN      DMUS_STREAM_TYPE        StreamType,
    IN      PKSDATAFORMAT           DataFormat,
    OUT     PSERVICEGROUP         * ServiceGroup,
    IN      PAllocatorMXF           AllocatorMXF,
    IN      PMASTERCLOCK            MasterClock,
    OUT     PULONGLONG              SchedulePreFetch
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDmSynth::NewStream"));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    *MXF = NULL;
    *ServiceGroup = NULL;
    *SchedulePreFetch = DONT_HOLD_FOR_SEQUENCING;

    if ((StreamType != DMUS_STREAM_WAVE_SINK) && (StreamType != DMUS_STREAM_MIDI_RENDER) )
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportDmSynth::NewStream stream type not supported"));
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    else
    {
        EnterCriticalSection(&m_CriticalSection);

        for (CDmSynthStream* pStreamItem = (CDmSynthStream*)m_StreamList.GetHead();
            pStreamItem;
            pStreamItem = (CDmSynthStream*)pStreamItem->GetNext())
        {
            if ( (StreamType == DMUS_STREAM_WAVE_SINK && !pStreamItem->m_fWaveOutCreated)
              || (StreamType == DMUS_STREAM_MIDI_RENDER && !pStreamItem->m_fMidiInCreated) )
            {
                if (StreamType == DMUS_STREAM_MIDI_RENDER)
                {
                    ntStatus = pStreamItem->InitMidiIn(AllocatorMXF, MasterClock);
                }
                else    // DMUS_STREAM_WAVE_SINK
                {
                    ntStatus = pStreamItem->InitWaveOut(DataFormat);
                }

                if (NT_SUCCESS(ntStatus))
                {
                    pStreamItem->AddRef();
                    *MXF = PMXF(pStreamItem);
                }
                break;
            }
        }

        if (!*MXF)
        {
            CDmSynthStream* pNewStream = new(PoolType,'sSmD') CDmSynthStream(OuterUnknown); //  DmSs

            if (pNewStream)
            {
#ifdef USE_OBSOLETE_FUNCS
                ntStatus = pNewStream->Init(this);
#else
                ntStatus = pNewStream->Init(this, m_pDeviceObject);
#endif

                if (NT_SUCCESS(ntStatus))
                {
                    if (StreamType == DMUS_STREAM_MIDI_RENDER)
                    {
                        ntStatus = pNewStream->InitMidiIn(AllocatorMXF, MasterClock);
                    }
                    else    // DMUS_STREAM_WAVE_SINK
                    {
                        ntStatus = pNewStream->InitWaveOut(DataFormat);
                    }
                }

                if (NT_SUCCESS(ntStatus))
                {
                    m_StreamList.AddTail(pNewStream);
                    pNewStream->AddRef();
                    *MXF = PMXF(pNewStream);
                }
                else
                {
                    pNewStream->Release();
                    pNewStream = NULL;
                }
            }
            else
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        LeaveCriticalSection(&m_CriticalSection);
    }

    return ntStatus;
}


/*****************************************************************************
 *****************************************************************************
 * CDmSynthStream implementation
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * CDmSynthStream::~CDmSynthStream()
 *****************************************************************************
 * Destructor for miniport stream (MXF).  Remove the download objects, clock,
 * allocator, miniport, synth, etc.
 *
 * All instruments and waves downloaded to
 * the synth are released (though a well behaved
 * client should have unloaded them prior to now).
 */
CDmSynthStream::~CDmSynthStream()
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::~CDmSynthStream"));

    if (m_pMasterClock)
    {
        m_pMasterClock->Release();
        m_pMasterClock = NULL;
    }

    if (m_pAllocator)
    {
        m_pAllocator->Release();
        m_pAllocator = NULL;
    }
#ifndef USE_OBSOLETE_FUNCS
    if(m_pEventListWorkItem != NULL)
    {
        IoFreeWorkItem(m_pEventListWorkItem);
    }
#endif

    if (m_pMiniport)
    {
        EnterCriticalSection(&m_pMiniport->m_CriticalSection);

        for (CDmSynthStream* pStreamItem = (CDmSynthStream*)m_pMiniport->m_StreamList.GetHead();
             pStreamItem;
             pStreamItem = (CDmSynthStream*)pStreamItem->GetNext())
        {
            if (pStreamItem == this)
            {
                m_pMiniport->m_StreamList.Remove(pStreamItem);
                break;
            }
        }
        LeaveCriticalSection(&m_pMiniport->m_CriticalSection);

        m_pMiniport->Release();
    }

    if (m_pSynth)
    {
        delete m_pSynth;
    }
}

/*****************************************************************************
 * CDmSynthStream::Init()
 *****************************************************************************
 * Initialize the miniport stream (MXF).  Create a synth.
 */
NTSTATUS
CDmSynthStream::Init
#ifdef USE_OBSOLETE_FUNCS
(
    CMiniportDmSynth *  Miniport
)
#else
(
    CMiniportDmSynth *  Miniport,
    PDEVICE_OBJECT pDeviceObject
)
#endif
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::Init"));

    if (!Miniport)
    {
        return STATUS_INVALID_PARAMETER;
    }

    m_pSynth = new(NonPagedPool,'SSmD') CSynth; //  DmSS
    if (m_pSynth == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize Synth with default settings.
    //
    if (FAILED(m_pSynth->Open(DEFAULT_CHANNEL_GROUPS, DEFAULT_VOICES)))
    {
        delete m_pSynth;
        m_pSynth = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    m_PortParams.ChannelGroups  = DEFAULT_CHANNEL_GROUPS;
    m_PortParams.Voices         = DEFAULT_VOICES;
    m_PortParams.EffectsFlags   = 0;

    m_pMiniport = Miniport;
    m_pMiniport->AddRef();

    m_fWaveOutCreated = FALSE;
    m_fMidiInCreated = FALSE;

    m_State = KSSTATE_STOP;

    m_EventList = NULL;
    KeInitializeSpinLock(&m_EventListLock);

#ifdef USE_OBSOLETE_FUNCS
    ExInitializeWorkItem(&m_EventListWorkItem,
                         (PWORKER_THREAD_ROUTINE)PutMessageWorker,
                         (PVOID)this);
#else
    m_pEventListWorkItem = IoAllocateWorkItem(pDeviceObject);
    if(m_pEventListWorkItem == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
#endif

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CDmSynthStream::InitMidiIn()
 *****************************************************************************
 * Initialize the MIDI input side.  Allocator and master clock are required.
 */
NTSTATUS
CDmSynthStream::InitMidiIn
(
    IN      PAllocatorMXF   AllocatorMXF,
    IN      PMASTERCLOCK    MasterClock
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::Init"));

    if (!AllocatorMXF || !MasterClock)
    {
        return STATUS_INVALID_PARAMETER;
    }

    m_pAllocator = AllocatorMXF;
    m_pAllocator->AddRef();

    // NOTE: master clock is set on midi pin, not wave pin
    m_pMasterClock = MasterClock;
    m_pMasterClock->AddRef();

    m_fMidiInCreated = TRUE;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CDmSynthStream::InitWaveOut()
 *****************************************************************************
 * Initialize the wave output side.
 */
NTSTATUS
CDmSynthStream::InitWaveOut
(
    IN      PKSDATAFORMAT       DataFormat
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::Init"));

    if (!DataFormat)
    {
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory(&m_PortParams, sizeof(m_PortParams));
    m_PortParams.SampleRate = PKSDATAFORMAT_WAVEFORMATEX(DataFormat)->WaveFormatEx.nSamplesPerSec;
    m_PortParams.AudioChannels = PKSDATAFORMAT_WAVEFORMATEX(DataFormat)->WaveFormatEx.nChannels;

    m_lVolume = 0;
    m_lBoost = 6 * 100;

    m_fWaveOutCreated = TRUE;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CDmSynthStream::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This method works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP
CDmSynthStream::NonDelegatingQueryInterface
(
    IN  REFIID      Interface,
    OUT PVOID*      Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_ISynthSinkDMus))
    {
        *Object = PVOID(PSYNTHSINKDMUS(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }
    return STATUS_INVALID_PARAMETER;
}

/*****************************************************************************
 * CDmSynthStream::SetState()
 *****************************************************************************
 * Set the state of the stream (RUN/PAUSE/ACQUIRE/STOP) and act accordingly.
 * Activate the synth if we are running.
 */
STDMETHODIMP
CDmSynthStream::SetState
(
    IN      KSSTATE     NewState
)
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::SetState: %d", NewState));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    m_llStartPosition = 0;
    m_llLastPosition = 0;

    switch (NewState)
    {
        case KSSTATE_RUN:
        {
            if (m_PortParams.SampleRate && m_PortParams.AudioChannels)
            {
                if (NT_SUCCESS(ntStatus))
                {
                    HRESULT hr = m_pSynth->Activate(m_PortParams.SampleRate,
                                                    m_PortParams.AudioChannels);
                    if (FAILED(hr))
                    {
                        ntStatus = MapHRESULT(hr);
                    }
                }
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::SetState invalid port params"));
                ntStatus = STATUS_UNSUCCESSFUL;
            }
            break;
        }
        case KSSTATE_ACQUIRE:
        case KSSTATE_STOP:
        case KSSTATE_PAUSE:
        {
            HRESULT hr = m_pSynth->Deactivate();
            if (FAILED(hr))
            {
                ntStatus = MapHRESULT(hr);
            }
            break;
        }
    }
    m_State = NewState;

    return ntStatus;
}

/*****************************************************************************
 * CDmSynthStream::ConnectOutput()
 *****************************************************************************
 * MXF base function.  This MXF does not feed another, so it is not implemented.
 */
STDMETHODIMP
CDmSynthStream::ConnectOutput(PMXF ConnectionPoint)
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::ConnectOutput"));

    return STATUS_SUCCESS;      // do nothing
}


/*****************************************************************************
 * CDmSynthStream::DisconnectOutput()
 *****************************************************************************
 * MXF base function.  This MXF does not feed another, so it is not implemented.
 */
STDMETHODIMP
CDmSynthStream::DisconnectOutput(PMXF ConnectionPoint)
{
    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::DisconnectOutput"));

    return STATUS_SUCCESS;      // do nothing
}


/*****************************************************************************
 * PutMessageWorker()
 *****************************************************************************
 * C function that thunks over to the stream's member function.
 */
#ifdef USE_OBSOLETE_FUNCS
VOID PutMessageWorker(PVOID Param)
#else
VOID PutMessageWorker(PDEVICE_OBJECT pDeviceObject, PVOID Param)
#endif
{
    CDmSynthStream *pCDmSynthStream = (CDmSynthStream *)Param;

    pCDmSynthStream->PutMessageInternal();
}


/*****************************************************************************
 * CDmSynthStream::PutMessageInternal()
 *****************************************************************************
 * Can be called at PASSIVE_LEVEL.  Receive MIDI events and queue them.
 */
void CDmSynthStream::PutMessageInternal(void)
{
    KIRQL oldIrql;
    PDMUS_KERNEL_EVENT  pEvent,pDMKEvt;
    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::PutMessageInternal"));

    // Grab everything on the list
    KeAcquireSpinLock(&m_EventListLock,&oldIrql);
    pEvent=m_EventList;
    m_EventList=NULL;
    KeReleaseSpinLock(&m_EventListLock,oldIrql);

    pDMKEvt=pEvent;
    while (pDMKEvt)
    {
        if (!(PACKAGE_EVT(pDMKEvt)))
        {
            PBYTE pData;
            if (pDMKEvt->cbEvent <= sizeof(PBYTE))
            {
                pData = (PBYTE)&pDMKEvt->uData;
            }
            else
            {
                pData = (PBYTE)pDMKEvt->uData.pbData;
            }

            // This is just MIDI bytes
            HRESULT hr = m_pSynth->PlayBuffer(PSYNTHSINKDMUS(this),
                                              pDMKEvt->ullPresTime100ns,
                                              pData,
                                              pDMKEvt->cbEvent,
                                              (ULONG)pDMKEvt->usChannelGroup);
            if (FAILED(hr))
            {
                ntStatus = MapHRESULT(hr);
            }
        }
        else
        {
            PutMessage(pDMKEvt->uData.pPackageEvt);
            pDMKEvt->uData.pPackageEvt = NULL;
        }
        pDMKEvt = pDMKEvt->pNextEvt;
    }
    m_pAllocator->PutMessage(pEvent);
}

/*****************************************************************************
 * CDmSynthStream::PutMessage()
 *****************************************************************************
 * Must be called at DISPATH_LEVEL (e.g. from a DPC).  We jam an event into
 * a queue and call a work item.  If the queue already exists, we just append
 * (no need to call the work item).
 */
STDMETHODIMP
CDmSynthStream::PutMessage(IN PDMUS_KERNEL_EVENT pEvent)
{
    BOOL bQueueWorkItem;

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::::PutMessage"));

    // Queue up on event list
    KeAcquireSpinLockAtDpcLevel(&m_EventListLock);

    if (!m_EventList)           // If nothing on event list
    {
        m_EventList = pEvent;   // Link to head
        bQueueWorkItem = TRUE;  // Need to queue work item
    }
    else                        // Something already pending, queue up behind them
    {
        // Find last event in queue to link to
        PDMUS_KERNEL_EVENT  pEventTail = m_EventList;
        while (pEventTail->pNextEvt)
        {
            pEventTail = pEventTail->pNextEvt;
        }
        pEventTail->pNextEvt = pEvent;
        bQueueWorkItem = FALSE; // No need to queue new work item
    }
    KeReleaseSpinLockFromDpcLevel(&m_EventListLock);

    // Queue up the work item after we release spinlock
    if (bQueueWorkItem)
    {
#ifdef USE_OBSOLETE_FUNCS
        ExQueueWorkItem(&m_EventListWorkItem, CriticalWorkQueue);
#else
        IoQueueWorkItem(m_pEventListWorkItem, PutMessageWorker,
                        CriticalWorkQueue, (PVOID)this);
#endif
    }
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CDmSynthStream::HandlePropertySupport()
 *****************************************************************************
 * Handle the support property.
 */
NTSTATUS
CDmSynthStream::HandlePropertySupport(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::HandlePropertySupport"));

    NTSTATUS ntStatus;

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        ntStatus = DefaultBasicPropertyHandler(pRequest,
            KSPROPERTY_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_GET);
    }
    else
    {
        ntStatus = ValidatePropertyParams(pRequest, sizeof(ULONG), KSPROPERTY_TYPE_SET);
        if (NT_SUCCESS(ntStatus))
        {
            if (IsEqualGUIDAligned(*pRequest->PropertyItem->Set, GUID_DMUS_PROP_GM_Hardware))
            {
                _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySupport GUID_DMUS_PROP_GM_Hardware"));

                *(PULONG)(pRequest->Value) = FALSE;
            }
            else if (IsEqualGUIDAligned(*pRequest->PropertyItem->Set, GUID_DMUS_PROP_GS_Hardware))
            {
                _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySupport GUID_DMUS_PROP_GS_Hardware"));

                *(PULONG)(pRequest->Value) = FALSE;
            }
            else if (IsEqualGUIDAligned(*pRequest->PropertyItem->Set, GUID_DMUS_PROP_XG_Hardware))
            {
                _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySupport GUID_DMUS_PROP_XG_Hardware"));

                *(PULONG)(pRequest->Value) = FALSE;
            }
            else if (IsEqualGUIDAligned(*pRequest->PropertyItem->Set, GUID_DMUS_PROP_XG_Capable))
            {
                _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySupport GUID_DMUS_PROP_XG_Capable"));

                *(PULONG)(pRequest->Value) = TRUE;
            }
            else if (IsEqualGUIDAligned(*pRequest->PropertyItem->Set, GUID_DMUS_PROP_GS_Capable))
            {
                _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySupport GUID_DMUS_PROP_GS_Capable"));

                *(PULONG)(pRequest->Value) = TRUE;
            }
            else if (IsEqualGUIDAligned(*pRequest->PropertyItem->Set, GUID_DMUS_PROP_DLS1))
            {
                _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySupport GUID_DMUS_PROP_DLS1"));

                *(PULONG)(pRequest->Value) = TRUE;
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE,("CDmSynthStream::HandlePropertySupport unrecognized set ID"));

                ntStatus = STATUS_UNSUCCESSFUL;
                pRequest->ValueSize = 0;
            }
        }

        if (NT_SUCCESS(ntStatus))
        {
            pRequest->ValueSize = sizeof(ULONG);
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CDmSynthStream::HandlePropertyEffects()
 *****************************************************************************
 * Handle the effects property.
 */
NTSTATUS
CDmSynthStream::HandlePropertyEffects(IN  PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::HandlePropertyEffects"));

    NTSTATUS ntStatus;

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        ntStatus = DefaultBasicPropertyHandler(pRequest,
            KSPROPERTY_TYPE_BASICSUPPORT |
            KSPROPERTY_TYPE_GET);
    }
    else
    {
        ntStatus = ValidatePropertyParams(pRequest, sizeof(ULONG), 0);
        if (NT_SUCCESS(ntStatus))
        {
            if (pRequest->Verb & KSPROPERTY_TYPE_GET)
            {
                PULONG pulEffects = (PULONG)pRequest->Value;

                pRequest->ValueSize = sizeof(ULONG);
                *pulEffects = 0;

                _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream: Get effects flags %x", *pulEffects));
            }
            else
            {
                pRequest->ValueSize = 0;
                ntStatus = STATUS_INVALID_PARAMETER;
            }
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * CDmSynthStream::HandlePortParams()
 *****************************************************************************
 * Handle the port parameters property.
 * Fix up the port params to include defaults. Cache the params as well
 * as passing the updated version back.
 */
NTSTATUS
CDmSynthStream::HandlePortParams(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    NTSTATUS ntStatus;

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::HandlePortParams"));

    ntStatus = ValidatePropertyParams(pRequest, sizeof(SYNTH_PORTPARAMS), KSPROPERTY_TYPE_SET);
    if (!NT_SUCCESS(ntStatus))
    {
        return ntStatus;
    }

    if (pRequest->InstanceSize < sizeof(SYNTH_PORTPARAMS))
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandlePortParams InstanceSize too small"));
        pRequest->ValueSize = 0;
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory(pRequest->Value, pRequest->Instance, sizeof(SYNTH_PORTPARAMS));

    PSYNTH_PORTPARAMS Params = (PSYNTH_PORTPARAMS)pRequest->Value;

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_VOICES))
    {
        Params->Voices = DEFAULT_VOICES;
    }
    else if (Params->Voices > MAX_VOICES)
    {
        Params->Voices = MAX_VOICES;
    }
    else if (Params->Voices < 1)
    {
        Params->Voices = 1;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_CHANNELGROUPS))
    {
        Params->ChannelGroups = DEFAULT_CHANNEL_GROUPS;
    }
    else if (Params->ChannelGroups > MAX_CHANNEL_GROUPS)
    {
        Params->ChannelGroups = MAX_CHANNEL_GROUPS;
    }
    else if (Params->ChannelGroups < 1)
    {
        Params->ChannelGroups = 1;
    }

    // audio channels is fixed (chosen) by SysAudio
    if (!(Params->ValidParams & SYNTH_PORTPARAMS_AUDIOCHANNELS))
    {
        Params->AudioChannels = m_PortParams.AudioChannels;
    }
    else if (Params->AudioChannels != m_PortParams.AudioChannels)
    {
        Params->AudioChannels = m_PortParams.AudioChannels;
    }

    // sample rate is fixed (chosen) by SysAudio
    if (!(Params->ValidParams & SYNTH_PORTPARAMS_SAMPLERATE))
    {
        Params->SampleRate = m_PortParams.SampleRate;
    }
    else if (Params->SampleRate != m_PortParams.SampleRate)
    {
        Params->SampleRate = m_PortParams.SampleRate;
    }

    // set share. This cannot change.
    Params->Share = m_PortParams.Share;

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_EFFECTS))
    {
        Params->EffectsFlags = SYNTH_EFFECT_NONE;
    }
    else
    {
        Params->EffectsFlags = SYNTH_EFFECT_NONE;
    }

    RtlCopyMemory(&m_PortParams, Params, sizeof(m_PortParams));

    // Each channel groups is represented by a ControlLogic object
    // (A channel groups is a set of sixteen MIDI channels)
    HRESULT hr = m_pSynth->Open(m_PortParams.ChannelGroups,
                                m_PortParams.Voices
                                );
    if (SUCCEEDED(hr))
    {
        m_pSynth->SetGainAdjust(m_lVolume + m_lBoost);
    }
    else
    {
        ntStatus = MapHRESULT(hr);
    }

    if (NT_SUCCESS(ntStatus))
    {
        pRequest->ValueSize = sizeof(SYNTH_PORTPARAMS);
    }
    else
    {
        pRequest->ValueSize = 0;
    }

    return ntStatus;
}

/*****************************************************************************
 * CDmSynthStream::HandleRunningStats()
 *****************************************************************************
 * Handle the property for running statistics.
 */
NTSTATUS
CDmSynthStream::HandleRunningStats(IN PPCPROPERTY_REQUEST pRequest)
{
    FLOATSAFE fs;

    PAGED_CODE();

    NTSTATUS ntStatus;
    _DbgPrintF(DEBUGLVL_VERBOSE, ("CDmSynthStream::HandleRunningStats"));

    ntStatus = ValidatePropertyParams(pRequest, sizeof(SYNTH_STATS), KSPROPERTY_TYPE_SET);
    if (!NT_SUCCESS(ntStatus))
    {
        return ntStatus;
    }

    PSYNTH_STATS StatsOut = (PSYNTH_STATS)pRequest->Value;

    PerfStats Stats;
    m_pSynth->GetPerformanceStats(&Stats);

    long lCPU = Stats.dwCPU;

    if (Stats.dwVoices)
    {
        lCPU /= Stats.dwVoices;
    }
    else
    {
        lCPU = 0;
    }

    StatsOut->Voices = Stats.dwVoices;
    StatsOut->CPUPerVoice = lCPU * 10;
    StatsOut->TotalCPU = Stats.dwCPU * 10;
    StatsOut->LostNotes = Stats.dwNotesLost;
    long ldB = 6;

    StatsOut->ValidStats =
        SYNTH_STATS_VOICES |
        SYNTH_STATS_TOTAL_CPU |
        SYNTH_STATS_CPU_PER_VOICE |
        SYNTH_STATS_LOST_NOTES;

    double fLevel = Stats.dwMaxAmplitude;
    if (Stats.dwMaxAmplitude < 1)
    {
        fLevel = -96.0;
    }
    else
    {
        fLevel /= 32768.0;
        fLevel = log10(fLevel);
        fLevel *= 20.0;
    }
    StatsOut->PeakVolume = (long) fLevel;
    StatsOut->ValidStats |= SYNTH_STATS_PEAK_VOLUME;

    pRequest->ValueSize = sizeof(SYNTH_STATS);

    return ntStatus;
}

/*****************************************************************************
 * CDmSynthStream::HandlePropertySynth()
 *****************************************************************************
 * Handle the synth property set.
 */
NTSTATUS
CDmSynthStream::HandlePropertySynth(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::HandlePropertySynth"));

    NTSTATUS ntStatus = STATUS_INVALID_PARAMETER;
    HRESULT hr;

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        ntStatus = DefaultSynthBasicPropertyHandler(pRequest);
    }
    else
    {
        switch (pRequest->PropertyItem->Id)
        {
        case KSPROPERTY_SYNTH_PORTPARAMETERS:
            _DbgPrintF(DEBUGLVL_VERBOSE,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_PORTPARAMETERS"));
            ntStatus = HandlePortParams(pRequest);
            break;
        case KSPROPERTY_SYNTH_RUNNINGSTATS:
            _DbgPrintF(DEBUGLVL_VERBOSE,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_RUNNINGSTATS"));
            ntStatus = HandleRunningStats(pRequest);
            break;
        case KSPROPERTY_SYNTH_VOLUME:
            _DbgPrintF(DEBUGLVL_VERBOSE,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_VOLUME"));

            ntStatus = ValidatePropertyParams(pRequest, sizeof(m_lVolume), 0);
            if (NT_SUCCESS(ntStatus))
            {
                if (pRequest->Verb & KSPROPERTY_TYPE_GET)
                {
                    pRequest->ValueSize = sizeof(m_lVolume);
                    *(PLONG)pRequest->Value = m_lVolume;
                }
                else
                {
                    m_lVolume = *(PLONG)pRequest->Value;
                    m_pSynth->SetGainAdjust(m_lVolume + m_lBoost);
                }
            }
            break;
        case KSPROPERTY_SYNTH_VOLUMEBOOST:
            _DbgPrintF(DEBUGLVL_VERBOSE,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_VOLUMEBOOST"));

            ntStatus = ValidatePropertyParams(pRequest, sizeof(m_lBoost), 0);
            if (NT_SUCCESS(ntStatus))
            {
                if (pRequest->Verb & KSPROPERTY_TYPE_GET)
                {
                    pRequest->ValueSize = sizeof(m_lBoost);
                    *(PLONG)pRequest->Value = m_lBoost;
                }
                else
                {
                    m_lBoost = *(PLONG)pRequest->Value;
                    m_pSynth->SetGainAdjust(m_lVolume + m_lBoost);
                }
            }
            break;
        case KSPROPERTY_SYNTH_CHANNELGROUPS:
            _DbgPrintF(DEBUGLVL_VERBOSE,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_CHANNELGROUPS"));

            ntStatus = ValidatePropertyParams(pRequest, sizeof(m_PortParams.ChannelGroups), 0);
            if (NT_SUCCESS(ntStatus))
            {
                if (pRequest->Verb & KSPROPERTY_TYPE_GET)
                {
                    pRequest->ValueSize = sizeof(m_PortParams.ChannelGroups);
                    *(PULONG)pRequest->Value = m_PortParams.ChannelGroups;
                }
                else
                {
                    hr = m_pSynth->SetNumChannelGroups(*(PULONG)pRequest->Value);

                    if (FAILED(hr))
                    {
                        ntStatus = MapHRESULT(hr);
                    }
                    else
                    {
                        m_PortParams.ChannelGroups = *(PULONG)pRequest->Value;
                    }
                }
            }
            break;
        case KSPROPERTY_SYNTH_VOICEPRIORITY:
            _DbgPrintF(DEBUGLVL_VERBOSE,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_VOICEPRIORITY"));

            ntStatus = ValidatePropertyParams(pRequest, sizeof(DWORD), 0);
            if (NT_SUCCESS(ntStatus))
            {
                if (pRequest->InstanceSize < sizeof(SYNTHVOICEPRIORITY_INSTANCE))
                {
                    ntStatus = STATUS_BUFFER_TOO_SMALL;
                    pRequest->ValueSize = 0;
                }
            }

            if (NT_SUCCESS(ntStatus))
            {
                if (pRequest->Verb & KSPROPERTY_TYPE_GET)
                {
                    PSYNTHVOICEPRIORITY_INSTANCE pVoicePriority = (PSYNTHVOICEPRIORITY_INSTANCE)pRequest->Instance;

                    hr = m_pSynth->GetChannelPriority(pVoicePriority->ChannelGroup,
                                                      pVoicePriority->Channel,
                                                      (PULONG)pRequest->Value);
                    if (FAILED(hr))
                    {
                        pRequest->ValueSize = 0;
                        ntStatus = MapHRESULT(hr);
                    }
                    else
                    {
                        pRequest->ValueSize = sizeof(DWORD);
                    }
                }
                else
                {
                    PSYNTHVOICEPRIORITY_INSTANCE pVoicePriority = (PSYNTHVOICEPRIORITY_INSTANCE)pRequest->Instance;

                    hr = m_pSynth->SetChannelPriority(pVoicePriority->ChannelGroup,
                                                      pVoicePriority->Channel,
                                                      *(PULONG)pRequest->Value);
                    if (FAILED(hr))
                    {
                        ntStatus = MapHRESULT(hr);
                    }
                }
            }
            break;
        case KSPROPERTY_SYNTH_LATENCYCLOCK:
            // This returns the latency clock created by the output audio sink object,
            // which handles the output audio stream.
            // The latency clock returns the current render time whenever its
            // IReferenceClock::GetTime method is called. This time is always relative
            // to the time established by the master clock.
            // The latency time is used by clients to identify the next available time
            // to start playing a note.
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySynth KSPROPERTY_SYNTH_LATENCYCLOCK"));

            ntStatus = ValidatePropertyParams(pRequest, sizeof(ULONGLONG), KSPROPERTY_TYPE_SET);
            if (NT_SUCCESS(ntStatus))
            {
                REFERENCE_TIME rtLatency;
                if (NT_SUCCESS(SampleToRefTime(m_llLastPosition, &rtLatency)))
                {
                    if (m_pMasterClock)
                    {
                        REFERENCE_TIME rtMaster;
                        if (NT_SUCCESS(m_pMasterClock->GetTime(&rtMaster)))
                        {
#if DBG
                            static DWORD g_dwIn = 0;
#endif // DBG
                            if (rtLatency < rtMaster)
                            {
#if DBG
                                if (g_dwIn++ % 25 == 0)
                                {
                                    _DbgPrintF(DEBUGLVL_VERBOSE,("Latency:%ld < Master:%ld",
                                                                 long(rtLatency / 10000),
                                                                 long(rtMaster / 10000)));
                                }
#endif // DBG
                                // REVIEW: rtLatency = rtMaster; // clamp it up
                            }
                            else if (rtLatency > rtMaster + 10000000)
                            {
#if DBG
                                if (g_dwIn++ % 25 == 0)
                                {
                                    _DbgPrintF(DEBUGLVL_VERBOSE,("Latency:%ld > Master:%ld",
                                                                 long(rtLatency / 10000),
                                                                 long(rtMaster / 10000)));
                                }
#endif // DBG
                                // REVIEW: rtLatency = rtMaster + 10000000; // clamp it down
                            }
                        }
                    }
                    *((PULONGLONG)pRequest->Value) = rtLatency;
                    pRequest->ValueSize = sizeof(ULONGLONG);
                }
                else
                {
                    ntStatus = STATUS_UNSUCCESSFUL;
                }
            }
            break;
        default:
            _DbgPrintF(DEBUGLVL_TERSE,("CDmSynthStream::HandlePropertySynth unrecognized ID"));
            ntStatus = STATUS_UNSUCCESSFUL;
            break;
        }
    }

    // We should return zero, if we fail.
    //
    if (STATUS_UNSUCCESSFUL == ntStatus || STATUS_INVALID_PARAMETER == ntStatus )
    {
        pRequest->ValueSize = 0;
    }

    return ntStatus;
}


/*****************************************************************************
 * CDmSynthStream::HandleDownload()
 *****************************************************************************
 * Handle a download request.  We carefully copy the data.
 * Forward to the synth and add to our list.
 */
NTSTATUS
CDmSynthStream::HandleDownload(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    NTSTATUS ntStatus;
    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::HandleDownload"));

    ntStatus = ValidatePropertyParams(pRequest, sizeof(SYNTHDOWNLOAD), 0);
    if (!NT_SUCCESS(ntStatus))
    {
        // We should return immediately. ValidatePropertyParams sets all
        // error codes appropriately.
        return ntStatus;
    }

    if (pRequest->InstanceSize < sizeof(SYNTH_BUFFER))
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload InstanceSize too small"));
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }
    if (pRequest->Instance == NULL)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload Instance is NULL"));
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }
    if (pRequest->InstanceSize != sizeof(SYNTH_BUFFER) ||
        pRequest->ValueSize != sizeof(SYNTHDOWNLOAD))
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload InstanceSize:%lu, ValueSize:%lu", pRequest->InstanceSize, pRequest->ValueSize));
    }

    PSYNTH_BUFFER pDlsBuffer;

    if (NT_SUCCESS(ntStatus))
    {
        pDlsBuffer = (PSYNTH_BUFFER)pRequest->Instance;

        if (!pDlsBuffer->BufferSize)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload BufferSize is invalid"));
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }

    // lock and copy user data into paged pool
    BOOL pagesLocked = FALSE;
    PVOID pvData = NULL;
    if (NT_SUCCESS(ntStatus))
    {
        PMDL pMdl = IoAllocateMdl(pDlsBuffer->BufferAddress, pDlsBuffer->BufferSize, FALSE, FALSE, NULL);
        if (pMdl)
        {
            __try
            {
                MmProbeAndLockPages(pMdl, KernelMode, IoReadAccess);
                pagesLocked = TRUE;

                PVOID pvUserData = KernHelpGetSysAddrForMdl(pMdl);

                pvData = (PVOID)new BYTE[pDlsBuffer->BufferSize];
                if (pvData && pvUserData)
                {
                    RtlCopyMemory(pvData, pvUserData, pDlsBuffer->BufferSize);
                    ntStatus = STATUS_SUCCESS;
                }
                else
                {
                    _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload download allocate failed"));
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload lock or copy failed"));
                ntStatus = GetExceptionCode();
            }

            // cleanup
            if (pagesLocked)
            {
                MmUnlockPages(pMdl);
            }
            IoFreeMdl(pMdl);
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("CDmSynthStream::HandleDownload IoAllocateMdl failed"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        // download to synth
        SYNTHDOWNLOAD SynthDownload;
        if (SUCCEEDED(ntStatus))
        {
            HRESULT hr = m_pSynth->Download(&SynthDownload.DownloadHandle,
                                            pvData,
                                            &SynthDownload.Free);
            if (SUCCEEDED(hr))
            {
                if (!SynthDownload.Free)
                {
                    pvData = NULL; // prevent from being freed
                }

                if (SUCCEEDED(ntStatus))
                {
                    SynthDownload.Free = TRUE; // client can always free user data

                    ASSERT(pRequest->ValueSize >= sizeof(SynthDownload));
                    RtlCopyMemory(pRequest->Value, &SynthDownload, sizeof(SynthDownload));
                    pRequest->ValueSize = sizeof(SynthDownload);
                }
            }
            else
            {
                ntStatus = MapHRESULT(hr);
            }
        }
    }

    if (pvData)
    {
        delete [] pvData;
        pvData = NULL;
    }

    if (!NT_SUCCESS(ntStatus))
    {
        pRequest->ValueSize = 0;
    }

    return ntStatus;
}

/*****************************************************************************
 * CDmSynthStream::HandleUnload()
 *****************************************************************************
 * Handle an unload request.  Forward to the synth and remove from our list.
 */
NTSTATUS
CDmSynthStream::HandleUnload(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::HandleUnload"));

    NTSTATUS ntStatus;

    ntStatus = ValidatePropertyParams(pRequest, sizeof(HANDLE), 0);
    if (NT_SUCCESS(ntStatus))
    {
        HRESULT hr = m_pSynth->Unload(*(HANDLE*)pRequest->Value,NULL,NULL);

        if (FAILED(hr))
        {
            pRequest->ValueSize = 0;
            ntStatus = MapHRESULT(hr);
        }
    }

    return ntStatus;
}


/*****************************************************************************
 * CDmSynthStream::HandlePropertySynthDls()
 *****************************************************************************
 * Handles a property in the SynthDls set.
 */
NTSTATUS
CDmSynthStream::HandlePropertySynthDls(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::HandlePropertySynthDls"));

    NTSTATUS ntStatus;

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        ntStatus = DefaultSynthBasicPropertyHandler(pRequest);
    }
    else
    {
        switch (pRequest->PropertyItem->Id)
        {
        case KSPROPERTY_SYNTH_DLS_DOWNLOAD:
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySynthDls KSPROPERTY_SYNTH_DLS_DOWNLOAD"));
            ntStatus = HandleDownload(pRequest);
            break;
        case KSPROPERTY_SYNTH_DLS_UNLOAD:
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySynthDls KSPROPERTY_SYNTH_DLS_UNLOAD"));
            ntStatus = HandleUnload(pRequest);
            break;
        case KSPROPERTY_SYNTH_DLS_APPEND:
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySynthDls KSPROPERTY_SYNTH_DLS_APPEND"));
            ntStatus = ValidatePropertyParams(pRequest, sizeof(ULONG), KSPROPERTY_TYPE_SET);
            if (NT_SUCCESS(ntStatus))
            {
                *(PULONG)(pRequest->Value) = 1;
                pRequest->ValueSize = sizeof(ULONG);
            }
            break;
        case KSPROPERTY_SYNTH_DLS_WAVEFORMAT:
            _DbgPrintF(DEBUGLVL_BLAB,("CDmSynthStream::HandlePropertySynthDls KSPROPERTY_SYNTH_DLS_WAVEFORMAT"));
            ntStatus = ValidatePropertyParams(pRequest, sizeof(WAVEFORMATEX), KSPROPERTY_TYPE_SET);
            if (NT_SUCCESS(ntStatus))
            {
                WAVEFORMATEX *pwfex;
                pwfex = (WAVEFORMATEX *)pRequest->Value;

                RtlZeroMemory(pwfex, sizeof(WAVEFORMATEX));
                pwfex->wFormatTag = WAVE_FORMAT_PCM;
                pwfex->nChannels = 2;
                pwfex->nSamplesPerSec = 22050L;
                pwfex->nAvgBytesPerSec = 22050L * 2 * 2;
                pwfex->nBlockAlign = 4;
                pwfex->wBitsPerSample = 16;
                pwfex->cbSize = 0;

                pRequest->ValueSize = sizeof(WAVEFORMATEX);
            }

            break;
        default:
            _DbgPrintF(DEBUGLVL_TERSE,("CDmSynthStream::HandlePropertySynthDls unrecognized ID"));
            pRequest->ValueSize = 0;
            ntStatus = STATUS_UNSUCCESSFUL;
            break;
        }
    }

    return ntStatus;
}

/*****************************************************************************
 * PropertyHandler_Support()
 *****************************************************************************
 * Redirect to the correct CDMSynthStream member.
 */
NTSTATUS
PropertyHandler_Support(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("PropertyHandler_Support"));

    ASSERT(pRequest);
    if (!(pRequest->MinorTarget))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->HandlePropertySupport(pRequest);
}

/*****************************************************************************
 * PropertyHandler_Effects()
 *****************************************************************************
 * Redirect to the correct CDMSynthStream member.
 */
NTSTATUS
PropertyHandler_Effects(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("PropertyHandler_Effects"));

    ASSERT(pRequest);
    if (!(pRequest->MinorTarget))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->HandlePropertyEffects(pRequest);
}


/*****************************************************************************
 * PropertyHandler_Synth()
 *****************************************************************************
 * Redirect to the correct CDMSynthStream member.
 */
NTSTATUS
PropertyHandler_Synth(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("PropertyHandler_Synth"));

    ASSERT(pRequest);
    if (!(pRequest->MinorTarget))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->HandlePropertySynth(pRequest);
}

const WCHAR wszDescription[] = L"Microsoft DDK Kernel DLS Synthesizer";

/*****************************************************************************
 * PropertyHandler_SynthCaps()
 *****************************************************************************
 * Redirect to the correct CDMSynthStream member.
 */
NTSTATUS
PropertyHandler_SynthCaps(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("PropertyHandler_SynthCaps"));

    ASSERT(pRequest);

    NTSTATUS ntStatus;

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        ntStatus = DefaultBasicPropertyHandler(
            pRequest, KSPROPERTY_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_GET);
    }
    else
    {
        ntStatus = ValidatePropertyParams(pRequest, sizeof(SYNTHCAPS), KSPROPERTY_TYPE_SET);
        if (NT_SUCCESS(ntStatus))
        {
            SYNTHCAPS Caps;
            RtlZeroMemory(&Caps, sizeof(Caps));

            Caps.Guid               = CLSID_DDKWDMSynth;
            Caps.Flags              = SYNTH_PC_DLS | SYNTH_PC_SOFTWARESYNTH;
            Caps.MemorySize         = SYNTH_PC_SYSTEMMEMORY;
            Caps.MaxChannelGroups   = MAX_CHANNEL_GROUPS;
            Caps.MaxVoices          = MAX_VOICES;
            Caps.MaxAudioChannels   = 2;
            RtlCopyMemory(Caps.Description, wszDescription, sizeof(wszDescription));

            RtlCopyMemory(pRequest->Value, &Caps, sizeof(Caps));
            pRequest->ValueSize = sizeof(Caps);
        }
    }

    return ntStatus;
}


/*****************************************************************************
 * PropertyHandler_SynthDls()
 *****************************************************************************
 * Redirect to the correct CDMSynthStream member.
 */
NTSTATUS
PropertyHandler_SynthDls(IN PPCPROPERTY_REQUEST pRequest)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("PropertyHandler_SynthDls"));

    ASSERT(pRequest);
    if (!(pRequest->MinorTarget))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->HandlePropertySynthDls(pRequest);
}

/*****************************************************************************
 * DefaultBasicPropertyHandler()
 *****************************************************************************
 * Finds the given property in SynthProperties and sets Support flags
 * accordingly.
 */
NTSTATUS
DefaultSynthBasicPropertyHandler
(
    IN PPCPROPERTY_REQUEST  pRequest
)
{
    NTSTATUS    ntStatus;
    const WORD  c_wMaxProps = SIZEOF_ARRAY(SynthProperties);
    WORD        wPropIdx;

    ntStatus = ValidatePropertyParams(pRequest, sizeof(ULONG), 0);
    if (NT_SUCCESS(ntStatus))
    {
        for (wPropIdx = 0; wPropIdx < c_wMaxProps; wPropIdx++)
        {
            if ( (SynthProperties[wPropIdx].Set == pRequest->PropertyItem->Set)
              && (SynthProperties[wPropIdx].Id == pRequest->PropertyItem->Id) )
            {
                // if return buffer can hold a ULONG, return the access flags
                PULONG AccessFlags = PULONG(pRequest->Value);

                *AccessFlags = SynthProperties[wPropIdx].Flags;

                // set the return value size
                pRequest->ValueSize = sizeof(ULONG);
                break;
            }
        }

        if (wPropIdx == c_wMaxProps)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("DefaultSynthBasicPropertyHandler property ID not found"));
            pRequest->ValueSize = 0;
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }

    return ntStatus;
} // DefaultSynthBasicPropertyHandler

/*****************************************************************************
 * DefaultBasicPropertyHandler()
 *****************************************************************************
 * Basic support Handler
 */
NTSTATUS DefaultBasicPropertyHandler
(
    IN PPCPROPERTY_REQUEST  pRequest,
    IN DWORD                dwSupportVerb
)
{
    NTSTATUS ntStatus;

    ntStatus = ValidatePropertyParams(pRequest, sizeof(ULONG), 0);
    if (NT_SUCCESS(ntStatus))
    {
        pRequest->ValueSize      = sizeof(ULONG);
        *PULONG(pRequest->Value) = dwSupportVerb;
    }

    return ntStatus;
} // DefaultBasicPropertyHandler

/*****************************************************************************
 * ValidatePropertyParams()
 *****************************************************************************
 * Checks whether the data size appropriate.
 */
NTSTATUS
ValidatePropertyParams
(
    IN PPCPROPERTY_REQUEST  pRequest,
    IN ULONG                cbSize,
    IN DWORD                dwExcludeVerb
)
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    if (pRequest && cbSize)
    {
        // If this is an invalid request.
        //
        if (pRequest->Verb & dwExcludeVerb)
        {
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
        // If the caller is asking for ValueSize.
        //
        else if (0 == pRequest->ValueSize)
        {
            pRequest->ValueSize = cbSize;
            ntStatus = STATUS_BUFFER_OVERFLOW;
        }
        // If the caller passed an invalid ValueSize.
        //
        else if (pRequest->ValueSize < cbSize)
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        // If all parameters are OK.
        //
        else if (pRequest->ValueSize >= cbSize)
        {
            if (pRequest->Value)
            {
                ntStatus = STATUS_SUCCESS;
                //
                // Caller should set ValueSize, if the property
                // call is successful.
                //
            }
        }
    }

    // Clear the ValueSize if unsuccessful.
    //
    if (STATUS_SUCCESS != ntStatus &&
        STATUS_BUFFER_OVERFLOW != ntStatus &&
        pRequest != NULL)
    {
        pRequest->ValueSize = 0;
    }

    return ntStatus;
} // ValidatePropertyParams
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\private.h ===
/*
    Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
*/

#ifndef _PRIVATE
#define _PRIVATE_

#include "clist.h"
#include "plclock.h"


#define STATIC_CLSID_DDKWDMSynth\
    0x820DC38AL, 0x1F81, 0x11d3, 0xA8, 0x2E, 0x00, 0x60, 0x08, 0x33, 0x16, 0xC1
DEFINE_GUIDSTRUCT("820DC38A-1F81-11d3-A82E-0060083316C1", CLSID_DDKWDMSynth);
#define CLSID_DDKWDMSynth DEFINE_GUIDNAMED(CLSID_DDKWDMSynth)

#define STATIC_KSNODETYPE_DMDDKSYNTH\
    0xD2D37597L, 0xA312, 0x434C, 0xA2, 0xDD, 0x2B, 0x4C, 0x32, 0xE6, 0x65, 0x8A
DEFINE_GUIDSTRUCT("D2D37597-A312-434C-A2DD-2B4C32E6658A", KSNODETYPE_DMDDKSYNTH);
#define KSNODETYPE_DMDDKSYNTH DEFINE_GUIDNAMED(KSNODETYPE_DMDDKSYNTH)

#ifdef USE_OBSOLETE_FUNCS
NTSTATUS CreateMiniportDmSynth(OUT PUNKNOWN * Unknown,
                               IN  PUNKNOWN   UnknownOuter OPTIONAL,
                               IN  POOL_TYPE  PoolType);
#else
NTSTATUS CreateMiniportDmSynth(OUT PUNKNOWN * Unknown,
                               IN  PUNKNOWN   UnknownOuter OPTIONAL,
                               IN  POOL_TYPE  PoolType,
                               IN  PDEVICE_OBJECT pDeviceObject);
#endif

class CDmSynthStream;

/*****************************************************************************
 * class CMiniportDmSynth
 *****************************************************************************
 * Each miniport instance corresponds to a port instance of type DMus.
 * This miniport implements the standard IMP_IMiniportDMus.
 */
class CMiniportDmSynth : public IMiniportDMus, public CUnknown
{
    friend class CDmSynthStream;

public:
    IMP_IMiniportDMus;

    // IUnknown
    //
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportDmSynth);
    ~CMiniportDmSynth();

private:
    PPORTDMUS           m_pPort;
    CList               m_StreamList;
    CRITICAL_SECTION    m_CriticalSection;

#ifndef USE_OBSOLETE_FUNCS
    PDEVICE_OBJECT      m_pDeviceObject;
    friend NTSTATUS CreateMiniportDmSynth(OUT PUNKNOWN * Unknown,
                                          IN  PUNKNOWN   UnknownOuter OPTIONAL,
                                          IN  POOL_TYPE  PoolType,
                                          IN  PDEVICE_OBJECT pDeviceObject);
#endif
};

/*****************************************************************************
 * class CDmSynthStream
 *****************************************************************************
 * The stream implements the standard MXF functions.  This stream handles
 * DLS and running statistics on a per-stream basis.
 */
class CDmSynthStream : public ISynthSinkDMus, public CUnknown, public CListItem
{
    friend class CMiniportDmSynth;

public:
    IMP_ISynthSinkDMus;

    // IUnknown
    //
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CDmSynthStream);
    ~CDmSynthStream();

    // Class
    //
#ifdef USE_OBSOLETE_FUNCS
    NTSTATUS Init(CMiniportDmSynth * Miniport);
#else
    NTSTATUS Init(CMiniportDmSynth * Miniport, PDEVICE_OBJECT pDeviceObject);
#endif
    NTSTATUS InitMidiIn(PAllocatorMXF AllocatorMXF, PMASTERCLOCK MasterClock);
    NTSTATUS InitWaveOut(PKSDATAFORMAT DataFormat);

    NTSTATUS HandlePropertySupport(PPCPROPERTY_REQUEST pRequest);
    NTSTATUS HandlePropertyEffects(PPCPROPERTY_REQUEST pRequest);

    NTSTATUS HandlePropertySynth(PPCPROPERTY_REQUEST pRequest);
    NTSTATUS HandlePortParams(PPCPROPERTY_REQUEST pRequest);
    NTSTATUS HandleRunningStats(PPCPROPERTY_REQUEST pRequest);


    NTSTATUS HandlePropertySynthDls(PPCPROPERTY_REQUEST pRequest);
    NTSTATUS HandleDownload(PPCPROPERTY_REQUEST pRequest);
    NTSTATUS HandleUnload(PPCPROPERTY_REQUEST pRequest);
    void     PutMessageInternal(void);

private:
    CMiniportDmSynth *  m_pMiniport;

    BOOL                m_fWaveOutCreated;
    BOOL                m_fMidiInCreated;

    PAllocatorMXF       m_pAllocator;
    PMASTERCLOCK        m_pMasterClock;

    CSynth *            m_pSynth;
    SYNTH_PORTPARAMS    m_PortParams;
    KSSTATE             m_State;

    LONG                m_lVolume;
    LONG                m_lBoost;

    CSampleClock        m_SampleClock;
    LONGLONG            m_llStartPosition;
    LONGLONG            m_llLastPosition;

    PDMUS_KERNEL_EVENT  m_EventList;
    KSPIN_LOCK          m_EventListLock;

#ifdef USE_OBSOLETE_FUNCS
    WORK_QUEUE_ITEM     m_EventListWorkItem;
#else
    PIO_WORKITEM        m_pEventListWorkItem;
#endif
};

typedef CDmSynthStream *PDMSYNTHSTREAM;


#endif // _PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-2000 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routine for 32 bit signed and unsiged numbers.
//
//      MulDiv(a,b,c) = (a * b) / c         (round down, signed)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


//----------------------------------------------------------------------;
//
//  Win 32
//
//----------------------------------------------------------------------;

#ifdef _X86_

    //
    //  Use 32-bit x86 assembly.
    //

    #pragma warning(disable:4035 4704)

    INLINE LONG MulDiv(LONG a,LONG b,LONG c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     imul    ebx              //  imul ebx
        _asm     idiv    ecx              //  idiv ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDiv()

    #pragma warning(default:4035 4704)


#else

    //
    //  Use C9 __int64 support for Daytona RISC platforms.
    //

    INLINE LONG MulDiv( LONG a, LONG b, LONG c )
    {
        return (LONG)( Int32x32To64(a,b) / c );
    }


#endif


#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\mmx.cpp ===
//
//      Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//      Mmx.cpp
//      MMX Mix engines for Microsoft synth

/*
Variable useage.

		Variable									register 
		pfSamplePos									eax
		pfPitch										ebx
		dwI											ecx
		dwIncDelta									edx (edx is sometimes a temporary register)
		dwPosition1									esi
		dwPostiion2									edi

		vfRvolume and vfLvolume						mm0		
		vfRVolume, vfLVolume						mm2		

		mm4 - mm7 are temporary mmx registers.
*/

// Notes about calculation.

		// Loop is unrolled once.
		// *1  shifting volumne to 15 bit values to get rid of shifts and simplify code.
		// This make the packed mulitply work better later since I keep the sound interpolated
		// wave value at 16 bit signed value.  For a PMULHW, this results in 15 bit results
		// which is the same as the original code.


		// *2 linear interpolation can be done very quickly with MMX by re-arranging the
		// way that the interpolation is done. Here is code in C that shows the difference.
		// Original C code		
        //lM1 = ((pcWave[dwPosition1 + 1] - pcWave[dwPosition1]) * dwFract1) >> 12;
		//lM2 = ((pcWave[dwPosition2 + 1] - pcWave[dwPosition2]) * dwFract2) >> 12;
        //lM1 += pcWave[dwPosition1];
		//lM2 += pcWave[dwPosition2];

		// Equivalent C Code that can be done with a pmadd
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;


#include "common.h"

#define STR_MODULENAME "DDKSynth.sys:MMX: "

typedef unsigned __int64 QWORD;

#pragma code_seg()
/*****************************************************************************
 * CDigitalAudio::MixMono8X()
 *****************************************************************************
 * Implement a mono eight-bit mix.
 * Heavily optimized for MMX.
 */
DWORD CDigitalAudio::MixMono8X(short * pBuffer,     DWORD dwLength,    
                               DWORD dwDeltaPeriod, VFRACT vfDeltaVolume, 
                               PFRACT pfDeltaPitch, PFRACT pfSampleLength,
                               PFRACT pfLoopLength)
{
    DWORD dwI,dwIncDelta = dwDeltaPeriod;
    
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = m_vfLastLVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfVolume
	movd	mm7, vfVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaVolume
	movd	mm6, vfDeltaVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfVFract += vfDeltaVolume;
											// vfVFract += vfDeltaVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		inc		ecx					//dwI++;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		//shl		esi, 1			// do not shift left since pcWave is array of chars
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movzx	esi, word ptr[esi]	//lLM1 = pcWave[dwPosition1];
		movd	mm3, esi

		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		//shl		edi, 1			//do not shift left since pcWave is array of chars
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;
		
		movzx	edi, word ptr[edi]	//lLM2 = pcWave[dwPoisition2];
		movd	mm6, edi

		pxor	mm7, mm7		// zero out mm7 to make 8 bit into 16 bit
					
								// low 4 bytes in mm3
		punpcklwd	mm3, mm6	// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1]											
		
		add		esi, pBuffer	//
	punpcklbw	mm7, mm3		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		

		movq	mm3, mm2		// put left and right volume levels in mm3
		add		eax, ebx		//pfSamplePos += pfPitch;

		packssdw	mm3, mm2		// words in mm7
								// vfVolume, vfVolume, vfVolume, vfVolume
									
		movd	mm5, dword ptr[esi-2]	// Load values from buffer
		inc		ecx				// dwI++;
						
		psrad	mm7, 12			// shift back down to 16 bits.

	packssdw	mm7, mm4		// only need one word in mono case.
								// low word are lm2 and lm1
										        
		// above multiplies and shifts are all done with this one pmul. Low two word are only
		// interest in mono case
		pmulhw		mm3, mm7	// lLM1 *= vfVolume;								
								// lLM2 *= vfVolume;
								
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movd	dword ptr[esi-2], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		//shl		esi, 1				// do not shift left since pcWave is array of chars
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		movzx	esi, word ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		pxor	mm7, mm7
								// low four bytes
		movd	mm4, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

								// 8 bytes after unpakc
		punpcklbw	mm7, mm4	// 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits
				
		movq		mm5, mm2	// move volume into mm5
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer

		movd	edx, mm5

		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:		
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //m_vfLastLVolume = vfVolume;
    //m_vfLastRVolume = vfVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
	movd	[edx]this.m_vfLastLVolume, mm2	
	movd	[edx]this.m_vfLastRVolume, mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI);
}


/*****************************************************************************
 * CDigitalAudio::Mix8X()
 *****************************************************************************
 * Implement a stereo eight-bit mix.
 * Heavily optimized for MMX.
 */
DWORD CDigitalAudio::Mix8X(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
        VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
        PFRACT pfDeltaPitch, PFRACT pfSampleLength, PFRACT pfLoopLength)

{
    DWORD dwI;
    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
	//long lM2, lLM2;
    DWORD dwIncDelta = dwDeltaPeriod;
    //VFRACT dwFract1, dwFract2;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;

	VFRACT vfLVolume2 = m_vfLastLVolume;
    VFRACT vfRVolume2 = m_vfLastRVolume;

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
	dwLength <<= 1;

	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfLVolume
	movd	mm7, vfRVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaLVolume
	movd	mm6, vfDeltaRVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfLVFract += vfDeltaLVolume;
											// vfRVFract += vfDeltaRVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		add		ecx, 2				//dwI += 2;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		//shl		esi, 1			// do not shift left since pcWave is array of chars
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movzx	esi, word ptr[esi]	//lLM1 = pcWave[dwPosition1];

		movd	mm3, esi

		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		//shl		edi, 1			// do not shift left since pcWave is array of chars
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		
					
		movzx	edi, word ptr[edi]	//lLM2 = pcWave[dwPosition2];
		movd	mm6, edi
	
		pxor	mm7, mm7		// zero out mm7 to make 8 bit into 16 bit

								// low 4 bytes bytes in mm3
	punpcklwd	mm3, mm6		// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
		
		add		esi, pBuffer	//
	punpcklbw	mm7, mm3		// bytes in mm7
								// pcWave[dwPos2+1], 0, pcWave[dwPos2], 0, pcWave[dwPos1+1], pcWave[dwPos1], 0 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		

		movq	mm3, mm2		// put left and right volume levels in mm3

		add		eax, ebx		//pfSamplePos += pfPitch;
	packssdw	mm3, mm2		// words in mm3
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		movq	mm5, qword ptr[esi-4]	// Load values from buffer
		add		ecx, 2			// dwI += 2;
						
		psrad	mm7, 12			// shift back down to 16 bits.

		pand	mm7, wordmask	// combine results to get ready to multiply by left and right
		movq	mm6, mm7		// volume levels.
		pslld	mm6, 16			//
		por		mm7, mm6		// words in mm7
								// lM2, lM2, lM1, lM1
										        
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm3, mm7	// lLM1 *= vfLVolume;
								// lM1 *= vfRVolume;
								// lLM2 *= vfLVolume;
								// lM2 *= vfRVolume;
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movq	qword ptr[esi-4], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		//shl		esi, 1				// do not shift left since pcWave is array of chars
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		movzx	esi, word ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

		pxor	mm7, mm7
								// byte in MMX registers
		movd	mm4, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

		punpcklbw	mm7, mm4	// 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits

		pand		mm7, wordmask	// combine results to get ready to multiply by left and right 
		movq		mm6, mm7		// volume levels.
		pslld		mm6, 16			//
		por			mm7, mm6		// words in mm7
									// lM2, lM2, lM1, lM1

		pxor		mm6, mm6

		movq		mm5, mm2	// move volume1 into mm5
								
								// use pack to get 4 volume values together for multiplication.
		packssdw	mm5, mm6    // words in mm7
								// 0, 0, vfRVolume1, vfLVolume1
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer		

/*
		add		word ptr[edi-4], si
        jno		no_oflowl1
		// pBuffer[dwI] = 0x7fff;
		mov		word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
		mov		word ptr[edi-4], 0x8000
no_oflowl1:
		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:
*/
		movd	mm7, dword ptr[edi-4]		
		paddsw	mm7, mm5
		movd	dword ptr[edi-4], mm7
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //m_vfLastLVolume = vfLVolume;
    //m_vfLastRVolume = vfRVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
	movd	[edx]this.m_vfLastLVolume, mm2
	psrlq	mm2, 32
	movd	[edx]this.m_vfLastRVolume, mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI >> 1);
}


/*****************************************************************************
 * CDigitalAudio::MixMono16X()
 *****************************************************************************
 * Implement a mono sixteen-bit mix.
 * Heavily optimized for MMX.
 */
DWORD CDigitalAudio::MixMono16X(short * pBuffer,    DWORD dwLength,
                                DWORD dwDeltaPeriod,VFRACT vfDeltaVolume,
                                PFRACT pfDeltaPitch,PFRACT pfSampleLength, 
                                PFRACT pfLoopLength)
{
    DWORD dwI,dwIncDelta = dwDeltaPeriod;
    
    short * pcWave = (short*) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = m_vfLastLVolume;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfVolume
	movd	mm7, vfVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaVolume
	movd	mm6, vfDeltaVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfVFract += vfDeltaVolume;
											// vfVFract += vfDeltaVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		inc		ecx					//dwI++;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		shl		esi, 1			// shift left since pcWave is array of shorts
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movd	mm7, dword ptr[esi]	//lLM1 = pcWave[dwPosition1];
		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		shl		edi, 1			// shift left since pcWave is array of shorts
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		movq	mm3, mm2		// put left and right volume levels in mm3
		
					
		movd	mm6, dword ptr[edi]	//lLM2 = pcWave[dwPosition2];
	packssdw	mm3, mm2		// words in mm7
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		add		esi, pBuffer	//
	punpckldq	mm7, mm6		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		
		add		eax, ebx		//pfSamplePos += pfPitch;
		
		movd	mm5, dword ptr[esi-2]	// Load values from buffer
		inc		ecx				// dwI++;
						
		psrad	mm7, 12			// shift back down to 16 bits.

	packssdw	mm7, mm4		// only need one word in mono case.
								// low word are lm2 and lm1
										        
		// above multiplies and shifts are all done with this one pmul. Low two word are only
		// interest in mono case
		pmulhw		mm3, mm7	// lLM1 *= vfVolume;								
								// lLM2 *= vfVolume;
								
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movd	dword ptr[esi-2], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		shl		esi, 1				// shift left since pcWave is array of shorts
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		mov		esi, dword ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		movd	mm7, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits
				
		movq		mm5, mm2	// move volume into mm5
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer

		movd	edx, mm5

		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:		
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //m_vfLastLVolume = vfVolume;
    //m_vfLastRVolume = vfVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
	movd	[edx]this.m_vfLastLVolume, mm2	
	movd	[edx]this.m_vfLastRVolume, mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI);
}


/*****************************************************************************
 * CDigitalAudio::Mix16X()
 *****************************************************************************
 * Implement a stereo sixteen-bit mix.
 * Heavily optimized for MMX.
 */
DWORD CDigitalAudio::Mix16X(short * pBuffer,      DWORD dwLength, 
                            DWORD dwDeltaPeriod,  VFRACT vfDeltaLVolume, 
                            VFRACT vfDeltaRVolume,PFRACT pfDeltaPitch, 
                            PFRACT pfSampleLength,PFRACT pfLoopLength)
{
    DWORD dwI,dwIncDelta = dwDeltaPeriod;
    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
	//long lM2, lLM2;
    //VFRACT dwFract1, dwFract2;
    short * pcWave = (short *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = m_vfLastLVolume;
    VFRACT vfRVolume = m_vfLastRVolume;

	VFRACT vfLVolume2 = m_vfLastLVolume;
    VFRACT vfRVolume2 = m_vfLastRVolume;

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
	dwLength <<= 1;

	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfLVolume
	movd	mm7, vfRVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaLVolume
	movd	mm6, vfDeltaRVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfLVFract += vfDeltaLVolume;
											// vfRVFract += vfDeltaRVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		add		ecx, 2				//dwI += 2;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		shl		esi, 1			// shift left since pcWave is array of shorts
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movd	mm7, dword ptr[esi]	//lLM1 = pcWave[dwPosition1];
		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		shl		edi, 1			// shift left since pcWave is array of shorts
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		movq	mm3, mm2		// put left and right volume levels in mm3
		
					
		movd	mm6, dword ptr[edi]	//lLM2 = pcWave[dwPosition2];
	packssdw	mm3, mm2		// words in mm7
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		add		esi, pBuffer	//
	punpckldq	mm7, mm6		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		
		add		eax, ebx		//pfSamplePos += pfPitch;
		
		movq	mm5, qword ptr[esi-4]	// Load values from buffer
		add		ecx, 2			// dwI += 2;
						
		psrad	mm7, 12			// shift back down to 16 bits.

		pand	mm7, wordmask	// combine results to get ready to multiply by left and right
		movq	mm6, mm7		// volume levels.
		pslld	mm6, 16			//
		por		mm7, mm6		// words in mm7
								// lM2, lM2, lM1, lM1
										        
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm3, mm7	// lLM1 *= vfLVolume;
								// lM1 *= vfRVolume;
								// lLM2 *= vfLVolume;
								// lM2 *= vfRVolume;
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movq	qword ptr[esi-4], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		shl		esi, 1				// shift left since pcWave is array of shorts
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		mov		esi, dword ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		movd	mm7, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits

		pand		mm7, wordmask	// combine results to get ready to multiply by left and right 
		movq		mm6, mm7		// volume levels.
		pslld		mm6, 16			//
		por			mm7, mm6		// words in mm7
									// lM2, lM2, lM1, lM1

		pxor		mm6, mm6

		movq		mm5, mm2	// move volume1 into mm5
								
								// use pack to get 4 volume values together for multiplication.
		packssdw	mm5, mm6    // words in mm7
								// 0, 0, vfRVolume1, vfLVolume1
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer		

/*
		add		word ptr[edi-4], si
        jno		no_oflowl1
		// pBuffer[dwI] = 0x7fff;
		mov		word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
		mov		word ptr[edi-4], 0x8000
no_oflowl1:
		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:
*/
		movd	mm7, dword ptr[edi-4]		
		paddsw	mm7, mm5
		movd	dword ptr[edi-4], mm7
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //m_vfLastLVolume = vfLVolume;
    //m_vfLastRVolume = vfRVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
	movd	[edx]this.m_vfLastLVolume, mm2
	psrlq	mm2, 32
	movd	[edx]this.m_vfLastRVolume, mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI >> 1);
}

/*****************************************************************************
 * MMXDisabled()
 *****************************************************************************
 * Check the registry key to determine whether to ignore MMX.
 */
static BOOL MMXDisabled()
{
    ULONG ulValue;

    if (!GetRegValueDword(
            TEXT("Software\\Microsoft\\DirectMusic"),
            TEXT("MMXDisabled"),
            &ulValue))
    {
        return FALSE;
    }

    return (BOOL)ulValue;
}

#define CPU_ID _asm _emit 0x0f _asm _emit 0xa2  

/*****************************************************************************
 * MultiMediaInstructionsSupported()
 *****************************************************************************
 * Returns whether this CPU supports MMX.
 */
BOOL MultiMediaInstructionsSupported()
{
    BOOL bMultiMediaInstructionsSupported;
    
	if (!MMXDisabled())
	{
		_asm 
		{
			pushfd                      // Store original EFLAGS on stack
			pop     eax                 // Get original EFLAGS in EAX
			mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
			xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
			push    eax                 // Save new EFLAGS value on stack
			popfd                       // Replace current EFLAGS value
			pushfd                      // Store new EFLAGS on stack
			pop     eax                 // Get new EFLAGS in EAX
			xor     eax, ecx            // Can we toggle ID bit?
			jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
			mov     eax, 1              // Set EAX to tell the CPUID instruction what to return
			push	ebx
			CPU_ID                      // Get family/model/stepping/features
			pop		ebx
            xor     eax,eax             // Assume failure
			test    edx, 0x00800000L    // Check if mmx technology available
			jz      Done                // Jump if no
                    		// Tests passed, this machine supports MMX
            inc     eax                 // Set to success
Done:
            mov     bMultiMediaInstructionsSupported, eax
		}
    } else {
        bMultiMediaInstructionsSupported = 0;
    }

    return (bMultiMediaInstructionsSupported);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\synth.h ===
//      Synth.h
//      Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//

/*

  DLS Design Overview (DLS Level 1 Specification, MMA)

  A musical instruments defined by a sound sample is much more than a simple wave file.
  In addition to the actual sample data and associated loop information, the instrument
  must indicate under what circumstances each sample should be used, and how to modulate,
  or articulate, the sample as it plays.

  A generic sample-playback synthesis architecture can be broken down into three distinct
  subsystems:

  Control logic

  Digital audio engine

  Articulation modules and connections




  Control Logic

  The control logic receives a MIDI note event and determines which instrument should play
  the note, and, within that instrument, which sample and articulation combination to use.

  Choosing the instrument is little more than observing the MIDI channel number in the
  event and selecting the proper instrument accordingly.

  Choosing the sample and articulation to use is not as simple.  Almost all samples synthesis
  architectures employ some method of organizing samples by note range across the keyboard.
  In addition, multiple samples can be used to represent different velocity randges and
  multiple samples can be played at once to create a layered, richer sound.

  Terms such as layers, splits, blocks, and regions are commonly used in synthesizer jargon
  to refer to the management of multiple samples.  For the purposes here, we refer to them
  as regions.

  DLS Level 1 implements a bare bones approach with no velocity cross-switching and no
  layering.



  Digital Audio Engine

  The digital audio engine is certainly the most obvious part of the synthesizer.  It is
  composed of a playback engine, or digital oscillator, and a digitally controlled amplifier.

  The digital oscillator plays a samples sound waveform, managing loop points within the
  waveform so the sound can play continuously if needed.  And, as the note plays, it responds
  to changes in pitch, allowing for real time expression such as vibrato and pitch bend.

  The digitally controlled amplirier modulates the loudness of the instrument.  Importantly,
  this is used to control the amplitude shape, or envelope, of the note.  However, it is also
  used for other types of real-time expression, such as tremolo.

  Pitch and volume control of the oscillator and amplifier are critical because they define
  the shape of the sounds as it plays, and allow it to be dynamically responsive in real
  time, giving the samples instrument much more expression than the simple digital audio
  playback could ever provide.  Real-time control of these parameters comes from modules in
  the Articulation section which generate a constant stream of changing pitch and volume to
  which the digital audio engine responds.

  The digital audio path represents the journey the sound takes from the oscillator to the
  amplifier to the digital-to-analog converter (DAC).  This patch can optionally include
  additional modules, such as filters and effects devices, that process the sound as it
  flows from oscillator to DAC.

  The DLS Level 1 specificaion implements a simple digital audio engine composed of an
  oscillator, amplifier, and DAC.  The oscillator supports looped as well as one-shot samples.



  Articulation Modules and Connections

  The articulation modules are a set of devices that provide additional control over the
  pitch and volume of the sample as it plays.

  The articulation modules include low frequency oscillators (LFOs) to contribute vibrato
  and tremolo, envelope generators to defint an overall volume and pitch shape to the sample,
  and MIDI real-time controllers, such as Pitch Bend and Mod Wheel, to give the music real-time
  expression.

  Generally, these modules can be linked in different ways to provide different results.  For
  example, a LFO might generate a sine wave which modulates the pitch of the sample for vibrato
  of the volume of the sample for tremolo.  Modules can also receive as well as send control
  signals.  An envelope generator might use the key velocity to influence the attack time of
  the envelope.

  Articulation modules can be configured in different ways, and this configuration is an
  important part of the instrument definition.  In fact, the term patch as used for an
  instrument preset refers to the early days when the hardware modules in an analog
  synthesizer were "patched" together with cables, which routed signals from module to module.

  The ability to configure the modules in important because it yields a flexible approach to
  synthesizer design.  At the same time, it is important to define the base level configuration
  that can be supported by all hardware.

  So, the DLS Level 1 specification is relatively rigid.  It defines a preset routing
  arrangement that is simple enough to be supportable by existing hardware.  Fortunately, it
  is a musically logical and useful configuration.

  Importantly, the specification maps the routing on a flexible system, so it can grow into
  Level 2 and beyond.

  It is important to understand that this is purely a symbolic system that can be mapped on
  many different hardware designs.  Do not think of it as the recipe for a specific method
  for building synthesis architectures.  It should be flexible enough to provide a common
  language between hardware implementations.

*/





#ifndef __SYNTH_H__
#define __SYNTH_H__

#include "clist.h"
#include "dmdls.h"

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE

// controller numbers
#define CC_BANKSELECTH  0x00
#define CC_BANKSELECTL  0x20

#define CC_MODWHEEL     0x01
#define CC_VOLUME       0x07
#define CC_PAN          0x0A
#define CC_EXPRESSION   0x0B
#define CC_SUSTAIN      0x40
#define CC_ALLSOUNDSOFF 0x78
#define CC_RESETALL     0x79
#define CC_ALLNOTESOFF  0x7B
#define CC_MONOMODE     0x7E
#define CC_POLYMODE     0x7F

// rpn controllers
#define CC_DATAENTRYMSB 0x06
#define CC_DATAENTRYLSB 0x26
#define CC_NRPN_LSB     0x62
#define CC_NRPN_MSB     0x63
#define CC_RPN_LSB      0x64
#define CC_RPN_MSB      0x65

// registered parameter numbers
#define RPN_PITCHBEND   0x00
#define RPN_FINETUNE    0x01
#define RPN_COARSETUNE  0x02

/*  Sample format and Sample playback flags are organized
    together because together they determine which
    mix loop to use.
*/
#define SFORMAT_16              1       // Sixteen bit sample.
#define SFORMAT_8               2       // Eight bit sample.
#define SPLAY_MMX               0x10    // Use MMX processor (16 bit only).
#define SPLAY_STEREO            0x40    // Stereo output.


/*  For internal representation, volume is stored in Volume Cents,
    where each increment represents 1/100 of a dB.
    Pitch is stored in Pitch Cents, where each increment
    represents 1/100 of a semitone.
*/
typedef long    PREL;   // Pitch cents, for relative pitch.
typedef short   PRELS;  // Pitch cents, in storage form.
typedef long    VREL;   // Volume cents, for relative volume.
typedef short   VRELS;  // Volume cents, in storage form.
typedef long    TREL;   // Time cents, for relative time
typedef short   TRELS;  // Time Cents, in storage form.
typedef LONGLONG STIME; // Time value, in samples.
typedef long    MTIME;  // Time value, in milliseconds.
typedef long    PFRACT; // Pitch increment, where upper 20 bits are
                        // the index and the lower 12 are the fractional
                        // component.
typedef long    VFRACT; // Volume, where lower 12 bits are the fraction.

typedef long    TCENT;
typedef short   SPERCENT;

#define MIN_VOLUME      -9600   // Below 96 db down is considered off.
#define PERCEIVED_MIN_VOLUME   -8000   // But, we cheat.
#define SAMPLE_RATE_22  22050   // 22 kHz is the standard rate.
#define SAMPLE_RATE_44  44100   // 44 kHz is the high quality rate.
#define SAMPLE_RATE_11  11025   // 11 kHz should not be allowed!
#define STEREO_ON       1
#define STEREO_OFF      0

#define FORCEBOUNDS(data,min,max) {if (data < min) data = min; else if (data > max) data = max;}
#define FORCEUPPERBOUNDS(data, max) {if (data > max) data = max;}

class Collection;
class CControlLogic;
class CInstManager;
class CSynth;

/*****************************************************************************
 * class CSourceLFO
 *****************************************************************************
 * CSourceLFO is the file format definition of the LFO in an
 * instrument. This is used to represent an LFO as part of
 * a specific articulation set within an instrument that
 * has been loaded from disk. Once the instrument is chosen
 * to play a note, this is also copied into the CVoice
 * object.
 */
class CSourceLFO
{
public:
                CSourceLFO();
    void        Init(DWORD dwSampleRate);
    void        SetSampleRate(long lDirection);
    void        Verify();           // Verifies that the data is valid.

    PFRACT      m_pfFrequency;      // Frequency, in increments through the sine table.
    STIME       m_stDelay;          // How long to delay in sample units.
    VRELS       m_vrMWVolumeScale;  // Scaling of volume LFO by Mod Wheel.
    PRELS       m_prMWPitchScale;   // Scaling of pitch LFO by Mod Wheel.
    VRELS       m_vrVolumeScale;    // Scaling of straight volume signal from LFO.
    PRELS       m_prPitchScale;     // Scaling of straight pitch signal from LFO.

};

/*****************************************************************************
 * class CSourceEG
 *****************************************************************************
 * CSourceEG is the file format definition of an Envelope
 * generator in an instrument.
 */
class CSourceEG
{
public:
                CSourceEG();
    void        SetSampleRate(long lDirection);
    void        Init();
    void        Verify();           // Verifies valid data.

    STIME       m_stAttack;         // Attack rate.
    STIME       m_stDecay;          // Decay rate.
    STIME       m_stRelease;        // Release rate.
    TRELS       m_trVelAttackScale; // Scaling of attack by note velocity.
    TRELS       m_trKeyDecayScale;  // Scaling of decay by note value.
    SPERCENT    m_pcSustain;        // Sustain level.
    short       m_sScale;           // Scaling of entire signal.
};

/*****************************************************************************
 * class CSourceArticulation
 *****************************************************************************
 * CSourceArticulation is the file format definition of
 * a complete articulation set: the LFO and two
 * envelope generators.
 *
 * Since several regions within one Instrument can
 * share one articulation, a counter is used to keep
 * track of the usage.
 */
class CSourceArticulation
{
public:
                CSourceArticulation();
    HRESULT     Download( DMUS_DOWNLOADINFO * pInfo,
                          void * pvOffsetTable[],   DWORD dwIndex,
                          DWORD dwSampleRate,       BOOL fNewFormat);
    void        Init(DWORD dwSampleRate);
    void        Verify();           // Verifies valid data.
    void        AddRef();
    void        Release();
    void        SetSampleRate(DWORD dwSampleRate);

    CSourceEG   m_PitchEG;          // Pitch envelope.
    CSourceEG   m_VolumeEG;         // Volume envelope.
    CSourceLFO  m_LFO;              // Low frequency oscillator.
    DWORD       m_dwSampleRate;
    WORD        m_wUsageCount;      // Keeps track of how many times in use.
    short       m_sDefaultPan;      // default pan (for drums)
};

/*****************************************************************************
 * class CWave
 *****************************************************************************
 * Since multiple regions may reference
 * the same Wave, a reference count is maintained to
 * keep track of how many regions are using the sample.
 */
class CWave : public CListItem
{
public:
                    CWave();
                    ~CWave();
    void            Verify();           // Verifies that the data is valid.
    void            Release();          // Remove reference.
    void            AddRef();           // Add reference.
    void            PlayOn();           // Increment play count.
    void            PlayOff();          // Decrement play count.
    BOOL            IsPlaying();        // Is currently playing?
    CWave *         GetNext()        {return(CWave *)CListItem::GetNext();};

    DWORD           m_dwSampleLength;   // Length of sample.
    DWORD           m_dwSampleRate;
    HRESULT ( CALLBACK *m_lpFreeHandle)(HANDLE,HANDLE);
    HANDLE          m_hUserData;        // Used to notify app when wave released.
    short *         m_pnWave;
    DWORD           m_dwID;             // ID for matching wave with regions.
    WORD            m_wUsageCount;      // Keeps track of how many times in use.
    WORD            m_wPlayCount;       // Wave is currently being played.
    BYTE            m_bSampleType;
    DMUS_DOWNLOADINFO * m_pWaveMem;
};

/*****************************************************************************
 * class CWavePool
 *****************************************************************************
 * implements a list of wave objects.
 */
class CWavePool : public CList
{
public:
    CWave *      GetHead()           {return (CWave *)CList::GetHead();};
    CWave *      GetItem(DWORD dwID) {return (CWave *)CList::GetItem((LONG)dwID);};
    CWave *      RemoveHead()        {return (CWave *)CList::RemoveHead();};
};


/*****************************************************************************
 * class CSourceSample
 *****************************************************************************
 * The CSourceSample class describes one sample in an
 * instrument. The sample is referenced by a CSourceRegion
 * structure.
 */
class CSourceSample
{
public:
                CSourceSample();
                ~CSourceSample();
    BOOL        CopyFromWave();
    void        Verify();           // Verifies that the data is valid.

    CWave *     m_pWave;            // Wave in pool.
    DWORD       m_dwLoopStart;      // Index of start of loop.
    DWORD       m_dwLoopEnd;        // Index of end of loop.
    DWORD       m_dwSampleLength;   // Length of sample.
    DWORD       m_dwSampleRate;     // Sample rate of recording.
    PRELS       m_prFineTune;       // Fine tune to correct pitch.
    DWORD       m_dwID;             // Wave pool id.
    BYTE        m_bSampleType;      // 16 or 8.
    BYTE        m_bOneShot;         // Is this a one shot sample?
    BYTE        m_bMIDIRootKey;     // MIDI note number for sample.
};

/*****************************************************************************
 * class CSourceRegion
 *****************************************************************************
 * The CSourceRegion class defines a region within an instrument.
 * The sample is managed with a pointer instead of an embedded
 * sample. This allows multiple regions to use the same sample.
 *
 * Each region also has an associated articulation. For drums, there
 * is a one to one matching. For melodic instruments, all regions
 * share the same articulation. So, to manage this, each region
 * points to the articulation.
 */
class CSourceRegion : public CListItem
{
public:
                CSourceRegion();
                ~CSourceRegion();
    CSourceRegion *GetNext()
        {return(CSourceRegion *)CListItem::GetNext();};

    void        Verify();                   // Verifies that the data is valid.
    void        SetSampleRate(DWORD dwSampleRate);
    HRESULT     Download( DMUS_DOWNLOADINFO * pInfo, void * pvOffsetTable[],
                          DWORD *pdwRegionIX, DWORD dwSampleRate, BOOL fNewFormat);

    CSourceSample m_Sample;                 // Sample structure.
    CSourceArticulation * m_pArticulation;  // Pointer to associated articulation.
    VRELS       m_vrAttenuation;            // Volume change to apply to sample.
    PRELS       m_prTuning;                 // Pitch shift to apply to sample.
    BYTE        m_bAllowOverlap;            // Allow overlapping of note.
    BYTE        m_bKeyHigh;                 // Upper note value for region.
    BYTE        m_bKeyLow;                  // Lower note value.
    BYTE        m_bGroup;                   // Logical group (for drums.)
};


/*****************************************************************************
 * class CSourceRegionList
 *****************************************************************************
 * implements a list of CSourceRegion objects.
 */
class CSourceRegionList : public CList
{
public:
    CSourceRegion *GetHead()    {return (CSourceRegion *)CList::GetHead();};
    CSourceRegion *RemoveHead() {return (CSourceRegion *)CList::RemoveHead();};
};


/*****************************************************************************
 * class CInstrument
 *****************************************************************************
 * The CInstrument class is really the file format definition
 * of an instrument.
 *
 * The CInstrument can be either a Drum or a Melodic instrument.
 * If a drum, it has up to 128 pairings of articulations and
 * regions. If melodic, all regions share the same articulation.
 * ScanForRegion is called by ControlLogic to get the region
 * that corresponds to a note.
 */
class CInstrument : public CListItem
{
public:
                    CInstrument();
                    ~CInstrument();
    void            Init(DWORD dwSampleRate);
    void            Verify();               // Verifies that the data is valid.
    CInstrument *   GetInstrument(DWORD dwProgram,DWORD dwAccept);
    CInstrument *   GetNext()
        {return(CInstrument *)CListItem::GetNext();};

    void            SetSampleRate(DWORD dwSampleRate);
    CSourceRegion * ScanForRegion(DWORD dwNoteValue);
    HRESULT         LoadRegions( BYTE *p, BYTE *pEnd, DWORD dwSampleRate);
    HRESULT         Load( BYTE *p, BYTE *pEnd, DWORD dwSampleRate);

    CSourceRegionList m_RegionList;         // Linked list of regions.
    DWORD             m_dwProgram;          // Which program change it represents.
};

/*****************************************************************************
 * class CInstrumentList
 *****************************************************************************
 * Implements a list of CInstrument objects.
 */
class CInstrumentList : public CList
{
public:
    CInstrument * GetHead()    {return (CInstrument *)CList::GetHead();};
    CInstrument * RemoveHead() {return (CInstrument *)CList::RemoveHead();};
};

#define WAVE_HASH_SIZE          31  // Keep waves in a hash table of linked lists to speed access.
#define INSTRUMENT_HASH_SIZE    31  // Same with instruments.

/*****************************************************************************
 * class CInstManager
 *****************************************************************************
 * Manages the instruments, including sample rates, downloads, and waves.
 * Utilizes a hash scheme for quick location of waves and instruments
 * (they can become numerous).
 */
class CInstManager
{
public:
                    CInstManager();
                    ~CInstManager();
    CInstrument *   GetInstrument(DWORD dwPatch,DWORD dwKey);
    void            Verify();           // Verifies that the data is valid.
    void            SetSampleRate(DWORD dwSampleRate);
    HRESULT         Download(LPHANDLE phDownload,
                             void * pvData,
                             LPBOOL pbFree);
    HRESULT         Unload(HANDLE hDownload,
                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                           HANDLE hUserData);
private:
    HRESULT         DownloadInstrument(LPHANDLE phDownload,
                                         DMUS_DOWNLOADINFO *pInfo,
                                         void *pvOffsetTable[],
                                         void *pvData,
                                         BOOL fNewFormat);
    HRESULT         DownloadWave(LPHANDLE phDownload,
                                DMUS_DOWNLOADINFO *pInfo,
                                void *pvOffsetTable[],
                                void *pvData);

    CInstrumentList m_InstrumentList[INSTRUMENT_HASH_SIZE];
    CWavePool       m_WavePool[WAVE_HASH_SIZE];
    CWavePool       m_FreeWavePool;     // Track waves still in use, but unloaded.
    DWORD           m_dwSampleRate;     // Sample rate requested by app.

public:
    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    BOOL            m_fCSInitialized;
};

/*****************************************************************************
 * class CMIDIData
 *****************************************************************************
 * Represents a single MIDI event.
 */
class CMIDIData : public CListItem
{
public:
                CMIDIData();
    CMIDIData *  GetNext()  {return (CMIDIData *)CListItem::GetNext();};

    STIME       m_stTime;   // Time this event was recorded.
    long        m_lData;    // Data stored in event.
};

/*****************************************************************************
 * class CMIDIDataList
 *****************************************************************************
 * Implements a list of CMIDIData objects.
 */
class CMIDIDataList : public CList
{
public:
    CMIDIData *GetHead()    {return (CMIDIData *)CList::GetHead();};
    CMIDIData *RemoveHead() {return (CMIDIData *)CList::RemoveHead();};
};

#define MAX_MIDI_EVENTS     1000

/*****************************************************************************
 * class CMIDIRecorder
 *****************************************************************************
 * CMIDIRecorder is used to keep track of a time
 * slice of MIDI continuous controller events.
 * This is subclassed by the PitchBend, Volume,
 * Expression, and ModWheel Recorder classes, so
 * each of them may reliably manage MIDI events
 * coming in.
 *
 * CMIDIRecorder uses a linked list of CMIDIData
 * structures to keep track of the changes within
 * the time slice.
 *
 * Allocation and freeing of the CMIDIData events
 * is kept fast and efficient because they are
 * always pulled from the static pool m_pFreeList,
 * which is really a list of events pulled directly
 * from the static array m_sEventBuffer. This is
 * safe because we can make the assumption that
 * the maximum MIDI rate is 1000 events per second.
 * Since we are managing time slices of roughly
 * 1/16 of a second, a buffer of 100 events would
 * be overkill.
 *
 * Although CMIDIRecorder is subclassed to several
 * different event types, they all share the one
 * static free list.
 */
class CMIDIRecorder
{
public:
                CMIDIRecorder();
                ~CMIDIRecorder();        // Be sure to clear local list.
    void        Init();                  // Inits the free list.
    static void InitTables();
    BOOL        FlushMIDI(STIME stTime); // Clear after time stamp.
    BOOL        ClearMIDI(STIME stTime); // Clear up to time stamp.
    BOOL        RecordMIDI(STIME stTime, long lData); // MIDI input goes here.
    long        GetData(STIME stTime);   // Gets data at time.
    static VREL VelocityToVolume(WORD nVelocity);

    static CMIDIDataList * m_sFreeList;  // Free list of events.
    static ULONG sm_cRefCnt;  // ref count

protected:
    void        GrabSpinLock();
    void        ReleaseSpinLock();

    CMIDIDataList m_EventList;           // This recorder's list.
    STIME         m_stCurrentTime;       // Time for current value.
    long          m_lCurrentData;        // Current value.

private:
    KSPIN_LOCK    m_SpinLock;
    KIRQL         m_OldIrql;

};

/*****************************************************************************
 * class CNote
 *****************************************************************************
 * Represents a single note.  This can also represent fakes notes that
 * represent special MIDI commands (Master Volume, etc).
 */
class CNote
{
public:
    STIME       m_stTime;
    BYTE        m_bPart;
    BYTE        m_bKey;
    BYTE        m_bVelocity;
};


/*****************************************************************************
 * Fake note values held in CNoteIn's queue to indicate changes in the
 * sustain pedal and "all notes off".
 *
 * This is a grab bag for synchronous events that should be queued in time,
 * not simply done as soon as received.
 *
 * By putting them in the note queue, we ensure they are evaluated in the
 * exact same order as the notes themselves.
 *****************************************************************************/
const BYTE NOTE_PROGRAMCHANGE   = 0xF1;
const BYTE NOTE_CC_BANKSELECTH  = 0xF2;
const BYTE NOTE_CC_BANKSELECTL  = 0xF3;
const BYTE NOTE_CC_POLYMODE     = 0xF4;
const BYTE NOTE_CC_MONOMODE     = 0xF5;
const BYTE NOTE_CC_RPN_MSB      = 0xF6;
const BYTE NOTE_CC_RPN_LSB      = 0xF7;
const BYTE NOTE_CC_NRPN         = 0xF8;
const BYTE NOTE_CC_DATAENTRYLSB = 0xF9;
const BYTE NOTE_CC_DATAENTRYMSB = 0xFA;
const BYTE NOTE_ASSIGNRECEIVE   = 0xFB;
const BYTE NOTE_MASTERVOLUME    = 0xFC;
const BYTE NOTE_SOUNDSOFF       = 0xFD;
const BYTE NOTE_SUSTAIN         = 0xFE;
const BYTE NOTE_ALLOFF          = 0xFF;

/*****************************************************************************
 * class CNoteIn
 *****************************************************************************
 * Implements a note receptor.  This is used by CControlLogic to queue notes.
 */
class CNoteIn : public CMIDIRecorder
{
public:
    void        FlushMIDI(STIME stTime);
    void        FlushPart(STIME stTime, BYTE bChannel);
    BOOL        RecordNote(STIME stTime, CNote * pNote);
    BOOL        RecordEvent(STIME stTime, DWORD dwPart, DWORD dwCommand, BYTE bData);
    BOOL        GetNote(STIME stTime, CNote * pNote); // Gets the next note.
};

/*****************************************************************************
 * class CModWheelIn
 *****************************************************************************
 * CModWheelIn handles one channel of Mod Wheel
 * input. As such, it is not embedded in the CVoice
 * class, rather it is in the Channel class.
 * CModWheelIn's task is simple: keep track of MIDI
 * Mod Wheel events, each tagged with millisecond
 * time and value, and return the value for a specific
 * time request.
 *
 * CModWheelIn inherits almost all of its functionality
 * from the CMIDIRecorder Class.
 * CModWheelIn receives MIDI mod wheel events through
 * the RecordMIDI() command, which stores the
 * time and value of the event.
 *
 * CModWheelIn is called by CVoiceLFO to get the
 * current values for the mod wheel to set the amount
 * of LFO modulation for pitch and volume.
 */
class CModWheelIn : public CMIDIRecorder
{
public:
    DWORD       GetModulation(STIME stTime);    // Gets the current Mod Wheel value.
};

/*****************************************************************************
 * class CPitchBendIn
 *****************************************************************************
 * CPitchBendIn handles one channel of Pitch Bend
 * input. Like the Mod Wheel module, it inherits
 * its abilities from the CMIDIRecorder class.
 *
 * It has one additional routine, GetPitch(),
 * which returns the current pitch bend value.
 */
class CPitchBendIn : public CMIDIRecorder
{
public:
                CPitchBendIn();
    PREL        GetPitch(STIME stTime); // Gets the current pitch in pitch cents.

    // current pitch bend range.  Note that this is not timestamped!
    PREL        m_prRange;
};

/*****************************************************************************
 * class CVolumeIn
 *****************************************************************************
 * CVolumeIn handles one channel of Volume
 * input. It inherits its abilities from
 * the CMIDIRecorder class.
 *
 * It has one additional routine, GetVolume(),
 * which returns the volume in decibels at the
 * specified time.
 */
class CVolumeIn : public CMIDIRecorder
{
public:
                CVolumeIn();
    VREL        GetVolume(STIME stTime);    // Gets the current volume in db cents.
};

/*****************************************************************************
 * class CExpressionIn
 *****************************************************************************
 * CExpressionIn handles one channel of Expression
 * input. It inherits its abilities from
 * the CMIDIRecorder class.
 *
 * It has one additional routine, GetVolume(),
 * which returns the volume in decibels at the
 * specified time.
 */
class CExpressionIn : public CMIDIRecorder
{
public:
                CExpressionIn();
    VREL        GetVolume(STIME stTime);    // Gets the current volume in db cents.
};

/*****************************************************************************
 * class CPanIn
 *****************************************************************************
 * CPanIn handles one channel of Volume
 * input. It inherits its abilities from
 * the CMIDIRecorder class.
 *
 * It has one additional routine, GetPan(),
 * which returns the pan position (MIDI value)
 * at the specified time.
 */
class CPanIn : public CMIDIRecorder
{
public:
                CPanIn();
    long        GetPan(STIME stTime);       // Gets the current pan.
};

/*****************************************************************************
 * class CVoiceLFO
 *****************************************************************************
 * The CVoiceLFO class is used to track the behavior
 * of an LFO within a voice. The LFO is hard wired to
 * output both volume and pitch values, through separate
 * calls to GetVolume and GetPitch.
 *
 * It also manages mixing Mod Wheel control of pitch and
 * volume LFO output. It tracks the scaling of Mod Wheel
 * for each of these in m_nMWVolumeScale and m_nMWPitchScale.
 * It calls the Mod Wheel module to get the current values
 * if the respective scalings are greater than 0.
 *
 * All of the preset values for the LFO are carried in
 * the m_CSource field, which is a replica of the file
 * CSourceLFO structure. This is initialized with the
 * StartVoice call.
 */
class CVoiceLFO
{
public:
                CVoiceLFO();
    STIME       StartVoice(CSourceLFO *pSource,
                           STIME stStartTime,CModWheelIn * pModWheelIn);
    VREL        GetVolume( STIME stTime, STIME *pstTime);   // Returns volume cents.
    PREL        GetPitch(  STIME stTime, STIME *pstTime);   // Returns pitch cents.
private:
    long        GetLevel(  STIME stTime, STIME *pstTime);

    CSourceLFO   m_Source;              // All of the preset information.
    STIME        m_stStartTime;         // Time the voice started playing.
    CModWheelIn  *m_pModWheelIn;        // Pointer to Mod Wheel for this channel.
    STIME        m_stRepeatTime;        // Repeat time for LFO.
};


/*****************************************************************************
 * class CVoiceEG
 *****************************************************************************
 * The CVoiceEG class is used to track the behavior of
 * an Envelope Generator within a voice. There are two
 * EG's, one for pitch and one for volume. However, they
 * behave identically.
 *
 * All of the preset values for the EG are carried in
 * the m_Source field, which is a replica of the file
 * CSourceEG structure. This is initialized with the
 * StartVoice call.
 */
class CVoiceEG
{
public:
                CVoiceEG();
    STIME       StartVoice(CSourceEG *pSource, STIME stStartTime,
                           WORD nKey, WORD nVelocity);
    void        StopVoice(STIME stTime);
    void        QuickStopVoice(STIME stTime, DWORD dwSampleRate);
    VREL        GetVolume(STIME stTime, STIME *pstTime);    // Returns volume cents.
    PREL        GetPitch(STIME stTime, STIME *pstTime);     // Returns pitch cents.
    BOOL        InAttack(STIME stTime);     // is voice still in attack?
    BOOL        InRelease(STIME stTime);    // is voice in release?
private:
    long        GetLevel(STIME stTime, STIME *pstTime, BOOL fVolume);

    CSourceEG    m_Source;           // Preset values for envelope, copied from file.
    STIME        m_stStartTime;      // Time note turned on
    STIME        m_stStopTime;       // Time note turned off
};

/*****************************************************************************
 * class CDigitalAudio
 *****************************************************************************
 * The CDigitalAudio class is used to track the playback
 * of a sample within a voice.
 *
 * It manages the loop points, the pointer to the sample.
 * and the base pitch and base volume, which it initially sets
 * when called via StartVoice().
 *
 * Pitch is stored in a fixed point format, where the leftmost
 * 20 bits define the sample increment and the right 12 bits
 * define the factional increment within the sample. This
 * format is also used to track the position in the sample.
 * Mix is a critical routine. It is called by the CVoice to blend
 * the instrument into the data buffer. It is handed relative change
 * values for pitch and volume (semitone cents and decibel
 * cents.) These it converts into three linear values:
 * Left volume, Right volume, and Pitch.
 *
 * It then compares these new values with the values that existed
 * for the previous slice and divides by the number of samples to
 * determine an incremental change at the sample rate.
 * Then, in the critical mix loop, these are added to the
 * volume and pitch indices to give a smooth linear slope to the
 * change in volume and pitch.
 */

#define MAX_SAMPLE  4095
#define MIN_SAMPLE  (-4096)

#define MAXDB           0
#define MINDB           -100
#define TEST_WRITE_SIZE     3000
#define TEST_SOURCE_SIZE    44100

class CDigitalAudio
{
public:
                CDigitalAudio();
    STIME       StartVoice(CSynth *pSynth,
                    CSourceSample *pSample,
                    VREL vrBaseLVolume, VREL vrBaseRVolume,
                    PREL prBasePitch, long lKey);
    BOOL        Mix(short *pBuffer,DWORD dwLength,
                    VREL dwVolumeL, VREL dwVolumeR, PREL dwPitch,
                    DWORD dwStereo);
    void        ClearVoice();
    static PFRACT PRELToPFRACT(PREL prPitch); // Pitch cents to pitch.

private:
    DWORD       Mix8(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMono8(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       Mix16(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
                    VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMono16(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD _cdecl Mix8X(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
                     VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                     PFRACT pfDeltaPitch,
                     PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD _cdecl Mix16X(short * pBuffer, DWORD dwLength, DWORD dwDeltaPeriod,
                     VFRACT vfDeltaLVolume, VFRACT vfDeltaRVolume,
                     PFRACT pfDeltaPitch,
                     PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMono16X(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    DWORD       MixMono8X(short * pBuffer, DWORD dwLength,DWORD dwDeltaPeriod,
                    VFRACT vfDeltaVolume,
                    PFRACT pfDeltaPitch,
                    PFRACT pfSampleLength, PFRACT pfLoopLength);
    void        BeforeBigSampleMix();
    void        AfterBigSampleMix();
    static VFRACT VRELToVFRACT(VREL vrVolume); // dB to absolute.

    CSourceSample   m_Source;           // Preset values for sample.
    CSynth *        m_pSynth;           // For access to sample rate, etc.

    BOOL            m_fMMXEnabled;

    short *         m_pnWave;           // Private pointer to wave.
    VREL            m_vrBaseLVolume;    // Overall left volume.
    VREL            m_vrBaseRVolume;    // Overall left volume.
    PFRACT          m_pfBasePitch;      // Overall pitch.
    VFRACT          m_vfLastLVolume;    // The last left volume value.
    VFRACT          m_vfLastRVolume;    // The last right volume value.
    PFRACT          m_pfLastPitch;      // The last pitch value.
    VREL            m_vrLastLVolume;    // The last left volume value, in VREL.
    VREL            m_vrLastRVolume;    // Same for right.
    PREL            m_prLastPitch;      // Same for pitch, in PREL.
    PFRACT          m_pfLastSample;     // The last sample position.
    PFRACT          m_pfLoopStart;      // Start of loop.
    PFRACT          m_pfLoopEnd;        // End of loop.
    PFRACT          m_pfSampleLength;   // Length of sample buffer.
    BOOL            m_fElGrande;        // Indicates larger than 1m wave.
    ULONGLONG       m_ullLastSample;    // Used to track > 1m wave.
    ULONGLONG       m_ullLoopStart;     // Used to track > 1m wave.
    ULONGLONG       m_ullLoopEnd;       // Used to track > 1m wave.
    ULONGLONG       m_ullSampleLength;  // Used to track > 1m wave.
    DWORD           m_dwAddressUpper;   // Temp storage for upper bits of address.
};

/*****************************************************************************
 * class CVoice
 *****************************************************************************
 * The CVoice class pulls together everything needed to perform
 * one voice. It has the envelopes, lfo, and sample embedded
 * within it.
 *
 * StartVoice() initializes a voice structure for playback. The
 * CSourceRegion structure carries the region and sample as well
 * as a pointer to the articulation, which is used to set up
 * the various articulation modules. It also carries pointers to
 * all the MIDI modulation inputs and the values for the note key
 * and channel which are used by the parent ControlLogic object
 * to match incoming note off events with the right voice.
 */
class CVoice : public CListItem
{
public:
                CVoice();
    CVoice *    GetNext()
        {return (CVoice *)CListItem::GetNext();};

    BOOL        StartVoice(CSynth *pControl,
                           CSourceRegion *pRegion, STIME stStartTime,
                           CModWheelIn * pModWheelIn,
                           CPitchBendIn * pPitchBendIn,
                           CExpressionIn * pExpressionIn,
                           CVolumeIn * pVolumeIn,
                           CPanIn * pPanIn,
                           WORD nKey,WORD nVelocity,
                           VREL vrVolume,      // Added for GS
                           PREL prPitch);      // Added for GS

    void        StopVoice(STIME stTime);        // Called on note off event.
    void        QuickStopVoice(STIME stTime);   // Called to get quick release.
    void        SpeedRelease();             // Force an already off envelope to release quickly.
    void        ClearVoice();               // Release use of sample.
    PREL        GetNewPitch(STIME stTime);  // Return current pitch value
    void        GetNewVolume(STIME stTime, VREL& vrVolume, VREL &vrVolumeR);
                                            // Return current volume value
    DWORD       Mix(short *pBuffer,DWORD dwLength,STIME stStart,STIME stEnd);

private:
    CVoiceLFO       m_LFO;              // LFO.
    CVoiceEG        m_PitchEG;          // Pitch Envelope.
    CVoiceEG        m_VolumeEG;         // Volume Envelope.
    CDigitalAudio   m_DigitalAudio;     // The Digital Audio Engine structure.
    CPitchBendIn *  m_pPitchBendIn;     // Pitch bend source.
    CExpressionIn * m_pExpressionIn;    // Expression source.
    CVolumeIn *     m_pVolumeIn;        // Volume source, if allowed to vary
    CPanIn *        m_pPanIn;           // Pan source, if allowed to vary
    CSynth *        m_pSynth;           // To access sample rate, etc.
    STIME           m_stMixTime;        // Next time we need a mix.
    long            m_lDefaultPan;      // Default pan
    STIME           m_stLastMix;        // Last sample position mixed.

public:
    STIME           m_stStartTime;      // Time the sound starts.
    STIME           m_stStopTime;       // Time the sound stops.
    BOOL            m_fInUse;           // This is currently in use.
    BOOL            m_fNoteOn;          // Note is considered on.
    BOOL            m_fTag;             // Used to track note stealing.
    VREL            m_vrVolume;         // Volume, used for voice stealing...
    BOOL            m_fSustainOn;       // Sus pedal kept note on after off event.
    WORD            m_nPart;            // Part that is playing this (channel).
    WORD            m_nKey;             // Note played.
    BOOL            m_fAllowOverlap;    // Allow overlapped note.
    DWORD           m_dwGroup;          // Group this voice is playing now
    DWORD           m_dwProgram;        // Bank and Patch choice.
    DWORD           m_dwPriority;       // Priority.
    CControlLogic * m_pControl;         // Which control group is playing voice.
};


/*****************************************************************************
 * class CVoiceList
 *****************************************************************************
 * Implements a list of CVoice objects.
 */
class CVoiceList : public CList
{
public:
    CVoice *     GetHead()            {return (CVoice *) CList::GetHead();};
    CVoice *     RemoveHead()         {return (CVoice *) CList::RemoveHead();};
    CVoice *     GetItem(LONG lIndex) {return (CVoice *) CList::GetItem(lIndex);};
};

/*****************************************************************************
 * struct PerfStats
 *****************************************************************************
 * Contains statistics on the synthesizer, updated continuously.
 */
typedef struct PerfStats
{
    DWORD dwTotalTime;
    DWORD dwTotalSamples;
    DWORD dwNotesLost;
    DWORD dwVoices;
    DWORD dwCPU;
    DWORD dwMaxAmplitude;
} PerfStats;

#define MIX_BUFFER_LEN      500     // Set the sample buffer size to 500 mils
#define MAX_NUM_VOICES      32
#define NUM_EXTRA_VOICES    8       // Extra voices for when we overload.


/*****************************************************************************
 * class CControlLogic
 *****************************************************************************
 * CControlLogic object, implementing the control logic for the DLS
 * instrument.  This handles MIDI events, plus selection of instrument, sample
 * and articulation.
 *
 *
 * Essentially, ControlLogic is the big Kahuna that manages
 * the whole system. It parses incoming MIDI events
 * by channel and event type. And, it manages the mixing
 * of voices into the buffer.
 *
 * MIDI Input:
 *
 * The most important events are the note on and
 * off events. When a note on event comes in,
 * ControlLogic searches for an available voice.
 * ControlLogic matches the channel and finds the
 * instrument on that channel. It then call the instrument's
 * ScanForRegion() command which finds the region
 * that matches the note. At this point, it can copy
 * the region and associated articulation into the
 * voice, using the StartVoice command.
 *
 * When it receives the sustain pedal command,
 * it artificially sets all notes on the channel on
 * until a sustain off arrives. To keep track of notes
 * that have been shut off while the sustain was on
 * it uses an array of 128 shorts, with each bit position
 * representing a channel. When the sustain releases,
 * it scans through the array and creates a note off for
 * each bit that was set.
 *
 * Additional continuous controller events are managed
 * by the CModWheelIn, CPitchBendIn, etc., MIDI input recording
 * modules.
 *
 * Mixing:
 *
 * Control Logic is also called to mix the instruments into a buffer
 * at regular intervals. The buffer is provided by the calling sound
 * driver. Each voice is called to mix its sample into the buffer.
 */
class CControlLogic
{
public:
                    CControlLogic();
                    ~CControlLogic();
    HRESULT         Init(CInstManager *pInstruments, CSynth *pSynth);
    void            Flush(STIME stTime); // Clears all events after time.
    BOOL            RecordMIDI(STIME stTime,BYTE bStatus, BYTE bData1, BYTE bData2);
    HRESULT         RecordSysEx(DWORD dwSysExLength,BYTE *pSysExData, STIME stTime);
    void            QueueNotes(STIME stEndTime);
    void            ClearMIDI(STIME stEndTime);
    void            SetGainAdjust(VREL vrGainAdjust);
    HRESULT         SetChannelPriority(DWORD dwChannel,DWORD dwPriority);
    HRESULT         GetChannelPriority(DWORD dwChannel,LPDWORD pdwPriority);

    CSynth *        m_pSynth;

private:
    void            GMReset();

    CInstManager *  m_pInstruments;
    CNoteIn         m_Notes;              // All Note ons and offs.
    CModWheelIn     m_ModWheel[16];       // Sixteen channels of Mod Wheel.
    CPitchBendIn    m_PitchBend[16];      // Sixteen channels of Pitch Bend.
    CVolumeIn       m_Volume[16];         // Sixteen channels of Volume.
    CExpressionIn   m_Expression[16];     // Sixteen channels of Expression.
    CPanIn          m_Pan[16];            // Sixteen channels of Pan.
    BOOL            m_fSustain[16];       // Sustain on / off.
    short           m_nCurrentRPN[16];    // RPN number.
    BYTE            m_bBankH[16];         // Bank selects for instrument.
    BYTE            m_bBankL[16];
    DWORD           m_dwProgram[16];      // Instrument choice.
    BOOL            m_fEmpty;             // Indicates empty lists, no need to flush.
    VREL            m_vrGainAdjust;       // Final stage gain adjust
    DWORD           m_dwPriority[16];     // Priorities for each channel.

    BOOL            m_fXGActive;          // Is XG Active?
    BOOL            m_fGSActive;          // Is GS enabled?
    WORD            m_nData[16];          // Used to track RPN reading.
    VREL            m_vrMasterVolume;     // Master Volume.
    PREL            m_prFineTune[16];     // Fine tune for each channel.
    PREL            m_prScaleTune[16][12];// Alternate scale for each channel.
    PREL            m_prCoarseTune[16];   // Coarse tune.
    BYTE            m_bPartToChannel[16]; // Channel to Part converter.
    BYTE            m_bDrums[16];         // Melodic or which drum?
    BOOL            m_fMono[16];          // Mono mode?

public:
    CRITICAL_SECTION m_CriticalSection;   // Critical section to manage access.
    BOOL            m_fCSInitialized;
};

#endif // __SYNTH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\syslink.cpp ===
//
// syslink.cpp
//
/*
  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
*/

#include "common.h"
#include "private.h"

#define STR_MODULENAME "DDKSynth.sys:SysLink: "

/*****************************************************************************
 *****************************************************************************
 * CDmSynthStream-- ISynthSinkDMus implementation
 *****************************************************************************
 ****************************************************************************/


#pragma code_seg()
/*****************************************************************************
 * CDmSynthStream::Render()
 *****************************************************************************
 * Render is called from the port driver, to fill the given buffer.  This is 
 * in turn forwarded to the synth (which -- roughly -- goes to the different 
 * voices, which goes to the DigitalAudios, which goes to the mix functions).
 *
 * Typically, a synthesizer manages converting messages into
 * rendered wave data in two processes. First, it time stamps the MIDI 
 * messages it receives from the application via calls to 
 * PlayBuffer and places them in its own internal queue. 
 * 
 * Then, in response to Render, it generates audio by pulling MIDI 
 * messages from the queue and synthesizing the appropriate tones within
 * the time span of the requested render buffer.
 * 
 * As the synthesizer renders the MIDI messages into the buffer, it
 * calls RefTimeToSample to translate the MIDI time stamps into sample 
 * positions. This guarantees extremely accurate timing.
 */
void CDmSynthStream::Render(
                            IN  PBYTE       pBuffer,
                            IN  DWORD       dwLength,
                            IN  LONGLONG    llPosition)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::Render"));
    ASSERT(pBuffer);

    m_pSynth->Mix((short*)pBuffer, dwLength, llPosition);

    m_llLastPosition = llPosition + dwLength;
}


/*****************************************************************************
 * CDmSynthStream::SyncToMaster()
 *****************************************************************************
 * Sync this stream to the master clock, using the given slave time, and
 * whether we are starting now.
 */
STDMETHODIMP 
CDmSynthStream::SyncToMaster(IN REFERENCE_TIME  rtSlaveTime,
                             IN BOOL            fStart)
{
    PAGED_CODE();

	_DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::SyncToMaster"));

    REFERENCE_TIME rtMasterTime;
	m_pMasterClock->GetTime(&rtMasterTime);

    if (!fStart)
    {
        m_SampleClock.SyncToMaster(rtSlaveTime, rtMasterTime);
    }
    else
    {
        m_llStartPosition = ((rtSlaveTime / 1000) * m_PortParams.SampleRate) / 10000;

        m_SampleClock.Start(m_pMasterClock, m_PortParams.SampleRate, m_llStartPosition);
    }


    return S_OK;
}

/*****************************************************************************
 * CDmSynthStream::SampleToRefTime()
 *****************************************************************************
 * Translate between sample time and reference clock time.
 */
STDMETHODIMP
CDmSynthStream::SampleToRefTime(IN  LONGLONG         llSampleTime,
                                OUT REFERENCE_TIME * prtTime)
{
	_DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::SampleToRefTime"));
    ASSERT(prtTime);

    m_SampleClock.SampleToRefTime(llSampleTime + m_llStartPosition, prtTime);

    return S_OK;
}


/*****************************************************************************
 * CDmSynthStream::RefTimeToSample()
 *****************************************************************************
 * Translate between sample time and reference clock time.
 */
STDMETHODIMP
CDmSynthStream::RefTimeToSample(IN  REFERENCE_TIME  rtTime,
                                OUT LONGLONG *      pllSampleTime)
{
	_DbgPrintF(DEBUGLVL_BLAB, ("CDmSynthStream::RefTimeToSample"));
    ASSERT(pllSampleTime);

    *pllSampleTime = m_SampleClock.RefTimeToSample(rtTime) - m_llStartPosition;
  
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\ddksynth\voice.cpp ===
//  Voice.cpp
//  Copyright (c) 1996-2000 Microsoft Corporation.  All Rights Reserved.
//

#include "common.h"
#include <math.h>
#include "muldiv32.h"

#define STR_MODULENAME "DDKSynth.sys:Voice: "

#ifdef _X86_
#define MMX_ENABLED 1
#endif

#pragma code_seg()
/*****************************************************************************
 * CVoiceLFO::CVoiceLFO()
 *****************************************************************************
 * Constructor for the low-frequency oscillator object.
 */
CVoiceLFO::CVoiceLFO()
{
    m_pModWheelIn = NULL;
}

/*****************************************************************************
 * snSineTable[]
 *****************************************************************************
 * Table of 16-bit integers, representing a sine wave.
 * value = sin((index*6.283185307)/256) * 100 where index = 0..255
 */
const CHAR snSineTable[] = {
//  0       1       2       3       4       5       6       7
    0,      2,      4,      7,      9,      12,     14,     17,
    19,     21,     24,     26,     29,     31,     33,     35,
    38,     40,     42,     44,     47,     49,     51,     53,
    55,     57,     59,     61,     63,     65,     67,     68,
    70,     72,     74,     75,     77,     78,     80,     81,
    83,     84,     85,     87,     88,     89,     90,     91,
    92,     93,     94,     94,     95,     96,     97,     97,
    98,     98,     98,     99,     99,     99,     99,     99,
    100,    99,     99,     99,     99,     99,     98,     98,
    98,     97,     97,     96,     95,     94,     94,     93,
    92,     91,     90,     89,     88,     87,     85,     84,
    83,     81,     80,     78,     77,     75,     74,     72,
    70,     68,     67,     65,     63,     61,     59,     57,
    55,     53,     51,     49,     47,     44,     42,     40,
    38,     35,     33,     31,     29,     26,     24,     21,
    19,     17,     14,     12,     9,      7,      4,      2,
    0,      -2,     -4,     -7,     -9,     -12,    -14,    -17,
    -19,    -21,    -24,    -26,    -29,    -31,    -33,    -35,
    -38,    -40,    -42,    -44,    -47,    -49,    -51,    -53,
    -55,    -57,    -59,    -61,    -63,    -65,    -67,    -68,
    -70,    -72,    -74,    -75,    -77,    -78,    -80,    -81,
    -83,    -84,    -85,    -87,    -88,    -89,    -90,    -91,
    -92,    -93,    -94,    -94,    -95,    -96,    -97,    -97,
    -98,    -98,    -98,    -99,    -99,    -99,    -99,    -99,
    -100,   -99,    -99,    -99,    -99,    -99,    -98,    -98,
    -98,    -97,    -97,    -96,    -95,    -94,    -94,    -93,
    -92,    -91,    -90,    -89,    -88,    -87,    -85,    -84,
    -83,    -81,    -80,    -78,    -77,    -75,    -74,    -72,
    -70,    -68,    -67,    -65,    -63,    -61,    -59,    -57,
    -55,    -53,    -51,    -49,    -47,    -44,    -42,    -40,
    -38,    -35,    -33,    -31,    -29,    -26,    -24,    -21,
    -19,    -17,    -14,    -12,    -9,     -7,     -4,     -2
};

/*****************************************************************************
 * CVoiceLFO::StartVoice()
 *****************************************************************************
 * Start a voice with this LFO.  Attach the given ModWheel receptor.
 */
STIME CVoiceLFO::StartVoice(CSourceLFO *pSource,STIME stStartTime,
                            CModWheelIn * pModWheelIn)
{
    m_pModWheelIn = pModWheelIn;
    m_Source = *pSource;
    m_stStartTime = stStartTime;
    if ((m_Source.m_prMWPitchScale == 0) && (m_Source.m_vrMWVolumeScale == 0) &&
        (m_Source.m_prPitchScale == 0) && (m_Source.m_vrVolumeScale == 0))
    {
        m_stRepeatTime = 44100;
    }
    else
    {
        m_stRepeatTime = 2097152 / m_Source.m_pfFrequency; // (1/8 * 256 * 4096 * 16)
    }
    return (m_stRepeatTime);
}

/*****************************************************************************
 * CVoiceLFO::GetLevel()
 *****************************************************************************
 * Return the value of the LFO right now.
 */
long CVoiceLFO::GetLevel(STIME stTime, STIME *pstNextTime)
{
    stTime -= (m_stStartTime + m_Source.m_stDelay);
    if (stTime < 0) 
    {
        *pstNextTime = -stTime;
        return (0);
    }
    *pstNextTime = m_stRepeatTime;
    stTime *= m_Source.m_pfFrequency;
    stTime = stTime >> (12 + 4); // We've added 4 extra bits of resolution...
    return (::snSineTable[stTime & 0xFF]);
}

/*****************************************************************************
 * CVoiceLFO::GetVolume()
 *****************************************************************************
 * Get the composite volume of the LFO.
 */
VREL CVoiceLFO::GetVolume(STIME stTime, STIME *pstNextTime)
{
    VREL vrVolume = m_pModWheelIn->GetModulation(stTime);
    vrVolume *= m_Source.m_vrMWVolumeScale;
    vrVolume /= 127;
    vrVolume += m_Source.m_vrVolumeScale;
    vrVolume *= GetLevel(stTime,pstNextTime);
    vrVolume /= 100;
    return (vrVolume);
}

/*****************************************************************************
 * CVoiceLFO::GetPitch()
 *****************************************************************************
 * Get the composite pitch of the LFO.
 */
PREL CVoiceLFO::GetPitch(STIME stTime, STIME *pstNextTime)
{
    PREL prPitch = m_pModWheelIn->GetModulation(stTime);
    prPitch *= m_Source.m_prMWPitchScale;
    prPitch /= 127;
    prPitch += m_Source.m_prPitchScale;
    prPitch *= GetLevel(stTime,pstNextTime);
    prPitch /= 100;
    return (prPitch);
}

/*****************************************************************************
 * CVoiceEG::CVoiceEG()
 *****************************************************************************
 * Constructor for the CVoiceEG object.
 */
CVoiceEG::CVoiceEG()
{
    m_stStopTime = 0;
}

/*****************************************************************************
 * snAttackTable[]
 *****************************************************************************
 * Table of 16-bit integers, representing a log attack curve.
 * value = (log10((index/200)^2)) * 10000 / 96 + 1000 where index = 0..199
 */
const short snAttackTable[] = {
//  0       1       2       3       4       5       6       7
    0,      520,    583,    620,    646,    666,    682,    696,
    708,    719,    728,    737,    745,    752,    759,    765,
    771,    776,    782,    787,    791,    796,    800,    804,
    808,    811,    815,    818,    822,    825,    828,    831,
    834,    836,    839,    842,    844,    847,    849,    852,
    854,    856,    858,    860,    863,    865,    867,    868,
    870,    872,    874,    876,    878,    879,    881,    883,
    884,    886,    887,    889,    891,    892,    894,    895,
    896,    898,    899,    901,    902,    903,    905,    906,
    907,    908,    910,    911,    912,    913,    914,    915,
    917,    918,    919,    920,    921,    922,    923,    924,
    925,    926,    927,    928,    929,    930,    931,    932,
    933,    934,    935,    936,    937,    938,    939,    939,
    940,    941,    942,    943,    944,    945,    945,    946,
    947,    948,    949,    949,    950,    951,    952,    953,
    953,    954,    955,    956,    956,    957,    958,    958,
    959,    960,    961,    961,    962,    963,    963,    964,
    965,    965,    966,    967,    967,    968,    969,    969,
    970,    970,    971,    972,    972,    973,    973,    974,
    975,    975,    976,    976,    977,    978,    978,    979,
    979,    980,    980,    981,    982,    982,    983,    983,
    984,    984,    985,    985,    986,    986,    987,    987,
    988,    988,    989,    989,    990,    990,    991,    991,
    992,    992,    993,    993,    994,    994,    995,    995,
    996,    996,    997,    997,    998,    998,    999,    999,
    1000
};

/*****************************************************************************
 * CVoiceEG::StopVoice()
 *****************************************************************************
 * Stop the envelope generator.  Use a heuristic to hasten the cutoff, 
 * depending on the current level.
 */
void CVoiceEG::StopVoice(STIME stTime)
{
    m_Source.m_stRelease *= GetLevel(stTime,&m_stStopTime,TRUE);    // Adjust for current sustain level.
    m_Source.m_stRelease /= 1000;
    m_stStopTime = stTime;
}

/*****************************************************************************
 * CVoiceEG::QuickStopVoice()
 *****************************************************************************
 * Stop the envelope generator ASAP.
 */
void CVoiceEG::QuickStopVoice(STIME stTime, DWORD dwSampleRate)
{
    m_Source.m_stRelease *= GetLevel(stTime,&m_stStopTime,TRUE);    // Adjust for current sustain level.
    m_Source.m_stRelease /= 1000;
    dwSampleRate /= 70;
    if (m_Source.m_stRelease > (long) dwSampleRate)
    {
        m_Source.m_stRelease = dwSampleRate;
    }
    m_stStopTime = stTime;
}

/*****************************************************************************
 * CVoiceEG::StartVoice()
 *****************************************************************************
 * Start the voice with the given envelope generator and parameters.
 */
STIME CVoiceEG::StartVoice(CSourceEG *pSource, STIME stStartTime, 
                           WORD nKey, WORD nVelocity)
{
    m_stStartTime = stStartTime;
    m_stStopTime = 0x7fffffffffffffff;      // set to indefinite future
    m_Source = *pSource;

    // apply velocity to attack length scaling here
    m_Source.m_stAttack *= CDigitalAudio::PRELToPFRACT(nVelocity * m_Source.m_trVelAttackScale / 127);
    m_Source.m_stAttack /= 4096;

    m_Source.m_stDecay *= CDigitalAudio::PRELToPFRACT(nKey * m_Source.m_trKeyDecayScale / 127);
    m_Source.m_stDecay /= 4096;

    m_Source.m_stDecay *= (1000 - m_Source.m_pcSustain);
    m_Source.m_stDecay /= 1000;
    return ((STIME)m_Source.m_stAttack);
}

/*****************************************************************************
 * CVoiceEG::InAttack()
 *****************************************************************************
 * Are we in the attack phase still?
 */
BOOL CVoiceEG::InAttack(STIME st)
{
    // has note been released?
    if (st >= m_stStopTime)
        return FALSE;

    // past length of attack?
    if (st >= m_stStartTime + m_Source.m_stAttack)
        return FALSE;

    return TRUE;
}
    
/*****************************************************************************
 * CVoiceEG::InRelease()
 *****************************************************************************
 * Are we in the release phase yet?
 */
BOOL CVoiceEG::InRelease(STIME st)
{
    // has note been released?
    if (st > m_stStopTime)
        return TRUE;

    return FALSE;
}
    
/*****************************************************************************
 * CVoiceEG::GetLevel()
 *****************************************************************************
 * Get the envelope generator's current level, from 0 to 1000.
 */
long CVoiceEG::GetLevel(STIME stEnd, STIME *pstNext, BOOL fVolume)
{
    long lLevel = 0;
    if (stEnd <= m_stStopTime)
    {
        stEnd -= m_stStartTime;
        // note not released yet.
        if (stEnd < m_Source.m_stAttack)
        {
            // still in attack
            lLevel = 1000 * (long) stEnd;
            if (m_Source.m_stAttack)
            {
                lLevel /= (long) m_Source.m_stAttack;
            }
            else // This should never happen, but it does...
            {
                lLevel = 0;
            }
            *pstNext = m_Source.m_stAttack - stEnd;
            if (lLevel < 0) lLevel = 0;
            if (lLevel > 1000) lLevel = 1000;
            if (fVolume)
            {
                lLevel = ::snAttackTable[lLevel / 5];
            }
        }
        else 
        {
            stEnd -= m_Source.m_stAttack;
            
            if (stEnd < m_Source.m_stDecay)
            {
                // still in decay
                lLevel = (1000 - m_Source.m_pcSustain) * (long) stEnd;
                lLevel /= (long) m_Source.m_stDecay;
                lLevel = 1000 - lLevel;
// To improve the decay curve, set the next point to be 1/4, 1/2, or end of slope. 
// To avoid close duplicates, fudge an extra 100 samples.
                if (stEnd < ((m_Source.m_stDecay >> 2) - 100))
                {
                    *pstNext = (m_Source.m_stDecay >> 2) - stEnd;
                }   
                else if (stEnd < ((m_Source.m_stDecay >> 1) - 100))
                {
                    *pstNext = (m_Source.m_stDecay >> 1) - stEnd;
                }
                else
                {
                    *pstNext = m_Source.m_stDecay - stEnd;  // Next is end of decay.
                }
            }
            else
            {
                // in sustain
                lLevel = m_Source.m_pcSustain;
                *pstNext = 44100;
            }
        }
    }
    else
    {
        STIME stBogus;
        // in release
        stEnd -= m_stStopTime;

        if (stEnd < m_Source.m_stRelease)
        {
            lLevel = GetLevel(m_stStopTime,&stBogus,fVolume) * (long) (m_Source.m_stRelease - stEnd);
            lLevel /= (long) m_Source.m_stRelease;
            if (stEnd < ((m_Source.m_stRelease >> 2) - 100))
            {
                *pstNext = (m_Source.m_stRelease >> 2) - stEnd;
            }   
            else if (stEnd < ((m_Source.m_stRelease >> 1) - 100))
            {
                *pstNext = (m_Source.m_stRelease >> 1) - stEnd;
            }
            else
            {
                *pstNext = m_Source.m_stRelease - stEnd;  // Next is end of decay.
            }
        }
        else
        {
            lLevel = 0;   // !!! off
            *pstNext = 0x7FFFFFFFFFFFFFFF;
        }
    }

    return lLevel;
}

/*****************************************************************************
 * CVoiceEG::GetVolume()
 *****************************************************************************
 * Get the composite volume of the envelope generator in dB cents (1/100ths db).
 */
VREL CVoiceEG::GetVolume(STIME stTime, STIME *pstNextTime)
{
    VREL vrLevel = GetLevel(stTime, pstNextTime, TRUE) * 96;
    vrLevel /= 10;
    vrLevel = vrLevel - 9600;
    return vrLevel;
}

/*****************************************************************************
 * CVoiceEG::GetPitch()
 *****************************************************************************
 * Get the composite pitch of the envelope generator, in fractional scale units.
 */
PREL CVoiceEG::GetPitch(STIME stTime, STIME *pstNextTime)
{
    PREL prLevel;
    if (m_Source.m_sScale != 0)
    {
        prLevel = GetLevel(stTime, pstNextTime,FALSE);
        prLevel *= m_Source.m_sScale;
        prLevel /= 1000;
    }
    else
    {
        *pstNextTime = 44100;
        prLevel = 0;
    }
    return prLevel;
}

BOOL MultiMediaInstructionsSupported();

/*****************************************************************************
 * CDigitalAudio::CDigitalAudio()
 *****************************************************************************
 * Initialize the digital audio object.
 * This object manages the sample looping and playback and 
 * digitally controlled amplifier.
 */
CDigitalAudio::CDigitalAudio()
{
    m_pfBasePitch = 0;
    m_pfLastPitch = 0;
    m_pfLastSample = 0;
    m_pfLoopEnd = 0;
    m_pfLoopStart = 0;
    m_pfSampleLength = 0;
    m_prLastPitch = 0;
    m_vrLastLVolume = 0;
    m_vrLastRVolume = 0;
    m_vrBaseLVolume = 0;
    m_vrBaseRVolume = 0;
    m_vfLastLVolume = 0;
    m_vfLastRVolume = 0;
    m_ullLastSample = 0;
    m_ullLoopStart = 0;
    m_ullLoopEnd = 0;
    m_ullSampleLength = 0;
    m_fElGrande = FALSE;
#ifdef MMX_ENABLED
    m_fMMXEnabled = MultiMediaInstructionsSupported();
#endif // MMX_ENABLED
};

/*****************************************************************************
 * Other CDigitalAudio tables
 *****************************************************************************/
// Pitch increment lookup.
// value = ((index/1200)^2)*4096 where index = -100..100
const /*PFRACT*/SHORT pfCents[] = {
//  0       1       2       3       4       5       6       7
    3866,   3868,   3870,   3872,   3875,   3877,   3879,   3881,
    3884,   3886,   3888,   3890,   3893,   3895,   3897,   3899,
    3902,   3904,   3906,   3908,   3911,   3913,   3915,   3917,
    3920,   3922,   3924,   3926,   3929,   3931,   3933,   3935,
    3938,   3940,   3942,   3945,   3947,   3949,   3951,   3954,
    3956,   3958,   3961,   3963,   3965,   3967,   3970,   3972,
    3974,   3977,   3979,   3981,   3983,   3986,   3988,   3990,
    3993,   3995,   3997,   4000,   4002,   4004,   4007,   4009,
    4011,   4014,   4016,   4018,   4020,   4023,   4025,   4027,
    4030,   4032,   4034,   4037,   4039,   4041,   4044,   4046,
    4048,   4051,   4053,   4055,   4058,   4060,   4063,   4065,
    4067,   4070,   4072,   4074,   4077,   4079,   4081,   4084,
    4086,   4088,   4091,   4093,   4096,   4098,   4100,   4103,
    4105,   4107,   4110,   4112,   4114,   4117,   4119,   4122,
    4124,   4126,   4129,   4131,   4134,   4136,   4138,   4141,
    4143,   4145,   4148,   4150,   4153,   4155,   4157,   4160,
    4162,   4165,   4167,   4170,   4172,   4174,   4177,   4179,
    4182,   4184,   4186,   4189,   4191,   4194,   4196,   4199,
    4201,   4203,   4206,   4208,   4211,   4213,   4216,   4218,
    4220,   4223,   4225,   4228,   4230,   4233,   4235,   4237,
    4240,   4242,   4245,   4247,   4250,   4252,   4255,   4257,
    4260,   4262,   4265,   4267,   4269,   4272,   4274,   4277,
    4279,   4282,   4284,   4287,   4289,   4292,   4294,   4297,
    4299,   4302,   4304,   4307,   4309,   4312,   4314,   4317,
    4319,   4322,   4324,   4327,   4329,   4332,   4334,   4337,
    4339
};
// Four octaves up and down.
// value = ((index/12)^2)*4096 where index = -48..48
const PFRACT pfSemiTones[] = {
//  0       1       2       3       4       5       6       7
    256,    271,    287,    304,    322,    341,    362,    383,
    406,    430,    456,    483,    512,    542,    574,    608,
    645,    683,    724,    767,    812,    861,    912,    966,
    1024,   1084,   1149,   1217,   1290,   1366,   1448,   1534,
    1625,   1722,   1824,   1933,   2048,   2169,   2298,   2435,
    2580,   2733,   2896,   3068,   3250,   3444,   3649,   3866,
    4096,   4339,   4597,   4870,   5160,   5467,   5792,   6137,
    6501,   6888,   7298,   7732,   8192,   8679,   9195,   9741,
    10321,  10935,  11585,  12274,  13003,  13777,  14596,  15464,
    16384,  17358,  18390,  19483,  20642,  21870,  23170,  24548,
    26007,  27554,  29192,  30928,  32768,  34716,  36780,  38967,
    41285,  43740,  46340,  49096,  52015,  55108,  58385,  61857,
    65536
};
// dB conversion table.
// value = (((index / 100)^10)^.5)*4095 where index = MINDB*10..MAXDB*10
const /*VFRACT*/SHORT vfDbToVolume[] = {
//  0       1       2       3       4       5       6       7
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      0,      0,
    0,      0,      0,      0,      0,      0,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      1,      1,      1,      1,      1,      1,
    1,      1,      2,      2,      2,      2,      2,      2,
    2,      2,      2,      2,      2,      2,      2,      2,
    2,      2,      2,      2,      2,      2,      2,      2,
    2,      2,      2,      2,      2,      2,      2,      2,
    2,      2,      2,      2,      2,      3,      3,      3,
    3,      3,      3,      3,      3,      3,      3,      3,
    3,      3,      3,      3,      3,      3,      3,      3,
    3,      3,      3,      3,      3,      3,      4,      4,
    4,      4,      4,      4,      4,      4,      4,      4,
    4,      4,      4,      4,      4,      4,      4,      4,
    4,      4,      5,      5,      5,      5,      5,      5,
    5,      5,      5,      5,      5,      5,      5,      5,
    5,      5,      6,      6,      6,      6,      6,      6,
    6,      6,      6,      6,      6,      6,      6,      7,
    7,      7,      7,      7,      7,      7,      7,      7,
    7,      7,      7,      8,      8,      8,      8,      8,
    8,      8,      8,      8,      8,      9,      9,      9,
    9,      9,      9,      9,      9,      9,      10,     10,
    10,     10,     10,     10,     10,     10,     11,     11,
    11,     11,     11,     11,     11,     11,     12,     12,
    12,     12,     12,     12,     12,     13,     13,     13,
    13,     13,     13,     14,     14,     14,     14,     14,
    14,     15,     15,     15,     15,     15,     15,     16,
    16,     16,     16,     16,     17,     17,     17,     17,
    17,     18,     18,     18,     18,     18,     19,     19,
    19,     19,     20,     20,     20,     20,     21,     21,
    21,     21,     21,     22,     22,     22,     23,     23,
    23,     23,     24,     24,     24,     24,     25,     25,
    25,     26,     26,     26,     27,     27,     27,     28,
    28,     28,     28,     29,     29,     30,     30,     30,
    31,     31,     31,     32,     32,     32,     33,     33,
    34,     34,     34,     35,     35,     36,     36,     36,
    37,     37,     38,     38,     39,     39,     40,     40,
    40,     41,     41,     42,     42,     43,     43,     44,
    44,     45,     45,     46,     47,     47,     48,     48,
    49,     49,     50,     50,     51,     52,     52,     53,
    53,     54,     55,     55,     56,     57,     57,     58,
    59,     59,     60,     61,     61,     62,     63,     64,
    64,     65,     66,     67,     67,     68,     69,     70,
    71,     71,     72,     73,     74,     75,     76,     77,
    78,     78,     79,     80,     81,     82,     83,     84,
    85,     86,     87,     88,     89,     90,     91,     92,
    93,     94,     95,     97,     98,     99,     100,    101,
    102,    104,    105,    106,    107,    108,    110,    111,
    112,    114,    115,    116,    118,    119,    120,    122,
    123,    125,    126,    128,    129,    130,    132,    134,
    135,    137,    138,    140,    141,    143,    145,    146,
    148,    150,    152,    153,    155,    157,    159,    161,
    163,    164,    166,    168,    170,    172,    174,    176,
    178,    180,    182,    185,    187,    189,    191,    193,
    195,    198,    200,    202,    205,    207,    210,    212,
    214,    217,    219,    222,    225,    227,    230,    232,
    235,    238,    241,    243,    246,    249,    252,    255,
    258,    261,    264,    267,    270,    273,    276,    280,
    283,    286,    289,    293,    296,    300,    303,    307,
    310,    314,    317,    321,    325,    329,    332,    336,
    340,    344,    348,    352,    356,    360,    364,    369,
    373,    377,    382,    386,    391,    395,    400,    404,
    409,    414,    419,    423,    428,    433,    438,    443,
    449,    454,    459,    464,    470,    475,    481,    486,
    492,    498,    503,    509,    515,    521,    527,    533,
    539,    546,    552,    558,    565,    571,    578,    585,
    591,    598,    605,    612,    619,    626,    634,    641,
    649,    656,    664,    671,    679,    687,    695,    703,
    711,    719,    728,    736,    745,    753,    762,    771,
    780,    789,    798,    807,    817,    826,    836,    845,
    855,    865,    875,    885,    895,    906,    916,    927,
    938,    948,    959,    971,    982,    993,    1005,   1016,
    1028,   1040,   1052,   1064,   1077,   1089,   1102,   1114,
    1127,   1140,   1154,   1167,   1181,   1194,   1208,   1222,
    1236,   1250,   1265,   1280,   1294,   1309,   1325,   1340,
    1355,   1371,   1387,   1403,   1419,   1436,   1452,   1469,
    1486,   1504,   1521,   1539,   1556,   1574,   1593,   1611,
    1630,   1649,   1668,   1687,   1707,   1726,   1746,   1767,
    1787,   1808,   1829,   1850,   1871,   1893,   1915,   1937,
    1959,   1982,   2005,   2028,   2052,   2076,   2100,   2124,
    2149,   2173,   2199,   2224,   2250,   2276,   2302,   2329,
    2356,   2383,   2411,   2439,   2467,   2496,   2524,   2554,
    2583,   2613,   2643,   2674,   2705,   2736,   2768,   2800,
    2833,   2865,   2899,   2932,   2966,   3000,   3035,   3070,
    3106,   3142,   3178,   3215,   3252,   3290,   3328,   3367,
    3406,   3445,   3485,   3525,   3566,   3607,   3649,   3691,
    3734,   3777,   3821,   3865,   3910,   3955,   4001,   4048,
    4095
};

/*****************************************************************************
 * CDigitalAudio::VRELToVFRACT()
 *****************************************************************************
 * Translate between VREL and VFRACT, clamping if necessary.
 */
VFRACT CDigitalAudio::VRELToVFRACT(VREL vrVolume)
{
    vrVolume /= 10;
    if (vrVolume < MINDB * 10) vrVolume = MINDB * 10;
    else if (vrVolume >= MAXDB * 10) vrVolume = MAXDB * 10;
    return (::vfDbToVolume[vrVolume - MINDB * 10]);
}

/*****************************************************************************
 * CDigitalAudio::PRELToPFRACT()
 *****************************************************************************
 * Translates from PREL to PFRACT, clamping if necessary.
 */
PFRACT CDigitalAudio::PRELToPFRACT(PREL prPitch)
{
    PFRACT pfPitch = 0;
    PREL prOctave;
    if (prPitch > 100)
    {
        if (prPitch > 4800)
        {
            prPitch = 4800;
        }
        prOctave = prPitch / 100;
        prPitch = prPitch % 100;
        pfPitch = ::pfCents[prPitch + 100];
        pfPitch <<= prOctave / 12;
        prOctave = prOctave % 12;
        pfPitch *= ::pfSemiTones[prOctave + 48];
        pfPitch >>= 12;
    }
    else if (prPitch < -100)
    {
        if (prPitch < -4800)
        {
            prPitch = -4800;
        }
        prOctave = prPitch / 100;
        prPitch = (-prPitch) % 100;
        pfPitch = ::pfCents[100 - prPitch];
        pfPitch >>= ((-prOctave) / 12);
        prOctave = (-prOctave) % 12;
        pfPitch *= ::pfSemiTones[48 - prOctave];
        pfPitch >>= 12;
    }
    else
    {
        pfPitch = ::pfCents[prPitch + 100];
    }
    return (pfPitch);
}

/*****************************************************************************
 * CDigitalAudio::ClearVoice()
 *****************************************************************************
 * Clear this voice in the Digital Audio Engine.  The wave object can go away now.
 */
void CDigitalAudio::ClearVoice()
{
    if (m_Source.m_pWave != NULL)
    {
        m_Source.m_pWave->PlayOff();
        m_Source.m_pWave->Release();    // Releases wave structure.
        m_Source.m_pWave = NULL;
    }
}

/*****************************************************************************
 * CDigitalAudio::StartVoice()
 *****************************************************************************
 * Start a voice on the given synth and sample.
 */
STIME CDigitalAudio::StartVoice(CSynth *pSynth,    CSourceSample *pSample, 
                               VREL vrBaseLVolume, VREL vrBaseRVolume,
                               PREL prBasePitch,   long lKey)
{
    m_vrBaseLVolume = vrBaseLVolume;
    m_vrBaseRVolume = vrBaseRVolume;
    m_vfLastLVolume = VRELToVFRACT(MIN_VOLUME); 
    m_vfLastRVolume = VRELToVFRACT(MIN_VOLUME);
    m_vrLastLVolume = 0;
    m_vrLastRVolume = 0;
    m_prLastPitch = 0;
    m_Source = *pSample;
    m_pnWave = pSample->m_pWave->m_pnWave;
    m_pSynth = pSynth;
    pSample->m_pWave->AddRef(); // Keeps track of Wave usage.
    pSample->m_pWave->PlayOn();
    prBasePitch += pSample->m_prFineTune;
    prBasePitch += ((lKey - pSample->m_bMIDIRootKey) * 100);
    m_pfBasePitch = PRELToPFRACT(prBasePitch);
    m_pfBasePitch *= pSample->m_dwSampleRate;
    m_pfBasePitch /= pSynth->m_dwSampleRate;
    m_pfLastPitch = m_pfBasePitch;
    
    m_fElGrande = pSample->m_dwSampleLength >= 0x80000;     // Greater than 512k.
    if ((pSample->m_dwLoopEnd - pSample->m_dwLoopStart) >= 0x80000)
    {   // We can't handle loops greater than 1 meg!
        m_Source.m_bOneShot = TRUE;
    }
    m_ullLastSample = 0;
    m_ullLoopStart = pSample->m_dwLoopStart;
    m_ullLoopStart = m_ullLoopStart << 12;
    m_ullLoopEnd = pSample->m_dwLoopEnd;
    m_ullLoopEnd = m_ullLoopEnd << 12;
    m_ullSampleLength = pSample->m_dwSampleLength;
    m_ullSampleLength = m_ullSampleLength << 12;
    m_pfLastSample = 0;
    m_pfLoopStart = (long) m_ullLoopStart;
    m_pfLoopEnd = (long) m_ullLoopEnd;
    if (m_pfLoopEnd <= m_pfLoopStart) // Should never happen, but death if it does!
    {
        m_Source.m_bOneShot = TRUE;
    }
    if (m_fElGrande)
    {
        m_pfSampleLength = 0x7FFFFFFF;
    }
    else
    {
        m_pfSampleLength = (long) m_ullSampleLength;
    }
    return (0); // !!! what is this return value?
}

/*  If the wave is bigger than one meg, the index can overflow. 
    Solve this by assuming no mix session will ever be as great
    as one meg AND loops are never that long. We keep all our
    fractional indexes in two variables. In one case, m_pfLastSample,
    is the normal mode where the lower 12 bits are the fraction and 
    the upper 20 bits are the index. And, m_ullLastSample
    is a LONGLONG with an extra 32 bits of index. The mix engine
    does not want the LONGLONGs, so we need to track the variables
    in the LONGLONGs and prepare them for the mixer as follows:
    Prior to mixing,
    if the sample is large (m_fElGrande is set), BeforeSampleMix()
    is called. This finds the starting point for the mix, which 
    is either the current position or the start of the loop, 
    whichever is earlier. It subtracts this starting point from
    the LONGLONG variables and stores an offset in m_dwAddressUpper.
    It also adjusts the pointer to the wave data appropriately.
    AfterSampleMix() does the inverse, reconstructing the the LONGLONG
    indeces and returning everthing back to normal.
*/

/*****************************************************************************
 * CDigitalAudio::BeforeBigSampleMix()
 *****************************************************************************
 * Setup before doing a large sample mix/loop.
 */
void CDigitalAudio::BeforeBigSampleMix()
{
    if (m_fElGrande)
    {
        ULONGLONG ullBase = 0;
        DWORD dwBase;
        if (m_Source.m_bOneShot)
        {
            ullBase = m_ullLastSample;
        }
        else
        {
            if (m_ullLastSample < m_ullLoopStart)
            {
                ullBase = m_ullLastSample;
            }
            else
            { 
                ullBase = m_ullLoopStart;
            }
        }
        ullBase >>= 12;
        dwBase = (DWORD) ullBase & 0xFFFFFFFE;      // Clear bottom bit so 8 bit pointer aligns with short.
        ullBase = dwBase;
        ullBase <<= 12;
        m_dwAddressUpper = dwBase;
        m_pfLastSample = (long) (m_ullLastSample - ullBase);
        if ((m_ullLoopEnd - ullBase) < 0x7FFFFFFF)
        {
            m_pfLoopStart = (long) (m_ullLoopStart - ullBase);
            m_pfLoopEnd = (long) (m_ullLoopEnd - ullBase);
        }
        else
        {
            m_pfLoopStart = 0;
            m_pfLoopEnd = 0x7FFFFFFF;
        }
        ullBase = m_ullSampleLength - ullBase;
        if (ullBase > 0x7FFFFFFF)
        {
            m_pfSampleLength = 0x7FFFFFFF;
        }
        else
        {
            m_pfSampleLength = (long) ullBase;
        }
        if (m_Source.m_bSampleType & SFORMAT_8)
        {
            dwBase >>= 1;
        }
        m_pnWave = &m_Source.m_pWave->m_pnWave[dwBase];
    }
}

/*****************************************************************************
 * CDigitalAudio::AfterBigSampleMix()
 *****************************************************************************
 * Cleanup after doing a large sample mix/loop.
 */
void CDigitalAudio::AfterBigSampleMix()
{
    m_pnWave = m_Source.m_pWave->m_pnWave;
    if (m_fElGrande)
    {
        ULONGLONG ullBase = m_dwAddressUpper;
        m_ullLastSample = m_pfLastSample;
        m_ullLastSample += (ullBase << 12);
        m_dwAddressUpper = 0;
    }
}

/*****************************************************************************
 * CDigitalAudio::Mix()
 *****************************************************************************
 * Do a mix on this buffer.  This handles loops and calling the different mix 
 * functions (depending on format).
 */
BOOL CDigitalAudio::Mix(short *pBuffer, DWORD dwLength, // length in SAMPLES
                        VREL  vrVolumeL,VREL  vrVolumeR,
                        PREL  prPitch,  DWORD dwStereo)
{
    PFRACT pfDeltaPitch;
    PFRACT pfEnd;
    PFRACT pfLoopLen;
    PFRACT pfNewPitch;
    VFRACT vfNewLVolume;
    VFRACT vfNewRVolume;
    VFRACT vfDeltaLVolume;
    VFRACT vfDeltaRVolume;
    DWORD dwPeriod = 64;
    DWORD dwSoFar;
    DWORD dwStart; // position in WORDs
    DWORD dwMixChoice = dwStereo ? SPLAY_STEREO : 0;
    if (dwLength == 0)      // Attack was instant. 
    {
        m_pfLastPitch = (m_pfBasePitch * PRELToPFRACT(prPitch)) >> 12;
        m_vfLastLVolume = VRELToVFRACT(m_vrBaseLVolume + vrVolumeL);
        m_vfLastRVolume = VRELToVFRACT(m_vrBaseRVolume + vrVolumeR);
        m_prLastPitch = prPitch;
        m_vrLastLVolume = vrVolumeL;
        m_vrLastRVolume = vrVolumeR;
        return (TRUE);
    }
    if ((m_Source.m_pWave == NULL) || (m_Source.m_pWave->m_pnWave == NULL))
    {
        return FALSE;
    }
    DWORD dwMax = abs(vrVolumeL - m_vrLastLVolume);
    m_vrLastLVolume = vrVolumeL;
    dwMax = max((long)dwMax,abs(vrVolumeR - m_vrLastRVolume));
    m_vrLastRVolume = vrVolumeR;
    dwMax = max((long)dwMax,abs(prPitch - m_prLastPitch) << 1);
    dwMax >>= 1;
    m_prLastPitch = prPitch;
    if (dwMax > 0)
    {
        dwPeriod = (dwLength << 3) / dwMax;
        if (dwPeriod > 512)
        {
            dwPeriod = 512;
        }
        else if (dwPeriod < 1)
        {
            dwPeriod = 1;
        }
    }
    else
    {
        dwPeriod = 512;     // Make it happen anyway.
    }

    // This makes MMX sound a little better (MMX bug will be fixed)
    dwPeriod += 3;
    dwPeriod &= 0xFFFFFFFC;

    pfNewPitch = m_pfBasePitch * PRELToPFRACT(prPitch);
    pfNewPitch >>= 12;

    pfDeltaPitch = MulDiv(pfNewPitch - m_pfLastPitch,dwPeriod << 8,dwLength);
    vfNewLVolume = VRELToVFRACT(m_vrBaseLVolume + vrVolumeL);
    vfNewRVolume = VRELToVFRACT(m_vrBaseRVolume + vrVolumeR);
    vfDeltaLVolume = MulDiv(vfNewLVolume - m_vfLastLVolume,dwPeriod << 8,dwLength);
    vfDeltaRVolume = MulDiv(vfNewRVolume - m_vfLastRVolume,dwPeriod << 8,dwLength);

    if (m_fMMXEnabled && (dwLength > 8))
    {
       dwMixChoice |= SPLAY_MMX; 
    }
    dwMixChoice |= m_Source.m_bSampleType;
    dwStart = 0;

    for (;;)
    {
        if (dwLength <= 8)
        {
            dwMixChoice &= ~SPLAY_MMX;
        }
        if (m_fElGrande)
        {
            BeforeBigSampleMix();
        }
        if (m_Source.m_bOneShot)
        {
            pfEnd = m_pfSampleLength;
            pfLoopLen = 0;
        }
        else
        {
            pfEnd = m_pfLoopEnd;
            pfLoopLen = m_pfLoopEnd - m_pfLoopStart;
            if (pfLoopLen <= pfNewPitch)
            {
                return FALSE;
            }
        }
        switch (dwMixChoice)
        {
        case SFORMAT_8 | SPLAY_STEREO : 
            dwSoFar = Mix8(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_8 : 
            dwSoFar = MixMono8(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_16 | SPLAY_STEREO : 
            dwSoFar = Mix16(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
            break;
        case SFORMAT_16 :
            dwSoFar = MixMono16(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
            break;
#ifdef MMX_ENABLED
        case SFORMAT_8 | SPLAY_MMX | SPLAY_STEREO : 
            dwSoFar = Mix8X(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume ,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
        
            break;
        case SFORMAT_16 | SPLAY_MMX | SPLAY_STEREO : 
            dwSoFar = Mix16X(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, vfDeltaRVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
            break; 
        case SFORMAT_8 | SPLAY_MMX : 
            dwSoFar = MixMono8X(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume,
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
        
            break;
        case SFORMAT_16 | SPLAY_MMX : 
            dwSoFar = MixMono16X(&pBuffer[dwStart],dwLength,dwPeriod,
                vfDeltaLVolume, 
                pfDeltaPitch, 
                pfEnd, pfLoopLen);
            break; 
#endif
        default :
            return (FALSE);
        }
        if (m_fElGrande)
        {
            AfterBigSampleMix();
        }
        if (m_Source.m_bOneShot)
        {
            if (dwSoFar < dwLength) 
            {
                return (FALSE);
            }
            break;
        }
        else
        {
            if (dwSoFar >= dwLength) break;

        // !!! even though we often handle loops in the mix function, sometimes
        // we don't, so we still need this code.
            // otherwise we must have reached the loop's end.
            dwStart += dwSoFar << dwStereo;
            dwLength -= dwSoFar;
            m_pfLastSample -= (m_pfLoopEnd - m_pfLoopStart);  
        }
    }

    m_vfLastLVolume = vfNewLVolume;
    m_vfLastRVolume = vfNewRVolume;
    m_pfLastPitch = pfNewPitch;
    return (TRUE);
}

/*****************************************************************************
 * CVoice::CVoice()
 *****************************************************************************
 * Constructor for the CVoice object.
 */
CVoice::CVoice()
{
    m_pControl = NULL;
    m_pPitchBendIn = NULL;
    m_pExpressionIn = NULL;
    m_dwPriority = 0;
    m_nPart = 0;
    m_nKey = 0;
    m_fInUse = FALSE;
    m_fSustainOn = FALSE;
    m_fNoteOn = FALSE;
    m_fTag = FALSE;
    m_stStartTime = 0;
    m_stStopTime = 0x7fffffffffffffff;
    m_vrVolume = 0;
    m_fAllowOverlap = FALSE;
}

/*****************************************************************************
 * svrPanToVREL[]
 *****************************************************************************
 * A table for 0-127 translation to log scale.
 * value = log10(index/127) * 1000 where index = 0..128
 */
const VREL svrPanToVREL[] = {
//  0       1       2       3       4       5       6       7
    -2500,  -2103,  -1802,  -1626,  -1501,  -1404,  -1325,  -1258,
    -1200,  -1149,  -1103,  -1062,  -1024,  -989,   -957,   -927,
    -899,   -873,   -848,   -825,   -802,   -781,   -761,   -742,
    -723,   -705,   -688,   -672,   -656,   -641,   -626,   -612,
    -598,   -585,   -572,   -559,   -547,   -535,   -524,   -512,
    -501,   -491,   -480,   -470,   -460,   -450,   -441,   -431,
    -422,   -413,   -404,   -396,   -387,   -379,   -371,   -363,
    -355,   -347,   -340,   -332,   -325,   -318,   -311,   -304,
    -297,   -290,   -284,   -277,   -271,   -264,   -258,   -252,
    -246,   -240,   -234,   -228,   -222,   -217,   -211,   -206,
    -200,   -195,   -189,   -184,   -179,   -174,   -169,   -164,
    -159,   -154,   -149,   -144,   -140,   -135,   -130,   -126,
    -121,   -117,   -112,   -108,   -103,   -99,    -95,    -90,
    -86,    -82,    -78,    -74,    -70,    -66,    -62,    -58,
    -54,    -50,    -46,    -43,    -39,    -35,    -31,    -28,
    -24,    -21,    -17,    -13,    -10,    -6,     -3,     0
};

/*****************************************************************************
 * CVoice::StopVoice()
 *****************************************************************************
 * Stop the voice if it is playing.  Reset the envelope generators, sustain.
 */
void CVoice::StopVoice(STIME stTime)
{
    if (m_fNoteOn)
    {
        if (stTime <= m_stStartTime) stTime = m_stStartTime + 1;
        m_PitchEG.StopVoice(stTime);
        m_VolumeEG.StopVoice(stTime);
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_stStopTime = stTime;
    }
}

/*****************************************************************************
 * CVoice::QuickStopVoice()
 *****************************************************************************
 * Stop the voice ASAP.  If the note is on or sustaining, turn everything off
 * now, otherwise we just have to stop the volume EG (kill the decay curve).
 */
void CVoice::QuickStopVoice(STIME stTime)
{
    m_fTag = TRUE;
    if (m_fNoteOn || m_fSustainOn)
    {
        if (stTime <= m_stStartTime) stTime = m_stStartTime + 1;
        m_PitchEG.StopVoice(stTime);
        m_VolumeEG.QuickStopVoice(stTime,m_pSynth->m_dwSampleRate);
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_stStopTime = stTime;
    }
    else
    {
        m_VolumeEG.QuickStopVoice(m_stStopTime,m_pSynth->m_dwSampleRate);
    }
}

/*****************************************************************************
 * CVoice::StartVoice()
 *****************************************************************************
 * Start the voice with all the given parameters for pitch, mod, pan, etc.
 * The region must have an articulation and a wave.  Mix it now if the 
 * start time dictates.
 */
BOOL CVoice::StartVoice(CSynth *pSynth,
                        CSourceRegion *pRegion, STIME stStartTime,
                        CModWheelIn * pModWheelIn,
                        CPitchBendIn * pPitchBendIn,
                        CExpressionIn * pExpressionIn,
                        CVolumeIn * pVolumeIn,
                        CPanIn * pPanIn,
                        WORD nKey,WORD nVelocity,
                        VREL vrVolume,
                        PREL prPitch)
{
    CSourceArticulation * pArticulation = pRegion->m_pArticulation;
    if (pArticulation == NULL)
    {
        return FALSE;
    }
    // if we're going to handle volume later, don't read it now.
    if (!pSynth->m_fAllowVolumeChangeWhilePlayingNote)
        vrVolume += pVolumeIn->GetVolume(stStartTime);
    prPitch += pRegion->m_prTuning;
    m_dwGroup = pRegion->m_bGroup;
    m_fAllowOverlap = pRegion->m_bAllowOverlap;

    m_pSynth = pSynth;

    vrVolume += CMIDIRecorder::VelocityToVolume(nVelocity);
//                 * (long) pArticulation->m_sVelToVolScale) / -9600);

    vrVolume += pRegion->m_vrAttenuation;

    m_lDefaultPan = pRegion->m_pArticulation->m_sDefaultPan;
    // ignore pan here if allowing pan to vary after note starts

    VREL vrLVolume;
    VREL vrRVolume;
    if (pSynth->m_dwStereo && !pSynth->m_fAllowPanWhilePlayingNote) {
        long lPan = pPanIn->GetPan(stStartTime) + m_lDefaultPan;
        if (lPan < 0) lPan = 0;
        if (lPan > 127) lPan = 127;
        vrLVolume = ::svrPanToVREL[127 - lPan] + vrVolume;
        vrRVolume = ::svrPanToVREL[lPan] + vrVolume;
    } else {
        vrLVolume = vrVolume;
        vrRVolume = vrVolume;
    }
    
    m_stMixTime = m_LFO.StartVoice(&pArticulation->m_LFO,
        stStartTime, pModWheelIn);
    STIME stMixTime = m_PitchEG.StartVoice(&pArticulation->m_PitchEG,
        stStartTime, nKey, nVelocity);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }
    stMixTime = m_VolumeEG.StartVoice(&pArticulation->m_VolumeEG,
            stStartTime, nKey, nVelocity);
    if (stMixTime < m_stMixTime)
    {
        m_stMixTime = stMixTime;
    }
    if (m_stMixTime > pSynth->m_stMaxSpan)
    {
        m_stMixTime = pSynth->m_stMaxSpan;
    }
    // Make sure we have a pointer to the wave ready:
    if ((pRegion->m_Sample.m_pWave == NULL) || (pRegion->m_Sample.m_pWave->m_pnWave == NULL))
    {
        return (FALSE);     // Do nothing if no sample.
    }
    m_DigitalAudio.StartVoice(pSynth,&pRegion->m_Sample,
        vrLVolume, vrRVolume, prPitch, (long)nKey);

    m_pPitchBendIn = pPitchBendIn;
    m_pExpressionIn = pExpressionIn;
    m_pPanIn = pPanIn;
    m_pVolumeIn = pVolumeIn;
    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_stStartTime = stStartTime;
    m_stLastMix = stStartTime - 1;
    m_stStopTime = 0x7fffffffffffffff;
    
    if (m_stMixTime == 0)
    {
        // zero length attack, be sure it isn't missed....

        PREL prNewPitch = GetNewPitch(stStartTime);
        VREL vrVolumeL, vrVolumeR;
        GetNewVolume(stStartTime, vrVolumeL, vrVolumeR);

        if (m_stMixTime > pSynth->m_stMaxSpan)
        {
            m_stMixTime = pSynth->m_stMaxSpan;
        }

        m_DigitalAudio.Mix(NULL, 0,
                               vrVolumeL, vrVolumeR, prNewPitch,
                               m_pSynth->m_dwStereo);
    }
    m_vrVolume = 0;
    return (TRUE);
}
    
/*****************************************************************************
 * CVoice::ClearVoice()
 *****************************************************************************
 * Clear the voice (just forward to the digital audio peer object).
 */
void CVoice::ClearVoice()
{
    m_fInUse = FALSE;
    m_DigitalAudio.ClearVoice();
}

/*****************************************************************************
 * CVoice::GetNewVolume()
 *****************************************************************************
 * Return the volume delta at time <stTime>.
 * Volume is sum of volume envelope, LFO, expression, optionally the
 * channel volume if we're allowing it to change, and optionally the current
 * pan if we're allowing that to change.
 * This will be added to the base volume calculated in CVoice::StartVoice().
 */
void CVoice::GetNewVolume(STIME stTime, VREL& vrVolume, VREL &vrVolumeR)
{
    STIME stMixTime;
    vrVolume = m_VolumeEG.GetVolume(stTime,&stMixTime);
    if (stMixTime < m_stMixTime) m_stMixTime = stMixTime;
    // save pre-LFO volume for code that detects whether this note is off
    m_vrVolume = vrVolume;

    vrVolume += m_LFO.GetVolume(stTime,&stMixTime);
    if (stMixTime < m_stMixTime) m_stMixTime = stMixTime;
    vrVolume += m_pExpressionIn->GetVolume(stTime);

    if (m_pSynth->m_fAllowVolumeChangeWhilePlayingNote)
        vrVolume += m_pVolumeIn->GetVolume(stTime);

    vrVolume += m_pSynth->m_vrGainAdjust;
    vrVolumeR = vrVolume;
   
    // handle pan here if allowing pan to vary after note starts
    if (m_pSynth->m_dwStereo &&
        m_pSynth->m_fAllowPanWhilePlayingNote)
    {
        // add current pan & instrument default pan
        LONG lPan = m_pPanIn->GetPan(stTime) + m_lDefaultPan;

        // don't go off either end....
        if (lPan < 0) lPan = 0;
        if (lPan > 127) lPan = 127;
        vrVolume += ::svrPanToVREL[127 - lPan];
        vrVolumeR += ::svrPanToVREL[lPan];
    }
}

/*****************************************************************************
 * CVoice::GetNewPitch()
 *****************************************************************************
 * Returns the current pitch for time <stTime>.
 * Pitch is the sum of the pitch LFO, the pitch envelope, and the current
 * pitch bend.
 */
PREL CVoice::GetNewPitch(STIME stTime)
{
    STIME stMixTime;
    PREL prPitch = m_LFO.GetPitch(stTime,&stMixTime);
    if (m_stMixTime > stMixTime) m_stMixTime = stMixTime;
    prPitch += m_PitchEG.GetPitch(stTime,&stMixTime);
    if (m_stMixTime > stMixTime) m_stMixTime = stMixTime;
    prPitch += m_pPitchBendIn->GetPitch(stTime); 

    return prPitch;
}


/*****************************************************************************
 * CVoice::Mix()
 *****************************************************************************
 * Mix this voice into the given buffer.  Determine certain volume and pitch
 * parameters, then call into the Digital Audio Engine.
 */
DWORD CVoice::Mix(  short *pBuffer, DWORD dwLength,
                    STIME stStart,  STIME stEnd)
{
    BOOL fInUse = TRUE;
    BOOL fFullMix = TRUE;
    STIME stEndMix = stStart;

    STIME stStartMix = m_stStartTime;
    if (stStartMix < stStart) 
    {
        stStartMix = stStart;
    }
    if (m_stLastMix >= stEnd)
    {
        return (0);
    }
    if (m_stLastMix >= stStartMix)
    {
        stStartMix = m_stLastMix;
    }
    while (stStartMix < stEnd && fInUse)
    {   
        stEndMix = stStartMix + m_stMixTime;
        
        if (stEndMix > stEnd)
        {
            stEndMix = stEnd;
        }
        m_stMixTime = m_pSynth->m_stMaxSpan;
        if ((m_stLastMix < m_stStopTime) && (m_stStopTime < stEnd))
        {
            if (m_stMixTime > (m_stStopTime - m_stLastMix))
            {
                m_stMixTime = m_stStopTime - m_stLastMix;
            }
        }
        
        PREL prPitch = GetNewPitch(stEndMix);

        VREL vrVolume, vrVolumeR;
        GetNewVolume(stEndMix, vrVolume, vrVolumeR);
        
        if (m_VolumeEG.InRelease(stEndMix)) 
        {
            if (m_vrVolume < PERCEIVED_MIN_VOLUME) // End of release slope
            {
                fInUse = FALSE;
            }
        }

        fFullMix = m_DigitalAudio.Mix(&pBuffer[(stStartMix - stStart) <<
                                                      m_pSynth->m_dwStereo],
                                      (DWORD) (stEndMix - stStartMix),
                                      vrVolume, vrVolumeR, prPitch,
                                      m_pSynth->m_dwStereo);
        stStartMix = stEndMix;
    }
    m_fInUse = fInUse && fFullMix;
    if (!m_fInUse) 
    {
        ClearVoice();
        m_stStopTime = stEndMix;    // For measurement purposes.
    }
    m_stLastMix = stEndMix;
    return (dwLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\dmusuart\miniport.cpp ===
/*****************************************************************************
 * miniport.cpp - UART miniport implementation
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *      Feb 98    MartinP   --  based on UART, began deltas for DirectMusic.
 */

#include "private.h"
#include "ksdebug.h"
#include "stdio.h"

#define STR_MODULENAME "DMusUART:Miniport: "

#pragma code_seg("PAGE")

/*****************************************************************************
 * PinDataRangesStreamLegacy
 * PinDataRangesStreamDMusic
 *****************************************************************************
 * Structures indicating range of valid format values for live pins.
 */
static
KSDATARANGE_MUSIC PinDataRangesStreamLegacy =
{
    {
        sizeof(KSDATARANGE_MUSIC),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    },
    STATICGUIDOF(KSMUSIC_TECHNOLOGY_PORT),
    0,
    0,
    0xFFFF
};
static
KSDATARANGE_MUSIC PinDataRangesStreamDMusic =
{
    {
        sizeof(KSDATARANGE_MUSIC),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    },
    STATICGUIDOF(KSMUSIC_TECHNOLOGY_PORT),
    0,
    0,
    0xFFFF
};

/*****************************************************************************
 * PinDataRangePointersStreamLegacy
 * PinDataRangePointersStreamDMusic
 * PinDataRangePointersStreamCombined
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for live pins.
 */
static
PKSDATARANGE PinDataRangePointersStreamLegacy[] =
{
    PKSDATARANGE(&PinDataRangesStreamLegacy)
};
static
PKSDATARANGE PinDataRangePointersStreamDMusic[] =
{
    PKSDATARANGE(&PinDataRangesStreamDMusic)
};
static
PKSDATARANGE PinDataRangePointersStreamCombined[] =
{
    PKSDATARANGE(&PinDataRangesStreamLegacy)
   ,PKSDATARANGE(&PinDataRangesStreamDMusic)
};

/*****************************************************************************
 * PinDataRangesBridge
 *****************************************************************************
 * Structures indicating range of valid format values for bridge pins.
 */
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI_BUS),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

/*****************************************************************************
 * PinDataRangePointersBridge
 *****************************************************************************
 * List of pointers to structures indicating range of valid format values
 * for bridge pins.
 */
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

/*****************************************************************************
 * SynthProperties
 *****************************************************************************
 * List of properties in the Synth set.
 */
static
PCPROPERTY_ITEM
SynthProperties[] =
{
    // Global: S/Get synthesizer caps
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CAPS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Global: S/Get port parameters
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_PORTPARAMETERS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per stream: S/Get channel groups
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CHANNELGROUPS,
        KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    },
    // Per stream: Get current latency time
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_LATENCYCLOCK,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Synth
    }
};
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSynth,  SynthProperties);
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSynth2, SynthProperties);

#define kMaxNumCaptureStreams       1
#define kMaxNumLegacyRenderStreams  1
#define kMaxNumDMusicRenderStreams  1

/*****************************************************************************
 * MiniportPins
 *****************************************************************************
 * List of pins.
 */
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    {
        kMaxNumLegacyRenderStreams,kMaxNumLegacyRenderStreams,0,    // InstanceCount
        NULL,                                                       // AutomationTable
        {                                                           // KsPinDescriptor
            0,                                              // InterfacesCount
            NULL,                                           // Interfaces
            0,                                              // MediumsCount
            NULL,                                           // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStreamLegacy), // DataRangesCount
            PinDataRangePointersStreamLegacy,               // DataRanges
            KSPIN_DATAFLOW_IN,                              // DataFlow
            KSPIN_COMMUNICATION_SINK,                       // Communication
            (GUID *) &KSCATEGORY_AUDIO,                     // Category
            &KSAUDFNAME_MIDI,                               // Name
            0                                               // Reserved
        }
    },
    {
        kMaxNumDMusicRenderStreams,kMaxNumDMusicRenderStreams,0,    // InstanceCount
        NULL,                                                       // AutomationTable
        {                                                           // KsPinDescriptor
            0,                                              // InterfacesCount
            NULL,                                           // Interfaces
            0,                                              // MediumsCount
            NULL,                                           // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStreamDMusic), // DataRangesCount
            PinDataRangePointersStreamDMusic,               // DataRanges
            KSPIN_DATAFLOW_IN,                              // DataFlow
            KSPIN_COMMUNICATION_SINK,                       // Communication
            (GUID *) &KSCATEGORY_AUDIO,                     // Category
            &KSAUDFNAME_DMUSIC_MPU_OUT,                     // Name
            0                                               // Reserved
        }
    },
    {
        0,0,0,                                      // InstanceCount
        NULL,                                       // AutomationTable
        {                                           // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
    {
        0,0,0,                                      // InstanceCount
        NULL,                                       // AutomationTable
        {                                           // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
    {
        kMaxNumCaptureStreams,kMaxNumCaptureStreams,0,      // InstanceCount
        NULL,                                               // AutomationTable
        {                                                   // KsPinDescriptor
            0,                                                // InterfacesCount
            NULL,                                             // Interfaces
            0,                                                // MediumsCount
            NULL,                                             // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStreamCombined), // DataRangesCount
            PinDataRangePointersStreamCombined,               // DataRanges
            KSPIN_DATAFLOW_OUT,                               // DataFlow
            KSPIN_COMMUNICATION_SINK,                         // Communication
            (GUID *) &KSCATEGORY_AUDIO,                       // Category
            &KSAUDFNAME_DMUSIC_MPU_IN,                        // Name
            0                                                 // Reserved
        }
    }
};

/*****************************************************************************
 * MiniportNodes
 *****************************************************************************
 * List of nodes.
 */
#define CONST_PCNODE_DESCRIPTOR(n)          { 0, NULL, &n, NULL }
#define CONST_PCNODE_DESCRIPTOR_AUTO(n,a)   { 0, &a, &n, NULL }
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
      CONST_PCNODE_DESCRIPTOR_AUTO(KSNODETYPE_SYNTHESIZER, AutomationSynth)
    , CONST_PCNODE_DESCRIPTOR_AUTO(KSNODETYPE_SYNTHESIZER, AutomationSynth2)
};

/*****************************************************************************
 * MiniportConnections
 *****************************************************************************
 * List of connections.
 */
enum {
      eSynthNode  = 0
    , eInputNode
};

enum {
      eFilterInputPinLeg = 0,
      eFilterInputPinDM,
      eBridgeOutputPin,
      eBridgeInputPin,
      eFilterOutputPin
};

static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{  // From                                   To
   // Node           pin                     Node           pin
    { PCFILTER_NODE, eFilterInputPinLeg,     PCFILTER_NODE, eBridgeOutputPin }      // Legacy Stream in to synth.
  , { PCFILTER_NODE, eFilterInputPinDM,      eSynthNode,    KSNODEPIN_STANDARD_IN } // DM Stream in to synth.
  , { eSynthNode,    KSNODEPIN_STANDARD_OUT, PCFILTER_NODE, eBridgeOutputPin }      // Synth to bridge out.
  , { PCFILTER_NODE, eBridgeInputPin,        eInputNode,    KSNODEPIN_STANDARD_IN } // Bridge in to input.
  , { eInputNode,    KSNODEPIN_STANDARD_OUT, PCFILTER_NODE, eFilterOutputPin }      // Input to DM/Legacy Stream out.
};

/*****************************************************************************
 * MiniportCategories
 *****************************************************************************
 * List of categories.
 */
static
GUID MiniportCategories[] =
{
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_RENDER),
    STATICGUIDOF(KSCATEGORY_CAPTURE)
};

/*****************************************************************************
 * MiniportFilterDescriptor
 *****************************************************************************
 * Complete miniport filter description.
 */
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    SIZEOF_ARRAY(MiniportCategories),   // CategoryCount
    MiniportCategories                  // Categories
};

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::GetDescription()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUART::
GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_BLAB,("GetDescription"));

    *OutFilterDescriptor = &MiniportFilterDescriptor;

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CreateMiniportDMusUART()
 *****************************************************************************
 * Creates a MPU-401 miniport driver for the adapter.  This uses a
 * macro from STDUNK.H to do all the work.
 */
NTSTATUS
CreateMiniportDMusUART
(
    OUT     PUNKNOWN *  Unknown,
    IN      REFCLSID,
    IN      PUNKNOWN    UnknownOuter    OPTIONAL,
    IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("CreateMiniportDMusUART"));
    ASSERT(Unknown);

    STD_CREATE_BODY_(   CMiniportDMusUART,
                        Unknown,
                        UnknownOuter,
                        PoolType,
                        PMINIPORTDMUS);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::ProcessResources()
 *****************************************************************************
 * Processes the resource list, setting up helper objects accordingly.
 */
NTSTATUS
CMiniportDMusUART::
ProcessResources
(
    IN      PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_BLAB,("ProcessResources"));
    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }
    //
    // Get counts for the types of resources.
    //
    ULONG   countIO     = ResourceList->NumberOfPorts();
    ULONG   countIRQ    = ResourceList->NumberOfInterrupts();
    ULONG   countDMA    = ResourceList->NumberOfDmas();
    ULONG   lengthIO    = ResourceList->FindTranslatedPort(0)->u.Port.Length;

#if (DBG)
    _DbgPrintF(DEBUGLVL_VERBOSE,("Starting MPU401 Port 0x%X",
        ResourceList->FindTranslatedPort(0)->u.Port.Start.LowPart) );
#endif

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make sure we have the expected number of resources.
    //
    if  (   (countIO != 1)
        ||  (countIRQ  > 1)
        ||  (countDMA != 0)
        ||  (lengthIO == 0)
        )
    {
        _DbgPrintF(DEBUGLVL_TERSE,("Unknown ResourceList configuraton"));
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Get the port address.
        //
        m_pPortBase =
            PUCHAR(ResourceList->FindTranslatedPort(0)->u.Port.Start.QuadPart);

        ntStatus = InitializeHardware(m_pInterruptSync,m_pPortBase);
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUART::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("Miniport::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTDMUS(this)));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportDMus))
    {
        *Object = PVOID(PMINIPORTDMUS(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMusicTechnology))
    {
        *Object = PVOID(PMUSICTECHNOLOGY(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IPowerNotify))
    {
        *Object = PVOID(PPOWERNOTIFY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::~CMiniportDMusUART()
 *****************************************************************************
 * Destructor.
 */
CMiniportDMusUART::~CMiniportDMusUART(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("~CMiniportDMusUART"));

    ASSERT(0 == m_NumCaptureStreams);
    ASSERT(0 == m_NumRenderStreams);

    //  reset the HW so we don't get anymore interrupts
    if (m_UseIRQ && m_pInterruptSync)
    {
        (void) m_pInterruptSync->CallSynchronizedRoutine(InitMPU,PVOID(m_pPortBase));
    }
    else
    {
        (void) InitMPU(NULL,PVOID(m_pPortBase));
    }

    if (m_pInterruptSync)
    {
        m_pInterruptSync->Release();
        m_pInterruptSync = NULL;
    }
    if (m_pServiceGroup)
    {
        m_pServiceGroup->Release();
        m_pServiceGroup = NULL;
    }
    if (m_pPort)
    {
        m_pPort->Release();
        m_pPort = NULL;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::Init()
 *****************************************************************************
 * Initializes a the miniport.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUART::
Init
(
    IN      PUNKNOWN        UnknownInterruptSync    OPTIONAL,
    IN      PRESOURCELIST   ResourceList,
    IN      PPORTDMUS       Port_,
    OUT     PSERVICEGROUP * ServiceGroup
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    ASSERT(Port_);
    ASSERT(ServiceGroup);

    _DbgPrintF(DEBUGLVL_BLAB,("Init"));

    *ServiceGroup = NULL;
    m_pPortBase = 0;
    m_fMPUInitialized = FALSE;

    // This will remain unspecified if the miniport does not get any power
    // messages.
    //
    m_PowerState.DeviceState = PowerDeviceUnspecified;

    //
    // AddRef() is required because we are keeping this pointer.
    //
    m_pPort = Port_;
    m_pPort->AddRef();

    // Set dataformat.
    //
    if (IsEqualGUIDAligned(m_MusicFormatTechnology, GUID_NULL))
    {
        RtlCopyMemory(  &m_MusicFormatTechnology,
                        &KSMUSIC_TECHNOLOGY_PORT,
                        sizeof(GUID));
    }
    RtlCopyMemory(  &PinDataRangesStreamLegacy.Technology,
                    &m_MusicFormatTechnology,
                    sizeof(GUID));
    RtlCopyMemory(  &PinDataRangesStreamDMusic.Technology,
                    &m_MusicFormatTechnology,
                    sizeof(GUID));

    for (ULONG bufferCount = 0;bufferCount < kMPUInputBufferSize;bufferCount++)
    {
        m_MPUInputBuffer[bufferCount] = 0;
    }
    m_MPUInputBufferHead = 0;
    m_MPUInputBufferTail = 0;
    m_InputTimeStamp = 0;
    m_KSStateInput = KSSTATE_STOP;

    NTSTATUS ntStatus = STATUS_SUCCESS;

    m_NumRenderStreams = 0;
    m_NumCaptureStreams = 0;

    m_UseIRQ = TRUE;
    if (ResourceList->NumberOfInterrupts() == 0)
    {
        m_UseIRQ = FALSE;
    }

    ntStatus = PcNewServiceGroup(&m_pServiceGroup,NULL);
    if (NT_SUCCESS(ntStatus) && !m_pServiceGroup)   //  keep any error
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(ntStatus))
    {
        *ServiceGroup = m_pServiceGroup;
        m_pServiceGroup->AddRef();

        //
        // Register the service group with the port early so the port is
        // prepared to handle interrupts.
        //
        m_pPort->RegisterServiceGroup(m_pServiceGroup);
    }

    if (NT_SUCCESS(ntStatus) && m_UseIRQ)
    {
        //
        //  Due to a bug in the InterruptSync design, we shouldn't share
        //  the interrupt sync object.  Whoever goes away first
        //  will disconnect it, and the other points off into nowhere.
        //
        //  Instead we generate our own interrupt sync object.
        //
        UnknownInterruptSync = NULL;

        if (UnknownInterruptSync)
        {
            ntStatus =
                UnknownInterruptSync->QueryInterface
                (
                    IID_IInterruptSync,
                    (PVOID *) &m_pInterruptSync
                );

            if (!m_pInterruptSync && NT_SUCCESS(ntStatus))  //  keep any error
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            if (NT_SUCCESS(ntStatus))
            {                                                                           //  run this ISR first
                ntStatus = m_pInterruptSync->
                    RegisterServiceRoutine(DMusMPUInterruptServiceRoutine,PVOID(this),TRUE);
            }

        }
        else
        {   // create our own interruptsync mechanism.
            ntStatus =
                PcNewInterruptSync
                (
                    &m_pInterruptSync,
                    NULL,
                    ResourceList,
                    0,                          // Resource Index
                    InterruptSyncModeNormal     // Run ISRs once until we get SUCCESS
                );

            if (!m_pInterruptSync && NT_SUCCESS(ntStatus))    //  keep any error
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = m_pInterruptSync->RegisterServiceRoutine(
                    DMusMPUInterruptServiceRoutine,
                    PVOID(this),
                    TRUE);          //  run this ISR first
            }
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = m_pInterruptSync->Connect();
            }
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ProcessResources(ResourceList);
    }

    if (!NT_SUCCESS(ntStatus))
    {
        //
        // clean up our mess
        //

        // clean up the interrupt sync
        if( m_pInterruptSync )
        {
            m_pInterruptSync->Release();
            m_pInterruptSync = NULL;
        }

        // clean up the service group
        if( m_pServiceGroup )
        {
            m_pServiceGroup->Release();
            m_pServiceGroup = NULL;
        }

        // clean up the out param service group.
        if (*ServiceGroup)
        {
            (*ServiceGroup)->Release();
            (*ServiceGroup) = NULL;
        }

        // release the port
        m_pPort->Release();
        m_pPort = NULL;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::NewStream()
 *****************************************************************************
 * Gets the topology.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUART::
NewStream
(
    OUT     PMXF                  * MXF,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      POOL_TYPE               PoolType,
    IN      ULONG                   PinID,
    IN      DMUS_STREAM_TYPE        StreamType,
    IN      PKSDATAFORMAT           DataFormat,
    OUT     PSERVICEGROUP         * ServiceGroup,
    IN      PAllocatorMXF           AllocatorMXF,
    IN      PMASTERCLOCK            MasterClock,
    OUT     PULONGLONG              SchedulePreFetch
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB, ("NewStream"));
    NTSTATUS ntStatus = STATUS_SUCCESS;

    // In 100 ns, we want stuff as soon as it comes in
    //
    *SchedulePreFetch = 0;

    // if we don't have any streams already open, get the hardware ready.
    if ((!m_NumCaptureStreams) && (!m_NumRenderStreams))
    {
        ntStatus = ResetHardware(m_pPortBase);
        if (!NT_SUCCESS(ntStatus))
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportDMusUART::NewStream ResetHardware failed"));
            return ntStatus;
        }
    }

    if  (   ((m_NumCaptureStreams < kMaxNumCaptureStreams)
            && (StreamType == DMUS_STREAM_MIDI_CAPTURE))
        ||  ((m_NumRenderStreams < kMaxNumLegacyRenderStreams + kMaxNumDMusicRenderStreams)
            && (StreamType == DMUS_STREAM_MIDI_RENDER))
        )
    {
        CMiniportDMusUARTStream *pStream =
            new(PoolType) CMiniportDMusUARTStream(OuterUnknown);

        if (pStream)
        {
            pStream->AddRef();

            ntStatus =
                pStream->Init(this,m_pPortBase,(StreamType == DMUS_STREAM_MIDI_CAPTURE),AllocatorMXF,MasterClock);

            if (NT_SUCCESS(ntStatus))
            {
                *MXF = PMXF(pStream);
                (*MXF)->AddRef();

                if (StreamType == DMUS_STREAM_MIDI_CAPTURE)
                {
                    m_NumCaptureStreams++;
                    *ServiceGroup = m_pServiceGroup;
                    (*ServiceGroup)->AddRef();
                }
                else
                {
                    m_NumRenderStreams++;
                    *ServiceGroup = NULL;
                }
            }

            pStream->Release();
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        if (StreamType == DMUS_STREAM_MIDI_CAPTURE)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewStream failed, too many capture streams"));
        }
        else if (StreamType == DMUS_STREAM_MIDI_RENDER)
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewStream failed, too many render streams"));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("NewStream invalid stream type"));
        }
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUART::SetTechnology()
 *****************************************************************************
 * Sets pindatarange technology.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUART::
SetTechnology
(
    IN      const GUID *            Technology
)
{
    PAGED_CODE();

    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    // Fail if miniport has already been initialized.
    //
    if (NULL == m_pPort)
    {
        RtlCopyMemory(&m_MusicFormatTechnology, Technology, sizeof(GUID));
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
} // SetTechnology

/*****************************************************************************
 * CMiniportDMusUART::PowerChangeNotify()
 *****************************************************************************
 * Handle power state change for the miniport.
 */
#pragma code_seg("PAGE")
STDMETHODIMP_(void)
CMiniportDMusUART::
PowerChangeNotify
(
    IN      POWER_STATE             PowerState
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportDMusUART::PoweChangeNotify D%d", PowerState.DeviceState));

    switch (PowerState.DeviceState)
    {
        case PowerDeviceD0:
            if (m_PowerState.DeviceState != PowerDeviceD0)
            {
                if (!NT_SUCCESS(InitializeHardware(m_pInterruptSync,m_pPortBase)))
                {
                    _DbgPrintF(DEBUGLVL_TERSE, ("InitializeHardware failed when resuming"));
                }
            }
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
        default:
            break;
    }
    m_PowerState.DeviceState = PowerState.DeviceState;
} // PowerChangeNotify

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::NonDelegatingQueryInterface()
 *****************************************************************************
 * Obtains an interface.  This function works just like a COM QueryInterface
 * call and is used if the object is not being aggregated.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUARTStream::
NonDelegatingQueryInterface
(
    REFIID  Interface,
    PVOID * Object
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("Stream::NonDelegatingQueryInterface"));
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMXF))
    {
        *Object = PVOID(PMXF(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::~CMiniportDMusUARTStream()
 *****************************************************************************
 * Destructs a stream.
 */
CMiniportDMusUARTStream::~CMiniportDMusUARTStream(void)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_BLAB,("~CMiniportDMusUARTStream"));

    KeCancelTimer(&m_TimerEvent);

    if (m_DMKEvtQueue)
    {
        if (m_AllocatorMXF)
        {
            m_AllocatorMXF->PutMessage(m_DMKEvtQueue);
        }
        else
        {
            _DbgPrintF(DEBUGLVL_ERROR,("~CMiniportDMusUARTStream, no allocator, can't flush DMKEvts"));
        }
        m_DMKEvtQueue = NULL;
    }
    if (m_AllocatorMXF)
    {
        m_AllocatorMXF->Release();
        m_AllocatorMXF = NULL;
    }

    if (m_pMiniport)
    {
        if (m_fCapture)
        {
            m_pMiniport->m_NumCaptureStreams--;
        }
        else
        {
            m_pMiniport->m_NumRenderStreams--;
        }

        m_pMiniport->Release();
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::Init()
 *****************************************************************************
 * Initializes a stream.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUARTStream::
Init
(
    IN      CMiniportDMusUART * pMiniport,
    IN      PUCHAR              pPortBase,
    IN      BOOLEAN             fCapture,
    IN      PAllocatorMXF       allocatorMXF,
    IN      PMASTERCLOCK        masterClock
)
{
    PAGED_CODE();

    ASSERT(pMiniport);
    ASSERT(pPortBase);

    _DbgPrintF(DEBUGLVL_BLAB,("Init"));

    m_NumFailedMPUTries = 0;
    m_TimerQueued = FALSE;
    KeInitializeSpinLock(&m_DpcSpinLock);
    m_pMiniport = pMiniport;
    m_pMiniport->AddRef();

    pMiniport->m_MasterClock = masterClock;

    m_pPortBase = pPortBase;
    m_fCapture = fCapture;

    m_SnapshotTimeStamp = 0;
    m_DMKEvtQueue = NULL;
    m_DMKEvtOffset = 0;

    m_NumberOfRetries = 0;

    if (allocatorMXF)
    {
        allocatorMXF->AddRef();
        m_AllocatorMXF = allocatorMXF;
        m_sinkMXF = m_AllocatorMXF;
    }
    else
    {
        return STATUS_INVALID_PARAMETER;
    }

    KeInitializeDpc
    (
        &m_Dpc,
        &::DMusUARTTimerDPC,
        PVOID(this)
    );
    KeInitializeTimer(&m_TimerEvent);

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::SetState()
 *****************************************************************************
 * Sets the state of the channel.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUARTStream::
SetState
(
    IN      KSSTATE     NewState
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("SetState %d",NewState));

    if (NewState == KSSTATE_RUN)
    {
        if (m_pMiniport->m_fMPUInitialized)
        {
            LARGE_INTEGER timeDue100ns;
            timeDue100ns.QuadPart = 0;
            KeSetTimer(&m_TimerEvent,timeDue100ns,&m_Dpc);
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportDMusUARTStream::SetState KSSTATE_RUN failed due to uninitialized MPU"));
            return STATUS_INVALID_DEVICE_STATE;
        }
    }

    if (m_fCapture)
    {
        m_pMiniport->m_KSStateInput = NewState;
        if (NewState == KSSTATE_STOP)   //  STOPping
        {
            m_pMiniport->m_MPUInputBufferHead = 0;   // Previously read bytes are discarded.
            m_pMiniport->m_MPUInputBufferTail = 0;   // The entire FIFO is available.
        }
    }
    return STATUS_SUCCESS;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUART::Service()
 *****************************************************************************
 * DPC-mode service call from the port.
 */
STDMETHODIMP_(void)
CMiniportDMusUART::
Service
(   void
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("Service"));
    if (!m_NumCaptureStreams)
    {
        //  we should never get here....
        //  if we do, we must have read some trash,
        //  so just reset the input FIFO
        m_MPUInputBufferTail = m_MPUInputBufferHead = 0;
    }
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::ConnectOutput()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
NTSTATUS
CMiniportDMusUARTStream::
ConnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if (m_fCapture)
    {
        if ((sinkMXF) && (m_sinkMXF == m_AllocatorMXF))
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("ConnectOutput"));
            m_sinkMXF = sinkMXF;
            return STATUS_SUCCESS;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ConnectOutput failed"));
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("ConnectOutput called on renderer; failed"));
    }
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * CMiniportDMusUARTStream::DisconnectOutput()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
NTSTATUS
CMiniportDMusUARTStream::
DisconnectOutput(PMXF sinkMXF)
{
    PAGED_CODE();

    if (m_fCapture)
    {
        if ((m_sinkMXF == sinkMXF) || (!sinkMXF))
        {
            _DbgPrintF(DEBUGLVL_BLAB, ("DisconnectOutput"));
            m_sinkMXF = m_AllocatorMXF;
            return STATUS_SUCCESS;
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("DisconnectOutput failed"));
        }
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("DisconnectOutput called on renderer; failed"));
    }
    return STATUS_UNSUCCESSFUL;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::PutMessageLocked()
 *****************************************************************************
 * Now that the spinlock is held, add this message to the queue.
 *
 * Writes an outgoing MIDI message.
 * We don't sort a new message into the queue -- we append it.
 * This is fine, since the sequencer feeds us sequenced data.
 * Timestamps will ascend by design.
 */
NTSTATUS CMiniportDMusUARTStream::PutMessageLocked(PDMUS_KERNEL_EVENT pDMKEvt)
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PDMUS_KERNEL_EVENT  aDMKEvt;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (!m_fCapture)
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("PutMessage to render stream"));
        if (pDMKEvt)
        {
            // m_DpcSpinLock already held

            if (m_DMKEvtQueue)
            {
                aDMKEvt = m_DMKEvtQueue;            //  put pDMKEvt in event queue

                while (aDMKEvt->pNextEvt)
                {
                    aDMKEvt = aDMKEvt->pNextEvt;
                }
                aDMKEvt->pNextEvt = pDMKEvt;        //  here is end of queue
            }
            else                                    //  currently nothing in queue
            {
                m_DMKEvtQueue = pDMKEvt;
                if (m_DMKEvtOffset)
                {
                    _DbgPrintF(DEBUGLVL_ERROR, ("PutMessage  Nothing in the queue, but m_DMKEvtOffset == %d",m_DMKEvtOffset));
                    m_DMKEvtOffset = 0;
                }
            }

            // m_DpcSpinLock already held
        }
        if (!m_TimerQueued)
        {
            (void) ConsumeEvents();
        }
    }
    else    //  capture
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("PutMessage to capture stream"));
        ASSERT(NULL == pDMKEvt);

        SourceEvtsToPort();
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::PutMessage()
 *****************************************************************************
 * Writes an outgoing MIDI message.
 * We don't sort a new message into the queue -- we append it.
 * This is fine, since the sequencer feeds us sequenced data.
 * Timestamps will ascend by design.
 */
NTSTATUS CMiniportDMusUARTStream::PutMessage(PDMUS_KERNEL_EVENT pDMKEvt)
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDMUS_KERNEL_EVENT  aDMKEvt;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (!m_fCapture)
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("PutMessage to render stream"));
        if (pDMKEvt)
        {
            KeAcquireSpinLockAtDpcLevel(&m_DpcSpinLock);

            if (m_DMKEvtQueue)
            {
                aDMKEvt = m_DMKEvtQueue;            //  put pDMKEvt in event queue

                while (aDMKEvt->pNextEvt)
                {
                    aDMKEvt = aDMKEvt->pNextEvt;
                }
                aDMKEvt->pNextEvt = pDMKEvt;        //  here is end of queue
            }
            else                                    //  currently nothing in queue
            {
                m_DMKEvtQueue = pDMKEvt;
                if (m_DMKEvtOffset)
                {
                    _DbgPrintF(DEBUGLVL_ERROR, ("PutMessage  Nothing in the queue, but m_DMKEvtOffset == %d",m_DMKEvtOffset));
                    m_DMKEvtOffset = 0;
                }
            }

            KeReleaseSpinLockFromDpcLevel(&m_DpcSpinLock);
        }
        if (!m_TimerQueued)
        {
            (void) ConsumeEvents();
        }
    }
    else    //  capture
    {
        _DbgPrintF(DEBUGLVL_BLAB, ("PutMessage to capture stream"));
        ASSERT(NULL == pDMKEvt);

        SourceEvtsToPort();
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::ConsumeEvents()
 *****************************************************************************
 * Attempts to empty the render message queue.
 * Called either from DPC timer or upon IRP submittal.
//  TODO: support packages right
//  process the package (actually, should do this above.
//  treat the package as a list fragment that shouldn't be sorted.
//  better yet, go through each event in the package, and when
//  an event is exhausted, delete it and decrement m_offset.
 */
NTSTATUS CMiniportDMusUARTStream::ConsumeEvents(void)
{
    PDMUS_KERNEL_EVENT aDMKEvt;

    NTSTATUS        ntStatus = STATUS_SUCCESS;
    ULONG           bytesRemaining = 0,bytesWritten = 0;
    LARGE_INTEGER   aMillisecIn100ns;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    KeAcquireSpinLockAtDpcLevel(&m_DpcSpinLock);

    m_TimerQueued = FALSE;
    while (m_DMKEvtQueue)                   //  do we have anything to play at all?
    {
        aDMKEvt = m_DMKEvtQueue;                            //  event we try to play
        if (aDMKEvt->cbEvent)
        {
            bytesRemaining = aDMKEvt->cbEvent - m_DMKEvtOffset; //  number of bytes left in this evt

            ASSERT(bytesRemaining > 0);
            if (bytesRemaining <= 0)
            {
                bytesRemaining = aDMKEvt->cbEvent;
            }

            if (aDMKEvt->cbEvent <= sizeof(PBYTE))                //  short message
            {
                _DbgPrintF(DEBUGLVL_BLAB, ("ConsumeEvents(%02x%02x%02x%02x)",aDMKEvt->uData.abData[0],aDMKEvt->uData.abData[1],aDMKEvt->uData.abData[2],aDMKEvt->uData.abData[3]));
                ntStatus = Write(aDMKEvt->uData.abData + m_DMKEvtOffset,bytesRemaining,&bytesWritten);
            }
            else if (PACKAGE_EVT(aDMKEvt))
            {
                ASSERT(m_DMKEvtOffset == 0);
                m_DMKEvtOffset = 0;
                _DbgPrintF(DEBUGLVL_BLAB, ("ConsumeEvents(Package)"));

                ntStatus = PutMessageLocked(aDMKEvt->uData.pPackageEvt);  // we already own the spinlock

                // null this because we are about to throw it in the allocator
                aDMKEvt->uData.pPackageEvt = NULL;
                aDMKEvt->cbEvent = 0;
                bytesWritten = bytesRemaining;
            }
            else                //  SysEx message
            {
                _DbgPrintF(DEBUGLVL_BLAB, ("ConsumeEvents(%02x%02x%02x%02x)",aDMKEvt->uData.pbData[0],aDMKEvt->uData.pbData[1],aDMKEvt->uData.pbData[2],aDMKEvt->uData.pbData[3]));

                ntStatus = Write(aDMKEvt->uData.pbData + m_DMKEvtOffset,bytesRemaining,&bytesWritten);
            }
        }   //  if (aDMKEvt->cbEvent)
        if (STATUS_SUCCESS != ntStatus)
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("ConsumeEvents: Write returned 0x%08x",ntStatus));
            bytesWritten = bytesRemaining;  //  just bail on this event and try next time
        }

        ASSERT(bytesWritten <= bytesRemaining);
        if (bytesWritten == bytesRemaining)
        {
            m_DMKEvtQueue = m_DMKEvtQueue->pNextEvt;
            aDMKEvt->pNextEvt = NULL;

            m_AllocatorMXF->PutMessage(aDMKEvt);    //  throw back in free pool
            m_DMKEvtOffset = 0;                     //  start fresh on next evt
            m_NumberOfRetries = 0;
        }           //  but wait ... there's more!
        else        //  our FIFO is full for now.
        {
            //  update our offset by that amount we did write
            m_DMKEvtOffset += bytesWritten;
            ASSERT(m_DMKEvtOffset < aDMKEvt->cbEvent);

            _DbgPrintF(DEBUGLVL_BLAB,("ConsumeEvents tried %d, wrote %d, at offset %d",bytesRemaining,bytesWritten,m_DMKEvtOffset));
            aMillisecIn100ns.QuadPart = -(kOneMillisec);    //  set timer, come back later
            m_TimerQueued = TRUE;
            m_NumberOfRetries++;
            ntStatus = KeSetTimer( &m_TimerEvent, aMillisecIn100ns, &m_Dpc );
            break;
        }   //  we didn't write it all
    }       //  go back, Jack, do it again (while m_DMKEvtQueue)
    KeReleaseSpinLockFromDpcLevel(&m_DpcSpinLock);
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::HandlePortParams()
 *****************************************************************************
 * Writes an outgoing MIDI message.
 */
NTSTATUS
CMiniportDMusUARTStream::
HandlePortParams
(
    IN      PPCPROPERTY_REQUEST     pRequest
)
{
    PAGED_CODE();

    NTSTATUS ntStatus;

    if (pRequest->Verb & KSPROPERTY_TYPE_SET)
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ntStatus = ValidatePropertyRequest(pRequest, sizeof(SYNTH_PORTPARAMS), TRUE);
    if (NT_SUCCESS(ntStatus))
    {
        RtlCopyMemory(pRequest->Value, pRequest->Instance, sizeof(SYNTH_PORTPARAMS));

        PSYNTH_PORTPARAMS Params = (PSYNTH_PORTPARAMS)pRequest->Value;

        if (Params->ValidParams & ~SYNTH_PORTPARAMS_CHANNELGROUPS)
        {
            Params->ValidParams &= SYNTH_PORTPARAMS_CHANNELGROUPS;
        }

        if (!(Params->ValidParams & SYNTH_PORTPARAMS_CHANNELGROUPS))
        {
            Params->ChannelGroups = 1;
        }
        else if (Params->ChannelGroups != 1)
        {
            Params->ChannelGroups = 1;
        }

        pRequest->ValueSize = sizeof(SYNTH_PORTPARAMS);
    }

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * DMusTimerDPC()
 *****************************************************************************
 * The timer DPC callback. Thunks to a C++ member function.
 * This is called by the OS in response to the DirectMusic pin
 * wanting to wakeup later to process more DirectMusic stuff.
 */
VOID
NTAPI
DMusUARTTimerDPC
(
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArgument1,
    IN  PVOID   SystemArgument2
)
{
    ASSERT(DeferredContext);

    CMiniportDMusUARTStream *aStream;
    aStream = (CMiniportDMusUARTStream *) DeferredContext;
    if (aStream)
    {
        _DbgPrintF(DEBUGLVL_BLAB,("DMusUARTTimerDPC"));
        if (false == aStream->m_fCapture)
        {
            (void) aStream->ConsumeEvents();
        }
        //  ignores return value!
    }
}

/*****************************************************************************
 * DirectMusic properties
 ****************************************************************************/

#pragma code_seg("PAGE")
/*
 *  Properties concerning synthesizer functions.
 */
const WCHAR wszDescOut[] = L"DMusic MPU-401 Out ";
const WCHAR wszDescIn[] = L"DMusic MPU-401 In ";

NTSTATUS PropertyHandler_Synth
(
    IN      PPCPROPERTY_REQUEST     pRequest
)
{
    NTSTATUS    ntStatus;

    PAGED_CODE();

    if (pRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        ntStatus = ValidatePropertyRequest(pRequest, sizeof(ULONG), TRUE);
        if (NT_SUCCESS(ntStatus))
        {
            // if return buffer can hold a ULONG, return the access flags
            PULONG AccessFlags = PULONG(pRequest->Value);

            *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT;
            switch (pRequest->PropertyItem->Id)
            {
                case KSPROPERTY_SYNTH_CAPS:
                case KSPROPERTY_SYNTH_CHANNELGROUPS:
                    *AccessFlags |= KSPROPERTY_TYPE_GET;
            }
            switch (pRequest->PropertyItem->Id)
            {
                case KSPROPERTY_SYNTH_CHANNELGROUPS:
                    *AccessFlags |= KSPROPERTY_TYPE_SET;
            }
            ntStatus = STATUS_SUCCESS;
            pRequest->ValueSize = sizeof(ULONG);

            switch (pRequest->PropertyItem->Id)
            {
                case KSPROPERTY_SYNTH_PORTPARAMETERS:
                    if (pRequest->MinorTarget)
                    {
                        *AccessFlags |= KSPROPERTY_TYPE_GET;
                    }
                    else
                    {
                        pRequest->ValueSize = 0;
                        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                    }
            }
        }
    }
    else
    {
        ntStatus = STATUS_SUCCESS;
        switch(pRequest->PropertyItem->Id)
        {
            case KSPROPERTY_SYNTH_CAPS:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_CAPS"));

                if (pRequest->Verb & KSPROPERTY_TYPE_SET)
                {
                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                }

                if (NT_SUCCESS(ntStatus))
                {
                    ntStatus = ValidatePropertyRequest(pRequest, sizeof(SYNTHCAPS), TRUE);

                    if (NT_SUCCESS(ntStatus))
                    {
                        SYNTHCAPS *caps = (SYNTHCAPS*)pRequest->Value;
                        int increment;
                        RtlZeroMemory(caps, sizeof(SYNTHCAPS));
                        // XXX Different guids for different instances!
                        //
                        if (pRequest->Node == eSynthNode)
                        {
                            increment = sizeof(wszDescOut) - 2;
                            RtlCopyMemory( caps->Description,wszDescOut,increment);
                            caps->Guid           = CLSID_MiniportDriverDMusUART;
                        }
                        else
                        {
                            increment = sizeof(wszDescIn) - 2;
                            RtlCopyMemory( caps->Description,wszDescIn,increment);
                            caps->Guid           = CLSID_MiniportDriverDMusUARTCapture;
                        }

                        caps->Flags              = SYNTH_PC_EXTERNAL;
                        caps->MemorySize         = 0;
                        caps->MaxChannelGroups   = 1;
                        caps->MaxVoices          = 0xFFFFFFFF;
                        caps->MaxAudioChannels   = 0xFFFFFFFF;

                        caps->EffectFlags        = 0;

                        CMiniportDMusUART *aMiniport;
                        ASSERT(pRequest->MajorTarget);
                        aMiniport = (CMiniportDMusUART *)(PMINIPORTDMUS)(pRequest->MajorTarget);
                        WCHAR wszDesc2[16];
                        int cLen;
                        cLen = swprintf(wszDesc2,L"[%03X]\0",PtrToUlong(aMiniport->m_pPortBase));

                        cLen *= sizeof(WCHAR);
                        RtlCopyMemory((WCHAR *)((DWORD_PTR)(caps->Description) + increment),
                                       wszDesc2,
                                       cLen);


                        pRequest->ValueSize = sizeof(SYNTHCAPS);
                    }
                }

                break;

             case KSPROPERTY_SYNTH_PORTPARAMETERS:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_PORTPARAMETERS"));
    {
                CMiniportDMusUARTStream *aStream;

                aStream = (CMiniportDMusUARTStream*)(pRequest->MinorTarget);
                if (aStream)
                {
                    ntStatus = aStream->HandlePortParams(pRequest);
                }
                else
                {
                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
               }
               break;

            case KSPROPERTY_SYNTH_CHANNELGROUPS:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_CHANNELGROUPS"));

                ntStatus = ValidatePropertyRequest(pRequest, sizeof(ULONG), TRUE);
                if (NT_SUCCESS(ntStatus))
                {
                    *(PULONG)(pRequest->Value) = 1;
                    pRequest->ValueSize = sizeof(ULONG);
                }
                break;

            case KSPROPERTY_SYNTH_LATENCYCLOCK:
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Synth:KSPROPERTY_SYNTH_LATENCYCLOCK"));

                if(pRequest->Verb & KSPROPERTY_TYPE_SET)
                {
                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
                else
                {
                    ntStatus = ValidatePropertyRequest(pRequest, sizeof(ULONGLONG), TRUE);
                    if(NT_SUCCESS(ntStatus))
                    {
                        REFERENCE_TIME rtLatency;
                        CMiniportDMusUARTStream *aStream;

                        aStream = (CMiniportDMusUARTStream*)(pRequest->MinorTarget);
                        if(aStream == NULL)
                        {
                            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                        }
                        else
                        {
                            aStream->m_pMiniport->m_MasterClock->GetTime(&rtLatency);
                            *((PULONGLONG)pRequest->Value) = rtLatency;
                            pRequest->ValueSize = sizeof(ULONGLONG);
                        }
                    }
                }
                break;

            default:
                _DbgPrintF(DEBUGLVL_TERSE,("Unhandled property in PropertyHandler_Synth"));
                break;
        }
    }
    return ntStatus;
}

/*****************************************************************************
 * ValidatePropertyRequest()
 *****************************************************************************
 * Validates pRequest.
 *  Checks if the ValueSize is valid
 *  Checks if the Value is valid
 *
 *  This does not update pRequest->ValueSize if it returns NT_SUCCESS.
 *  Caller must set pRequest->ValueSize in case of NT_SUCCESS.
 */
NTSTATUS ValidatePropertyRequest
(
    IN      PPCPROPERTY_REQUEST     pRequest,
    IN      ULONG                   ulValueSize,
    IN      BOOLEAN                 fValueRequired
)
{
    NTSTATUS    ntStatus;

    if (pRequest->ValueSize >= ulValueSize)
    {
        if (fValueRequired && NULL == pRequest->Value)
        {
            ntStatus = STATUS_INVALID_PARAMETER;
        }
        else
        {
            ntStatus = STATUS_SUCCESS;
        }
    }
    else  if (0 == pRequest->ValueSize)
    {
        ntStatus = STATUS_BUFFER_OVERFLOW;
    }
    else
    {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    if (STATUS_BUFFER_OVERFLOW == ntStatus)
    {
        pRequest->ValueSize = ulValueSize;
    }
    else
    {
        pRequest->ValueSize = 0;
    }

    return ntStatus;
} // ValidatePropertyRequest

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\fmsynth\miniport.h ===
//
// Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
//
// ======================================================================
//  miniport.h
//      defines globals used by miniport.cpp
//
// ======================================================================
/* MIDI defines */
#define NUMCHANNELS                     (16)
#define NUMPATCHES                      (256)
#define DRUMCHANNEL                     (9)     /* midi channel 10 */


#define BCODE
#define fEnabled TRUE



#define AsULMUL(a, b) ((DWORD)((DWORD)(a) * (DWORD)(b)))
#define AsLSHL(a, b) ((DWORD)((DWORD)(a) << (DWORD)(b)))
#define AsULSHR(a, b) ((DWORD)((DWORD)(a) >> (DWORD)(b)))

#define AsMemCopy CopyMemory

// indexed FM registers

#define AD_LSI                          (0x000)
#define AD_LSI2                         (0x101)
#define AD_TIMER1                       (0x001)
#define AD_TIMER2                       (0x002)
#define AD_MASK                         (0x004)
#define AD_CONNECTION                   (0x104)
#define AD_NEW                          (0x105)
#define AD_NTS                          (0x008)
#define AD_MULT                         (0x020)
#define AD_MULT2                        (0x120)
#define AD_LEVEL                        (0x040)
#define AD_LEVEL2                       (0x140)
#define AD_AD                           (0x060)
#define AD_AD2                          (0x160)
#define AD_SR                           (0x080)
#define AD_SR2                          (0x180)
#define AD_FNUMBER                      (0x0a0)
#define AD_FNUMBER2                     (0x1a0)
#define AD_BLOCK                        (0x0b0)
#define AD_BLOCK2                       (0x1b0)
#define AD_DRUM                         (0x0bd)
#define AD_FEEDBACK                     (0x0c0)
#define AD_FEEDBACK2                    (0x1c0)
#define AD_WAVE                         (0x0e0)
#define AD_WAVE2                        (0x1e0)

/* transformation of linear velocity value to
        logarithmic attenuation */
BYTE gbVelocityAtten[64] = {
        40, 37, 35, 33, 31, 29, 27, 25, 24, 22, 21, 20, 19, 18, 17, 16,
        16, 15, 14, 14, 13, 13, 12, 12, 11, 11, 10, 10, 9,  9,  8,  8,
        7,  7,  6,  6,  6,  5,  5,  5,  4,  4,  4,  4,  3,  3,  3,  3,
        2,  2,  2,  2,  2,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0 };
/*
                                        o
                                     o
                                   o
                                 o
                               o
                             o
                           o
                         o
                        o
                      o
                     o
                    o
                   o
                  o
                 o
                o
                o
               o
              o
              o
             o
             o
            o
            o
           o
           o
          o
          o
         o
         o
        o
        o
       o
       o
      o
      o
      o
     o
     o
     o
    o
    o
    o
    o
   o
   o
   o
   o
  o
  o
  o
  o
  o
 o
 o
 o
 o
 o
o
o
o
o
o
o
*/

BYTE BCODE gbPercMap[53][2] =
{
   {  0, 35 },
   {  0, 35 },
   {  2, 52 },
   {  3, 48 },
   {  4, 58 },
   {  5, 60 },
   {  6, 47 },
   {  7, 43 },
   {  6, 49 },
   {  9, 43 },
   {  6, 51 },
   { 11, 43 },
   {  6, 54 },
   {  6, 57 },
   { 14, 72 },
   {  6, 60 },
   { 16, 76 },
   { 17, 84 },
   { 18, 36 },
   { 19, 76 },
   { 20, 84 },
   { 21, 83 },
   { 22, 84 },
   { 23, 24 },
   { 16, 77 },
   { 25, 60 },
   { 26, 65 },
   { 27, 59 },
   { 28, 51 },
   { 29, 45 },
   { 30, 71 },
   { 31, 60 },
   { 32, 58 },
   { 33, 53 },
   { 34, 64 },
   { 35, 71 },
   { 36, 61 },
   { 37, 61 },
   { 38, 48 },
   { 39, 48 },
   { 40, 69 },
   { 41, 68 },
   { 42, 63 },
   { 43, 74 },
   { 44, 60 },
   { 45, 80 },
   { 46, 64 },
   { 47, 69 },
   { 48, 73 },
   { 49, 75 },
   { 50, 68 },
   { 51, 48 },
   { 52, 53 }
} ;


/* typedefs for MIDI patches */
#define PATCH_1_4OP             (0) /* use 4-operator patch */
#define PATCH_2_2OP             (1) /* use two 2-operator patches */
#define PATCH_1_2OP             (2) /* use one 2-operator patch */

#define NUM2VOICES   18
#define NUMOPS      4

#pragma pack (1)

typedef struct _operStruct {
    BYTE    bAt20;              /* flags which are send to 0x20 on fm */
    BYTE    bAt40;              /* flags seet to 0x40 */
                                /* the note velocity & midi velocity affect total level */
    BYTE    bAt60;              /* flags sent to 0x60 */
    BYTE    bAt80;              /* flags sent to 0x80 */
    BYTE    bAtE0;              /* flags send to 0xe0 */
} operStruct;

typedef struct _noteStruct {
    operStruct op[NUMOPS];      /* operators */
    BYTE    bAtA0[2];           /* send to 0xA0, A3 */
    BYTE    bAtB0[2];           /* send to 0xB0, B3 */
                                /* use in a patch, the block should be 4 to indicate
                                    normal pitch, 3 => octave below, etc. */
    BYTE    bAtC0[2];           /* sent to 0xc0, C3 */
    BYTE    bOp;                /* see PATCH_??? */
    BYTE    bDummy;             /* place holder */
} noteStruct;


typedef struct _patchStruct {
    noteStruct note;            /* note. This is all in the structure at the moment */
} patchStruct;


#include "patch.h"

#pragma pack()

/* MIDI */

typedef struct _voiceStruct {
        BYTE    bNote;                  /* note played */
        BYTE    bChannel;               /* channel played on */
        BYTE    bPatch;                 /* what patch is the note,
                                           drums patch = drum note + 128 */
        BYTE    bOn;                    /* TRUE if note is on, FALSE if off */
        BYTE    bVelocity;              /* velocity */
        BYTE    bJunk;                  /* filler */
        DWORD   dwTime;                 /* time that was turned on/off;
                                           0 time indicates that its not in use */
        DWORD   dwOrigPitch[2];         /* original pitch, for pitch bend */
        BYTE    bBlock[2];              /* value sent to the block */
        BYTE    bSusHeld;               /* turned off, but held on by sustain */
} voiceStruct;


/* a bit of tuning information */
#define FSAMP                           (50000.0)     /* sampling frequency */
#define PITCH(x)                        ((DWORD)((x) * (double) (1L << 19) / FSAMP))
                            /* x is the desired frequency,
                                == FNUM at b=1 */
#define EQUAL                           (1.059463094359)
#ifdef EUROPE
#       define  A                                                       (442.0)
#else
#       define  A                           (440.0)
#endif
#define ASHARP                          (A * EQUAL)
#define B                               (ASHARP * EQUAL)
#define C                               (B * EQUAL / 2.0)
#define CSHARP                          (C * EQUAL)
#define D                               (CSHARP * EQUAL)
#define DSHARP                          (D * EQUAL)
#define E                               (DSHARP * EQUAL)
#define F                               (E * EQUAL)
#define FSHARP                          (F * EQUAL)
#define G                               (FSHARP * EQUAL)
#define GSHARP                          (G * EQUAL)


/* operator offset location */
static WORD BCODE gw2OpOffset[ NUM2VOICES ][ 2 ] =
   {
     { 0x000,0x003 },
     { 0x001,0x004 },
     { 0x002,0x005 },
     { 0x008,0x00b },
     { 0x009,0x00c },
     { 0x00a,0x00d },
     { 0x010,0x013 },
     { 0x011,0x014 },
     { 0x012,0x015 },

     { 0x100,0x103 },
     { 0x101,0x104 },
     { 0x102,0x105 },
     { 0x108,0x10b },
     { 0x109,0x10c },
     { 0x10a,0x10d },
     { 0x110,0x113 },
     { 0x111,0x114 },
     { 0x112,0x115 },
   } ;

/* pitch values, from middle c, to octave above it */
static DWORD BCODE gdwPitch[12] = {
        PITCH(C), PITCH(CSHARP), PITCH(D), PITCH(DSHARP),
        PITCH(E), PITCH(F), PITCH(FSHARP), PITCH(G),
        PITCH(GSHARP), PITCH(A), PITCH(ASHARP), PITCH(B)};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\dmusuart\mpu.cpp ===
/*****************************************************************************
 * MPU.cpp - UART miniport implementation
 *****************************************************************************
 * Copyright (c) 1998-2000 Microsoft Corporation.  All rights reserved.
 *
 *      Sept 98    MartinP .
 */

#include "private.h"
#include "ksdebug.h"

#define STR_MODULENAME "DMusUART:MPU: "

#define UartFifoOkForWrite(status)  ((status & MPU401_DRR) == 0)
#define UartFifoOkForRead(status)   ((status & MPU401_DSR) == 0)

typedef struct
{
    CMiniportDMusUART  *Miniport;
    PUCHAR              PortBase;
    PVOID               BufferAddress;
    ULONG               Length;
    PULONG              BytesRead;
}
SYNCWRITECONTEXT, *PSYNCWRITECONTEXT;

BOOLEAN  TryMPU(IN PUCHAR PortBase);
NTSTATUS WriteMPU(IN PUCHAR PortBase,IN BOOLEAN IsCommand,IN UCHAR Value);

#pragma code_seg("PAGE")
//  make sure we're in UART mode
NTSTATUS ResetHardware(PUCHAR portBase)
{
    PAGED_CODE();

    return WriteMPU(portBase,COMMAND,MPU401_CMD_UART);
}

#pragma code_seg("PAGE")
//
// We initialize the UART with interrupts suppressed so we don't
// try to service the chip prematurely.
//
NTSTATUS CMiniportDMusUART::InitializeHardware(PINTERRUPTSYNC interruptSync,PUCHAR portBase)
{
    PAGED_CODE();

    NTSTATUS    ntStatus;
    if (m_UseIRQ)
    {
        ntStatus = interruptSync->CallSynchronizedRoutine(InitMPU,PVOID(portBase));
    }
    else
    {
        ntStatus = InitMPU(NULL,PVOID(portBase));
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Start the UART (this should trigger an interrupt).
        //
        ntStatus = ResetHardware(portBase);
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE,("*** InitMPU returned with ntStatus 0x%08x ***",ntStatus));
    }

    m_fMPUInitialized = NT_SUCCESS(ntStatus);

    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * InitMPU()
 *****************************************************************************
 * Synchronized routine to initialize the MPU401.
 */
NTSTATUS
InitMPU
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("InitMPU"));
    if (!DynamicContext)
    {
        return STATUS_INVALID_PARAMETER_2;
    }
        
    PUCHAR      portBase = PUCHAR(DynamicContext);
    UCHAR       status;
    ULONGLONG   startTime;
    BOOLEAN     success;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    
    //
    // Reset the card (puts it into "smart mode")
    //
    ntStatus = WriteMPU(portBase,COMMAND,MPU401_CMD_RESET);

    // wait for the acknowledgement
    // NOTE: When the Ack arrives, it will trigger an interrupt.  
    //       Normally the DPC routine would read in the ack byte and we
    //       would never see it, however since we have the hardware locked (HwEnter),
    //       we can read the port before the DPC can and thus we receive the Ack.
    startTime = PcGetTimeInterval(0);
    success = FALSE;
    while(PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        status = READ_PORT_UCHAR(portBase + MPU401_REG_STATUS);
        
        if (UartFifoOkForRead(status))                      // Is data waiting?
        {
            READ_PORT_UCHAR(portBase + MPU401_REG_DATA);    // yep.. read ACK 
            success = TRUE;                                 // don't need to do more 
            break;
        }
        KeStallExecutionProcessor(25);  //  microseconds
    }
#if (DBG)
    if (!success)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("First attempt to reset the MPU didn't get ACKed.\n"));
    }
#endif  //  (DBG)

    // NOTE: We cannot check the ACK byte because if the card was already in
    // UART mode it will not send an ACK but it will reset.

    // reset the card again
    (void) WriteMPU(portBase,COMMAND,MPU401_CMD_RESET);

                                    // wait for ack (again)
    startTime = PcGetTimeInterval(0); // This might take a while
    BYTE dataByte = 0;
    success = FALSE;
    while (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        status = READ_PORT_UCHAR(portBase + MPU401_REG_STATUS);
        if (UartFifoOkForRead(status))                              // Is data waiting?
        {
            dataByte = READ_PORT_UCHAR(portBase + MPU401_REG_DATA); // yep.. read ACK
            success = TRUE;                                         // don't need to do more
            break;
        }
        KeStallExecutionProcessor(25);
    }

    if ((0xFE != dataByte) || !success)   // Did we succeed? If no second ACK, something is hosed  
    {                       
        _DbgPrintF(DEBUGLVL_TERSE,("Second attempt to reset the MPU didn't get ACKed.\n"));
        _DbgPrintF(DEBUGLVL_TERSE,("Init Reset failure error. Ack = %X", ULONG(dataByte) ) );
        ntStatus = STATUS_IO_DEVICE_ERROR;
    }
    
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * CMiniportDMusUARTStream::Write()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUARTStream::
Write
(
    IN      PVOID       BufferAddress,
    IN      ULONG       Length,
    OUT     PULONG      BytesWritten
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("Write"));
    ASSERT(BytesWritten);
    if (!BufferAddress)
    {
        Length = 0;
    }

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (!m_fCapture)
    {
        PUCHAR  pMidiData;
        ULONG   count;

        count = 0;
        pMidiData = PUCHAR(BufferAddress);

        if (Length)
        {
            SYNCWRITECONTEXT context;
            context.Miniport        = (m_pMiniport);
            context.PortBase        = m_pPortBase;
            context.BufferAddress   = pMidiData;
            context.Length          = Length;
            context.BytesRead       = &count;

            if (m_pMiniport->m_UseIRQ)
            {
                ntStatus = m_pMiniport->m_pInterruptSync->
                                CallSynchronizedRoutine(SynchronizedDMusMPUWrite,PVOID(&context));
            }
            else    //  !m_UseIRQ
            {
                ntStatus = SynchronizedDMusMPUWrite(NULL,PVOID(&context));
            }       //  !m_UseIRQ

            if (count == 0)
            {
                m_NumFailedMPUTries++;
                if (m_NumFailedMPUTries >= 100)
                {
                    ntStatus = STATUS_IO_DEVICE_ERROR;
                    m_NumFailedMPUTries = 0;
                }
            }
            else
            {
                m_NumFailedMPUTries = 0;
            }
        }           //  if we have data at all
        *BytesWritten = count;
    }
    else    //  called write on the read stream
    {
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * SynchronizedDMusMPUWrite()
 *****************************************************************************
 * Writes outgoing MIDI data.
 */
NTSTATUS
SynchronizedDMusMPUWrite
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           syncWriteContext
)
{
    PSYNCWRITECONTEXT context;
    context = (PSYNCWRITECONTEXT)syncWriteContext;
    ASSERT(context->Miniport);
    ASSERT(context->PortBase);
    ASSERT(context->BufferAddress);
    ASSERT(context->Length);
    ASSERT(context->BytesRead);

    PUCHAR  pChar = PUCHAR(context->BufferAddress);
    NTSTATUS ntStatus,readStatus;
    ntStatus = STATUS_SUCCESS;
    //
    // while we're not there yet, and
    // while we don't have to wait on an aligned byte (including 0)
    // (we never wait on a byte.  Better to come back later)
    readStatus = DMusMPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
    while (  (*(context->BytesRead) < context->Length)
          && (  TryMPU(context->PortBase) 
             || (*(context->BytesRead)%3)
          )  )
    {
        ntStatus = WriteMPU(context->PortBase,DATA,*pChar);
        if (NT_SUCCESS(ntStatus))
        {
            pChar++;
            *(context->BytesRead) = *(context->BytesRead) + 1;
//            readStatus = DMusMPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("SynchronizedDMusMPUWrite failed (0x%08x)",ntStatus));
            break;
        }
    }
    readStatus = DMusMPUInterruptServiceRoutine(InterruptSync,PVOID(context->Miniport));
    return ntStatus;
}

#define kMPUPollTimeout 2

#pragma code_seg()
/*****************************************************************************
 * TryMPU()
 *****************************************************************************
 * See if the MPU401 is free.
 */
BOOLEAN
TryMPU
(
    IN      PUCHAR      PortBase
)
{
    BOOLEAN success;
    USHORT  numPolls;
    UCHAR   status;

    _DbgPrintF(DEBUGLVL_BLAB, ("TryMPU"));
    numPolls = 0;

    while (numPolls < kMPUPollTimeout)
    {
        status = READ_PORT_UCHAR(PortBase + MPU401_REG_STATUS);
                                       
        if (UartFifoOkForWrite(status)) // Is this a good time to write data?
        {
            break;
        }
        numPolls++;
    }
    if (numPolls >= kMPUPollTimeout)
    {
        success = FALSE;
        _DbgPrintF(DEBUGLVL_BLAB, ("TryMPU failed"));
    }
    else
    {
        success = TRUE;
    }

    return success;
}

#pragma code_seg()
/*****************************************************************************
 * WriteMPU()
 *****************************************************************************
 * Write a byte out to the MPU401.
 */
NTSTATUS
WriteMPU
(
    IN      PUCHAR      PortBase,
    IN      BOOLEAN     IsCommand,
    IN      UCHAR       Value
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("WriteMPU"));
    NTSTATUS ntStatus = STATUS_IO_DEVICE_ERROR;

    if (!PortBase)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("O: PortBase is zero\n"));
        return ntStatus;
    }
    PUCHAR deviceAddr = PortBase + MPU401_REG_DATA;

    if (IsCommand)
    {
        deviceAddr = PortBase + MPU401_REG_COMMAND;
    }

    ULONGLONG startTime = PcGetTimeInterval(0);
    
    while (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50))
    {
        UCHAR status
        = READ_PORT_UCHAR(PortBase + MPU401_REG_STATUS);

        if (UartFifoOkForWrite(status)) // Is this a good time to write data?
        {                               // yep (Jon comment)
            WRITE_PORT_UCHAR(deviceAddr,Value);
            _DbgPrintF(DEBUGLVL_BLAB, ("WriteMPU emitted 0x%02x",Value));
            ntStatus = STATUS_SUCCESS;
            break;
        }
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * SnapTimeStamp()
 *****************************************************************************
 *
 * At synchronized execution to ISR, copy miniport's volatile m_InputTimeStamp 
 * to stream's m_SnapshotTimeStamp and zero m_InputTimeStamp.
 *
 */
STDMETHODIMP_(NTSTATUS) 
SnapTimeStamp(PINTERRUPTSYNC InterruptSync,PVOID pStream)
{
    CMiniportDMusUARTStream *pMPStream = (CMiniportDMusUARTStream *)pStream;

    //  cache the timestamp
    pMPStream->m_SnapshotTimeStamp = pMPStream->m_pMiniport->m_InputTimeStamp;

    //  if the window is closed, zero the timestamp
    if (pMPStream->m_pMiniport->m_MPUInputBufferHead == 
        pMPStream->m_pMiniport->m_MPUInputBufferTail)
    {
        pMPStream->m_pMiniport->m_InputTimeStamp = 0;
    }

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CMiniportDMusUARTStream::SourceEvtsToPort()
 *****************************************************************************
 *
 * Reads incoming MIDI data, feeds into DMus events.
 * No need to touch the hardware, just read from our SW FIFO.
 *
 */
STDMETHODIMP_(NTSTATUS)
CMiniportDMusUARTStream::SourceEvtsToPort()
{
    NTSTATUS    ntStatus;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    _DbgPrintF(DEBUGLVL_BLAB, ("SourceEvtsToPort"));

    if (m_fCapture)
    {
        ntStatus = STATUS_SUCCESS;
        if (m_pMiniport->m_MPUInputBufferHead != m_pMiniport->m_MPUInputBufferTail)
        {
            PDMUS_KERNEL_EVENT  aDMKEvt,eventTail,eventHead = NULL;

            while (m_pMiniport->m_MPUInputBufferHead != m_pMiniport->m_MPUInputBufferTail)
            {
                (void) m_AllocatorMXF->GetMessage(&aDMKEvt);
                if (!aDMKEvt)
                {
                    _DbgPrintF(DEBUGLVL_TERSE, ("SourceEvtsToPort can't allocate DMKEvt"));
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                //  put this event at the end of the list
                if (!eventHead)
                {
                    eventHead = aDMKEvt;
                }
                else
                {
                    eventTail = eventHead;
                    while (eventTail->pNextEvt)
                    {
                        eventTail = eventTail->pNextEvt;
                    }
                    eventTail->pNextEvt = aDMKEvt;
                }
                //  read all the bytes out of the buffer, into event(s)
                for (aDMKEvt->cbEvent = 0; aDMKEvt->cbEvent < sizeof(PBYTE); aDMKEvt->cbEvent++)
                {
                    if (m_pMiniport->m_MPUInputBufferHead == m_pMiniport->m_MPUInputBufferTail)
                    {
//                        _DbgPrintF(DEBUGLVL_TERSE, ("SourceEvtsToPort m_MPUInputBufferHead met m_MPUInputBufferTail, overrun"));
                        break;
                    }
                    aDMKEvt->uData.abData[aDMKEvt->cbEvent] = m_pMiniport->m_MPUInputBuffer[m_pMiniport->m_MPUInputBufferHead];
                    m_pMiniport->m_MPUInputBufferHead++;
                    if (m_pMiniport->m_MPUInputBufferHead >= kMPUInputBufferSize)
                    {
                        m_pMiniport->m_MPUInputBufferHead = 0;
                    }
                }
            }

            if (m_pMiniport->m_UseIRQ)
            {
                ntStatus = m_pMiniport->m_pInterruptSync->CallSynchronizedRoutine(SnapTimeStamp,PVOID(this));
            }
            else    //  !m_UseIRQ
            {
                ntStatus = SnapTimeStamp(NULL,PVOID(this));
            }       //  !m_UseIRQ
            aDMKEvt = eventHead;
            while (aDMKEvt)
            {
                aDMKEvt->ullPresTime100ns = m_SnapshotTimeStamp;
                aDMKEvt->usChannelGroup = 1;
                aDMKEvt->usFlags = DMUS_KEF_EVENT_INCOMPLETE;
                aDMKEvt = aDMKEvt->pNextEvt;
            }
            (void)m_sinkMXF->PutMessage(eventHead);
        }
    }
    else    //  render stream
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("SourceEvtsToPort called on render stream"));
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    return ntStatus;
}

#pragma code_seg()
/*****************************************************************************
 * DMusMPUInterruptServiceRoutine()
 *****************************************************************************
 * ISR.
 */
NTSTATUS
DMusMPUInterruptServiceRoutine
(
    IN      PINTERRUPTSYNC  InterruptSync,
    IN      PVOID           DynamicContext
)
{
    _DbgPrintF(DEBUGLVL_BLAB, ("DMusMPUInterruptServiceRoutine"));
    ULONGLONG   startTime;

    ASSERT(DynamicContext);

    NTSTATUS            ntStatus;
    BOOL                newBytesAvailable;
    CMiniportDMusUART   *that;
    NTSTATUS            clockStatus;

    that = (CMiniportDMusUART *) DynamicContext;
    newBytesAvailable = FALSE;
    ntStatus = STATUS_UNSUCCESSFUL;

    UCHAR portStatus = 0xff;

    //
    // Read the MPU status byte.
    //
    if (that->m_pPortBase)
    {
        portStatus =
            READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_STATUS);

        //
        // If there is outstanding work to do and there is a port-driver for
        // the MPU miniport...
        //
        if (UartFifoOkForRead(portStatus) && that->m_pPort)
        {
            startTime = PcGetTimeInterval(0);
            while ( (PcGetTimeInterval(startTime) < GTI_MILLISECONDS(50)) 
                &&  (UartFifoOkForRead(portStatus)) )
            {
                UCHAR uDest = READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_DATA);
                if (    (that->m_KSStateInput == KSSTATE_RUN) 
                    &&  (that->m_NumCaptureStreams)
                   )
                {
                    LONG    buffHead = that->m_MPUInputBufferHead;
                    if (   (that->m_MPUInputBufferTail + 1 == buffHead)
                        || (that->m_MPUInputBufferTail + 1 - kMPUInputBufferSize == buffHead))
                    {
                        _DbgPrintF(DEBUGLVL_TERSE,("*****MPU Input Buffer Overflow*****"));
                    }
                    else
                    {
                        if (!that->m_InputTimeStamp)
                        {
                            clockStatus = that->m_MasterClock->GetTime(&that->m_InputTimeStamp);
                            if (STATUS_SUCCESS != clockStatus)
                            {
                                _DbgPrintF(DEBUGLVL_TERSE,("GetTime failed for clock 0x%08x",that->m_MasterClock));
                            }
                        }
                        newBytesAvailable = TRUE;
                        //  ...place the data in our FIFO...
                        that->m_MPUInputBuffer[that->m_MPUInputBufferTail] = uDest;
                        ASSERT(that->m_MPUInputBufferTail < kMPUInputBufferSize);
                        
                        that->m_MPUInputBufferTail++;
                        if (that->m_MPUInputBufferTail >= kMPUInputBufferSize)
                        {
                            that->m_MPUInputBufferTail = 0;
                        }
                    } 
                }
                //
                // Look for more MIDI data.
                //
                portStatus =
                    READ_PORT_UCHAR(that->m_pPortBase + MPU401_REG_STATUS);
            }   //  either there's no data or we ran too long
            if (newBytesAvailable)
            {
                //
                // ...notify the MPU port driver that we have bytes.
                //
                that->m_pPort->Notify(that->m_pServiceGroup);
            }
            ntStatus = STATUS_SUCCESS;
        }
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\fmsynth\miniport.cpp ===
// ==============================================================================
//
// miniport.cpp - miniport driver implementation for FM synth.
// Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//
// ==============================================================================

#include "private.h"    // contains class definitions.

#define STR_MODULENAME "FMSynth: "


#pragma code_seg("PAGE")
// ==============================================================================
// CreateMiniportMidiFM()
// Creates a MIDI FM miniport driver.  This uses a
// macro from STDUNK.H to do all the work.
// ==============================================================================
NTSTATUS CreateMiniportMidiFM
(
OUT     PUNKNOWN *  Unknown,
IN      REFCLSID    ClassID,
IN      PUNKNOWN    UnknownOuter    OPTIONAL,
IN      POOL_TYPE   PoolType
)
{
    PAGED_CODE();

    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CreateMiniportMidiFM"));

//  expand STD_CREATE_BODY_ to take constructor(boolean) for whether to include volume
    NTSTATUS ntStatus;
    CMiniportMidiFM *p =  
        new(PoolType,'MFcP') CMiniportMidiFM(
                                 UnknownOuter,
                                 (IsEqualGUIDAligned(ClassID,CLSID_MiniportDriverFmSynthWithVol))
                             );

#ifdef DEBUG
    if (IsEqualGUIDAligned(ClassID,CLSID_MiniportDriverFmSynthWithVol))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Creating new FM miniport with volume node"));
    }
#endif
    if (p)
    {
        *Unknown = PUNKNOWN((PMINIPORTMIDI)(p));
        (*Unknown)->AddRef();
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    return ntStatus;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiFM::ProcessResources()
// Processes the resource list.
// ==============================================================================
NTSTATUS
CMiniportMidiFM::
ProcessResources
(
IN  PRESOURCELIST   ResourceList
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::ProcessResources"));

    //
    // Get counts for the types of resources.
    //
    ULONG       countIO     = ResourceList->NumberOfPorts();
    ULONG       countIRQ    = ResourceList->NumberOfInterrupts();
    ULONG       countDMA    = ResourceList->NumberOfDmas();

    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // Make sure we have the expected number of resources.
    //
    if  (   (countIO != 1)
        ||  (countIRQ != 0)
        ||  (countDMA != 0)
        )
    {
        ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
    }

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Get the port address.
        //
        m_PortBase = PUCHAR(ResourceList->FindTranslatedPort(0)->u.Port.Start.QuadPart);
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Port Address = 0x%X", m_PortBase));
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiFM::NonDelegatingQueryInterface()
// Obtains an interface.  This function works just like a COM QueryInterface
// call and is used if the object is not being aggregated.
// ==============================================================================
STDMETHODIMP_(NTSTATUS) CMiniportMidiFM::NonDelegatingQueryInterface
(
REFIID  Interface,
PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::NonDelegatingQueryInterface"));

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORT(this)));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface,IID_IMiniportMidi))
    {
        *Object = PVOID(PMINIPORTMIDI(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IPowerNotify))
    {
        *Object = PVOID(PPOWERNOTIFY(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN((PMINIPORT)*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg()
// ==============================================================================
// CMiniportMidiFM::~CMiniportMidiFM()
// Destructor.
// ==============================================================================
CMiniportMidiFM::~CMiniportMidiFM
(
void
)
{
    KIRQL   oldIrql;
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::~CMiniportMidiFM"));

    KeAcquireSpinLock(&m_SpinLock,&oldIrql);
    // Set silence on the device
    Opl3_BoardReset();

    KeReleaseSpinLock(&m_SpinLock,oldIrql);

    if (m_Port)
    {
        m_Port->Release();
    }
}

#pragma code_seg()
// ==============================================================================
// CMiniportMidiFM::Init()
// Initializes a the miniport.
// ==============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportMidiFM::
Init
(
    IN      PUNKNOWN        UnknownAdapter  OPTIONAL,
    IN      PRESOURCELIST   ResourceList,
    IN      PPORTMIDI       Port_,
    OUT     PSERVICEGROUP * ServiceGroup
)
{
    PAGED_CODE();

    ASSERT(ResourceList);
    if (!ResourceList)
    {
        return STATUS_DEVICE_CONFIGURATION_ERROR;
    }
    ASSERT(Port_);
    ASSERT(ServiceGroup);

    int i;
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::init"));

    //
    // AddRef() is required because we are keeping this pointer.
    //
    m_Port = Port_;
    m_Port->AddRef();

    //
    // m_fStreamExists is not explicitly set to FALSE because C++ zeros 
    // them out on a 'new'
    //

    KeInitializeSpinLock(&m_SpinLock);
    //
    // We want the IAdapterCommon interface on the adapter common object,
    // which is given to us as a IUnknown.  The QueryInterface call gives us
    // an AddRefed pointer to the interface we want.
    //
    NTSTATUS ntStatus = ProcessResources(ResourceList);

    if (NT_SUCCESS(ntStatus))
    {
        KIRQL oldIrql;
        KeAcquireSpinLock(&m_SpinLock,&oldIrql);

        for (i = 0; i < 0x200; i++)    // initialize the shadow registers, used
           m_SavedRegValues[i] = 0x00; // in case of power-down during playback

        // Initialize the hardware.
        // 1. First check to see if an opl device is present.
        // 2. Then determine if it is an opl2 or opl3. Bail if opl2.
        // 3. Call Opl3_BoardReset to silence and reset the device.
        if (SoundSynthPresent(m_PortBase, m_PortBase))
        {
            // Now check if the device is an opl2 or opl3 type.
            // The patches are already declared for opl3. So Init() is not defined.
            // For opl2 we have to go through an init and load the patches structure.
            if (SoundMidiIsOpl3())
            {
                _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiFM::Init Type = OPL3"));
                // now silence the device and reset the board.
                Opl3_BoardReset();

                *ServiceGroup = NULL;
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiFM::Init Type = OPL2"));
                ntStatus = STATUS_NOT_IMPLEMENTED;                
            }

        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiFM::Init SoundSynthPresent failed"));
            ntStatus = STATUS_DEVICE_CONFIGURATION_ERROR;
        }
        KeReleaseSpinLock(&m_SpinLock,oldIrql);
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiFM::Init ProcessResources failed"));
    }

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiFM::Init returning 0x%X", ntStatus));

    if (!NT_SUCCESS(ntStatus))
    {
        //
        // clean up our mess
        //

        // release the port
        m_Port->Release();
        m_Port = NULL;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
// ==============================================================================
// NewStream()
// Creates a new stream.
// ==============================================================================
STDMETHODIMP_(NTSTATUS) 
CMiniportMidiFM::
NewStream
(
    OUT     PMINIPORTMIDISTREAM *   Stream,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      POOL_TYPE               PoolType,
    IN      ULONG                   Pin,
    IN      BOOLEAN                 Capture,
    IN      PKSDATAFORMAT           DataFormat,
    OUT     PSERVICEGROUP *         ServiceGroup
)
{
    PAGED_CODE();

    NTSTATUS ntStatus = STATUS_SUCCESS;

    if (m_fStreamExists)
    {
        _DbgPrintF(DEBUGLVL_TERSE,("CMiniportMidiFM::NewStream stream already exists"));
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }
    else
    {
        _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::NewStream"));
        CMiniportMidiStreamFM *pStream =
            new(PoolType) CMiniportMidiStreamFM(OuterUnknown);

        if (pStream)
        {
            pStream->AddRef();

            ntStatus = pStream->Init(this,m_PortBase);

            if (NT_SUCCESS(ntStatus))
            {
                *Stream = PMINIPORTMIDISTREAM(pStream);
                (*Stream)->AddRef();

                *ServiceGroup = NULL;
                m_fStreamExists = TRUE;
            }

            pStream->Release();
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE,("CMiniportMidiFM::NewStream failed, no memory"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*----------------------------------------------------------------------------
 FUNCTION NAME- CMiniportMidiFM::PowerChangeNotify()
 ENTRY      --- IN  POWER_STATE     NewState
                        power management status
 RETURN     --- void
 *------------------------------------------------------------------------- */
STDMETHODIMP_(void) CMiniportMidiFM::PowerChangeNotify(
    IN  POWER_STATE     PowerState
) 
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::PowerChangeNotify(%d)",PowerState));

    switch (PowerState.DeviceState)
    {
        case PowerDeviceD0:
            if (m_PowerState.DeviceState != PowerDeviceD0) // check for power state delta
            {
                MiniportMidiFMResume();
            }
            break;

        case PowerDeviceD1:
        case PowerDeviceD2:
        case PowerDeviceD3:
        default:
            //  Don't need to do anything special, we always remember where we are.
            break;
    }
    m_PowerState.DeviceState = PowerState.DeviceState;
}

#pragma code_seg()
// ==========================================================================
// ==========================================================================
void
CMiniportMidiFM::
MiniportMidiFMResume()
{
    KIRQL   oldIrql;
    BYTE    i;
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::MiniportMidiFMResume"));
    KeAcquireSpinLock(&m_SpinLock,&oldIrql);
    //  We never touch these--set them to the default value anyway.
    //  AD_LSI
    SoundMidiSendFM(m_PortBase, AD_LSI, m_SavedRegValues[AD_LSI]);
    //  AD_LSI2
    SoundMidiSendFM(m_PortBase, AD_LSI2, m_SavedRegValues[AD_LSI2]);
    //  AD_TIMER1
    SoundMidiSendFM(m_PortBase, AD_TIMER1, m_SavedRegValues[AD_TIMER1]);
    //  AD_TIMER2
    SoundMidiSendFM(m_PortBase, AD_TIMER2, m_SavedRegValues[AD_TIMER2]);

    //  AD_MASK
    SoundMidiSendFM(m_PortBase, AD_MASK, m_SavedRegValues[AD_MASK]);
    
    //  AD_CONNECTION
    SoundMidiSendFM(m_PortBase, AD_CONNECTION, m_SavedRegValues[AD_CONNECTION]);

    //  AD_NEW
    SoundMidiSendFM(m_PortBase, AD_NEW, m_SavedRegValues[AD_NEW]);
    
    //  AD_NTS
    SoundMidiSendFM(m_PortBase, AD_NTS, m_SavedRegValues[AD_NTS]);
  
    //  AD_DRUM
    SoundMidiSendFM(m_PortBase, AD_DRUM, m_SavedRegValues[AD_DRUM]);
  
    for (i = 0; i <= 0x15; i++) 
    {
        if ((i & 0x07) <= 0x05)
        {
            //  AD_MULT
            //  AD_MULT2
            SoundMidiSendFM(m_PortBase, AD_MULT + i, m_SavedRegValues[AD_MULT + i]);
            SoundMidiSendFM(m_PortBase, AD_MULT2 + i, m_SavedRegValues[AD_MULT2 + i]);

            //  AD_LEVEL
            //  AD_LEVEL2
            //  turn off all the oscillators
            SoundMidiSendFM(m_PortBase, AD_LEVEL + i, m_SavedRegValues[AD_LEVEL + i]);
            SoundMidiSendFM(m_PortBase, AD_LEVEL2 + i, m_SavedRegValues[AD_LEVEL2 + i]);

            //  AD_AD
            //  AD_AD2
            SoundMidiSendFM(m_PortBase, AD_AD + i, m_SavedRegValues[AD_AD + i]);
            SoundMidiSendFM(m_PortBase, AD_AD2 + i, m_SavedRegValues[AD_AD2 + i]);

            //  AD_SR
            //  AD_SR2
            SoundMidiSendFM(m_PortBase, AD_SR + i, m_SavedRegValues[AD_SR + i]);
            SoundMidiSendFM(m_PortBase, AD_SR2 + i, m_SavedRegValues[AD_SR2 + i]);

            //  AD_WAVE
            //  AD_WAVE2
            SoundMidiSendFM(m_PortBase, AD_WAVE + i, m_SavedRegValues[AD_WAVE + i]);
            SoundMidiSendFM(m_PortBase, AD_WAVE2 + i, m_SavedRegValues[AD_WAVE2 + i]);
        }
    }
    
    for (i = 0; i <= 0x08; i++) 
    {
        //  AD_FNUMBER
        //  AD_FNUMBER2
        SoundMidiSendFM(m_PortBase, AD_FNUMBER + i, m_SavedRegValues[AD_FNUMBER + i]);
        SoundMidiSendFM(m_PortBase, AD_FNUMBER2 + i, m_SavedRegValues[AD_FNUMBER2 + i]);

        //  AD_FEEDBACK
        //  AD_FEEDBACK2
        SoundMidiSendFM(m_PortBase, AD_FEEDBACK + i, m_SavedRegValues[AD_FEEDBACK + i]);
        SoundMidiSendFM(m_PortBase, AD_FEEDBACK2 + i, m_SavedRegValues[AD_FEEDBACK2 + i]);

        //  AD_BLOCK
        //  AD_BLOCK2
        SoundMidiSendFM(m_PortBase, AD_BLOCK + i, m_SavedRegValues[AD_BLOCK + i]);
        SoundMidiSendFM(m_PortBase, AD_BLOCK2 + i, m_SavedRegValues[AD_BLOCK2 + i]);
    }
    KeReleaseSpinLock(&m_SpinLock,oldIrql);

    _DbgPrintF(DEBUGLVL_VERBOSE,("Done with CMiniportMidiFM::MiniportMidiFMResume"));
}

#pragma code_seg()
void 
CMiniportMidiFM::
Opl3_BoardReset()
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    BYTE i;
    
    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::Opl3_BoardReset"));
    /* ---- silence the chip -------- */

    /* tell the FM chip to use 4-operator mode, and
    fill in any other random variables */
    SoundMidiSendFM(m_PortBase, AD_NEW, 0x01);
    SoundMidiSendFM(m_PortBase, AD_MASK, 0x60);
    SoundMidiSendFM(m_PortBase, AD_CONNECTION, 0x00);
    SoundMidiSendFM(m_PortBase, AD_NTS, 0x00);

    /* turn off the drums, and use high vibrato/modulation */
    SoundMidiSendFM(m_PortBase, AD_DRUM, 0xc0);

    /* turn off all the oscillators */
    for (i = 0; i <= 0x15; i++) 
    {
        if ((i & 0x07) <= 0x05)
        {
            SoundMidiSendFM(m_PortBase, AD_LEVEL + i, 0x3f);
            SoundMidiSendFM(m_PortBase, AD_LEVEL2 + i, 0x3f);
        }
    };

    /* turn off all the voices */
    for (i = 0; i <= 0x08; i++) 
    {
        SoundMidiSendFM(m_PortBase, AD_BLOCK + i, 0x00);
        SoundMidiSendFM(m_PortBase, AD_BLOCK2 + i, 0x00);
    };
}


// ==============================================================================
// PinDataRangesStream
// Structures indicating range of valid format values for streaming pins.
// ==============================================================================
static
KSDATARANGE_MUSIC PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_MUSIC),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
        },
        STATICGUIDOF(KSMUSIC_TECHNOLOGY_FMSYNTH),
        NUM2VOICES,
        NUM2VOICES,
        0xffffffff
    }
};

// ==============================================================================
// PinDataRangePointersStream
// List of pointers to structures indicating range of valid format values
// for streaming pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

// ==============================================================================
// PinDataRangesBridge
// Structures indicating range of valid format values for bridge pins.
// ==============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI_BUS),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

// ==============================================================================
// PinDataRangePointersBridge
// List of pointers to structures indicating range of valid format values
// for bridge pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

// ==============================================================================
// MiniportPins
// List of pins.
// ==============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    {
        1,1,1,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStream),   // DataRangesCount
            PinDataRangePointersStream,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            (GUID *) &KSCATEGORY_SYNTHESIZER,           // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
};

/*****************************************************************************
 * PropertiesVolume
 *****************************************************************************
 * Properties for volume controls.
 */
static
PCPROPERTY_ITEM PropertiesVolume[] =
{
    { 
        &KSPROPSETID_Audio, 
        KSPROPERTY_AUDIO_VOLUMELEVEL,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_BASICSUPPORT,
        PropertyHandler_Level
    },
    {
        &KSPROPSETID_Audio,
        KSPROPERTY_AUDIO_CPU_RESOURCES,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_CpuResources
    }
};

/*****************************************************************************
 * AutomationVolume
 *****************************************************************************
 * Automation table for volume controls.
 */
DEFINE_PCAUTOMATION_TABLE_PROP(AutomationVolume,PropertiesVolume);

// ==============================================================================
// MiniportNodes
// List of nodes.
// ==============================================================================
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    {
            // synth node, #0
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_SYNTHESIZER,// Type
        NULL                    // Name TODO: fill in with correct GUID
    },
    {
            // volume node, #1
        0,                      // Flags
        &AutomationVolume,      // AutomationTable
        &KSNODETYPE_VOLUME,     // Type
        NULL                    // Name TODO: fill in with correct GUID
    }
};

// ==============================================================================
// MiniportConnections
// List of connections.
// ==============================================================================

/*****************************************************************************
 *      Table of topology unit connections.
 *
 * Pin numbering is technically arbitrary, but the convention established here
 * is to number a solitary output pin 0 (looks like an 'o') and a solitary
 * input pin 1 (looks like an 'i').  Even destinations, which have no output,
 * have an input pin numbered 1 and no pin 0.
 *
 * Nodes are more likely to have multiple ins than multiple outs, so the more
 * general rule would be that inputs are numbered >=1.  If a node has multiple
 * outs, none of these conventions apply.
 *
 * Nodes have at most one control value.  Mixers are therefore simple summing
 * nodes with no per-pin levels.  Rather than assigning a unique pin to each
 * input to a mixer, all inputs are connected to pin 1.  This is acceptable
 * because there is no functional distinction between the inputs.
 *
 * There are no multiplexers in this topology, so there is no opportunity to
 * give an example of a multiplexer.  A multiplexer should have a single
 * output pin (0) and multiple input pins (1..n).  Its control value is an
 * integer in the range 1..n indicating which input is connected to the
 * output.
 *
 * In the case of connections to pins, as opposed to connections to nodes, the
 * node is identified as PCFILTER_NODE and the pin number identifies the
 * particular filter pin.
 *****************************************************************************
 */
enum {
    eFMSynthNode  = 0,
    eFMVolumeNode
};

enum {
    eFMNodeOutput = 0,
    eFMNodeInput  = 1
};

enum {
    eFilterInput = eFMNodeOutput,
    eBridgeOutput = eFMNodeInput
};

static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    //  FromNode,       FromPin,        ToNode,         ToPin
    {   PCFILTER_NODE,  eFilterInput,   eFMSynthNode,   eFMNodeInput }, // Stream in to synth.
    {   eFMSynthNode,   eFMNodeOutput,  PCFILTER_NODE,  eBridgeOutput } // Synth to bridge out.
};

// different connection struct for volume version
static
PCCONNECTION_DESCRIPTOR MiniportWithVolConnections[] =
{
    //  FromNode,       FromPin,        ToNode,         ToPin
    {   PCFILTER_NODE,  eFilterInput,   eFMSynthNode,   eFMNodeInput }, // Stream in to synth.
    {   eFMSynthNode,   eFMNodeOutput,  eFMVolumeNode,  eFMNodeInput }, // Synth to volume.
    {   eFMVolumeNode,  eFMNodeOutput,  PCFILTER_NODE,  eBridgeOutput } // volume to bridge out.
};

////////////////////////////////////////////////////////////////////////////////
// MiniportCategories
//
// List of categories.
static
GUID MiniportCategories[] =
{
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_RENDER),
    STATICGUIDOF(KSCATEGORY_SYNTHESIZER)
};

// ==============================================================================
// MiniportDescription
// Complete description of the miniport.
// ==============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    1,                                  // NodeCount - no volume node
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    SIZEOF_ARRAY(MiniportCategories),   // CategoryCount
    MiniportCategories                  // Categories
};

static
PCFILTER_DESCRIPTOR MiniportFilterWithVolDescriptor =
{
    0,                                          // Version
    NULL,                                       // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),                   // PinSize
    SIZEOF_ARRAY(MiniportPins),                 // PinCount
    MiniportPins,                               // Pins
    sizeof(PCNODE_DESCRIPTOR),                  // NodeSize
    2,                                          // NodeCount - extra volume node
    MiniportNodes,                              // Nodes
    SIZEOF_ARRAY(MiniportWithVolConnections),   // ConnectionCount
    MiniportWithVolConnections,                 // Connections
    0,                                          // CategoryCount
    NULL                                        // Categories
};

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiFM::GetDescription()
// Gets the topology.
// Pass back appropriate descriptor, depending on whether volume node is needed.
// ==============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportMidiFM::
GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiFM::GetDescription"));

    if (m_volNodeNeeded)
    {
        *OutFilterDescriptor = &MiniportFilterWithVolDescriptor;
        _DbgPrintF(DEBUGLVL_VERBOSE, ("Getting descriptor of new FM miniport with volume node"));
    }
    else
    {
        *OutFilterDescriptor = &MiniportFilterDescriptor;
    }

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::NonDelegatingQueryInterface()
// Obtains an interface.  This function works just like a COM QueryInterface
// call and is used if the object is not being aggregated.
// ==============================================================================
STDMETHODIMP_(NTSTATUS) CMiniportMidiStreamFM::NonDelegatingQueryInterface
(
REFIID  Interface,
PVOID * Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::NonDelegatingQueryInterface"));

    if (IsEqualGUIDAligned(Interface,IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORT(this)));
    }
    else
    if (IsEqualGUIDAligned(Interface,IID_IMiniportMidiStream))
    {
        *Object = PVOID(PMINIPORTMIDISTREAM(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(PMINIPORT(*Object))->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::~CMiniportMidiStreamFM()
// Destructor.
// ==============================================================================
CMiniportMidiStreamFM::~CMiniportMidiStreamFM
(
void
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::~CMiniportMidiStreamFM"));

    Opl3_AllNotesOff();

    if (m_Miniport)
    {
        m_Miniport->m_fStreamExists = FALSE;
        m_Miniport->Release();
    }
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::Init()
// Initializes a the miniport.
// ==============================================================================
NTSTATUS
CMiniportMidiStreamFM::
Init
(
    IN      CMiniportMidiFM *   Miniport,
    IN      PUCHAR              PortBase
)
{
    PAGED_CODE();

    ASSERT(Miniport);
    ASSERT(PortBase);

    int i;

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::Init"));

    //
    // AddRef() is required because we are keeping this pointer.
    //
    m_Miniport = Miniport;
    m_Miniport->AddRef();

    m_PortBase = PortBase;

    // init some members
    m_dwCurTime = 1;    /* for note on/off */
    /* volume */
    m_wSynthAttenL = 0;        /* in 1.5dB steps */
    m_wSynthAttenR = 0;        /* in 1.5dB steps */

    m_MinVolValue  = 0xFFD0C000;    //  minimum -47.25(dB) * 0x10000
    m_MaxVolValue  = 0x00000000;    //  maximum  0    (dB) * 0x10000
    m_VolStepDelta = 0x0000C000;    //  steps of 0.75 (dB) * 0x10000
    m_SavedVolValue[CHAN_LEFT] = m_SavedVolValue[CHAN_RIGHT] = 0;

    /* start attenuations at -3 dB, which is 90 MIDI level */
    for (i = 0; i < NUMCHANNELS; i++) 
    {
        m_bChanAtten[i] = 4;
        m_bStereoMask[i] = 0xff;
    };

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::SetState()
// Sets the transport state.
// ==============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportMidiStreamFM::
SetState
(
    IN      KSSTATE     NewState
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::SetState"));

    NTSTATUS ntStatus = STATUS_SUCCESS;

    switch (NewState)
    {
    case KSSTATE_STOP:
    case KSSTATE_ACQUIRE:
    case KSSTATE_PAUSE:
        Opl3_AllNotesOff();
        break;

    case KSSTATE_RUN:
        break;
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
// ==============================================================================
// CMiniportMidiStreamFM::SetFormat()
// Sets the format.
// ==============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportMidiStreamFM::
SetFormat
(
    IN      PKSDATAFORMAT   Format
)
{
    PAGED_CODE();

    ASSERT(Format);

    _DbgPrintF(DEBUGLVL_VERBOSE,("CMiniportMidiStreamFM::SetFormat"));

    return STATUS_SUCCESS;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * BasicSupportHandler()
 *****************************************************************************
 * Assists in BASICSUPPORT accesses on level properties - 
 * this is declared as a friend method in the header file.
 */
static
NTSTATUS BasicSupportHandler
(
    IN  PPCPROPERTY_REQUEST PropertyRequest
)
{
    PAGED_CODE();
    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("BasicSupportHandler"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    if (PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
    {
        // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
        PKSPROPERTY_DESCRIPTION PropDesc = PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);

        PropDesc->AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                                KSPROPERTY_TYPE_GET |
                                KSPROPERTY_TYPE_SET;
        PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION) +
                                      sizeof(KSPROPERTY_MEMBERSHEADER) +
                                      sizeof(KSPROPERTY_STEPPING_LONG);
        PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        PropDesc->PropTypeSet.Id    = VT_I4;
        PropDesc->PropTypeSet.Flags = 0;
        PropDesc->MembersListCount  = 1;
        PropDesc->Reserved          = 0;

        // if return buffer can also hold a range description, return it too
        if (PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION) +
                                           sizeof(KSPROPERTY_MEMBERSHEADER) +
                                           sizeof(KSPROPERTY_STEPPING_LONG)))
        {
            // fill in the members header
            PKSPROPERTY_MEMBERSHEADER Members = PKSPROPERTY_MEMBERSHEADER(PropDesc + 1);

            Members->MembersFlags   = KSPROPERTY_MEMBER_STEPPEDRANGES;
            Members->MembersSize    = sizeof(KSPROPERTY_STEPPING_LONG);
            Members->MembersCount   = 1;
            Members->Flags          = 0;

            // fill in the stepped range
            PKSPROPERTY_STEPPING_LONG Range = PKSPROPERTY_STEPPING_LONG(Members + 1);

            switch (PropertyRequest->Node)
            {
                case eFMVolumeNode:
                    CMiniportMidiStreamFM *that = (CMiniportMidiStreamFM *)PropertyRequest->MinorTarget;

                    if (that)
                    {
                        Range->Bounds.SignedMinimum = that->m_MinVolValue;
                        Range->Bounds.SignedMaximum = that->m_MaxVolValue;
                        Range->SteppingDelta        = that->m_VolStepDelta;
                        break;
                    }
                    else
                    {
                        return STATUS_INVALID_PARAMETER;
                    }
            }

            Range->Reserved = 0;

            _DbgPrintF(DEBUGLVL_VERBOSE, ("---Node: %d  Max: 0x%X  Min: 0x%X  Step: 0x%X",PropertyRequest->Node,
                                       Range->Bounds.SignedMaximum,
                                       Range->Bounds.SignedMinimum,
                                       Range->SteppingDelta));

            // set the return value size
            PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION) +
                                         sizeof(KSPROPERTY_MEMBERSHEADER) +
                                         sizeof(KSPROPERTY_STEPPING_LONG);
        }
        else
        {
            // set the return value size
            PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
        }
        ntStatus = STATUS_SUCCESS;

    }
    else if (PropertyRequest->ValueSize >= sizeof(ULONG))
    {
        // if return buffer can hold a ULONG, return the access flags
        PULONG AccessFlags = PULONG(PropertyRequest->Value);

        *AccessFlags = KSPROPERTY_TYPE_BASICSUPPORT |
                       KSPROPERTY_TYPE_GET |
                       KSPROPERTY_TYPE_SET;

        // set the return value size
        PropertyRequest->ValueSize = sizeof(ULONG);
        ntStatus = STATUS_SUCCESS;

    }
    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PropertyHandler_Level()
 *****************************************************************************
 * Accesses a KSAUDIO_LEVEL property.
 */
static
NTSTATUS PropertyHandler_Level
(
    IN  PPCPROPERTY_REQUEST PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_Level"));


    NTSTATUS        ntStatus = STATUS_INVALID_PARAMETER;
    LONG            channel;

    // validate node
    if (PropertyRequest->Node == eFMVolumeNode)
    {
        if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            // get the instance channel parameter
            if (PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));

                // only support get requests on either mono/left(0) or right(1) channels
                if ((channel == CHAN_LEFT) || (channel == CHAN_RIGHT))
                {
                    // validate and get the output parameter
                    if (PropertyRequest->ValueSize >= sizeof(LONG))
                    {
                        PLONG Level = (PLONG)PropertyRequest->Value;

                        // check if volume property request
                        if (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                        {
                            CMiniportMidiStreamFM *that = (CMiniportMidiStreamFM *)PropertyRequest->MinorTarget;
                            if (that)
                            {
                                *Level = that->GetFMAtten(channel);
                                PropertyRequest->ValueSize = sizeof(LONG);
                                ntStatus = STATUS_SUCCESS;
                            }
                            //  if (!that) return STATUS_INVALID_PARAMETER

                        }   // (PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                    }     // (ValueSize >= sizeof(LONG))
                }       // ((channel == CHAN_LEFT) || (channel == CHAN_RIGHT))
            }         // (InstanceSize >= sizeof(LONG))
        }           // (Verb & KSPROPERTY_TYPE_GET)

        else if (PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
        {
            // get the instance channel parameter
            if (PropertyRequest->InstanceSize >= sizeof(LONG))
            {
                channel = *(PLONG(PropertyRequest->Instance));

                // only support get requests on either mono/left (0), right (1), or master (-1) channels
                if ((channel == CHAN_LEFT) || (channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
                {
                    // validate and get the input parameter
                    if (PropertyRequest->ValueSize == sizeof(LONG))
                    {
                        PLONG level = (PLONG)PropertyRequest->Value;

                        if (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                        {
                            CMiniportMidiStreamFM *that = (CMiniportMidiStreamFM *)PropertyRequest->MinorTarget;
                            if (that)
                            {
                                that->SetFMAtten(channel,*level);
                                ntStatus = STATUS_SUCCESS;
                            }
                            //  if (!that) return STATUS_INVALID_PARAMETER

                        }   // (PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
                    }     // (ValueSize == sizeof(LONG))
                }       // ((channel == CHAN_LEFT) || (channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
            }         // (InstanceSize >= sizeof(LONG))
        }           // (Verb & KSPROPERTY_TYPE_SET)

        else if (PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
        {
            if (PropertyRequest->PropertyItem->Id == KSPROPERTY_AUDIO_VOLUMELEVEL)
            {
                ntStatus = BasicSupportHandler(PropertyRequest);
            }
        }   // (Verb & KSPROPERTY_TYPE_BASICSUPPORT) 
    }     // (Node == eFMVolumeNode)

    return ntStatus;
}

#pragma code_seg()
// convert from 16.16 dB to [0,63], set m_wSynthAttenR
void 
CMiniportMidiStreamFM::
SetFMAtten
(
    IN LONG channel, 
    IN LONG level
)
{
    KIRQL   oldIrql;
    if ((channel == CHAN_LEFT) || (channel == CHAN_MASTER))
    {
        m_SavedVolValue[CHAN_LEFT] = level;

        if (level > m_MaxVolValue)
            m_wSynthAttenL = 0;
        else if (level < m_MinVolValue)
            m_wSynthAttenL = 63;
        else
            m_wSynthAttenL = WORD(-level / (LONG)m_VolStepDelta);
    }
    if ((channel == CHAN_RIGHT) || (channel == CHAN_MASTER))
    {
        m_SavedVolValue[CHAN_RIGHT] = level;
    
        if (level > m_MaxVolValue)
            m_wSynthAttenR = 0;
        else if (level < m_MinVolValue)
            m_wSynthAttenR = 63;
        else
            m_wSynthAttenR = WORD(-level / (LONG)m_VolStepDelta);
    }
#ifdef USE_KDPRINT
    KdPrint(("'StreamFM::SetFMAtten: channel: 0x%X, level: 0x%X, m_wSynthAttenL: 0x%X, m_wSynthAttenR: 0x%X \n",
                                     channel,       level,       m_wSynthAttenL,       m_wSynthAttenR));
#else   //  USE_KDPRINT
    _DbgPrintF(DEBUGLVL_VERBOSE,("StreamFM::SetFMAtten: channel: 0x%X, level: 0x%X, m_wSynthAttenL: 0x%X, m_wSynthAttenR: 0x%X \n",
                                                        channel,       level,       m_wSynthAttenL,       m_wSynthAttenR));
#endif  //  USE_KDPRINT

    KeAcquireSpinLock(&m_Miniport->m_SpinLock,&oldIrql);
    Opl3_SetVolume(0xFF); //  0xFF means all channels
    KeReleaseSpinLock(&m_Miniport->m_SpinLock,oldIrql);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * PropertyHandler_CpuResources()
 *****************************************************************************
 * Processes a KSPROPERTY_AUDIO_CPU_RESOURCES request
 */
static
NTSTATUS PropertyHandler_CpuResources
(
    IN  PPCPROPERTY_REQUEST   PropertyRequest
)
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_CpuResources"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    // validate node
    if(PropertyRequest->Node == eFMVolumeNode)
    {
        if(PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
        {
            if(PropertyRequest->ValueSize >= sizeof(LONG))
            {
                *(PLONG(PropertyRequest->Value)) = KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU;
                PropertyRequest->ValueSize = sizeof(LONG);
                ntStatus = STATUS_SUCCESS;
            } 
            else
            {
                _DbgPrintF(DEBUGLVL_VERBOSE,("PropertyHandler_CpuResources failed, buffer too small"));
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            }
        }
    }
    return ntStatus;
}

#pragma code_seg()
// ==============================================================================
// SoundMidiSendFM
//  Writes out to the device.
//  Called from DPC code (Write->WriteMidiData->Opl3_NoteOn->Opl3_FMNote->here)
// ==============================================================================
void 
CMiniportMidiFM::
SoundMidiSendFM
(
IN    PUCHAR PortBase,
IN    ULONG Address,
IN    UCHAR Data
)
{
    ASSERT(Address < 0x200);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    // these delays need to be 23us at least for old opl2 chips, even
    // though new chips can handle 1 us delays.

#ifdef USE_KDPRINT
    KdPrint(("'SoundMidiSendFM(%02x %02x) \n",Address,Data));
#else   //  USE_KDPRINT
    _DbgPrintF(DEBUGLVL_VERBOSE, ("%X\t%X", Address,Data));
#endif  //  USE_KDPRINT
    WRITE_PORT_UCHAR(PortBase + (Address < 0x100 ? 0 : 2), (UCHAR)Address);
    KeStallExecutionProcessor(23);

    WRITE_PORT_UCHAR(PortBase + (Address < 0x100 ? 1 : 3), Data);
    KeStallExecutionProcessor(23);

    m_SavedRegValues[Address] = Data;
}


#pragma code_seg()
// ==============================================================================
// Service()
// DPC-mode service call from the port.
// ==============================================================================
STDMETHODIMP_(void) 
CMiniportMidiFM::
Service
(   void
)
{
}

#pragma code_seg()
// ==============================================================================
// CMiniportMidiStreamFM::Read()
// Reads incoming MIDI data.
// ==============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportMidiStreamFM::
Read
(
    IN      PVOID   BufferAddress,
    IN      ULONG   Length,
    OUT     PULONG  BytesRead
)
{
    return STATUS_NOT_IMPLEMENTED;
}

#pragma code_seg()
// ==============================================================================
// CMiniportMidiStreamFM::Write()
// Writes outgoing MIDI data.  
// 
// N.B.!!!
// THIS DATA SINK ASSUMES THAT DATA COMES IN ONE MESSAGE AT A TIME!!!
// IF LENGTH IS MORE THAN THREE BYTES, SUCH AS SYSEX OR MULTIPLE MIDI 
// MESSAGES, ALL THE DATA IS DROPPED UNCEREMONIOUSLY ON THE FLOOR!!!
// ALSO DOES NOT PLAY WELL WITH RUNNING STATUS!!!
// 
// CLEARLY, THIS MINIPORT HAS SOME "ISSUES".
//
// ==============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportMidiStreamFM::
Write
(
    IN      PVOID   BufferAddress,  // pointer to Midi Data.
    IN      ULONG   Length,
    OUT     PULONG  BytesWritten
)
{
    ASSERT(BufferAddress);
    ASSERT(BytesWritten);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiStreamFM::Write"));

    BYTE    statusByte = *(PBYTE)BufferAddress & 0xF0;
    *BytesWritten = Length;
    
    if (statusByte < 0x80)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("CMiniportMidiStreamFM::Write requires first byte to be status -- ignored"));
    }
    else if (statusByte == 0xF0)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("StreamFM::Write doesn't handle System messages -- ignored"));
    }
    else if (statusByte == 0xA0)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("StreamFM::Write doesn't handle Polyphonic key pressure/Aftertouch messages -- ignored"));
    }
    else if (statusByte == 0xD0)
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("StreamFM::Write doesn't handle Channel pressure/Aftertouch messages -- ignored"));
    }
    else if (Length < 4)
    {
        WriteMidiData(*(DWORD *)BufferAddress);
    }
    else 
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("StreamFM::Write doesn't handle Length > 3."));
    }   
    return STATUS_SUCCESS;
}

// ==============================================================================
// ==============================================================================
// Private Methods of CMiniportMidiFM
// ==============================================================================
// ==============================================================================


#pragma code_seg()
// =================================================================
// SoundMidiIsOpl3
// Checks if the midi synthesizer is Opl3 compatible or just adlib-compatible.
// returns:  TRUE if OPL3-compatible chip. FALSE otherwise.
//
// NOTE: This has been taken as is from the nt driver code.
// =================================================================
BOOL CMiniportMidiFM::
SoundMidiIsOpl3(void)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    BOOL bIsOpl3 = FALSE;

    /*
     * theory: an opl3-compatible synthesizer chip looks
     * exactly like two separate 3812 synthesizers (for left and right
     * channels) until switched into opl3 mode. Then, the timer-control
     * register for the right half is replaced by a channel connection register
     * (among other changes).
     *
     * We can detect 3812 synthesizers by starting a timer and looking for
     * timer overflow. So if we find 3812s at both left and right addresses,
     * we then switch to opl3 mode and look again for the right-half. If we
     * still find it, then the switch failed and we have an old synthesizer
     * if the right half disappeared, we have a new opl3 synthesizer.
     *
     * NB we use either monaural base-level synthesis, or stereo opl3
     * synthesis. If we discover two 3812s (as on early SB Pro and
     * PAS), we ignore one of them.
     */

    /*
     * nice theory - but wrong. The timer on the right half of the
     * opl3 chip reports its status in the left-half status register.
     * There is no right-half status register on the opl3 chip.
     */


    /* ensure base mode */
    SoundMidiSendFM(m_PortBase, AD_NEW, 0x00);
    KeStallExecutionProcessor(20);

    /* look for right half of chip */
    if (SoundSynthPresent(m_PortBase + 2, m_PortBase))
    {
        /* yes - is this two separate chips or a new opl3 chip ? */
        /* switch to opl3 mode */
        SoundMidiSendFM(m_PortBase, AD_NEW, 0x01);
        KeStallExecutionProcessor(20);

        if (!SoundSynthPresent(m_PortBase + 2, m_PortBase))
        {
            _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiFM: In SoundMidiIsOpl3 right half disappeared"));
            /* right-half disappeared - so opl3 */
            bIsOpl3 = TRUE;
        }
    }

    if (!bIsOpl3)
    {
        /* reset to 3812 mode */
        SoundMidiSendFM(m_PortBase, AD_NEW, 0x00);
        KeStallExecutionProcessor(20);
    }

    _DbgPrintF(DEBUGLVL_VERBOSE, ("CMiniportMidiFM: In SoundMidiIsOpl3 returning bIsOpl3 = 0x%X", bIsOpl3));
    return(bIsOpl3);
}

#pragma code_seg()
// ==============================================================================
// SoundSynthPresent
//
// Detect the presence or absence of a 3812 (opl2/adlib-compatible) synthesizer
// at the given i/o address by starting the timer and looking for an
// overflow. Can be used to detect left and right synthesizers separately.
//
// Returns: True if a synthesiser is present at that address and false if not.
//
// NOTE: This and has been taken as is from the nt driver code.
// ==============================================================================
BOOL
CMiniportMidiFM::
SoundSynthPresent
(
IN PUCHAR   base,
IN PUCHAR inbase
)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    UCHAR t1, t2;
    // check if the chip is present
    SoundMidiSendFM(base, 4, 0x60);             // mask T1 & T2
    SoundMidiSendFM(base, 4, 0x80);             // reset IRQ

    t1 = READ_PORT_UCHAR((PUCHAR)inbase);       // read status register

    SoundMidiSendFM(base, 2, 0xff);             // set timer - 1 latch
    SoundMidiSendFM(base, 4, 0x21);             // unmask & start T1

    // this timer should go off in 80 us. It sometimes
    // takes more than 100us, but will always have expired within
    // 200 us if it is ever going to.
    KeStallExecutionProcessor(200);

    t2 = READ_PORT_UCHAR((PUCHAR)inbase);       // read status register

    SoundMidiSendFM(base, 4, 0x60);
    SoundMidiSendFM(base, 4, 0x80);

    if (!((t1 & 0xE0) == 0) || !((t2 & 0xE0) == 0xC0))
    {
        _DbgPrintF(DEBUGLVL_VERBOSE, ("SoundSynthPresent: returning false"));
        return(FALSE);
    }
    _DbgPrintF(DEBUGLVL_VERBOSE, ("SoundSynthPresent: returning true"));
    return TRUE;
}


// ==============================================================================
// this array gives the offsets of the slots within an opl2
// chip. This is needed to set the attenuation for all slots to max,
// to ensure that the chip is silenced completely - switching off the
// voices alone will not do this.
// ==============================================================================
BYTE offsetSlot[] =
{
    0, 1, 2, 3, 4, 5,
    8, 9, 10, 11, 12, 13,
    16, 17, 18, 19, 20, 21
};

#pragma code_seg()
// =========================================================================
// WriteMidiData
//      Converts a MIDI atom into the corresponding FM transaction.
// =========================================================================
void
CMiniportMidiStreamFM::
WriteMidiData(DWORD dwData)
{
    BYTE    bMsgType,bChannel, bVelocity, bNote;
    WORD    wTemp;
    KIRQL   oldIrql;

    bMsgType = (BYTE) dwData & (BYTE)0xf0;
    bChannel = (BYTE) dwData & (BYTE)0x0f;
    bNote = (BYTE) ((WORD) dwData >> 8) & (BYTE)0x7f;
    bVelocity = (BYTE) (dwData >> 16) & (BYTE)0x7f;
    
#ifdef USE_KDPRINT
    KdPrint(("'StreamFM::WriteMidiData: (%x %x %x) \n",bMsgType+bChannel,bNote,bVelocity));
#else   //  USE_KDPRINT
    _DbgPrintF(DEBUGLVL_VERBOSE,("StreamFM::WriteMidiData: (%x %x %x) \n",bMsgType+bChannel,bNote,bVelocity));
#endif  //  USE_KDPRINT
    KeAcquireSpinLock(&m_Miniport->m_SpinLock,&oldIrql);
    switch (bMsgType)
    {
        case 0x90:      /* turn key on, or key off if volume == 0 */
            if (bVelocity)
            {
                if (bChannel == DRUMCHANNEL)
                {
                    Opl3_NoteOn((BYTE)(bNote + 128),bNote,bChannel,bVelocity,(short)m_iBend[bChannel]);
                }
                else
                {
                    Opl3_NoteOn((BYTE)m_bPatch[bChannel],bNote,bChannel,bVelocity,(short) m_iBend[bChannel]);
                }
                break;
            } // if bVelocity.
            //NOTE: no break specified here. On an else case we want to continue through and turn key off

        case 0x80:
            /* turn key off */
            //  we don't care what the velocity is on note off
            if (bChannel == DRUMCHANNEL)
            {
                Opl3_NoteOff((BYTE) (bNote + 128),bNote, bChannel, 0);
            }
            else
            {
                Opl3_NoteOff ((BYTE) m_bPatch[bChannel],bNote, bChannel, m_bSustain[ bChannel ]);
            }
            break;

        case 0xb0:
            /* change control */
            switch (bNote) 
            {
                case 7:
                    /* change channel volume */
                    Opl3_ChannelVolume(bChannel,gbVelocityAtten[bVelocity >> 1]);
                    break;

                case 8:
                case 10:
                    /* change the pan level */
                    Opl3_SetPan(bChannel, bVelocity);
                    break;

                case 64:
                    /* Change the sustain level */
                    Opl3_SetSustain(bChannel, bVelocity);
                    break;

                default:
                    if (bNote >= 120)        /* Channel mode messages */
                    {
                        Opl3_ChannelNotesOff(bChannel);
                    }
                    //  else unknown controller
            };
            break;

        case 0xc0:
            if (bChannel != DRUMCHANNEL)
            {
               m_bPatch[ bChannel ] = bNote ;

            }
            break;

        case 0xe0:  // pitch bend
            wTemp = ((WORD) bVelocity << 9) | ((WORD) bNote << 2);
            m_iBend[bChannel] = (short) (WORD) (wTemp + 0x8000);
            Opl3_PitchBend(bChannel, m_iBend[bChannel]);

            break;
    };
    KeReleaseSpinLock(&m_Miniport->m_SpinLock,oldIrql);
    
    return;
}

// ========================= opl3 specific methods ============================
#pragma code_seg()
// ==========================================================================
// Opl3_AllNotesOff - turn off all notes
// ==========================================================================
void 
CMiniportMidiStreamFM::
Opl3_AllNotesOff()
{
    BYTE i;
    KIRQL   oldIrql;

    KeAcquireSpinLock(&m_Miniport->m_SpinLock,&oldIrql);
    for (i = 0; i < NUM2VOICES; i++) 
    {
        Opl3_NoteOff(m_Voice[i].bPatch, m_Voice[i].bNote, m_Voice[i].bChannel, 0);
    }
    KeReleaseSpinLock(&m_Miniport->m_SpinLock,oldIrql);
}

#pragma code_seg()
// ==========================================================================
//  void Opl3_NoteOff
//
//  Description:
//     This turns off a note, including drums with a patch
//     # of the drum note + 128, but the first drum instrument is at MIDI note _35_.
//
//  Parameters:
//     BYTE bPatch
//        MIDI patch
//
//     BYTE bNote
//        MIDI note
//
//     BYTE bChannel
//        MIDI channel
//
//  Return Value:
//     Nothing.
//
//
// ==========================================================================
void 
CMiniportMidiStreamFM::
Opl3_NoteOff
(
    BYTE            bPatch,
    BYTE            bNote,
    BYTE            bChannel,
    BYTE            bSustain
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   patchStruct FAR  *lpPS ;
   WORD             wOffset, wTemp ;

   // Find the note slot
   wTemp = Opl3_FindFullSlot( bNote, bChannel ) ;

   if (wTemp != 0xffff)
   {
      if (bSustain)
      {
          // This channel is sustained, don't really turn the note off,
          // just flag it.
          //
          m_Voice[ wTemp ].bSusHeld = 1;
          
          return;
      }
      
      // get a pointer to the patch
      lpPS = glpPatch + (BYTE) m_Voice[ wTemp ].bPatch ;

      // shut off the note portion
      // we have the note slot, turn it off.
      wOffset = wTemp;
      if (wTemp >= (NUM2VOICES / 2))
         wOffset += (0x100 - (NUM2VOICES / 2));

      m_Miniport->SoundMidiSendFM(m_PortBase, AD_BLOCK + wOffset,
                  (BYTE)(m_Voice[ wTemp ].bBlock[ 0 ] & 0x1f) ) ;

      // Note this...
      m_Voice[ wTemp ].bOn = FALSE ;
      m_Voice[ wTemp ].bBlock[ 0 ] &= 0x1f ;
      m_Voice[ wTemp ].bBlock[ 1 ] &= 0x1f ;
      m_Voice[ wTemp ].dwTime = m_dwCurTime ;
   }
}

#pragma code_seg()
// ==========================================================================
//  WORD Opl3_FindFullSlot
//
//  Description:
//     This finds a slot with a specific note, and channel.
//     If it is not found then 0xFFFF is returned.
//
//  Parameters:
//     BYTE bNote
//        MIDI note number
//
//     BYTE bChannel
//        MIDI channel #
//
//  Return Value:
//     WORD
//        note slot #, or 0xFFFF if can't find it
//
//
// ==========================================================================
WORD 
CMiniportMidiStreamFM::
Opl3_FindFullSlot
(
    BYTE            bNote,
    BYTE            bChannel
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD  i ;

   for (i = 0; i < NUM2VOICES; i++)
   {
      if ((bChannel == m_Voice[ i ].bChannel) 
            && (bNote == m_Voice[ i ].bNote) 
            && (m_Voice[ i ].bOn))
      {
            return ( i ) ;
      }
   // couldn't find it
   }
   return ( 0xFFFF ) ;
} 


#pragma code_seg()
//------------------------------------------------------------------------
//  void Opl3_FMNote
//
//  Description:
//     Turns on an FM-synthesizer note.
//
//  Parameters:
//     WORD wNote
//        the note number from 0 to NUMVOICES
//
//     noteStruct FAR *lpSN
//        structure containing information about what
//        is to be played.
//
//  Return Value:
//     Nothing.
//------------------------------------------------------------------------
void 
CMiniportMidiStreamFM::
Opl3_FMNote
(
    WORD                wNote,
    noteStruct FAR *    lpSN
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD            i ;
   WORD            wOffset ;
   operStruct FAR  *lpOS ;

   // write out a note off, just to make sure...

   wOffset = wNote;
   if (wNote >= (NUM2VOICES / 2))
      wOffset += (0x100 - (NUM2VOICES / 2));

   m_Miniport->SoundMidiSendFM(m_PortBase, AD_BLOCK + wOffset, 0 ) ;

   // writing the operator information

//   for (i = 0; i < (WORD)((wNote < NUM4VOICES) ? NUMOPS : 2); i++)
   for (i = 0; i < 2; i++)
   {
      lpOS = &lpSN -> op[ i ] ;
      wOffset = gw2OpOffset[ wNote ][ i ] ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0x20 + wOffset, lpOS -> bAt20) ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0x40 + wOffset, lpOS -> bAt40) ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0x60 + wOffset, lpOS -> bAt60) ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0x80 + wOffset, lpOS -> bAt80) ;
      m_Miniport->SoundMidiSendFM( m_PortBase, 0xE0 + wOffset, lpOS -> bAtE0) ;

   }

   // write out the voice information
   wOffset = (wNote < 9) ? wNote : (wNote + 0x100 - 9) ;
   m_Miniport->SoundMidiSendFM(m_PortBase, 0xa0 + wOffset, lpSN -> bAtA0[ 0 ] ) ;
   m_Miniport->SoundMidiSendFM(m_PortBase, 0xc0 + wOffset, lpSN -> bAtC0[ 0 ] ) ;

   // Note on...
   m_Miniport->SoundMidiSendFM(m_PortBase, 0xb0 + wOffset,
               (BYTE)(lpSN -> bAtB0[ 0 ] | 0x20) ) ;

} // end of Opl3_FMNote()

#pragma code_seg()
//=======================================================================
//  WORD Opl3_NoteOn
//
//  Description:
//     This turns on a note, including drums with a patch # of the
//     drum note + 0x80.  The first GM drum instrument is mapped to note 35 instead of zero, though, so
//     we expect 0 as the first drum patch (acoustic kick) if note 35 comes in.
//
//  Parameters:
//     BYTE bPatch
//        MIDI patch
//
//     BYTE bNote
//        MIDI note
//
//     BYTE bChannel
//        MIDI channel
//
//     BYTE bVelocity
//        velocity value
//
//     short iBend
//        current pitch bend from -32768 to 32767
//
//  Return Value:
//     WORD
//        note slot #, or 0xFFFF if it is inaudible
//=======================================================================
void 
CMiniportMidiStreamFM::
Opl3_NoteOn
(
    BYTE            bPatch,
    BYTE            bNote,
    BYTE            bChannel,
    BYTE            bVelocity,
    short           iBend
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD             wTemp, i, j ;
   BYTE             b4Op, bTemp, bMode, bStereo ;
   patchStruct FAR  *lpPS ;
   DWORD            dwBasicPitch, dwPitch[ 2 ] ;
   noteStruct       NS ;

   // Get a pointer to the patch
   lpPS = glpPatch + bPatch ;

   // Find out the basic pitch according to our
   // note value.  This may be adjusted because of
   // pitch bends or special qualities for the note.

   dwBasicPitch = gdwPitch[ bNote % 12 ] ;
   bTemp = bNote / (BYTE) 12 ;
   if (bTemp > (BYTE) (60 / 12))
      dwBasicPitch = AsLSHL( dwBasicPitch, (BYTE)(bTemp - (BYTE)(60/12)) ) ;
   else if (bTemp < (BYTE) (60/12))
      dwBasicPitch = AsULSHR( dwBasicPitch, (BYTE)((BYTE) (60/12) - bTemp) ) ;

   // Copy the note information over and modify
   // the total level and pitch according to
   // the velocity, midi volume, and tuning.

   RtlCopyMemory( (LPSTR) &NS, (LPSTR) &lpPS -> note, sizeof( noteStruct ) ) ;
   b4Op = (BYTE)(NS.bOp != PATCH_1_2OP) ;

   for (j = 0; j < 2; j++)
   {
      // modify pitch
      dwPitch[ j ] = dwBasicPitch ;
      bTemp = (BYTE)((NS.bAtB0[ j ] >> 2) & 0x07) ;
      if (bTemp > 4)
         dwPitch[ j ] = AsLSHL( dwPitch[ j ], (BYTE)(bTemp - (BYTE)4) ) ;
      else if (bTemp < 4)
         dwPitch[ j ] = AsULSHR( dwPitch[ j ], (BYTE)((BYTE)4 - bTemp) ) ;

      wTemp = Opl3_CalcFAndB( Opl3_CalcBend( dwPitch[ j ], iBend ) ) ;
      NS.bAtA0[ j ] = (BYTE) wTemp ;
      NS.bAtB0[ j ] = (BYTE) 0x20 | (BYTE) (wTemp >> 8) ;
   }

   // Modify level for each operator, but only
   // if they are carrier waves

   bMode = (BYTE) ((NS.bAtC0[ 0 ] & 0x01) * 2 + 4) ;

   for (i = 0; i < 2; i++)
   {
      wTemp = (BYTE) 
          Opl3_CalcVolume(  (BYTE)(NS.op[ i ].bAt40 & (BYTE) 0x3f),
                            bChannel, 
                            bVelocity, 
                            (BYTE) i, 
                            bMode ) ;
      NS.op[ i ].bAt40 = (NS.op[ i ].bAt40 & (BYTE)0xc0) | (BYTE) wTemp ;
   }

   // Do stereo panning, but cutting off a left or
   // right channel if necessary...

   bStereo = Opl3_CalcStereoMask( bChannel ) ;
   NS.bAtC0[ 0 ] &= bStereo ;

   // Find an empty slot, and use it...
   wTemp = Opl3_FindEmptySlot( bPatch ) ;

   Opl3_FMNote(wTemp, &NS ) ;
   m_Voice[ wTemp ].bNote = bNote ;
   m_Voice[ wTemp ].bChannel = bChannel ;
   m_Voice[ wTemp ].bPatch = bPatch ;
   m_Voice[ wTemp ].bVelocity = bVelocity ;
   m_Voice[ wTemp ].bOn = TRUE ;
   m_Voice[ wTemp ].dwTime = m_dwCurTime++ ;
   m_Voice[ wTemp ].dwOrigPitch[0] = dwPitch[ 0 ] ;  // not including bend
   m_Voice[ wTemp ].dwOrigPitch[1] = dwPitch[ 1 ] ;  // not including bend
   m_Voice[ wTemp ].bBlock[0] = NS.bAtB0[ 0 ] ;
   m_Voice[ wTemp ].bBlock[1] = NS.bAtB0[ 1 ] ;
   m_Voice[ wTemp ].bSusHeld = 0;


} // end of Opl3_NoteOn()

#pragma code_seg()
//=======================================================================
//Opl3_CalcFAndB - Calculates the FNumber and Block given a frequency.
//
//inputs
//       DWORD   dwPitch - pitch
//returns
//        WORD - High byte contains the 0xb0 section of the
//                        block and fNum, and the low byte contains the
//                        0xa0 section of the fNumber
//=======================================================================
WORD 
CMiniportMidiStreamFM::
Opl3_CalcFAndB(DWORD dwPitch)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    BYTE    bBlock;

    /* bBlock is like an exponential to dwPitch (or FNumber) */
    for (bBlock = 1; dwPitch >= 0x400; dwPitch >>= 1, bBlock++)
        ;

    if (bBlock > 0x07)
        bBlock = 0x07;  /* we cant do anything about this */

    /* put in high two bits of F-num into bBlock */
    return ((WORD) bBlock << 10) | (WORD) dwPitch;
}

#pragma code_seg()
//=======================================================================
//Opl3_CalcBend - This calculates the effects of pitch bend
//        on an original value.
//
//inputs
//        DWORD   dwOrig - original frequency
//        short   iBend - from -32768 to 32768, -2 half steps to +2
//returns
//        DWORD - new frequency
//=======================================================================
DWORD 
CMiniportMidiStreamFM::
Opl3_CalcBend (DWORD dwOrig, short iBend)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    DWORD   dw;
  
    /* do different things depending upon positive or
        negative bend */
    if (iBend > 0)
    {
        dw = (DWORD)((iBend * (LONG)(256.0 * (EQUAL * EQUAL - 1.0))) >> 8);
        dwOrig += (DWORD)(AsULMUL(dw, dwOrig) >> 15);
    }
    else if (iBend < 0)
    {
        dw = (DWORD)(((-iBend) * (LONG)(256.0 * (1.0 - 1.0 / EQUAL / EQUAL))) >> 8);
        dwOrig -= (DWORD)(AsULMUL(dw, dwOrig) >> 15);
    }

    return dwOrig;
}


#pragma code_seg()
//=======================================================================
// Opl3_CalcVolume - This calculates the attenuation for an operator.
//
//inputs
//        BYTE    bOrigAtten - original attenuation in 0.75 dB units
//        BYTE    bChannel - MIDI channel
//        BYTE    bVelocity - velocity of the note
//        BYTE    bOper - operator number (from 0 to 3)
//        BYTE    bMode - voice mode (from 0 through 7 for
//                                modulator/carrier selection)
//returns
//        BYTE - new attenuation in 0.75 dB units, maxing out at 0x3f.
//=======================================================================
BYTE 
CMiniportMidiStreamFM::
Opl3_CalcVolume(BYTE bOrigAtten,BYTE bChannel,BYTE bVelocity,BYTE bOper,BYTE bMode)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    BYTE        bVolume;
    WORD        wTemp;
    WORD        wMin;

    switch (bMode) {
        case 0:
                bVolume = (BYTE)(bOper == 3);
                break;
        case 1:
                bVolume = (BYTE)((bOper == 1) || (bOper == 3));
                break;
        case 2:
                bVolume = (BYTE)((bOper == 0) || (bOper == 3));
                break;
        case 3:
                bVolume = (BYTE)(bOper != 1);
                break;
        case 4:
                bVolume = (BYTE)((bOper == 1) || (bOper == 3));
                break;
        case 5:
                bVolume = (BYTE)(bOper >= 1);
                break;
        case 6:
                bVolume = (BYTE)(bOper <= 2);
                break;
        case 7:
                bVolume = TRUE;
                break;
        default:
                bVolume = FALSE;
                break;
        };
    if (!bVolume)
        return bOrigAtten; /* this is a modulator wave */

    wMin =(m_wSynthAttenL < m_wSynthAttenR) ? m_wSynthAttenL : m_wSynthAttenR;
    wTemp = bOrigAtten + 
            ((wMin << 1) +
            m_bChanAtten[bChannel] + 
            gbVelocityAtten[bVelocity >> 1]);
    return (wTemp > 0x3f) ? (BYTE) 0x3f : (BYTE) wTemp;
}

#pragma code_seg()
// ===========================================================================
// Opl3_ChannelNotesOff - turn off all notes on a channel
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_ChannelNotesOff(BYTE bChannel)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    int i;

    for (i = 0; i < NUM2VOICES; i++) 
    {
       if ((m_Voice[ i ].bOn) && (m_Voice[ i ].bChannel == bChannel)) 
       {
          Opl3_NoteOff(m_Voice[i].bPatch, m_Voice[i].bNote,m_Voice[i].bChannel, 0) ;
       }
    }
}

#pragma code_seg()
// ===========================================================================
/* Opl3_ChannelVolume - set the volume level for an individual channel.
 *
 * inputs
 *      BYTE    bChannel - channel number to change
 *      WORD    wAtten  - attenuation in 1.5 db units
 *
 * returns
 *      none
 */
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_ChannelVolume(BYTE bChannel, WORD wAtten)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    m_bChanAtten[bChannel] = (BYTE)wAtten;

    Opl3_SetVolume(bChannel);
}

#pragma code_seg()
// ===========================================================================
//  void Opl3_SetVolume
//
//  Description:
//     This should be called if a volume level has changed.
//     This will adjust the levels of all the playing voices.
//
//  Parameters:
//     BYTE bChannel
//        channel # of 0xFF for all channels
//
//  Return Value:
//     Nothing.
//
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_SetVolume
(
    BYTE   bChannel
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD            i, j, wTemp, wOffset ;
   noteStruct FAR  *lpPS ;
   BYTE            bMode, bStereo ;

   // Make sure that we are actually open...
   if (!glpPatch)
      return ;

   // Loop through all the notes looking for the right
   // channel.  Anything with the right channel gets
   // its pitch bent.
   for (i = 0; i < NUM2VOICES; i++)
   {
      if ((m_Voice[ i ].bChannel == bChannel) || (bChannel == 0xff))
      {
         // Get a pointer to the patch
         lpPS = &(glpPatch + m_Voice[ i ].bPatch) -> note ;

         // Modify level for each operator, IF they are carrier waves...
         bMode = (BYTE) ( (lpPS->bAtC0[0] & 0x01) * 2 + 4);

         for (j = 0; j < 2; j++)
         {
            wTemp = (BYTE) Opl3_CalcVolume(
               (BYTE) (lpPS -> op[j].bAt40 & (BYTE) 0x3f),
               m_Voice[i].bChannel, m_Voice[i].bVelocity, 
               (BYTE) j,            bMode ) ;

            // Write new value.
            wOffset = gw2OpOffset[ i ][ j ] ;
            m_Miniport->SoundMidiSendFM(
               m_PortBase, 0x40 + wOffset,
               (BYTE) ((lpPS -> op[j].bAt40 & (BYTE)0xc0) | (BYTE) wTemp) ) ;
         }

         // Do stereo pan, but cut left or right channel if needed.
         bStereo = Opl3_CalcStereoMask( m_Voice[ i ].bChannel ) ;
         wOffset = i;
         if (i >= (NUM2VOICES / 2))
             wOffset += (0x100 - (NUM2VOICES / 2));
         m_Miniport->SoundMidiSendFM(m_PortBase, 0xc0 + wOffset, (BYTE)(lpPS -> bAtC0[ 0 ] & bStereo) ) ;
      }
   }
} // end of Opl3_SetVolume

#pragma code_seg()
// ===========================================================================
// Opl3_SetPan - set the left-right pan position.
//
// inputs
//      BYTE    bChannel - channel number to alter
//      BYTE    bPan     - 0-47 for left, 81-127 for right, or somewhere in the middle.
//
// returns - none
//
//  As a side note, I think it's odd that (since 64 = CENTER, 127 = RIGHT and 0 = LEFT)
//  there are 63 intermediate gradations for the left side, but 62 for the right.
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_SetPan(BYTE bChannel, BYTE bPan)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    /* change the pan level */
    if (bPan > (64 + 16))
            m_bStereoMask[bChannel] = 0xef;      /* let only right channel through */
    else if (bPan < (64 - 16))
            m_bStereoMask[bChannel] = 0xdf;      /* let only left channel through */
    else
            m_bStereoMask[bChannel] = 0xff;      /* let both channels */

    /* change any curently playing patches */
    Opl3_SetVolume(bChannel);
}


#pragma code_seg()
// ===========================================================================
//  void Opl3_PitchBend
//
//  Description:
//     This pitch bends a channel.
//
//  Parameters:
//     BYTE bChannel
//        channel
//
//     short iBend
//        values from -32768 to 32767, being -2 to +2 half steps
//
//  Return Value:
//     Nothing.
// ===========================================================================
void 
CMiniportMidiStreamFM::
Opl3_PitchBend
(
    BYTE        bChannel,
    short        iBend
)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD   i, wTemp[ 2 ], wOffset, j ;
   DWORD  dwNew ;

   // Remember the current bend..
   m_iBend[ bChannel ] = iBend ;

   // Loop through all the notes looking for 
   // the correct channel.  Anything with the 
   // correct channel gets its pitch bent...
   for (i = 0; i < NUM2VOICES; i++)
      if (m_Voice[ i ].bChannel == bChannel)
      {
         j = 0 ;
         dwNew = Opl3_CalcBend( m_Voice[ i ].dwOrigPitch[ j ], iBend ) ;
         wTemp[ j ] = Opl3_CalcFAndB( dwNew ) ;
         m_Voice[ i ].bBlock[ j ] =
            (m_Voice[ i ].bBlock[ j ] & (BYTE) 0xe0) |
               (BYTE) (wTemp[ j ] >> 8) ;

         wOffset = i;
         if (i >= (NUM2VOICES / 2))
             wOffset += (0x100 - (NUM2VOICES / 2));

         m_Miniport->SoundMidiSendFM(m_PortBase, AD_BLOCK + wOffset, m_Voice[ i ].bBlock[ 0 ] ) ;
         m_Miniport->SoundMidiSendFM(m_PortBase, AD_FNUMBER + wOffset, (BYTE) wTemp[ 0 ] ) ;
      }
} // end of Opl3_PitchBend


#pragma code_seg()
// ===========================================================================
//  Opl3_CalcStereoMask - This calculates the stereo mask.
//
//  inputs
//            BYTE  bChannel - MIDI channel
//  returns
//            BYTE  mask (for register 0xc0-c8) for eliminating the
//                  left/right/both channels
// ===========================================================================
BYTE 
CMiniportMidiStreamFM::
Opl3_CalcStereoMask(BYTE bChannel)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    WORD        wLeft, wRight;

    /* figure out the basic levels of the 2 channels */
    wLeft = (m_wSynthAttenL << 1) + m_bChanAtten[bChannel];
    wRight = (m_wSynthAttenR << 1) + m_bChanAtten[bChannel];

    /* if both are too quiet then mask to nothing */
    if ((wLeft > 0x3f) && (wRight > 0x3f))
        return 0xcf;

    /* if one channel is significantly quieter than the other than
        eliminate it */
    if ((wLeft + 8) < wRight)
        return (BYTE)(0xef & m_bStereoMask[bChannel]);   /* right is too quiet so eliminate */
    else if ((wRight + 8) < wLeft)
        return (BYTE)(0xdf & m_bStereoMask[bChannel]);   /* left too quiet so eliminate */
    else
        return (BYTE)(m_bStereoMask[bChannel]);  /* use both channels */
}

#pragma code_seg()
//------------------------------------------------------------------------
//  WORD Opl3_FindEmptySlot
//
//  Description:
//     This finds an empty note-slot for a MIDI voice.
//     If there are no empty slots then this looks for the oldest
//     off note.  If this doesn't work then it looks for the oldest
//     on-note of the same patch.  If all notes are still on then
//     this finds the oldests turned-on-note.
//
//  Parameters:
//     BYTE bPatch
//        MIDI patch that will replace it.
//
//  Return Value:
//     WORD
//        note slot #
//
//
//------------------------------------------------------------------------
WORD 
CMiniportMidiStreamFM::
Opl3_FindEmptySlot(BYTE bPatch)
{
   ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

   WORD   i, found ;
   DWORD  dwOldest ;

   // First, look for a slot with a time == 0
   for (i = 0;  i < NUM2VOICES; i++)
      if (!m_Voice[ i ].dwTime)
         return ( i ) ;

   // Now, look for a slot of the oldest off-note
   dwOldest = 0xffffffff ;
   found = 0xffff ;

   for (i = 0; i < NUM2VOICES; i++)
      if (!m_Voice[ i ].bOn && (m_Voice[ i ].dwTime < dwOldest))
      {
         dwOldest = m_Voice[ i ].dwTime ;
         found = i ;
      }
   if (found != 0xffff)
      return ( found ) ;

   // Now, look for a slot of the oldest note with
   // the same patch
   dwOldest = 0xffffffff ;
   found = 0xffff ;
   for (i = 0; i < NUM2VOICES; i++)
      if ((m_Voice[ i ].bPatch == bPatch) && (m_Voice[ i ].dwTime < dwOldest))
      {
         dwOldest = m_Voice[ i ].dwTime ;
         found = i ;
      }
   if (found != 0xffff)
      return ( found ) ;

   // Now, just look for the oldest voice
   found = 0 ;
   dwOldest = m_Voice[ found ].dwTime ;
   for (i = (found + 1); i < NUM2VOICES; i++)
      if (m_Voice[ i ].dwTime < dwOldest)
      {
         dwOldest = m_Voice[ i ].dwTime ;
         found = i ;
      }

   return ( found ) ;

} // end of Opl3_FindEmptySlot()

#pragma code_seg()
//------------------------------------------------------------------------
//  WORD Opl3_SetSustain
//
//  Description:
//     Set the sustain controller on the current channel.
//
//  Parameters:
//     BYTE bSusLevel
//        The new sustain level 
//
//
//------------------------------------------------------------------------
VOID
CMiniportMidiStreamFM::
Opl3_SetSustain(BYTE bChannel,BYTE bSusLevel)
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    WORD            i;

    if (m_bSustain[ bChannel ] && !bSusLevel)
    {
        // Sustain has just been turned off for this channel
        // Go through and turn off all notes that are being held for sustain
        //
        for (i = 0; i < NUM2VOICES; i++)
        {
            if ((bChannel == m_Voice[ i ].bChannel) &&
                m_Voice[ i ].bSusHeld)
            {
                Opl3_NoteOff(m_Voice[i].bPatch, m_Voice[i].bNote, m_Voice[i].bChannel, 0);
            }
        }
    }
    m_bSustain[ bChannel ] = bSusLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\dmusuart\private.h ===
/*****************************************************************************
 * private.h - MPU-401 miniport private definitions
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 */

#ifndef _DMUSUART_PRIVATE_H_
#define _DMUSUART_PRIVATE_H_

#include "portcls.h"
#include "stdunk.h"
#include "dmusicks.h"

//  + for absolute / - for relative
#define kOneMillisec (10 * 1000)

//
// MPU401 ports
//
#define MPU401_REG_STATUS   0x01    // Status register
#define MPU401_DRR          0x40    // Output ready (for command or data)
                                    // if this bit is set, the output FIFO is FULL
#define MPU401_DSR          0x80    // Input ready (for data)
                                    // if this bit is set, the input FIFO is empty

#define MPU401_REG_DATA     0x00    // Data in
#define MPU401_REG_COMMAND  0x01    // Commands
#define MPU401_CMD_RESET    0xFF    // Reset command
#define MPU401_CMD_UART     0x3F    // Switch to UART mod


/*****************************************************************************
 * References forward
 */


/*****************************************************************************
 * Prototypes
 */

NTSTATUS InitMPU(IN PINTERRUPTSYNC InterruptSync,IN PVOID DynamicContext);
NTSTATUS ResetHardware(PUCHAR portBase);
NTSTATUS ValidatePropertyRequest(IN PPCPROPERTY_REQUEST pRequest, IN ULONG ulValueSize, IN BOOLEAN fValueRequired);


/*****************************************************************************
 * Constants
 */

const BOOLEAN   COMMAND   = TRUE;
const BOOLEAN   DATA      = FALSE;

const LONG      kMPUInputBufferSize = 128;


/*****************************************************************************
 * Globals
 */


/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CMiniportDMusUART
 *****************************************************************************
 * MPU-401 miniport.  This object is associated with the device and is 
 * created when the device is started.  The class inherits IMiniportDMus
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportDMusUART
:   public IMiniportDMus,
    public IMusicTechnology,
    public IPowerNotify,
    public CUnknown
{
private:
    KSSTATE         m_KSStateInput;         // Miniport state (RUN/PAUSE/ACQUIRE/STOP)
    PPORTDMUS       m_pPort;                // Callback interface.
    PUCHAR          m_pPortBase;            // Base port address.
    PINTERRUPTSYNC  m_pInterruptSync;       // Interrupt synchronization object.
    PSERVICEGROUP   m_pServiceGroup;        // Service group for capture.
    PMASTERCLOCK    m_MasterClock;          // for input data
    REFERENCE_TIME  m_InputTimeStamp;       // capture data timestamp
    USHORT          m_NumRenderStreams;     // Num active render streams.
    USHORT          m_NumCaptureStreams;    // Num active capture streams.
    LONG            m_MPUInputBufferHead;   // Index of the newest byte in the FIFO.
    LONG            m_MPUInputBufferTail;   // Index of the oldest empty space in the FIFO.
    GUID            m_MusicFormatTechnology;
    POWER_STATE     m_PowerState;           // Saved power state (D0 = full power, D3 = off)
    BOOLEAN         m_fMPUInitialized;      // Is the MPU HW initialized.
    BOOLEAN         m_UseIRQ;               // FALSE if no IRQ is used for MIDI.
    UCHAR           m_MPUInputBuffer[kMPUInputBufferSize];  // Internal SW FIFO.

    /*************************************************************************
     * CMiniportDMusUART methods
     *
     * These are private member functions used internally by the object.
     * See MINIPORT.CPP for specific descriptions.
     */
    NTSTATUS ProcessResources
    (
        IN      PRESOURCELIST   ResourceList
    );
    NTSTATUS InitializeHardware(PINTERRUPTSYNC interruptSync,PUCHAR portBase);

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportDMusUART);

    ~CMiniportDMusUART();

    /*************************************************************************
     * IMiniport methods
     */
    STDMETHODIMP_(NTSTATUS) 
    GetDescription
    (   OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );
    STDMETHODIMP_(NTSTATUS) 
    DataRangeIntersection
    (   IN      ULONG           PinId
    ,   IN      PKSDATARANGE    DataRange
    ,   IN      PKSDATARANGE    MatchingDataRange
    ,   IN      ULONG           OutputBufferLength
    ,   OUT     PVOID           ResultantFormat
    ,   OUT     PULONG          ResultantFormatLength
    )
    {
        return STATUS_NOT_IMPLEMENTED;
    }

    /*************************************************************************
     * IMiniportDMus methods
     */
    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTDMUS       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    );
    STDMETHODIMP_(NTSTATUS) NewStream
    (
        OUT     PMXF                  * Stream,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   PinID,
        IN      DMUS_STREAM_TYPE        StreamType,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP         * ServiceGroup,
        IN      PAllocatorMXF           AllocatorMXF,
        IN      PMASTERCLOCK            MasterClock,
        OUT     PULONGLONG              SchedulePreFetch
    );
    STDMETHODIMP_(void) Service
    (   void
    );

    /*************************************************************************
     * IMusicTechnology methods
     */
    IMP_IMusicTechnology;

    /*************************************************************************
     * IPowerNotify methods
     */
    IMP_IPowerNotify;

    /*************************************************************************
     * Friends 
     */
    friend class CMiniportDMusUARTStream;
    friend NTSTATUS 
        DMusMPUInterruptServiceRoutine(PINTERRUPTSYNC InterruptSync,PVOID DynamicContext);
    friend NTSTATUS 
        SynchronizedDMusMPUWrite(PINTERRUPTSYNC InterruptSync,PVOID syncWriteContext);
    friend VOID NTAPI 
        DMusUARTTimerDPC(PKDPC Dpc,PVOID DeferredContext,PVOID SystemArgument1,PVOID SystemArgument2);
    friend NTSTATUS PropertyHandler_Synth(IN PPCPROPERTY_REQUEST);
    friend STDMETHODIMP_(NTSTATUS) SnapTimeStamp(PINTERRUPTSYNC InterruptSync,PVOID pStream);
};

/*****************************************************************************
 * CMiniportDMusUARTStream
 *****************************************************************************
 * MPU-401 miniport stream.  This object is associated with the pin and is
 * created when the pin is instantiated.  It inherits IMXF
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportDMusUARTStream
:   public IMXF,
    public CUnknown
{
private:
    CMiniportDMusUART * m_pMiniport;            // Parent.
    REFERENCE_TIME      m_SnapshotTimeStamp;    // Current snapshot of miniport's input timestamp.
    PUCHAR              m_pPortBase;            // Base port address.
    BOOLEAN             m_fCapture;             // Whether this is capture.
    long                m_NumFailedMPUTries;    // Deadman timeout for MPU hardware.
    PAllocatorMXF       m_AllocatorMXF;         // source/sink for DMus structs
    PMXF                m_sinkMXF;              // sink for DMus capture
    PDMUS_KERNEL_EVENT  m_DMKEvtQueue;          // queue of waiting events
    ULONG               m_NumberOfRetries;      // Number of consecutive times the h/w was busy/full
    ULONG               m_DMKEvtOffset;         // offset into the event
    KDPC                m_Dpc;                  // DPC for timer
    KTIMER              m_TimerEvent;           // timer 
    BOOL                m_TimerQueued;          // whether a timer has been set
    KSPIN_LOCK          m_DpcSpinLock;          // protects the ConsumeEvents DPC

    STDMETHODIMP_(NTSTATUS) SourceEvtsToPort();
    STDMETHODIMP_(NTSTATUS) ConsumeEvents();
    STDMETHODIMP_(NTSTATUS) PutMessageLocked(PDMUS_KERNEL_EVENT pDMKEvt);

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportDMusUARTStream);

    ~CMiniportDMusUARTStream();

    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      CMiniportDMusUART * pMiniport,
        IN      PUCHAR              pPortBase,
        IN      BOOLEAN             fCapture,
        IN      PAllocatorMXF       allocatorMXF,
        IN      PMASTERCLOCK        masterClock
    );

    NTSTATUS HandlePortParams
    (
        IN      PPCPROPERTY_REQUEST     Request
    );

    /*************************************************************************
     * IMiniportStreamDMusUART methods
     */
    IMP_IMXF;

    STDMETHODIMP_(NTSTATUS) Write
    (
        IN      PVOID       BufferAddress,
        IN      ULONG       BytesToWrite,
        OUT     PULONG      BytesWritten
    );

    friend VOID NTAPI
    DMusUARTTimerDPC
    (
        IN      PKDPC   Dpc,
        IN      PVOID   DeferredContext,
        IN      PVOID   SystemArgument1,
        IN      PVOID   SystemArgument2
    );
    friend NTSTATUS PropertyHandler_Synth(IN PPCPROPERTY_REQUEST);
    friend STDMETHODIMP_(NTSTATUS) SnapTimeStamp(PINTERRUPTSYNC InterruptSync,PVOID pStream);
};
#endif  //  _DMusUART_PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\driver\common.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

#define _WDMDDK_        // secret hacks ...
extern "C" {
    #include <ntddk.h>
} // extern "C"

#include <unknown.h>
#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmedia.h>
#include <kcom.h>
#include <drmk.h>

#include "debug.h"
#include "filter.h"
#include "pin.h"

//
// Put your own pool tag here. 'pawS' is backwards for 'Swap'.
//
#define GFXSWAP_POOL_TAG    'pawS'
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\fmsynth\private.h ===
/*****************************************************************************
 * private.h - FM synth miniport private definitions
 *****************************************************************************
 * Copyright (c) 1997-2000 Microsoft Corporation.  All rights reserved.
 */

#ifndef _FMSYNTH_PRIVATE_H_
#define _FMSYNTH_PRIVATE_H_

#include "portcls.h"
#include "stdunk.h"
#include "ksdebug.h"

#include "miniport.h"

enum {
    CHAN_MASTER = (-1),
    CHAN_LEFT = 0,
    CHAN_RIGHT = 1
};

/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CMiniportMidiFM
 *****************************************************************************
 * FM miniport.  This object is associated with the device and is
 * created when the device is started.  The class inherits IMiniportMidi
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportMidiFM
:   public IMiniportMidi,
    public IPowerNotify,
    public CUnknown
{
private:
    PPORTMIDI       m_Port;                 // Callback interface.
    PUCHAR          m_PortBase;             // Base port address.
    BOOLEAN         m_BoardNotResponsive;   // Indicates dead hardware.
    BOOLEAN         m_bInit;                // true if we have already done init.
    BOOLEAN         m_fStreamExists;        // True if we have a stream.

    BYTE            m_SavedRegValues[0x200]; // Shadow copies of the FM registers.
    POWER_STATE     m_PowerState;            // Saved power state (D0 = full power, D3 = off)
    BOOLEAN         m_volNodeNeeded;         // Whether we need to furnish a volume node.
    KSPIN_LOCK      m_SpinLock;              // Protects writes to hardware.

    /*************************************************************************
     * CMiniportMidiFM methods
     *
     * These are private member functions used internally by the object.  See
     * MINIPORT.CPP for specific descriptions.
     *
     */
    NTSTATUS 
    ProcessResources
    (
        IN      PRESOURCELIST   ResourceList
    );

    void SoundMidiSendFM(PUCHAR PortBase, ULONG Address, UCHAR Data); // low-level--write registers

    BOOL SoundSynthPresent(IN PUCHAR base, IN PUCHAR inbase);   // detect if synth is present.
    BOOL SoundMidiIsOpl3(VOID);     // returns true if the device is an opl3 and false if not.
    VOID Opl3_BoardReset(VOID);
    VOID MiniportMidiFMResume(VOID);

public:
    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();

//  expand constructor to take bool for whether to include volume
    CMiniportMidiFM(PUNKNOWN pUnknownOuter,int createVolNode)
    :   CUnknown(pUnknownOuter)
    {
        m_volNodeNeeded = (createVolNode != 0);
    };

    ~CMiniportMidiFM();

    /*************************************************************************
     * IMiniport methods
     */
    STDMETHODIMP_(NTSTATUS) 
    GetDescription
    (   OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );
    STDMETHODIMP_(NTSTATUS) 
    DataRangeIntersection
    (   IN      ULONG           PinId
    ,   IN      PKSDATARANGE    DataRange
    ,   IN      PKSDATARANGE    MatchingDataRange
    ,   IN      ULONG           OutputBufferLength
    ,   OUT     PVOID           ResultantFormat
    ,   OUT     PULONG          ResultantFormatLength
    )
    {
        return STATUS_NOT_IMPLEMENTED;
    }

    /*************************************************************************
     * IMiniportMidi methods
     */
    STDMETHODIMP_(NTSTATUS) Init
    (
        IN      PUNKNOWN        UnknownNotUsed  OPTIONAL,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTMIDI       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    );
    STDMETHODIMP_(NTSTATUS) NewStream
    (
        OUT     PMINIPORTMIDISTREAM *   Stream,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   Pin,
        IN      BOOLEAN                 Capture,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP *         ServiceGroup
    );
    STDMETHODIMP_(void) Service
    (   void
    );

    /*************************************************************************
     * IPowerNotify methods
     */
    STDMETHODIMP_(void) PowerChangeNotify(
        IN  POWER_STATE     PowerState
    );

    
/*************************************************************************
     * Friends
     */
    friend class CMiniportMidiStreamFM;

};

/*****************************************************************************
 * CMiniportMidiStreamFM
 *****************************************************************************
 * FM miniport stream.  This object is associated with a pin and is created
 * when the pin is instantiated.  The class inherits IMiniportMidiStream
 * so it can expose this interface and CUnknown so it automatically gets
 * reference counting and aggregation support.
 */
class CMiniportMidiStreamFM
:   public IMiniportMidiStream,
    public CUnknown
{
private:
    CMiniportMidiFM *   m_Miniport;     // Parent miniport.
    PUCHAR              m_PortBase;     // Base port address.

    // midi stuff
    voiceStruct m_Voice[NUM2VOICES];  /* info on what voice is where */
    DWORD m_dwCurTime;    /* for note on/off */
    /* volume */
    WORD    m_wSynthAttenL;        /* in 1.5dB steps */
    WORD    m_wSynthAttenR;        /* in 1.5dB steps */

    /* support for volume property */
    LONG    m_MinVolValue;      // Minimum value for volume controller
    LONG    m_MaxVolValue;      // Maximum value for volume controller
    ULONG   m_VolStepDelta;     // Correlation between controller and actual decibels
    LONG    m_SavedVolValue[2]; // Saved value for volume controller

    /* channel volumes */
    BYTE    m_bChanAtten[NUMCHANNELS];       /* attenuation of each channel, in .75 db steps */
    BYTE    m_bStereoMask[NUMCHANNELS];              /* mask for left/right for stereo midi files */

    short   m_iBend[NUMCHANNELS];    /* bend for each channel */
    BYTE    m_bPatch[NUMCHANNELS];   /* patch number mapped to */
    BYTE    m_bSustain[NUMCHANNELS];   /* Is sustain in effect on this channel? */

    /*************************************************************************
     * CMiniportMidiStreamFM methods
     *
     * These are private member functions used internally by the object.  See
     * MINIPORT.CPP for specific descriptions.
     */

    VOID WriteMidiData(DWORD dwData);
    // opl3 processing methods.
    VOID Opl3_ChannelVolume(BYTE bChannel, WORD wAtten);
    VOID Opl3_SetPan(BYTE bChannel, BYTE bPan);
    VOID Opl3_PitchBend(BYTE bChannel, short iBend);
    VOID Opl3_NoteOn(BYTE bPatch,BYTE bNote, BYTE bChannel, BYTE bVelocity,short iBend);
    VOID Opl3_NoteOff (BYTE bPatch,BYTE bNote, BYTE bChannel, BYTE bSustain);
    VOID Opl3_AllNotesOff(VOID);
    VOID Opl3_ChannelNotesOff(BYTE bChannel);
    WORD Opl3_FindFullSlot(BYTE bNote, BYTE bChannel);
    WORD Opl3_CalcFAndB (DWORD dwPitch);
    DWORD Opl3_CalcBend (DWORD dwOrig, short iBend);
    BYTE Opl3_CalcVolume (BYTE bOrigAtten, BYTE bChannel,BYTE bVelocity, BYTE bOper, BYTE bMode);
    BYTE Opl3_CalcStereoMask (BYTE bChannel);
    WORD Opl3_FindEmptySlot(BYTE bPatch);
    VOID Opl3_SetVolume(BYTE bChannel);
    VOID Opl3_FMNote(WORD wNote, noteStruct FAR * lpSN);
    VOID Opl3_SetSustain(BYTE bChannel, BYTE bSusLevel);

    void SetFMAtten(LONG channel, LONG level);
    LONG GetFMAtten(LONG channel)    {   return m_SavedVolValue[channel];    };

public:
    NTSTATUS
    Init
    (
        IN      CMiniportMidiFM *   Miniport,
        IN      PUCHAR              PortBase
    );

    /*************************************************************************
     * The following two macros are from STDUNK.H.  DECLARE_STD_UNKNOWN()
     * defines inline IUnknown implementations that use CUnknown's aggregation
     * support.  NonDelegatingQueryInterface() is declared, but it cannot be
     * implemented generically.  Its definition appears in MINIPORT.CPP.
     * DEFINE_STD_CONSTRUCTOR() defines inline a constructor which accepts
     * only the outer unknown, which is used for aggregation.  The standard
     * create macro (in MINIPORT.CPP) uses this constructor.
     */
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportMidiStreamFM);

    ~CMiniportMidiStreamFM();

    /*************************************************************************
     * IMiniportMidiStream methods
     */
    STDMETHODIMP_(NTSTATUS) SetFormat
    (
        IN      PKSDATAFORMAT   DataFormat
    );
    STDMETHODIMP_(NTSTATUS) SetState
    (
        IN      KSSTATE     State
    );
    STDMETHODIMP_(NTSTATUS) Read
    (
        IN      PVOID       BufferAddress,
        IN      ULONG       BufferLength,
        OUT     PULONG      BytesRead
    );
    STDMETHODIMP_(NTSTATUS) Write
    (
        IN      PVOID       BufferAddress,
        IN      ULONG       BytesToWrite,
        OUT     PULONG      BytesWritten
    );

/*************************************************************************
     * Friends
     */
    friend
    NTSTATUS BasicSupportHandler
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

    friend
    NTSTATUS PropertyHandler_Level
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

    friend
    NTSTATUS PropertyHandler_CpuResources
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\fmsynth\patch.h ===
//
//   Copyright (c) 1996-2000 Microsoft Corporation.  All rights reserved.
//
// ==============================================
// This file is generated programmatically from
// a RIFF file synth.pat. 

// Please do not edit this file.
// ==============================================
patchStruct glpPatch[] = 
{
    {   //  1st patch struct
        0x01,0x8f,0xf2,0xf4,0x00,0x01,0x06,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  2nd patch struct
        0x01,0x4b,0xf2,0xf4,0x00,0x01,0x00,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  3rd patch struct
        0x01,0x49,0xf2,0xf4,0x00,0x01,0x00,0xf2,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  4th patch struct
        0x81,0x12,0xf2,0xf7,0x00,0x41,0x00,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  5th patch struct
        0x01,0x57,0xf1,0xf7,0x00,0x01,0x00,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  6th patch struct
        0x01,0x93,0xf1,0xf7,0x00,0x01,0x00,0xf2,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  7th patch struct
        0x01,0x80,0xa1,0xf2,0x00,0x16,0x0e,0xf2,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  8th patch struct
        0x01,0x92,0xc2,0xf8,0x00,0x01,0x00,0xc2,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  9th patch struct
        0x0c,0x5c,0xf6,0xf4,0x00,0x81,0x00,0xf3,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  10th patch struct
        0x07,0x97,0xf3,0xf2,0x00,0x11,0x80,0xf2,0xf1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  11th patch struct
        0x17,0x21,0x54,0xf4,0x00,0x01,0x00,0xf4,0xf4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  12th patch struct
        0x98,0x62,0xf3,0xf6,0x00,0x81,0x00,0xf2,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  13th patch struct
        0x18,0x23,0xf6,0xf6,0x00,0x01,0x00,0xe7,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  14th patch struct
        0x15,0x91,0xf6,0xf6,0x00,0x01,0x00,0xf6,0xf6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  15th patch struct
        0x45,0x59,0xd3,0xf3,0x00,0x81,0x80,0xa3,0xf3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  16th patch struct
        0x03,0x49,0x75,0xf5,0x01,0x81,0x80,0xb5,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  17th patch struct
        0x71,0x92,0xf6,0x14,0x00,0x31,0x00,0xf1,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  18th patch struct
        0x72,0x14,0xc7,0x58,0x00,0x30,0x00,0xc7,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  19th patch struct
        0x70,0x44,0xaa,0x18,0x00,0xb1,0x00,0x8a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  20th patch struct
        0x23,0x93,0x97,0x23,0x01,0xb1,0x00,0x55,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  21th patch struct
        0x61,0x13,0x97,0x04,0x01,0xb1,0x80,0x55,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  22th patch struct
        0x24,0x48,0x98,0x2a,0x01,0xb1,0x00,0x46,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  23th patch struct
        0x61,0x13,0x91,0x06,0x01,0x21,0x00,0x61,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  24th patch struct
        0x21,0x13,0x71,0x06,0x00,0xa1,0x89,0x61,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  25th patch struct
        0x02,0x9c,0xf3,0x94,0x01,0x41,0x80,0xf3,0xc8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  26th patch struct
        0x03,0x54,0xf3,0x9a,0x01,0x11,0x00,0xf1,0xe7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  27th patch struct
        0x23,0x5f,0xf1,0x3a,0x00,0x21,0x00,0xf2,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  28th patch struct
        0x03,0x87,0xf6,0x22,0x01,0x21,0x80,0xf3,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  29th patch struct
        0x03,0x47,0xf9,0x54,0x00,0x21,0x00,0xf6,0x3a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  30th patch struct
        0x23,0x4a,0x91,0x41,0x01,0x21,0x05,0x84,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  31th patch struct
        0x23,0x4a,0x95,0x19,0x01,0x21,0x00,0x94,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  32th patch struct
        0x09,0xa1,0x20,0x4f,0x00,0x84,0x80,0xd1,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  33th patch struct
        0x21,0x1e,0x94,0x06,0x00,0xa2,0x00,0xc3,0xa6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  34th patch struct
        0x31,0x12,0xf1,0x28,0x00,0x31,0x00,0xf1,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  35th patch struct
        0x31,0x8d,0xf1,0xe8,0x00,0x31,0x00,0xf1,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  36th patch struct
        0x31,0x5b,0x51,0x28,0x00,0x32,0x00,0x71,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  37th patch struct
        0x01,0x8b,0xa1,0x9a,0x00,0x21,0x40,0xf2,0xdf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  38th patch struct
        0x21,0x8b,0xa2,0x16,0x00,0x21,0x08,0xa1,0xdf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  39th patch struct
        0x31,0x8b,0xf4,0xe8,0x00,0x31,0x00,0xf1,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  40th patch struct
        0x31,0x12,0xf1,0x28,0x00,0x31,0x00,0xf1,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  41th patch struct
        0x31,0x15,0xdd,0x13,0x01,0x21,0x00,0x56,0x26,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  42th patch struct
        0x31,0x16,0xdd,0x13,0x01,0x21,0x00,0x66,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  43th patch struct
        0x71,0x49,0xd1,0x1c,0x01,0x31,0x00,0x61,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  44th patch struct
        0x21,0x4d,0x71,0x12,0x01,0x23,0x80,0x72,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  45th patch struct
        0xf1,0x40,0xf1,0x21,0x01,0xe1,0x00,0x6f,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  46th patch struct
        0x02,0x1a,0xf5,0x75,0x01,0x01,0x80,0x85,0x35,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  47th patch struct
        0x02,0x1d,0xf5,0x75,0x01,0x01,0x80,0xf3,0xf4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  48th patch struct
        0x10,0x41,0xf5,0x05,0x01,0x11,0x00,0xf2,0xc3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  49th patch struct
        0x21,0x9b,0xb1,0x25,0x01,0xa2,0x01,0x72,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  50th patch struct
        0xa1,0x98,0x7f,0x03,0x01,0x21,0x00,0x3f,0x07,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  51st patch struct
        0xa1,0x93,0xc1,0x12,0x00,0x61,0x00,0x4f,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  52th patch struct
        0x21,0x18,0xc1,0x22,0x00,0x61,0x00,0x4f,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  53th patch struct
        0x31,0x5b,0xf4,0x15,0x00,0x72,0x83,0x8a,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  54th patch struct
        0xa1,0x90,0x74,0x39,0x00,0x61,0x00,0x71,0x67,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  55th patch struct
        0x71,0x57,0x54,0x05,0x00,0x72,0x00,0x7a,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  56th patch struct
        0x90,0x00,0x54,0x63,0x00,0x41,0x00,0xa5,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  57th patch struct
        0x21,0x92,0x85,0x17,0x00,0x21,0x01,0x8f,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  58th patch struct
        0x21,0x94,0x75,0x17,0x00,0x21,0x05,0x8f,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  59th patch struct
        0x21,0x94,0x76,0x15,0x00,0x61,0x00,0x82,0x37,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  60th patch struct
        0x31,0x43,0x9e,0x17,0x01,0x21,0x00,0x62,0x2c,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  61th patch struct
        0x21,0x9b,0x61,0x6a,0x00,0x21,0x00,0x7f,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  62th patch struct
        0x61,0x8a,0x75,0x1f,0x00,0x22,0x06,0x74,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  63th patch struct
        0xa1,0x86,0x72,0x55,0x01,0x21,0x83,0x71,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  64th patch struct
        0x21,0x4d,0x54,0x3c,0x00,0x21,0x00,0xa6,0x1c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  65th patch struct
        0x31,0x8f,0x93,0x02,0x01,0x61,0x00,0x72,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  66th patch struct
        0x31,0x8e,0x93,0x03,0x01,0x61,0x00,0x72,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x31,0x91,0x93,0x03,0x01,0x61,0x00,0x82,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x31,0x8e,0x93,0x0f,0x01,0x61,0x00,0x72,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x4b,0xaa,0x16,0x01,0x21,0x00,0x8f,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  70th patch struct
        0x31,0x90,0x7e,0x17,0x01,0x21,0x00,0x8b,0x0c,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  71th patch struct
        0x31,0x81,0x75,0x19,0x01,0x32,0x00,0x61,0x19,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  72th patch struct
        0x32,0x90,0x9b,0x21,0x00,0x21,0x00,0x72,0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  73th patch struct
        0xe1,0x1f,0x85,0x5f,0x00,0xe1,0x00,0x65,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  74th patch struct
        0xe1,0x46,0x88,0x5f,0x00,0xe1,0x00,0x65,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  75th patch struct
        0xa1,0x9c,0x75,0x1f,0x00,0x21,0x00,0x75,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  76th patch struct
        0x31,0x8b,0x84,0x58,0x00,0x21,0x00,0x65,0x1a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  77th patch struct
        0xe1,0x4c,0x66,0x56,0x00,0xa1,0x00,0x65,0x26,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  78th patch struct
        0x62,0xcb,0x76,0x46,0x00,0xa1,0x00,0x55,0x36,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  79th patch struct
        0x62,0x99,0x57,0x07,0x00,0xa1,0x00,0x56,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3b,0x00,0x02,0x00
    },{ //  80th patch struct
        0x62,0x93,0x77,0x07,0x00,0xa1,0x00,0x76,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3b,0x00,0x02,0x00
    },{ //  th patch struct
        0x22,0x59,0xff,0x03,0x02,0x21,0x00,0xff,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x0e,0xff,0x0f,0x01,0x21,0x00,0xff,0x0f,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x22,0x46,0x86,0x55,0x00,0x21,0x80,0x64,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x45,0x66,0x12,0x00,0xa1,0x00,0x96,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  85th patch struct
        0x21,0x8b,0x92,0x2a,0x01,0x22,0x00,0x91,0x2a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0xa2,0x9e,0xdf,0x05,0x00,0x61,0x40,0x6f,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  th patch struct
        0x20,0x1a,0xef,0x01,0x00,0x60,0x00,0x8f,0x06,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x8f,0xf1,0x29,0x00,0x21,0x80,0xf4,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x77,0xa5,0x53,0x94,0x00,0xa1,0x00,0xa0,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  90th patch struct
        0x61,0x1f,0xa8,0x11,0x00,0xb1,0x80,0x25,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x61,0x17,0x91,0x34,0x00,0x61,0x00,0x55,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  th patch struct
        0x71,0x5d,0x54,0x01,0x00,0x72,0x00,0x6a,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x97,0x21,0x43,0x00,0xa2,0x00,0x42,0x35,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0xa1,0x1c,0xa1,0x77,0x01,0x21,0x00,0x31,0x47,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  95th patch struct
        0x21,0x89,0x11,0x33,0x00,0x61,0x03,0x42,0x25,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0xa1,0x15,0x11,0x47,0x01,0x21,0x00,0xcf,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x3a,0xce,0xf8,0xf6,0x00,0x51,0x00,0x86,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x32,0x00,0x02,0x00
    },{ //  th patch struct
        0x21,0x15,0x21,0x23,0x01,0x21,0x00,0x41,0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x06,0x5b,0x74,0x95,0x00,0x01,0x00,0xa5,0x72,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  100th patch struct
        0x22,0x92,0xb1,0x81,0x00,0x61,0x83,0xf2,0x26,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  th patch struct
        0x41,0x4d,0xf1,0x51,0x01,0x42,0x00,0xf2,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x61,0x94,0x11,0x51,0x01,0xa3,0x80,0x11,0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x61,0x8c,0x11,0x31,0x00,0xa1,0x80,0x1d,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0xa4,0x4c,0xf3,0x73,0x01,0x61,0x00,0x81,0x23,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  105th patch struct
        0x02,0x85,0xd2,0x53,0x00,0x07,0x03,0xf2,0xf6,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x11,0x0c,0xa3,0x11,0x01,0x13,0x80,0xa2,0xe5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x11,0x06,0xf6,0x41,0x01,0x11,0x00,0xf2,0xe6,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x93,0x91,0xd4,0x32,0x00,0x91,0x00,0xeb,0x11,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x04,0x4f,0xfa,0x56,0x00,0x01,0x00,0xc2,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  110th patch struct
        0x21,0x49,0x7c,0x20,0x00,0x22,0x00,0x6f,0x0c,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x31,0x85,0xdd,0x33,0x01,0x21,0x00,0x56,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x20,0x04,0xda,0x05,0x02,0x21,0x81,0x8f,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x05,0x6a,0xf1,0xe5,0x00,0x03,0x80,0xc3,0xe5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x07,0x15,0xec,0x26,0x00,0x02,0x00,0xf8,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  115th patch struct
        0x05,0x9d,0x67,0x35,0x00,0x01,0x00,0xdf,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x18,0x96,0xfa,0x28,0x00,0x12,0x00,0xf8,0xe5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x10,0x86,0xa8,0x07,0x00,0x00,0x03,0xfa,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x11,0x41,0xf8,0x47,0x02,0x10,0x03,0xf3,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x01,0x8e,0xf1,0x06,0x02,0x10,0x00,0xf3,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  120th patch struct
        0x0e,0x00,0x1f,0x00,0x00,0xc0,0x00,0x1f,0xff,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x06,0x80,0xf8,0x24,0x00,0x03,0x88,0x56,0x84,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf8,0x00,0x00,0xd0,0x05,0x34,0x04,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf6,0x00,0x00,0xc0,0x00,0x1f,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0xd5,0x95,0x37,0xa3,0x00,0xda,0x40,0x56,0x37,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  125th patch struct
        0x35,0x5c,0xb2,0x61,0x02,0x14,0x08,0xf4,0x15,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  126th patch struct
        0x0e,0x00,0xf6,0x00,0x00,0xd0,0x00,0x4f,0xf5,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  127th patch struct
        0x26,0x00,0xff,0x01,0x00,0xe4,0x00,0x12,0x16,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  128th patch struct
        0x00,0x00,0xf3,0xf0,0x00,0x00,0x00,0xf6,0xc9,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  129th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  130th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  133th patch struct 
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  135th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  138th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  140th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  143th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  145th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  148th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  150th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  153th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  155th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  158th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  160th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  164th patch struct    FIRST DRUM patch. note 35
        0x10,0x44,0xf8,0x77,0x02,0x11,0x00,0xf3,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  165th patch struct
        0x10,0x44,0xf8,0x77,0x02,0x11,0x00,0xf3,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x02,0x07,0xf9,0xff,0x00,0x11,0x00,0xf8,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x00,0xfc,0x05,0x02,0x00,0x00,0xfa,0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x02,0xff,0x07,0x00,0x01,0x00,0xff,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x00,0xfc,0x05,0x02,0x00,0x00,0xfa,0x17,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  170th patch struct
        0x00,0x00,0xf6,0x0c,0x00,0x00,0x00,0xf6,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x0c,0x00,0xf6,0x08,0x00,0x12,0x00,0xfb,0x47,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x0c,0x00,0xf6,0x08,0x00,0x12,0x05,0x7b,0x47,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  175th patch struct
        0x0c,0x00,0xf6,0x02,0x00,0x12,0x00,0xcb,0x43,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3a,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf6,0x00,0x00,0xd0,0x00,0x9f,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x00,0x03,0xf8,0x2a,0x00,0x00,0x00,0xf6,0x45,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x34,0x00,0x02,0x00
    },{ //  180th patch struct
        0x0e,0x08,0xf8,0x42,0x00,0x07,0x4a,0xf4,0xe4,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf5,0x30,0x00,0xd0,0x0a,0x9f,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x0a,0xe4,0xe4,0x03,0x07,0x5d,0xf5,0xe5,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct
        0x02,0x03,0xb4,0x04,0x00,0x05,0x0a,0x97,0xf7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x4e,0x00,0xf6,0x00,0x00,0x9e,0x00,0x9f,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  185th patch struct
        0x11,0x45,0xf8,0x37,0x02,0x10,0x08,0xf3,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x38,0x00,0x02,0x00
    },{ //  th patch struct
        0x0e,0x00,0xf6,0x00,0x00,0xd0,0x00,0x9f,0x02,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct
        0x80,0x00,0xff,0x03,0x03,0x10,0x0d,0xff,0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3c,0x00,0x02,0x00
    },{ //  th patch struct note 59
        0x0e,0x08,0xf8,0x42,0x00,0x07,0x51,0xf4,0xe4,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct note 60
        0x06,0x0b,0xf5,0x0c,0x00,0x02,0x00,0xf5,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  190th patch struct note 61
        0x01,0x00,0xfa,0xbf,0x00,0x02,0x00,0xc8,0x97,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x37,0x00,0x02,0x00
    },{ //  th patch struct note 62
        0x01,0x51,0xfa,0x87,0x00,0x01,0x00,0xfa,0xb7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct note 63
        0x01,0x54,0xfa,0x8d,0x00,0x02,0x00,0xf8,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct note 64
        0x01,0x59,0xfa,0x88,0x00,0x02,0x00,0xf8,0xb6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  th patch struct note 65
        0x01,0x00,0xf9,0x0a,0x03,0x00,0x00,0xfa,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  195th patch struct note 66
        0x00,0x80,0xf9,0x89,0x03,0x00,0x00,0xf6,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct note 67
        0x03,0x80,0xf8,0x88,0x03,0x0c,0x08,0xf6,0xb6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3f,0x00,0x02,0x00
    },{ //  th patch struct note 68
        0x03,0x85,0xf8,0x88,0x03,0x0c,0x00,0xf6,0xb6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3f,0x00,0x02,0x00
    },{ //  th patch struct note 69
        0x0e,0x40,0x76,0x4f,0x00,0x00,0x08,0x77,0x18,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  th patch struct note 70
        0x0e,0x40,0xc8,0x49,0x00,0x03,0x00,0x9b,0x69,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  200th patch struct note 71
        0xd7,0xdc,0xad,0x05,0x03,0xc7,0x00,0x8d,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  201th patch struct note 72
        0xd7,0xdc,0xa8,0x04,0x03,0xc7,0x00,0x88,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  202th patch struct note 73
        0x80,0x00,0xf6,0x06,0x03,0x11,0x00,0x67,0x17,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  203th patch struct note 74
        0x80,0x00,0xf5,0x05,0x02,0x11,0x09,0x46,0x16,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x3e,0x00,0x02,0x00
    },{ //  204th patch struct note 75
        0x06,0x3f,0x00,0xf4,0x00,0x15,0x00,0xf7,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x31,0x00,0x02,0x00
    },{ //  205th patch struct     42nd DRUM patch note 76
        0x06,0x3f,0x00,0xf4,0x03,0x12,0x00,0xf7,0xf5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x30,0x00,0x02,0x00
    },{ //  206th patch struct note 77 (low wood block from 60 high bongo)
        0x06,0x0b,0xf5,0x0c,0x00,0x02,0x00,0xf5,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x36,0x00,0x02,0x00
//        0x06,0x0b,0xf5,0x0c,0x00,0x02,0x00,0xf5,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  207th patch struct note 78 (mute cuica from 62 mute hi conga)
        0x01,0x51,0xfa,0x87,0x00,0x01,0x00,0xfa,0xb7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x36,0x00,0x02,0x00
//        0x01,0x51,0xfa,0x87,0x00,0x01,0x00,0xfa,0xb7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  208th patch struct note 79 (open cuica from 63 open hi conga)
        0x01,0x54,0xfa,0x8d,0x00,0x02,0x00,0xf8,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x36,0x00,0x02,0x00
//        0x01,0x54,0xfa,0x8d,0x00,0x02,0x00,0xf8,0xb8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x36,0x00,0x02,0x00
    },{ //  209th patch struct note 80 (mute triangle from NT - note 53 ride bell)
        0x01,0x2E,0xF5,0xF5,0x05,0x11,0x02,0xA5,0x34,0x00,0x0E,0x08,0xF1,0xF1,0x02,0x18,0x05,0xC9,0xA6,0x02,0x9A,0x67,0x14,0x10,0x30,0x7E,0x01,0x9A 
//        0x01,0x2E,0xF5,0xF5,0x05,0x11,0x02,0xA5,0x34,0x00,0x0E,0x08,0xF1,0xF1,0x02,0x18,0x05,0xC9,0xA6,0x02,0x9A,0x67,0x10,0x10,0x30,0x7E,0x01,0x9A 
    },{ //  210th patch struct note 81 (open triangle from NT - note 81)
        0x29,0x27,0xF1,0x41,0x00,0x04,0x00,0xF7,0x43,0x00,0x9A,0xFE,0x05,0x00,0x00,0x52,0x50,0x9A,0x1E,0x06,0x00,0x00,0x1C,0x10,0x32,0x5A,0x02,0x6A
//        0x29,0x27,0xF1,0x41,0x00,0x04,0x00,0xF7,0x43,0x00,0x9A,0xFE,0x05,0x00,0x00,0x52,0x50,0x9A,0x1E,0x06,0x00,0x00,0x18,0x10,0x32,0x5A,0x02,0x6A
    },{ //  211th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  212th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  213th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  214th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  215th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  216th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  221th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  226th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  231th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  236th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  240th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  245th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  246th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  247th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  248th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  249th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  250th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  251th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  252th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  253th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  254th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  255th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    },{ //  256th patch struct
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\driver\device.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

//
// We want the global debug variables here.
//
#define DEFINE_DEBUG_VARS

//
// Every debug output has "STR_MODULENAME text"
//
static char STR_MODULENAME[] = "GFX device: ";

#include "common.h"

//
// The table points to the filter descriptors of the device.
// We have only one filter descriptor which is defined in filter.cpp
//
DEFINE_KSFILTER_DESCRIPTOR_TABLE (FilterDescriptorTable)
{   
    &FilterDescriptor
};

//
// This defines the device descriptor. It has a dispatch table +
// the filter descriptors.
// We do not need to intercept PnP messages, so we keep the dispatch table
// empty and KS will deal with that.
//
const KSDEVICE_DESCRIPTOR DeviceDescriptor =
{   
    NULL,
    SIZEOF_ARRAY(FilterDescriptorTable),
    FilterDescriptorTable
};

/**************************************************************************
 * DriverEntry
 **************************************************************************
 * This function is called by the operating system when the filter is loaded.
 */
extern "C"
NTSTATUS DriverEntry (IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING pRegistryPathName)
{
    PAGED_CODE ();
    
    DOUT (DBG_PRINT, ("DriverEntry"));

    return KsInitializeDriver (pDriverObject, pRegistryPathName, &DeviceDescriptor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\driver\filter.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

typedef class CGFXFilter
{
public:
    BOOL        enableChannelSwap;
    ULONGLONG   bytesProcessed;

public:
    CGFXFilter() {enableChannelSwap = TRUE, bytesProcessed = 0;}
    ~CGFXFilter() {}

    //
    // Create and Close are used to construct and destruct, respectively the
    // client CGFXFilter object.  Process gets called by the ks when there 
    // is work to be done. 
    //
    static NTSTATUS Create
    (
        IN OUT PKSFILTER filter,
        IN PIRP          irp
    );
    static NTSTATUS Close
    (
        IN OUT PKSFILTER filter,
        IN PIRP          irp
    );
    static NTSTATUS Process
    (
        IN PKSFILTER                filter,
        IN PKSPROCESSPIN_INDEXENTRY processPinsIndex
    );
} GFXFILTER, *PGFXFILTER;

//---------------------------------------------------------------------------
// Globals
//---------------------------------------------------------------------------

extern const KSFILTER_DESCRIPTOR FilterDescriptor;

//---------------------------------------------------------------------------
// Local prototypes
//---------------------------------------------------------------------------
// These are all properties function prototypes. Feel free to move them
// into a "FilterProperty" object if you want.

NTSTATUS PropertySaveState
(
    IN PIRP         irp,
    IN PKSPROPERTY  property,
    IN OUT PVOID    data
);
NTSTATUS PropertyGetFilterState
(
    IN PIRP         irp,
    IN PKSPROPERTY  property,
    OUT PVOID       data
);

NTSTATUS PropertySetRenderTargetDeviceId
(
    IN PIRP         irp,
    IN PKSPROPERTY  property,
    IN PVOID        data
);

NTSTATUS PropertySetCaptureTargetDeviceId
(
    IN PIRP         irp,
    IN PKSPROPERTY  property,
    IN PVOID        data
);

NTSTATUS PropertyDrmSetContentId
(
    IN PIRP         irp,
    IN PKSPROPERTY  property,
    IN PVOID        drmData
);

NTSTATUS PropertyChannelSwap
(
    IN     PIRP        irp,
    IN     PKSPROPERTY property,
    IN OUT PVOID       data
);

NTSTATUS PropertyAudioPosition
(
    IN PIRP                  irp,
    IN PKSPROPERTY           property,
    IN OUT PKSAUDIO_POSITION position
);

NTSTATUS DataRangeIntersection
(
    IN PVOID            Filter,
    IN PIRP             Irp,
    IN PKSP_PIN         PinInstance,
    IN PKSDATARANGE     CallerDataRange,
    IN PKSDATARANGE     DescriptorDataRange,
    IN ULONG            BufferSize,
    OUT PVOID           Data OPTIONAL,
    OUT PULONG          DataSize
);

NTSTATUS PropertyDataFormat
(
    IN PIRP         pIrp,
    IN PKSPROPERTY  pProperty,
    IN PVOID        pVoid
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\driver\filter.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

//
// Every debug output has "Modulname text"
//
static char STR_MODULENAME[] = "GFX filter: ";

#include "common.h"
#include <msgfx.h>

//
// These defines are used to describe the framing requirements.
// MAX_NUMBER_OF_FRAMES are the max number of frames that float between the
// output pin of this filter and the input pin of the lower filter (which
// would be the audio driver) and FRAME_SIZE is the buffer (frame) size.
// 3306 is the max. size of a 10ms buffer (55010Hz * 24bit * stereo). The
// buffers don't get filled completely if not neccessary.
//
#define MAX_NUMBER_OF_FRAMES    8
#define FRAME_SIZE              3306

//
// Define the pin data range here. Since we are an autoload GFX that loads on
// the Microsoft USB speakers (DSS 80), we have to support the same data range
// than the USB speakers.
// If you do not support the same data range then you restrict the audio stack
// from the mixer down with your limitations. For example, in case you would
// only support 48KHz 16 bit stereo PCM data then only this can be played by
// the audio driver even though it might have the ability to play 44.1KHz
// also.
// List the data ranges in the preferred connection order, that means, first
// list the data range you always would like to connect with the audio driver,
// if the DataRangeIntersection with the audio driver fails, then the second
// data range gets used etc.
// Please don't use wildcards in the data range, because ValidateDataFormat
// and the DataRangeIntersection functions wouldn't work anymore. Both
// functions also only work with KSDATAFORMAT_SPECIFIER_WAVEFORMATEX. If your
// device can handle float or other formats then you need to modify those
// functions. Also take a look at GFXPinSetDataFormat.
//
const KSDATARANGE_AUDIO PinDataRanges[] = 
{
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            6,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),              // major format
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),             // sub format
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)   // wave format
        },
        2,          // channels
        24,         // min. bits per sample
        24,         // max. bits per sample
        4990,       // min. sample rate
        55010       // max. sample rate
    },
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            4,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),              // major format
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),             // sub format
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)   // wave format
        },
        2,          // channels
        16,         // min. bits per sample
        16,         // max. bits per sample
        4990,       // min. sample rate
        55010       // max. sample rate
    }

};

//
// This structure points to the different pin data ranges that we defined.
//
const PKSDATARANGE DataRanges[] =
{
    PKSDATARANGE(&PinDataRanges[0]),        // the 24bit data range
    PKSDATARANGE(&PinDataRanges[1])         // the 16bit data range
};

//
// This will define the framing requirements that are used in the pin descrip-
// tor. Note that we can also deal with other framing requirements as the flag
// KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY indicates. Note also that KS will
// allocate the non-paged buffers (MAX_NUMBER_OF_FRAMES * FRAME_SIZE) for you,
// so don't be too greedy here.
//
DECLARE_SIMPLE_FRAMING_EX
(
    AllocatorFraming,                               // Name of the framing structure
    STATIC_KSMEMORY_TYPE_KERNEL_PAGED,              // memory type that's used for allocation
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |        // flags
    KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    MAX_NUMBER_OF_FRAMES,                           // max. number of frames
    31,                                             // 32-byte alignment
    FRAME_SIZE,                                     // min. frame size
    FRAME_SIZE                                      // max. frame size
);

//
// DEFINE_KSPROPERTY_TABLE defines a KSPROPERTY_ITEM. We use these macros to
// define properties in a property set. A property set is represented as a GUID.
// It contains property items that have a functionality. You could imagine that
// a property set is a function group and a property a function. An example for
// a property set is KSPROPSETID_Audio, a property item in this set is for
// example KSPROPERTY_AUDIO_POSITION
// We add here the pre-defined (in ksmedia.h) property for the audio position
// to the pin.
//

//
// Define the KSPROPERTY_AUDIO_POSITION property item.
//
DEFINE_KSPROPERTY_TABLE (AudioPinPropertyTable)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_AUDIO_POSITION,      // property item defined in ksmedia.h
        PropertyAudioPosition,          // our "get" property handler
        sizeof(KSPROPERTY),             // minimum buffer length for property
        sizeof(KSAUDIO_POSITION),       // minimum buffer length for returned data
        PropertyAudioPosition,          // our "set" property handler
        NULL,                           // default values
        0,                              // related properties
        NULL,
        NULL,                           // no raw serialization handler
        0                               // don't serialize
    )
};

//
// Define the KSPROPERTY_DRMAUDIOSTREAM_CONTENTID property item.
//
DEFINE_KSPROPERTY_TABLE (PinPropertyTable_DRM)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_DRMAUDIOSTREAM_CONTENTID,    // property item defined in ksmedia.h
        NULL,                                   // does not support "get"
        sizeof(KSPROPERTY),                     // minimum buffer length for property
        sizeof(ULONG)+sizeof(DRMRIGHTS),        // minimum buffer length for returned data
        PropertyDrmSetContentId,                // our "set" property handler
        NULL,                                   // default values
        0,                                      // related properties
        NULL,
        NULL,                                   // no raw serialization handler
        0                                       // don't serialize
    )
};

//
// Define the property sets KSPROPSETID_Audio and KSPROPSETID_Connection.
// They both will be added to the pin descriptor through the automation table.
//
DEFINE_KSPROPERTY_SET_TABLE (PinPropertySetTable)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Audio,                     // property set defined in ksmedia.h
        SIZEOF_ARRAY(AudioPinPropertyTable),    // the properties supported
        AudioPinPropertyTable,
        0,                                      // reserved
        NULL                                    // reserved
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_DrmAudioStream,            // property set defined in ksmedia.h
        SIZEOF_ARRAY(PinPropertyTable_DRM),     // the properties supported
        PinPropertyTable_DRM,
        0,                                      // reserved
        NULL                                    // reserved
    )
};

//
// This defines the automation table. The automation table will be added to
// the pin descriptor and has pointers to the porperty (set) table, method
// table and event table.
//
DEFINE_KSAUTOMATION_TABLE (PinAutomationTable)
{
    DEFINE_KSAUTOMATION_PROPERTIES (PinPropertySetTable),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

//
// This defines the pin dispatch table. We need to provide our own dispatch
// functions because we have special requirements (for example, input and
// output pin need to have the same sample format).
//
const KSPIN_DISPATCH GFXSinkPinDispatch =
{
    CGFXPin::Create,            // Create
    CGFXPin::Close,             // Close
    NULL,                       // Process
    NULL,                       // Reset
    CGFXPin::SetDataFormat,     // SetDataFormat
    CGFXPin::SetDeviceState,    // SetDeviceState
    NULL,                       // Connect
    NULL,                       // Disconnect
    NULL,                       // Clock
    NULL                        // Allocator
};

const KSPIN_DISPATCH GFXSourcePinDispatch =
{
    NULL,                       // Create
    NULL,                       // Close
    NULL,                       // Process
    NULL,                       // Reset
    CGFXPin::SetDataFormat,     // SetDataFormat
    NULL,                       // SetDeviceState
    NULL,                       // Connect
    NULL,                       // Disconnect
    NULL,                       // Clock
    NULL                        // Allocator
};

//
// This defines the pin descriptor for a filter.
// The pin descriptor has pointers to the dispatch functions, automation
// tables, basic pin descriptor etc. - just everything you need ;)
//
const KSPIN_DESCRIPTOR_EX PinDescriptors[]=
{
    {   // This is the first pin. It's the top pin of the filter for incoming
        // data flow

        &GFXSinkPinDispatch,                    // dispatch table
        &PinAutomationTable,                    // automation table
        {                                       // basic pin descriptor
            DEFINE_KSPIN_DEFAULT_INTERFACES,    // default interfaces
            DEFINE_KSPIN_DEFAULT_MEDIUMS,       // default mediums
            SIZEOF_ARRAY(DataRanges),           // pin data ranges
            DataRanges,
            KSPIN_DATAFLOW_IN,                  // data flow in (into the GFX)
            KSPIN_COMMUNICATION_BOTH,           // KS2 will handle that
            NULL,                               // Category GUID
            NULL,                               // Name GUID
            0                                   // ConstrainedDataRangesCount
        },
        NULL,                                   // Flags. Since we are filter centric, these flags
                                                // won't effect anything
        1,                                      // max. InstancesPossible
        1,                                      // InstancesNecessary for processing
        &AllocatorFraming,                      // Allocator framing requirements.
        CGFXPin::DataRangeIntersection          // Out data intersection handler (we need one!)
    },
    
    {   // This is the second pin. It's the bottom pin of the filter for outgoing
        // data flow. Everything is the same as above, except for the data flow
        // and the pin dispatch table.
        &GFXSourcePinDispatch,
        &PinAutomationTable,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(DataRanges),
            DataRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            NULL,
            NULL,
            0
        },
        NULL,
        1,
        1,
        &AllocatorFraming,
        CGFXPin::DataRangeIntersection
    }
};

//
// DEFINE_KSPROPERTY_TABLE defines a KSPROPERTY_ITEM. We use these macros to
// define properties in a property set. A property set is represented as a
// GUID. It contains property items that have a functionality. You could
// imagine that a property set is a function group and a property a function.
// An example for a property set is KSPROPSETID_Audio, a property item in this
// set is for example KSPROPERTY_AUDIO_POSITION.
// We add here our private property for controlling the GFX (channel swap
// on/off) which will be added to the node descriptor.
//

//
// Define our private KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP property item.
//
DEFINE_KSPROPERTY_TABLE (AudioNodePropertyTable)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP, // property item defined in msgfx.h
        PropertyChannelSwap,                // our "get" property handler
        sizeof(KSP_NODE),                   // minimum buffer length for property
        sizeof(ULONG),                      // minimum buffer length for returned data
        PropertyChannelSwap,                // our "set" property handler
        NULL,                               // default values
        0,                                  // related properties
        NULL,
        NULL,                               // no raw serialization handler
        sizeof(ULONG)                       // Serialized size
    )
};

//
// Define the private property set KSPROPSETID_MsGfxSample.
// The property set will be added to the node descriptor through the automation
// table.
//
DEFINE_KSPROPERTY_SET_TABLE (NodePropertySetTable)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_MsGfxSample,               // property set defined in msgfx.h
        SIZEOF_ARRAY(AudioNodePropertyTable),   // the properties supported
        AudioNodePropertyTable,
        0,                                      // reserved
        NULL                                    // reserved
    )
};

//
// This defines the automation table. The automation table will be added to
// the node descriptor and has pointers to the porperty (set) table, method
// table and event table.
//
DEFINE_KSAUTOMATION_TABLE (NodeAutomationTable)
{
    DEFINE_KSAUTOMATION_PROPERTIES (NodePropertySetTable),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

//
// This defines the node descriptor for a (filter) node.
// The node descriptor has pointers to the automation table and the type & name
// of the node.
// We have only one node that is for the private property.
//
const KSNODE_DESCRIPTOR NodeDescriptors[] =
{
    DEFINE_NODE_DESCRIPTOR
    (
        &NodeAutomationTable,               // Automation table (for the properties)
        &GFXSAMPLE_NODETYPE_CHANNEL_SWAP,   // Type of node
        &GFXSAMPLE_NODENAME_CHANNEL_SWAP    // Name of node
    )
};

//
// Define our private KSPROPERTY_MSGFXSAMPLE_SAVESTATE property item.
//
DEFINE_KSPROPERTY_TABLE (FilterPropertyTable_SaveState)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_MSGFXSAMPLE_SAVESTATE,   // property item defined in msgfx.h
        PropertySaveState,                  // our "get" property handler
        sizeof(KSPROPERTY),                 // minimum buffer length for property
        sizeof(ULONG),                      // minimum buffer length for returned data
        PropertySaveState,                  // our "set" property handler
        NULL,                               // default values
        0,                                  // related properties
        NULL,
        NULL,                               // no raw serialization handler
        sizeof(ULONG)                       // Serialized size
    )
};

//
// Define the items for the property set KSPROPSETID_AudioGfx, which are
// KSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID and
// KSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID.
//
DEFINE_KSPROPERTY_TABLE (FilterPropertyTable_AudioGfx)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID,   // property item defined in msgfx.h
        NULL,                                       // no "get" property handler
        sizeof(KSPROPERTY),                         // minimum buffer length for property
        sizeof(WCHAR),                              // minimum buffer length for returned data
        PropertySetRenderTargetDeviceId,            // our "set" property handler
        NULL,                                       // default values
        0,                                          // related properties
        NULL,
        NULL,                                       // no raw serialization handler
        0                                           // don't serialize
    ),
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID,  // property item defined in msgfx.h
        NULL,                                       // no "get" property handler
        sizeof(KSPROPERTY),                         // minimum buffer length for property
        sizeof(WCHAR),                              // minimum buffer length for returned data
        PropertySetCaptureTargetDeviceId,           // our "set" property handler
        NULL,                                       // default values
        0,                                          // related properties
        NULL,
        NULL,                                       // no raw serialization handler
        0                                           // don't serialize
    )
};

//
// Define the items for the property set KSPROPSETID_Audio, which are
// KSPROPERTY_AUDIO_FILTER_STATE.
//
DEFINE_KSPROPERTY_TABLE (FilterPropertyTable_Audio)
{
    DEFINE_KSPROPERTY_ITEM
    (
        KSPROPERTY_AUDIO_FILTER_STATE,      // property item defined in msgfx.h
        PropertyGetFilterState,             // our "get" property handler
        sizeof(KSPROPERTY),                 // minimum buffer length for property
        0,                                  // minimum buffer length for returned data
        NULL,                               // no "set" property handler
        NULL,                               // default values
        0,                                  // related properties
        NULL,
        NULL,                               // no raw serialization handler
        0                                   // don't serialize
    )
};

//
// Define the property sets KSPROPSETID_SaveState, KSPROPSETID_AudioGfx,
// KSPROPSETID_Audio and KSPROPSETID_DrmAudioStream. They will be added to
// the filter descriptor through the automation table.
//
DEFINE_KSPROPERTY_SET_TABLE (FilterPropertySetTable)
{
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_SaveState,                         // property set defined in msgfx.h
        SIZEOF_ARRAY(FilterPropertyTable_SaveState),    // the properties supported
        FilterPropertyTable_SaveState,
        0,                                              // reserved
        NULL                                            // reserved
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_AudioGfx,                          // property set defined in msgfx.h
        SIZEOF_ARRAY(FilterPropertyTable_AudioGfx),     // the properties supported
        FilterPropertyTable_AudioGfx,
        0,                                              // reserved
        NULL                                            // reserved
    ),
    DEFINE_KSPROPERTY_SET
    (
        &KSPROPSETID_Audio,                             // property set defined in msgfx.h
        SIZEOF_ARRAY(FilterPropertyTable_Audio),        // the properties supported
        FilterPropertyTable_Audio,
        0,                                              // reserved
        NULL                                            // reserved
    )
};

//
// This defines the automation table. The automation table will be added to the
// filter descriptor and has pointers to the porperty (set) table, method table
// and event table.
//
DEFINE_KSAUTOMATION_TABLE (FilterAutomationTable)
{
    DEFINE_KSAUTOMATION_PROPERTIES (FilterPropertySetTable),
    DEFINE_KSAUTOMATION_METHODS_NULL,
    DEFINE_KSAUTOMATION_EVENTS_NULL
};

//
// The categories of the filter.
//
const GUID Categories[] =
{
    STATICGUIDOF(KSCATEGORY_AUDIO),
    STATICGUIDOF(KSCATEGORY_DATATRANSFORM)
};

//
// The dispath handlers of the filter.
//
const KSFILTER_DISPATCH FilterDispatch =
{
    CGFXFilter::Create,
    CGFXFilter::Close,
    CGFXFilter::Process,
    NULL                    // Reset
};

//
// The connection table
//
const KSTOPOLOGY_CONNECTION FilterConnections[] =
{
    // From Pin0 (input pin) to Node0 - pin1 (input of our "channel swap" node)
    {KSFILTER_NODE, 0, 0, 1},
    // From Node0 - pin0 (output of our "channel swap" node) to pin1 (output pin)
    {0, 0, KSFILTER_NODE, 1}
};

//
// This defines the filter descriptor.
//
DEFINE_KSFILTER_DESCRIPTOR (FilterDescriptor)
{
    &FilterDispatch,                                    // Dispath table
    &FilterAutomationTable,                             // Automation table
    KSFILTER_DESCRIPTOR_VERSION,
    KSFILTER_FLAG_CRITICAL_PROCESSING,                  // Flags
    &KSNAME_MsGfxSample,                                // The name of the filter
    DEFINE_KSFILTER_PIN_DESCRIPTORS (PinDescriptors),
    DEFINE_KSFILTER_CATEGORIES (Categories),
    DEFINE_KSFILTER_NODE_DESCRIPTORS (NodeDescriptors),
    DEFINE_KSFILTER_CONNECTIONS (FilterConnections),
    NULL                                                // Component ID
};

/*****************************************************************************
 * CGFXFilter::Create
 *****************************************************************************
 * This routine is called when a  filter is created.  It instantiates the
 * client filter object and attaches it to the  filter structure.
 * 
 * Arguments:
 *    filter - Contains a pointer to the  filter structure.
 *    irp    - Contains a pointer to the create request.
 *
 * Return Value:
 *    STATUS_SUCCESS or, if the filter could not be instantiated, 
 *    STATUS_INSUFFICIENT_RESOURCES.
 */
NTSTATUS CGFXFilter::Create
(
    IN OUT PKSFILTER filter,
    IN     PIRP      irp
)
{
    PAGED_CODE ();
    
    PGFXFILTER gfxFilter;

    DOUT (DBG_PRINT, ("[Create]"));
    
    //
    // Check the filter context
    //
    if (filter->Context)
    {
        DOUT (DBG_ERROR, ("[Create] filter context already exists!"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Create an instance of the client filter object.
    //
    gfxFilter = new (PagedPool, GFXSWAP_POOL_TAG) GFXFILTER;
    if(gfxFilter == NULL)
    {
        DOUT (DBG_ERROR, ("[Create] couldn't allocate gfx filter object!"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    //
    // Attach it to the filter structure.
    //
    filter->Context = (PVOID)gfxFilter;
    DOUT (DBG_PRINT, ("[Create] gfxFilter %08x", gfxFilter));
    
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXFilter::Close
 *****************************************************************************
 * This routine is called when a  filter is closed.  It deletes the
 * client filter object attached it to the  filter structure.
 * 
 * Arguments:
 *    filter - Contains a pointer to the  filter structure.
 *    irp    - Contains a pointer to the create request.
 *
 * Return Value:
 *    STATUS_SUCCESS.
 */
NTSTATUS CGFXFilter::Close
(
    IN PKSFILTER filter,
    IN PIRP      irp
)
{
    PAGED_CODE ();
    
    DOUT (DBG_PRINT, ("[Close] gfxFilter %08x", filter->Context));
    
    // delete is safe with NULL pointers.
    delete (PGFXFILTER)filter->Context;
    
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXFilter::Process
 *****************************************************************************
 * This routine is called when there is data to be processed.
 * 
 * Arguments:
 *    filter - Contains a pointer to the  filter structure.
 *    processPinsIndex -
 *       Contains a pointer to an array of process pin index entries.  This
 *       array is indexed by pin ID.  An index entry indicates the number 
 *       of pin instances for the corresponding pin type and points to the
 *       first corresponding process pin structure in the ProcessPins array.
 *       This allows process pin structures to be quickly accessed by pin ID
 *       when the number of instances per type is not known in advance.
 *
 * Return Value:
 *    STATUS_SUCCESS or STATUS_PENDING.
 */
NTSTATUS CGFXFilter::Process
(
    IN PKSFILTER                filter,
    IN PKSPROCESSPIN_INDEXENTRY processPinsIndex
)
{
    PAGED_CODE ();
    
    PGFXFILTER      gfxFilter = (PGFXFILTER)filter->Context;
    PKSPROCESSPIN   inPin, outPin;
    ULONG           ulByteCount, ulBytesProcessed;

    //
    // The first pin is the input pin, then we have an output pin.
    //
    inPin  = processPinsIndex[0].Pins[0];
    outPin = processPinsIndex[1].Pins[0];

    // Makes it easier to read.
    PKSDATAFORMAT_WAVEFORMATEX pWaveFmt =
        (PKSDATAFORMAT_WAVEFORMATEX)inPin->Pin->ConnectionFormat;
    
    //
    // Find out how much data we have to process.
    // Calculate the number of bytes we can processed for the buffer. Ideally
    // this would always be equal ulByteCount since we have our framing
    // requirements calculated to fit a 10ms buffer, but we might also get
    // more. Note that the 3306 bytes won't hold complete stereo 16bit samples.
    //
    ulByteCount = min (inPin->BytesAvailable, outPin->BytesAvailable);
    ulByteCount = ulByteCount -
        ulByteCount % ((pWaveFmt->WaveFormatEx.nChannels *
                        pWaveFmt->WaveFormatEx.wBitsPerSample) >> 3);

    //
    // Start process here.
    // We only do a channel swap if we are connected with a stereo format and we
    // are supposed to channel swap.
    //
    if (((PGFXFILTER)filter->Context)->enableChannelSwap &&
        (pWaveFmt->WaveFormatEx.nChannels == 2))
    {
        //
        // Check the data format of the pin. We have 2 different process
        // routines, one for 16bit and one for 24bit data.
        //
        if (pWaveFmt->WaveFormatEx.wBitsPerSample == 16)
        {
            //
            // Do the 16bit channel swap
            //
            PSHORT  in = (PSHORT)inPin->Data;
            PSHORT out = (PSHORT)outPin->Data;
            SHORT wSwap;
            
            //
            // loop through & swap
            //
            for (int nLoop = ulByteCount; nLoop; nLoop -= 4)
            {
                // In case the input and output buffers are the same
                // (in-place processing) we need to use a wSwap
                // to store one sample.
                wSwap = *in;
                *out = *(in + 1);
                out++;
                *out = wSwap;
                out++;
                in += 2;
            }
        }
        else
        {
            //
            // This must be 24bit channel swap since we only accept 16 or 24bit.
            //
            struct tag3Bytes
            {
                BYTE    a, b, c;
            };
            typedef tag3Bytes   THREEBYTES;

            THREEBYTES  *in = (THREEBYTES *)inPin->Data;
            THREEBYTES *out = (THREEBYTES *)outPin->Data;
            THREEBYTES wSwap;
            
            //
            // loop through & swap
            //
            for (int nLoop = ulByteCount; nLoop; nLoop -= 6)
            {
                // In case the input and output buffers are the same
                // (in-place processing) we need to use a wSwap
                // to store one sample.
                wSwap = *in;
                *out = *(in + 1);
                out++;
                *out = wSwap;
                out++;
                in += 2;
            }
        }
    }
    else
    {
        //
        // No swap required.
        // In case we do in-place processing we don't need to do a data copy.
        // Note that the InPlaceCounterpart pointer must point to the outPin
        // since we only have one in and out pin.
        //
        if (!inPin->InPlaceCounterpart)
            RtlCopyMemory (outPin->Data, inPin->Data, ulByteCount);
    }

    //
    // Report back how much data we processed
    //
    inPin->BytesUsed = outPin->BytesUsed = ulByteCount;

    // Update the bytesProcessed variable in the filter.
    // We start assuming that bytesProcessed is 0. The loop makes sure that if this is not
    // the case (which most likely will not) that bytesProcessed gets read in an interlocked
    // fashion, then modified and written back on the 2nd loop.
    ULONGLONG oldBytesProcessed = 0;
    ULONGLONG newBytesProcessed = ulByteCount;
    ULONGLONG returnValue;

    // ExInterlockedCompareExchange64 doesn't use the 4th parameter.
    while ((returnValue = ExInterlockedCompareExchange64 ((LONGLONG *)&gfxFilter->bytesProcessed,
            (LONGLONG *)&newBytesProcessed, (LONGLONG *)&oldBytesProcessed, NULL)) != oldBytesProcessed)
    {
        oldBytesProcessed = returnValue;
        newBytesProcessed = returnValue + ulByteCount;
    }

    //
    // Do not pack frames. Submit what we have so that we don't
    // hold off the audio stack.
    //
    outPin->Terminate = TRUE;

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * PropertyGetFilterState
 *****************************************************************************
 * Returns the property sets that comprise the persistable filter settings.
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the get.
 *    property  - not used in this function.
 *    data      - return buffer which will contain the property sets.
 */
NTSTATUS PropertyGetFilterState
(
    IN  PIRP        irp,
    IN  PKSPROPERTY property,
    OUT PVOID       data
)
{
    PAGED_CODE ();
    
    NTSTATUS ntStatus;

    DOUT (DBG_PRINT, ("[PropertyGetFilterState]"));
    
    //
    // These are the property set IDs that we return.
    //
    GUID SaveStatePropertySets[] =
    {
        STATIC_KSPROPSETID_SaveState
    };

    //
    // Get the output buffer length.
    //
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation (irp);
    ULONG              cbData = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Check buffer length.
    //
    if (!cbData)
    {
        //
        // 0 buffer length requests the buffer size needed.
        //
        irp->IoStatus.Information = sizeof(SaveStatePropertySets);
        ntStatus = STATUS_BUFFER_OVERFLOW;
    }
    else
        if (cbData < sizeof(SaveStatePropertySets))
        {
            //
            // This buffer is simply too small
            //
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            //
            // Right size. Copy the property set IDs.
            //
            RtlCopyMemory (data, SaveStatePropertySets, sizeof(SaveStatePropertySets));
            irp->IoStatus.Information = sizeof(SaveStatePropertySets);
            ntStatus = STATUS_SUCCESS;
        }

    return ntStatus;
}

/*****************************************************************************
 * PropertySetRenderTargetDeviceId
 *****************************************************************************
 * Advises the GFX of the hardware PnP ID of the target render device.
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the set.
 *    property  - not used in this function.
 *    data      - Pointer to Unicode string containing the hardware PnP ID of
 *                 the target render device
 */
NTSTATUS PropertySetRenderTargetDeviceId
(
    IN PIRP        irp,
    IN PKSPROPERTY property,
    IN PVOID       data
)
{
    PAGED_CODE ();
    
    PWSTR    deviceId;
    NTSTATUS ntStatus;

    DOUT (DBG_PRINT, ("[PropertySetRenderTargetDeviceId]"));
    
    //
    // Get the output buffer length.
    //
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
    ULONG              cbData = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    // check for reasonable values
    if (!cbData || cbData > 1024)
        return STATUS_UNSUCCESSFUL;

    //
    // Handle this property if you are interested in the PnP device ID
    // of the target render device on which this GFX is applied
    //
    // For now we just copy the PnP device ID and print it on the debugger,
    // then we discard it. You could for example compare the PnP ID string
    // with the ones in the INF file to make sure nobody altered the INF
    // file to apply your GFX to a different device.
    //
    deviceId = (PWSTR)ExAllocatePoolWithTag (PagedPool, cbData, GFXSWAP_POOL_TAG);
    if (deviceId)
    {
        //
        // Copy the PnP device ID.
        //
        RtlCopyMemory ((PVOID)deviceId, data, cbData);
        
        //
        // Ensure last character is NULL
        //
        deviceId[(cbData/sizeof(deviceId[0]))-1] = L'\0';
        
        //
        // Print out the string.
        //
        DOUT (DBG_PRINT, ("[PropertySetRenderTargetDeviceId] ID is [%ls]", deviceId));

        //
        // If you are interested in the DeviceId and need to store it then
        // you probably wouldn't free the memory here.
        //
        ExFreePool (deviceId);
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        DOUT (DBG_WARNING, ("[PropertySetRenderTargetDeviceId] couldn't allocate buffer for device ID."));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

/*****************************************************************************
 * PropertySetCaptureTargetDeviceId
 *****************************************************************************
 * Advises the GFX of the hardware PnP ID of the target capture device
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the set.
 *    property  - not used in this function.
 *    data      - Pointer to Unicode string containing the hardware PnP ID of
 *                 the target capture device
 */
NTSTATUS PropertySetCaptureTargetDeviceId
(
    IN PIRP        irp,
    IN PKSPROPERTY property,
    IN PVOID       data
)
{
    PAGED_CODE ();
    
    PWSTR    deviceId;
    NTSTATUS ntStatus;

    DOUT (DBG_PRINT, ("[PropertySetCaptureTargetDeviceId]"));
    
    //
    // Get the output buffer length.
    //
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
    ULONG              cbData = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    // check for reasonable values
    if (!cbData || cbData > 1024)
        return STATUS_UNSUCCESSFUL;

    //
    // Handle this property if you are interested in the PnP device ID
    // of the target capture device on which this GFX is applied
    //
    //
    // For now we just copy the PnP device ID and print it on the debugger,
    // then we discard it. You could for example compare the PnP ID string
    // with the ones in the INF file to make sure nobody altered the INF
    // file to apply your GFX to a different device.
    //
    deviceId = (PWSTR)ExAllocatePoolWithTag (PagedPool, cbData, GFXSWAP_POOL_TAG);
    if (deviceId)
    {
        //
        // Copy the PnP device ID.
        //
        RtlCopyMemory ((PVOID)deviceId, data, cbData);
        
        //
        // Ensure last character is NULL
        //
        deviceId[(cbData/sizeof(deviceId[0]))-1] = L'\0';
        
        //
        // Print out the string.
        //
        DOUT (DBG_PRINT, ("[PropertySetCaptureTargetDeviceId] ID is [%ls]", deviceId));

        //
        // If you are interested in the DeviceId and need to store it then
        // you probably wouldn't free the memory here.
        //
        ExFreePool (deviceId);
        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        DOUT (DBG_WARNING, ("[PropertySetCaptureTargetDeviceId] couldn't allocate buffer for device ID."));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

/*****************************************************************************
 * PropertySaveState
 *****************************************************************************
 * Saves or restores the filter state. The filter has only one "channel swap"
 * node, so this will be easy!
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the get/set.
 *    property  - not used in this function.
 *    data      - buffer to receive the filter state OR new filter state that
 *                 is to be used.
 */
NTSTATUS PropertySaveState
(
    IN     PIRP        irp,
    IN     PKSPROPERTY property,
    IN OUT PVOID       data
)
{
    PAGED_CODE ();
    
    PGFXFILTER  gfxFilter;
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    DOUT (DBG_PRINT, ("[PropertySaveState]"));
    
    //
    // This handler is a filter property handler, but is not different
    // from the PropertyChannelSwap node property handler.
    // This property handler therefore only shows that you can have a
    // different property for saving your filter state which is usefull
    // once you have a lot of things to save (and you want to do that
    // at once and not by calling several properties).
    //

    //
    // Get hold of our FilterContext via pIrp
    //
    gfxFilter = (PGFXFILTER)(KsGetFilterFromIrp(irp)->Context);

    //
    // Assert that we have a valid filter context
    //
    ASSERT (gfxFilter);

    if (property->Flags & KSPROPERTY_TYPE_GET)
    {
        //
        // Get channel swap state
        //
        *(PBOOL)data = gfxFilter->enableChannelSwap;
    }
    else if (property->Flags & KSPROPERTY_TYPE_SET)
        {
            //
            // Set Channel swap state
            //
            gfxFilter->enableChannelSwap = *(PBOOL)data;
        }
        else
        {
            //
            // We support only Get & Set
            //
            DOUT (DBG_ERROR, ("[PropertySaveState] invalid property type."));
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
    
    return ntStatus;
}


/*****************************************************************************
 * PropertyChannelSwap
 *****************************************************************************
 * This is our private property for our private node. The node just gets/sets
 * a flag to disable/enable the filter, that means, to disable/enable the
 * channel swapping.
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the get/set.
 *    property  - our private property.
 *    data      - buffer to receive the filter state.
 */
NTSTATUS PropertyChannelSwap
(
    IN     PIRP        irp,
    IN     PKSPROPERTY property,
    IN OUT PVOID       data
)
{
    PAGED_CODE ();
    
    PGFXFILTER  gfxFilter;
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    DOUT (DBG_PRINT, ("[PropertyChannelSwap]"));
    
    //
    // Get hold of our FilterContext via pIrp
    //
    gfxFilter = (PGFXFILTER)(KsGetFilterFromIrp(irp)->Context);

    //
    // Assert that we have a valid filter context
    //
    ASSERT (gfxFilter);

    if (property->Flags & KSPROPERTY_TYPE_GET)
    {
        //
        // Get channel swap state
        //
        *(PBOOL)data = gfxFilter->enableChannelSwap;
    }
    else if (property->Flags & KSPROPERTY_TYPE_SET)
        {
            //
            // Set Channel swap state
            //
            gfxFilter->enableChannelSwap = *(PBOOL)data;
        }
        else
        {
            //
            // We support only Get & Set
            //
            DOUT (DBG_ERROR, ("[PropertyChannelSwap] invalid property type."));
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        }
    
    return ntStatus;
}

/*****************************************************************************
 * PropertyDrmSetContentId
 *****************************************************************************
 * A KS audio filter handles this property request synchronously.
 * If the request returns STATUS_SUCCESS, all the downstream KS audio nodes
 * of the target KS audio pin were also successfully configured with the
 * specified DRM content ID and DRM content rights. 
 * (Note that a downstream node is a direct or indirect sink for the audio
 * content flowing through an audio pin.)
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the set.
 *    property  - not used in this function.
 *    drmData   - The content ID and the DRM rights.
 */
NTSTATUS PropertyDrmSetContentId
(
    IN PIRP         irp,
    IN PKSPROPERTY  property,
    IN PVOID        drmData
)
{
    PAGED_CODE ();

    NTSTATUS    ntStatus = STATUS_SUCCESS;
    ULONG       contentId = *(PULONG)drmData;
    DRMRIGHTS*  drmRights = (PDRMRIGHTS)(((PULONG)drmData) + 1);
    PKSPIN      pin, otherPin;
    PKSFILTER   filter;
     
    DOUT (DBG_PRINT, ("[PropertyDrmSetContentId]"));

    //
    // Get the pin from the IRP. If the pin is NULL, that means that
    // the IRP is for a filter node (not a filter pin).
    //
    pin = KsGetPinFromIrp (irp);
    if (!pin)
    {
        DOUT (DBG_ERROR, ("[PropertyDrmSetContentId] this property is for a filter node?"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // This property should only go to the sink pin. Check this out.
    //
    if (pin->Id != GFX_SINK_PIN)
    {
        DOUT (DBG_ERROR, ("[PropertyDrmSetContentId] this property was invoked on the source pin!"));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Now get the filter where the pin is implemented.
    //
    filter = KsPinGetParentFilter (pin);
    
    //
    // We need to go through the pin list to get the source pin.
    // For that we need the control mutex.
    //
    KsFilterAcquireControl (filter);

    //
    // Look now for the source pin.
    //
    otherPin = KsFilterGetFirstChildPin (filter, GFX_SOURCE_PIN);
    if (!otherPin)
    {
        // We couldn't find the source pin.
        KsFilterReleaseControl (filter);
        DOUT (DBG_ERROR, ("[PropertyDrmSetContentId] couldn't find source pin."));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // You need to honor the DRM rights bits.
    // The sample GFX just processes the buffers and sends it down the stack,
    // so all we do is let the system verify the filter below us. If this
    // filter (normally the usbaudio driver) is certified then we can
    // play DRM content.
    //

    //
    // Forward the Content ID to the lower device object.
    //
    PFILE_OBJECT   fileObject   = KsPinGetConnectedPinFileObject (otherPin);
    PDEVICE_OBJECT deviceObject = KsPinGetConnectedPinDeviceObject (otherPin);

    //
    // The above 2 functions would only fail if pOtherPin is not a source pin.
    //
    if (fileObject && deviceObject)
    {
        DRMFORWARD DrmForward;

        DrmForward.Flags        = 0;
        DrmForward.DeviceObject = deviceObject;
        DrmForward.FileObject   = fileObject;
        DrmForward.Context      = (PVOID)fileObject;

        ntStatus = DrmForwardContentToDeviceObject (contentId, NULL, &DrmForward);
    }
    else
    {
        ASSERT (!"[PropertyDrmSetContentId] otherPin not source pin?!?");
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }

    KsFilterReleaseControl (filter);

    return ntStatus;
}

/*****************************************************************************
 * PropertyAudioPosition
 *****************************************************************************
 * Gets/Sets the audio position of the audio stream (Relies on the next
 * filter's audio position)
 * 
 * Arguments:
 *    irp       - Irp which asked us to do the get/set.
 *    property  - Ks Property structure.
 *    data      - Pointer to buffer where position value needs to be filled OR
 *                 Pointer to buffer which has the new positions
 */
NTSTATUS PropertyAudioPosition
(
    IN     PIRP              irp,
    IN     PKSPROPERTY       property,
    IN OUT PKSAUDIO_POSITION position
)
{
    PAGED_CODE ();
    
    PKSFILTER       filter;
    PGFXFILTER      gfxFilter;
    PKSPIN          otherPin;
    PKSPIN          pin;
    ULONG           bytesReturned;
    PIKSCONTROL     pIKsControl;
    NTSTATUS        ntStatus;

    DOUT (DBG_PRINT, ("[PropertyAudioPosition]"));

    //
    // Get the pin from the IRP. If the pin is NULL, that means that
    // the IRP is for a filter node (not a filter pin).
    //
    pin = KsGetPinFromIrp (irp);
    if (!pin)
    {
        DOUT (DBG_ERROR, ("[PropertyAudioPosition] this property is for a filter node?"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // This property should only go to the sink pin. Check this out.
    //
    if (pin->Id != GFX_SINK_PIN)
    {
        DOUT (DBG_ERROR, ("[PropertyAudioPosition] this property was invoked on the source pin!"));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Now get the filter where the pin is implemented.
    //
    filter = KsPinGetParentFilter (pin);
    gfxFilter = (PGFXFILTER)filter->Context;
    
    //
    // We need to go through the pin list to get the source pin.
    // For that we need the control mutex.
    //
    KsFilterAcquireControl (filter);

    //
    // Look now for the source pin.
    //
    otherPin = KsFilterGetFirstChildPin (filter, GFX_SOURCE_PIN);
    if (!otherPin)
    {
        // We couldn't find the source pin.
        KsFilterReleaseControl (filter);
        DOUT (DBG_ERROR, ("[PropertyAudioPosition] couldn't find the source pin."));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // This gets the interface that is connected with our output pin.
    //
    ntStatus = KsPinGetConnectedPinInterface (otherPin, &IID_IKsControl, (PVOID*)&pIKsControl);
    if (!NT_SUCCESS (ntStatus))
    {
        // We couldn't get the interface.
        KsFilterReleaseControl (filter);
        DOUT (DBG_ERROR, ("[PropertyAudioPosition] couldn't get IID_IKsControl interface."));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Pass the property down through the interface.
    // Always release the mutex before calling down.
    //
    KsFilterReleaseControl (filter);
    ntStatus = pIKsControl->KsProperty (property, sizeof (KSPROPERTY),
                                        position, sizeof (KSAUDIO_POSITION),
                                        &bytesReturned);

    //
    // This GFX is always in the playback graph (it's never used for
    // capture). We need to modify therefore only the WritePosition of
    // the KSAUDIO_POSITION structure.
    // If you do a GFX that is in the capture graph, you need to check if
    // you are inplace. If true, you change the write position like we do
    // now, and if you are not inplace, then you need to set the write
    // position to the BytesProcessed and the play position you need to
    // clip to the number of bytes processed + bytes outstanding on the
    // sink pin.
    //
    if (property->Id & KSPROPERTY_TYPE_GET)
    {
        // ExInterlockedCompareExchange64 doesn't use the 4th parameter.
        position->WriteOffset = ExInterlockedCompareExchange64 ((LONGLONG *)&gfxFilter->bytesProcessed,
                    (LONGLONG *)&position->WriteOffset, (LONGLONG *)&position->WriteOffset, NULL);
        ASSERT (position->PlayOffset <= position->WriteOffset);
    }

    //
    // We don't need this interface anymore.
    //
    pIKsControl->Release();

    // Set the IRP information field.
    irp->IoStatus.Information = bytesReturned;

    return(ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\driver\debug.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

#ifndef _DEBUG_H_
#define _DEBUG_H_

//
// Modified version of ksdebug.h to support runtime debug level changes.
//
const int DBG_NONE     = 0x00000000;
const int DBG_PRINT    = 0x00000001; // Blabla. Function entries for example
const int DBG_WARNING  = 0x00000002; // warning level
const int DBG_ERROR    = 0x00000004; // this doesn't generate a breakpoint
const int DBG_STREAM   = 0x00000010; // For stream messages
const int DBG_SYSTEM   = 0x10000000; // For system information messages
const int DBG_ALL      = 0xFFFFFFFF;

//
// The default statements that will print are warnings (DBG_WARNING) and
// errors (DBG_ERROR).
//
const int DBG_DEFAULT = DBG_WARNING | DBG_ERROR;

//
// Define global debug variable.
//
#ifdef DEFINE_DEBUG_VARS
#if (DBG)
unsigned long ulDebugOut = DBG_DEFAULT;
#endif

#else // !DEFINED_DEBUG_VARS
#if (DBG)
extern unsigned long ulDebugOut;
#endif
#endif

//
// Define the print statement.
//
#if defined(__cplusplus)
extern "C" {
#endif // #if defined(__cplusplus)

//
// DBG is 1 in checked builds
//
#if (DBG)
#define DOUT(lvl, strings)          \
    if ((lvl) & ulDebugOut)         \
    {                               \
        DbgPrint(STR_MODULENAME);   \
        DbgPrint##strings;          \
        DbgPrint("\n");             \
    }

#define BREAK()                     \
    DbgBreakPoint()

#else // if (!DBG)
#define DOUT(lvl, strings)
#define BREAK()
#endif // !DBG    

#if defined(__cplusplus)
}
#endif // #if defined(__cplusplus)

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\driver\pin.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

//
// The pin descriptors (static structures) are in filter.cpp
//

//
// Every debug output has "Modulname text"
//
static char STR_MODULENAME[] = "GFX pin: ";

#include "common.h"
#include <msgfx.h>


/*****************************************************************************
 * CGFXPin::ValidateDataFormat
 *****************************************************************************
 * Checks if the passed data format is in the data range passed in. The data
 * range is one of our own data ranges that we defined for the pin and the
 * data format is the requested data format for creating a stream or changing
 * the data format (SetDataFormat).
 */
NTSTATUS CGFXPin::ValidateDataFormat
(
    IN PKSDATAFORMAT dataFormat,
    IN PKSDATARANGE  dataRange
)
{
    PAGED_CODE ();

    ASSERT (dataFormat);

    DOUT (DBG_PRINT, ("[ValidateDataFormat]"));

    //
    // KSDATAFORMAT contains three GUIDs to support extensible format.  The
    // first two GUIDs identify the type of data.  The third indicates the
    // type of specifier used to indicate format specifics.
    // KS makes sure that it doesn't call the driver with any data format
    // that doesn't match the GUIDs in the data range of the pin. That
    // means we don't have to check this here again.
    //

    PWAVEFORMATPCMEX    waveFormat = (PWAVEFORMATPCMEX)(dataFormat + 1);
    PKSDATARANGE_AUDIO  audioDataRange = (PKSDATARANGE_AUDIO)dataRange;

    //
    // We are only supporting PCM audio formats that use WAVEFORMATEX.
    //
    // If the size doesn't match, then something is messed up.
    //
    if (dataFormat->FormatSize < (sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATEX)))
    {
        DOUT (DBG_WARNING, ("[ValidateDataFormat] Invalid FormatSize!"));
        return STATUS_INVALID_PARAMETER;
    }
            
    //
    // Print the information.
    //
    if (waveFormat->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE)
    {
        DOUT (DBG_STREAM, ("[ValidateDataFormat] PCMEX - Frequency: %d, Channels: %d, bps: %d, ChannelMask: %X",
              waveFormat->Format.nSamplesPerSec, waveFormat->Format.nChannels,
              waveFormat->Format.wBitsPerSample, waveFormat->dwChannelMask));
    }
    else
    {
        DOUT (DBG_STREAM, ("[ValidateDataFormat] PCM - Frequency: %d, Channels: %d, bps: %d",
              waveFormat->Format.nSamplesPerSec, waveFormat->Format.nChannels,
              waveFormat->Format.wBitsPerSample));
    }
    
    //
    // Compare the data format with the data range.
    // Check the bits per sample.
    //
    if ((waveFormat->Format.wBitsPerSample < audioDataRange->MinimumBitsPerSample) ||
        (waveFormat->Format.wBitsPerSample > audioDataRange->MaximumBitsPerSample))
    {
        DOUT (DBG_PRINT, ("[ValidateDataFormat] No match for Bits Per Sample!"));
        return STATUS_NO_MATCH;
    }
    
    //
    // Check the number of channels.
    //
    if ((waveFormat->Format.nChannels < 1) ||
        (waveFormat->Format.nChannels > audioDataRange->MaximumChannels))
    {
        DOUT (DBG_PRINT, ("[ValidateDataFormat] No match for Number of Channels!"));
        return STATUS_NO_MATCH;
    }
    
    //
    // Check the sample frequency.
    //
    if ((waveFormat->Format.nSamplesPerSec < audioDataRange->MinimumSampleFrequency) ||
        (waveFormat->Format.nSamplesPerSec > audioDataRange->MaximumSampleFrequency))
    {
        DOUT (DBG_PRINT, ("[ValidateDataFormat] No match for Sample Frequency!"));
        return STATUS_NO_MATCH;
    }
    
    //
    // We support WaveFormatPCMEX (=WAVEFORMATEXTENSIBLE) or WaveFormatPCM.
    // In case of WaveFormatPCMEX we need to check the speaker config too.
    //
    if ((waveFormat->Format.wFormatTag != WAVE_FORMAT_EXTENSIBLE) &&
        (waveFormat->Format.wFormatTag != WAVE_FORMAT_PCM))
    {
        DOUT (DBG_WARNING, ("[ValidateDataFormat] Invalid Format Tag!"));
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make additional checks for the WAVEFORMATEXTENSIBLE
    //
    if (waveFormat->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE)
    {
        //
        // If the size doesn't match, then something is messed up.
        //
        if (dataFormat->FormatSize < (sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX)))
        {
            DOUT (DBG_WARNING, ("[ValidateDataFormat] Invalid FormatSize!"));
            return STATUS_INVALID_PARAMETER;
        }
        
        //
        // Check also the subtype (PCM) and the size of the extended data.
        //
        if (!IsEqualGUIDAligned (waveFormat->SubFormat, KSDATAFORMAT_SUBTYPE_PCM) ||
            (waveFormat->Format.cbSize < 22))
        {
            DOUT (DBG_WARNING, ("[ValidateDataFormat] Unsupported WAVEFORMATEXTENSIBLE!"));
            return STATUS_INVALID_PARAMETER;
        }

        //
        // Check the channel mask. We support 1 or 2 channels.
        //
        if (((waveFormat->Format.nChannels == 1) &&
             (waveFormat->dwChannelMask != KSAUDIO_SPEAKER_MONO)) ||
            ((waveFormat->Format.nChannels == 2) &&
             (waveFormat->dwChannelMask != KSAUDIO_SPEAKER_STEREO)))
        {
            DOUT (DBG_WARNING, ("[ValidateDataFormat] Unsupported Channel Mask!"));
            return STATUS_INVALID_PARAMETER;
        }
    }
        
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXPin::Create
 *****************************************************************************
 * This function is called once a pin gets opened.
 */
NTSTATUS CGFXPin::Create
(
    IN PKSPIN   pin,
    IN PIRP     irp
)
{
    PAGED_CODE ();
    
    PGFXPIN     gfxPin;

    DOUT (DBG_PRINT, ("[Create]"));
    
    //
    // The pin context is the filter's context. We overwrite it with
    // the pin object.
    //
    gfxPin = new (NonPagedPool, GFXSWAP_POOL_TAG) GFXPIN;
    if (gfxPin == NULL)
    {
        DOUT (DBG_ERROR, ("[Create] couldn't allocate gfx pin object."));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    //
    // Attach it to the pin structure.
    //
    pin->Context = (PVOID)gfxPin;
    DOUT (DBG_PRINT, ("[Create] gfxPin %08x", gfxPin));
    
    //
    // Initialize the CGFXPin object variables.
    //
    ExInitializeFastMutex (&gfxPin->pinQueueSync);

    //
    // Get the OS version info
    //
    RTL_OSVERSIONINFOEXW version;
    version.dwOSVersionInfoSize = sizeof (RTL_OSVERSIONINFOEXW);
    RtlGetVersion ((PRTL_OSVERSIONINFOW)&version);

    //
    // If we are running under the first release of Windows XP,
    // KsPinGetAvailableByteCount has a bug so that we can't use it.
    // We only use this function in SetDataFormat, so we just reject
    // all data format changes. Otherwise, if a service pack is installed
    // or Windows .NET or a later version of Windows XP we can use the
    // function.
    //
    if (version.dwBuildNumber > 2600)
        gfxPin->rejectDataFormatChange = FALSE;
    else
    {
        if (version.wServicePackMajor > 0)
            gfxPin->rejectDataFormatChange = FALSE;
        else
            gfxPin->rejectDataFormatChange = TRUE;
    }
    DOUT (DBG_SYSTEM,
        ("[Create] OS build number: %d, version: %d.%d, service pack: %d.%d",
        version.dwBuildNumber, version.dwMajorVersion, version.dwMinorVersion,
        version.wServicePackMajor, version.wServicePackMinor));

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXPin::Close
 *****************************************************************************
 * This routine is called when a pin is closed.  It deletes the
 * client pin object attached to the pin structure.
 * 
 * Arguments:
 *    pin     - Contains a pointer to the pin structure.
 *    pIrp    - Contains a pointer to the close request.
 *
 * Return Value:
 *    STATUS_SUCCESS.
 */
NTSTATUS CGFXPin::Close
(
    IN PKSPIN    pin,
    IN PIRP      irp
)
{
    PAGED_CODE ();
    
    DOUT (DBG_PRINT, ("[Close] gfxPin %08x", pin->Context));
    
    // delete is safe with NULL pointers.
    delete (PGFXPIN)pin->Context;
    
    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXPin::SetDataFormat
 *****************************************************************************
 * This function is called on the pin everytime the data format should change.
 * It is also called just before the pin gets created with the new data format.
 * Therefore, we don't need to have a pin Create dispatch function just to
 * check the data format.
 * Since we need to have both pins running at the same data format, we need
 * to pass down the request to change the pin's data format to the lower
 * driver, which would be the audio driver. If the audio driver fails to change
 * the data format, we will do so too.
 */
NTSTATUS CGFXPin::SetDataFormat
(
    IN PKSPIN                   pin,
    IN PKSDATAFORMAT            oldFormat,
    IN PKSMULTIPLE_ITEM         oldAttributeList,
    IN const KSDATARANGE        *dataRange,
    IN const KSATTRIBUTE_LIST   *attributeRange
)
{
    PAGED_CODE ();

    ASSERT (pin);
    
    NTSTATUS    ntStatus;
    PKSFILTER   filter;
    PKSPIN      otherPin;
    PGFXPIN     gfxPin = NULL;
    
    DOUT (DBG_PRINT, ("[GFXPinSetDataFormat]"));
    
    //
    // First validate if the requested data format is valid.
    //
    ntStatus = ValidateDataFormat (pin->ConnectionFormat, (PKSDATARANGE)dataRange);
    if (!NT_SUCCESS(ntStatus))
    {
        return ntStatus;
    }

    //
    // We need to have the same data format on both pins.
    // That means we need to get to the other pin and if this pin is created
    // make sure that the lower level driver (audio driver) gets a SetDataFormat
    // too.
    //

    //
    // We hold the filter control mutex already.
    //
    filter = KsPinGetParentFilter (pin);

    //
    // Now get to the other pin. If this property was called on the sink
    // pin, then we get the source pin and continue. If it was called on
    // the source pin we go to the sink pin and continue.
    // To check if the pin really exists you look at the OldFormat which
    // is passed in. If it's a creation of the pin the OldFormat will be
    // NULL.
    // If the other pin doesn't exist we accept the format since it passed
    // the format check.
    //
    if (pin->Id == GFX_SINK_PIN)
    {
        otherPin = KsFilterGetFirstChildPin (filter, GFX_SOURCE_PIN);
        if (oldFormat)
            gfxPin = (PGFXPIN)pin->Context;
    }
    else    // It's a source pin
    {
        otherPin = KsFilterGetFirstChildPin (filter, GFX_SINK_PIN);
        if (otherPin)
            gfxPin = (PGFXPIN)otherPin->Context;
    }
        
    //
    // If there is no other pin open, accept the data format.
    //
    if (!otherPin)
    {
        DOUT (DBG_PRINT, ("[GFXPinSetDataFormat] data format accepted."));
        return STATUS_SUCCESS;
    }

    //
    // Check if the data format if equal for both pins.
    // We cannot just compare the memory of the data format structure
    // since one could be WAVEFORMATEX and the other one WAVEFORMATPCMEX,
    // but we also know that these are the only formats that we accept,
    // so compare their values now.
    //
    PWAVEFORMATEX   thisWaveFmt = (PWAVEFORMATEX)(pin->ConnectionFormat + 1);
    PWAVEFORMATEX  otherWaveFmt = (PWAVEFORMATEX)(otherPin->ConnectionFormat + 1);

    if ((thisWaveFmt->nChannels == otherWaveFmt->nChannels) &&
        (thisWaveFmt->nSamplesPerSec == otherWaveFmt->nSamplesPerSec) &&
        (thisWaveFmt->wBitsPerSample == otherWaveFmt->wBitsPerSample))
    {
        //
        // We have a match right here.
        //
        DOUT (DBG_PRINT, ("[GFXPinSetDataFormat] data format accepted."));
        return STATUS_SUCCESS;
    }
     
    //
    // We don't have a match. We need to change the data format of the otherPin
    // now and if that succeeds we can continue, otherwise we need to fail.
    //
    // Before we pass down the property however, we need to make sure that all
    // buffers on the sink pin are processed (since they were sampled with
    // the old data format).
    //
    LONG  bytesQueuedUp = 0;
    do
    {
        //
        // We need to synchronize the call to KsPinGetAvailableByteCount
        // with changes in the pin state (using the fast mutex) only on
        // the sink pin.
        //
        if (gfxPin)
        {
            ExAcquireFastMutex (&gfxPin->pinQueueSync);
            //
            // In case we are not in STOP state, the pin queue should be there,
            // otherwise it is destroyed (or in the process of destroying) and
            // therefore we assume no buffers are waiting on the pin.
            //
            if (gfxPin->pinQueueValid)
            {
                //
                // If we are running on a system without the KS fix, we
                // need to reject the SetDataFormat because we want to
                // prevent an unprocessed buffer from playing at the
                // wrong sample frequency.
                //
                if (gfxPin->rejectDataFormatChange)
                {
                    ExReleaseFastMutex (&gfxPin->pinQueueSync);
                    return STATUS_UNSUCCESSFUL;
                }
                
                KsPinGetAvailableByteCount (pin, &bytesQueuedUp, NULL);
            }
            else
                bytesQueuedUp = 0;
            ExReleaseFastMutex (&gfxPin->pinQueueSync);
        }

        //
        // If we got some bytes queued on the sink pin yield for 1ms.
        //
        if (bytesQueuedUp)
        {
            LARGE_INTEGER   timeToWait;

            DOUT (DBG_STREAM, ("[GFXPinSetDataFormat] %d Bytes left to process.\n", bytesQueuedUp));
            timeToWait.QuadPart = -10000;   // one ms
            KeDelayExecutionThread (KernelMode, FALSE, &timeToWait);
        }
    } while (bytesQueuedUp);
    
    //
    // Now that every data frame on the sink pin is processed and passed
    // down the stack we can call down with the property too.
    //
    KSPROPERTY      property;
    PIKSCONTROL     pIKsControl;
    ULONG           cbReturned;

    property.Set = KSPROPSETID_Connection;
    property.Id = KSPROPERTY_CONNECTION_DATAFORMAT;
    property.Flags = KSPROPERTY_TYPE_SET;

    //
    // Get a control interface to the pin that is connected with otherPin.
    //
    ntStatus = KsPinGetConnectedPinInterface (otherPin, &IID_IKsControl, (PVOID*)&pIKsControl);
    if (!NT_SUCCESS(ntStatus))
    {
        DOUT (DBG_ERROR, ("[GFXPinSetDataFormat] Could not get pin interface."));
        return ntStatus;
    }

    // Always release the mutex before calling down.
    KsFilterReleaseControl (filter);

    //
    // Call the interface with KSPROPERTY_CONNECTION_DATAFORMAT.
    // Pass in our pin data format as the data format.
    //
    ntStatus = pIKsControl->KsProperty (&property, sizeof(property),
                                        pin->ConnectionFormat, pin->ConnectionFormat->FormatSize,
                                        &cbReturned);

    // Get the control of the filter back!
    KsFilterAcquireControl (filter);

    //
    // We don't need this interface anymore.
    //
    pIKsControl->Release();
    
    //
    // Return the error code from the KsProperty call. If the connected pin
    // changed seccessfully the data format then we can accept this data
    // format too.
    //
    return ntStatus;
}

/*****************************************************************************
 * CGFXPin::SetDeviceState
 *****************************************************************************
 * This function is called on the pin everytime the device state changes.
 */
NTSTATUS CGFXPin::SetDeviceState
(
    IN PKSPIN  pin,
    IN KSSTATE toState,
    IN KSSTATE fromState
)
{
    PAGED_CODE ();

    ASSERT (pin);
    ASSERT (pin->Context);
    
    PKSFILTER   filter;
    PGFXFILTER  gfxFilter;
    PGFXPIN     gfxPin = (PGFXPIN)pin->Context;
    
    DOUT (DBG_PRINT, ("[GFXPinSetDeviceState]"));
    
    //
    // We hold the filter control mutex already. Get the filter and that
    // way to the bytesProcessed variable.
    //
    filter = KsPinGetParentFilter (pin);
    gfxFilter = (PGFXFILTER)filter->Context;

    //
    // We only need to reset the byte counter on STOP.
    // In addition, for synchronization with the set data format handler,
    // we need to set pinQueueValid variable.
    //
    ExAcquireFastMutex (&gfxPin->pinQueueSync);
    if (toState == KSSTATE_STOP)
    {
        gfxFilter->bytesProcessed = 0;
        gfxPin->pinQueueValid = FALSE;
    }
    else
    {
        gfxPin->pinQueueValid = TRUE;
    }
    ExReleaseFastMutex (&gfxPin->pinQueueSync);

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXPin::IntersectDataRanges
 *****************************************************************************
 * This routine performs a data range intersection between 2 specific formats.
 * It assumes that it can always return a WAVEFORMATPCMEX structure, that
 * means that the data ranges of this filter cannot be anything else than
 * KSDATAFORMAT_SPECIFIER_WAVEFORMATEX.
 * This function will return STATUS_NO_MATCH if there is no intersection
 * between the 2 data ranges and it will return the "highest" data format if
 * the client's data range contains wildcards.
 * 
 * Arguments:
 *     clientDataRange - pointer to one of the data ranges supplied by the
 *                       client in the data intersection request. The format
 *                       type, subtype and specifier are compatible with the
 *                       DescriptorDataRange.
 *     myDataRange     - pointer to one of the data ranges from the pin
 *                       descriptor for the pin in question.  The format type,
 *                       subtype and specifier are compatible with the
 *                       clientDataRange.
 *     ResultantFormat - pointer to the buffer to contain the data format
 *                       structure representing the best format in the
 *                       intersection of the two data ranges. The buffer is
 *                       big enough to hold a WAVEFORMATPCMEX structure.
 *     ReturnedBytes   - pointer to ULONG containing the number of bytes
 *                       that this routine will write into ResultantFormat.
 *
 * Return Value:
 *    STATUS_SUCCESS if there is an intersection or STATUS_NO_MATCH.
 */
NTSTATUS CGFXPin::IntersectDataRanges
(
    IN PKSDATARANGE clientDataRange,
    IN PKSDATARANGE myDataRange,
    OUT PVOID       ResultantFormat,
    OUT PULONG      ReturnedBytes
)
{
    DOUT (DBG_PRINT, ("[GFXPinIntersectDataRanges]"));

    //
    // Handle the wildcards. KS checked that the GUIDS will match either with
    // a wildcard or exactly.
    //
    if (IsEqualGUIDAligned (clientDataRange->Specifier,  KSDATAFORMAT_SPECIFIER_WILDCARD))
    {
        //
        // If there is a wildcard passed in and all the other fields fit, then we can
        // return the best format in the current data range.
        //
        
        // First copy the GUIDs
        *(PKSDATAFORMAT)ResultantFormat = *myDataRange;
        
        //
        // Append the WAVEFORMATPCMEX structure.
        //
        PWAVEFORMATPCMEX WaveFormat = (PWAVEFORMATPCMEX)((PKSDATAFORMAT)ResultantFormat + 1);

        // We want a WAFEFORMATEXTENSIBLE which is equal to WAVEFORMATPCMEX.
        WaveFormat->Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
        // Set the number of channels
        WaveFormat->Format.nChannels = (WORD)((PKSDATARANGE_AUDIO)myDataRange)->MaximumChannels;
        // Set the sample frequency
        WaveFormat->Format.nSamplesPerSec = ((PKSDATARANGE_AUDIO)myDataRange)->MaximumSampleFrequency;
        // Set the bits per sample
        WaveFormat->Format.wBitsPerSample = (WORD)((PKSDATARANGE_AUDIO)myDataRange)->MaximumBitsPerSample;
        // Calculate one sample block (a frame).
        WaveFormat->Format.nBlockAlign = (WaveFormat->Format.wBitsPerSample * WaveFormat->Format.nChannels) / 8;
        // That is played in a sec.
        WaveFormat->Format.nAvgBytesPerSec = WaveFormat->Format.nSamplesPerSec * WaveFormat->Format.nBlockAlign;
        // WAVEFORMATPCMEX
        WaveFormat->Format.cbSize = 22;
        // We have as many valid bits as the bit depth is.
        WaveFormat->Samples.wValidBitsPerSample = WaveFormat->Format.wBitsPerSample;
        // Set the channel mask
        ASSERT (WaveFormat->dwChannelMask == 2);
        WaveFormat->dwChannelMask = KSAUDIO_SPEAKER_STEREO;
        // Here we specify the subtype of the WAVEFORMATEXTENSIBLE.
        WaveFormat->SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
        
        //
        // Modify the size of the data format structure to fit the WAVEFORMATPCMEX
        // structure.
        //
        ((PKSDATAFORMAT)ResultantFormat)->FormatSize =
            sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
        
        //
        // Now overwrite also the sample size in the KSDATAFORMAT structure.
        //
        ((PKSDATAFORMAT)ResultantFormat)->SampleSize = WaveFormat->Format.nBlockAlign;

        //
        // That we will return.
        //
        *ReturnedBytes = sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
    }
    else
    {
        //
        // Check the passed data range format.
        //
        if (clientDataRange->FormatSize < sizeof(KSDATARANGE_AUDIO))
            return STATUS_INVALID_PARAMETER;
        
        //
        // Verify that we have an intersection with the specified data range and
        // our audio data range.
        //
        if ((((PKSDATARANGE_AUDIO)clientDataRange)->MinimumSampleFrequency >
             ((PKSDATARANGE_AUDIO)myDataRange)->MaximumSampleFrequency) ||
            (((PKSDATARANGE_AUDIO)clientDataRange)->MaximumSampleFrequency <
             ((PKSDATARANGE_AUDIO)myDataRange)->MinimumSampleFrequency) ||
            (((PKSDATARANGE_AUDIO)clientDataRange)->MinimumBitsPerSample >
             ((PKSDATARANGE_AUDIO)myDataRange)->MaximumBitsPerSample) ||
            (((PKSDATARANGE_AUDIO)clientDataRange)->MaximumBitsPerSample <
             ((PKSDATARANGE_AUDIO)myDataRange)->MinimumBitsPerSample))
        {
            return STATUS_NO_MATCH;
        }

        //
        // Since we have a match now, build the data format for our buddy.
        //

        // First copy the GUIDs
        *(PKSDATAFORMAT)ResultantFormat = *myDataRange;
        
        //
        // Append the WAVEFORMATPCMEX structure.
        //
        PWAVEFORMATPCMEX WaveFormat = (PWAVEFORMATPCMEX)((PKSDATAFORMAT)ResultantFormat + 1);

        // We want a WAFEFORMATEXTENSIBLE which is equal to WAVEFORMATPCMEX.
        WaveFormat->Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
        // Set the number of channels
        WaveFormat->Format.nChannels = (WORD)
            min (((PKSDATARANGE_AUDIO)clientDataRange)->MaximumChannels,
                 ((PKSDATARANGE_AUDIO)myDataRange)->MaximumChannels);
        // Set the sample frequency
        WaveFormat->Format.nSamplesPerSec =
            min (((PKSDATARANGE_AUDIO)clientDataRange)->MaximumSampleFrequency,
                 ((PKSDATARANGE_AUDIO)myDataRange)->MaximumSampleFrequency);
        // Set the bits per sample
        WaveFormat->Format.wBitsPerSample = (WORD)
            min (((PKSDATARANGE_AUDIO)clientDataRange)->MaximumBitsPerSample,
                 ((PKSDATARANGE_AUDIO)myDataRange)->MaximumBitsPerSample);
        // Calculate one sample block (a frame).
        WaveFormat->Format.nBlockAlign = (WaveFormat->Format.wBitsPerSample * WaveFormat->Format.nChannels) / 8;
        // That is played in a sec.
        WaveFormat->Format.nAvgBytesPerSec = WaveFormat->Format.nSamplesPerSec * WaveFormat->Format.nBlockAlign;
        // WAVEFORMATPCMEX
        WaveFormat->Format.cbSize = 22;
        // We have as many valid bits as the bit depth is.
        WaveFormat->Samples.wValidBitsPerSample = WaveFormat->Format.wBitsPerSample;
        // Set the channel mask
        if (WaveFormat->Format.nChannels == 1)
        {
            WaveFormat->dwChannelMask = KSAUDIO_SPEAKER_MONO;
        }
        else
        {
            // We can have only 1 or 2 channels in this sample.
            ASSERT (WaveFormat->Format.nChannels == 2);
            WaveFormat->dwChannelMask = KSAUDIO_SPEAKER_STEREO;
        }
        // Here we specify the subtype of the WAVEFORMATEXTENSIBLE.
        WaveFormat->SubFormat = KSDATAFORMAT_SUBTYPE_PCM;

        //
        // Modify the size of the data format structure to fit the WAVEFORMATPCMEX
        // structure.
        //
        ((PKSDATAFORMAT)ResultantFormat)->FormatSize =
            sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
    
        //
        // Now overwrite also the sample size in the KSDATAFORMAT structure.
        //
        ((PKSDATAFORMAT)ResultantFormat)->SampleSize = WaveFormat->Format.nBlockAlign;
    
        //
        // That we will return.
        //
        *ReturnedBytes = sizeof(KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
    }

    return STATUS_SUCCESS;
}

/*****************************************************************************
 * CGFXPin::DataRangeIntersection
 *****************************************************************************
 * This routine handles pin data intersection queries by determining the
 * intersection between two data ranges.
 * 
 * Arguments:
 *    Filter          - void pointer to the filter structure.
 *    Irp             - pointer to the data intersection property request.
 *    PinInstance     - pointer to a structure indicating the pin in question.
 *    CallerDataRange - pointer to one of the data ranges supplied by the client
 *                      in the data intersection request.  The format type, subtype
 *                      and specifier are compatible with the DescriptorDataRange.
 *    OurDataRange    - pointer to one of the data ranges from the pin descriptor
 *                      for the pin in question.  The format type, subtype and
 *                      specifier are compatible with the CallerDataRange.
 *    BufferSize      - size in bytes of the buffer pointed to by the Data
 *                      argument.  For size queries, this value will be zero.
 *    Data            - optionall. Pointer to the buffer to contain the data format
 *                      structure representing the best format in the intersection
 *                      of the two data ranges.  For size queries, this pointer will
 *                      be NULL.
 *    DataSize        - pointer to the location at which to deposit the size of the
 *                      data format.  This information is supplied by the function
 *                      when the format is actually delivered and in response to size
 *                      queries.
 *
 * Return Value:
 *    STATUS_SUCCESS if there is an intersection and it fits in the supplied
 *    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, STATUS_NO_MATCH
 *    if the intersection is empty, or STATUS_BUFFER_TOO_SMALL if the supplied
 *    buffer is too small.
 */
NTSTATUS CGFXPin::DataRangeIntersection
(
    IN PVOID        Filter,
    IN PIRP         Irp,
    IN PKSP_PIN     PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE OurDataRange,
    IN ULONG        BufferSize,
    OUT PVOID       Data OPTIONAL,
    OUT PULONG      DataSize
)
{
    PAGED_CODE();

    PKSFILTER filter = (PKSFILTER) Filter;
    PKSPIN    pin;
    NTSTATUS  ntStatus;

    DOUT (DBG_PRINT, ("[DataRangeIntersection]"));

    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(OurDataRange);
    ASSERT(DataSize);

    //
    // We need to have the same data format on both pins. So, first look if
    // the other pin is already open, then return the data format of that
    // pin instance.
    // If the other pin is not open, do a real data range intersection.
    //
    if (PinInstance->PinId == GFX_SINK_PIN)
    {
        pin = KsFilterGetFirstChildPin (filter, GFX_SOURCE_PIN);
    }
    else
    {
        pin = KsFilterGetFirstChildPin (filter, GFX_SINK_PIN);
    }

    if (!pin)
    {
        //
        // Do the data range instersection here. The returned data format
        // will always be a KSDATAFORMAT_WAVEFORMATPCMEX for now.
        //

        //
        // Validate return buffer size, if the request is only for the
        // size of the resultant structure, return it now.
        //
        if (!BufferSize)
        {
            *DataSize = sizeof (KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX);
            ntStatus = STATUS_BUFFER_OVERFLOW;
        }
        else
        {
            if (BufferSize < (sizeof (KSDATAFORMAT) + sizeof(WAVEFORMATPCMEX)))
            {
                ntStatus =  STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                //
                // Check if there is a match.
                //
                ntStatus = IntersectDataRanges (CallerDataRange, OurDataRange, Data, DataSize);

                if (NT_SUCCESS (ntStatus))
                {
                    PWAVEFORMATEX   pWvFmt = (PWAVEFORMATEX)((PKSDATAFORMAT)Data + 1);
                    DOUT (DBG_PRINT, ("[DataRangeIntersection] Intersection returns %d Hz, %d ch, %d bits.",
                                      pWvFmt->nSamplesPerSec, (DWORD)pWvFmt->nChannels, (DWORD)pWvFmt->wBitsPerSample));
                }
            }
        }
    }
    else
    {
        //
        // Validate that the current wave format is part of the data range.
        //
        PWAVEFORMATEX pWvFmt = (PWAVEFORMATEX)(pin->ConnectionFormat + 1);
        if (IsEqualGUIDAligned (CallerDataRange->Specifier, KSDATAFORMAT_SPECIFIER_WAVEFORMATEX))
        {
            //
            // Check the passed data range format.
            //
            if (CallerDataRange->FormatSize < sizeof(KSDATARANGE_AUDIO))
                return STATUS_INVALID_PARAMETER;

            //
            // Check the range of channels, frequency & bit depth.
            //
            if ((((PKSDATARANGE_AUDIO)CallerDataRange)->MinimumSampleFrequency >
                 pWvFmt->nSamplesPerSec) ||
                (((PKSDATARANGE_AUDIO)CallerDataRange)->MaximumSampleFrequency <
                 pWvFmt->nSamplesPerSec) ||
                (((PKSDATARANGE_AUDIO)CallerDataRange)->MinimumBitsPerSample >
                 pWvFmt->wBitsPerSample) ||
                (((PKSDATARANGE_AUDIO)CallerDataRange)->MaximumBitsPerSample <
                 pWvFmt->wBitsPerSample) ||
                (((PKSDATARANGE_AUDIO)CallerDataRange)->MaximumChannels <
                 pWvFmt->nChannels))
            {
                 return STATUS_NO_MATCH;
            }
        }
        else
        {
            if (!IsEqualGUIDAligned (CallerDataRange->Specifier, KSDATAFORMAT_SPECIFIER_WILDCARD))
                return STATUS_NO_MATCH;
        }
            
            
        //
        // Validate return buffer size, if the request is only for the
        // size of the resultant structure, return it now.
        //    
        if (!BufferSize)
        {
            *DataSize = pin->ConnectionFormat->FormatSize;
            ntStatus = STATUS_BUFFER_OVERFLOW;
        }
        else
        {
            if (BufferSize < pin->ConnectionFormat->FormatSize)
            {
                ntStatus =  STATUS_BUFFER_TOO_SMALL;
            }
            else
            {
                DOUT (DBG_PRINT, ("[DataRangeIntersection] Returning pin's data format."));
                DOUT (DBG_PRINT, ("[DataRangeIntersection] pin->ConnectionFormat: %P.",
                                  pin->ConnectionFormat));
                
                if (pin->ConnectionFormat->FormatSize >= sizeof (KSDATAFORMAT_WAVEFORMATEX))
                {
                    DOUT (DBG_PRINT, ("[DataRangeIntersection] Which is %d Hz, %d ch, %d bits.",
                                      pWvFmt->nSamplesPerSec, (DWORD)pWvFmt->nChannels, (DWORD)pWvFmt->wBitsPerSample));
                }
                
                *DataSize = pin->ConnectionFormat->FormatSize;
                RtlCopyMemory (Data, pin->ConnectionFormat, *DataSize);
                ntStatus = STATUS_SUCCESS;
            }
        }
    } 

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\gfxprop\gfxproperty.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// GFXProperty.cpp : Implementation of CGFXProperty
#include "stdafx.h"
#include <devioctl.h>
#include <ks.h>
#include "GFXProp.h"
#include "GFXProperty.h"
#include "..\inc\msgfx.h"

/////////////////////////////////////////////////////////////////////////////
// CGFXProperty

/////////////////////////////////////////////////////////////////////////////
// SetObjects
//
// This function gets passed in a IUnknown interface pointer from mmsys.cpl
// through OleCreatePropertyFrame. This IUnknown interface belongs to a
// IDataObject that stores the handle of the GFX. We need this handle in order
// to "talk" with the GFX.
// The implied action is that we close this handle when the dialog closes.

STDMETHODIMP CGFXProperty::SetObjects (ULONG nObjects, IUnknown **ppUnk)
{
    IDataObject *pDataObject;
    FORMATETC   DataFormat;
    STGMEDIUM   GFXObject;

    // Check paramters. We expect one IUnknown.
    if (ppUnk == NULL)
    {
        ATLTRACE(_T("[CGFXProperty::SetObjects] IUnknown is NULL\n"));
        return E_POINTER;
    }

    if (nObjects != 1)
    {
        ATLTRACE(_T("[CGFXProperty::SetObjects] Not one object passed but %d\n"), nObjects);
        return E_INVALIDARG;
    }

    // Query for IDataObject interface.
    if (ppUnk[0]->QueryInterface (IID_IDataObject, (PVOID *)&pDataObject) != S_OK)
    {
        ATLTRACE(_T("[CGFXProperty::SetObjects] QueryInterface failed!\n"));
        return E_FAIL;
    }

    // Get the handle
    memset ((PVOID)&DataFormat, 0, sizeof (DataFormat));
    DataFormat.tymed = TYMED_HGLOBAL;
    if (pDataObject->GetData (&DataFormat, &GFXObject) != S_OK)
    {
        ATLTRACE(_T("[CGFXProperty::SetObjects] GetData failed!\n"));
        return E_FAIL;
    }

    // Store the handle of the GFX filter.
    m_hGFXFilter = GFXObject.hGlobal;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// SetChannelSwap
//
// This function send down a property to the sample GFX to change the GFX
// functionality, that is the channel swap variable.
// Setting it (pass TRUE to this function) means that the left and right
// channel are swapped.

void CGFXProperty::SetChannelSwap (BOOL bSwap)
{
    KSP_NODE        GFXSampleProperty;
    ULONG           ulBytesReturned;
    BOOL            fSuccess;

    // Prepare the property structure sent down.
    GFXSampleProperty.Property.Set = KSPROPSETID_MsGfxSample;
    GFXSampleProperty.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;
    GFXSampleProperty.Property.Id = KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP;
    // The first node in the filter is the GFX node. If you have
    // a more complicated filter, you could search for the node by
    // optaining the filter node list first with KSPROPERTY_TOPOLOGY_NODES.
    GFXSampleProperty.NodeId = 0;

    // Make the final call.
    fSuccess = DeviceIoControl (m_hGFXFilter, IOCTL_KS_PROPERTY,
                                &GFXSampleProperty, sizeof (GFXSampleProperty),
                                &bSwap, sizeof (bSwap),
                                &ulBytesReturned, NULL);
    
    // Check for error.
    if (!fSuccess)
    {
        ATLTRACE (_T("[CGFXProperty::SetChannelSwap] DeviceIoControl failed!\n"));
    }

    return;     // We don't care about the return value.
}

/////////////////////////////////////////////////////////////////////////////
// GetChannelSwap
//
// This function sends down the property to the sample GFX to get the current GFX
// channel swap variable. We need this information to set the dialog controls
// before they get displayed.

void CGFXProperty::GetChannelSwap (BOOL *pbSwap)
{
    KSP_NODE        GFXSampleProperty;
    ULONG           ulBytesReturned;
    BOOL            fSuccess;

    // Initialize
    *pbSwap = TRUE;
    
    // Prepare the property structure sent down.
    GFXSampleProperty.Property.Set = KSPROPSETID_MsGfxSample;
    GFXSampleProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;
    GFXSampleProperty.Property.Id = KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP;
    // The first node in the filter is the GFX node. If you have
    // a more complicated filter, you could search for the node by
    // optaining the filter node list first with KSPROPERTY_TOPOLOGY_NODES.
    GFXSampleProperty.NodeId = 0;

    // Make the final call.
    fSuccess = DeviceIoControl (m_hGFXFilter, IOCTL_KS_PROPERTY,
                                &GFXSampleProperty, sizeof (GFXSampleProperty),
                                pbSwap, sizeof (BOOL),
                                &ulBytesReturned, NULL);
    
    // Check for error.
    if (!fSuccess)
    {
        ATLTRACE (_T("[CGFXProperty::GetChannelSwap] DeviceIoControl failed!\n"));
    }

    return;     // We don't care about the return value.
}

/////////////////////////////////////////////////////////////////////////////
// OnInitDialog
//
// This function is called when the dialog gets initialized.
// We read the KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP property and set the checkbox
// appropriately.

LRESULT CGFXProperty::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Get the current KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP property value.
    GetChannelSwap (&m_bChannelSwap);
    // Set the checkbox to reflect the current state.
    SendMessage (GetDlgItem (IDC_CHANNEL_SWAP), BM_SETCHECK,
        (m_bChannelSwap) ? BST_CHECKED : BST_UNCHECKED, 0);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\gfxprop\gfxproppages.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// GFXPropPages.cpp : Implementation of CGFXPropPages
#include "stdafx.h"
#include "GFXProp.h"
#include "GFXPropPages.h"

/////////////////////////////////////////////////////////////////////////////
// CGFXPropPages
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\gfxprop\gfxprop.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// GFXProp.cpp : Implementation of DLL Exports.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f GFXPropps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "GFXProp.h"

#include "GFXProp_i.c"
#include "GFXPropPages.h"
#include "GFXProperty.h"


// We need this for ATL to work.
CComModule _Module;

// This specifies the different CLSIDs that can be created with the IClassFactory
// interface that ATL implements for us. The second parameter specifies the class
// that would be created with that CLSID.
BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_GFXPropPages, CGFXPropPages)
    OBJECT_ENTRY(CLSID_GFXProperty, CGFXProperty)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_GFXPROPLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object but not the typelib.
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\gfxprop\gfxproppages.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// GFXPropPages.h : Declaration of the CGFXPropPages

#ifndef __GFXPROPPAGES_H_
#define __GFXPROPPAGES_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CGFXPropPages
//
// This class only provides the ISpecifyPropertyPages interface that is used
// by mmsys.cpl to query for the GUIDs which represent property pages.
// mmsys.cpl uses these GUIDs to create the property page with
// OleCreatePropertyFrame. OleCreatePropertyFrame will then instanciate these
// objects and attach them to the dialog (means calls them for dialog messages).
//
// NOTE: The CLSID of this object is registered by the INF file to make the
//       Connection between the GFX and the property page.
class ATL_NO_VTABLE CGFXPropPages : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CGFXPropPages, &CLSID_GFXPropPages>,
    public ISpecifyPropertyPagesImpl<CGFXPropPages>
{
public:
    // ATL "secrets"
    DECLARE_REGISTRY_RESOURCEID(IDR_GFXPROPPAGES)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    // This is the only interface we have.
    BEGIN_COM_MAP(CGFXPropPages)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    END_COM_MAP()

    // These are the GUIDs that are returned on a GetPages call.
    BEGIN_PROP_MAP(CGFXPropPages)
        PROP_PAGE(CLSID_GFXProperty)
    END_PROP_MAP()
};

#endif //__GFXPROPPAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\gfxprop\stdafx.cpp ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\gfxprop\resource.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GFXProp.rc
//
#define IDS_PROJNAME                    100
#define IDR_GFXPROPPAGES                101
#define IDS_TITLEGFXProperty            102
#define IDS_HELPFILEGFXProperty         103
#define IDS_DOCSTRINGGFXProperty        104
#define IDR_GFXPROPERTY                 105
#define IDD_GFXPROPERTY                 106
#define IDC_CHANNEL_SWAP                201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         202
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\gfxprop\gfxproperty.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// GFXProperty.h : Declaration of the CGFXProperty

#ifndef __GFXPROPERTY_H_
#define __GFXPROPERTY_H_

#include "resource.h"       // main symbols

EXTERN_C const CLSID CLSID_GFXProperty;

/////////////////////////////////////////////////////////////////////////////
// CGFXProperty
//
// This class implements the functionality we need to control the GFX property
// page. It also has the necessary functions to "talk" with the GFX.
// The IUnknown that we get passed in with "SetObjects" is the IUnknown
// interface of a IDataObject that stores the GFX handle. We will ask this
// object for the handle and when the dialog gets destroyed, we will close
// the handle.
class ATL_NO_VTABLE CGFXProperty :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CGFXProperty, &CLSID_GFXProperty>,
    public IPropertyPageImpl<CGFXProperty>,
    public CDialogImpl<CGFXProperty>
{
public:
    // Stores string resources for the dialog and initializes private member
    // variables.
    CGFXProperty() 
    {
        m_dwTitleID = IDS_TITLEGFXProperty;
        // To enable help in the dialog box uncomment this line and change the
        // string resource
        //m_dwHelpFileID = IDS_HELPFILEGFXProperty;
        m_dwDocStringID = IDS_DOCSTRINGGFXProperty;
        m_hGFXFilter = NULL;
    }

    // Closes the handle got from the IID_IDataObject.
    ~CGFXProperty()
    {
        if (m_hGFXFilter)
            CloseHandle (m_hGFXFilter);
    }

    enum {IDD = IDD_GFXPROPERTY};

    // ATL "secrets"
    DECLARE_REGISTRY_RESOURCEID(IDR_GFXPROPERTY)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    // This is the only interface we have (or want to expose).
    BEGIN_COM_MAP(CGFXProperty) 
        COM_INTERFACE_ENTRY(IPropertyPage)
    END_COM_MAP()

    // This is the message map that redirects messages to our message handlers.
    BEGIN_MSG_MAP(CGFXProperty)
        CHAIN_MSG_MAP(IPropertyPageImpl<CGFXProperty>)
        COMMAND_HANDLER(IDC_CHANNEL_SWAP, BN_CLICKED, OnClickedChannelSwap)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    END_MSG_MAP()

    // Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // "Apply" button pressed on the dialog.
    STDMETHOD(Apply)(void)
    {
        // Set the property on the GFX to the desired value.
        SetChannelSwap (m_bChannelSwap);
        // Mark the "Apply" button to be grayed out.
        m_bDirty = FALSE;
        return S_OK;
    }

    // The checkbox changed it's value.
    LRESULT OnClickedChannelSwap (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        // Get the state of the checkbox and safe if in out variable.
        if (SendMessage (hWndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED)
            m_bChannelSwap = TRUE;
        else
            m_bChannelSwap = FALSE;
        
        // Mark the "Apply" button as valid.
        SetDirty (TRUE);
        return 0;
    }
    
    // This function is called indirect by mmsys.cpl to pass in the IUnknown
    // of the IDataObject which has the handle of our GFX.
    STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);

private:
    // This is the value of the KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP property
    BOOL   m_bChannelSwap;
    // The handle to our GFX.
    HANDLE m_hGFXFilter;

    // Set the KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP property on the GFX.
    void GetChannelSwap (BOOL *);
    // Get the KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP property on the GFX.
    void SetChannelSwap (BOOL);
    // Gets called when the dialog gets initialized.
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};

#endif //__GFXPROPERTY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\driver\pin.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

enum GFXPinIds
{
    GFX_SINK_PIN = 0,
    GFX_SOURCE_PIN
};

typedef class CGFXPin
{
public:
    BOOL        rejectDataFormatChange;
    BOOL        pinQueueValid;
    FAST_MUTEX  pinQueueSync;

public:
    CGFXPin() {pinQueueValid = FALSE;};
    ~CGFXPin() {};

    //
    // The functions here are static so that we can add them to the
    // dispatch function table. Some also might be called when the
    // object itself is not yet created.
    //
    static NTSTATUS Create
    (
        IN PKSPIN   pin,
        IN PIRP     Irp
    );

    static NTSTATUS Close
    (
        IN PKSPIN   pin,
        IN PIRP     Irp
    );

    static NTSTATUS SetDataFormat
    (
        IN PKSPIN                   pin,
        IN PKSDATAFORMAT            oldFormat,
        IN PKSMULTIPLE_ITEM         oldAttributeList,
        IN const KSDATARANGE        *DataRange,
        IN const KSATTRIBUTE_LIST   *AttributeRange
    );

    static NTSTATUS SetDeviceState
    (
        IN PKSPIN  pin,
        IN KSSTATE ToState,
        IN KSSTATE FromState
    );
    
    static NTSTATUS DataRangeIntersection
    (
        IN PVOID        Filter,
        IN PIRP         Irp,
        IN PKSP_PIN     PinInstance,
        IN PKSDATARANGE CallerDataRange,
        IN PKSDATARANGE OurDataRange,
        IN ULONG        BufferSize,
        OUT PVOID       Data OPTIONAL,
        OUT PULONG      DataSize
    );

private:
    //
    // These functions are static because they need to be called
    // even if the object doesn't exist.
    //
    static NTSTATUS ValidateDataFormat
    (
        IN PKSDATAFORMAT DataFormat,
        IN PKSDATARANGE  DataRange
    );

    static NTSTATUS IntersectDataRanges
    (
        IN PKSDATARANGE clientDataRange,
        IN PKSDATARANGE myDataRange,
        OUT PVOID       ResultantFormat,
        OUT PULONG      ReturnedBytes
    );
} GFXPIN, *PGFXPIN;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\inc\msgfx.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

//
// This is the sample GFX property set ID.
// Please use your own GUIDs in your GFX.
//
#define STATIC_KSPROPSETID_MsGfxSample \
    0xec1699d5, 0x2845, 0x4ca2, 0xbe, 0x7d, 0x8c, 0xe4, 0x62, 0xfd, 0xac, 0x2b
DEFINE_GUIDSTRUCT("EC1699D5-2845-4ca2-BE7D-8CE462FDAC2B", KSPROPSETID_MsGfxSample);
#define KSPROPSETID_MsGfxSample DEFINE_GUIDNAMED(KSPROPSETID_MsGfxSample)

//
// These are the defined methods that the property supports.
// KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP will be used to set/get the "channel swap"
// flag.
//
typedef enum {
    KSPROPERTY_MSGFXSAMPLE_CHANNELSWAP = 1
} KSPROPERTY_MSGFXSAMPLE_NODE;


//
// This property set is used to save the state of the GFX.
// Please use your own GUIDs in your GFX.
//
#define STATIC_KSPROPSETID_SaveState \
    0xe04db855, 0x1846, 0x4c9d, 0xb5, 0x57, 0x8a, 0xf7, 0x55, 0x5a, 0xbe, 0x57
DEFINE_GUIDSTRUCT("E04DB855-1846-4c9d-B557-8AF7555ABE57", KSPROPSETID_SaveState);
#define KSPROPSETID_SaveState DEFINE_GUIDNAMED(KSPROPSETID_SaveState)

//
// These are the defined methods that the property supports.
// KSPROPERTY_MSGFXSAMPLE_SAVESTATE will be used to save the "channel swap"
// flag.
//
typedef enum {
    KSPROPERTY_MSGFXSAMPLE_SAVESTATE = 1
} KSPROPERTY_MSGFXSAMPLE_FILTER;


//
// This GUID defines the type for the "channel swap" node.
// Please use your own GUIDs in your GFX.
//
#define STATIC_GFXSAMPLE_NODETYPE_CHANNEL_SWAP \
    0x4398814d, 0xeb1c, 0x4b99, 0x97, 0x61, 0x3c, 0x24, 0xc9, 0x2e, 0xb7, 0xcb
DEFINE_GUIDSTRUCT("4398814D-EB1C-4b99-9761-3C24C92EB7CB", GFXSAMPLE_NODETYPE_CHANNEL_SWAP);
#define GFXSAMPLE_NODETYPE_CHANNEL_SWAP DEFINE_GUIDNAMED(GFXSAMPLE_NODETYPE_CHANNEL_SWAP)

//
// This GUID defines the name for the "channel swap" node.
// Note that the name & GUID are linked together in the INF file.
// Please use your own GUIDs in your GFX.
//
#define STATIC_GFXSAMPLE_NODENAME_CHANNEL_SWAP \
    0x2b143fe6, 0x4f67, 0x4b12, 0x80, 0x39, 0xce, 0x03, 0xeb, 0xef, 0x12, 0x90
DEFINE_GUIDSTRUCT("2B143FE6-4F67-4b12-8039-CE03EBEF1290", GFXSAMPLE_NODENAME_CHANNEL_SWAP);
#define GFXSAMPLE_NODENAME_CHANNEL_SWAP DEFINE_GUIDNAMED(GFXSAMPLE_NODENAME_CHANNEL_SWAP)

//
// This GUID defines the name for the GFXSwap filter.
// Note that the name & GUID are linked together in the INF file.
// Please use your own GUIDs in your GFX.
//
#define STATIC_KSNAME_MsGfxSample \
    0x9b365890, 0x165f, 0x11d0, 0xa1, 0x9f, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("9b365890-165f-11d0-a195-0020afd156e4", KSNAME_MsGfxSample);
#define KSNAME_MsGfxSample DEFINE_GUIDNAMED(KSNAME_MsGfxSample)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\gfx\gfxswap\gfxprop\stdafx.h ===
/**************************************************************************
**
**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
**  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
**  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
**  PURPOSE.
**
**  Copyright (c) 2000-2001 Microsoft Corporation. All Rights Reserved.
**
**************************************************************************/

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__722DC775_FE6F_42FB_BED5_E1E299976D17__INCLUDED_)
#define AFX_STDAFX_H__722DC775_FE6F_42FB_BED5_E1E299976D17__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__722DC775_FE6F_42FB_BED5_E1E299976D17__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\basetopo.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    basetopo.h

Abstract:

    Declaration of topology miniport.

--*/

#ifndef _MSVAD_BASETOPO_H_
#define _MSVAD_BASETOPO_H_

//=============================================================================
// Classes
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// CMiniportTopologyMSVAD
//

class CMiniportTopologyMSVAD
{
  protected:
    PADAPTERCOMMON              m_AdapterCommon;    // Adapter common object.
    PPCFILTER_DESCRIPTOR        m_FilterDescriptor; // Filter descriptor.

  public:
    CMiniportTopologyMSVAD();
    ~CMiniportTopologyMSVAD();

    NTSTATUS                    GetDescription
    (   
        OUT PPCFILTER_DESCRIPTOR *  Description
    );

    NTSTATUS                    DataRangeIntersection
    (   
        IN  ULONG               PinId,
        IN  PKSDATARANGE        ClientDataRange,
        IN  PKSDATARANGE        MyDataRange,
        IN  ULONG               OutputBufferLength,
        OUT PVOID               ResultantFormat OPTIONAL,
        OUT PULONG              ResultantFormatLength
    );

    NTSTATUS                    Init
    ( 
        IN  PUNKNOWN            UnknownAdapter,
        IN  PPORTTOPOLOGY       Port_ 
    );

    // PropertyHandlers.
    NTSTATUS                    PropertyHandlerBasicSupportVolume
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );
    
    NTSTATUS                    PropertyHandlerCpuResources
    ( 
        IN  PPCPROPERTY_REQUEST PropertyRequest 
    );

    NTSTATUS                    PropertyHandlerGeneric
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

    NTSTATUS                    PropertyHandlerMute
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

    NTSTATUS                    PropertyHandlerMuxSource
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

    NTSTATUS                    PropertyHandlerVolume
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\adapter.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    adapter.cpp

Abstract:

    Setup and miniport installation.  No resources are used by msvad.

--*/

//
// All the GUIDS for all the miniports end up in this object.
//
#define PUT_GUIDS_HERE

#include <msvad.h>
#include "common.h"

//-----------------------------------------------------------------------------
// Defines                                                                    
//-----------------------------------------------------------------------------

// BUGBUG set this to number of miniports
#define MAX_MINIPORTS 3     // Number of maximum miniports.

//-----------------------------------------------------------------------------
// Externals
//-----------------------------------------------------------------------------

NTSTATUS
CreateMiniportWaveCyclicMSVAD
( 
    OUT PUNKNOWN *,
    IN  REFCLSID,
    IN  PUNKNOWN,
    IN  POOL_TYPE
);

NTSTATUS
CreateMiniportTopologyMSVAD
( 
    OUT PUNKNOWN *,
    IN  REFCLSID,
    IN  PUNKNOWN,
    IN  POOL_TYPE
);

//-----------------------------------------------------------------------------
// Referenced forward.
//-----------------------------------------------------------------------------

extern "C" NTSTATUS
AddDevice
( 
    IN  PDRIVER_OBJECT,
    IN  PDEVICE_OBJECT
);

NTSTATUS
StartDevice
( 
    IN  PDEVICE_OBJECT,      
    IN  PIRP,                
    IN  PRESOURCELIST        
); 

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

//=============================================================================
#pragma code_seg("INIT")
extern "C" NTSTATUS
DriverEntry
( 
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PUNICODE_STRING         RegistryPathName
)
{
/*++

Routine Description:

  Installable driver initialization entry point.
  This entry point is called directly by the I/O system.

  All audio adapter drivers can use this code without change.

Arguments:

  DriverObject - pointer to the driver object

  RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

  STATUS_SUCCESS if successful,
  STATUS_UNSUCCESSFUL otherwise.

--*/
    PAGED_CODE();

    NTSTATUS                    ntStatus;

    DPF(D_TERSE, ("[DriverEntry]"));

    // Tell the class driver to initialize the driver.
    //
    ntStatus =  
        PcInitializeAdapterDriver
        ( 
            DriverObject,
            RegistryPathName,
            AddDevice 
        );

    return ntStatus;
} // DriverEntry
#pragma code_seg()

#pragma code_seg("PAGE")
//=============================================================================
extern "C" NTSTATUS
AddDevice
( 
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject 
)
/*++

Routine Description:

  The Plug & Play subsystem is handing us a brand new PDO, for which we
  (by means of INF registration) have been asked to provide a driver.

  We need to determine if we need to be in the driver stack for the device.
  Create a function device object to attach to the stack
  Initialize that device object
  Return status success.

  All audio adapter drivers can use this code without change.
  Set MAX_MINIPORTS depending on the number of miniports that the driver
  uses.

Arguments:

  DriverObject - pointer to a driver object

  PhysicalDeviceObject -  pointer to a device object created by the
                            underlying bus driver.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    NTSTATUS                    ntStatus;

    DPF(D_TERSE, ("[AddDevice]"));

    // Tell the class driver to add the device.
    //
    ntStatus = 
        PcAddAdapterDevice
        ( 
            DriverObject,
            PhysicalDeviceObject,
            PCPFNSTARTDEVICE(StartDevice),
            MAX_MINIPORTS,
            0
        );

    return ntStatus;
} // AddDevice

//=============================================================================
NTSTATUS
InstallSubdevice
( 
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PWCHAR                  Name,
    IN  REFGUID                 PortClassId,
    IN  REFGUID                 MiniportClassId,
    IN  PFNCREATEINSTANCE       MiniportCreate   OPTIONAL,
    IN  PUNKNOWN                UnknownAdapter   OPTIONAL,
    IN  PRESOURCELIST           ResourceList,
    IN  REFGUID                 PortInterfaceId,
    OUT PUNKNOWN *              OutPortInterface OPTIONAL,
    OUT PUNKNOWN *              OutPortUnknown   OPTIONAL 
)
{
/*++

Routine Description:

    This function creates and registers a subdevice consisting of a port       
    driver, a minport driver and a set of resources bound together.  It will   
    also optionally place a pointer to an interface on the port driver in a    
    specified location before initializing the port driver.  This is done so   
    that a common ISR can have access to the port driver during 
    initialization, when the ISR might fire.                                   

Arguments:

    DeviceObject - pointer to the driver object

    Irp - pointer to the irp object.

    Name - name of the miniport. Passes to PcRegisterSubDevice
 
    PortClassId - port class id. Passed to PcNewPort.

    MiniportClassId - miniport class id. Passed to PcNewMiniport.

    MiniportCreate - pointer to a miniport creation function. If NULL, 
                     PcNewMiniport is used.

    UnknownAdapter - pointer to the adapter object. 
                     Used for initializing the port.

    ResourceList - pointer to the resource list.

    PortInterfaceId - GUID that represents the port interface.
       
    OutPortInterface - pointer to store the port interface

    OutPortUnknown - pointer to store the unknown port interface.

Return Value:

    NT status code.

--*/
    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(Name);

    NTSTATUS                    ntStatus;
    PPORT                       port = NULL;
    PUNKNOWN                    miniport = NULL;
     
    DPF_ENTER(("[InstallSubDevice %s]", Name));

    // Create the port driver object
    //
    ntStatus = PcNewPort(&port, PortClassId);

    // Create the miniport object
    //
    if (NT_SUCCESS(ntStatus))
    {
        if (MiniportCreate)
        {
            ntStatus = 
                MiniportCreate
                ( 
                    &miniport,
                    MiniportClassId,
                    NULL,
                    NonPagedPool 
                );
        }
        else
        {
            ntStatus = 
                PcNewMiniport
                (
                    (PMINIPORT *) &miniport, 
                    MiniportClassId
                );
        }
    }

    // Init the port driver and miniport in one go.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = 
            port->Init
            ( 
                DeviceObject,
                Irp,
                miniport,
                UnknownAdapter,
                ResourceList 
            );

        if (NT_SUCCESS(ntStatus))
        {
            // Register the subdevice (port/miniport combination).
            //
            ntStatus = 
                PcRegisterSubdevice
                ( 
                    DeviceObject,
                    Name,
                    port 
                );
        }

        // We don't need the miniport any more.  Either the port has it,
        // or we've failed, and it should be deleted.
        //
        miniport->Release();
    }

    // Deposit the port interfaces if it's needed.
    //
    if (NT_SUCCESS(ntStatus))
    {
        if (OutPortUnknown)
        {
            ntStatus = 
                port->QueryInterface
                ( 
                    IID_IUnknown,
                    (PVOID *)OutPortUnknown 
                );
        }

        if (OutPortInterface)
        {
            ntStatus = 
                port->QueryInterface
                ( 
                    PortInterfaceId,
                    (PVOID *) OutPortInterface 
                );
        }
    }

    if (port)
    {
        port->Release();
    }

    return ntStatus;
} // InstallSubDevice

//=============================================================================
NTSTATUS
StartDevice
( 
    IN  PDEVICE_OBJECT          DeviceObject,     
    IN  PIRP                    Irp,              
    IN  PRESOURCELIST           ResourceList      
)  
{
/*++

Routine Description:

  This function is called by the operating system when the device is 
  started.
  It is responsible for starting the miniports.  This code is specific to    
  the adapter because it calls out miniports for functions that are specific 
  to the adapter.                                                            

Arguments:

  DeviceObject - pointer to the driver object

  Irp - pointer to the irp 

  ResourceList - pointer to the resource list assigned by PnP manager

Return Value:

  NT status code.

--*/
    PAGED_CODE();
    
    ASSERT(DeviceObject);
    ASSERT(Irp);
    ASSERT(ResourceList);

    NTSTATUS                    ntStatus        = STATUS_SUCCESS;
    PUNKNOWN                    unknownTopology = NULL;
    PUNKNOWN                    unknownWave     = NULL;
    PADAPTERCOMMON              pAdapterCommon  = NULL;
    PUNKNOWN                    pUnknownCommon  = NULL;

    DPF_ENTER(("[StartDevice]"));

    // create a new adapter common object
    //
    ntStatus = 
        NewAdapterCommon
        ( 
            &pUnknownCommon,
            IID_IAdapterCommon,
            NULL,
            NonPagedPool 
        );
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = 
            pUnknownCommon->QueryInterface
            ( 
                IID_IAdapterCommon,
                (PVOID *) &pAdapterCommon 
            );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = 
                pAdapterCommon->Init(DeviceObject);

            if (NT_SUCCESS(ntStatus))
            {
                // register with PortCls for power-management services
                //    
                ntStatus = 
                    PcRegisterAdapterPowerManagement
                    ( 
                        PUNKNOWN(pAdapterCommon),
                        DeviceObject 
                    );
            }
        }
    }

    // install MSVAD topology miniport.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = 
            InstallSubdevice
            ( 
                DeviceObject,
                Irp,
                L"Topology",
                CLSID_PortTopology,
                CLSID_PortTopology, 
                CreateMiniportTopologyMSVAD,
                pAdapterCommon,
                NULL,
                IID_IPortTopology,
                NULL,
                &unknownTopology 
            );
    }

    // install MSVAD wavecyclic miniport.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = 
            InstallSubdevice
            ( 
                DeviceObject,
                Irp,
                L"Wave",
                CLSID_PortWaveCyclic,
                CLSID_PortWaveCyclic,   
                CreateMiniportWaveCyclicMSVAD,
                pAdapterCommon,
                NULL,
                IID_IPortWaveCyclic,
                pAdapterCommon->WavePortDriverDest(),
                &unknownWave 
            );
    }

    if (unknownTopology && unknownWave)
    {
        // register wave <=> topology connections
        // This will connect bridge pins of wavecyclic and topology
        // miniports.
        //
        ntStatus =
            PcRegisterPhysicalConnection
            ( 
                DeviceObject,
                unknownTopology,
                TopologyPhysicalConnections.ulTopologyOut,
                unknownWave,
                TopologyPhysicalConnections.ulWaveIn
            );

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus =
                PcRegisterPhysicalConnection
                ( 
                    DeviceObject,
                    unknownWave,
                    TopologyPhysicalConnections.ulWaveOut,
                    unknownTopology,
                    TopologyPhysicalConnections.ulTopologyIn
                );
        }
    }

    // Release the adapter common object.  It either has other references,
    // or we need to delete it anyway.
    //
    if (pAdapterCommon)
    {
        pAdapterCommon->Release();
    }

    if (pUnknownCommon)
    {
        pUnknownCommon->Release();
    }
    
    if (unknownTopology)
    {
        unknownTopology->Release();
    }

    if (unknownWave)
    {
        unknownWave->Release();
    }

    return ntStatus;
} // StartDevice
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\basetopo.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    basetopo.cpp

Abstract:

    Implementation of topology miniport. This the base class for 
    all MSVAD samples

--*/

#include <msvad.h>
#include "common.h"
#include "basetopo.h"

//=============================================================================
#pragma code_seg("PAGE")
CMiniportTopologyMSVAD::CMiniportTopologyMSVAD
(
    void
)
/*++

Routine Description:

  Topology miniport constructor

Arguments:

Return Value:

  void

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopologyMSVAD::CMiniportTopologyMSVAD]"));

    m_AdapterCommon = NULL;
    m_FilterDescriptor = NULL;
} // CMiniportTopologyMSVAD

CMiniportTopologyMSVAD::~CMiniportTopologyMSVAD
(
    void
)
/*++

Routine Description:

  Topology miniport destructor

Arguments:

Return Value:

  void

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopologyMSVAD::~CMiniportTopologyMSVAD]"));

    if (m_AdapterCommon)
    {
        m_AdapterCommon->Release();
    }
} // ~CMiniportTopologyMSVAD

//=============================================================================
NTSTATUS
CMiniportTopologyMSVAD::DataRangeIntersection
( 
    IN  ULONG                   PinId,
    IN  PKSDATARANGE            ClientDataRange,
    IN  PKSDATARANGE            MyDataRange,
    IN  ULONG                   OutputBufferLength,
    OUT PVOID                   ResultantFormat     OPTIONAL,
    OUT PULONG                  ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest 
  quality intersection of two data ranges. Topology miniport does nothing.

Arguments:

  PinId - Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data range 
                    submitted by client in the data range intersection property 
                    request

  MyDataRange - Pin's data range to be compared with client's data range

  OutputBufferLength - Size of the buffer pointed to by the resultant format 
                       parameter

  ResultantFormat - Pointer to value where the resultant format should be 
                    returned

  ResultantFormatLength - Actual length of the resultant format that is placed 
                          at ResultantFormat. This should be less than or equal 
                          to OutputBufferLength

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopologyMSVAD::DataRangeIntersection]"));

    return (STATUS_NOT_IMPLEMENTED);
} // DataRangeIntersection

//=============================================================================
NTSTATUS
CMiniportTopologyMSVAD::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR *  OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    DPF_ENTER(("[CMiniportTopologyMSVAD::GetDescription]"));

    *OutFilterDescriptor = m_FilterDescriptor;

    return (STATUS_SUCCESS);
} // GetDescription

//=============================================================================
NTSTATUS
CMiniportTopologyMSVAD::Init
( 
    IN  PUNKNOWN                UnknownAdapter_,
    IN  PPORTTOPOLOGY           Port_ 
)
/*++

Routine Description:

  Initializes the topology miniport.

Arguments:

  UnknownAdapter -

  Port_ - Pointer to topology port

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter_);
    ASSERT(Port_);

    DPF_ENTER(("[CMiniportTopologyMSVAD::Init]"));

    NTSTATUS                    ntStatus;

    ntStatus = 
        UnknownAdapter_->QueryInterface
        ( 
            IID_IAdapterCommon,
            (PVOID *) &m_AdapterCommon
        );
    if (NT_SUCCESS(ntStatus))
    {
        m_AdapterCommon->MixerReset();
    }

    if (!NT_SUCCESS(ntStatus))
    {
        // clean up AdapterCommon
        if (m_AdapterCommon)
        {
            m_AdapterCommon->Release();
            m_AdapterCommon = NULL;
        }
    }

    return ntStatus;
} // Init

//=============================================================================
NTSTATUS
CMiniportTopologyMSVAD::PropertyHandlerBasicSupportVolume
(
    IN  PPCPROPERTY_REQUEST     PropertyRequest
)
/*++

Routine Description:

  Handles BasicSupport for Volume nodes.

Arguments:
    
  PropertyRequest - property request structure

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    ULONG                       cbFullProperty = 
        sizeof(KSPROPERTY_DESCRIPTION) +
        sizeof(KSPROPERTY_MEMBERSHEADER) +
        sizeof(KSPROPERTY_STEPPING_LONG);

    if(PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)))
    {
        PKSPROPERTY_DESCRIPTION PropDesc = 
            PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);

        PropDesc->AccessFlags       = KSPROPERTY_TYPE_ALL;
        PropDesc->DescriptionSize   = cbFullProperty;
        PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        PropDesc->PropTypeSet.Id    = VT_I4;
        PropDesc->PropTypeSet.Flags = 0;
        PropDesc->MembersListCount  = 1;
        PropDesc->Reserved          = 0;

        // if return buffer can also hold a range description, return it too
        if(PropertyRequest->ValueSize >= cbFullProperty)
        {
            // fill in the members header
            PKSPROPERTY_MEMBERSHEADER Members = 
                PKSPROPERTY_MEMBERSHEADER(PropDesc + 1);

            Members->MembersFlags   = KSPROPERTY_MEMBER_STEPPEDRANGES;
            Members->MembersSize    = sizeof(KSPROPERTY_STEPPING_LONG);
            Members->MembersCount   = 1;
            Members->Flags          = 0;

            // fill in the stepped range
            PKSPROPERTY_STEPPING_LONG Range = 
                PKSPROPERTY_STEPPING_LONG(Members + 1);

            // BUGBUG these are from SB16 driver.
            // Are these valid.
            Range->Bounds.SignedMaximum = 0xE0000;      // 14  (dB) * 0x10000
            Range->Bounds.SignedMinimum = 0xFFF20000;   // -14 (dB) * 0x10000
            Range->SteppingDelta        = 0x20000;      // 2   (dB) * 0x10000
            Range->Reserved             = 0;

            // set the return value size
            PropertyRequest->ValueSize = cbFullProperty;
        } 
        else
        {
            PropertyRequest->ValueSize = 0;
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
    } 
    else if(PropertyRequest->ValueSize >= sizeof(ULONG))
    {
        // if return buffer can hold a ULONG, return the access flags
        PULONG AccessFlags = PULONG(PropertyRequest->Value);

        PropertyRequest->ValueSize = sizeof(ULONG);
        *AccessFlags = KSPROPERTY_TYPE_ALL;
    }
    else if (PropertyRequest->ValueSize == 0)
    {
        // Send the caller required value size.
        PropertyRequest->ValueSize = cbFullProperty;
        ntStatus = STATUS_BUFFER_OVERFLOW;
    }
    else
    {
        PropertyRequest->ValueSize = 0;
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    return ntStatus;
} // PropertyHandlerBasicSupportVolume

//=============================================================================
NTSTATUS
CMiniportTopologyMSVAD::PropertyHandlerCpuResources
( 
    IN  PPCPROPERTY_REQUEST     PropertyRequest 
)
/*++

Routine Description:

  Processes KSPROPERTY_AUDIO_CPURESOURCES

Arguments:
    
  PropertyRequest - property request structure

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopologyMSVAD::PropertyHandlerCpuResources]"));

    NTSTATUS ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
    {
        ntStatus = ValidatePropertyParams(PropertyRequest, sizeof(ULONG));
        if (NT_SUCCESS(ntStatus))
        {
            *(PLONG(PropertyRequest->Value)) = KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU;
            PropertyRequest->ValueSize = sizeof(LONG);
        }
    }
    else if (PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        ntStatus = 
            PropertyHandler_BasicSupport
            ( 
                PropertyRequest, 
                KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
                VT_ILLEGAL
            );
    }

    return ntStatus;
} // PropertyHandlerCpuResources

//=============================================================================
NTSTATUS                            
CMiniportTopologyMSVAD::PropertyHandlerGeneric
(
    IN  PPCPROPERTY_REQUEST     PropertyRequest
)
/*++

Routine Description:

  Handles all properties for this miniport.

Arguments:

  PropertyRequest - property request structure

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    NTSTATUS                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    switch (PropertyRequest->PropertyItem->Id)
    {
        case KSPROPERTY_AUDIO_VOLUMELEVEL:
            ntStatus = PropertyHandlerVolume(PropertyRequest);
            break;
        
        case KSPROPERTY_AUDIO_CPU_RESOURCES:
            ntStatus = PropertyHandlerCpuResources(PropertyRequest);
            break;

        case KSPROPERTY_AUDIO_MUTE:
            ntStatus = PropertyHandlerMute(PropertyRequest);
            break;

        case KSPROPERTY_AUDIO_MUX_SOURCE:
            ntStatus = PropertyHandlerMuxSource(PropertyRequest);
            break;

        default:
            DPF(D_TERSE, ("[PropertyHandlerGeneric: Invalid Device Request]"));
    }

    return ntStatus;
} // PropertyHandlerGeneric

//=============================================================================
NTSTATUS                            
CMiniportTopologyMSVAD::PropertyHandlerMute
(
    IN  PPCPROPERTY_REQUEST     PropertyRequest
)
/*++

Routine Description:

  Property handler for KSPROPERTY_AUDIO_MUTE

Arguments:

  PropertyRequest - property request structure

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopologyMSVAD::PropertyHandlerMute]"));

    NTSTATUS                    ntStatus;
    LONG                        lChannel;
    PBOOL                       pfMute;

    if (PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        ntStatus = 
            PropertyHandler_BasicSupport
            (
                PropertyRequest,
                KSPROPERTY_TYPE_ALL,
                VT_BOOL
            );
    }
    else
    {
        ntStatus = 
            ValidatePropertyParams
            (   
                PropertyRequest, 
                sizeof(BOOL), 
                sizeof(LONG)
            );
        if (NT_SUCCESS(ntStatus))
        {
            lChannel = * PLONG (PropertyRequest->Instance);
            pfMute   = PBOOL (PropertyRequest->Value);

            if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
            {
                *pfMute = 
                    m_AdapterCommon->MixerMuteRead
                    (
                        PropertyRequest->Node
                    );
                PropertyRequest->ValueSize = sizeof(BOOL);
                ntStatus = STATUS_SUCCESS;
            }
            else if (PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
            {
                m_AdapterCommon->MixerMuteWrite
                (
                    PropertyRequest->Node, 
                    *pfMute
                );
                ntStatus = STATUS_SUCCESS;
            }
        }
        else
        {
            DPF(D_TERSE, ("[PropertyHandlerMute - Invalid parameter]"));
            ntStatus = STATUS_INVALID_PARAMETER;
        }
    }

    return ntStatus;
} // PropertyHandlerMute

//=============================================================================
NTSTATUS                            
CMiniportTopologyMSVAD::PropertyHandlerMuxSource
(
    IN  PPCPROPERTY_REQUEST     PropertyRequest
)
/*++

Routine Description:

  PropertyHandler for KSPROPERTY_AUDIO_MUX_SOURCE.

Arguments:

  PropertyRequest - property request structure

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopologyMSVAD::PropertyHandlerMuxSource]"));

    NTSTATUS                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    //
    // Validate node
    // This property is only valid for WAVEIN_MUX node.
    //
    // TODO if (WAVEIN_MUX == PropertyRequest->Node)
    {
        if (PropertyRequest->ValueSize >= sizeof(ULONG))
        {
            PULONG pulMuxValue = PULONG(PropertyRequest->Value);
            
            if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
            {
                *pulMuxValue = m_AdapterCommon->MixerMuxRead();
                PropertyRequest->ValueSize = sizeof(ULONG);
                ntStatus = STATUS_SUCCESS;
            }
            else if (PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
            {
                m_AdapterCommon->MixerMuxWrite(*pulMuxValue);
                ntStatus = STATUS_SUCCESS;
            }
            else if (PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
            {
                ntStatus = 
                    PropertyHandler_BasicSupport
                    ( 
                        PropertyRequest, 
                        KSPROPERTY_TYPE_ALL,
                        VT_I4
                    );
            }
        }
        else
        {
            DPF(D_TERSE, ("[PropertyHandlerMuxSource - Invalid parameter]"));
            ntStatus = STATUS_INVALID_PARAMETER;
        }
    }

    return ntStatus;
} // PropertyHandlerMuxSource

//=============================================================================
NTSTATUS
CMiniportTopologyMSVAD::PropertyHandlerVolume
(
    IN  PPCPROPERTY_REQUEST     PropertyRequest     
)
/*++

Routine Description:

  Property handler for KSPROPERTY_AUDIO_VOLUMELEVEL

Arguments:

  PropertyRequest - property request structure

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportTopologyMSVAD::PropertyHandlerVolume]"));

    NTSTATUS                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    LONG                        lChannel;
    PULONG                      pulVolume;

    if (PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        ntStatus = PropertyHandlerBasicSupportVolume(PropertyRequest);
    }
    else
    {
        ntStatus = 
            ValidatePropertyParams
            (
                PropertyRequest, 
                sizeof(ULONG), 
                sizeof(KSNODEPROPERTY_AUDIO_CHANNEL)
            );
        if (NT_SUCCESS(ntStatus))
        {
            lChannel = * (PLONG (PropertyRequest->Instance));
            pulVolume = PULONG (PropertyRequest->Value);

            if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
            {
                *pulVolume = 
                    m_AdapterCommon->MixerVolumeRead
                    (
                        PropertyRequest->Node, 
                        lChannel
                    );
                PropertyRequest->ValueSize = sizeof(ULONG);                
                ntStatus = STATUS_SUCCESS;
            }
            else if (PropertyRequest->Verb & KSPROPERTY_TYPE_SET)
            {
                m_AdapterCommon->MixerVolumeWrite
                (
                    PropertyRequest->Node, 
                    lChannel, 
                    *pulVolume
                );
                ntStatus = STATUS_SUCCESS;
            }
        }
        else
        {
            DPF(D_TERSE, ("[PropertyHandlerVolume - Invalid parameter]"));
            ntStatus = STATUS_INVALID_PARAMETER;
        }
    }

    return ntStatus;
} // PropertyHandlerVolume

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\mpu401\adapter.cpp ===
/*****************************************************************************
 * adapter.cpp - MPU401 adapter driver implementation.
 *****************************************************************************
 * Copyright (c) 1997-1999 Microsoft Corporation.  All rights reserved.
 *
 * Created 6/19/97, a-seemap
 *
 */

//
// All the GUIDS for all the miniports end up in this object.
//
#define PUT_GUIDS_HERE

#define STR_MODULENAME "MPU401Adapter: "
#define PC_NEW_NAMES 1

#define kUseDMusicMiniport 1

#include "portcls.h"
#include "ksdebug.h"

#if (kUseDMusicMiniport)
#include "dmusicks.h"
#endif  //  kUseDMusicMiniport

/*****************************************************************************
 * Defines
 */

#define MAX_MINIPORTS 1

#if (DBG)
#define SUCCEEDS(s) ASSERT(NT_SUCCESS(s))
#else
#define SUCCEEDS(s) (s)
#endif

/*****************************************************************************
 * Referenced forward
 */
extern "C"
NTSTATUS
AddDevice
(
        IN PVOID        Context1,
        IN PVOID        Context2
);

NTSTATUS
StartDevice
(
    IN      PDEVICE_OBJECT  pDeviceObject,  // Context for the class driver.
    IN      PIRP            pIrp,           // Context for the class driver.
    IN      PRESOURCELIST   ResourceList    // List of hardware resources.
);


#pragma code_seg("INIT")
/*****************************************************************************
 * DriverEntry()
 *****************************************************************************
 * This function is called by the operating system when the driver is loaded.
 * All adapter drivers can use this code without change.
 */
extern "C"
NTSTATUS
DriverEntry
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE, ("DriverEntry"));
//    _DbgPrintF(DEBUGLVL_ERROR, ("Starting breakpoint for debugging"));

    //
    // Tell the class driver to initialize the driver.
    //
    return PcInitializeAdapterDriver((PDRIVER_OBJECT)Context1,
                                     (PUNICODE_STRING)Context2,
                                     (PDRIVER_ADD_DEVICE)AddDevice);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * AddDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is added.
 * All adapter drivers can use this code without change.
 */
NTSTATUS
AddDevice
(
    IN      PVOID   Context1,   // Context for the class driver.
    IN      PVOID   Context2    // Context for the class driver.
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE, ("AddDevice"));

    //
    // Tell the class driver to add the device.
    //
    return PcAddAdapterDevice((PDRIVER_OBJECT)Context1,(PDEVICE_OBJECT)Context2,StartDevice,MAX_MINIPORTS,0);
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * InstallSubdevice()
 *****************************************************************************
 * This function creates and registers a subdevice consisting of a port
 * driver, a minport driver and a set of resources bound together.  It will
 * also optionally place a pointer to an interface on the port driver in a
 * specified location before initializing the port driver.  This is done so
 * that a common ISR can have access to the port driver during initialization,
 * when the ISR might fire.
 */
NTSTATUS
InstallSubdevice
(
    IN      PVOID               Context1,
    IN      PVOID               Context2,
    IN      PWCHAR              Name,
    IN      REFGUID             PortClassId,
    IN      REFGUID             MiniportClassId,
    IN      PUNKNOWN            UnknownAdapter      OPTIONAL,   //not used - null
    IN      PRESOURCELIST       ResourceList,                   //not optional, but can be EMPTY!
    IN      REFGUID             PortInterfaceId,
    OUT     PUNKNOWN *          OutPortInterface,   OPTIONAL    //not used - null
    OUT     PUNKNOWN *          OutPortUnknown      OPTIONAL    //not used - null
)
{
    PAGED_CODE();
    _DbgPrintF(DEBUGLVL_VERBOSE, ("InstallSubdevice"));

    ASSERT(Context1);
    ASSERT(Context2);
    ASSERT(Name);
    ASSERT(ResourceList);

    //
    // Create the port driver object
    //
    PPORT       port;
    NTSTATUS    ntStatus = PcNewPort(&port,PortClassId);

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Deposit the port somewhere if it's needed.
        //
        if (OutPortInterface)
        {
            //
            //  Failure here doesn't cause the entire routine to fail.
            //
            (void) port->QueryInterface
            (
                PortInterfaceId,
                (PVOID *) OutPortInterface
            );
        }

        PMINIPORT miniport;
        //
        // Create the miniport object
        //
        ntStatus = PcNewMiniport(&miniport,MiniportClassId);

        if (NT_SUCCESS(ntStatus))
        {
            //
            // Init the port driver and miniport in one go.
            //
            ntStatus = port->Init( (PDEVICE_OBJECT)Context1,
                                   (PIRP)Context2,
                                   miniport,
                                   NULL,   // interruptsync created in miniport.
                                   ResourceList);

            if (NT_SUCCESS(ntStatus))
            {
                //
                // Register the subdevice (port/miniport combination).
                //
                ntStatus = PcRegisterSubdevice( (PDEVICE_OBJECT)Context1,
                                                Name,
                                                port    );
                if (!(NT_SUCCESS(ntStatus)))
                {
                    _DbgPrintF(DEBUGLVL_TERSE, ("StartDevice: PcRegisterSubdevice failed"));
                }
            }
            else
            {
                _DbgPrintF(DEBUGLVL_TERSE, ("InstallSubdevice: port->Init failed"));
            }

            //
            // We don't need the miniport any more.  Either the port has it,
            // or we've failed, and it should be deleted.
            //
            miniport->Release();
        }
        else
        {
            _DbgPrintF(DEBUGLVL_TERSE, ("InstallSubdevice: PcNewMiniport failed"));
        }

        if (NT_SUCCESS(ntStatus))
        {
            //
            // Deposit the port as an unknown if it's needed.
            //
            if (OutPortUnknown)
            {
                //
                //  Failure here doesn't cause the entire routine to fail.
                //
                (void) port->QueryInterface
                (
                    IID_IUnknown,
                    (PVOID *) OutPortUnknown
                );
            }
        }
        else
        {
            //
            // Retract previously delivered port interface.
            //
            if (OutPortInterface && (*OutPortInterface))
            {
                (*OutPortInterface)->Release();
                *OutPortInterface = NULL;
            }
        }

        //
        // Release the reference which existed when PcNewPort() gave us the
        // pointer in the first place.  This is the right thing to do
        // regardless of the outcome.
        //
        port->Release();
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("InstallSubdevice: PcNewPort failed"));
    }

    return ntStatus;
}

#pragma code_seg("PAGE")
/*****************************************************************************
 * StartDevice()
 *****************************************************************************
 * This function is called by the operating system when the device is started.
 * It is responsible for starting the miniport. 
 * This code is specific to the adapter because it calls out miniports for  
 * functions that are specific to the adapter.
 */
NTSTATUS
StartDevice
(
    IN      PDEVICE_OBJECT  pDeviceObject,  // Context for the class driver.
    IN      PIRP            pIrp,           // Context for the class driver.
    IN      PRESOURCELIST   ResourceList    // List of hardware resources.
)
{
    PAGED_CODE();

    ASSERT(pDeviceObject);
    ASSERT(pIrp);
    ASSERT(ResourceList);
    if (!ResourceList)
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("StartDevice: NULL resource list"));
        return STATUS_INVALID_PARAMETER;
    }

    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    
    if (ResourceList->NumberOfEntries())
    {
#if (kUseDMusicMiniport)
        //
        // Start the UART miniport.
        //
        ntStatus = InstallSubdevice(
                                    pDeviceObject,
                                    pIrp,
                                    L"Uart",
                                    CLSID_PortDMus,
                                    CLSID_MiniportDriverDMusUART,
                                    NULL,
                                    ResourceList,
                                    IID_IPortDMus,
                                    NULL,
                                    NULL    // Not physically connected to anything.
                                    );
#else   //  (kUseDMusicMiniport)
        //
        // Start the UART miniport.
        //
        ntStatus = InstallSubdevice(
                                    pDeviceObject,
                                    pIrp,
                                    L"Uart",
                                    CLSID_PortMidi,
                                    CLSID_MiniportDriverUart,
                                    NULL,
                                    ResourceList,
                                    IID_IPortMidi,
                                    NULL,
                                    NULL    // Not physically connected to anything.
                                    );
#endif  //  (kUseDMusicMiniport)
    }
    else
    {
        _DbgPrintF(DEBUGLVL_TERSE, ("StartDevice: no entries in resource list"));
    }
    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\basedma.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    basedma.cpp

Abstract:

    IDmaChannel implementation. Does nothing HW related.

--*/

#include <msvad.h>
#include "common.h"
#include "basewave.h"

#pragma code_seg("PAGE")
//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclicStreamMSVAD::AllocateBuffer
( 
    IN ULONG                    BufferSize,
    IN PPHYSICAL_ADDRESS        PhysicalAddressConstraint OPTIONAL 
)
/*++

Routine Description:

  The AllocateBuffer function allocates a buffer associated with the DMA object. 
  The buffer is nonPaged.
  Callers of AllocateBuffer should run at a passive IRQL.

Arguments:

  BufferSize - Size in bytes of the buffer to be allocated. 

  PhysicalAddressConstraint - Optional constraint to place on the physical 
                              address of the buffer. If supplied, only the bits 
                              that are set in the constraint address may vary 
                              from the beginning to the end of the buffer. 
                              For example, if the desired buffer should not 
                              cross a 64k boundary, the physical address 
                              constraint 0x000000000000ffff should be specified

Return Value:

  NT status code.

--*/
{
    DPF_ENTER(("[CMiniportWaveCyclicStreamMSVAD::AllocateBuffer]"));

    NTSTATUS                    ntStatus = STATUS_SUCCESS;

    //
    // Adjust this cap as needed...
    ASSERT (BufferSize <= DMA_BUFFER_SIZE);

    m_pvDmaBuffer = (PVOID)
        ExAllocatePoolWithTag
        ( 
            NonPagedPool, 
            BufferSize,
            MSVAD_POOLTAG
        );
    if (!m_pvDmaBuffer)
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        m_ulDmaBufferSize = BufferSize;
    }

    return ntStatus;
} // AllocateBuffer
#pragma code_seg()

//=============================================================================
STDMETHODIMP_(ULONG)
CMiniportWaveCyclicStreamMSVAD::AllocatedBufferSize
( 
    void 
)
/*++

Routine Description:

  AllocatedBufferSize returns the size of the allocated buffer. 
  Callers of AllocatedBufferSize can run at any IRQL.

Arguments:

Return Value:

  ULONG

--*/
{
    DPF_ENTER(("[CMiniportWaveCyclicStreamMSVAD::AllocatedBufferSize]"));

    return m_ulDmaBufferSize;
} // AllocatedBufferSize

//=============================================================================
STDMETHODIMP_(ULONG)
CMiniportWaveCyclicStreamMSVAD::BufferSize
( 
    void 
)
/*++

Routine Description:

  BufferSize returns the size set by SetBufferSize or the allocated buffer size 
  if the buffer size has not been set. The DMA object does not actually use 
  this value internally. This value is maintained by the object to allow its 
  various clients to communicate the intended size of the buffer. This call 
  is often used to obtain the map size parameter to the Start member 
  function. Callers of BufferSize can run at any IRQL

Arguments:

Return Value:

  ULONG

--*/
{
    return m_ulDmaBufferSize;
} // BufferSize

//=============================================================================
STDMETHODIMP_(void)
CMiniportWaveCyclicStreamMSVAD::CopyFrom
( 
    IN  PVOID                   Destination,
    IN  PVOID                   Source,
    IN  ULONG                   ByteCount 
)
/*++

Routine Description:

  The CopyFrom function copies sample data from the DMA buffer. 
  Callers of CopyFrom can run at any IRQL

Arguments:

  Destination - Points to the destination buffer. 

  Source - Points to the source buffer. 

  ByteCount - Points to the source buffer. 

Return Value:

  void

--*/
{
} // CopyFrom

//=============================================================================
STDMETHODIMP_(void)
CMiniportWaveCyclicStreamMSVAD::CopyTo
( 
    IN  PVOID                   Destination,
    IN  PVOID                   Source,
    IN  ULONG                   ByteCount 
/*++

Routine Description:

  The CopyTo function copies sample data to the DMA buffer. 
  Callers of CopyTo can run at any IRQL. 

Arguments:

  Destination - Points to the destination buffer. 
  
  Source - Points to the source buffer

  ByteCount - Number of bytes to be copied

Return Value:

  void

--*/
)
{
    m_SaveData.WriteData((PBYTE) Source, ByteCount);
} // CopyTo

//=============================================================================
#pragma code_seg("PAGE")
STDMETHODIMP_(void)
CMiniportWaveCyclicStreamMSVAD::FreeBuffer
( 
    void 
)
/*++

Routine Description:

  The FreeBuffer function frees the buffer allocated by AllocateBuffer. Because 
  the buffer is automatically freed when the DMA object is deleted, this 
  function is not normally used. Callers of FreeBuffer should run at 
  IRQL PASSIVE_LEVEL.

Arguments:

Return Value:

  void

--*/
{
    DPF_ENTER(("[CMiniportWaveCyclicStreamMSVAD::FreeBuffer]"));

    if ( m_pvDmaBuffer )
    {
        ExFreePool( m_pvDmaBuffer );
        m_ulDmaBufferSize = 0;
    }
} // FreeBuffer
#pragma code_seg()

//=============================================================================
STDMETHODIMP_(PADAPTER_OBJECT)
CMiniportWaveCyclicStreamMSVAD::GetAdapterObject
( 
    void 
)
/*++

Routine Description:

  The GetAdapterObject function returns the DMA object's internal adapter 
  object. Callers of GetAdapterObject can run at any IRQL.

Arguments:

Return Value:

  PADAPTER_OBJECT - The return value is the object's internal adapter object.

--*/
{
    DPF_ENTER(("[CMiniportWaveCyclicStreamMSVAD::GetAdapterObject]"));

    // MSVAD does not have need a physical DMA channel. Therefore it 
    // does not have physical DMA structure.
    
    return NULL;
} // GetAdapterObject

//=============================================================================
STDMETHODIMP_(ULONG)
CMiniportWaveCyclicStreamMSVAD::MaximumBufferSize
( 
    void 
)
/*++

Routine Description:

Arguments:

Return Value:

  NT status code.

--*/
{
    DPF_ENTER(("[CMiniportWaveCyclicStreamMSVAD::MaximumBufferSize]"));

    return m_pMiniport->m_MaxDmaBufferSize;
} // MaximumBufferSize

//=============================================================================
STDMETHODIMP_(PHYSICAL_ADDRESS)
CMiniportWaveCyclicStreamMSVAD::PhysicalAddress
( 
    void 
)
/*++

Routine Description:

  MaximumBufferSize returns the size in bytes of the largest buffer this DMA 
  object is configured to support. Callers of MaximumBufferSize can run 
  at any IRQL

Arguments:

Return Value:

  PHYSICAL_ADDRESS - The return value is the size in bytes of the largest 
                     buffer this DMA object is configured to support.

--*/
{
    DPF_ENTER(("[CMiniportWaveCyclicStreamMSVAD::PhysicalAddress]"));

    PHYSICAL_ADDRESS            pAddress;

    pAddress.QuadPart = (LONGLONG) m_pvDmaBuffer;

    return pAddress;
} // PhysicalAddress

//=============================================================================
STDMETHODIMP_(void)
CMiniportWaveCyclicStreamMSVAD::SetBufferSize
( 
    IN ULONG                    BufferSize 
)
/*++

Routine Description:

  The SetBufferSize function sets the current buffer size. This value is set to 
  the allocated buffer size when AllocateBuffer is called. The DMA object does 
  not actually use this value internally. This value is maintained by the object 
  to allow its various clients to communicate the intended size of the buffer. 
  Callers of SetBufferSize can run at any IRQL.

Arguments:

  BufferSize - Current size in bytes.

Return Value:

  void

--*/
{
    DPF_ENTER(("[CMiniportWaveCyclicStreamMSVAD::SetBufferSize]"));

    if ( BufferSize <= m_ulDmaBufferSize )
    {
        m_ulDmaBufferSize = BufferSize;
    }
    else
    {
        DPF(D_ERROR, ("Tried to enlarge dma buffer size"));
    }
} // SetBufferSize

//=============================================================================
STDMETHODIMP_(PVOID)
CMiniportWaveCyclicStreamMSVAD::SystemAddress
( 
    void 
)
/*++

Routine Description:

  The SystemAddress function returns the virtual system address of the 
  allocated buffer. Callers of SystemAddress can run at any IRQL.

Arguments:

Return Value:

  PVOID - The return value is the virtual system address of the 
          allocated buffer.

--*/
{
    return m_pvDmaBuffer;
} // SystemAddress

//=============================================================================
STDMETHODIMP_(ULONG)
CMiniportWaveCyclicStreamMSVAD::TransferCount
( 
    void 
)
/*++

Routine Description:

  The TransferCount function returns the size in bytes of the buffer currently 
  being transferred by a slave DMA object. Callers of TransferCount can run 
  at any IRQL.

Arguments:

Return Value:

  ULONG - The return value is the size in bytes of the buffer currently 
          being transferred.

--*/
{
    DPF_ENTER(("[CMiniportWaveCyclicStreamMSVAD::TransferCount]"));

    return m_ulDmaBufferSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\basewave.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    basewave.cpp

Abstract:

    Implementation of wavecyclic miniport.

--*/

#include <msvad.h>
#include "common.h"
#include "basewave.h"

//=============================================================================
// CMiniportWaveCyclicMSVAD
//=============================================================================

//=============================================================================
#pragma code_seg("PAGE")
CMiniportWaveCyclicMSVAD::CMiniportWaveCyclicMSVAD
(
    void
)
/*++

Routine Description:

  Constructor for wavecyclic miniport.

Arguments:

Return Value:

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicMSVAD::CMiniportWaveCyclicMSVAD]"));

    // Initialize members.
    //
    m_AdapterCommon = NULL;
    m_Port = NULL;
    m_FilterDescriptor = NULL;

    m_NotificationInterval = 0;
    m_SamplingFrequency = 0;

    m_ServiceGroup = NULL;
    m_MaxDmaBufferSize = DMA_BUFFER_SIZE;

    m_MaxOutputStreams = 0;
    m_MaxInputStreams = 0;
    m_MaxTotalStreams = 0;

    m_MinChannels = 0;
    m_MaxChannelsPcm = 0;
    m_MinBitsPerSamplePcm = 0;
    m_MaxBitsPerSamplePcm = 0;
    m_MinSampleRatePcm = 0;
    m_MaxSampleRatePcm = 0;
} // CMiniportWaveCyclicMSVAD

//=============================================================================
CMiniportWaveCyclicMSVAD::~CMiniportWaveCyclicMSVAD
(
    void
)
/*++

Routine Description:

  Destructor for wavecyclic miniport

Arguments:

Return Value:

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicMSVAD::~CMiniportWaveCyclicMSVAD]"));

    if (m_Port)
    {
        m_Port->Release();
    }

    if (m_ServiceGroup)
    {
        m_ServiceGroup->Release();
    }

    if (m_AdapterCommon)
    {
        m_AdapterCommon->Release();
    }
} // ~CMiniportWaveCyclicMSVAD

//=============================================================================
STDMETHODIMP
CMiniportWaveCyclicMSVAD::GetDescription
(
    OUT PPCFILTER_DESCRIPTOR * OutFilterDescriptor
)
/*++

Routine Description:

    The GetDescription function gets a pointer to a filter description.
    The descriptor is defined in wavtable.h for each MSVAD sample.

Arguments:

  OutFilterDescriptor - Pointer to the filter description

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    DPF_ENTER(("[CMiniportWaveCyclicMSVAD::GetDescription]"));

    *OutFilterDescriptor = m_FilterDescriptor;

    return (STATUS_SUCCESS);
} // GetDescription

//=============================================================================
STDMETHODIMP
CMiniportWaveCyclicMSVAD::Init
(
    IN  PUNKNOWN                UnknownAdapter_,
    IN  PRESOURCELIST           ResourceList_,
    IN  PPORTWAVECYCLIC         Port_
)
/*++

Routine Description:

Arguments:

  UnknownAdapter_ - pointer to adapter common.

  ResourceList_ - resource list. MSVAD does not use resources.

  Port_ - pointer to the port

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter_);
    ASSERT(Port_);

    DPF_ENTER(("[CMiniportWaveCyclicMSVAD::Init]"));

    // AddRef() is required because we are keeping this pointer.
    //
    m_Port = Port_;
    m_Port->AddRef();

    // We want the IAdapterCommon interface on the adapter common object,
    // which is given to us as a IUnknown.  The QueryInterface call gives us
    // an AddRefed pointer to the interface we want.
    //
    NTSTATUS ntStatus =
        UnknownAdapter_->QueryInterface
        (
            IID_IAdapterCommon,
            (PVOID *) &m_AdapterCommon
        );

    if (NT_SUCCESS(ntStatus))
    {
        KeInitializeMutex(&m_SampleRateSync, 1);
        ntStatus = PcNewServiceGroup(&m_ServiceGroup, NULL);

        if (NT_SUCCESS(ntStatus))
        {
            m_AdapterCommon->SetWaveServiceGroup(m_ServiceGroup);
        }
    }

    if (!NT_SUCCESS(ntStatus))
    {
        // clean up AdapterCommon
        //
        if (m_AdapterCommon)
        {
            // clean up the service group
            //
            if (m_ServiceGroup)
            {
                m_AdapterCommon->SetWaveServiceGroup(NULL);
                m_ServiceGroup->Release();
                m_ServiceGroup = NULL;
            }

            m_AdapterCommon->Release();
            m_AdapterCommon = NULL;
        }

        // release the port
        //
        m_Port->Release();
        m_Port = NULL;
    }

    return ntStatus;
} // Init

//=============================================================================
NTSTATUS
CMiniportWaveCyclicMSVAD::PropertyHandlerCpuResources
(
    IN  PPCPROPERTY_REQUEST     PropertyRequest
)
/*++

Routine Description:

  Processes KSPROPERTY_AUDIO_CPURESOURCES

Arguments:

  PropertyRequest - property request structure

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(PropertyRequest);

    DPF_ENTER(("[CMiniportWaveCyclicMSVAD::PropertyHandlerCpuResources]"));

    NTSTATUS                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    if (PropertyRequest->Verb & KSPROPERTY_TYPE_GET)
    {
        ntStatus = ValidatePropertyParams(PropertyRequest, sizeof(LONG), 0);
        if (NT_SUCCESS(ntStatus))
        {
            *(PLONG(PropertyRequest->Value)) = KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU;
            PropertyRequest->ValueSize = sizeof(LONG);
            ntStatus = STATUS_SUCCESS;
        }
    }
    else if (PropertyRequest->Verb & KSPROPERTY_TYPE_BASICSUPPORT)
    {
        ntStatus =
            PropertyHandler_BasicSupport
            (
                PropertyRequest,
                KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT,
                VT_I4
            );
    }

    return ntStatus;
} // PropertyHandlerCpuResources

//=============================================================================
NTSTATUS
CMiniportWaveCyclicMSVAD::PropertyHandlerGeneric
(
    IN  PPCPROPERTY_REQUEST     PropertyRequest
)
/*++

Routine Description:

  Handles all properties for this miniport.

Arguments:

  PropertyRequest - property request structure

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(PropertyRequest);
    ASSERT(PropertyRequest->PropertyItem);

    NTSTATUS                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;

    switch (PropertyRequest->PropertyItem->Id)
    {
        case KSPROPERTY_AUDIO_CPU_RESOURCES:
            ntStatus = PropertyHandlerCpuResources(PropertyRequest);
            break;

        default:
            DPF(D_TERSE, ("[PropertyHandlerGeneric: Invalid Device Request]"));
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    }

    return ntStatus;
} // PropertyHandlerGeneric

//=============================================================================
NTSTATUS
CMiniportWaveCyclicMSVAD::ValidateFormat
(
    IN  PKSDATAFORMAT           pDataFormat
)
/*++

Routine Description:

  Validates that the given dataformat is valid.
  This version of the driver only supports PCM.

Arguments:

  pDataFormat - The dataformat for validation.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(pDataFormat);

    DPF_ENTER(("[CMiniportWaveCyclicMSVAD::ValidateFormat]"));

    NTSTATUS                    ntStatus = STATUS_INVALID_PARAMETER;
    PWAVEFORMATEX               pwfx;

    pwfx = GetWaveFormatEx(pDataFormat);
    if (pwfx)
    {
        if (IS_VALID_WAVEFORMATEX_GUID(&pDataFormat->SubFormat))
        {
            USHORT wfxID = EXTRACT_WAVEFORMATEX_ID(&pDataFormat->SubFormat);

            switch (wfxID)
            {
                case WAVE_FORMAT_PCM:
                {
                    switch (pwfx->wFormatTag)
                    {
                        case WAVE_FORMAT_PCM:
                        {
                            ntStatus = ValidatePcm(pwfx);
                            break;
                        }
                    }
                    break;
                }

                default:
                    DPF(D_TERSE, ("Invalid format EXTRACT_WAVEFORMATEX_ID!"));
                    break;
            }
        }
        else
        {
            DPF(D_TERSE, ("Invalid pDataFormat->SubFormat!") );
        }
    }

    return ntStatus;
} // ValidateFormat

//-----------------------------------------------------------------------------
NTSTATUS
CMiniportWaveCyclicMSVAD::ValidatePcm
(
    IN  PWAVEFORMATEX           pWfx
)
/*++

Routine Description:

  Given a waveformatex and format size validates that the format is in device
  datarange.

Arguments:

  pWfx - wave format structure.

Return Value:

    NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("CMiniportWaveCyclicMSVAD::ValidatePcm"));

    if
    (
        pWfx                                                &&
        (pWfx->cbSize == 0)                                 &&
        (pWfx->nChannels >= m_MinChannels)                  &&
        (pWfx->nChannels <= m_MaxChannelsPcm)               &&
        (pWfx->nSamplesPerSec >= m_MinSampleRatePcm)        &&
        (pWfx->nSamplesPerSec <= m_MaxSampleRatePcm)        &&
        (pWfx->wBitsPerSample >= m_MinBitsPerSamplePcm)     &&
        (pWfx->wBitsPerSample <= m_MaxBitsPerSamplePcm)
    )
    {
        return STATUS_SUCCESS;
    }

    DPF(D_TERSE, ("Invalid PCM format"));

    return STATUS_INVALID_PARAMETER;
} // ValidatePcm

//=============================================================================
// CMiniportWaveCyclicStreamMSVAD
//=============================================================================

CMiniportWaveCyclicStreamMSVAD::CMiniportWaveCyclicStreamMSVAD
(
    void
)
{
    m_pMiniport = NULL;
    m_fCapture = FALSE;
    m_fFormat16Bit = FALSE;
    m_fFormatStereo = FALSE;
    m_ksState = KSSTATE_STOP;
    m_ulPin = (ULONG)-1;

    m_pDpc = NULL;
    m_pTimer = NULL;

    m_fDmaActive = FALSE;
    m_ulDmaPosition = 0;
    m_pvDmaBuffer = NULL;
    m_ulDmaBufferSize = 0;
    m_ulDmaMovementRate = 0;    
    m_ullDmaTimeStamp = 0;
}

//=============================================================================
CMiniportWaveCyclicStreamMSVAD::~CMiniportWaveCyclicStreamMSVAD
(
    void
)
/*++

Routine Description:

  Destructor for wavecyclic stream

Arguments:

  void

Return Value:

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicStreamMS::~CMiniportWaveCyclicStreamMS]"));

    if (m_pTimer)
    {
        KeCancelTimer(m_pTimer);
        ExFreePool(m_pTimer);
    }

    if (m_pDpc)
    {
        ExFreePool( m_pDpc );
    }

    // Free the DMA buffer
    //
    FreeBuffer();
} // ~CMiniportWaveCyclicStreamMSVAD

//=============================================================================
NTSTATUS
CMiniportWaveCyclicStreamMSVAD::Init
(
    IN  PCMiniportWaveCyclicMSVAD Miniport_,
    IN  ULONG                   Pin_,
    IN  BOOLEAN                 Capture_,
    IN  PKSDATAFORMAT           DataFormat_
)
/*++

Routine Description:

  Initializes the stream object. Allocate a DMA buffer, timer and DPC

Arguments:

  Miniport_ - miniport object

  Pin_ - pin id

  Capture_ - TRUE if this is a capture stream

  DataFormat_ - new dataformat

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicStreamMSVAD::Init]"));

    ASSERT(Miniport_);
    ASSERT(DataFormat_);

    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PWAVEFORMATEX               pWfx;

    pWfx = GetWaveFormatEx(DataFormat_);
    if (!pWfx)
    {
        DPF(D_TERSE, ("Invalid DataFormat param in NewStream"));
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(ntStatus))
    {
        m_pMiniport = Miniport_;

        m_ulPin         = Pin_;
        m_fCapture      = Capture_;
        m_fFormatStereo = (pWfx->nChannels == 2);
        m_fFormat16Bit  = (pWfx->wBitsPerSample == 16);
        m_ksState       = KSSTATE_STOP;
        m_ulDmaPosition = 0;
        m_fDmaActive    = FALSE;
        m_pDpc          = NULL;
        m_pTimer        = NULL;
        m_pvDmaBuffer   = NULL;

        // If this is not the capture stream, create the output file.
        //
        if (!m_fCapture)
        {
            DPF(D_TERSE, ("SaveData %X", &m_SaveData));
            ntStatus = m_SaveData.SetDataFormat(DataFormat_);
            if (NT_SUCCESS(ntStatus))
            {
                ntStatus = m_SaveData.Initialize();
            }

        }
    }

    // Allocate DMA buffer for this stream.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = AllocateBuffer(m_pMiniport->m_MaxDmaBufferSize, NULL);
    }

    // Set sample frequency. Note that m_SampleRateSync access should
    // be syncronized.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus =
            KeWaitForSingleObject
            (
                &m_pMiniport->m_SampleRateSync,
                Executive,
                KernelMode,
                FALSE,
                NULL
            );
        if (NT_SUCCESS(ntStatus))
        {
            m_pMiniport->m_SamplingFrequency = pWfx->nSamplesPerSec;
            KeReleaseMutex(&m_pMiniport->m_SampleRateSync, FALSE);
        }
        else
        {
            DPF(D_TERSE, ("[SamplingFrequency Sync failed: %08X]", ntStatus));
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = SetFormat(DataFormat_);
    }

    if (NT_SUCCESS(ntStatus))
    {
        m_pDpc = (PRKDPC)
            ExAllocatePoolWithTag
            (
                NonPagedPool,
                sizeof(KDPC),
                MSVAD_POOLTAG
            );
        if (!m_pDpc)
        {
            DPF(D_TERSE, ("[Could not allocate memory for DPC]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        m_pTimer = (PKTIMER)
            ExAllocatePoolWithTag
            (
                NonPagedPool,
                sizeof(KTIMER),
                MSVAD_POOLTAG
            );
        if (!m_pTimer)
        {
            DPF(D_TERSE, ("[Could not allocate memory for Timer]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        KeInitializeDpc(m_pDpc, TimerNotify, m_pMiniport);
        KeInitializeTimerEx(m_pTimer, NotificationTimer);
    }

    return ntStatus;
} // Init

#pragma code_seg()

//=============================================================================
// CMiniportWaveCyclicStreamMSVAD IMiniportWaveCyclicStream
//=============================================================================

//=============================================================================
STDMETHODIMP
CMiniportWaveCyclicStreamMSVAD::GetPosition
(
    OUT PULONG                  Position
)
/*++

Routine Description:

  The GetPosition function gets the current position of the DMA read or write
  pointer for the stream. Callers of GetPosition should run at
  IRQL <= DISPATCH_LEVEL.

Arguments:

  Position - Position of the DMA pointer

Return Value:

  NT status code.

--*/
{
    if (m_fDmaActive)
    {
        ULONGLONG CurrentTime = KeQueryInterruptTime();

        ULONG TimeElapsedInMS =
            ( (ULONG) (CurrentTime - m_ullDmaTimeStamp) ) / 10000;

        ULONG ByteDisplacement =
            (m_ulDmaMovementRate * TimeElapsedInMS) / 1000;

        m_ulDmaPosition =
            (m_ulDmaPosition + ByteDisplacement) % m_ulDmaBufferSize;

        *Position = m_ulDmaPosition;

        m_ullDmaTimeStamp = CurrentTime;
    }
    else
    {
        *Position = m_ulDmaPosition;
    }

    return STATUS_SUCCESS;
} // GetPosition

//=============================================================================
STDMETHODIMP
CMiniportWaveCyclicStreamMSVAD::NormalizePhysicalPosition
(
    IN OUT PLONGLONG            PhysicalPosition
)
/*++

Routine Description:

  Given a physical position based on the actual number of bytes transferred,
  NormalizePhysicalPosition converts the position to a time-based value of
  100 nanosecond units. Callers of NormalizePhysicalPosition can run at any IRQL.

Arguments:

  PhysicalPosition - On entry this variable contains the value to convert.
                     On return it contains the converted value

Return Value:

  NT status code.

--*/
{
    *PhysicalPosition =
        ( _100NS_UNITS_PER_SECOND /
        ( 1 << ( m_fFormatStereo + m_fFormat16Bit ) ) * *PhysicalPosition ) /
        m_pMiniport->m_SamplingFrequency;

    return STATUS_SUCCESS;
} // NormalizePhysicalPosition

#pragma code_seg("PAGE")
//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclicStreamMSVAD::SetFormat
(
    IN  PKSDATAFORMAT           Format
)
/*++

Routine Description:

  The SetFormat function changes the format associated with a stream.
  Callers of SetFormat should run at IRQL PASSIVE_LEVEL

Arguments:

  Format - Pointer to a KSDATAFORMAT structure which indicates the new format
           of the stream.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Format);

    DPF_ENTER(("[CMiniportWaveCyclicStreamMSVAD::SetFormat]"));

    NTSTATUS                    ntStatus = STATUS_INVALID_DEVICE_REQUEST;
    PWAVEFORMATEX               pWfx;

    if (m_ksState != KSSTATE_RUN)
    {
        // MSVAD does not validate the format.
        //
        pWfx = GetWaveFormatEx(Format);
        if (pWfx)
        {
            ntStatus =
                KeWaitForSingleObject
                (
                    &m_pMiniport->m_SampleRateSync,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL
                );
            if (NT_SUCCESS(ntStatus))
            {
                if (!m_fCapture)
                {
                    ntStatus = m_SaveData.SetDataFormat(Format);
                }

                m_fFormatStereo = (pWfx->nChannels == 2);
                m_fFormat16Bit  = (pWfx->wBitsPerSample == 16);
                m_pMiniport->m_SamplingFrequency =
                    pWfx->nSamplesPerSec;
                m_ulDmaMovementRate = pWfx->nAvgBytesPerSec;

                DPF(D_TERSE, ("New Format: %d", pWfx->nSamplesPerSec));
            }

            KeReleaseMutex(&m_pMiniport->m_SampleRateSync, FALSE);
        }
    }

    return ntStatus;
} // SetFormat

//=============================================================================
STDMETHODIMP_(ULONG)
CMiniportWaveCyclicStreamMSVAD::SetNotificationFreq
(
    IN  ULONG                   Interval,
    OUT PULONG                  FramingSize
)
/*++

Routine Description:

  The SetNotificationFrequency function sets the frequency at which
  notification interrupts are generated. Callers of SetNotificationFrequency
  should run at IRQL PASSIVE_LEVEL.

Arguments:

  Interval - Value indicating the interval between interrupts,
             expressed in milliseconds

  FramingSize - Pointer to a ULONG value where the number of bytes equivalent
                to Interval milliseconds is returned

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(FramingSize);

    DPF_ENTER(("[CMiniportWaveCyclicStreamMSVAD::SetNotificationFreq]"));

    m_pMiniport->m_NotificationInterval = Interval;

    *FramingSize =
        ( 1 << ( m_fFormatStereo + m_fFormat16Bit ) ) *
        m_pMiniport->m_SamplingFrequency *
        Interval / 1000;

  return m_pMiniport->m_NotificationInterval;
} // SetNotificationFreq

//=============================================================================
STDMETHODIMP
CMiniportWaveCyclicStreamMSVAD::SetState
(
    IN  KSSTATE                 NewState
)
/*++

Routine Description:

  The SetState function sets the new state of playback or recording for the
  stream. SetState should run at IRQL PASSIVE_LEVEL

Arguments:

  NewState - KSSTATE indicating the new state for the stream.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicStreamMSVAD::SetState]"));

    NTSTATUS                    ntStatus = STATUS_SUCCESS;

    // The acquire state is not distinguishable from the stop state for our
    // purposes.
    //
    if (NewState == KSSTATE_ACQUIRE)
    {
        NewState = KSSTATE_STOP;
    }

    if (m_ksState != NewState)
    {
        switch(NewState)
        {
            case KSSTATE_PAUSE:
            {
                DPF(D_TERSE, ("KSSTATE_PAUSE"));

                m_fDmaActive = FALSE;
            }
            break;

            case KSSTATE_RUN:
            {
                DPF(D_TERSE, ("KSSTATE_RUN"));

                 LARGE_INTEGER   delay;

                // Set the timer for DPC.
                //
                m_ullDmaTimeStamp   = KeQueryInterruptTime();
                m_fDmaActive        = TRUE;
                delay.HighPart      = 0;
                delay.LowPart       = m_pMiniport->m_NotificationInterval;

                KeSetTimerEx
                (
                    m_pTimer,
                    delay,
                    m_pMiniport->m_NotificationInterval,
                    m_pDpc
                );
            }
            break;

        case KSSTATE_STOP:

            DPF(D_TERSE, ("KSSTATE_STOP"));

            m_fDmaActive = FALSE;
            m_ulDmaPosition = 0;

            KeCancelTimer( m_pTimer );

            // Wait until all work items are completed.
            //
            if (!m_fCapture)
            {
                m_SaveData.WaitAllWorkItems();
            }

            break;
        }

        m_ksState = NewState;
    }

    return ntStatus;
} // SetState

#pragma code_seg()

//=============================================================================
STDMETHODIMP_(void)
CMiniportWaveCyclicStreamMSVAD::Silence
(
    IN PVOID                    Buffer,
    IN ULONG                    ByteCount
)
/*++

Routine Description:

  The Silence function is used to copy silence samplings to a certain location.
  Callers of Silence can run at any IRQL

Arguments:

  Buffer - Pointer to the buffer where the silence samplings should
           be deposited.

  ByteCount - Size of buffer indicating number of bytes to be deposited.

Return Value:

  NT status code.

--*/
{
    RtlFillMemory(Buffer, ByteCount, m_fFormat16Bit ? 0 : 0x80);
} // Silence

//=============================================================================
void
TimerNotify
(
    IN  PKDPC                   Dpc,
    IN  PVOID                   DeferredContext,
    IN  PVOID                   SA1,
    IN  PVOID                   SA2
)
/*++

Routine Description:

  Dpc routine. This simulates an interrupt service routine. The Dpc will be
  called whenever CMiniportWaveCyclicStreamMSVAD::m_pTimer triggers.

Arguments:

  Dpc - the Dpc object

  DeferredContext - Pointer to a caller-supplied context to be passed to
                    the DeferredRoutine when it is called

  SA1 - System argument 1

  SA2 - System argument 2

Return Value:

  NT status code.

--*/
{
    PCMiniportWaveCyclicMSVAD pMiniport =
        (PCMiniportWaveCyclicMSVAD) DeferredContext;

    if (pMiniport && pMiniport->m_Port)
    {
        pMiniport->m_Port->Notify(pMiniport->m_ServiceGroup);
    }
} // TimerNotify
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\basewave.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    basewave.h

Abstract:

    Definition of base wavecyclic and wavecyclic stream class.

--*/

#ifndef _MSVAD_BASEWAVE_H_
#define _MSVAD_BASEWAVE_H_

#include "savedata.h"

//=============================================================================
// Referenced Forward
//=============================================================================
void
TimerNotify
( 
    IN  PKDPC                   Dpc,
    IN  PVOID                   DeferredContext,
    IN  PVOID                   SA1, 
    IN  PVOID                   SA2 
);

class CMiniportWaveCyclicStreamMSVAD;
typedef CMiniportWaveCyclicStreamMSVAD *PCMiniportWaveCyclicStreamMSVAD;

//=============================================================================
// Classes
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclicMSVAD
//   This is the common base class for all MSVAD samples. It implements basic
//   functionality.

class CMiniportWaveCyclicMSVAD
{
protected:
    PADAPTERCOMMON              m_AdapterCommon;    // Adapter common object
    PPORTWAVECYCLIC             m_Port;             // Callback interface
    PPCFILTER_DESCRIPTOR        m_FilterDescriptor; // Filter descriptor

    ULONG                       m_NotificationInterval; // milliseconds.
    ULONG                       m_SamplingFrequency;    // Frames per second.

    PSERVICEGROUP               m_ServiceGroup;     // For notification.
    KMUTEX                      m_SampleRateSync;   // Sync for sample rate 

    ULONG                       m_MaxDmaBufferSize; // Dma buffer size.

    // All the below members should be updated by the child classes
    //
    ULONG                       m_MaxOutputStreams; // Max stream caps
    ULONG                       m_MaxInputStreams;
    ULONG                       m_MaxTotalStreams;

    ULONG                       m_MinChannels;      // Format caps
    ULONG                       m_MaxChannelsPcm;
    ULONG                       m_MinBitsPerSamplePcm;
    ULONG                       m_MaxBitsPerSamplePcm;
    ULONG                       m_MinSampleRatePcm;
    ULONG                       m_MaxSampleRatePcm;

protected:
    NTSTATUS                    ValidateFormat
    (
        IN  PKSDATAFORMAT       pDataFormat 
    );

    NTSTATUS                    ValidatePcm
    (
        IN  PWAVEFORMATEX       pWfx
    );

public:
    CMiniportWaveCyclicMSVAD();
    ~CMiniportWaveCyclicMSVAD();

    STDMETHODIMP                GetDescription
    (   
        OUT PPCFILTER_DESCRIPTOR *Description
    );

    STDMETHODIMP                Init
    (   IN PUNKNOWN             UnknownAdapter,
        IN PRESOURCELIST        ResourceList,
        IN PPORTWAVECYCLIC      Port
    );

    NTSTATUS                    PropertyHandlerCpuResources
    ( 
        IN  PPCPROPERTY_REQUEST PropertyRequest 
    );

    NTSTATUS                    PropertyHandlerGeneric
    (
        IN  PPCPROPERTY_REQUEST PropertyRequest
    );

    // Friends
    friend class                CMiniportWaveCyclicStreamMSVAD;
    friend class                CMiniportTopologyMSVAD;
    friend void                 TimerNotify
    ( 
        IN  PKDPC               Dpc, 
        IN  PVOID               DeferredContext, 
        IN  PVOID               SA1, 
        IN  PVOID               SA2 
    );
};
typedef CMiniportWaveCyclicMSVAD *PCMiniportWaveCyclicMSVAD;

///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclicStreamMSVAD
//   This is the common base class for all MSVAD samples. It implements basic
//   functionality for wavecyclic streams.

class CMiniportWaveCyclicStreamMSVAD : 
    public IMiniportWaveCyclicStream,
    public IDmaChannel
{
protected:
    PCMiniportWaveCyclicMSVAD   m_pMiniport;        // Miniport that created us
    BOOLEAN                     m_fCapture;         // Capture or render.
    BOOLEAN                     m_fFormat16Bit;     // 16- or 8-bit samples.
    BOOLEAN                     m_fFormatStereo;    // Two or one channel.
    KSSTATE                     m_ksState;          // Stop, pause, run.
    ULONG                       m_ulPin;            // Pin Id.

    PRKDPC                      m_pDpc;             // Deferred procedure call object
    PKTIMER                     m_pTimer;           // Timer object

    BOOLEAN                     m_fDmaActive;       // Dma currently active? 
    ULONG                       m_ulDmaPosition;    // Position in Dma
    PVOID                       m_pvDmaBuffer;      // Dma buffer pointer
    ULONG                       m_ulDmaBufferSize;  // Size of dma buffer
    ULONG                       m_ulDmaMovementRate;// Rate of transfer specific to system
    ULONGLONG                   m_ullDmaTimeStamp;  // Dma time elasped 

    CSaveData                   m_SaveData;         // Object to save settings.
  
public:
    CMiniportWaveCyclicStreamMSVAD();
    ~CMiniportWaveCyclicStreamMSVAD();

    IMP_IMiniportWaveCyclicStream;
    IMP_IDmaChannel;

    NTSTATUS                    Init
    ( 
        IN  PCMiniportWaveCyclicMSVAD  Miniport,
        IN  ULONG               Pin,
        IN  BOOLEAN             Capture,
        IN  PKSDATAFORMAT       DataFormat
    );

    // Friends
    friend class CMiniportWaveCyclicMSVAD;
};
typedef CMiniportWaveCyclicStreamMSVAD *PCMiniportWaveCyclicStreamMSVAD;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\common.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    common.cpp

Abstract:

    Implementation of the AdapterCommon class. 

--*/

#include <msvad.h>
#include "common.h"
#include "hw.h"
#include "savedata.h"

//-----------------------------------------------------------------------------
// Externals
//-----------------------------------------------------------------------------

PSAVEWORKER_PARAM               CSaveData::m_pWorkItems = NULL;
PDEVICE_OBJECT                  CSaveData::m_pDeviceObject = NULL;

//=============================================================================
// Classes
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// CAdapterCommon
//   

class CAdapterCommon : 
    public IAdapterCommon,
    public IAdapterPowerManagement,
    public CUnknown    
{
	private:
		PPORTWAVECYCLIC         m_pPortWave;    // Port interface
		PSERVICEGROUP           m_pServiceGroupWave;
		PDEVICE_OBJECT          m_pDeviceObject;      
		DEVICE_POWER_STATE      m_PowerState;        

        PCMSVADHW               m_pHW;          // Virtual MSVAD HW object

	public:
		//=====================================================================
		// Default CUnknown
        DECLARE_STD_UNKNOWN();
		DEFINE_STD_CONSTRUCTOR(CAdapterCommon);
		~CAdapterCommon();

		//=====================================================================
		// Default IAdapterPowerManagement
		IMP_IAdapterPowerManagement;

		//=====================================================================
		// IAdapterCommon methods                                               
		STDMETHODIMP_(NTSTATUS) Init
        (   
            IN  PDEVICE_OBJECT  DeviceObject
        );

        STDMETHODIMP_(PDEVICE_OBJECT)   GetDeviceObject(void);

		STDMETHODIMP_(PUNKNOWN *)       WavePortDriverDest(void);

		STDMETHODIMP_(void)     SetWaveServiceGroup
        (   
            IN  PSERVICEGROUP   ServiceGroup
        );

        STDMETHODIMP_(BOOL)     MixerMuteRead
        (
            IN  ULONG           Index
        );

        STDMETHODIMP_(void)     MixerMuteWrite
        (
            IN  ULONG           Index,
            IN  BOOL            Value
        );

        STDMETHODIMP_(ULONG)    MixerMuxRead(void);

        STDMETHODIMP_(void)     MixerMuxWrite
        (
            IN  ULONG           Index
        );

		STDMETHODIMP_(void)     MixerReset(void);

        STDMETHODIMP_(LONG)     MixerVolumeRead
        ( 
            IN  ULONG           Index,
            IN  LONG            Channel
        );

        STDMETHODIMP_(void)     MixerVolumeWrite
        ( 
            IN  ULONG           Index,
            IN  LONG            Channel,
            IN  LONG            Value 
        );

		//=====================================================================
		// friends

        friend NTSTATUS		    NewAdapterCommon
		( 
			OUT PADAPTERCOMMON * OutAdapterCommon, 
			IN  PRESOURCELIST   ResourceList 
		);
};

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

//=============================================================================
#pragma code_seg("PAGE")
NTSTATUS
NewAdapterCommon
( 
	OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

  Creates a new CAdapterCommon

Arguments:

  Unknown - 

  UnknownOuter -

  PoolType

Return Value:

  NT status code.

--*/
{
	PAGED_CODE();

	ASSERT(Unknown);

	STD_CREATE_BODY_
	( 
		CAdapterCommon, 
        Unknown, 
        UnknownOuter, 
        PoolType,      
		PADAPTERCOMMON 
	);
} // NewAdapterCommon

//=============================================================================
CAdapterCommon::~CAdapterCommon
( 
	void 
)
/*++

Routine Description:

  Destructor for CAdapterCommon.

Arguments:

Return Value:

  void

--*/
{
	PAGED_CODE();

	DPF_ENTER(("[CAdapterCommon::~CAdapterCommon]"));

    if (m_pHW)
    {
        delete m_pHW;
    }

    CSaveData::DestroyWorkItems();

    if (m_pPortWave)
	{
	    m_pPortWave->Release();
	}

	if (m_pServiceGroupWave)
	{
	    m_pServiceGroupWave->Release();
	}
} // ~CAdapterCommon  

//=============================================================================
STDMETHODIMP_(PDEVICE_OBJECT)   
CAdapterCommon::GetDeviceObject
(
    void
)
/*++

Routine Description:

  Returns the deviceobject

Arguments:

Return Value:

  PDEVICE_OBJECT

--*/
{
    PAGED_CODE();
    
    return m_pDeviceObject;
} // GetDeviceObject

//=============================================================================
NTSTATUS
CAdapterCommon::Init
( 
    IN  PDEVICE_OBJECT          DeviceObject 
)
/*++

Routine Description:

    Initialize adapter common object.

Arguments:

    DeviceObject - pointer to the device object

Return Value:

  NT status code.

--*/
{
	PAGED_CODE();

	ASSERT(DeviceObject);

    NTSTATUS                    ntStatus = STATUS_SUCCESS;

    DPF_ENTER(("[CAdapterCommon::Init]"));

	m_pDeviceObject = DeviceObject;
	m_PowerState    = PowerDeviceD0;

    // Initialize HW.
    // 
    m_pHW = new (NonPagedPool, MSVAD_POOLTAG)  CMSVADHW;
    if (!m_pHW)
    {
        DPF(D_TERSE, ("Insufficient memory for MSVAD HW"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        m_pHW->MixerReset();
    }

    // Initialize the work items for saving data to disk.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = CSaveData::InitializeWorkItems(DeviceObject);
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP_(void)
CAdapterCommon::MixerReset
( 
	void 
)
/*++

Routine Description:

  Reset mixer registers from registry.

Arguments:

Return Value:

  void

--*/
{
	PAGED_CODE();
    
    if (m_pHW)
    {
        m_pHW->MixerReset();
    }
} // MixerReset

//=============================================================================
STDMETHODIMP
CAdapterCommon::NonDelegatingQueryInterface
( 
	REFIID                      Interface,
    PVOID *                     Object 
)
/*++

Routine Description:

  QueryInterface routine for AdapterCommon

Arguments:

  Interface - 

  Object -

Return Value:

  NT status code.

--*/
{
	PAGED_CODE();

	ASSERT(Object);

	if (IsEqualGUIDAligned(Interface, IID_IUnknown))
	{
		*Object = PVOID(PUNKNOWN(PADAPTERCOMMON(this)));
	}
	else if (IsEqualGUIDAligned(Interface, IID_IAdapterCommon))
	{
		*Object = PVOID(PADAPTERCOMMON(this));
	}
	else if (IsEqualGUIDAligned(Interface, IID_IAdapterPowerManagement))
	{
		*Object = PVOID(PADAPTERPOWERMANAGEMENT(this));
	}
	else
	{
		*Object = NULL;
	}

	if (*Object)
	{
		PUNKNOWN(*Object)->AddRef();
		return STATUS_SUCCESS;
	}

	return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface

//=============================================================================
STDMETHODIMP_(void)
CAdapterCommon::SetWaveServiceGroup
( 
	IN PSERVICEGROUP            ServiceGroup 
)
/*++

Routine Description:


Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();
    
    DPF_ENTER(("[CAdapterCommon::SetWaveServiceGroup]"));
    
    if (m_pServiceGroupWave)
	{
		m_pServiceGroupWave->Release();
	}

	m_pServiceGroupWave = ServiceGroup;

	if (m_pServiceGroupWave)
	{
		m_pServiceGroupWave->AddRef();
	}
} // SetWaveServiceGroup

//=============================================================================
STDMETHODIMP_(PUNKNOWN *)
CAdapterCommon::WavePortDriverDest
( 
	void 
)
/*++

Routine Description:

  Returns the wave port.

Arguments:

Return Value:

  PUNKNOWN : pointer to waveport

--*/
{
	PAGED_CODE();

	return (PUNKNOWN *)&m_pPortWave;
} // WavePortDriverDest
#pragma code_seg()

//=============================================================================
STDMETHODIMP_(BOOL)
CAdapterCommon::MixerMuteRead
(
    IN  ULONG                   Index
)
/*++

Routine Description:

  Store the new value in mixer register array.

Arguments:

  Index - node id

Return Value:

    BOOL - mixer mute setting for this node

--*/
{
    if (m_pHW)
    {
        return m_pHW->GetMixerMute(Index);
    }

    return 0;
} // MixerMuteRead

//=============================================================================
STDMETHODIMP_(void)
CAdapterCommon::MixerMuteWrite
(
    IN  ULONG                   Index,
    IN  BOOL                    Value
)
/*++

Routine Description:

  Store the new value in mixer register array.

Arguments:

  Index - node id

  Value - new mute settings

Return Value:

  NT status code.

--*/
{
    if (m_pHW)
    {
        m_pHW->SetMixerMute(Index, Value);
    }
} // MixerMuteWrite

//=============================================================================
STDMETHODIMP_(ULONG)
CAdapterCommon::MixerMuxRead() 
/*++

Routine Description:

  Return the mux selection

Arguments:

  Index - node id

  Value - new mute settings

Return Value:

  NT status code.

--*/
{
    if (m_pHW)
    {
        return m_pHW->GetMixerMux();
    }

    return 0;
} // MixerMuxRead

//=============================================================================
STDMETHODIMP_(void)
CAdapterCommon::MixerMuxWrite
(
    IN  ULONG                   Index
)
/*++

Routine Description:

  Store the new mux selection

Arguments:

  Index - node id

  Value - new mute settings

Return Value:

  NT status code.

--*/
{
    if (m_pHW)
    {
        m_pHW->SetMixerMux(Index);
    }
} // MixerMuxWrite

//=============================================================================
STDMETHODIMP_(LONG)
CAdapterCommon::MixerVolumeRead
( 
	IN  ULONG                   Index,
    IN  LONG                    Channel
)
/*++

Routine Description:

  Return the value in mixer register array.

Arguments:

  Index - node id

  Channel = which channel

Return Value:

    Byte - mixer volume settings for this line

--*/
{
    if (m_pHW)
    {
        return m_pHW->GetMixerVolume(Index, Channel);
    }

    return 0;
} // MixerVolumeRead

//=============================================================================
STDMETHODIMP_(void)
CAdapterCommon::MixerVolumeWrite
( 
	IN  ULONG                   Index,
    IN  LONG                    Channel,
    IN  LONG                    Value
)
/*++

Routine Description:

  Store the new value in mixer register array.

Arguments:

  Index - node id

  Channel - which channel

  Value - new volume level

Return Value:

    void

--*/
{
    if (m_pHW)
    {
        m_pHW->SetMixerVolume(Index, Channel, Value);
    }
} // MixerVolumeWrite

//=============================================================================
STDMETHODIMP_(void)
CAdapterCommon::PowerChangeState
( 
    IN  POWER_STATE             NewState 
)
/*++

Routine Description:


Arguments:

  NewState - The requested, new power state for the device. 

Return Value:

    void

--*/
{
    UINT i;

    DPF_ENTER(("[CAdapterCommon::PowerChangeState]"));

    // is this actually a state change??
    //
    if (NewState.DeviceState != m_PowerState)
    {
        // switch on new state
        //
        switch (NewState.DeviceState)
        {
            case PowerDeviceD0:
            case PowerDeviceD1:
            case PowerDeviceD2:
            case PowerDeviceD3:
                m_PowerState = NewState.DeviceState;

                DPF
                ( 
                    D_VERBOSE, 
                    ("Entering D%d", ULONG(m_PowerState) - ULONG(PowerDeviceD0)) 
                );

                break;
    
            default:
            
                DPF(D_VERBOSE, ("Unknown Device Power State"));
                break;
        }
    }
} // PowerStateChange

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CAdapterCommon::QueryDeviceCapabilities
( 
    IN  PDEVICE_CAPABILITIES    PowerDeviceCaps 
)
/*++

Routine Description:

    Called at startup to get the caps for the device.  This structure provides 
    the system with the mappings between system power state and device power 
    state.  This typically will not need modification by the driver.         

Arguments:

  PowerDeviceCaps - The device's capabilities. 

Return Value:

  NT status code.

--*/
{
    DPF_ENTER(("[CAdapterCommon::QueryDeviceCapabilities]"));

    return (STATUS_SUCCESS);
} // QueryDeviceCapabilities

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CAdapterCommon::QueryPowerChangeState
( 
    IN  POWER_STATE             NewStateQuery 
)
/*++

Routine Description:

  Query to see if the device can change to this power state 

Arguments:

  NewStateQuery - The requested, new power state for the device

Return Value:

  NT status code.

--*/
{
    DPF_ENTER(("[CAdapterCommon::QueryPowerChangeState]"));

    return STATUS_SUCCESS;
} // QueryPowerChangeState
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\hw.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    hw.h

Abstract:

    Declaration of MSVAD HW class. 
    MSVAD HW has an array for storing mixer and volume settings
    for the topology.

--*/

#ifndef _MSVAD_HW_H_
#define _MSVAD_HW_H_

//=============================================================================
// Defines
//=============================================================================
// BUGBUG we should dynamically allocate this...
#define MAX_TOPOLOGY_NODES      20

//=============================================================================
// Classes
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// CMSVADHW
// This class represents virtual MSVAD HW. An array representing volume
// registers and mute registers.

class CMSVADHW
{
public:
protected:
    BOOL                        m_MuteControls[MAX_TOPOLOGY_NODES];
    LONG                        m_VolumeControls[MAX_TOPOLOGY_NODES];
    ULONG                       m_ulMux;            // Mux selection

private:

public:
    CMSVADHW();
    
    void                        MixerReset();
    BOOL                        GetMixerMute
    (
        IN  ULONG               ulNode
    );
    void                        SetMixerMute
    (
        IN  ULONG               ulNode,
        IN  BOOL                fMute
    );
    ULONG                       GetMixerMux();
    void                        SetMixerMux
    (
        IN  ULONG               ulNode
    );
    LONG                        GetMixerVolume
    (   
        IN  ULONG               ulNode,
        IN  LONG                lChannel
    );
    void                        SetMixerVolume
    (   
        IN  ULONG               ulNode,
        IN  LONG                lChannel,
        IN  LONG                lVolume
    );

protected:
private:
};
typedef CMSVADHW                *PCMSVADHW;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\common.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    Common.h

Abstract:
    
    CAdapterCommon class declaration.

--*/

#ifndef _MSVAD_COMMON_H_
#define _MSVAD_COMMON_H_

//=============================================================================
// Defines
//=============================================================================

DEFINE_GUID(IID_IAdapterCommon,
0x7eda2950, 0xbf9f, 0x11d0, 0x87, 0x1f, 0x0, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

//=============================================================================
// Interfaces
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// IAdapterCommon
//
DECLARE_INTERFACE_(IAdapterCommon, IUnknown)
{
    STDMETHOD_(NTSTATUS,        Init) 
    ( 
        THIS_
        IN  PDEVICE_OBJECT      DeviceObject 
    ) PURE;

    STDMETHOD_(PDEVICE_OBJECT,  GetDeviceObject)
    (
        THIS
    ) PURE;

    STDMETHOD_(VOID,            SetWaveServiceGroup) 
    ( 
        THIS_
        IN PSERVICEGROUP        ServiceGroup 
    ) PURE;

    STDMETHOD_(PUNKNOWN *,      WavePortDriverDest) 
    ( 
        THIS 
    ) PURE;

    STDMETHOD_(BOOL,            MixerMuteRead)
    (
        THIS_
        IN  ULONG               Index
    ) PURE;

    STDMETHOD_(VOID,            MixerMuteWrite)
    (
        THIS_
        IN  ULONG               Index,
        IN  BOOL                Value
    );

    STDMETHOD_(ULONG,           MixerMuxRead)
    (
        THIS
    );

    STDMETHOD_(VOID,            MixerMuxWrite)
    (
        THIS_
        IN  ULONG               Index
    );

    STDMETHOD_(LONG,            MixerVolumeRead) 
    ( 
        THIS_
        IN  ULONG               Index,
        IN  LONG                Channel
    ) PURE;

    STDMETHOD_(VOID,            MixerVolumeWrite) 
    ( 
        THIS_
        IN  ULONG               Index,
        IN  LONG                Channel,
        IN  LONG                Value 
    ) PURE;

    STDMETHOD_(VOID,            MixerReset) 
    ( 
        THIS 
    ) PURE;
};
typedef IAdapterCommon *PADAPTERCOMMON;

//=============================================================================
// Function Prototypes
//=============================================================================
NTSTATUS
NewAdapterCommon
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
);

#endif  //_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\kshelper.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    kshelper.cpp

Abstract:

    Helper functions for msvad

--*/

#include "kshelper.h"

//-----------------------------------------------------------------------------
PWAVEFORMATEX                   
GetWaveFormatEx
(
    IN  PKSDATAFORMAT           pDataFormat
)
/*++

Routine Description:

  Returns the waveformatex for known formats. 

Arguments:

  pDataFormat - data format.

Return Value:
    
    waveformatex in DataFormat.
    NULL for unknown data formats.

--*/
{
    PWAVEFORMATEX           pWfx = NULL;
    
    // If this is a known dataformat extract the waveformat info.
    //
    if
    ( 
        pDataFormat &&
        ( IsEqualGUIDAligned(pDataFormat->MajorFormat, 
                KSDATAFORMAT_TYPE_AUDIO)             &&
          ( IsEqualGUIDAligned(pDataFormat->Specifier, 
                KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
            IsEqualGUIDAligned(pDataFormat->Specifier, 
                KSDATAFORMAT_SPECIFIER_DSOUND) ) )
    )
    {
        pWfx = PWAVEFORMATEX(pDataFormat + 1);

        if (IsEqualGUIDAligned(pDataFormat->Specifier, 
                KSDATAFORMAT_SPECIFIER_DSOUND))
        {
            PKSDSOUND_BUFFERDESC    pwfxds;

            pwfxds = PKSDSOUND_BUFFERDESC(pDataFormat + 1);
            pWfx = &pwfxds->WaveFormatEx;
        }
    }

    return pWfx;
} // GetWaveFormatEx

//-----------------------------------------------------------------------------
NTSTATUS                        
PropertyHandler_BasicSupport
(
    IN PPCPROPERTY_REQUEST         PropertyRequest,
    IN ULONG                       Flags,
    IN DWORD                       PropTypeSetId
)
/*++

Routine Description:

  Default basic support handler. Basic processing depends on the size of data.
  For ULONG it only returns Flags. For KSPROPERTY_DESCRIPTION, the structure   
  is filled.

Arguments:

  PropertyRequest - 

  Flags - Support flags.

  PropTypeSetId - PropTypeSetId

Return Value:
    
    NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Flags & KSPROPERTY_TYPE_BASICSUPPORT);

    NTSTATUS                    ntStatus = STATUS_INVALID_PARAMETER;

    if (PropertyRequest->ValueSize >= (sizeof(KSPROPERTY_DESCRIPTION)) &&
        VT_ILLEGAL != PropTypeSetId)
    {
        // if return buffer can hold a KSPROPERTY_DESCRIPTION, return it
        //
        PKSPROPERTY_DESCRIPTION PropDesc = 
            PKSPROPERTY_DESCRIPTION(PropertyRequest->Value);

        PropDesc->AccessFlags       = Flags;
        PropDesc->DescriptionSize   = sizeof(KSPROPERTY_DESCRIPTION);
        PropDesc->PropTypeSet.Set   = KSPROPTYPESETID_General;
        PropDesc->PropTypeSet.Id    = PropTypeSetId;
        PropDesc->PropTypeSet.Flags = 0;
        PropDesc->MembersListCount  = 0;
        PropDesc->Reserved          = 0;

        PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
        ntStatus = STATUS_SUCCESS;
    } 
    else if (PropertyRequest->ValueSize >= sizeof(ULONG))
    {
        // if return buffer can hold a ULONG, return the access flags
        //
        *(PULONG(PropertyRequest->Value)) = Flags;

        PropertyRequest->ValueSize = sizeof(ULONG);
        ntStatus = STATUS_SUCCESS;                    
    }
    else if (0 == PropertyRequest->ValueSize)
    {
        // Send the caller required value size.
        PropertyRequest->ValueSize = sizeof(KSPROPERTY_DESCRIPTION);
        ntStatus = STATUS_BUFFER_OVERFLOW;
    }
    else
    {
        PropertyRequest->ValueSize = 0;
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    return ntStatus;
} // PropertyHandler_BasicSupport

//-----------------------------------------------------------------------------
NTSTATUS 
ValidatePropertyParams
(
    IN PPCPROPERTY_REQUEST      PropertyRequest, 
    IN ULONG                    cbSize,
    IN ULONG                    cbInstanceSize /* = 0  */
)
/*++

Routine Description:

  Validates property parameters.

Arguments:

  PropertyRequest - 
  cbSize -
  cbInstanceSize -

Return Value:

  NT status code.

--*/
{
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    if (PropertyRequest && cbSize)
    {
        // If the caller is asking for ValueSize.
        //
        if (0 == PropertyRequest->ValueSize) 
        {
            PropertyRequest->ValueSize = cbSize;
            ntStatus = STATUS_BUFFER_OVERFLOW;
        }
        // If the caller passed an invalid ValueSize.
        //
        else if (PropertyRequest->ValueSize < cbSize)
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else if (PropertyRequest->InstanceSize < cbInstanceSize)
        {
            ntStatus = STATUS_BUFFER_TOO_SMALL;
        }
        // If all parameters are OK.
        // 
        else if (PropertyRequest->ValueSize == cbSize)
        {
            if (PropertyRequest->Value)
            {
                ntStatus = STATUS_SUCCESS;
                //
                // Caller should set ValueSize, if the property 
                // call is successful.
                //
            }
        }
    }
    else
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    
    // Clear the ValueSize if unsuccessful.
    //
    if (PropertyRequest &&
        STATUS_SUCCESS != ntStatus &&
        STATUS_BUFFER_OVERFLOW != ntStatus)
    {
        PropertyRequest->ValueSize = 0;
    }

    return ntStatus;
} // ValidatePropertyParams
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\kshelper.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    kshelper.h

Abstract:

    Helper functions for msvad

--*/
#ifndef _MSVAD_KSHELPER_H_
#define _MSVAD_KSHELPER_H_

#include <portcls.h>
#include <ksdebug.h>

PWAVEFORMATEX                   GetWaveFormatEx
(
    IN  PKSDATAFORMAT           pDataFormat
);

NTSTATUS                        PropertyHandler_BasicSupport
(
    IN  PPCPROPERTY_REQUEST     PropertyRequest,
    IN  ULONG                   Flags,
    IN  DWORD                   PropTypeSetId
);

NTSTATUS                        ValidatePropertyParams
(
    IN PPCPROPERTY_REQUEST      PropertyRequest, 
    IN ULONG                    cbValueSize,
    IN ULONG                    cbInstanceSize = 0 
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\msvad.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    Msvad.h

Abstract:

    Header file for common stuff.

--*/

#ifndef _MSVAD_H_
#define _MSVAD_H_

#include <portcls.h>
#include <stdunk.h>
#include <ksdebug.h>
#include "kshelper.h"

//=============================================================================
// Defines
//=============================================================================

// Version number. Revision numbers are specified for each sample.
#define MSVAD_VERSION               1

// Revision number.
#define MSVAD_REVISION              0

// Product Id
// {5B722BF8-F0AB-47ee-B9C8-8D61D31375A1}
#define STATIC_PID_MSVAD\
    0x5b722bf8, 0xf0ab, 0x47ee, 0xb9, 0xc8, 0x8d, 0x61, 0xd3, 0x13, 0x75, 0xa1
DEFINE_GUIDSTRUCT("5B722BF8-F0AB-47ee-B9C8-8D61D31375A1", PID_MSVAD);
#define PID_MSVAD DEFINE_GUIDNAMED(PID_MSVAD)

// Pool tag used for MSVAD allocations
#define MSVAD_POOLTAG               'DVSM'  

// Debug module name
#define STR_MODULENAME              "MSVAD: "

// Debug utility macros
#define D_FUNC                      4
#define D_BLAB                      DEBUGLVL_BLAB
#define D_VERBOSE                   DEBUGLVL_VERBOSE        
#define D_TERSE                     DEBUGLVL_TERSE          
#define D_ERROR                     DEBUGLVL_ERROR          
#define DPF                         _DbgPrintF
#define DPF_ENTER(x)                DPF(D_FUNC, x)

// Channel orientation
#define CHAN_LEFT                   0
#define CHAN_RIGHT                  1
#define CHAN_MASTER                 (-1)

// Dma Settings.
#define DMA_BUFFER_SIZE             0x16000

#define KSPROPERTY_TYPE_ALL         KSPROPERTY_TYPE_BASICSUPPORT | \
                                    KSPROPERTY_TYPE_GET | \
                                    KSPROPERTY_TYPE_SET

//=============================================================================
// Typedefs
//=============================================================================

// Connection table for registering topology/wave bridge connection
typedef struct _PHYSICALCONNECTIONTABLE
{
    ULONG       ulTopologyIn;
    ULONG       ulTopologyOut;
    ULONG       ulWaveIn;
    ULONG       ulWaveOut;
} PHYSICALCONNECTIONTABLE, *PPHYSICALCONNECTIONTABLE;

//=============================================================================
// Externs
//=============================================================================

// Physical connection table. Defined in mintopo.cpp for each sample
extern PHYSICALCONNECTIONTABLE TopologyPhysicalConnections;

// Generic topology handler
extern NTSTATUS PropertyHandler_Topology
( 
    IN  PPCPROPERTY_REQUEST     PropertyRequest 
);

// Generic wave port handler
extern NTSTATUS PropertyHandler_Wave
(
    IN  PPCPROPERTY_REQUEST     PropertyRequest
);

// Default WaveFilter automation table.
// Handles the GeneralComponentId request.
extern NTSTATUS PropertyHandler_WaveFilter
(
    IN PPCPROPERTY_REQUEST PropertyRequest
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\hw.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    hw.cpp

Abstract:

    Implementation of MSVAD HW class. 
    MSVAD HW has an array for storing mixer and volume settings
    for the topology.


--*/
#include <msvad.h>
#include "hw.h"

//=============================================================================
// CMSVADHW
//=============================================================================

//=============================================================================
#pragma code_seg("PAGE")
CMSVADHW::CMSVADHW()
: m_ulMux(0)
/*++

Routine Description:

    Constructor for MSVADHW. 

Arguments:

Return Value:

    void

--*/
{
    PAGED_CODE();
    
    MixerReset();
} // CMSVADHW
#pragma code_seg()

//=============================================================================
BOOL
CMSVADHW::GetMixerMute
(
    IN  ULONG                   ulNode
)
/*++

Routine Description:

  Gets the HW (!) mute levels for MSVAD

Arguments:

  ulNode - topology node id

Return Value:

  mute setting

--*/
{
    if (ulNode < MAX_TOPOLOGY_NODES)
    {
        return m_MuteControls[ulNode];
    }

    return 0;
} // GetMixerMute

//=============================================================================
ULONG                       
CMSVADHW::GetMixerMux()
/*++

Routine Description:

  Return the current mux selection

Arguments:

Return Value:

  ULONG

--*/
{
    return m_ulMux;
} // GetMixerMux

//=============================================================================
LONG
CMSVADHW::GetMixerVolume
(   
    IN  ULONG                   ulNode,
    IN  LONG                    lChannel
)
/*++

Routine Description:

  Gets the HW (!) volume for MSVAD.

Arguments:

  ulNode - topology node id

  lChannel - which channel are we setting?

Return Value:

  LONG - volume level

--*/
{
    if (ulNode < MAX_TOPOLOGY_NODES)
    {
        return m_VolumeControls[ulNode];
    }

    return 0;
} // GetMixerVolume

//=============================================================================
#pragma code_seg("PAGE")
void 
CMSVADHW::MixerReset()
/*++

Routine Description:

  Resets the mixer registers.

Arguments:

Return Value:

    void

--*/
{
    PAGED_CODE();
    
    RtlFillMemory(m_VolumeControls, sizeof(LONG) * MAX_TOPOLOGY_NODES, 0xFF);
    RtlFillMemory(m_MuteControls, sizeof(BOOL) * MAX_TOPOLOGY_NODES, TRUE);
    
    // BUGBUG change this depending on the topology
    m_ulMux = 2;
} // MixerReset
#pragma code_seg()

//=============================================================================
void
CMSVADHW::SetMixerMute
(
    IN  ULONG                   ulNode,
    IN  BOOL                    fMute
)
/*++

Routine Description:

  Sets the HW (!) mute levels for MSVAD

Arguments:

  ulNode - topology node id

  fMute - mute flag

Return Value:

    void

--*/
{
    if (ulNode < MAX_TOPOLOGY_NODES)
    {
        m_MuteControls[ulNode] = fMute;
    }
} // SetMixerMute

//=============================================================================
void                        
CMSVADHW::SetMixerMux
(
    IN  ULONG                   ulNode
)
/*++

Routine Description:

  Sets the HW (!) mux selection

Arguments:

  ulNode - topology node id

Return Value:

    void

--*/
{
    m_ulMux = ulNode;
} // SetMixMux

//=============================================================================
void  
CMSVADHW::SetMixerVolume
(   
    IN  ULONG                   ulNode,
    IN  LONG                    lChannel,
    IN  LONG                    lVolume
)
/*++

Routine Description:

  Sets the HW (!) volume for MSVAD.

Arguments:

  ulNode - topology node id

  lChannel - which channel are we setting?

  lVolume - volume level

Return Value:

    void

--*/
{
    if (ulNode < MAX_TOPOLOGY_NODES)
    {
        m_VolumeControls[ulNode] = lVolume;
    }
} // SetMixerVolume
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\savedata.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    savedata.h

Abstract:

    Declaration of MSVAD data saving class. This class supplies services
to save data to disk.


--*/

#ifndef _MSVAD_SAVEDATA_H
#define _MSVAD_SAVEDATA_H

//-----------------------------------------------------------------------------
//  Forward declaration
//-----------------------------------------------------------------------------
class CSaveData;
typedef CSaveData *PCSaveData;


//-----------------------------------------------------------------------------
//  Structs
//-----------------------------------------------------------------------------

// Parameter to workitem.
#include <pshpack1.h>
typedef struct _SAVEWORKER_PARAM {
#ifdef USE_OBSOLETE_FUNCS
    WORK_QUEUE_ITEM  WorkItem;
#else
    PIO_WORKITEM     WorkItem;
#endif
    ULONG            ulFrameNo;
    ULONG            ulDataSize;
    PBYTE            pData;
    PCSaveData       pSaveData;
    KEVENT           EventDone;
} SAVEWORKER_PARAM;
typedef SAVEWORKER_PARAM *PSAVEWORKER_PARAM;
#include <poppack.h>

// wave file header.
#include <pshpack1.h>
typedef struct _OUTPUT_FILE_HEADER
{
    DWORD           dwRiff;
    DWORD           dwFileSize;
    DWORD           dwWave;
    DWORD           dwFormat;
    DWORD           dwFormatLength;
} OUTPUT_FILE_HEADER;
typedef OUTPUT_FILE_HEADER *POUTPUT_FILE_HEADER;

typedef struct _OUTPUT_DATA_HEADER
{
    DWORD           dwData;
    DWORD           dwDataLength;
} OUTPUT_DATA_HEADER;
typedef OUTPUT_DATA_HEADER *POUTPUT_DATA_HEADER;

#include <poppack.h>

//-----------------------------------------------------------------------------
//  Classes
//-----------------------------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////
// CSaveData
//   Saves the wave data to disk.
//

class CSaveData
{
protected:
    UNICODE_STRING              m_FileName;         // DataFile name.
    HANDLE                      m_FileHandle;       // DataFile handle.
    PBYTE                       m_pDataBuffer;      // Data buffer.
    ULONG                       m_ulBufferSize;     // Total buffer size.

    ULONG                       m_ulFramePtr;       // Current Frame.
    ULONG                       m_ulFrameCount;     // Frame count.
    ULONG                       m_ulFrameSize;
    ULONG                       m_ulBufferPtr;      // Pointer in buffer.
    PBOOL                       m_fFrameUsed;       // Frame usage table.
    KSPIN_LOCK                  m_FrameInUseSpinLock; // Spinlock for synch.

    OBJECT_ATTRIBUTES           m_objectAttributes; // Used for opening file.

    OUTPUT_FILE_HEADER          m_FileHeader;
    PWAVEFORMATEX               m_waveFormat;
    OUTPUT_DATA_HEADER          m_DataHeader;
    PLARGE_INTEGER              m_pFilePtr;

    static PDEVICE_OBJECT       m_pDeviceObject;
    static ULONG                m_ulStreamId;
    static PSAVEWORKER_PARAM    m_pWorkItems;

    BOOL                        m_fWriteDisabled;

public:
    CSaveData();
    ~CSaveData();

    static void                 DestroyWorkItems
    (
        void
    );
    void                        Disable
    (
        BOOL                    fDisable
    );
    static PSAVEWORKER_PARAM    GetNewWorkItem
    (
        void
    );
    NTSTATUS                    Initialize
    (
        void
    );
    static NTSTATUS             InitializeWorkItems
    (
        IN  PDEVICE_OBJECT      DeviceObject
    );
    void                        ReadData
    (
        IN  PBYTE               pBuffer,
        IN  ULONG               ulByteCount
    );
    NTSTATUS                    SetDataFormat
    (
        IN  PKSDATAFORMAT       pDataFormat
    );
    void                        WaitAllWorkItems
    (
        void
    );
    void                        WriteData
    (
        IN  PBYTE               pBuffer,
        IN  ULONG               ulByteCount
    );

private:
    NTSTATUS                    FileClose
    (
        void
    );
    NTSTATUS                    FileOpen
    (
        IN  BOOL                fOverWrite
    );
    NTSTATUS                    FileWrite
    (
        IN  PBYTE               pData,
        IN  ULONG               ulDataSize
    );
    NTSTATUS                    FileWriteHeader
    (
        void
    );

    void                        SaveFrame
    (
        IN  ULONG               ulFrameNo,
        IN  ULONG               ulDataSize
    );

    friend void                 SaveFrameWorkerCallback
#ifdef USE_OBSOLETE_FUNCS
    (
        IN  PVOID               Context
    );
#else
    (
     PDEVICE_OBJECT pDeviceObject, 
     IN  PVOID  Context       
    );
#endif
};
typedef CSaveData *PCSaveData;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\savedata.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    savedata.cpp

Abstract:

    Implementation of MSVAD data saving class.

    To save the playback data to disk, this class maintains a circular data
    buffer, associated frame structures and worker items to save frames to
    disk.
    Each frame structure represents a portion of buffer. When that portion
    of frame is full, a workitem is scheduled to save it to disk.



--*/
#include <msvad.h>
#include "savedata.h"
#include <stdio.h>   // This is for using swprintf..

//=============================================================================
// Defines
//=============================================================================
#define RIFF_TAG                    0x46464952;
#define WAVE_TAG                    0x45564157;
#define FMT__TAG                    0x20746D66;
#define DATA_TAG                    0x61746164;

#define DEFAULT_FRAME_COUNT         2
#define DEFAULT_FRAME_SIZE          PAGE_SIZE * 4
#define DEFAULT_BUFFER_SIZE         DEFAULT_FRAME_SIZE * DEFAULT_FRAME_COUNT

#define DEFAULT_FILE_NAME           L"\\DosDevices\\C:\\STREAM"

#define MAX_WORKER_ITEM_COUNT       15

//=============================================================================
// Statics
//=============================================================================
ULONG CSaveData::m_ulStreamId = 0;

#pragma code_seg("PAGE")
//=============================================================================
// CSaveData
//=============================================================================

//=============================================================================
CSaveData::CSaveData()
:   m_pDataBuffer(NULL),
    m_FileHandle(NULL),
    m_ulFrameCount(DEFAULT_FRAME_COUNT),
    m_ulBufferSize(DEFAULT_BUFFER_SIZE),
    m_ulFrameSize(DEFAULT_FRAME_SIZE),
    m_ulBufferPtr(0),
    m_ulFramePtr(0),
    m_fFrameUsed(NULL),
    m_pFilePtr(NULL),
    m_fWriteDisabled(FALSE)
{
    PAGED_CODE();

    m_FileHeader.dwRiff           = RIFF_TAG;
    m_FileHeader.dwFileSize       = 0;
    m_FileHeader.dwWave           = WAVE_TAG;
    m_FileHeader.dwFormat         = FMT__TAG;
    m_FileHeader.dwFormatLength   = sizeof(WAVEFORMATEX);

    m_DataHeader.dwData           = DATA_TAG;
    m_DataHeader.dwDataLength     = 0;

    RtlZeroMemory(&m_objectAttributes, sizeof(m_objectAttributes));

    m_ulStreamId++;
} // CSaveData

//=============================================================================
CSaveData::~CSaveData()
{
    PAGED_CODE();

    LARGE_INTEGER           offset;
    IO_STATUS_BLOCK         ioStatusBlock;

    DPF_ENTER(("[CSaveData::~CSaveData]"));

    // Update the wave header in data file with real file size.
    //
    if (m_pFilePtr)
    {
        m_FileHeader.dwFileSize =
            (DWORD) m_pFilePtr->QuadPart - 2 * sizeof(DWORD);
        m_DataHeader.dwDataLength = (DWORD) m_pFilePtr->QuadPart -
                                     sizeof(m_FileHeader)        -
                                     m_FileHeader.dwFormatLength -
                                     sizeof(m_DataHeader);

        if (NT_SUCCESS(FileOpen(FALSE)))
        {
            FileWriteHeader();

            FileClose();
        }
    }

    //frees the work items

#ifndef USE_OBSOLETE_FUNCS
   for (int i = 0; i < MAX_WORKER_ITEM_COUNT; i++)
   {
    
       if (m_pWorkItems[i].WorkItem!=NULL)
       {
           IoFreeWorkItem(m_pWorkItems[i].WorkItem);
           m_pWorkItems[i].WorkItem = NULL;
       }
   }
#endif

    if (m_waveFormat)
    {
        ExFreePool(m_waveFormat);
    }

    if (m_fFrameUsed)
    {
        ExFreePool(m_fFrameUsed);

        // NOTE : Do not release m_pFilePtr.
    }

    if (m_FileName.Buffer)
    {
        ExFreePool(m_FileName.Buffer);
    }

    if (m_pDataBuffer)
    {
        ExFreePool(m_pDataBuffer);
    }
} // CSaveData

//=============================================================================
void
CSaveData::DestroyWorkItems
(
    void
)
{
    if (m_pWorkItems)
    {
        ExFreePool(m_pWorkItems);
        m_pWorkItems = NULL;
    }

} // DestroyWorkItems

//=============================================================================
void
CSaveData::Disable
(
    BOOL                        fDisable
)
{
    m_fWriteDisabled = fDisable;
} // Disable

//=============================================================================
NTSTATUS
CSaveData::FileClose(void)
{
    PAGED_CODE();

    NTSTATUS                    ntStatus = STATUS_SUCCESS;

    if (m_FileHandle)
    {
        ntStatus = ZwClose(m_FileHandle);
        m_FileHandle = NULL;
    }

    return ntStatus;
} // FileClose

//=============================================================================
NTSTATUS
CSaveData::FileOpen
(
    IN  BOOL                    fOverWrite
)
{
    PAGED_CODE();

    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    IO_STATUS_BLOCK             ioStatusBlock;

    if (!m_FileHandle)
    {
        ntStatus =
            ZwCreateFile
            (
                &m_FileHandle,
                GENERIC_WRITE | SYNCHRONIZE,
                &m_objectAttributes,
                &ioStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,
                fOverWrite ? FILE_OVERWRITE_IF : FILE_OPEN_IF,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
            );
        if (!NT_SUCCESS(ntStatus))
        {
            DPF(D_TERSE, ("[CSaveData::FileOpen : Error opening data file]"));
        }
    }

    return ntStatus;
} // FileOpen

//=============================================================================
NTSTATUS
CSaveData::FileWrite
(
    IN  PBYTE                   pData,
    IN  ULONG                   ulDataSize
)
{
    PAGED_CODE();

    ASSERT(pData);
    ASSERT(m_pFilePtr);

    NTSTATUS                    ntStatus;

    if (m_FileHandle)
    {
        IO_STATUS_BLOCK         ioStatusBlock;

        ntStatus = ZwWriteFile( m_FileHandle,
                                NULL,
                                NULL,
                                NULL,
                                &ioStatusBlock,
                                pData,
                                ulDataSize,
                                m_pFilePtr,
                                NULL);

        if (NT_SUCCESS(ntStatus))
        {
            ASSERT(ioStatusBlock.Information == ulDataSize);

            m_pFilePtr->QuadPart += ulDataSize;
        }
        else
        {
            DPF(D_TERSE, ("[CSaveData::FileWrite : WriteFileError]"));
        }
    }
    else
    {
        DPF(D_TERSE, ("[CSaveData::FileWrite : File not open]"));
        ntStatus = STATUS_INVALID_HANDLE;
    }

    return ntStatus;
} // FileWrite

//=============================================================================
NTSTATUS
CSaveData::FileWriteHeader(void)
{
    PAGED_CODE();

    NTSTATUS                    ntStatus;

    if (m_FileHandle && m_waveFormat)
    {
        IO_STATUS_BLOCK         ioStatusBlock;

        m_pFilePtr->QuadPart = 0;

        m_FileHeader.dwFormatLength = (m_waveFormat->wFormatTag == WAVE_FORMAT_PCM) ?
                                        sizeof( PCMWAVEFORMAT ) :
                                        sizeof( WAVEFORMATEX ) + m_waveFormat->cbSize;

        ntStatus = ZwWriteFile( m_FileHandle,
                                NULL,
                                NULL,
                                NULL,
                                &ioStatusBlock,
                                &m_FileHeader,
                                sizeof(m_FileHeader),
                                m_pFilePtr,
                                NULL);
        if (!NT_SUCCESS(ntStatus))
        {
            DPF(D_TERSE, ("[CSaveData::FileWriteHeader : Write File Header Error]"));
        }

        m_pFilePtr->QuadPart += sizeof(m_FileHeader);

        ntStatus = ZwWriteFile( m_FileHandle,
                                NULL,
                                NULL,
                                NULL,
                                &ioStatusBlock,
                                m_waveFormat,
                                m_FileHeader.dwFormatLength,
                                m_pFilePtr,
                                NULL);
        if (!NT_SUCCESS(ntStatus))
        {
            DPF(D_TERSE, ("[CSaveData::FileWriteHeader : Write Format Error]"));
        }

        m_pFilePtr->QuadPart += m_FileHeader.dwFormatLength;

        ntStatus = ZwWriteFile( m_FileHandle,
                                NULL,
                                NULL,
                                NULL,
                                &ioStatusBlock,
                                &m_DataHeader,
                                sizeof(m_DataHeader),
                                m_pFilePtr,
                                NULL);
        if (!NT_SUCCESS(ntStatus))
        {
            DPF(D_TERSE, ("[CSaveData::FileWriteHeader : Write Data Header Error]"));
        }

        m_pFilePtr->QuadPart += sizeof(m_DataHeader);
    }
    else
    {
        DPF(D_TERSE, ("[CSaveData::FileWriteHeader : File not open]"));
        ntStatus = STATUS_INVALID_HANDLE;
    }

    return ntStatus;
} // FileWriteHeader

#pragma code_seg()
//=============================================================================
PSAVEWORKER_PARAM
CSaveData::GetNewWorkItem
(
    void
)
{
    LARGE_INTEGER               timeOut = { 0 };
    NTSTATUS                    ntStatus;

    for (int i = 0; i < MAX_WORKER_ITEM_COUNT; i++)
    {
        ntStatus =
            KeWaitForSingleObject
            (
                &m_pWorkItems[i].EventDone,
                Executive,
                KernelMode,
                FALSE,
                &timeOut
            );
        if (NT_SUCCESS(ntStatus))
        {
            if (m_pWorkItems[i].WorkItem)
                return &(m_pWorkItems[i]);
            else
                return NULL;
        }
    }

    return NULL;
} // GetNewWorkItem
#pragma code_seg("PAGE")

//=============================================================================
NTSTATUS
CSaveData::Initialize
(
    void
)
{
    PAGED_CODE();

    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    WCHAR                       szTemp[MAX_PATH];

    DPF_ENTER(("[CSaveData::Initialize]"));

    // Allocaet data file name.
    //
    swprintf(szTemp, L"%s_%d.wav", DEFAULT_FILE_NAME, m_ulStreamId);

    m_FileName.Length = 0;
    m_FileName.MaximumLength = (wcslen(szTemp) + 1) * sizeof(WCHAR);
    m_FileName.Buffer = (PWSTR)
        ExAllocatePool
        (
            PagedPool,
            m_FileName.MaximumLength
        );
    if (!m_FileName.Buffer)
    {
        DPF(D_TERSE, ("[Could not allocate memory for FileName]"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    // Allocate memory for data buffer.
    //
    if (NT_SUCCESS(ntStatus))
    {
        wcscpy(m_FileName.Buffer, szTemp);
        m_FileName.Length = wcslen(m_FileName.Buffer) * sizeof(WCHAR);
        DPF(D_BLAB, ("[New DataFile -- %s", m_FileName.Buffer));

        m_pDataBuffer = (PBYTE)
            ExAllocatePoolWithTag
            (
                NonPagedPool,
                m_ulBufferSize,
                MSVAD_POOLTAG
            );
        if (!m_pDataBuffer)
        {
            DPF(D_TERSE, ("[Could not allocate memory for Saving Data]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // Allocate memory for frame usage flags and m_pFilePtr.
    //
    if (NT_SUCCESS(ntStatus))
    {
        m_fFrameUsed = (PBOOL)
            ExAllocatePoolWithTag
            (
                NonPagedPool,
                m_ulFrameCount * sizeof(BOOL) +
                sizeof(LARGE_INTEGER),
                MSVAD_POOLTAG
            );
        if (!m_fFrameUsed)
        {
            DPF(D_TERSE, ("[Could not allocate memory for frame flags]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // Initialize the spinlock to synchronize access to the frames
    //
    KeInitializeSpinLock ( &m_FrameInUseSpinLock ) ;

    // Open the data file.
    //
    if (NT_SUCCESS(ntStatus))
    {
        // m_fFrameUsed has additional memory to hold m_pFilePtr
        //
        m_pFilePtr = (PLARGE_INTEGER)
            (((PBYTE) m_fFrameUsed) + m_ulFrameCount * sizeof(BOOL));
        RtlZeroMemory(m_fFrameUsed, m_ulFrameCount * sizeof(BOOL));

        // Create data file.
        InitializeObjectAttributes
        (
            &m_objectAttributes,
            &m_FileName,
            OBJ_CASE_INSENSITIVE|OBJ_KERNEL_HANDLE,
            NULL,
            NULL
        );

        // Write wave header information to data file.
        ntStatus = FileOpen(TRUE);
        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = FileWriteHeader();

            FileClose();
        }
    }

    return ntStatus;
} // Initialize

//=============================================================================
NTSTATUS
CSaveData::InitializeWorkItems
(
    IN  PDEVICE_OBJECT          DeviceObject
)
{
    PAGED_CODE();

    ASSERT(DeviceObject);

    NTSTATUS                    ntStatus = STATUS_SUCCESS;

    DPF_ENTER(("[CSaveData::InitializeWorkItems]"));

    m_pDeviceObject = DeviceObject;

    m_pWorkItems = (PSAVEWORKER_PARAM)
        ExAllocatePoolWithTag
        (
            NonPagedPool,
            sizeof(SAVEWORKER_PARAM) * MAX_WORKER_ITEM_COUNT,
            MSVAD_POOLTAG
        );
    if (m_pWorkItems)
    {
        for (int i = 0; i < MAX_WORKER_ITEM_COUNT; i++)
        {

#ifdef USE_OBSOLETE_FUNCS
            ExInitializeWorkItem
            (
                &m_pWorkItems[i].WorkItem,
                SaveFrameWorkerCallback,
                &m_pWorkItems[i]
            );
#else
            m_pWorkItems[i].WorkItem = IoAllocateWorkItem(DeviceObject);
            if(m_pWorkItems[i].WorkItem == NULL)
            {
              return STATUS_INSUFFICIENT_RESOURCES;
            }
#endif
            KeInitializeEvent
            (
                &m_pWorkItems[i].EventDone,
                NotificationEvent,
                TRUE
            );
        }
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
} // InitializeWorkItems

//=============================================================================

void
SaveFrameWorkerCallback
#ifdef USE_OBSOLETE_FUNCS
(
    IN  PVOID                   Context
)
#else
(
    PDEVICE_OBJECT pDeviceObject, IN  PVOID  Context
)
#endif
{
    PAGED_CODE();

    ASSERT(Context);

    PSAVEWORKER_PARAM           pParam = (PSAVEWORKER_PARAM) Context;
    PCSaveData                  pSaveData;
    IO_STATUS_BLOCK             ioStatusBlock;

    DPF(D_VERBOSE, ("[SaveFrameWorkerCallback], %d", pParam->ulFrameNo));

    ASSERT(pParam->pSaveData);
    ASSERT(pParam->pSaveData->m_fFrameUsed);

    if (pParam->WorkItem)
    {
     pSaveData = pParam->pSaveData;

     if (NT_SUCCESS(pSaveData->FileOpen(FALSE)))
     { 
         pSaveData->FileWrite(pParam->pData, pParam->ulDataSize);
         pSaveData->FileClose();
      }
      InterlockedExchange( (LONG *)&(pSaveData->m_fFrameUsed[pParam->ulFrameNo]), FALSE );
    }

    KeSetEvent(&pParam->EventDone, 0, FALSE);
} // SaveFrameWorkerCallback

//=============================================================================
NTSTATUS
CSaveData::SetDataFormat
(
    IN PKSDATAFORMAT            pDataFormat
)
{
    PAGED_CODE();
    NTSTATUS                    ntStatus = STATUS_SUCCESS;
 
    DPF_ENTER(("[CSaveData::SetDataFormat]"));

    ASSERT(pDataFormat);

    PWAVEFORMATEX pwfx = NULL;

    if (IsEqualGUIDAligned(pDataFormat->Specifier,
        KSDATAFORMAT_SPECIFIER_DSOUND))
    {
        pwfx =
            &(((PKSDATAFORMAT_DSOUND) pDataFormat)->BufferDesc.WaveFormatEx);
    }
    else if (IsEqualGUIDAligned(pDataFormat->Specifier,
        KSDATAFORMAT_SPECIFIER_WAVEFORMATEX))
    {
        pwfx = &((PKSDATAFORMAT_WAVEFORMATEX) pDataFormat)->WaveFormatEx;
    }

    if (pwfx)
    {
        // Free the previously allocated waveformat
        if (m_waveFormat)
        {
            ExFreePool(m_waveFormat);
        }

        m_waveFormat = (PWAVEFORMATEX)
            ExAllocatePoolWithTag
            (
                NonPagedPool,
                (pwfx->wFormatTag == WAVE_FORMAT_PCM) ?
                sizeof( PCMWAVEFORMAT ) :
                sizeof( WAVEFORMATEX ) + pwfx->cbSize,
                MSVAD_POOLTAG
            );

        if(m_waveFormat)
        {
            RtlCopyMemory( m_waveFormat,
                           pwfx,
                           (pwfx->wFormatTag == WAVE_FORMAT_PCM) ?
                           sizeof( PCMWAVEFORMAT ) :
                           sizeof( WAVEFORMATEX ) + pwfx->cbSize);
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return ntStatus;
} // SetDataFormat

//=============================================================================
void
CSaveData::ReadData
(
    IN PBYTE                    pBuffer,
    IN ULONG                    ulByteCount
)
{
    // Not implemented yet.
} // ReadData

//=============================================================================
#pragma code_seg()
void
CSaveData::SaveFrame
(
    IN ULONG                    ulFrameNo,
    IN ULONG                    ulDataSize
)
{
    PSAVEWORKER_PARAM           pParam = NULL;

    DPF_ENTER(("[CSaveData::SaveFrame]"));

    pParam = GetNewWorkItem();
    if (pParam)
    {
        pParam->pSaveData = this;
        pParam->ulFrameNo = ulFrameNo;
        pParam->ulDataSize = ulDataSize;
        pParam->pData = m_pDataBuffer + ulFrameNo * m_ulFrameSize;
        KeResetEvent(&pParam->EventDone);

#ifdef USE_OBSOLETE_FUNCS
        ExQueueWorkItem(&pParam->WorkItem, CriticalWorkQueue);
#else
        IoQueueWorkItem(pParam->WorkItem, (PIO_WORKITEM_ROUTINE)SaveFrameWorkerCallback,
                        CriticalWorkQueue, (PVOID)pParam);
#endif
    }
} // SaveFrame
#pragma code_seg("PAGE")
//=============================================================================
void
CSaveData::WaitAllWorkItems
(
    void
)
{
    DPF_ENTER(("[CSaveData::WaitAllWorkItems]"));

    // Save the last partially-filled frame
    SaveFrame(m_ulFramePtr, m_ulBufferPtr - (m_ulFramePtr * m_ulFrameSize));

    for (int i = 0; i < MAX_WORKER_ITEM_COUNT; i++)
    {
        DPF(D_VERBOSE, ("[Waiting for WorkItem] %d", i));
        KeWaitForSingleObject
        (
            &(m_pWorkItems[i].EventDone),
            Executive,
            KernelMode,
            FALSE,
            NULL
        );
    }
} // WaitAllWorkItems

#pragma code_seg()
//=============================================================================
void
CSaveData::WriteData
(
    IN  PBYTE                   pBuffer,
    IN  ULONG                   ulByteCount
)
{
    ASSERT(pBuffer);
    ASSERT(ulByteCount);

    BOOL                        fSaveFrame = FALSE;
    ULONG                       ulSaveFramePtr;
    KIRQL                       OldIrql;
    LARGE_INTEGER               timeOut = { 0 };

    // If stream writing is disabled, then exit.
    //
    if (m_fWriteDisabled)
    {
        return;
    }

    DPF_ENTER(("[CSaveData::WriteData ulByteCount=%lu]", ulByteCount));

    // Check to see if this frame is available.
    KeAcquireSpinLockAtDpcLevel( &m_FrameInUseSpinLock );
    if (!m_fFrameUsed[m_ulFramePtr])
    {
        KeReleaseSpinLockFromDpcLevel( &m_FrameInUseSpinLock );

        ULONG ulWriteBytes =
            (ulByteCount + m_ulBufferPtr < m_ulBufferSize) ?
            ulByteCount :
            (m_ulBufferSize - m_ulBufferPtr);

        RtlCopyMemory(m_pDataBuffer + m_ulBufferPtr, pBuffer, ulWriteBytes);
        m_ulBufferPtr += ulWriteBytes;

        // Check to see if we need to save this frame
        if (m_ulBufferPtr >= ((m_ulFramePtr + 1) * m_ulFrameSize))
        {
            fSaveFrame = TRUE;
        }

        // Loop the buffer, if we reached the end.
        if (m_ulBufferPtr == m_ulBufferSize)
        {
            fSaveFrame = TRUE;
            m_ulBufferPtr = 0;
        }

        if (fSaveFrame)
        {
            InterlockedExchange( (LONG *)&(m_fFrameUsed[m_ulFramePtr]), TRUE );
            ulSaveFramePtr = m_ulFramePtr;
            m_ulFramePtr = (m_ulFramePtr + 1) % m_ulFrameCount;
        }

        // Write the left over if the next frame is available.
        if (ulWriteBytes != ulByteCount)
        {
            KeAcquireSpinLockAtDpcLevel( &m_FrameInUseSpinLock );
            if (!m_fFrameUsed[m_ulFramePtr])
            {
                KeReleaseSpinLockFromDpcLevel( &m_FrameInUseSpinLock );
                RtlCopyMemory
                (
                    m_pDataBuffer + m_ulBufferPtr,
                    pBuffer,
                    ulWriteBytes
                );
            }
            else
            {
                KeReleaseSpinLockFromDpcLevel( &m_FrameInUseSpinLock );
                DPF(D_BLAB, ("[Frame overflow, next frame is in use]"));
            }
        }

        if (fSaveFrame)
        {
            SaveFrame(ulSaveFramePtr, m_ulFrameSize);
        }
    }
    else
    {
        KeReleaseSpinLockFromDpcLevel( &m_FrameInUseSpinLock );
        DPF(D_BLAB, ("[Frame %d is in use]", m_ulFramePtr));
    }

} // WriteData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ac3\ac3.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    ac3.h

Abstract:

    Node and Pin numbers for ac3 sample.

--*/

#ifndef _MSVAD_AC3_H_
#define _MSVAD_AC3_H_

// Pin properties.
#define MAX_OUTPUT_STREAMS          1       // Number of capture streams.
#define MAX_INPUT_STREAMS           1       // Number of render streams.
#define MAX_TOTAL_STREAMS           MAX_OUTPUT_STREAMS + MAX_INPUT_STREAMS                      
#define MAX_AC3_INPUT_STREAMS       1       // Number of AC3 render streams.


// PCM Info
#define MIN_CHANNELS                1       // Min Channels.
#define MAX_CHANNELS_PCM            2       // Max Channels.
#define MIN_BITS_PER_SAMPLE_PCM     8       // Min Bits Per Sample
#define MAX_BITS_PER_SAMPLE_PCM     16      // Max Bits Per Sample
#define MIN_SAMPLE_RATE             4000    // Min Sample Rate
#define MAX_SAMPLE_RATE             64000   // Max Sample Rate

// AC3 Info
#define MAX_CHANNELS_AC3            2
#define MIN_BITS_PER_SAMPLE_AC3     16
#define MAX_BITS_PER_SAMPLE_AC3     16
#define MIN_SAMPLE_RATE_AC3         48000
#define MAX_SAMPLE_RATE_AC3         48000

// Wave pins
enum 
{
    KSPIN_WAVE_CAPTURE_SINK = 0,
    KSPIN_WAVE_CAPTURE_SOURCE,
    KSPIN_WAVE_RENDER_SINK, 
    KSPIN_WAVE_RENDER_SOURCE,
    KSPIN_WAVE_AC3_RENDER_SINK,
    KSPIN_WAVE_AC3_RENDER_SOURCE
};

// Wave Topology nodes.
enum 
{
    KSNODE_WAVE_ADC = 0,
    KSNODE_WAVE_DAC
};

// topology pins.
enum
{
    KSPIN_TOPO_WAVEOUT_SOURCE = 0,
    KSPIN_TOPO_SYNTHOUT_SOURCE,
    KSPIN_TOPO_SYNTHIN_SOURCE,
    KSPIN_TOPO_MIC_SOURCE,
    KSPIN_TOPO_LINEOUT_DEST,
    KSPIN_TOPO_WAVEIN_DEST
};

// topology nodes.
enum
{
    KSNODE_TOPO_WAVEOUT_VOLUME = 0,
    KSNODE_TOPO_WAVEOUT_MUTE,
    KSNODE_TOPO_SYNTHOUT_VOLUME,
    KSNODE_TOPO_SYNTHOUT_MUTE,
    KSNODE_TOPO_MIC_VOLUME,
    KSNODE_TOPO_SYNTHIN_VOLUME,
    KSNODE_TOPO_LINEOUT_MIX,
    KSNODE_TOPO_LINEOUT_VOLUME,
    KSNODE_TOPO_WAVEIN_MUX
};

// Misc functions.
inline BOOL IsFormatAc3(IN PKSDATAFORMAT pDataFormat)
{
    return 
        (WAVE_FORMAT_DOLBY_AC3_SPDIF == 
         EXTRACT_WAVEFORMATEX_ID(&pDataFormat->SubFormat));
} // IsFormatAc3


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ac3\minwave.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.h

Abstract:

    Definition of wavecyclic miniport class.

--*/

#ifndef _MSVAD_MINWAVE_H_
#define _MSVAD_MINWAVE_H_

#include "basewave.h"

//=============================================================================
// Referenced Forward
//=============================================================================
class CMiniportWaveCyclicStream;
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

//=============================================================================
// Classes
//=============================================================================
///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclic 
//   

class CMiniportWaveCyclic : 
    public CMiniportWaveCyclicMSVAD,
    public IMiniportWaveCyclic,
    public CUnknown
{
private:
    BOOL                        m_fCaptureAllocated;
    BOOL                        m_fPcmRenderAllocated;
    BOOL                        m_fAc3RenderAllocated;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclic);
    ~CMiniportWaveCyclic();

    IMP_IMiniportWaveCyclic;

protected:
    NTSTATUS                    ValidateFormat
    (
        IN  PKSDATAFORMAT       pDataFormat 
    );

    // Friends
    friend class                CMiniportWaveCyclicStream;
    friend class                CMiniportTopologySimple;
};
typedef CMiniportWaveCyclic *PCMiniportWaveCyclic;

///////////////////////////////////////////////////////////////////////////////
// CMiniportWaveCyclicStream 
//   

class CMiniportWaveCyclicStream : 
    public CMiniportWaveCyclicStreamMSVAD,
    public CUnknown
{
protected:
    PCMiniportWaveCyclic        m_pMiniportLocal;
    BOOL                        m_fFormatAc3;

public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportWaveCyclicStream);
    ~CMiniportWaveCyclicStream();

    NTSTATUS                    Init
    ( 
        IN  PCMiniportWaveCyclic Miniport,
        IN  ULONG               Channel,
        IN  BOOLEAN             Capture,
        IN  PKSDATAFORMAT       DataFormat
    );

    // Friends
    friend class                CMiniportWaveCyclic;
};
typedef CMiniportWaveCyclicStream *PCMiniportWaveCyclicStream;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ac3\mintopo.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minitopo.h

Abstract:

    Declaration of topology miniport.

--*/

#ifndef _MSVAD_MINTOPO_H_
#define _MSVAD_MINTOPO_H_

#include "basetopo.h"

//=============================================================================
// Classes
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// CMiniportTopology 
//   

class CMiniportTopology : 
    public CMiniportTopologyMSVAD,
    public IMiniportTopology,
    public CUnknown
{
  public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportTopology);
    ~CMiniportTopology();

    IMP_IMiniportTopology;
};
typedef CMiniportTopology *PCMiniportTopology;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\sources.inc ===
# Copyright (c) 1995-2000 Microsoft Corporation.  All rights reserved.

TARGETTYPE=DRIVER
TARGETPATH=obj

TARGETLIBS= \
        $(DDK_LIB_PATH)\portcls.lib\
        $(DDK_LIB_PATH)\stdunk.lib

INCLUDES= \
          $(DDK_INC_PATH); \
          ..

MSC_WARNING_LEVEL=-W3 -WX

C_DEFINES= $(C_DEFINES) -D_WIN32 -DUNICODE -D_UNICODE -DPC_IMPLEMENTATION

#
# Different levels of debug printage.  First is nothing but
# catastrophic errors, last is everything under the sun.
#
#C_DEFINES= $(C_DEFINES) -DDEBUG_LEVEL=DEBUGLVL_ERROR
C_DEFINES= $(C_DEFINES) -DDEBUG_LEVEL=DEBUGLVL_TERSE
#C_DEFINES= $(C_DEFINES) -DDEBUG_LEVEL=DEBUGLVL_VERBOSE
#C_DEFINES= $(C_DEFINES) -DDEBUG_LEVEL=DEBUGLVL_BLAB

LINKER_FLAGS=-map

SOURCES=\
        adapter.cpp     \
        basedma.cpp     \
        basetopo.cpp    \
        basewave.cpp    \
        common.cpp      \
        hw.cpp          \
        kshelper.cpp    \
        savedata.cpp    \
        msvad.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ac3\minwave.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minwave.cpp

Abstract:

    Implementation of wavecyclic miniport.

--*/

#include <msvad.h>
#include <common.h>
#include "ac3.h"
#include "minwave.h"
#include "wavtable.h"

#pragma code_seg("PAGE")

//=============================================================================
// CMiniportWaveCyclic
//=============================================================================

//=============================================================================
NTSTATUS
CreateMiniportWaveCyclicMSVAD
( 
    OUT PUNKNOWN *              Unknown,
    IN  REFCLSID,
    IN  PUNKNOWN                UnknownOuter OPTIONAL,
    IN  POOL_TYPE               PoolType 
)
/*++

Routine Description:

  Create the wavecyclic miniport.

Arguments:

  Unknown - 

  RefClsId -

  UnknownOuter -

  PoolType -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Unknown);

    STD_CREATE_BODY(CMiniportWaveCyclic, Unknown, UnknownOuter, PoolType);
}

//=============================================================================
CMiniportWaveCyclic::~CMiniportWaveCyclic
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclic miniport

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclic::~CMiniportWaveCyclic]"));
} // ~CMiniportWaveCyclic


//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::DataRangeIntersection
( 
    IN  ULONG                       PinId,
    IN  PKSDATARANGE                ClientDataRange,
    IN  PKSDATARANGE                MyDataRange,
    IN  ULONG                       OutputBufferLength,
    OUT PVOID                       ResultantFormat,
    OUT PULONG                      ResultantFormatLength 
)
/*++

Routine Description:

  The DataRangeIntersection function determines the highest quality 
  intersection of two data ranges.

Arguments:

  PinId -           Pin for which data intersection is being determined. 

  ClientDataRange - Pointer to KSDATARANGE structure which contains the data 
                    range submitted by client in the data range intersection 
                    property request. 

  MyDataRange -         Pin's data range to be compared with client's data 
                        range. In this case we actually ignore our own data 
                        range, because we know that we only support one range.

  OutputBufferLength -  Size of the buffer pointed to by the resultant format 
                        parameter. 

  ResultantFormat -     Pointer to value where the resultant format should be 
                        returned. 

  ResultantFormatLength -   Actual length of the resultant format placed in 
                            ResultantFormat. This should be less than or equal 
                            to OutputBufferLength. 

  Return Value:

    NT status code.

--*/
{
    PAGED_CODE();

    // For all other pins, let PortCls handle the request (PCM only).
    //
    if (KSPIN_WAVE_AC3_RENDER_SINK != PinId)
    {
        return STATUS_NOT_IMPLEMENTED;
    }

    // The client's DataRange should be AC3.
    // Otherwise, there is no intersection.
    //
    if (!IsEqualGUIDAligned(ClientDataRange->MajorFormat, 
            KSDATAFORMAT_TYPE_AUDIO) &&
        !IsEqualGUIDAligned(ClientDataRange->MajorFormat, 
            KSDATAFORMAT_TYPE_WILDCARD))
    {
        return STATUS_NO_MATCH;
    }

    if (!IsEqualGUIDAligned(ClientDataRange->SubFormat,
            KSDATAFORMAT_SUBTYPE_DOLBY_AC3_SPDIF) &&
        !IsEqualGUIDAligned(ClientDataRange->SubFormat,
            KSDATAFORMAT_SUBTYPE_WILDCARD))
    {
        return STATUS_NO_MATCH;
    }

    if (IsEqualGUIDAligned(ClientDataRange->Specifier, 
            KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) ||
        IsEqualGUIDAligned(ClientDataRange->Specifier,
            KSDATAFORMAT_SPECIFIER_WILDCARD))
    {
        *ResultantFormatLength = sizeof(KSDATAFORMAT_WAVEFORMATEX);
    }
    else if (IsEqualGUIDAligned(ClientDataRange->Specifier, 
        KSDATAFORMAT_SPECIFIER_DSOUND))
    {
        *ResultantFormatLength = sizeof(KSDATAFORMAT_DSOUND);
    }
    else
    {
        return STATUS_NO_MATCH;
    }

    // Validate return buffer size, if the request is only for the
    // size of the resultant structure, return it now.
    //
    if (!OutputBufferLength) 
    {
        *ResultantFormatLength = sizeof(KSDATAFORMAT_WAVEFORMATEX);
        return STATUS_BUFFER_OVERFLOW;
    } 
    else if (OutputBufferLength < sizeof(KSDATAFORMAT_WAVEFORMATEX)) 
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    PKSDATAFORMAT_WAVEFORMATEX  resultantFormatWFX;
    PWAVEFORMATEX               pWaveFormatEx;

    resultantFormatWFX = (PKSDATAFORMAT_WAVEFORMATEX) ResultantFormat;

    // Return the best (only) available format.
    //
    resultantFormatWFX->DataFormat.FormatSize   = *ResultantFormatLength;
    resultantFormatWFX->DataFormat.Flags        = 0;
    resultantFormatWFX->DataFormat.SampleSize   = 4; // must match nBlockAlign
    resultantFormatWFX->DataFormat.Reserved     = 0;

    resultantFormatWFX->DataFormat.MajorFormat  = KSDATAFORMAT_TYPE_AUDIO;
    INIT_WAVEFORMATEX_GUID(&resultantFormatWFX->DataFormat.SubFormat,
        WAVE_FORMAT_DOLBY_AC3_SPDIF );

    // Extra space for the DSound specifier
    //
    if (IsEqualGUIDAligned(ClientDataRange->Specifier,
            KSDATAFORMAT_SPECIFIER_DSOUND))
    {
        PKSDATAFORMAT_DSOUND        resultantFormatDSound;
        resultantFormatDSound = (PKSDATAFORMAT_DSOUND)    ResultantFormat;

        resultantFormatDSound->DataFormat.Specifier = 
            KSDATAFORMAT_SPECIFIER_DSOUND;

        // DSound format capabilities are not expressed 
        // this way in KS, so we express no capabilities. 
        //
        resultantFormatDSound->BufferDesc.Flags = 0 ;
        resultantFormatDSound->BufferDesc.Control = 0 ;

        pWaveFormatEx = &resultantFormatDSound->BufferDesc.WaveFormatEx;
    }
    else  // WAVEFORMATEX or WILDCARD (WAVEFORMATEX)
    {
        resultantFormatWFX->DataFormat.Specifier = 
            KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

        pWaveFormatEx = (PWAVEFORMATEX)((PKSDATAFORMAT)resultantFormatWFX + 1);
    }

    pWaveFormatEx->wFormatTag      = WAVE_FORMAT_DOLBY_AC3_SPDIF;     
    pWaveFormatEx->nChannels       = 2;
    pWaveFormatEx->nSamplesPerSec  = 48000;
    pWaveFormatEx->wBitsPerSample  = 16;
    pWaveFormatEx->cbSize          = 0;
    pWaveFormatEx->nBlockAlign     = 
        pWaveFormatEx->nChannels * pWaveFormatEx->wBitsPerSample / 8;
    pWaveFormatEx->nAvgBytesPerSec = 
        pWaveFormatEx->nSamplesPerSec * pWaveFormatEx->nBlockAlign;

    return STATUS_SUCCESS;
} // DataRangeIntersection

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::GetDescription
( 
    OUT PPCFILTER_DESCRIPTOR * OutFilterDescriptor 
)
/*++

Routine Description:

  The GetDescription function gets a pointer to a filter description. 
  It provides a location to deposit a pointer in miniport's description 
  structure. This is the placeholder for the FromNode or ToNode fields in 
  connections which describe connections to the filter's pins. 

Arguments:

  OutFilterDescriptor - Pointer to the filter description. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutFilterDescriptor);

    return 
        CMiniportWaveCyclicMSVAD::GetDescription(OutFilterDescriptor);
} // GetDescription

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::Init
( 
    IN  PUNKNOWN                UnknownAdapter_,
    IN  PRESOURCELIST           ResourceList_,
    IN  PPORTWAVECYCLIC         Port_ 
)
/*++

Routine Description:

  The Init function initializes the miniport. Callers of this function 
  should run at IRQL PASSIVE_LEVEL

Arguments:

  UnknownAdapter - A pointer to the Iuknown interface of the adapter object. 

  ResourceList - Pointer to the resource list to be supplied to the miniport 
                 during initialization. The port driver is free to examine the 
                 contents of the ResourceList. The port driver will not be 
                 modify the ResourceList contents. 

  Port - Pointer to the topology port object that is linked with this miniport. 

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(UnknownAdapter_);
    ASSERT(Port_);

    NTSTATUS                    ntStatus;

    DPF_ENTER(("[CMiniportWaveCyclic::Init]"));

    m_MaxOutputStreams      = MAX_OUTPUT_STREAMS;
    m_MaxInputStreams       = MAX_INPUT_STREAMS;
    m_MaxTotalStreams       = MAX_TOTAL_STREAMS;

    m_MinChannels           = MIN_CHANNELS;
    m_MaxChannelsPcm        = MAX_CHANNELS_PCM;

    m_MinBitsPerSamplePcm   = MIN_BITS_PER_SAMPLE_PCM;
    m_MaxBitsPerSamplePcm   = MAX_BITS_PER_SAMPLE_PCM;
    m_MinSampleRatePcm      = MIN_SAMPLE_RATE;
    m_MaxSampleRatePcm      = MAX_SAMPLE_RATE;
    
    ntStatus =
        CMiniportWaveCyclicMSVAD::Init
        (
            UnknownAdapter_,
            ResourceList_,
            Port_
        );
    if (NT_SUCCESS(ntStatus))
    {
        // Set filter descriptor.
        m_FilterDescriptor = &MiniportFilterDescriptor;

        m_fCaptureAllocated     = FALSE;
        m_fPcmRenderAllocated   = FALSE;
        m_fAc3RenderAllocated   = FALSE;
    }

    return ntStatus;
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NewStream
( 
    OUT PMINIPORTWAVECYCLICSTREAM * OutStream,
    IN  PUNKNOWN                OuterUnknown,
    IN  POOL_TYPE               PoolType,
    IN  ULONG                   Pin,
    IN  BOOLEAN                 Capture,
    IN  PKSDATAFORMAT           DataFormat,
    OUT PDMACHANNEL *           OutDmaChannel,
    OUT PSERVICEGROUP *         OutServiceGroup 
)
/*++

Routine Description:

  The NewStream function creates a new instance of a logical stream 
  associated with a specified physical channel. Callers of NewStream should 
  run at IRQL PASSIVE_LEVEL.

Arguments:

  OutStream -

  OuterUnknown -

  PoolType - 

  Pin - 

  Capture - 

  DataFormat -

  OutDmaChannel -

  OutServiceGroup -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(OutStream);
    ASSERT(DataFormat);
    ASSERT(OutDmaChannel);
    ASSERT(OutServiceGroup);

    DPF_ENTER(("[CMiniportWaveCyclic::NewStream]"));

    NTSTATUS                    ntStatus = STATUS_SUCCESS;
    PCMiniportWaveCyclicStream  stream = NULL;

    // Determine if the format is valid.
    //
    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = ValidateFormat(DataFormat);
    }

    // Check if we have enough streams.
    if (Capture)
    {
        if (m_fCaptureAllocated)
        {
            DPF(D_TERSE, ("[Only one capture stream supported]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        if (m_fAc3RenderAllocated && IsFormatAc3(DataFormat))
        {
            DPF(D_TERSE, ("[Only one Ac3 render stream supported]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (m_fPcmRenderAllocated && !IsFormatAc3(DataFormat))
        {
            DPF(D_TERSE, ("[Only one Pcm render stream supported]"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // Instantiate a stream. Stream must be in
    // NonPagedPool because of file saving.
    //
    if (NT_SUCCESS(ntStatus))
    {
        stream = new (NonPagedPool, MSVAD_POOLTAG) 
            CMiniportWaveCyclicStream(OuterUnknown);

        if (stream)
        {
            stream->AddRef();

            ntStatus = 
                stream->Init
                ( 
                    this,
                    Pin,
                    Capture,
                    DataFormat
                );
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        if (Capture)
        {
            m_fCaptureAllocated = TRUE;
        }
        else
        {
            if (IsFormatAc3(DataFormat)) 
            {
                m_fAc3RenderAllocated = TRUE;
            }
            else
            {
                m_fPcmRenderAllocated = TRUE;
            }
        }

        *OutStream = PMINIPORTWAVECYCLICSTREAM(stream);
        (*OutStream)->AddRef();
        
        *OutDmaChannel = PDMACHANNEL(stream);
        (*OutDmaChannel)->AddRef();

        *OutServiceGroup = m_ServiceGroup;
        (*OutServiceGroup)->AddRef();

        // The stream, the DMA channel, and the service group have
        // references now for the caller.  The caller expects these
        // references to be there.
    }

    // This is our private reference to the stream.  The caller has
    // its own, so we can release in any case.
    //
    if (stream)
    {
        stream->Release();
    }
    
    return ntStatus;
} // NewStream

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclic::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLIC(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclic))
    {
        *Object = PVOID(PMINIPORTWAVECYCLIC(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        // We reference the interface for the caller.

        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface

//=============================================================================
NTSTATUS                    
CMiniportWaveCyclic::ValidateFormat
(
    IN  PKSDATAFORMAT       pDataFormat 
)
/*++

Routine Description:

  Validates that the given dataformat is valid. This overwrites BaseWave's
  ValidateFormat and includes checks for AC3 format.

Arguments:

  pDataFormat - The dataformat for validation.

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclic::ValidateFormat]"));

    NTSTATUS                    ntStatus;

    ntStatus = CMiniportWaveCyclicMSVAD::ValidateFormat(pDataFormat);
    if (!NT_SUCCESS(ntStatus))
    {
        PWAVEFORMATEX               pwfx;

        pwfx = GetWaveFormatEx(pDataFormat);
        if (pwfx)
        {
            if (IS_VALID_WAVEFORMATEX_GUID(&pDataFormat->SubFormat))
            {
                USHORT wfxID = EXTRACT_WAVEFORMATEX_ID(&pDataFormat->SubFormat);

                switch (wfxID)
                {
                    case WAVE_FORMAT_DOLBY_AC3_SPDIF:
                    {
                        if
                        (
            (pDataFormat->FormatSize == sizeof(KSDATAFORMAT_WAVEFORMATEX)) &&
            (pwfx->cbSize == 0)                              &&
            (pwfx->nChannels <= MAX_CHANNELS_AC3 )           &&
            (pwfx->wBitsPerSample >= MIN_BITS_PER_SAMPLE_AC3)&&
            (pwfx->wBitsPerSample <= MAX_BITS_PER_SAMPLE_AC3)&&
            (pwfx->nSamplesPerSec >= MIN_SAMPLE_RATE_AC3)    &&
            (pwfx->nSamplesPerSec <= MAX_SAMPLE_RATE_AC3)
                        )
                        {
                            ntStatus = STATUS_SUCCESS;
                        }
                        else
                        {
            DPF(D_TERSE, ("Invalid WAVE_FORMAT_DOLBY_AC3_SPDIF format"));
                        }
                        break;
                    }
                }
            }
            else
            {
                DPF(D_TERSE, ("Invalid pDataFormat->SubFormat!") );
            }
        }
    }

    return ntStatus;
} // ValidateFormat


//=============================================================================
// CMiniportWaveStreamCyclicSimple
//=============================================================================

//=============================================================================
CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream
( 
    void 
)
/*++

Routine Description:

  Destructor for wavecyclicstream 

Arguments:

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    DPF_ENTER(("[CMiniportWaveCyclicStream::~CMiniportWaveCyclicStream]"));

    if (NULL != m_pMiniportLocal)
    {
        if (m_fCapture)
        {
            m_pMiniportLocal->m_fCaptureAllocated = FALSE;
        }
        else
        {
            if (m_fFormatAc3)
            {
                m_pMiniportLocal->m_fAc3RenderAllocated = FALSE;
            }
            else
            {
                m_pMiniportLocal->m_fPcmRenderAllocated = FALSE;
            }
        }
    }
} // ~CMiniportWaveCyclicStream

//=============================================================================
NTSTATUS
CMiniportWaveCyclicStream::Init
( 
    IN PCMiniportWaveCyclic         Miniport_,
    IN ULONG                        Pin_,
    IN BOOLEAN                      Capture_,
    IN PKSDATAFORMAT                DataFormat_
)
/*++

Routine Description:

  Initializes the stream object. Allocate a DMA buffer, timer and DPC

Arguments:

  Miniport_ -

  Pin_ -

  Capture_ -

  DataFormat -

  DmaChannel_ -

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    m_pMiniportLocal = Miniport_;
    m_fFormatAc3 = IsFormatAc3(DataFormat_);

    return 
        CMiniportWaveCyclicStreamMSVAD::Init
        (
            Miniport_,
            Pin_,
            Capture_,
            DataFormat_
        );
} // Init

//=============================================================================
STDMETHODIMP_(NTSTATUS)
CMiniportWaveCyclicStream::NonDelegatingQueryInterface
( 
    IN  REFIID  Interface,
    OUT PVOID * Object 
)
/*++

Routine Description:

  QueryInterface

Arguments:

  Interface - GUID

  Object - interface pointer to be returned

Return Value:

  NT status code.

--*/
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(PMINIPORTWAVECYCLICSTREAM(this)));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportWaveCyclicStream))
    {
        *Object = PVOID(PMINIPORTWAVECYCLICSTREAM(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IDmaChannel))
    {
        *Object = PVOID(PDMACHANNEL(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
} // NonDelegatingQueryInterface
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ac3\wavtable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    wavtable.h

Abstract:

    Declaration of wave miniport tables.

--*/

#ifndef _MSVAD_WAVTABLE_H_
#define _MSVAD_WAVTABLE_H_

//=============================================================================
// Defines
//=============================================================================

#define STATIC_KSDATAFORMAT_SUBTYPE_DOLBY_AC3_SPDIF\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_DOLBY_AC3_SPDIF)
DEFINE_GUIDSTRUCT("00000092-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_DOLBY_AC3_SPDIF);
#define KSDATAFORMAT_SUBTYPE_DOLBY_AC3_SPDIF DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DOLBY_AC3_SPDIF)


//=============================================================================
static
KSDATARANGE_AUDIO PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        MAX_CHANNELS_PCM,           
        MIN_BITS_PER_SAMPLE_PCM,    
        MAX_BITS_PER_SAMPLE_PCM,    
        MIN_SAMPLE_RATE,            
        MAX_SAMPLE_RATE             
    },
    // For AC3 support, add a new datarange. 
    //
    {
        {
            sizeof(KSDATARANGE_AUDIO),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_DOLBY_AC3_SPDIF),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
        },
        MAX_CHANNELS_AC3,           
        MIN_BITS_PER_SAMPLE_AC3,    
        MAX_BITS_PER_SAMPLE_AC3,    
        MIN_SAMPLE_RATE_AC3,
        MAX_SAMPLE_RATE_AC3
    }
};

static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

static
PKSDATARANGE PinDataRangePointersAC3Stream[] =
{
    PKSDATARANGE(&PinDataRangesStream[1])
};

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
    {
        sizeof(KSDATARANGE),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    },
    {
        sizeof(KSDATARANGE),
        0,
        0,
        0,
        STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SUBTYPE_AC3_AUDIO),
        STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
    }
};

static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
    // Wave In Streaming Pin (Capture) KSPIN_WAVE_CAPTURE_SINK
    {
        MAX_OUTPUT_STREAMS,
        MAX_OUTPUT_STREAMS,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_RECORDING_CONTROL,  
            0
        }
    },
    
    // Wave In Bridge Pin (Capture - From Topology) KSPIN_WAVE_CAPTURE_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
  
    // Wave Out Streaming Pin (Renderer) KSPIN_WAVE_RENDER_SINK
    {
        MAX_INPUT_STREAMS,
        MAX_INPUT_STREAMS, 
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersStream),
            PinDataRangePointersStream,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            &KSAUDFNAME_VOLUME_CONTROL,
            0
        }
    },
  
    // Wave Out Bridge Pin (Renderer) KSPIN_WAVE_RENDER_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },

    // Wave Out AC3 Bridge Pin (Renderer) KSPIN_WAVE_AC3_RENDER_SINK
    {
        MAX_AC3_INPUT_STREAMS,
        MAX_AC3_INPUT_STREAMS,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersAC3Stream),
            PinDataRangePointersAC3Stream,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_SINK,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },


    // Wave Out AC3 Bridge Pin (Renderer) KSPIN_WAVE_AC3_RENDER_SOURCE
    {
        0,
        0,
        0,
        NULL,
        {
            0,
            NULL,
            0,
            NULL,
            SIZEOF_ARRAY(PinDataRangePointersBridge),
            PinDataRangePointersBridge,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_NONE,
            &KSCATEGORY_AUDIO,
            NULL,
            0
        }
    },
};

//=============================================================================
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    // KSNODE_WAVE_ADC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_ADC,        // Type
        NULL                    // Name
    },
    // KSNODE_WAVE_DAC
    {
        0,                      // Flags
        NULL,                   // AutomationTable
        &KSNODETYPE_DAC,        // Type
        NULL                    // Name
    }
};


//=============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    { PCFILTER_NODE,        KSPIN_WAVE_CAPTURE_SOURCE,  KSNODE_WAVE_ADC,     1 },    
    { KSNODE_WAVE_ADC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_CAPTURE_SINK },    

    { PCFILTER_NODE,        KSPIN_WAVE_RENDER_SINK,     KSNODE_WAVE_DAC,     1 },    
    { KSNODE_WAVE_DAC,      0,                          PCFILTER_NODE,       KSPIN_WAVE_RENDER_SOURCE },    

    { PCFILTER_NODE,        KSPIN_WAVE_AC3_RENDER_SINK, PCFILTER_NODE,       KSPIN_WAVE_AC3_RENDER_SOURCE}
};

//=============================================================================
static
PCFILTER_DESCRIPTOR MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories - NULL->use defaults (AUDIO RENDER CAPTURE)
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\drmmult\mintopo.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    minitopo.h

Abstract:

    Declaration of topology miniport.

--*/

#ifndef _MSVAD_MINTOPO_H_
#define _MSVAD_MINTOPO_H_

#include "basetopo.h"

//=============================================================================
// Classes
//=============================================================================

///////////////////////////////////////////////////////////////////////////////
// CMiniportTopology 
//   

class CMiniportTopology : 
    public CMiniportTopologyMSVAD,
    public IMiniportTopology,
    public CUnknown
{
  public:
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportTopology);
    ~CMiniportTopology();

    IMP_IMiniportTopology;
};
typedef CMiniportTopology *PCMiniportTopology;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\ddk\wdmaudio\msvad\ac3\toptable.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation All Rights Reserved

Module Name:

    toptable.h

Abstract:

    Declaration of topology tables.

--*/

#ifndef _MSVAD_TOPTABLE_H_
#define _MSVAD_TOPTABLE_H_

//=============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
 {
   sizeof(KSDATARANGE),
   0,
   0,
   0,
   STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
   STATICGUIDOF(KSDATAFORMAT_SUBTYPE_ANALOG),
   STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
 }
};

//=============================================================================
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
  &PinDataRangesBridge[0]
};

//=============================================================================
static
PCPIN_DESCRIPTOR MiniportPins[] =
{
  // KSPIN_TOPO_WAVEOUT_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSCATEGORY_AUDIO,                            // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHOUT_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_SYNTHIN_SOURCE
  {
    0,
    0, 
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SYNTHESIZER,                      // Category
      &KSAUDFNAME_MIDI,                             // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_MIC_SOURCE
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_IN,                            // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_MICROPHONE,                       // Category
      NULL,                                         // Name
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_LINEOUT_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                                           // AutomationTable
    {                                               // KsPinDescriptor
      0,                                            // InterfacesCount
      NULL,                                         // Interfaces
      0,                                            // MediumsCount
      NULL,                                         // Mediums
      SIZEOF_ARRAY(PinDataRangePointersBridge),     // DataRangesCount
      PinDataRangePointersBridge,                   // DataRanges
      KSPIN_DATAFLOW_OUT,                           // DataFlow
      KSPIN_COMMUNICATION_NONE,                     // Communication
      &KSNODETYPE_SPEAKER,                          // Category
      &KSAUDFNAME_VOLUME_CONTROL,                   // Name (this name shows up as
                                                    // the playback panel name in SoundVol)
      0                                             // Reserved
    }
  },

  // KSPIN_TOPO_WAVEIN_DEST
  {
    0,
    0,
    0,                                              // InstanceCount
    NULL,                   