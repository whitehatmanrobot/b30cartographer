stItem = &dlgListDummy;
ULONG cRefs = 1;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    pDlgListItem = g_ObjectMgrData.DlgList;

    // look for existing.
    while (pDlgListItem)
    {
        if (rclsid == pDlgListItem->clsid
                &&  dlgType == pDlgListItem->dlgType)
        {
            break;
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }

    if (pDlgListItem)
    {
         // since only allow one choice at a time Dlg should always match.
        Assert(pDlgListItem->pDlg == pDlg);

        cRefs = ++pDlgListItem->cRefs;
    }
    else
    {
        cCritSect.Leave();
        AssertSz(0,"Addref Called on invalid DLG");
        cCritSect.Enter();
    }


    cCritSect.Leave();
    return cRefs;

}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseDialog, private
//
//  Synopsis:   Looks to see if there is an existing  dialog
//              matching the type and  clsid and calls release on it..
//
//  Arguments:
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) ReleaseDialog(DLGTYPE dlgType,REFCLSID rclsid,CBaseDlg *pDlg,BOOL fForce)
{
DLGLISTITEM dlgListDummy;
DLGLISTITEM *pDlgListItem = &dlgListDummy;
ULONG cRefs = 0;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());


    cCritSect.Enter();

    pDlgListItem->pDlgNextListItem = g_ObjectMgrData.DlgList;

    // look for existing.
    while (pDlgListItem->pDlgNextListItem)
    {
        if (dlgType == pDlgListItem->pDlgNextListItem->dlgType
            && rclsid == pDlgListItem->pDlgNextListItem->clsid)
        {
        DLGLISTITEM *pDlgListMatch;
        DWORD cRefs;

            pDlgListMatch = pDlgListItem->pDlgNextListItem;

            Assert(pDlgListMatch->pDlg == pDlg);

            cRefs = --pDlgListMatch->cRefs;
            Assert(0 <= ((LONG) cRefs));

            // 2/23/98 rogerg changed cLocks to go to zero if
            // flocks is set in case the cancel (which is the only button to set force)
            // release comes in before a an object that just needs to keep the dialog alive.

           if (fForce)
                pDlgListMatch->cLocks = 0;

            if (0 >= cRefs && (0 == pDlgListMatch->cLocks || fForce) )
            {
            HANDLE hThread;

                // remove the item from the list.
                pDlgListItem->pDlgNextListItem = pDlgListMatch->pDlgNextListItem;
                g_ObjectMgrData.DlgList = dlgListDummy.pDlgNextListItem;

                cCritSect.Leave();

                // we should have always set the callback
                Assert(TRUE == pDlgListMatch->fHasReleaseDlgCmdId);

                pDlgListMatch->pDlg->ReleaseDlg(pDlgListMatch->wCommandID);
                pDlgListMatch->fHasReleaseDlgCmdId = FALSE;
                hThread = pDlgListMatch->hThread;

                FREE(pDlgListMatch);
                ReleaseOneStopLifetime(FALSE /* !External */); // release the ServerCount

                CloseHandle(hThread);

            }
            else
            {
                cCritSect.Leave();
            }

            return cRefs;
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }

    // if got here and didn't find let us know
    Assert(0);
    cCritSect.Leave();

    return cRefs; // we return zero if can't find the item.
}

//+---------------------------------------------------------------------------
//
//  Function:   SetReleaseDlgCmdId, private
//
//  Synopsis:   Sets the releaseCmdId for the specified dialog.
//
//  Arguments:
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI SetReleaseDlgCmdId(DLGTYPE dlgType,REFCLSID rclsid,CBaseDlg *pDlg,WORD wCommandId)
{
HRESULT hr;
DLGLISTITEM *pDlgListItem;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    pDlgListItem = g_ObjectMgrData.DlgList;

    // look for existing.
    while (pDlgListItem)
    {
        if (rclsid == pDlgListItem->clsid
                &&  dlgType == pDlgListItem->dlgType)
        {

           // should only ever be one choice dialog in the list
           Assert(pDlg == pDlgListItem->pDlg);

           // if there is already a cmdId associated don't replace it
            pDlgListItem->fHasReleaseDlgCmdId = TRUE;
            pDlgListItem->wCommandID = wCommandId;
            hr =  NOERROR;

            cCritSect.Leave();
            return hr;
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }

    cCritSect.Leave();
    Assert(0); // object wasn't found for some reason.

    return E_UNEXPECTED;
}


//+---------------------------------------------------------------------------
//
//  Function:   FindChoiceDialog, public
//
//  Synopsis:   Looks to see if there is an existing choice dialog
//              matching the clsid. If not and fCreate is true a
//              new choice dialog will be made. If fCreate is false
//              and no dialog is found S_FALSE will be returned.
//
//  Arguments:  [rclcisd] - clsid of choice dialog
//              [fCreate] - If true and no choice dialog found a new one will
//                          be created.
//              [nCmdShow] - How to Create the dialog
//              [pChoiceDlg] - On Success is a pointer to the new Choice Dialog.
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI FindChoiceDialog(REFCLSID rclsid,BOOL fCreate,int nCmdShow,CChoiceDlg **pChoiceDlg)
{

    return FindDialog(DLGTYPE_CHOICE,rclsid,fCreate,nCmdShow,(CBaseDlg**) pChoiceDlg);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseChoiceDialog, public
//
//  Synopsis:   Releases the ChoiceDialog matching the clsid
//              and Dialog Ptr. If it finds a match, and the
//              refcount decrements to zero the dialog if first
//              removed from the list and then its ReleaseDlg
//              method is called.
//
//  Arguments:  [rclcisd] - clsid of choice dialog
//              [pChoiceDlg] - Ptr to the Choice dialog
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) ReleaseChoiceDialog(REFCLSID rclsid,CChoiceDlg *pChoiceDlg)
{

    return ReleaseDialog(DLGTYPE_CHOICE,rclsid,pChoiceDlg,FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRefChoiceDialog, public
//
//  Synopsis:   puts an Addref of the choice dialog
//
//  Arguments:  [rclsid] - Identifies the choice dialog
//              [pChoiceDlg] - Ptr to the choice dialog
//
//  Returns:    New Reference count
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) AddRefChoiceDialog(REFCLSID rclsid,CChoiceDlg *pChoiceDlg)
{
    return AddRefDialog(DLGTYPE_CHOICE,rclsid,pChoiceDlg);
}


//+---------------------------------------------------------------------------
//
//  Function:   SetChoiceReleaseDlgCmdId, public
//
//  Synopsis:   Sets the CommandId to be used inthe
//              ReleaseDlg is call when the dialog is destroyed.
//
//  Arguments:  [rclcisd] - clsid of choice dialog
//              [pChoiceDlg] - Ptr to the Choice dialog
//              [wCommandId] - CommandId to pass to ReleaseDlg
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI SetChoiceReleaseDlgCmdId(REFCLSID rclsid,CChoiceDlg *pChoiceDlg,WORD wCommandId)
{
    return SetReleaseDlgCmdId(DLGTYPE_CHOICE,rclsid,pChoiceDlg,wCommandId);
}


//+---------------------------------------------------------------------------
//
//  Function:   FindProgressDialog, public
//
//  Synopsis:   Looks to see if there is an existing progress dialog.
//              If not and fCreate is true a new progress dialog will be made.
//              If fCreate is false and no dialog is found S_FALSE will be returned.
//
//  Arguments:  [fCreate] - If true and no choice dialog found a new one will
//                          be created.
//              [nCmdShow] - How to display the dialog
//              [pProgressDlg] - On Success is a pointer to the new Progress Dialog.
//
//  Returns:    Appropriate return codes.
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI FindProgressDialog(REFCLSID rclsid,BOOL fCreate,int nCmdShow,CProgressDlg **pProgressDlg)
{
    return FindDialog(DLGTYPE_PROGRESS,rclsid,fCreate,nCmdShow,(CBaseDlg **) pProgressDlg);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseProgressDialog, public
//
//  Synopsis:   Releases the Progress dialog matching the Dialog Ptr.
//              If it finds a match, and the
//              refcount decrements to zero the dialog if first
//              removed from the list and then its ReleaseDlg
//              method is called.
//
//  Arguments:  [fForce] - if refs gos to zero releases the dialog
//                         even if there is a lock on it.
//              [pProgressDlg] - Ptr to the Progress dialog
//
//  Returns:    New Reference count.
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) ReleaseProgressDialog(REFCLSID rclsid,CProgressDlg *pProgressDlg,BOOL fForce)
{
    return ReleaseDialog(DLGTYPE_PROGRESS,rclsid,pProgressDlg,fForce);
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRefProgressDialog, public
//
//  Synopsis:   puts an Addref of the progress dialog
//
//  Arguments:  [fForce] - if refs gos to zero releases the dialog
//                         even if there is a lock on it.
//              [pProgressDlg] - Ptr to the Progress dialog
//
//  Returns:    New Reference count
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) AddRefProgressDialog(REFCLSID clsid,CProgressDlg *pProgressDlg)
{
    return AddRefDialog(DLGTYPE_PROGRESS,clsid,pProgressDlg);
}

//+---------------------------------------------------------------------------
//
//  Function:   SetProgressReleaseDlgCmdId, public
//
//  Synopsis:   Sets the Callback for the Progress dialog that
//              is called when the Progress dialog has been removed
//              from the list.
//
//  Arguments:  [pProgressDlg] - Ptr to the Progress dialog
//              [wCommandId] - CommandId to pass to ReleaseDlg
//
//  Returns:    Appropriate Error codes
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI SetProgressReleaseDlgCmdId(REFCLSID clsid,CProgressDlg *pProgressDlg,WORD wCommandId)
{
    return SetReleaseDlgCmdId(DLGTYPE_PROGRESS,clsid,pProgressDlg,wCommandId);
}


//+---------------------------------------------------------------------------
//
//  Function:   LockProgressDialog, public
//
//  Synopsis:   Add/Removes Lock on the Progress Dialog.
//              When there is a lock on the Progress Dialog
//              it won't go away when the reference count
//              goes to zero.
//
//              !!Dialog will not go away if lock count
//              goes to zero even if cRefs are currently zero
//
//
//  Arguments:  [pProgressDlg] - Ptr to the Progress dialog
//              [fLock] - BOOL whether to lock/unlocK
//
//  Returns:    Appropriate Error codes
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg      Created.
//  History     09-Dec-98       rogerg      Change so lock was a bool instead of refcount
//                                          to have same behavior as release with force flag
//
//----------------------------------------------------------------------------

STDAPI LockProgressDialog(REFCLSID clsid,CProgressDlg *pProgressDlg,BOOL fLock)
{
HRESULT hr = S_FALSE;
DLGLISTITEM *pDlgListItem;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());


    cCritSect.Enter();

    pDlgListItem = g_ObjectMgrData.DlgList;

    // look for existing.
    while (pDlgListItem)
    {
        if (DLGTYPE_PROGRESS == pDlgListItem->dlgType
                && clsid == pDlgListItem->clsid)
        {
            break;
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }

    if (pDlgListItem)
    {
        if (fLock)
        {
            pDlgListItem->cLocks = 1;
        }
        else
        {
            pDlgListItem->cLocks = 0;
        }

        hr = S_OK;
    }
    else
    {
        AssertSz(0,"Dialog Not found in Lock");
    }

    cCritSect.Leave();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ShowOptionsDialog, public
//
//  Synopsis:   Displays the options dialog. If one is already displayed
//              it just brings it to the foreground.
//
//  Arguments:  [hwndParent] - Use as parent if dialog doesn't already exist
//
//  Returns:    Appropriate Error codes
//
//
//  Modifies:
//
//  History:    24-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI ShowOptionsDialog(HWND hwndParent)
{
DlgSettingsArgs ThreadArgs;
HRESULT hr = E_FAIL;
HANDLE hNewThread = NULL;
DWORD dwThreadId;


    ThreadArgs.hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);

    if (ThreadArgs.hEvent)
    {
        ThreadArgs.hwndParent = hwndParent;
        ThreadArgs.dwParentThreadId = GetCurrentThreadId();

        hr = NOERROR;

        hNewThread = CreateThread(NULL,0,SettingsThread,&ThreadArgs,0,&dwThreadId);

        if (hNewThread)
        {
            WaitForSingleObject(ThreadArgs.hEvent,INFINITE);
            CloseHandle(hNewThread); // we'll let the thread take care of itself
        }

        CloseHandle(ThreadArgs.hEvent);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   SettingsThread, private
//
//  Synopsis:   Worker thread for displaying the settings dialog.
//
//  Arguments:
//
//  Returns:
//
//
//  Modifies:
//
//  History:    24-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

DWORD WINAPI  SettingsThread( LPVOID lpArg )
{
DlgSettingsArgs *pThreadArgs = (DlgSettingsArgs *) lpArg;
HWND hwndParent;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    hwndParent = pThreadArgs->hwndParent;

    // see if we are already in a DisplayOptions Dialog
    // and if so just return,

    AddRefOneStopLifetime(FALSE /* !External */);

    // Increment settings ref count
    cCritSect.Enter();
    ++g_ObjectMgrData.dwSettingsLockCount;
    cCritSect.Leave();

   // attach the thread input with the creating thread so focus works correctly.
   AttachThreadInput(GetCurrentThreadId(),pThreadArgs->dwParentThreadId,TRUE);

   // let the caller know the thread is done initializing.
   if (pThreadArgs->hEvent)
     SetEvent(pThreadArgs->hEvent);

   DisplayOptions(hwndParent);  // exported in the OneStop Dll.

    // decrement the settings lock count
    cCritSect.Enter();
    --g_ObjectMgrData.dwSettingsLockCount;
    cCritSect.Leave();

    ReleaseOneStopLifetime(FALSE /* !External */);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterOneStopCLSIDs, private
//
//  Synopsis:   Registers the Clsids associated with the OneStop app
//
//  Arguments:
//
//  Returns:    Appropriate Error codes
//
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI RegisterOneStopCLSIDs()
{
LPCLASSFACTORY pClassFact;
HRESULT hr = E_OUTOFMEMORY;

    pClassFact = (LPCLASSFACTORY) new CClassFactory();

    if (pClassFact)
    {
        hr = CoRegisterClassObject(CLSID_SyncMgrp,pClassFact,CLSCTX_LOCAL_SERVER,
                    REGCLS_MULTIPLEUSE,&g_ObjectMgrData.dwRegClassFactCookie);

        if (NOERROR != hr)
        {
            // on longon the rpc server may not yet be available and on
            // logoff we get the wrong server identity. Don't assert on these
            // since we know about the cases.
            if (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) != hr
                &&  CO_E_WRONG_SERVER_IDENTITY != hr)
            {
                AssertSz(0,"Class Factory Registration failed");
            }

            g_ObjectMgrData.dwRegClassFactCookie = 0;
        }
        else
        {
            g_ObjectMgrData.fRegClassFactCookieValid = TRUE;
        }

        pClassFact->Release(); // Release our reference on the ClassFactory.

    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   MakeWinstaDesktopName, public
//
//  Synopsis:   Stole main code from Ole32 remote.cxx to generate
//              a unique eventName based on session and desktop..

//  Arguments:  
//
//  Returns:    Appropriate Error codes
//
//  Modifies:
//
//  History:    18-Dec-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI MakeWinstaDesktopName(LPCWSTR pszPreceding,LPWSTR *ppszResultString)
{
HWINSTA hWinsta;
HDESK   hDesk;
WCHAR   wszWinsta[32];
WCHAR   wszDesktop[32];
LPWSTR  pwszWinsta;
LPWSTR  pwszDesktop;
LPWSTR _pwszWinstaDesktop; // out param
DWORD   Length;
BOOL    Status;
HRESULT hr;
DWORD dwResult;
DWORD dwPrecedingSize;


    if (!ppszResultString)
    {
        Assert(ppszResultString);
        return E_INVALIDARG;
    }

    *ppszResultString = NULL;;

    // if not on flavor of NT return an error
    if (VER_PLATFORM_WIN32_NT != g_OSVersionInfo.dwPlatformId)
    {
        AssertSz(0,"MakeWinstaDesktopName called on unsupported platform");
        return E_FAIL;
    }

    hWinsta = GetProcessWindowStation();

    if ( ! hWinsta )
        return HRESULT_FROM_WIN32(GetLastError());

    hDesk = GetThreadDesktop(GetCurrentThreadId());

    if ( ! hDesk )
        return HRESULT_FROM_WIN32(GetLastError());

    pwszWinsta = wszWinsta;
    pwszDesktop = wszDesktop;

    Length = sizeof(wszWinsta);

    Status = GetUserObjectInformation(
                hWinsta,
                UOI_NAME,
                pwszWinsta,
                Length,
                &Length );

    if ( ! Status )
    {
        dwResult = GetLastError();
        if ( ERROR_INSUFFICIENT_BUFFER != dwResult)
        {
            hr  = HRESULT_FROM_WIN32(dwResult);
            goto WinstaDesktopExit;
        }

        pwszWinsta = (LPWSTR) ALLOC( Length );
        if ( ! pwszWinsta )
        {
            hr = E_OUTOFMEMORY;
            goto WinstaDesktopExit;
        }

        Status = GetUserObjectInformation(
                    hWinsta,
                    UOI_NAME,
                    pwszWinsta,
                    Length,
                    &Length );

        if ( ! Status )
        {
            hr  = HRESULT_FROM_WIN32(GetLastError());
            goto WinstaDesktopExit;
        }
    }

    Length = sizeof(wszDesktop);

    Status = GetUserObjectInformation(
                hDesk,
                UOI_NAME,
                pwszDesktop,
                Length,
                &Length );

    if ( ! Status )
    {
        dwResult = GetLastError();
        if ( dwResult != ERROR_INSUFFICIENT_BUFFER )
        {
            hr = HRESULT_FROM_WIN32(dwResult);
            goto WinstaDesktopExit;
        }

        pwszDesktop = (LPWSTR) ALLOC( Length );
        if ( ! pwszDesktop )
        {
            hr = E_OUTOFMEMORY;
            goto WinstaDesktopExit;
        }

        Status = GetUserObjectInformation(
                    hDesk,
                    UOI_NAME,
                    pwszDesktop,
                    Length,
                    &Length );

        if ( ! Status )
        {
            hr =  HRESULT_FROM_WIN32(GetLastError());
            goto WinstaDesktopExit;
        }
    }

    dwPrecedingSize = pszPreceding ? lstrlen(pszPreceding) + 1 : 0;

    _pwszWinstaDesktop = 
        (WCHAR *)  ALLOC( (dwPrecedingSize 
                            +  lstrlen(pwszWinsta) + 1 
                            + lstrlen(pwszDesktop) + 1) * sizeof(WCHAR) );

    if ( _pwszWinstaDesktop )
    {
        *_pwszWinstaDesktop = NULL;

        if (pszPreceding)
        {
            lstrcat(_pwszWinstaDesktop,pszPreceding);
            lstrcat( _pwszWinstaDesktop, L"_" );
        }

        lstrcat(_pwszWinstaDesktop, pwszWinsta );
        lstrcat( _pwszWinstaDesktop, L"_" );
        lstrcat(_pwszWinstaDesktop, pwszDesktop );
        hr = NOERROR;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

WinstaDesktopExit:

    if ( pwszWinsta != wszWinsta )
    {
        FREE( pwszWinsta );
    }

    if ( pwszDesktop != wszDesktop )
    {
        FREE( pwszDesktop );
    }

   if (NOERROR == hr)
   {
       *ppszResultString = _pwszWinstaDesktop;
   }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegisterOneStopClassFactory, public
//
//  Synopsis:   Handles the ClassFactory registration
//              along with the associated race conditions.
//
//              if class factory isn't already registered, then go ahead and register now.
//              there is the case the between the time we see if there is a class factory
//              and the CoCreateInstance is called it could go away.  If this happens, another
//              instance of Onestop.exe is launched and everything will work properly.

//  Arguments:  [fForce] - When true the ClassFactory is registered even if there
//                          is an existing event object.
//
//  Returns:    Appropriate Error codes
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------



const WCHAR SZ_CFACTORYEVENTNAME[] =  TEXT("{6295DF2D-35EE-11d1-8707-00C04FD93327}CFactEvent");

STDAPI RegisterOneStopClassFactory(BOOL fForce)
{
HRESULT hr = NOERROR; // only report error is actual call to register CFact Failed.
LPWSTR pEventName;
BOOL fExistingInstance = FALSE;

    if (( VER_PLATFORM_WIN32_NT != g_OSVersionInfo.dwPlatformId)
         || (NOERROR != MakeWinstaDesktopName(SZ_CFACTORYEVENTNAME,&pEventName)) )
    {
        pEventName = (LPWSTR) SZ_CFACTORYEVENTNAME;
    }

    // this should only ever be called on MainThread so don't
    // need to lock
    Assert(g_ObjectMgrData.dwMainThreadID == GetCurrentThreadId());
    Assert(NULL == g_ObjectMgrData.hClassRegisteredEvent);

    g_ObjectMgrData.hClassRegisteredEvent =  CreateEvent(NULL,TRUE,FALSE,pEventName);
    Assert(g_ObjectMgrData.hClassRegisteredEvent);

    // if got the event and not a force see if there is an existing instance.
    if (g_ObjectMgrData.hClassRegisteredEvent && !fForce)
    {
       if (ERROR_ALREADY_EXISTS == GetLastError())
       {
           // object already existed and the force flag isn't set
           // it means we can use the existing registered object.
          CloseHandle(g_ObjectMgrData.hClassRegisteredEvent);
          g_ObjectMgrData.hClassRegisteredEvent = NULL;
          hr = NOERROR;
          fExistingInstance = TRUE;
       }

   }

   // If fForce is set or these isn't an existing class
   // go ahead and register.
   if (fForce || (!fExistingInstance && g_ObjectMgrData.hClassRegisteredEvent)) 
   {
        // force on an event already existing is  a state that
        // should only occur if EXE was launched twice with the embedding flag.
        // This shouldn't happen under normal conditions so assert.
        // so we can catch any cases that we didn't get the event
        // and the force flag is set.

        Assert(g_ObjectMgrData.hClassRegisteredEvent);

        hr = RegisterOneStopCLSIDs();

        if (NOERROR != hr)
        {
            if (g_ObjectMgrData.hClassRegisteredEvent)
            {
                  CloseHandle(g_ObjectMgrData.hClassRegisteredEvent);
                  g_ObjectMgrData.hClassRegisteredEvent = NULL;
            }

        }
   }

   if (pEventName && (SZ_CFACTORYEVENTNAME != pEventName))
   {
       FREE(pEventName);
   }

   return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   AddRefOneStopLifetime, public
//
//  Synopsis:   Adds a Reference to the applications

//  Arguments:
//
//  Returns:    New total Reference count including both
//              internal and external locks.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) AddRefOneStopLifetime(BOOL fExternal)
{
DWORD cRefs;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    // Increment ref count
    cCritSect.Enter();

    if (fExternal)
    {
        ++g_ObjectMgrData.LockCountExternal;
    }
    else
    {
        ++g_ObjectMgrData.LockCountInternal;
    }

    cRefs = g_ObjectMgrData.LockCountExternal + g_ObjectMgrData.LockCountInternal;

    cCritSect.Leave();

    Assert(0 < cRefs);

    return cRefs;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseOneStopLifetime, public
//
//  Synopsis:   Releases a Reference to the applications
//              If the refcount goes to zero the classfactory
//              is revoked an a quit message is posted to the
//              main thread
//
//  Arguments:
//
//  Returns:    New Reference count including internal and
//              external locks.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) ReleaseOneStopLifetime(BOOL fExternal)
{
DWORD cRefsExternal;
DWORD cRefsInternal;
BOOL fForceClose;
DLGLISTITEM *pDlgListItem;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());


    cCritSect.Enter();

    if (fExternal)
    {
        --g_ObjectMgrData.LockCountExternal;
    }
    else
    {
        --g_ObjectMgrData.LockCountInternal;
    }


    cRefsInternal = g_ObjectMgrData.LockCountInternal;
    cRefsExternal = g_ObjectMgrData.LockCountExternal;
    fForceClose = g_ObjectMgrData.fCloseAll;

    pDlgListItem = g_ObjectMgrData.DlgList;


    Assert(0 <= ((LONG) cRefsInternal));
    Assert(0 <= ((LONG) cRefsExternal));

    if( (0 >= cRefsInternal)
        && (0 >= cRefsExternal || fForceClose)
        && (FALSE == g_ObjectMgrData.fDead) )
    {
    HANDLE hRegisteredEvent;
    HWND hwndMainThreadMsg;
    DWORD dwRegClassFactCookie;
    BOOL  fRegClassFactCookieValid;

        Assert(0 == pDlgListItem); // all dialogs should have been released.
        Assert(0 == g_ObjectMgrData.dwSettingsLockCount); // settings dialogs should be gone.

        g_ObjectMgrData.fDead = TRUE;

        hRegisteredEvent = g_ObjectMgrData.hClassRegisteredEvent;
        g_ObjectMgrData.hClassRegisteredEvent = NULL;

        hwndMainThreadMsg = g_ObjectMgrData.hWndMainThreadMsg;
        g_ObjectMgrData.hWndMainThreadMsg = NULL;

        dwRegClassFactCookie = g_ObjectMgrData.dwRegClassFactCookie;
        g_ObjectMgrData.dwRegClassFactCookie = 0;

        fRegClassFactCookieValid = g_ObjectMgrData.fRegClassFactCookieValid;
        g_ObjectMgrData.fRegClassFactCookieValid = FALSE;

        cCritSect.Leave();

        if (NULL != hRegisteredEvent)
        {
            CloseHandle(hRegisteredEvent); // release our registration event.
        }

        // we need to revoke the classfactory on the thread that registered it.
        // Send a message back to the thread that registered the event.

         if (fRegClassFactCookieValid)
         {
            SendMessage(hwndMainThreadMsg,WM_CFACTTHREAD_REVOKE,dwRegClassFactCookie,0);
         }

        // if lockcount is still zero then post the quitmessage
        // else someone came in during our revoke and we
        // need to wait for the refcount to hit zero again.

        cCritSect.Enter();

        cRefsInternal = g_ObjectMgrData.LockCountInternal;
        cRefsExternal = g_ObjectMgrData.LockCountExternal;

        if ( (0 >= cRefsInternal) 
                && (0 >= cRefsExternal || fForceClose) )
        {
        DWORD dwMainThreadID;
        HANDLE hThread = NULL;

            dwMainThreadID = g_ObjectMgrData.dwMainThreadID;

            // its possible the quite is occuring on a thread other than
            // the main thread. If this is the case send the handle of the thread
            // along with the quit message to the main thread can wait for this
            // thread to exit.

#ifdef _THREADSHUTDOWN
            if (dwMainThreadID != GetCurrentThreadId())
            {
            HANDLE hCurThread;
            HANDLE hProcess;

                hCurThread = GetCurrentThread();
                hProcess = GetCurrentProcess();

                if (!DuplicateHandle(hProcess,hCurThread,hProcess,&hThread,
                            0,FALSE,DUPLICATE_SAME_ACCESS) )
                {
                    hThread = NULL; // don't rely on DupHandle to set this to null on error.
                }

            }
#endif // _THREADSHUTDOWN

            // shut down the main thread
            cCritSect.Leave();
            PostMessage(hwndMainThreadMsg,WM_MAINTHREAD_QUIT,0,(LPARAM) /* hThread */ 0);
            cCritSect.Enter();
        }
        else
        {
            g_ObjectMgrData.fDead = FALSE;
        }


    }

    cCritSect.Leave();

    return (cRefsExternal + cRefsInternal);
}

//+---------------------------------------------------------------------------
//
//  Function:   IsOneStopDlgMessage, public
//
//  Synopsis:   Called in messageloop to determine if message
//              should be handled by a dialog
//
//  Arguments:
//
//  Returns:    TRUE - The item was processed.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

#ifdef _UNUSED

BOOL IsOneStopDlgMessage(MSG *msg)
{
DLGLISTITEM *pDlgListItem;
DWORD dwThreadID = GetCurrentThreadId();
CCriticalSection cCritSect(&g_LockCountCriticalSection,dwThreadID);
HWND hwnd = NULL;


    cCritSect.Enter();

    // see if we have a dialog in this thread.
    pDlgListItem = g_ObjectMgrData.DlgList;
    while (pDlgListItem)
    {

        if (pDlgListItem->pDlg
                && dwThreadID == pDlgListItem->dwThreadID)
        {
            hwnd = pDlgListItem->pDlg->GetHwnd();
            pDlgListItem = pDlgListItem->pDlgNextListItem;
            break;
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }

#if DEBUG

    // we should only ever have one registered dialog per thread
    // loop through remaining dialogs and if find a match assert

    while (pDlgListItem)
    {

        if (pDlgListItem->pDlg
                && dwThreadID == pDlgListItem->dwThreadID)
        {
            AssertSz(0,"Multiple dialogs in thread");
            break;
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }



#endif // DEBUG

    cCritSect.Leave();

    if (hwnd && IsDialogMessage(hwnd,msg))
    {
        return TRUE;
    }

    return FALSE;
}

#endif // _UNUSED

//+---------------------------------------------------------------------------
//
//  Function:   InitObjectManager, public
//
//  Synopsis:   Must be called from Main thread before any
//              new threads, dialogs are created or the class factory
//              is registered.
//
//  Arguments:
//
//  Returns:    Appropriate Error Codes.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI InitObjectManager(CMsgServiceHwnd *pMsgService)
{
    // initialize critical section for our lock count.
    InitializeCriticalSection(&g_LockCountCriticalSection);

    g_ObjectMgrData.dwMainThreadID = GetCurrentThreadId();
    g_ObjectMgrData.hWndMainThreadMsg = pMsgService->GetHwnd();

    g_ObjectMgrData.DlgList = NULL;
    g_ObjectMgrData.hClassRegisteredEvent = NULL;
    g_ObjectMgrData.dwRegClassFactCookie = 0;
    g_ObjectMgrData.fRegClassFactCookieValid = FALSE;
    g_ObjectMgrData.LockCountInternal = 0;
    g_ObjectMgrData.LockCountExternal = 0;
    g_ObjectMgrData.fCloseAll = FALSE;
    g_ObjectMgrData.dwSettingsLockCount = 0;
    g_ObjectMgrData.dwHandlerPropertiesLockCount = 0;
    g_ObjectMgrData.fDead = FALSE;

    // Initialize autodial support
    g_ObjectMgrData.eAutoDialState = eQuiescedOff;
    g_ObjectMgrData.fRasAutoDial = FALSE;
    g_ObjectMgrData.fWininetAutoDial = FALSE;
    g_ObjectMgrData.fFirstSyncItem = FALSE;
    g_ObjectMgrData.cNestedStartCalls = 0;

    Assert(NULL != g_ObjectMgrData.hWndMainThreadMsg);

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   RequestIdleLock, public
//
//  Synopsis:   request to see if an new Idle can be started.
//
//  Arguments:
//
//  Returns:    NOERROR - if Idle should be continued
//              S_FALSE - if another Idle is already in progreaa.
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI RequestIdleLock()
{
HRESULT hr;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    if (g_ObjectMgrData.fIdleHandlerRunning)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = NOERROR;
        g_ObjectMgrData.fIdleHandlerRunning = TRUE;
    }

    cCritSect.Leave();

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   ReleaseIdleLock, public
//
//  Synopsis:   Informs ObjectMgr that the Idle is done processing.
//
//  Arguments:
//
//  Returns:    Appropriate error codes.
//
//  Modifies:
//
//  History:    23-Feb-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI ReleaseIdleLock()
{
HRESULT hr = NOERROR;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    // note okay for this to already be FALSE in case progress receives
    // an offidle before release. Call this when idle progress is 
    // released as safety in case offidle isn't working properly.

    g_ObjectMgrData.fIdleHandlerRunning = FALSE;

    cCritSect.Leave();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ObjMgr_HandleQueryEndSession, public
//
//  Synopsis:   Called by main thread so knows how to respond to WN_QUERYENDSESSION.
//
//  Arguments:
//
//  Returns:    S_OK - if system can shutdown
//              S_FALSE - if hould fail the query. On an S_FALSE the out params
//                  are filled, hwnd with parent hwnd of any message box and MessageID
//                  with the appropriate messageID to display.
//
//  Modifies:
//
//  History:    21-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI ObjMgr_HandleQueryEndSession(HWND *phwnd,UINT *puMessageId,BOOL *pfLetUserDecide)
{
HRESULT hr = S_OK;
BOOL fProgressDialog = FALSE;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    cCritSect.Enter();

    *phwnd = NULL;
    *pfLetUserDecide = FALSE;

    // if there are any settings dialogs then we can't quit
    if (g_ObjectMgrData.dwSettingsLockCount > 0)
    {
        *phwnd = NULL;
        *puMessageId = IDS_SETTINGSQUERYENDSESSION;
        hr = S_FALSE;
    }
    else
    {
    DLGLISTITEM *pDlgListItem;
    BOOL fDontShutdown = FALSE; // set when find match
    HWND hwnd;
    UINT uMessageId;
    BOOL fLetUserDecide;


        // loop through dialogs asking if they can shutdown.
        // first dialog find that doesn't give choice return
        // if the dialog says to let user decide continue looping
        // until hit end or find a dialog that doesn't give choice since
        // not giving choice takes precedence.

        // see if there is a progress dialog other than idle and if so stop the logoff.
        pDlgListItem = g_ObjectMgrData.DlgList;

        // loop through the choice dialogs to see if
        while (pDlgListItem)
        {

            if ( (pDlgListItem->pDlg)
                && (S_FALSE == pDlgListItem->pDlg->QueryCanSystemShutdown(&hwnd,&uMessageId,&fLetUserDecide) ) )
            {
                // if first dialog find we can't shutdown or fLetUserDecide isn't set
                // then upate the out params

                if (!fDontShutdown || !fLetUserDecide)
                {
                    *phwnd = hwnd;
                    *puMessageId = uMessageId;
                    *pfLetUserDecide = fLetUserDecide;

                    fProgressDialog = (pDlgListItem->dlgType == DLGTYPE_PROGRESS) ? TRUE : FALSE;
                }

                fDontShutdown = TRUE;

                // if this dialog doesn't allow the use choice then break
                if (!fLetUserDecide)
                {
                    break;
                }

            }

            pDlgListItem = pDlgListItem->pDlgNextListItem;
        }

        if (fDontShutdown)
        {
            hr = S_FALSE;
        }
    }


    cCritSect.Leave();

    // if can't shutdown and it is a progress dialog then make sure
    // the dialog is not minimized;
    if (fProgressDialog && (NULL != *phwnd) )
    {
        BASEDLG_SHOWWINDOW(*phwnd,SW_SHOWNORMAL);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjMgr_AddRefHandlerPropertiesLockCount, public
//
//  Synopsis:   Called by choice dialog to change the global lock count
//              of open handler properties dialogs
//
//  Arguments:  dwNumRefs - number of references to increment
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    21-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) ObjMgr_AddRefHandlerPropertiesLockCount(DWORD dwNumRefs)
{
ULONG cRefs;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    Assert(0 != dwNumRefs); // catch people passing on 0 since doesn't make sense.

    cCritSect.Enter();

    g_ObjectMgrData.dwHandlerPropertiesLockCount += dwNumRefs;
    cRefs = g_ObjectMgrData.dwHandlerPropertiesLockCount;

    cCritSect.Leave();

    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjMgr_ReleaseHandlerPropertiesLockCount, public
//
//  Synopsis:   Called by choice dialog to change the global lock count
//              of open handler properties dialogs
//
//  Arguments:  dwNumRefs - number of references to decrement
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    21-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(ULONG) ObjMgr_ReleaseHandlerPropertiesLockCount(DWORD dwNumRefs)
{
DWORD cRefs;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());

    Assert(0 != dwNumRefs); // catch people passing on 0 since doesn't make sense.

    cCritSect.Enter();

    g_ObjectMgrData.dwHandlerPropertiesLockCount -= dwNumRefs;
    cRefs = g_ObjectMgrData.dwHandlerPropertiesLockCount;

    cCritSect.Leave();

    Assert( ((LONG) cRefs) >= 0);

    if ( ((LONG) cRefs) < 0)
    {
        cRefs = 0;
    }

    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjMgr_CloseAll, public
//
//  Synopsis:   Called by main thread when an END_SESSION occurs. Loops throug
//              dialogs posting a close to them
//
//  Arguments:
//
//  Returns:    Appropriate error codes
//
//  Modifies:
//
//  History:    21-May-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI ObjMgr_CloseAll()
{
HRESULT hr = S_OK;
HWND hwndDlg;
DLGLISTITEM *pDlgListItem;
CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());


    // Put on Addref to hold alive until done with loop. and also
   // toggle lifetime in case launched with /embedding and
   // no references on self.

    AddRefOneStopLifetime(FALSE /* !External */);

    cCritSect.Enter();
    // see if there is a progress dialog other than idle and if so stop the logoff.
    pDlgListItem = g_ObjectMgrData.DlgList;

    // look for existing.
    while (pDlgListItem)
    {
        Assert(pDlgListItem->pDlg);

        if (pDlgListItem->pDlg)
        {
            hwndDlg = pDlgListItem->pDlg->GetHwnd();

            Assert(hwndDlg);

            if (NULL != hwndDlg)
            {
                PostMessage(hwndDlg,WM_BASEDLG_HANDLESYSSHUTDOWN,0,0);
            }
        }

        pDlgListItem = pDlgListItem->pDlgNextListItem;
    }

    // set the CloseAll flag so Release knows to ignore any
    // external refCounts
    g_ObjectMgrData.fCloseAll  = TRUE;

    cCritSect.Leave();

    ReleaseOneStopLifetime(FALSE /* !External */);

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetAutoDialState
//
//  Synopsis:   Reads the current auto dial state of the machine/process
//
//  History:    18-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDAPI GetAutoDialState()
{
    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    if (NULL != pNetApi )
    {
        BOOL fEnabled;

        pNetApi->RasGetAutodial( fEnabled );
        g_ObjectMgrData.fRasAutoDial = fEnabled;

        pNetApi->InternetGetAutodial( fEnabled );
        g_ObjectMgrData.fWininetAutoDial = fEnabled;
    }

    if ( pNetApi != NULL )
        pNetApi->Release();

    if ( g_ObjectMgrData.fRasAutoDial || g_ObjectMgrData.fWininetAutoDial )
        g_ObjectMgrData.eAutoDialState = eQuiescedOn;

    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Function:   LokEnableAutoDial
//
//  Synopsis:   Enables Ras and Wininet autodialing
//
//  History:    18-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDAPI LokEnableAutoDial()
{
    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    if (NULL != pNetApi )
    {
        if ( g_ObjectMgrData.fRasAutoDial )
            pNetApi->RasSetAutodial( TRUE );

        if ( g_ObjectMgrData.fWininetAutoDial )
            pNetApi->InternetSetAutodial( TRUE );
    }

   if ( pNetApi != NULL )
        pNetApi->Release();

   return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   LokDisableAutoDial
//
//  Synopsis:   Disables Ras and Wininet autodialing
//
//  History:    18-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDAPI LokDisableAutoDial()
{
    LPNETAPI pNetApi = gSingleNetApiObj.GetNetApiObj();

    if (NULL != pNetApi )
    {
        if ( g_ObjectMgrData.fRasAutoDial )
            pNetApi->RasSetAutodial( FALSE );

        if ( g_ObjectMgrData.fWininetAutoDial )
            pNetApi->InternetSetAutodial( FALSE );
    }

   if ( pNetApi != NULL )
        pNetApi->Release();

   return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Function:   BeginSyncSession
//
//  Synopsis:   Called at the beginning of actual synchronization to setup
//              autodial support.
//
//  History:    18-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDAPI BeginSyncSession()
{
    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());
    cCritSect.Enter();

    if ( g_ObjectMgrData.cNestedStartCalls == 0 )
    {
        Assert( g_ObjectMgrData.eAutoDialState == eQuiescedOn
                || g_ObjectMgrData.eAutoDialState == eQuiescedOff );

        g_ObjectMgrData.fFirstSyncItem = TRUE;
    }

    g_ObjectMgrData.cNestedStartCalls++;

    cCritSect.Leave();

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   EndSyncSession
//
//  Synopsis:   Called at the end of actual synchronization to cleanup
//              autodial support.
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDAPI EndSyncSession()
{
    HRESULT hr = E_UNEXPECTED;

    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());
    cCritSect.Enter();

    Assert( g_ObjectMgrData.cNestedStartCalls > 0 );
    Assert( g_ObjectMgrData.eAutoDialState != eQuiescedOn );

    g_ObjectMgrData.cNestedStartCalls--;

    if ( g_ObjectMgrData.cNestedStartCalls == 0 )
    {
        if ( g_ObjectMgrData.eAutoDialState == eAutoDialOn )
            g_ObjectMgrData.eAutoDialState = eQuiescedOn;
        else if ( g_ObjectMgrData.eAutoDialState == eAutoDialOff )
        {
            //
            // Reset autodial state to enabled now that all synch has completed.
            // What to do if hr is set to error code ?
            //
            hr = LokEnableAutoDial();

            g_ObjectMgrData.eAutoDialState = eQuiescedOn;
        }
        //
        // If the state is eQuiescedOff then do nothing
        //
    }

    cCritSect.Leave();

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   ApplySyncItemDialState
//
//  Synopsis:   Set the auto dial requirements of each handler as it is being
//              prepared for syncing.
//
//  Arguments:  [fAutoDialDisable] -- Should autodial be disabled for this
//                                    handler ?
//
//  History:    28-Jul-98       SitaramR        Created
//
//----------------------------------------------------------------------------

STDAPI ApplySyncItemDialState( BOOL fAutoDialDisable )
{
    HRESULT hr = NOERROR;

    CCriticalSection cCritSect(&g_LockCountCriticalSection,GetCurrentThreadId());
    cCritSect.Enter();

    if ( g_ObjectMgrData.fFirstSyncItem )
    {
        //
        // Read whether autodial state is on or off, before we modify it
        //
        GetAutoDialState();

        Assert( g_ObjectMgrData.eAutoDialState == eQuiescedOn
                || g_ObjectMgrData.eAutoDialState == eQuiescedOff );

        if ( g_ObjectMgrData.eAutoDialState == eQuiescedOn )
        {
            if ( fAutoDialDisable )
            {
                hr = LokDisableAutoDial();
                g_ObjectMgrData.eAutoDialState = eAutoDialOff;
            }
            else
                g_ObjectMgrData.eAutoDialState = eAutoDialOn;
        }

        g_ObjectMgrData.fFirstSyncItem = FALSE;
    }
    else
    {
        if ( !fAutoDialDisable
             && g_ObjectMgrData.eAutoDialState == eAutoDialOff )
        {
            hr = LokEnableAutoDial();
            g_ObjectMgrData.eAutoDialState = eAutoDialOn;
        }
    }

    cCritSect.Leave();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSingletonNetApi::~CSingletonNetApi
//
//  Synopsis:   Destructor
//
//  History:    31-Jul-1998     SitaramR        Created
//
//--------------------------------------------------------------------------

CSingletonNetApi::~CSingletonNetApi()
{
    CLock lock(this);
    lock.Enter();

    Assert(NULL == m_pNetApi);

    if ( m_pNetApi != 0 )
    {
        m_pNetApi->Release();
        m_pNetApi = 0;
    }

    lock.Leave();
}


//+-------------------------------------------------------------------------
//
//  Method:     CSingletonNetApi::GetNetApiObj
//
//  Synopsis:   Returns a pointer to NetApi object
//
//  History:    31-Jul-1998     SitaramR        Created
//
//--------------------------------------------------------------------------

LPNETAPI CSingletonNetApi::GetNetApiObj()
{
    CLock lock(this);
    lock.Enter();

    if ( m_pNetApi == 0 )
    {
        if (NOERROR != MobsyncGetClassObject(MOBSYNC_CLASSOBJECTID_NETAPI,(void **) &m_pNetApi))
        {
            m_pNetApi = NULL;
        }
    }

    if ( m_pNetApi )
        m_pNetApi->AddRef();

    lock.Leave();

    return m_pNetApi;
}


void CSingletonNetApi::DeleteNetApiObj()
{
    CLock lock(this);
    lock.Enter();

    if ( m_pNetApi )
    {
    DWORD cRefs;

        cRefs = m_pNetApi->Release();
        Assert(0 == cRefs);

        m_pNetApi = NULL;
    }   

    lock.Leave();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\progtab.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Progtab.cpp
//
//  Contents:   Progress tab
//
//  Classes:
//
//  Notes:		Handle the custom results pane.
//
//  History:    05-Nov-97   Susia      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"
							
extern HINSTANCE g_hInst; // current instance

extern BOOL CALLBACK ProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);
BOOL CALLBACK ResultsProgressWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam);


//--------------------------------------------------------------------------------
//
//  FUNCTION: ListBox_HitTest(HWND hwnd, LONG xPos, LONG yPos)
//
//  PURPOSE:  HitTest for a ListBox, since Windows was nice enough to not provide one
//          This is really a function to see if the hittest falls in the range
//          of the More Info Jump text.
//
//	COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
INT ListBox_HitTest(HWND hwnd, LONG xPos, LONG yPos)
{
int begin = ListBox_GetTopIndex(hwnd);
int end = ListBox_GetCount(hwnd);
int i;
RECT rcRect;

    for (i=begin;i<end;i++)
    {
    LBDATA *pData = NULL;

	if (ListBox_GetItemRect(hwnd, i, &rcRect))
        {
            pData = (LBDATA *) ListBox_GetItemData(hwnd,i);

            if (pData == NULL)
            {
                // if no data then  try the next one
                continue;
            }

            // if textRect not calculated then this isn't visible.
            if (pData->fTextRectValid)
            {
                // only use left and right vars for hit test. top and bottom
                // can change.

                // compare y values first since they are the ones
                // most likely to be different.
	        if (    (yPos >= rcRect.top)	&&
                        (yPos <= rcRect.bottom) &&
                        (xPos >= pData->rcTextHitTestRect.left) &&
                        (xPos <= pData->rcTextHitTestRect.right) )
                {
                    return i;
                }
            }
        }
    }
		
    return -1;
}


//--------------------------------------------------------------------------------
//
//  FUNCTION: OnProgressResultsDrawItem(HWND hwnd, UINT idCtl, LPDRAWITEMSTRUCT lpdis)
//
//  PURPOSE:  Handle DrawItem events for Progress Dialog Results Tab
//
//	COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
BOOL OnProgressResultsDrawItem(HWND hwnd,CProgressDlg *pProgress,UINT idCtl, const DRAWITEMSTRUCT* lpDrawItem)
{
HDC      hdc = lpDrawItem->hDC;
COLORREF clrText, clrBack;
RECT     rcText, rcFocus;
LOGFONT	 lf;
HGDIOBJ  hFont, hFontOld;
HFONT hFontJumpText = NULL;
int nSavedDC;
LBDATA *pData = (LBDATA *) lpDrawItem->itemData;

    if (!hdc || !pData)
    {
        return FALSE;
    }

    nSavedDC = SaveDC(hdc);

    Assert(lpDrawItem->CtlType == ODT_LISTBOX);
    if (lpDrawItem->itemID == -1)
        goto exit;

   clrBack = SetBkColor(hdc, GetSysColor(COLOR_WINDOW));

   // Clear the item for drawing
   // + 1 is just the way you do it for some reason
   FillRect(hdc, &(lpDrawItem->rcItem),
                            (HBRUSH) (COLOR_WINDOW + 1) );


    if (pData->IconIndex != -1)
    {
	    ImageList_Draw(pProgress->m_errorimage,
               pData->IconIndex,
               hdc,
               BULLET_INDENT,
               lpDrawItem->rcItem.top  + BULLET_INDENT,
               ILD_TRANSPARENT);
    }

    // Set up the font, text and background colors
    hFont = (HFONT) SendMessage(hwnd, WM_GETFONT, 0, 0);

    if (hFont)
    {
        Assert(NULL == hFontJumpText);

        if (pData->fIsJump && GetObject(hFont,sizeof(LOGFONT),&lf))
        {
	
	    lf.lfUnderline = TRUE;
            hFontJumpText = CreateFontIndirect(&lf);

            if (hFontJumpText)
            {
	        hFontOld = SelectObject(hdc,hFontJumpText);
            }

        }

        if (!hFontJumpText)
        {
           hFontOld = SelectObject(hdc,hFont);
        }

    }

    // set up colors
    if (pData->fIsJump)
    {
        // even if don't get font change the attribs;
        if (pData->fHasBeenClicked)
	{
	    clrText = SetTextColor(hdc, RGB(128,0,128));
	}
	else
	{
	    clrText = SetTextColor(hdc, RGB(0,0,255));
	}

    }
    else
    {	
	clrText = SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    }

    // calc what the drawText should be. Need to take our stored
    // text value and adjust the top.

    {
        RECT rpDataRect =  pData->rcText;

        rcText = lpDrawItem->rcItem;
        rcText.top = lpDrawItem->rcItem.top + BULLET_INDENT;
        rcText.left +=   rpDataRect.left;
        rcText.right =   rcText.left  +  WIDTH(rpDataRect);
    }

   /* rcText = lpDrawItem->rcItem;
    rcText.left += (pProgress->m_iIconMetricX*3)/2 + BULLET_INDENT; // move over Icon distance
    rcText.top += BULLET_INDENT;
*/
    // draw the text using the TextBox we calc'd in Measure Item
    DrawText(hdc,pData->pszText, -1,
           &rcText,
           DT_NOCLIP | DT_WORDBREAK );

    // If we need a focus rect, do that too
    if (lpDrawItem->itemState & ODS_FOCUS)
    {
        rcFocus = lpDrawItem->rcItem;
      //  rcFocus.left += (pProgress->m_iIconMetricX*3)/2;

        rcFocus.top += BULLET_INDENT;
        rcFocus.left += BULLET_INDENT;
        DrawFocusRect(hdc, &rcFocus);
    }

//    SetBkColor(hdc, clrBack);
 //   SetTextColor(hdc, clrText);

    if (nSavedDC)
    {
        RestoreDC(hdc,nSavedDC);
    }

    if (hFontJumpText)
    {
        DeleteObject(hFontJumpText);
    }


exit:

    return TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: OnProgressResultsMeasureItem(HWND hwnd, CProgressDlg *pProgress, UINT *horizExtent UINT idCtl, MEASUREITEMSTRUCT *pMeasureItem)
//
//  PURPOSE:  Handle MeasureItem events for Progress Dialog Results Tab
//
//	COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
BOOL OnProgressResultsMeasureItem(HWND hwnd,CProgressDlg *pProgress, UINT *horizExtent, UINT /* idCtl */, MEASUREITEMSTRUCT *pMeasureItem)
{
LBDATA *pData = NULL;
HWND hwndList = GetDlgItem(hwnd,IDC_LISTBOXERROR);

    if (!hwndList)
    {
        return FALSE;
    }

    pData = (LBDATA *) ListBox_GetItemData(hwndList, pMeasureItem->itemID);

    if (pData == NULL)
    {
        Assert(pProgress != NULL);
        Assert(pProgress->m_CurrentListEntry != NULL);
        pData = pProgress->m_CurrentListEntry;
    }

    if (pData == NULL)
    {
        return FALSE;
    }

    HFONT hfont = NULL;
    HFONT hFontJumpText = NULL;
    HDC hdc;
    int iHeight;
    int nSavedDC;

    hdc = GetDC(hwndList);

    if (NULL == hdc)
    {
        return FALSE;
    }

    nSavedDC = SaveDC(hdc);

    // Get the size of the string
    hfont = (HFONT) SendMessage(hwnd, WM_GETFONT, 0, 0);

    // if can't get font or jump text font just use the
    // current font.
    if (hfont)
    {
        // if this is jump text then change some
        // font attributes.
        if (pData->fIsJump)
        {
        LOGFONT lf;

            if (GetObject(hfont,sizeof(LOGFONT),&lf))
            {
	        lf.lfUnderline = TRUE;

                 hFontJumpText = CreateFontIndirect(&lf);
            }
        }


        if (hFontJumpText)
        {
            SelectFont(hdc, hFontJumpText);
        }
        else
        {
            SelectFont(hdc, hfont);
        }

    }

    int cxResultsWidth;
    RECT rcRect;

    // GetClientRect seems to subtract off the Scroll Bars for us.
    GetClientRect(hwndList, &rcRect);

    cxResultsWidth = rcRect.right;

    SetRect(&rcRect, 0, 0, cxResultsWidth, 0);

    // subtract off the length of Icon + 1/2
    rcRect.right -=  ((pProgress->m_iIconMetricX*3)/2
            + BULLET_INDENT );

    int tempwidth = rcRect.right;
    iHeight = DrawText(hdc, pData->pszText, -1, &rcRect,
           DT_NOCLIP | DT_CALCRECT | DT_WORDBREAK) + BULLET_INDENT;



    //We have a smegging word in the string wider than the rect.
    if (rcRect.right > tempwidth)
    {
        *horizExtent = cxResultsWidth + (rcRect.right - tempwidth);
   	    // fix up the proper width
        rcRect.right = cxResultsWidth + (rcRect.right - tempwidth);

    }
    else
    {
        rcRect.right = cxResultsWidth;
    }
    rcRect.left +=  ((pProgress->m_iIconMetricX*3)/2
            + BULLET_INDENT );

    // bottom is either the height of the line or if it has
    // an icon the max of these two.
    if (-1 != pData->IconIndex)
    {
        rcRect.bottom = max(iHeight,pProgress->m_iIconMetricY + BULLET_INDENT*2);
    }
    else
    {
        rcRect.bottom = iHeight;
    }

    // if need to add space on the end then do that
    if (pData->fAddLineSpacingAtEnd)
    {
        SIZE Size;

        if (!GetTextExtentPoint(hdc,SZ_SYNCMGRNAME,
                            lstrlen(SZ_SYNCMGRNAME),&Size))
        {
            // if can't get size make up a number
            Size.cy = 13;
        }

        // lets do 2/3 a line spacing.
        rcRect.bottom += (Size.cy*2)/3;

    }


    // store the TextRect in the pData field.
    pMeasureItem->itemHeight = rcRect.bottom;
    pMeasureItem->itemWidth = cxResultsWidth;


    pData->rcText = rcRect;

    pData->fTextRectValid = TRUE;
    pData->rcTextHitTestRect = rcRect;

    if (pData->fIsJump)
    {
    SIZE size;

        // on jump text want the hit test only over the actual text
        // in the horizontal location.
	if(GetTextExtentPoint(hdc,pData->pszText,lstrlen(pData->pszText), &size))
	{
            pData->rcTextHitTestRect.right = size.cx +  pData->rcTextHitTestRect.left;
	}

    }

    if (nSavedDC)
    {
        RestoreDC(hdc,nSavedDC);
    }

    if (hFontJumpText)
    {
        DeleteObject(hFontJumpText);
    }

    ReleaseDC(hwndList, hdc);


    return TRUE;
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: OnProgressResultsDeleteItem(HWND hwnd, UINT idCtl, const DELETEITEMSTRUCT * lpDeleteItem)
//
//  PURPOSE:  Handle DeleteItem events for Progress Dialog Results Tab
//
//	COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
BOOL OnProgressResultsDeleteItem(HWND hwnd,UINT idCtl, const DELETEITEMSTRUCT * lpDeleteItem)
{

   // Assert(lpDeleteItem->itemData);

   if (lpDeleteItem->itemData)
   {
       FREE((LPVOID) lpDeleteItem->itemData);
   }

   return TRUE;
}

void OnProgressResultsSize(HWND hwnd,CProgressDlg *pProgress,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
HWND hwndList = GetDlgItem(hwnd,IDC_LISTBOXERROR);
int iItems = ListBox_GetCount(hwndList);
int iCurItem;
MEASUREITEMSTRUCT measureItem;
RECT rect;

UINT horizExtent = 0;

    SendMessage(hwndList,WM_SETREDRAW,FALSE /*fRedraw */,0);

    GetClientRect(hwndList,&rect);

    for (iCurItem = 0 ; iCurItem < iItems; ++iCurItem)
    {
        measureItem.itemID = iCurItem;

        if (OnProgressResultsMeasureItem(hwnd,pProgress,&horizExtent, -1,&measureItem))
        {
            ListBox_SetItemHeight(hwndList, iCurItem, measureItem.itemHeight);
        }
    }
    //make sure there is a horizontal scroll bar if needed.
    SendMessage(hwndList, LB_SETHORIZONTALEXTENT, horizExtent, 0L);

    SendMessage(hwndList,WM_SETREDRAW,TRUE /*fRedraw */,0);

    InvalidateRect(hwndList,&rect,FALSE);

}

//--------------------------------------------------------------------------------
//
//  FUNCTION: ResultsListBoxWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam)
//
//  PURPOSE:  Callback for Progress Dialog Update Tab
//
//	COMMENTS: Implemented on main thread.
//
//--------------------------------------------------------------------------------
BOOL CALLBACK ResultsListBoxWndProc(HWND hwnd, UINT uMsg,WPARAM wParam,LPARAM lParam)
{
CProgressDlg *pProgressDlg = (CProgressDlg *) GetWindowLongPtr(GetParent(hwnd), DWLP_USER);
                // OUR PARENT HAS A POINTER TO THE progress in dwl_user.

    switch (uMsg)
    {
    case WM_POWERBROADCAST:
	{
        DWORD dwRet = TRUE;

		if (wParam == PBT_APMQUERYSUSPEND)
		{
                // if just created or syncing don't suspend
                    if (pProgressDlg)
                    {

                        if ( (pProgressDlg->m_dwProgressFlags & PROGRESSFLAG_NEWDIALOG)
                            || (pProgressDlg->m_dwProgressFlags & PROGRESSFLAG_SYNCINGITEMS))
                        {
                            dwRet = BROADCAST_QUERY_DENY;
                        }
                    }

                    return dwRet;
                }


	}
	break;

    case WM_SETCURSOR:
        return TRUE; // rely on mousemove to set the cursor.
        break;
    case WM_MOUSEMOVE:
	{
		int index = ListBox_HitTest(hwnd, (LONG) LOWORD(lParam),(LONG) HIWORD(lParam));
		
		LBDATA *lbData =(LBDATA *) ListBox_GetItemData(hwnd, index);

		if (lbData)
                {
		    if ((index != -1) && (lbData->fIsJump))
		    {
			    SetCursor(LoadCursor(g_hInst,MAKEINTRESOURCE(IDC_HARROW)));
		    }
		    else
		    {
			    SetCursor(LoadCursor(NULL,IDC_ARROW));
		    }
                }
	}
	break;
    case WM_KEYDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    {
    int index = -1;
    LBDATA *lbData = NULL;
        // get index either through hittest of selection based on
        // if keydown or not.
        if (uMsg == WM_KEYDOWN)
        {
            if (VK_SPACE == ((int) wParam) )
            {
                index =  ListBox_GetCurSel(hwnd);
            }
            else
            {
                break; // don't mess with any other keys
            }

        }
        else
        {
            index = ListBox_HitTest(hwnd, (LONG) LOWORD(lParam),(LONG) HIWORD(lParam));
        }

        if (-1 != index)
        {
            lbData =(LBDATA *) ListBox_GetItemData(hwnd, index);
        }


        if ((lbData) && (lbData->fIsJump))
	{
		if (pProgressDlg)
		{
                    if (NOERROR == pProgressDlg->OnShowError(lbData->pHandlerID,
				                         hwnd,
				                         lbData->ErrorID))
                    {
                        lbData->fHasBeenClicked = TRUE;
                        RedrawWindow(hwnd, NULL,NULL, RDW_INVALIDATE | RDW_UPDATENOW);
                    }

                return 0;
                }
        }
        break;
    }
    default:
	    break;
    }

    if (pProgressDlg && pProgressDlg->m_fnResultsListBox)
    {
        return (BOOL)CallWindowProc(pProgressDlg->m_fnResultsListBox, hwnd, uMsg, wParam, lParam);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\resource.h ===
//{{NO_DEPENDENCIES}}
//  Copyright (C) Microsoft Corporation, 1999.
// Microsoft Developer Studio generated include file.
// Used by syncmgr.rc
//

#define MAINDIALOG_HWNDCLASSNAME  "SyncMgr_HwndDialog" // class name for our choice/progress dialog


#define IDS_HIDE_DETAILS                1
#define IDC_CHOICELISTVIEW              1
#define IDS_SHOW_DETAILS                2
#define IDS_UPDATETAB                   3
#define IDS_ERRORSTAB                   4
#define IDS_PROGRESSCOMPLETETITLE       5
#define IDS_PROGRESSWORKINGTITLE        6
#define IDS_PROGRESSCOMPLETEOK          7
#define IDS_PROGRESSCOMPLETEERROR       8
#define IDS_PROGRESSCOMPLETEWARNING     9
#define IDS_LISTBOXDESCRIPTION          10
#define IDS_NOITEMS                     11
#define IDS_LAN_CONNECTION              12
#define IDS_NOERRORSREPORTED    	13
#define IDS_SYNCMGRNAME         	14
#define IDS_NUM_ITEMS_COMPLETE  	15
#define IDS_PROGRESSQUERYENDSESSION     16
#define IDS_SETTINGSQUERYENDSESSION     17
#define IDS_HANDLERPROPERTIESQUERYENDSESSION 18
#define IDS_HANDLERSHOWERRORQUERYENDSESSION 19
#define IDS_NULL_HANDLERNOTRESPONDING   20
#define IDS_HANDLERNOTRESPONDING        21
#define IDS_SYNCMGR_ERROR               22

#define IDS_STOP                     	40
#define IDS_CLOSE                     	41

#define IDS_STOPPING                    49
#define IDS_STOPPED                     50
#define IDS_SKIPPED                     51
#define IDS_PENDING                     52
#define IDS_SYNCHRONIZING               53
#define IDS_SUCCEEDED                   54
#define IDS_FAILED                      55
#define IDS_PAUSED                      56
#define IDS_RESUMING                    57
#define IDS_JUMPTEXT                    58

#define IDS_STOPPED_ITEM                60
#define IDS_SKIPPED_ITEM                61
#define IDS_PENDING_ITEM                62
#define IDS_SYNCHRONIZING_ITEM          63
#define IDS_SUCCEEDED_ITEM              64
#define IDS_FAILED_ITEM                 65
#define IDS_PAUSED_ITEM                 66
#define IDS_RESUMING_ITEM               67

#define IDS_CHOICEHANDLERCOLUMN         70
#define IDS_CHOICELASTUPDATECOLUMN      71
#define IDS_PROGRESS_DLG_COLUMN_INFO    72
#define IDS_PROGRESS_DLG_COLUMN_NAME    73
#define IDS_PROGRESS_DLG_COLUMN_STATUS  74

#define IDS_LOGERRORWITHITEMID          80
#define IDS_LOGERRORNOITEMID            81
#define IDS_LOGERRORNOHANDLER           82

#define IDD_PROGRESS                    101
#define IDD_CHOICE                      102
#define IDD_PROPERTY                    111
#define IDD_PROGRESS_UPDATE             119
#define IDD_PROGRESS_RESULTS            120
#define IDI_ICON_ERROR                  121
#define IDI_ICON_INFO                   122
#define IDC_HARROW                      126
#define IDI_OFFLINE                     127
#define IDA_UPDATE                      128
#define IDI_PHONE                       129
#define IDI_SYNCMGR                     132
#define IDI_SETTINGS                    133
#define IDI_ICON1                       135
#define IDI_FOLDOPEN                    139
#define IDC_PROGRESSBAR                 1000
#define IDC_OFFLINEICON                 1002
#define IDC_DETAILS                     1003
#define IDC_SP_SEPARATOR                1004
#define IDC_SKIP_BUTTON                 1006
#define IDC_PROPERTY                    1007
#define IDC_OPTIONS                     1009
#define IDC_CLOSE                       1010
#define IDC_PROGRESS_TABS               1011
#define IDC_DONT_PROMPT                 1012
#define IDC_START                       1013
#define IDC_UPDATE_LIST                 1015
#define IDC_STATIC_SKIP_TEXT            1017
#define IDC_PROGRESS_OPTIONS_BUTTON     1018
#define IDC_STATIC_WHATS_UPDATING       1019
#define IDC_STATIC_HOW_MANY_COMPLETE    1020
#define IDSTOP                          1022
#define IDC_RESULTS_LIST                1023
#define IDC_LISTBOXERROR                1024
#define IDC_UPDATEAVI                   1025
#define IDC_PROGRESSRESIZESCROLLBAR     1026
#define IDC_CONNECTICON                 1027
#define IDC_SYNCHELP                    1028
#define IDC_FOLDER2                     1029
#define IDC_FOLDER1                     1030
#define IDC_RESULTTEXT                  1031
#define IDHIDE                          1032
#define IDC_HIDE                        1033

#define IDC_PROGRESS_OPTIONS_BUTTON_MAIN     1053
#define IDC_SKIP_BUTTON_MAIN                 1054
#define IDC_STATIC_WHATS_UPDATING_INFO       1055
#define IDC_CHOICERESIZESCROLLBAR          1060

#define IDC_STATIC			-1
#define IDC_STATIC1                     1501
#define IDC_STATIC2                     1502
#define IDC_STATIC3                     1503
#define IDC_STATIC4                     1504
#define IDC_STATIC5                     1505

#define IDS_UNDEFINED_ERROR	     2000

// define values for Tray Icons
#define IDI_SYSTRAYINFORMATION          2050
#define IDI_SYSTRAYWARNING              2051
#define IDI_SYSTRAYERROR                2052
#define IDI_SYSTRAYANI1                 2053
#define IDI_SYSTRAYANI2                 2054
#define IDI_SYSTRAYANI3                 2055
#define IDI_SYSTRAYANI4                 2056
#define IDI_SYSTRAYANI5                 2057
#define IDI_SYSTRAYANI6                 2058
#define IDB_PUSHPIN			2059
#define IDC_PUSHPIN			2060
#define IDC_TOOLBAR			2061





// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        140
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1032
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\reg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Reg.h
//
//  Contents:   Registration routines
//
//  Classes:    
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _ONESTOPREG_
#define _ONESTOPREG_


#define GUID_SIZE 128
#define MAX_STRING_LENGTH 256


// public functions
STDMETHODIMP GetLastIdleHandler(CLSID *clsidHandler);
STDMETHODIMP SetLastIdleHandler(REFCLSID clsidHandler);
BOOL  RegSchedHandlerItemsChecked(TCHAR *pszHandlerName, 
                                 TCHAR *pszConnectionName,
                                 TCHAR *pszScheduleName);


#endif // _ONESTOPREG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\h\clsobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       clsobj.h
//
//  Contents:  header MobsyncGetClassObject.
//
//  Classes:
//
//  Notes:
//
//  History:    04-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _MOBSYNC_CLASSOBJ
#define MOBSYNC_CLASSOBJ

typedef enum _tagMOBSYNC_CLASSOBJECTID
{
    MOBSYNC_CLASSOBJECTID_NETAPI        = 0x01,


} MOBSYNC_CLASSOBJECTID;

STDAPI MobsyncGetClassObject(ULONG mobsyncClassObjectId,void **pCObj);


#endif // MOBSYNC_CLASSOBJ
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\h\listview.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       listview.h
//
//  Contents:   Implements Mobsync Custom Listview/TreeView control
//
//  Classes:    CListView
//
//  Notes:
//
//  History:    23-Jul-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _MOBSYNCLISTVIEW_
#define _MOBSYNCLISTVIEW_

/*

    wraps standard ListView control so can do TreeView like operations.

    ItemdId still refers to linear location in the ListView independent
    of who many levels deep the item is 

      Item                          itemID
    toplevel1                           0
        child1                          1
        child2                          2
    toplevel2                           3

    This works fine except causes some confusion on insert. On an insert

    if the LVIFEX_PARENT flag isn't set the item is inserted as it always was
    and indent is the same as the item is is inserted after. For example, if
    if was inserted after toplevel1 it would be a toplevel item. If it was inserted
    after child1 is would be another child of toplevel1

    if the LVIFEX_PARENT flag is set the item is inserted as a child of iParent.
    if the client specified LVI_FIRST, LVI_LAST the item is inserted a first or
    last child. if a normal itemId is specified then it must fall within a valid 
    range to be the specified parents child or the inser fails.

    For example, if I specified a parent of TopLevel1 an itemID of 1,2 or 3 would be valid.
    a vlue of 4 would not be since it would fall outside the child range for toplevel1
*/

#define LVI_ROOT    -1 // itemID to pass in for ParenItemID for root
#define LVI_FIRST   -0x0FFFE
#define LVI_LAST    -0x0FFFF

// The blob field is for perf so a user of the listview doesn't have to
// enumerate, getting the lParam or storing its own lookup for an item.
// when a blob is added the listview makes its own copy and automatically
// frees it when the item is deleted. The blob field is not allowed on subitems.

// define blob structure that app can set and listview 
typedef struct _tagLVBLOB
{
    ULONG cbSize;   // size of the blob struture. !!!Include cbSize itself.
    BYTE  data[1];
} LVBLOB;
typedef LVBLOB* LPLVBLOB;

// state flags for ListView Item check,uncheck conform to real ListView others are our own defines.

// #define LVIS_STATEIMAGEMASK_UNCHECK (0x1000)
// #define LVIS_STATEIMAGEMASK_CHECK (0x2000)

typedef enum _tagLVITEMEXSTATE
{
    // mutually exclusive 
    LVITEMEXSTATE_UNCHECKED		= 0x0000, 
    LVITEMEXSTATE_CHECKED		= 0x0001, 
    LVITEMEXSTATE_INDETERMINATE		= 0x0002, 

} LVITEMSTATE;

// extended flags 
#define LVIFEX_PARENT          0x0001  
#define LVIFEX_BLOB            0x0002

#define LVIFEX_VALIDFLAGMASK   0x0003

// make private LVITEM structure,
// Blob is only allowed on a insert and set.
// parent is only allowed on insert
typedef struct _tagLVITEMEX
{
   // original listviewItem Structure
    UINT mask;
    int iItem;
    int iSubItem;
    UINT state;
    UINT stateMask;
    LPWSTR pszText;
    int cchTextMax;
    int iImage;
    LPARAM lParam;
    int iIndent; // need to add indent to depth

    // new item methods that we need.
    UINT maskEx;
    int iParent;     // set LVIFEX_PARENT maskEx when this field valid. If not LVI_ROOT is assumed.
    LPLVBLOB pBlob;  // set LVIFEX_BLOB maskEx when this field is valid. Currently not returned on a GetItem.
} LVITEMEX, *LPLVITEMEX;

// notification structures for this listview First fields are identical to real listView

typedef struct tagNMLISTVIEWEX{  
    NMLISTVIEW nmListView;

    // specific notification items
    int iParent;     
    LPLVBLOB pBlob;  
} NMLISTVIEWEX, *LPNMLISTVIEWEX;


typedef struct tagNMLISTVIEWEXITEMCHECKCOUNT{  
    NMHDR hdr;;

    // specific notification items
    int iCheckCount;   // new checkCount 
    int iItemId; // ItemIds who checkCount was changed.
    LVITEMSTATE dwItemState; // new state of the item whose checkcount has changed.
} NMLISTVIEWEXITEMCHECKCOUNT, *LPNMLISTVIEWEXITEMCHECKCOUNT;



// notification codes we wrap
#define LVNEX_ITEMCHANGED       LVN_ITEMCHANGED
#define LVNEX_DBLCLK            NM_DBLCLK
#define LVNEX_CLICK             NM_CLICK

// notificaiton codes we send
#define LVNEX_ITEMCHECKCOUNT  (LVN_LAST + 1)  // lparam contains number of items selected in the ListView.

// #define INDEXTOSTATEIMAGEMASK(i) ((i) << 12) (Macro from commctrl.h usefull for setting state)


// itemID is just how far into the list an item is.  We keep a flat list of 
// of items in the same order they are displayed in the ListView. 

// have parent, children pointers just for optimization, Review if really need when done implimenting.
typedef struct _tagListViewItem
{
    // vars for keeping track of tree view status
    struct _tagListViewItem *pSubItems; // ptr to array of subItems for ListView Row.

    // internal vars
    BOOL fExpanded; // true if children are expanded
    int iChildren; // Number of children this node has.

    // native ListView structure and Item
    int iNativeListViewItemId;    // id of Item in acutal listView - If not shown it is set to -1
    LVITEMEX lvItemEx;  // current lvItemEx state for this item
} LISTVIEWITEM;
typedef LISTVIEWITEM* LPLISTVIEWITEM;


class CListView
{
public:
    
    CListView(HWND hwnd,HWND hwndParent,int idCtrl,UINT MsgNotify); // contructor gives in ptr to the listView.
    ~CListView(); 

    // wrappers for top-level ListView calls
    BOOL DeleteAllItems();
    int GetItemCount(); // returns total number of items in the listview.
    UINT GetSelectedCount();
    int GetSelectionMark();
    HIMAGELIST GetImageList(int iImageList);
    HIMAGELIST SetImageList(HIMAGELIST himage,int iImageList);
    void SetExtendedListViewStyle(DWORD dwExStyle); // !!Handle checkboxes ourselves.

    // wrappers for basic listviewItem calls that we support
    // ids are given from our list, not the true ListView id.

    BOOL InsertItem(LPLVITEMEX pitem); 
    BOOL DeleteItem(int iItem);
    BOOL DeleteChildren(int iItem);

    BOOL SetItem(LPLVITEMEX pitem);    
    BOOL SetItemlParam(int iItem,LPARAM lParam);
    BOOL SetItemState(int iItem,UINT state,UINT mask);
    BOOL SetItemText(int iItem,int iSubItem,LPWSTR pszText);

    BOOL GetItem(LPLVITEMEX pitem);    
    BOOL GetItemText(int iItem,int iSubItem,LPWSTR pszText,int cchTextMax);    
    BOOL GetItemlParam(int iItem,LPARAM *plParam);    

    HWND GetHwnd();
    HWND GetParent();
    
    // really helper function for generic set/getitem calls.
    int GetCheckState(int iItem); // return state from LVITEMEXSTATE enum.
    int GetCheckedItemsCount(); // returns the number of checked items. 

    // wrapper for ListView Column Calls
    BOOL SetColumn(int iCol,LV_COLUMN * pColumn);
    int InsertColumn(int iCol,LV_COLUMN * pColumn);
    BOOL SetColumnWidth(int iCol,int cx);
    
    // TreeView like calls

    BOOL Expand(int iItemId);  // expand children of this item,
    BOOL Collapse(int iItemId); // collapse children of this item, 

    // helper functions not impl in either standard ListView or TreeView control
    int FindItemFromBlob(LPLVBLOB pBlob); // returns first toplevel item in list that matches blob
    LPLVBLOB GetItemBlob(int ItemId,LPLVBLOB pBlob,ULONG cbBlobSize);

    // notification method client must call when receives native listview notification
    LRESULT OnNotify(LPNMHDR pnmv); 

private:
    HWND m_hwnd;
    HWND m_hwndParent;
    int m_idCtrl;
    UINT m_MsgNotify;
    LPLISTVIEWITEM m_pListViewItems;        // ptr to the array of listview Items.
    int m_iListViewNodeCount;               // total number of nodes in the listView (Doesn't include SubItems
    int m_iListViewArraySize;               // number of elements allocated in listViewItems array
    int m_iNumColumns;                      // number of columns for this listView
    int m_iCheckCount;                      // not of checked items in the ListView (Does not include indeterminate
    DWORD m_dwExStyle;                      // Extendend Style for this ListView

private:
    LPLISTVIEWITEM ListViewItemFromNativeListViewItemId(int iNativeListViewItemId); // returns ptr to ListViewItem from native ListView ID.
    LPLISTVIEWITEM ListViewItemFromNativeListViewItemId(int iNativeListViewItemId,int iSubItem); // returns ptr to ListViewItem from native ListView ID.
    LPLISTVIEWITEM ListViewItemFromIndex(int iItemID);  //  returns ptr to ListViewItem from internal list.
    LPLISTVIEWITEM ListViewItemFromIndex(int iItemID,int iSubitem,int *piNativeListViewItemId);
    void DeleteListViewItemSubItems(LPLISTVIEWITEM pListItem);
    BOOL ExpandCollapse(LPLISTVIEWITEM pListViewItem,BOOL fExpand);
    BOOL IsEqualBlob(LPLVBLOB pBlob1,LPLVBLOB pBlob2);
    void OnGetDisplayInfo(UINT code,LV_DISPINFO *plvdi);
    void OnSetDisplayInfo(UINT code,LV_DISPINFO *plvdi);
    LRESULT OnCustomDraw(NMCUSTOMDRAW *pnmcd);
    BOOL   OnHandleUIEvent(UINT code,UINT flags,WORD wVKey,int iItemNative);

};

#endif // _MOBSYNCLISTVIEW_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\h\alloc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Alloc.h
//
//  Contents:   Allocation routines
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _ONESTOPALLOC_
#define _ONESTOPALLOC_

inline void* __cdecl operator new (size_t size);
inline void __cdecl operator delete(void FAR* lpv);

extern "C" void __RPC_API MIDL_user_free(IN void __RPC_FAR * ptr);
extern "C" void __RPC_FAR * __RPC_API MIDL_user_allocate(IN size_t len);


LPVOID ALLOC(ULONG cb);
void FREE(void* pv);
LPVOID REALLOC(void *pv,ULONG cb);


#define ADDENTRY(lpv,size)
#define FREEENTRY(lpv)
#define WALKARENA()

#ifdef _DEBUG

#define MEMINITVALUE 0xff
#define MEMFREEVALUE 0xfe

// set to 1 to turn enable leak detection on, 0 for off.
// must also set regkey DWORD value
// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Syncmgr\debug\LeakDetection = 1

#define MEMLEAKDETECTION 1

#if MEMLEAKDETECTION

typedef struct _MemArena{
    DWORD   Free;
    void    *lpv;
    ULONG   size;
    ULONG  Order;
}MEMARENA, *LPMEMARENA;


// memory leak detection apis
void AddEntry( void *lpv, unsigned long size);
void FreeEntry ( void *lpv );
void WalkArena();

#undef ADDENTRY
#undef FREEENTRY
#undef WALKARENA

#define ADDENTRY(lpv,size) AddEntry(lpv,size)
#define FREEENTRY(lpv) FreeEntry(lpv)
#define WALKARENA() WalkArena()
#endif // MEMLEAKDETECTION

#endif // DEBUG


#endif // _ONESTOPALLOC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\h\debug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Debug.h
//
//  Contents:   Debug Routines
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _ONESTOPDEBUG_
#define _ONESTOPDEBUG_


#define _SENS 1

#if (DBG == 1)
#undef DEBUG
#undef _DEBUG

#define DEBUG 1
#define _DEBUG 1

#endif // DGB

#define ErrJmp(label, errval, var) \
{\
    var = errval;\
    goto label;\
}
#define smBoolChk(e) if (!(e)) {return FALSE;} else 1

#define smErr(l, e) ErrJmp(l, e, sc)
#define smChkTo(l, e) if (ERROR_SUCCESS != (sc = (e))) smErr(l, sc) else 1
#define smChk(e) smChkTo(EH_Err, e)
#define smHChk(e) smHChkTo(EH_Err, e)
#define smMemTo(l, e) \
    if ((e) == NULL) smErr(l, E_OUTOFMEMORY) else 1
#define smMem(e) smMemTo(EH_Err, e)

#define _ZAWTRACK 0 // current ZAW Trackingis off, set this to 1 to turn on

#if _ZAWTRACK

// definitions for ZAW tracking.
typedef BOOL (STDAPICALLTYPE *PFNONESTOPTRK)(DWORD dwFlags);
void InitZawTrack();
void UninitZawTrack();
void LogZawTrack(DWORD dwFlags);

#endif // _ZAWTRACK

#if DEBUG

STDAPI_(void) InitDebugFlags(void);
STDAPI FnAssert( LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine );
STDAPI FnTrace(LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine );

#undef Assert
#undef AssertSz
#undef Puts
#define Assert(a) { if (!(a)) FnAssert(#a, NULL, __FILE__, __LINE__); }
#define AssertSz(a, b) { if (!(a)) FnAssert(#a, b, __FILE__, __LINE__); }
#define Puts(s) OutputDebugStringA(s)

#undef TRACE
#define TRACE(s)  /* FnTrace(s,__FILE__,__LINE__) */ // tracing isn't turned on by default
#define DEBUG_OUT_LASTERROR /* OutputDebugStringA(s) */ // debug out isn't turned on by default


#else // !DEBUG

#define Assert(a)
#define AssertSz(a, b)
#define Puts(s)

#define TRACE(s)
#define DEBUG_OUT_LASTERROR

#endif  // DEBUG


#endif // _ONESTOPDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\h\critsect.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       critsect.h
//
//  Contents:   critical section helper class
//
//  Classes:    CCriticalSection
//		CLockHandler
//		CLock
//		
//
//  Notes:      
//
//  History:    13-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------



#ifndef _CRITSECT_
#define _CRITSECT_

#include "widewrap.h"

class CLock;

class CCriticalSection 
{
DWORD cRefs;
CRITICAL_SECTION *m_pcsect;
DWORD m_dwThreadID;

public:
    inline CCriticalSection(CRITICAL_SECTION *pcsect,DWORD dwThreadID)
    {	
	m_pcsect = pcsect;
	cRefs = 0;
	m_dwThreadID = dwThreadID;
    };


    inline ~CCriticalSection()
    {
	AssertSz(0 == cRefs,"UnReleased Critical Section");
	Assert(m_dwThreadID == GetCurrentThreadId());

	while(cRefs--) // unwind any left over cRefs
	{
	    LeaveCriticalSection(m_pcsect);
	}

    };

    inline void Enter()
    {
	EnterCriticalSection(m_pcsect);

	Assert(m_dwThreadID == GetCurrentThreadId());
	++cRefs;

	Assert(1 == cRefs); // we don't allow nested calls.
    };

    inline void Leave()
    {
	Assert(m_dwThreadID == GetCurrentThreadId());
	Assert(0 < cRefs);

	if (0 >= cRefs)
	    return;

	--cRefs;
	Assert(0 == cRefs);

	LeaveCriticalSection(m_pcsect);
    };

};


class CLockHandler {

public:
    CLockHandler();
    ~CLockHandler();

    void Lock(DWORD dwThreadId); 
    void UnLock();
    inline DWORD GetLockThreadId() { return m_dwLockThreadId; };

private:
    CRITICAL_SECTION m_CriticalSection; // critical section for the queue.
    DWORD m_dwLockThreadId; // thread that has the lock.

    friend CLock;
};


// helper class for making sure locks on the queue are released.
class CLock 
{
DWORD cRefs;
CLockHandler *m_pLockHandler;
DWORD m_dwThreadID;

public:
    inline CLock(CLockHandler *pLockHandler)
    {	
	m_pLockHandler = pLockHandler;
	cRefs = 0;
	m_dwThreadID = GetCurrentThreadId();
    };


    inline ~CLock()
    {
	AssertSz(0 == cRefs,"UnReleased Lock");
	Assert(m_dwThreadID == GetCurrentThreadId());

	while(cRefs--) // unwind any left over cRefs
	{
	    m_pLockHandler->UnLock();
	}

    };

    inline void Enter()
    {
	Assert(m_dwThreadID == GetCurrentThreadId());

	++cRefs;
	Assert(1 == cRefs); // we don't allow nested calls.
	m_pLockHandler->Lock(m_dwThreadID);
    };

    inline void Leave()
    {
	Assert(m_dwThreadID == GetCurrentThreadId());
	Assert(0 < cRefs);

	if (0 >= cRefs)
	    return;

	--cRefs;
	Assert(0 == cRefs);
	m_pLockHandler->UnLock();

    };

};


#define ASSERT_LOCKHELD(pLockHandler) Assert(pLockHandler->GetLockThreadId() == GetCurrentThreadId());
#define ASSERT_LOCKNOTHELD(pLockHandler) Assert(pLockHandler->GetLockThreadId() == 0);

// helper class for Mutex locking

class CMutex 
{
HANDLE m_hMutex;
BOOL m_fHasLock;
BOOL m_fReleasedLock;

public:
    inline CMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes,BOOL bInitialOwner,LPCTSTR lpName)
    {	
	 m_hMutex = CreateMutex(lpMutexAttributes,bInitialOwner,lpName);

         // on failure routines go on just don't take the lock

         m_fHasLock = FALSE;
         m_fReleasedLock = FALSE;
    };


    inline ~CMutex()
    {
	AssertSz(!m_fHasLock,"UnReleased Mutex ");

        // if failed to release mutex release now.
        if (m_hMutex && m_fHasLock)
        {
	    ReleaseMutex(m_hMutex);
        }        
        if (m_hMutex)
        {
            CloseHandle(m_hMutex);
        }
    };

    inline void Enter(DWORD dwMilliseconds = INFINITE)
    {
	AssertSz(!m_fHasLock,"Tried to take Lock Twice");
        AssertSz(!m_fReleasedLock,"Tried to take lock After Released Mutex");

        if (!m_fHasLock && m_hMutex)
        {
            if (WAIT_OBJECT_0 ==WaitForSingleObject( m_hMutex, dwMilliseconds ))
            {
                m_fHasLock = TRUE;
            }
        }
    
    };

    inline void Leave()
    {
        Assert(m_fHasLock);

        if (m_fHasLock && m_hMutex)
        {
	    ReleaseMutex(m_hMutex);
        }
        
        if (m_hMutex)
        {
            CloseHandle(m_hMutex);
        }
        m_hMutex = NULL;
        m_fHasLock = FALSE;
        m_fReleasedLock = TRUE;

    };


};



#endif // _CRITSECT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\exe\winmain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       OneStop.cpp
//
//  Contents:   Main application
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "precomp.h"

// Global Variables:
HINSTANCE g_hInst = NULL;      // current instance
OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo, setup by WinMain.
LANGID g_LangIdSystem;      // LangId of system we are running on.
DWORD g_WMTaskbarCreated; // TaskBar Created WindowMessage;

// HACCEL  hAccelTable = NULL; // currently don't have any accelerators.

// Foward declarations of functions included in this code module:

BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow,CMsgServiceHwnd *pMsgService);
void UnitApplication();
BOOL SetupUserEnvironment();


//+---------------------------------------------------------------------------
//
//  Function:	WinMain, public
//
//  Synopsis:   The start of all things
//
//  Arguments:  Standard WinMain.
//
//  Returns:
//
//  Modifies:
//
//  History:    18-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

#ifdef _DEBUG
extern DWORD g_ThreadCount;
#endif // _DEBUG

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
MSG msg;
CMsgServiceHwnd *pMsgService;
BOOL fMsgServiceCreated = FALSE;
HRESULT hr;

   g_hInst = hInstance; // Store instance handle in our global variable

#ifdef _DEBUG
   InitDebugFlags();
#endif // _DEBUG

   g_OSVersionInfo.dwOSVersionInfoSize = sizeof(g_OSVersionInfo);
   if (!GetVersionExA(&g_OSVersionInfo))
   {
       AssertSz(0,"Unable to GetOS Version");
       return FALSE; // bail if can't get OSVersion
   }

   BOOL fOSUnicode =  (VER_PLATFORM_WIN32_NT == g_OSVersionInfo.dwPlatformId) ? TRUE : FALSE;

   InitCommonLib(fOSUnicode);
   g_LangIdSystem = GetSystemDefaultLangID();

   SetupUserEnvironment();

   if (!hPrevInstance) {
      // Perform instance initialization:
      if (!InitApplication(hInstance)) {
         return (FALSE);
      }
   }

#if _ZAWTRACK
   InitZawTrack();
#endif _ZAWTRACK


   hr = CoInitializeEx(NULL,COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE); // main thread is freeThreaded
   if (FAILED(hr))
   {
       AssertSz(0,"CoInitFailed");
       return FALSE;
   }

    // Initialize the Message Service for all threads
   if (NOERROR != InitMessageService())
   {
      AssertSz(0,"Unable to Init Message Service");
      return FALSE;
   }


   // crate a MessageService for main thread
   pMsgService = new CMsgServiceHwnd;
   if (NULL != pMsgService)
   {
	fMsgServiceCreated = pMsgService->Initialize(GetCurrentThreadId(),MSGHWNDTYPE_MAINTHREAD);
        Assert(fMsgServiceCreated);
   }

    if (fMsgServiceCreated && InitInstance(hInstance, nCmdShow,pMsgService))
    {
       // hAccelTable = LoadAccelerators (hInstance, APPNAME); // Currently don't have any accelerators

       // Main message loop:
       while (GetMessage(&msg, NULL, 0, 0))
       {
	    if (1 /* !TranslateAccelerator(msg.hwnd,hAccelTable, &msg) */)
	    {
		 TranslateMessage(&msg);
		 DispatchMessage(&msg);
	    }
       }
    }
    else
    {
	msg.wParam = 0;

	if (pMsgService) // get rid of this threads messageService
	    pMsgService->Destroy();

    }


   UnitApplication();  // unitialize application.

   return (int)(msg.wParam);

   lpCmdLine; // This will prevent 'unused formal parameter' warnings
}

//+---------------------------------------------------------------------------
//
//  Function:	InitApplication, public
//
//  Synopsis:   Peforms any application specific tasks
//
//  Arguments:  [hInstance] - hInstance.
//
//  Returns:
//
//  Modifies:
//
//  History:    18-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL InitApplication(HINSTANCE hInstance)
{
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:	UnitApplication, public
//
//  Synopsis:   Peforms any application specific cleanup
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    19-Jun-98      rogerg        Created.
//
//----------------------------------------------------------------------------

void  UnitApplication()
{
   ReleaseConnectionObjects(); // release global connection object class.

   gSingleNetApiObj.DeleteNetApiObj(); // get rid of globa NetObj

   Assert(g_ThreadCount == 0); // make sure all our threads are cleaned up.

   CoFreeUnusedLibraries();
   CoUninitialize();

   UnInitCommonLib();

#if _ZAWTRACK
   UninitZawTrack();
#endif _ZAWTRACK

   WALKARENA(); // check for memleaks
}


//+---------------------------------------------------------------------------
//
//  Function:	InitInstance, public
//
//  Synopsis:   Peforms instance specific initialization
//
//  Arguments:  [hInstance] - hInstance.
//		[nCmdShow] - value to start windows as
//		[pMsgService] - Message service for this instance
//
//  Returns:    TRUE will put application into a message loop
//		FALSE will cause application to terminate immediately
//
//  Modifies:
//
//  History:    18-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow,CMsgServiceHwnd *pMsgService)
{
HRESULT hr;
CCmdLine cmdLine;
DWORD cmdLineFlags;
BOOL fEmbeddingFlag;
ATOM aWndClass;


   g_WMTaskbarCreated = RegisterWindowMessage(L"TaskbarCreated"); // get taskbar created message.

   cmdLine.ParseCommandLine();
   cmdLineFlags = cmdLine.GetCmdLineFlags();
   fEmbeddingFlag = cmdLineFlags & CMDLINE_COMMAND_EMBEDDING;

   //register a windows class to store the icon for the OneStop dialogs
   //get an icon for the dialog
    WNDCLASS wc;
    wc.style = CS_DBLCLKS | CS_SAVEBITS | CS_BYTEALIGNWINDOW;


    // if unicode use the wide version of the def else use the ANSI
     wc.lpfnWndProc = WideWrapIsUnicode()  ?  DefDlgProcW : DefDlgProcA;

    // WRAPPER, need wrappers for LoadIcon/LoadCursor.
    wc.cbClsExtra = 0;
    wc.cbWndExtra = DLGWINDOWEXTRA;
    wc.hInstance = g_hInst;
    wc.hIcon = LoadIconA(g_hInst,(LPSTR) MAKEINTRESOURCE(IDI_SYNCMGR));
    wc.hCursor = LoadCursorA(NULL,(LPSTR) IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = TEXT(MAINDIALOG_HWNDCLASSNAME);

    aWndClass = RegisterClass(&wc);

    Assert(aWndClass);

   // if register flag is passed, just register and return.
   if (cmdLineFlags & CMDLINE_COMMAND_REGISTER)
   {
       AssertSz(0,"SyncMgr launched with obsolete /register flag.");
       return FALSE;
   }


   INITCOMMONCONTROLSEX controlsEx;
   controlsEx.dwSize = sizeof(INITCOMMONCONTROLSEX);
   controlsEx.dwICC = ICC_USEREX_CLASSES | ICC_WIN95_CLASSES | ICC_NATIVEFNTCTL_CLASS;
   InitCommonControlsEx(&controlsEx);

   hr = InitObjectManager(pMsgService); // Initialize Object manager
   if (NOERROR != hr)
   {
       Assert(NOERROR == hr);
       return FALSE;
   }

   hr = InitConnectionObjects(); // initialize connection objects.
   if (NOERROR != hr)
   {
       Assert(NOERROR == hr);
       return FALSE;
   }

   // If the embedding flag is set force a Register.
   // Review - Activate as Interactive user doesn't work for Logoff

   // don't register class factory for schedules or Idle since if an error occurs
   // we want TS to launch us again next time it is time for the
   // schedule to Fire.

   if (!(cmdLineFlags & CMDLINE_COMMAND_SCHEDULE)
        && !(cmdLineFlags & CMDLINE_COMMAND_IDLE))
   {
      hr = RegisterOneStopClassFactory(fEmbeddingFlag);
   }
   else
   {
      hr = NOERROR;
   }


   // if didn't force a register then continue on our journey
   // and wait to fail until CoCreateInstance does

   Assert(NOERROR == hr || !fEmbeddingFlag);

   if (NOERROR == hr || !fEmbeddingFlag )
   {

 	// if only /Embedding is specified we were launch to service someone else so
        // dont' do anything, just wait for them to connect.

       if (!fEmbeddingFlag)
       {
	LPPRIVSYNCMGRSYNCHRONIZEINVOKE pUnk;

	   // If there are other command lines or known to the proper thing. (manual, schedule, etc.).
	
            // addref our lifetime in case update doesn't take, treat as external
            // since invoke can go to another process.
	    AddRefOneStopLifetime(TRUE /*External*/);

	    // if class factory registered successful then CoCreate
             
            if (SUCCEEDED(hr))
            {
                hr = CoCreateInstance(CLSID_SyncMgrp,NULL,CLSCTX_ALL,
			IID_IPrivSyncMgrSynchronizeInvoke,(void **) &pUnk);
            }

            // if have failure either from class factory or CoCreateIntance
            // then create a class directlry.
	    if (FAILED(hr))
	    {
                // this is really an error path that shouldn't happen.
                // AssertSz(SUCCEEDED(hr),"COM Activation Failed");


                // If COM Activation Fails go ahead and create a class directly
                // unless it is a schedule or idle event.
                if ( !(cmdLineFlags & CMDLINE_COMMAND_SCHEDULE)
                    && !(cmdLineFlags & CMDLINE_COMMAND_IDLE) )
                {
		    pUnk = new CSynchronizeInvoke;
		    hr = pUnk ? NOERROR : E_OUTOFMEMORY;

		    // Assert(NOERROR == hr);
                }
	    }

	    if (NOERROR == hr)
	    {

                AllowSetForegroundWindow(ASFW_ANY); // let mobsync.exe come to front if necessary

		if (cmdLineFlags & CMDLINE_COMMAND_LOGON)
		{
		    pUnk->Logon();
		}
		else if (cmdLineFlags & CMDLINE_COMMAND_LOGOFF)
		{
		    pUnk->Logoff();
		}
		else if (cmdLineFlags & CMDLINE_COMMAND_SCHEDULE)
		{
		    pUnk->Schedule(cmdLine.GetJobFile());
		}
		else if (cmdLineFlags & CMDLINE_COMMAND_IDLE)
		{
		    pUnk->Idle();
		}
		else
		{
		    // default is a manual sync
		    pUnk->UpdateAll();
		}

    		pUnk->Release();
            }
	    else
	    {
		// AssertSz(0,"Unable to Create Invoke Instance");
	    }

	    ReleaseOneStopLifetime(TRUE /*External*/); // Release our reference.

       }


	return TRUE; // even on failure return true, locking will take care of releasing object.
   }

   return (FALSE); // if couldn't forward the update then end.
}

//+---------------------------------------------------------------------------
//
//  Function:	SetupUserEnvironment,private
//
//  Synopsis:   Sets up any use environment variables we need to run.
//
//              When we are launched as interactive User by DCOM the
//              environment variables aren't set so we need to set
//              any up that us or the handlers rely on.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    14-Aug-98      rogerg        Created.
//
//----------------------------------------------------------------------------

#define SZ_ENVIRONVARIABLE_USERPROFILE TEXT("USERPROFILE")
#define SZ_ENVIRONVARIABLE_USERNAME TEXT("USERNAME")

BOOL SetupUserEnvironment()
{
HANDLE  hToken = NULL;
BOOL fValidToken;
BOOL fSetEnviron = FALSE;
BOOL fSetUserName = FALSE;


    // only need to setup the user environment if we are on NT
    if (VER_PLATFORM_WIN32_NT != g_OSVersionInfo.dwPlatformId)
    {
        return TRUE;
    }

   // setup the User Profile Dir
    fValidToken = TRUE;
    if (!OpenThreadToken (GetCurrentThread(), TOKEN_READ,TRUE, &hToken))
    {
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_READ,
                              &hToken))
        {
            AssertSz(0,"Failed to GetToken");
            fValidToken = FALSE;
        }
    }

   if (fValidToken)
   {
   DWORD cbSize;

       // Call GetUserProfile once for Size and then again for real allocation
       cbSize = 0;
       GetUserProfileDirectory(hToken,NULL,&cbSize);

       if (cbSize > 0)
       {
       WCHAR *pwszProfileDir = (WCHAR *) ALLOC(cbSize*sizeof(WCHAR));

           if (pwszProfileDir && GetUserProfileDirectory(hToken,pwszProfileDir,&cbSize))
           {
               fSetEnviron = SetEnvironmentVariable(SZ_ENVIRONVARIABLE_USERPROFILE,pwszProfileDir);
           }

           if (pwszProfileDir)
           {
               FREE(pwszProfileDir);
           }
       }

       Assert(fSetEnviron); // assert if anything fails when we have a valid token

       CloseHandle(hToken);
   }

   // setup the UserName
   TCHAR szBuffer[UNLEN + 1];
   DWORD dwBufSize = sizeof(szBuffer)/sizeof(TCHAR);

   if (GetUserName(szBuffer,&dwBufSize))
   {
	fSetUserName = SetEnvironmentVariable(SZ_ENVIRONVARIABLE_USERNAME,szBuffer);
	Assert(fSetUserName);
   }

   return (fSetEnviron && fSetUserName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\h\osdefine.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:	osdefine.h
//
//  Contents:	Generic header OneStop defines
//
//  History:	24-Oct-97	SusiA	Created
//
//----------------------------------------------------------------------------

#ifndef __OSDEFINE_H__
#define __OSDEFINE_H__


#define LVIS_STATEIMAGEMASK_CHECK (0x2000)
#define LVIS_STATEIMAGEMASK_UNCHECK (0x1000)

#define MAX_STRING_RES					64
#define MAX_ERR0R_ICONS					20
#define BULLET_INDENT					 2

#ifndef ILC_MIRROR
#define ILC_MIRROR              0x2000 
#endif // ILC_MIRROR

#endif __OSDEFINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\h\netapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       netapi.h
//
//  Contents:   Network/SENS API wrappers
//
//  Classes:
//
//  Notes:
//
//  History:    08-Dec-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _SYNCMGRNETAPI_
#define _SYNCMGRNETAPI_

#include <ras.h>
#include <raserror.h>
#include <wininet.h>

#ifdef _SENS
#include <eventsys.h> // EventSystem Headers
#include <sens.h>
#endif // _SENS

#ifndef NETWORK_ALIVE_LAN
#define NETWORK_ALIVE_LAN   0x00000001
#endif // NETWORK_ALIVE_LAN

#ifndef NETWORK_ALIVE_WAN
#define NETWORK_ALIVE_WAN   0x00000002
#endif // NETWORK_ALIVE_WAN


#define CNETAPI_CONNECTIONTYPEUNKNOWN   0x00
#define CNETAPI_CONNECTIONTYPELAN       0x01
#define CNETAPI_CONNECTIONTYPEWAN       0x02


//
// When INTERNET_OPTION_AUTODIAL is available, remove this definition
//
#ifndef INTERNET_OPTION_DISABLE_AUTODIAL
#define INTERNET_OPTION_DISABLE_AUTODIAL  70
#endif // INTERNET_OPTION_DISABLE_AUTODIAL

#define RASERROR_MAXSTRING 256


// interface delcaration so can get at
// NetApi through MobsyncGetClassObject

interface  INetApi : public IUnknown
{
    // SENS Methods
    virtual STDMETHODIMP_(BOOL) IsSensInstalled(void) = 0;
    virtual STDMETHODIMP_(BOOL) IsNetworkAlive(LPDWORD lpdwFlags) = 0;
    
    virtual STDMETHODIMP GetWanConnections(DWORD *cbNumEntries,RASCONN **pWanConnections) = 0;
    virtual STDMETHODIMP FreeWanConnections(RASCONN *pWanConnections) = 0;
    virtual STDMETHODIMP GetConnectionStatus(LPCTSTR pszConnectionName,DWORD ConnectionType,BOOL *fConnected,BOOL *fCanEstablishConnection) = 0;
    virtual STDMETHODIMP_(DWORD) RasEnumConnections(LPRASCONNW lprasconn,LPDWORD lpcb,LPDWORD lpcConnections) = 0;
    virtual STDMETHODIMP RasGetAutodial( BOOL& fEnabled ) = 0;
    virtual STDMETHODIMP RasSetAutodial( BOOL fEnabled ) = 0;
    virtual STDMETHODIMP_(DWORD) RasGetErrorStringProc( UINT uErrorValue, LPTSTR lpszErrorString,DWORD cBufSize) = 0;
    virtual STDMETHODIMP_(DWORD) RasEnumEntries(LPWSTR reserved,LPWSTR lpszPhoneBook,
                    LPRASENTRYNAME lprasEntryName,LPDWORD lpcb,LPDWORD lpcEntries) = 0;
  
    // ConvertGid, GetEntryProps only support on NT 5.0
    virtual STDMETHODIMP RasConvertGuidToEntry(GUID *pGuid,LPWSTR lpszEntry,RASENTRY *pRasEntry) = 0;


    // methods for calling wininet
    virtual STDMETHODIMP_(DWORD) InternetDialA(HWND hwndParent,char* lpszConnectoid,DWORD dwFlags,
                                                    LPDWORD lpdwConnection, DWORD dwReserved) = 0;
    virtual STDMETHODIMP_(DWORD)InternetDialW(HWND hwndParent,WCHAR* lpszConnectoid,DWORD dwFlags,
                                                    LPDWORD lpdwConnection, DWORD dwReserved) = 0;
    virtual STDMETHODIMP_(DWORD)InternetHangUp(DWORD dwConnection,DWORD dwReserved) = 0;
    virtual STDMETHODIMP_(BOOL) InternetAutodial(DWORD dwFlags,DWORD dwReserved) = 0;
    virtual STDMETHODIMP_(BOOL) InternetAutodialHangup(DWORD dwReserved) = 0;
    virtual STDMETHODIMP  InternetGetAutodial( BOOL& fEnabled ) = 0;
    virtual STDMETHODIMP  InternetSetAutodial( BOOL fEnabled ) = 0;
    virtual STDMETHODIMP_(BOOL) IsGlobalOffline(void) = 0;
    virtual STDMETHODIMP_(BOOL) SetOffline(BOOL fOffline) = 0;

};
typedef INetApi *LPNETAPI;

STDAPI ResetNetworkIdle();


#endif // _SYNCMGRNETAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\h\validate.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       validate.h
//
//  Contents:   validation routines
//
//  Classes:
//
//  Notes:
//
//  History:    13-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifndef _MOBSYNCVALIDATE_
#define _MOBSYNCVALIDATE_

BOOL IsValidSyncMgrItem(SYNCMGRITEM *poffItem);
BOOL IsValidSyncMgrHandlerInfo(LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo);
BOOL IsValidSyncProgressItem(LPSYNCMGRPROGRESSITEM lpProgItem);
BOOL IsValidSyncLogErrorInfo(DWORD dwErrorLevel,const WCHAR *lpcErrorText,
                                        LPSYNCMGRLOGERRORINFO lpSyncLogError);

#endif // _MOBSYNCVALIDATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\lib\critsect.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       critsect.cpp
//
//  Contents:   critical section helper class
//
//  Classes:    CCriticalSection
//		CLockHandler
//		CLock
//		
//
//  Notes:      
//
//  History:    13-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "lib.h"

//+---------------------------------------------------------------------------
//
//  Member:     CLockHandler::CLockHandler, public
//
//  Synopsis:   Constructor
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CLockHandler::CLockHandler()
{
    m_dwLockThreadId = 0;
    InitializeCriticalSection(&m_CriticalSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLockHandler::~CLockHandler, public
//
//  Synopsis:   Destructor
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

CLockHandler::~CLockHandler()
{
    Assert (0 == m_dwLockThreadId);
    DeleteCriticalSection(&m_CriticalSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLockHandler::Lock, public
//
//  Synopsis:   Adds a lock to the specified class
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CLockHandler::Lock(DWORD dwThreadId)
{ 
    EnterCriticalSection(&m_CriticalSection); 

    m_dwLockThreadId = dwThreadId;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLockHandler::UnLock, public
//
//  Synopsis:   Removes a lock to the specified class
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void CLockHandler::UnLock()
{ 
    m_dwLockThreadId = 0;
    LeaveCriticalSection(&m_CriticalSection); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\h\widewrap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       widewrap.h
//
//  Contents:   Wrapper functions for Win32c API used by 32-bit OLE 2
//
//  History:    12-27-93   ErikGav   Created
//              06-14-94   KentCe    Various Chicago build fixes.
//
//----------------------------------------------------------------------------

#ifndef _WIDEWRAP_H_
#define _WIDEWRAP_H_

#include <objbase.h>
#include <commctrl.h>
#include <shellapi.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _UNICODE // temporary so can turn of files not yet converted

void InitCommonLib(BOOL fUnicode);
void UnInitCommonLib(void);
BOOL WideWrapIsUnicode();

BOOL 
GetUserTextualSid(
    LPTSTR TextualSid,  // buffer for Textual representaion of Sid
    LPDWORD cchSidSize  // required/provided TextualSid buffersize
    );


#undef  WNDCLASS
#define WNDCLASS WNDCLASSW
#define WNDCLASST WNDCLASSA

#undef  STARTUPINFO
#define STARTUPINFO STARTUPINFOW

#undef  WIN32_FIND_DATA
#define WIN32_FIND_DATA WIN32_FIND_DATAW


int AnsiToUnicodeOem(LPWSTR pwsz, LPCSTR sz, LONG cb);

int LoadStringX(  HINSTANCE hInstance,UINT uID, LPWSTR lpBuffer,int nBufferMax);

#undef  LoadString
#define LoadString LoadStringX


HANDLE
WINAPI
CreateFileX(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

#undef  CreateFile
#define CreateFile CreateFileX
#define CreateFileT CreateFileA

BOOL
WINAPI
ExpandEnvironmentStringsX(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    );

#undef  ExpandEnvironmentStrings
#define ExpandEnvironmentStrings ExpandEnvironmentStringsX
#define ExpandEnvironmentStringsT ExpandEnvironmentStringsA

BOOL
WINAPI
DeleteFileX(
    LPCWSTR lpFileName
    );

#undef  DeleteFile
#define DeleteFile DeleteFileX
#define DeleteFileT DeleteFileA

UINT
WINAPI
RegisterClipboardFormatX(
    LPCWSTR lpszFormat);

#undef  RegisterClipboardFormat
#define RegisterClipboardFormat RegisterClipboardFormatX
#define RegisterClipboardFormatT RegisterClipboardFormatA

int
WINAPI
GetClipboardFormatNameX(
    UINT format,
    LPWSTR lpszFormatName,
    int cchMaxCount);

#undef  GetClipboardFormatName
#define GetClipboardFormatName GetClipboardFormatNameX
#define GetClipboardFormatNameT GetClipboardFormatNameA

LONG
APIENTRY
RegOpenKeyX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

#undef  RegOpenKey
#define RegOpenKey RegOpenKeyX
#define RegOpenKeyT RegOpenKeyA

LONG
APIENTRY
RegQueryValueX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpValue,
    PLONG   lpcbValue
    );

#undef  RegQueryValue
#define RegQueryValue RegQueryValueX
#define RegQueryValueT RegQueryValueA
LONG
APIENTRY
RegSetValueX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    );

#undef  RegSetValue
#define RegSetValue RegSetValueX
#define RegSetValueT RegSetValueA


LONG
APIENTRY
RegDeleteValueX (
    HKEY hKey,
    LPCWSTR lpValueName
    );

#undef  RegDeleteValue
#define RegDeleteValue RegDeleteValueX

LONG
APIENTRY
RegSetValueExX(
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

#undef  RegSetValueEx
#define RegSetValueEx RegSetValueExX

LONG
APIENTRY
RegCreateKeyExXp(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL fSetSecurity);
 
LONG
APIENTRY
RegCreateKeyExX(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

#undef  RegCreateKeyEx
#define RegCreateKeyEx RegCreateKeyExX

UINT
WINAPI
RegisterWindowMessageX(
    LPCWSTR lpString);

#undef  RegisterWindowMessage
#define RegisterWindowMessage RegisterWindowMessageX
#define RegisterWindowMessageT RegisterWindowMessageA

LONG
APIENTRY
RegOpenKeyExXp(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult,
    BOOL fSetSecurity);

LONG
APIENTRY
RegOpenKeyExX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

#undef  RegOpenKeyEx
#define RegOpenKeyEx RegOpenKeyExX
#define RegOpenKeyExT RegOpenKeyExA

LONG
APIENTRY
RegQueryValueExX (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

#undef  RegQueryValueEx
#define RegQueryValueEx RegQueryValueExX
#define RegQueryValueExT RegQueryValueExA

BOOL GetUserNameX(
    LPWSTR lpBuffer,
    LPDWORD nSize
);

#undef  GetUserName
#define GetUserName GetUserNameX

HWND
WINAPI
CreateWindowExX(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent ,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);

#undef  CreateWindowEx
#define CreateWindowEx CreateWindowExX
#define CreateWindowExT CreateWindowExA


HWND WINAPI CreateDialogParamX(
      HINSTANCE hInstance,
      LPCWSTR lpTemplateName,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam
);

#undef  CreateDialogParam
#define CreateDialogParam CreateDialogParamX

INT_PTR
WINAPI
DialogBoxParamX(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam);

#undef  DialogBoxParam
#define DialogBoxParam DialogBoxParamX

ATOM
WINAPI
RegisterClassX(
    CONST WNDCLASSW *lpWndClass);

#undef  RegisterClass
#define RegisterClass RegisterClassX
#define RegisterClassT RegisterClassA

BOOL
WINAPI
UnregisterClassX(
    LPCWSTR lpClassName,
    HINSTANCE hInstance);

#undef  UnregisterClass
#define UnregisterClass UnregisterClassX
#define UnregisterClassT UnregisterClassA

#ifndef _M_ALPHA
int WINAPIV wsprintfX(LPWSTR pwszOut, LPCWSTR pwszFormat, ...);

#undef  wsprintf
#define wsprintf wsprintfX
#define wsprintfT wsprintfA
#endif // _M_ALPHA


HWND
WINAPI
CreateWindowX(
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent ,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);

#undef  CreateWindow
#define CreateWindow CreateWindowX
#define CreateWindowT CreateWindowA

HANDLE
WINAPI
GetPropX(
    HWND hWnd,
    LPCWSTR lpString);

#undef  GetProp
#define GetProp GetPropX
#define GetPropT GetPropA

BOOL
WINAPI
SetPropX(
    HWND hWnd,
    LPCWSTR lpString,
    HANDLE hData);

#undef  SetProp
#define SetProp SetPropX
#define SetPropT SetPropA

HANDLE
WINAPI
RemovePropX(
    HWND hWnd,
    LPCWSTR lpString);

#undef  RemoveProp
#define RemoveProp RemovePropX
#define RemovePropT RemovePropA

UINT
WINAPI
GetProfileIntX(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault
    );

#undef  GetProfileInt
#define GetProfileInt GetProfileIntX
#define GetProfileIntT GetProfileIntA

ATOM
WINAPI
GlobalAddAtomX(
    LPCWSTR lpString
    );

#undef  GlobalAddAtom
#define GlobalAddAtom GlobalAddAtomX
#define GlobalAddAtomT GlobalAddAtomA

UINT
WINAPI
GlobalGetAtomNameX(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    );

#undef  GlobalGetAtomName
#define GlobalGetAtomName GlobalGetAtomNameX
#define GlobalGetAtomNameT GlobalGetAtomNameA

DWORD
WINAPI
GetModuleFileNameX(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

#undef  GetModuleFileName
#define GetModuleFileName GetModuleFileNameX
#define GetModuleFileNameT GetModuleFileNameA

LPWSTR
WINAPI
CharPrevX(
    LPCWSTR lpszStart,
    LPCWSTR lpszCurrent);

#undef  CharPrev
#define CharPrev CharPrevX
#define CharPrevT CharPrevA

HFONT   WINAPI CreateFontX(int, int, int, int, int, DWORD,
                             DWORD, DWORD, DWORD, DWORD, DWORD,
                             DWORD, DWORD, LPCWSTR);
#undef  CreateFont
#define CreateFont CreateFontX
#define CreateFontT CreateFontA

HMODULE
WINAPI
LoadLibraryX(
    LPCWSTR lpLibFileName
    );

#undef  LoadLibrary
#define LoadLibrary LoadLibraryX
#define LoadLibraryT LoadLibraryA

HMODULE
WINAPI
LoadLibraryExX(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );

#undef  LoadLibraryEx
#define LoadLibraryEx LoadLibraryExX
#define LoadLibraryExT LoadLibraryExA

LONG
APIENTRY
RegDeleteKeyX (
    HKEY hKey,
    LPCWSTR lpSubKey
    );

#undef  RegDeleteKey
#define RegDeleteKey RegDeleteKeyX
#define RegDeleteKeyT RegDeleteKeyA

#undef  RpcStringBindingCompose
#define RpcStringBindingCompose RpcStringBindingComposeW

#undef  RpcBindingFromStringBinding
#define RpcBindingFromStringBinding RpcBindingFromStringBindingW

#undef  RpcStringFree
#define RpcStringFree RpcStringFreeW

BOOL
WINAPI
CreateProcessX(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

#undef  CreateProcess
#define CreateProcess CreateProcessX
#define CreateProcessT CreateProcessA

LONG
APIENTRY
RegEnumKeyExX (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

#undef  RegEnumKeyEx
#define RegEnumKeyEx RegEnumKeyExX
#define RegEnumKeyExT RegEnumKeyExA

#undef  RpcServerUseProtseqEp
#define RpcServerUseProtseqEp RpcServerUseProtseqEpW

BOOL
WINAPI
AppendMenuX(
    HMENU hMenu,
    UINT uFlags,
    UINT uIDNewItem,
    LPCWSTR lpNewItem
    );

#undef  AppendMenu
#define AppendMenu AppendMenuX
#define AppendMenuT AppendMenuA

HANDLE
WINAPI
OpenEventX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

#undef  OpenEvent
#define OpenEvent OpenEventX
#define OpenEventT OpenEventA

HANDLE
WINAPI
CreateEventX(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );

#undef  CreateEvent
#define CreateEvent CreateEventX
#define CreateEventT CreateEventA

HANDLE
WINAPI
CreateMutexX(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    );

#undef  CreateMutex
#define CreateMutex CreateMutexX


UINT
WINAPI
GetDriveTypeX(
    LPCWSTR lpRootPathName
    );

#undef  GetDriveType
#define GetDriveType GetDriveTypeX
#define GetDriveTypeT GetDriveTypeA

DWORD
WINAPI
GetFileAttributesX(
    LPCWSTR lpFileName
    );

#undef  GetFileAttributes
#define GetFileAttributes GetFileAttributesX
#define GetFileAttributesT GetFileAttributesA

LONG
APIENTRY
RegEnumKeyX (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    );

#undef  RegEnumKey
#define RegEnumKey RegEnumKeyX
#define RegEnumKeyT RegEnumKeyA

LONG
APIENTRY
RegEnumValueX(
    HKEY hkey,
    DWORD dwIndex,
    LPWSTR wszName,
    LPDWORD pcbName,
    LPDWORD pReserved,
    LPDWORD ptype,
    LPBYTE  pValue,
    LPDWORD pcbValue
    );

#undef  RegEnumValue
#define RegEnumValue RegEnumValueX
#define RegEnumValueT RegEnumValueA

HANDLE
WINAPI
FindFirstFileX(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );

#undef  FindFirstFile
#define FindFirstFile FindFirstFileX
#define FindFirstFileT FindFirstFileA

#undef  RegisterProtseq
#define RegisterProtseq RegisterProtseqW

#undef  RpcStringBindingParse
#define RpcStringBindingParse RpcStringBindingParseW

#undef  RpcNetworkIsProtseqValid
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidW

#undef  RpcBindingToStringBinding
#define RpcBindingToStringBinding RpcBindingToStringBindingW

#undef  RpcServerUseProtseq
#define RpcServerUseProtseq RpcServerUseProtseqW

BOOL
WINAPI
GetComputerNameX (
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

#undef  GetComputerName
#define GetComputerName GetComputerNameX
#define GetComputerNameT GetComputerNameA


//The following force Chicago to directly use the ANSI versions

LRESULT
DefWindowProcX(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

#undef  DefWindowProc
#define DefWindowProc   DefWindowProcX

#undef  CopyMetaFile                       // Currently str ptr is always
#define CopyMetaFile    CopyMetaFileA      // null, write a wrapper if this
                                           // changes
#undef  CreateMetaFile
#define CreateMetaFile  CreateMetaFileA

#undef  PostMessage
#define PostMessage     PostMessageA

#undef  SendMessage
#define SendMessage     SendMessageA

#undef  PeekMessage
#define PeekMessage     PeekMessageA

#undef  GetMessage
#define GetMessage      GetMessageA

#undef TranslateAccelerator
#define TranslateAccelerator TranslateAcceleratorA

#undef IsDialogMessage
#define IsDialogMessage IsDialogMessageA

#undef  DispatchMessage
#define DispatchMessage DispatchMessageA

#undef  GetWindowLong
#define GetWindowLong GetWindowLongA

#undef  SetWindowLong
#define SetWindowLong SetWindowLongA

#undef  GetWindowLongPtr
#define GetWindowLongPtr GetWindowLongPtrA

#undef  SetWindowLongPtr
#define SetWindowLongPtr SetWindowLongPtrA

#undef SystemParametersInfo
#define SystemParametersInfo SystemParametersInfoA

#undef GetObject
#define GetObject GetObjectA

DWORD
WINAPI
GetShortPathNameX(
    LPCWSTR lpszLongPath,
    LPWSTR lpszShortPath,
    DWORD cchBuffer
    );

#undef  GetShortPathName
#define GetShortPathName GetShortPathNameX
#define GetShortPathNameT GetShortPathNameA

DWORD
WINAPI
GetFullPathNameX(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );

#undef  GetFullPathName
#define GetFullPathName GetFullPathNameX
#define GetFullPathNameT GetFullPathNameA

DWORD
WINAPI
SearchPathX(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );

#undef SearchPath
#define SearchPath SearchPathX
#define SearchPathT SearchPathA

ATOM
WINAPI
GlobalFindAtomX(
    LPCWSTR lpString
    );

#undef GlobalFindAtom
#define GlobalFindAtom GlobalFindAtomX
#define GlobalFindAtomT GlobalFindAtomA

int
WINAPI
GetClassNameX(
    HWND hWnd,
    LPWSTR lpClassName,
    int nMaxCount);

#undef GetClassName
#define GetClassName GetClassNameX
#define GetClassNameT GetClassNameA

LPWSTR
WINAPI
CharLowerX(
    LPWSTR lpsz);

#undef  CharLower
#define CharLower CharLowerX

LPWSTR
WINAPI
CharUpperX(
    LPWSTR lpsz);

#undef CharUpper
#define CharUpper CharUpperX

#define CharLowerBuffW CharLowerBuffW_not_available_on_Win9x

#define CharUpperBuffW CharUpperBuffW_not_available_on_Win9x

BOOL
WINAPI
GetStringTypeX(
    DWORD    dwInfoType,
    LPCWSTR  lpSrcStr,
    int      cchSrc,
    LPWORD   lpCharType);

#define GetStringTypeW GetStringTypeX


BOOL
WINAPI
IsCharAlphaX(
    WCHAR ch);


#define IsCharAlphaW IsCharAlphaX

BOOL
WINAPI
IsCharAlphaNumericX(
    WCHAR ch);

#define IsCharAlphaNumericW IsCharAlphaNumericX

#define IsCharLowerW IsCharLowerW_is_not_available_on_Win9x

#define IsCharUpperW IsCharUpperW_is_not_available_on_Win9x

#define LCMapStringW LCMapStringW_is_not_available_on_Win9x

LPWSTR
WINAPI
lstrcatX(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );

#undef lstrcat
#define lstrcat lstrcatX

LPWSTR
WINAPI
lstrcpyX(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );

#undef lstrcpy
#define lstrcpy lstrcpyX

LPWSTR
WINAPI
lstrcpynX(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    );

#undef lstrcpyn
#define lstrcpyn lstrcpynX

int
WINAPI
lstrcmpX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );

#undef lstrcmp
#define lstrcmp lstrcmpX

int  
strnicmpX(
    LPWSTR lpString1, 
    LPWSTR lpString2,
    size_t count
    );

#undef strnicmp
#define strnicmp strnicmpX

int
WINAPI
lstrcmpiX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );

#undef lstrcmpi
#define lstrcmpi lstrcmpiX


DWORD
WINAPI
lstrlenX(
    LPCWSTR lpString2
    );


#undef lstrlen
#define lstrlen lstrlenX



BOOL
WINAPI
SetFileAttributesX(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );

#undef SetFileAttributes
#define SetFileAttributes SetFileAttributesX
HANDLE
WINAPI
CreateFileMappingX(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );

#undef CreateFileMapping
#define CreateFileMapping CreateFileMappingX
#define CreateFileMappingT CreateFileMappingA

HANDLE
WINAPI
OpenFileMappingX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

#undef OpenFileMapping
#define OpenFileMapping OpenFileMappingX
#define OpenFileMappingT OpenFileMappingA

HICON LoadIconX(
    HINSTANCE hInstance,
    LPCWSTR lpIconName
);

#undef LoadIcon
#define LoadIcon LoadIconX

HCURSOR LoadCursorX(
    HINSTANCE hInstance,
    LPCWSTR lpCursorName
);

#undef LoadCursor
#define LoadCursor LoadCursorX

HANDLE LoadImageX(
    HINSTANCE hinst,
	LPCWSTR lpszName,
	UINT uType,
	int cxDesired,
	int cyDesired,
	UINT fuLoad
);

#undef LoadImage
#define LoadImage LoadImageX


HRSRC FindResourceX(
    HMODULE hModule,
	LPCWSTR lpName,
	LPCWSTR lpType
);

#undef FindResource
#define FindResource FindResourceX


DWORD_PTR
WINAPI
SHGetFileInfoX(
    LPCWSTR pszPath,
    DWORD dwFileAttributes,
    SHFILEINFOW FAR *psfi,
    UINT cbFileInfo,
    UINT uFlags);


#undef SHGetFileInfo
#define SHGetFileInfo SHGetFileInfoX

BOOL
WINAPI
Shell_NotifyIconX(
    DWORD dwMessage,
    PNOTIFYICONDATAW lpData);

#undef Shell_NotifyIcon
#define Shell_NotifyIcon Shell_NotifyIconX

int
WINAPI
MessageBoxX(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType);

#undef MessageBox
#define MessageBox MessageBoxX


// listView Wrappers
BOOL
ListView_GetItemX(
    HWND hwnd,
    LV_ITEM * pitem);

#undef ListView_GetItem
#define ListView_GetItem ListView_GetItemX

BOOL
ListView_SetItemX(
    HWND hwnd,
    LV_ITEM * pitem);

#undef ListView_SetItem
#define ListView_SetItem ListView_SetItemX

BOOL
ListView_InsertItemX(
    HWND hwnd,
    LV_ITEM * pitem);

#undef ListView_InsertItem
#define ListView_InsertItem ListView_InsertItemX

BOOL
ListView_SetColumnX(
    HWND hwnd,
    int iCol,
    LV_COLUMN * pColumn);

#undef ListView_SetColumn
#define ListView_SetColumn ListView_SetColumnX

int
ListView_InsertColumnX(
    HWND hwnd,
    int iCol,
    LV_COLUMN * pColumn);

#undef ListView_InsertColumn
#define ListView_InsertColumn ListView_InsertColumnX

// comboBox wrappers

int ComboEx_InsertItemX(HWND hwnd,PCCOMBOEXITEMW pComboExItemW);

#undef ComboEx_InsertItem
#define ComboEx_InsertItem ComboEx_InsertItemX

BOOL ComboEx_GetItemX(HWND hwnd,PCCOMBOEXITEMW pComboExItemW);

#undef ComboEx_GetItem
#define ComboEx_GetItem ComboEx_GetItemX

// TabCtrl Wrappers.
int
TabCtrl_InsertItemX(HWND hwnd,int iItem,LPTCITEMW ptcItem);

#undef TabCtrl_InsertItem
#define TabCtrl_InsertItem TabCtrl_InsertItemX

// animatiion control wrappers
BOOL Animate_OpenX(HWND hwnd,LPWSTR szName);

#undef Animate_Open
#define Animate_Open Animate_OpenX


HPROPSHEETPAGE
WINAPI CreatePropertySheetPageX(LPCPROPSHEETPAGEW);

#undef CreatePropertySheetPage
#define CreatePropertySheetPage   CreatePropertySheetPageX


INT_PTR
WINAPI PropertySheetX(
    LPCPROPSHEETHEADERW);

#undef PropertySheet
#define PropertySheet   PropertySheetX

int DrawTextX(
    HDC hDC,
    LPCWSTR lpString,
    int nCount,
    LPRECT lpRect,
    UINT uFormat
);

#undef DrawText
#define DrawText  DrawTextX


HWND
WINAPI
FindWindowExX(
    HWND hwndParent,
    HWND hwndChildAfter,
    LPCWSTR lpszClass,
    LPCWSTR lpszWindow
);

#undef FindWindowEx
#define FindWindowEx  FindWindowExX

HWND
WINAPI
FindWindowX(
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName);

#undef FindWindow
#define FindWindow  FindWindowX

BOOL SetWindowTextX(
    HWND hWnd,
    LPCWSTR lpString
);

#undef SetWindowText
#define SetWindowText  SetWindowTextX

int ListBox_AddStringX(
    HWND hWnd,
    LPCWSTR lpString
);

#undef ListBox_AddString
#define ListBox_AddString  ListBox_AddStringX

int GetWindowTextX(
    HWND hWnd,
    LPTSTR lpString,
    int nMaxCount
);

#undef GetWindowText
#define GetWindowText  GetWindowTextX

#undef SetDlgItemText
#define  SetDlgItemText(h,id,szBuf) SetWindowTextX(GetDlgItem(h,id),szBuf)

#undef GetDlgItemText
#define GetDlgItemText(h,id,szBuf,cchMax) GetWindowTextX(GetDlgItem(h,id),szBuf,cchMax)

#undef SendDlgItemMessage
#define SendDlgItemMessage(h,id,msg,wp,lp) SendMessageA(GetDlgItem(h,id),msg,wp,lp)

BOOL
WINAPI
WinHelpX(
    HWND hWndMain,
    LPCWSTR lpszHelp,
    UINT uCommand,
    ULONG_PTR dwData
    );


#undef WinHelp
#define WinHelp  WinHelpX

int
WINAPI
GetDateFormatX(
    LCID             Locale,
    DWORD            dwFlags,
    CONST SYSTEMTIME *lpDate,
    LPCWSTR          lpFormat,
    LPWSTR          lpDateStr,
    int              cchDate);

#undef GetDateFormat
#define GetDateFormat GetDateFormatX

int
WINAPI
GetTimeFormatX(
    LCID             Locale,
    DWORD            dwFlags,
    CONST SYSTEMTIME *lpTime,
    LPCWSTR          lpFormat,
    LPWSTR          lpTimeStr,
    int              cchTime);


#undef GetTimeFormat
#define GetTimeFormat GetTimeFormatX

BOOL
DateTime_SetFormatX(
	HWND hwnd,
	LPCWSTR pszTimeFormat);

#undef DateTime_SetFormat
#define DateTime_SetFormat DateTime_SetFormatX

HFONT
WINAPI
CreateFontIndirectX(
	CONST LOGFONTW *);


#undef CreateFontIndirect
#define CreateFontIndirect CreateFontIndirectX

DWORD
WINAPI
FormatMessageX(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    );

#undef FormatMessage
#define FormatMessage FormatMessageX

BOOL
WINAPI
IsBadStringPtrX(
    LPCWSTR lpsz,
    UINT ucchMax
    );

#undef IsBadStringPtr
#define IsBadStringPtr IsBadStringPtrX

BOOL
APIENTRY
GetTextExtentPointX(
    HDC,
    LPCWSTR,
    int,
    LPSIZE
    );

#undef GetTextExtentPoint
#define GetTextExtentPoint GetTextExtentPointX

#endif // _UNICODE

// automation exports
// don't widewrap so outside of UNICODE ifdef but need to delay load
// so do it here.

STDAPI_(BSTR) SysAllocStringX(const OLECHAR *);

#undef  SysAllocString
#define SysAllocString SysAllocStringX

STDAPI_(void) SysFreeStringX(BSTR);

#undef  SysFreeString
#define SysFreeString SysFreeStringX

STDAPI LoadRegTypeLibX(REFGUID rguid, WORD wVerMajor, WORD wVerMinor,
            LCID lcid, ITypeLib ** pptlib);

#undef  LoadRegTypeLib
#define LoadRegTypeLib LoadRegTypeLibX

// wrappers for delay loading userenv

BOOL
WINAPI
GetUserProfileDirectoryX(
    HANDLE  hToken,
    LPWSTR lpProfileDir,
    LPDWORD lpcchSize);

#undef  GetUserProfileDirectory
#define GetUserProfileDirectory GetUserProfileDirectoryX

// wrappers for delay load of user32 exports only available on NT 5.0

#ifndef ASFW_ANY
#define ASFW_ANY    ((DWORD)-1)
#endif // ASFW_ANY 

BOOL
WINAPI
AllowSetForegroundWindowX(
    DWORD dwProcessId);

#undef  AllowSetForegroundWindow
#define AllowSetForegroundWindow AllowSetForegroundWindowX


// wrappers for delayed IMM

HIMC 
WINAPI 
ImmAssociateContextX(HWND hWnd,HIMC hIMC);

#undef  ImmAssociateContext
#define  ImmAssociateContext ImmAssociateContextX

#ifdef __cplusplus
}
#endif


#endif  // _WIDEWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\lib\alloc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Alloc.cpp
//
//  Contents:   Allocation routines
//
//  Classes:
//
//  Notes:
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "lib.h"


#ifdef _DEBUG
extern DWORD g_dwDebugLeakDetection;
#endif // _DEBUG


//+-------------------------------------------------------------------
//
//  Function:    ::operator new
//
//  Synopsis:   Our operator new implementation
//
//  Arguments:  [size] -- Size of memory to allocate
//
//
//  Notes:
//
//--------------------------------------------------------------------

inline void* __cdecl operator new (size_t size)
{
    return(ALLOC(size));
}


//+-------------------------------------------------------------------
//
//  Function:    ::operator delete
//
//  Synopsis:   Our operator deleteimplementation
//
//  Arguments:  lpv-- Pointer to memory to free
//
//
//  Notes:
//
//--------------------------------------------------------------------

inline void __cdecl operator delete(void FAR* lpv)
{
    FREE(lpv);
}

//
// Allocator for MIDL stubs
//

//+-------------------------------------------------------------------
//
//  Function:   MIDL_user_allocate
//
//  Synopsis:   
//
//  Arguments:  lpv-- Pointer to memory to free
//
//
//  Notes:
//
//--------------------------------------------------------------------

extern "C" void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    IN size_t len
    )
{
    return ALLOC(len);
}

//+-------------------------------------------------------------------
//
//  Function:   MIDL_user_free
//
//  Synopsis:   
//
//  Arguments:  ptr-- Pointer to memory to free
//
//
//  Notes:
//
//--------------------------------------------------------------------

extern "C" void __RPC_API
MIDL_user_free(
    IN void __RPC_FAR * ptr
    )
{
    FREE(ptr);
}

//+---------------------------------------------------------------------------
//
//  function:   ALLOC, public
//
//  Synopsis:   memory allocator
//
//  Arguments:  [cb] - requested size of memory to alloc.
//
//  Returns:    Pointer to newly allocated memory, NULL on failure
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

LPVOID ALLOC(ULONG cb)
{
void *pv;

    pv = LocalAlloc(LMEM_FIXED,cb);

#ifdef _DEBUG
    if (NULL != pv) // under debug always initialize to -1 to catch unitialize errors.
    {
        memset(pv,MEMINITVALUE,cb);

        // add entry to arena
        ADDENTRY(pv,cb);

    }
#endif // _DEBUG

    return pv;
}


//+---------------------------------------------------------------------------
//
//  function:   FREE, public
//
//  Synopsis:   memory destructor
//
//  Arguments:  [pv] - pointer to memory to be released.
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------


void FREE(void* pv)
{
#ifdef _DEBUG
    if (NULL != pv) // under debug always initialize to -1 to catch unitialize errors.
    {
    UINT cb;

        Assert(LMEM_INVALID_HANDLE != LocalFlags(pv));

        cb = (UINT)LocalSize(pv); // returns zero on failure
        memset(pv,MEMFREEVALUE,cb);
    }

    FREEENTRY(pv);

    Assert(pv);

#endif // _DEBUG

    LocalFree(pv);
}


//+---------------------------------------------------------------------------
//
//  function:   REALLOC, public
//
//  Synopsis:   reallocs memory
//
//  Arguments:  [pv] - pointer to memory to be released.
//              [cb] - size to resize the memory to.
//
//  Returns:
//
//  Modifies:
//
//  History:    22-Jul-98      rogerg        Created.
//
//----------------------------------------------------------------------------

LPVOID REALLOC(void *pv,ULONG cb)
{

    Assert(pv);

    FREEENTRY(pv);
    pv =  LocalReAlloc(pv,cb,LMEM_MOVEABLE);
    ADDENTRY(pv,cb);

    return pv;
}


#if MEMLEAKDETECTION

#define ARENA_SIZE  5000

MEMARENA *g_MemChk = NULL;
BOOL g_InitArenaFailed = FALSE;
ULONG g_AllocNumber = 0;
ULONG g_FreeNumber      = 0;
ULONG g_ulAssertonAlloc = -1; // set this to the leak number for getting the stack trace.
CRITICAL_SECTION g_ArenaCriticalSection;


//+---------------------------------------------------------------------------
//
//  function:   InitArena, private
//
//  Synopsis:   Initializes our memory leak arena
//
//  Arguments:  .
//
//  Returns:    TRUE if Arena was successsfully initialized
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL InitArena()
{
int i = 0;


    Assert(g_dwDebugLeakDetection);

    if (!g_dwDebugLeakDetection || g_InitArenaFailed)
    {
	    return FALSE;
    }

    // if g_MemChk is NULL Allocate space for it,
    // else we are already initialized

    if (g_MemChk == NULL)
    {
        g_MemChk = (MEMARENA *) CoTaskMemAlloc(sizeof(MEMARENA) * (ARENA_SIZE + 1)) ;
        if (g_MemChk == NULL)
        {
	    AssertSz(0,"Unable to Initialize LeakDetection");
	    g_InitArenaFailed = TRUE;
            return FALSE;
        }

        g_MemChk[ARENA_SIZE - 1].Free = 'END ';

        while(g_MemChk[i].Free != 'END ' )
        {
            g_MemChk[i].Free = 'FREE';
            i++     ;
        }

        g_AllocNumber = 0;
        g_FreeNumber = 0;

        InitializeCriticalSection(&g_ArenaCriticalSection);

    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  function:   AddEntry, private
//
//  Synopsis:   Adds an entry to our memory leak arena
//
//  Arguments:  [lpv] - pointer to add to arena
//              [size] - size of pointer to add to the arena
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void AddEntry( void *lpv, unsigned long size)
{
LPMEMARENA      lpMem = g_MemChk;
CCriticalSection critsect(&g_ArenaCriticalSection,GetCurrentThreadId());
int i = 0;

    if (!g_dwDebugLeakDetection)
    {
        return;
    }

    if (!InitArena())
    {
        return;
    }

    critsect.Enter();

    // Find first available entry.
    while(g_MemChk[i].Free != 'FREE' && g_MemChk[i].Free != 'END ')
    {
        i++;
    }

    if ( g_MemChk[i].Free != 'END ' )
    {
        g_AllocNumber++;
        g_MemChk[i].Free = 'Ptr ';
        g_MemChk[i].lpv = lpv;
        g_MemChk[i].size = size;
        g_MemChk[i].Order = g_AllocNumber;

        if (g_AllocNumber == g_ulAssertonAlloc)
        {
            AssertSz(0,"Allocating AllocNumber");
        }
    }
    else
    {
        AssertSz(0,"Arena is full");
    }

    critsect.Leave();

    return;
}

//+---------------------------------------------------------------------------
//
//  function:   FreeEntry, private
//
//  Synopsis:   removes an entry from the memory arena
//
//  Arguments:  [lpv] - pointer to remove from the arena
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void FreeEntry ( void *lpv )
{
int i = 0;
BOOL fFoundEntry = FALSE;
CCriticalSection critsect(&g_ArenaCriticalSection,GetCurrentThreadId());

    if (!g_dwDebugLeakDetection)
    {
        return;
    }

    if (!InitArena())
    {
        return;
    }

    critsect.Enter();

    g_FreeNumber++;

    // Find entry.

    while( g_MemChk[i].Free != 'END ' )
    {
        if ( g_MemChk[i].lpv == lpv )
        {
            g_MemChk[i].Free = 'FREE';
            g_MemChk[i].lpv = NULL;
            g_MemChk[i].size = 0;
            g_MemChk[i].Order = 0;

            fFoundEntry = TRUE;
            break;
        }
        i++;
    }

    if (!fFoundEntry)
    {
    char buf[255];

        wsprintfA(buf, "??Freeing block not in mem arena %X\n", lpv);
        AssertSz(0,buf);
    }

    critsect.Leave();

}

//+---------------------------------------------------------------------------
//
//  function:   WalkArena, private
//
//  Synopsis:   walks arena asserting if finds any leaks.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

void WalkArena()
{
int i = 0;

    if (!g_dwDebugLeakDetection)
    {
        return;
    }

    if (!InitArena())
    {
        return;
    }

    while( g_MemChk[i].Free != 'END ' )
    {

        if ( g_MemChk[i].Free != 'FREE' )
        {
            AssertSz(0,"You Have a Leak");
        }

        i++;
    }

    g_MemChk = NULL;
}


#endif // MEMLEAKDETECTION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\h\stringc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       stringc.h
//
//  Contents:   SyncMgr string constants
//
//  History:    18-Feb-98   SusiA      Created.
//
//--------------------------------------------------------------------------

#ifndef _LIB_STRINGC_
#define _LIB_STRINGC_

extern "C" { 
extern const WCHAR SZ_SYNCMGRNAME[];

extern const WCHAR REGSTR_WINLOGON[];    
extern const WCHAR REGSTR_DEFAULT_DOMAIN[];  

extern const WCHAR CREATOR_SYNCMGR_TASK[];
extern const WCHAR SCHED_COMMAND_LINE_ARG[];

// registration constants. should be able to move to dll string constants
// if write wrapper class for preference access instead of exe reading these
// keys directly.

extern const WCHAR TOPLEVEL_REGKEY[];

extern const WCHAR HANDLERS_REGKEY[];
extern const WCHAR AUTOSYNC_REGKEY[];
extern const WCHAR IDLESYNC_REGKEY[];
extern const WCHAR SCHEDSYNC_REGKEY[];
extern const WCHAR MANUALSYNC_REGKEY[];
extern const WCHAR PROGRESS_REGKEY[];

extern const WCHAR SZ_IDLELASTHANDLERKEY[];
extern const WCHAR SZ_IDLERETRYMINUTESKEY[];
extern const WCHAR SZ_IDLEDELAYSHUTDOWNTIMEKEY[];
extern const WCHAR SZ_IDLEREPEATESYNCHRONIZATIONKEY[];
extern const WCHAR SZ_IDLEWAITAFTERIDLEMINUTESKEY[];
extern const WCHAR SZ_IDLERUNONBATTERIESKEY[];

extern const WCHAR SZ_REGISTRATIONFLAGSKEY[];
extern const WCHAR SZ_REGISTRATIONTIMESTAMPKEY[];

extern const WCHAR SZ_DEFAULTDOMAINANDUSERNAME[];
};

#endif // _LIB_STRINGC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\lib\debug.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       Debug.cpp
//
//  Contents:   Debug Code
//
//  Classes:    
//
//  Notes:      
//
//  History:    05-Nov-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "lib.h"

#ifdef _DEBUG

// globals for keeping track of debug flags
DWORD g_dwDebugLeakDetection = 0;
DWORD g_dwDebugLogAsserts = 0;

#endif // _DEBUG


#if _ZAWTRACK

// SENS DLL and function strings
STRING_FILENAME(szTrk1OneStopDll, "trk1stop.dll");
STRING_INTERFACE(szpfnOneStopTrk,"OneStopTrk");

// globals for ZawTrack. Set up in Init before
// any other threads are created.
HINSTANCE g_hInstTrk1StopDll = NULL;
PFNONESTOPTRK g_pfnOneStopTrk = NULL;

// Called by WinMain to set up ZawTracking.
void InitZawTrack()
{
    
    g_pfnOneStopTrk = NULL;
    g_hInstTrk1StopDll = LoadLibrary(szTrk1OneStopDll);

    if (g_hInstTrk1StopDll)
    {
	// for now, don't return an error is GetProc Fails but check in each function.
	g_pfnOneStopTrk = (PFNONESTOPTRK) 
			GetProcAddress(g_hInstTrk1StopDll,(LPCSTR) 0x01);

	if (NULL == g_pfnOneStopTrk)
	{
	    FreeLibrary(g_hInstTrk1StopDll);
	    g_hInstTrk1StopDll = NULL;
	}

    }

}

// called to log the flags
void LogZawTrack(DWORD dwFlags)
{
    if (g_pfnOneStopTrk)
    {
	g_pfnOneStopTrk(dwFlags);
    }

}



// Called by winmain to free
void UninitZawTrack()
{
    if (NULL != g_hInstTrk1StopDll)
    {
	g_pfnOneStopTrk = NULL;
	FreeLibrary(g_hInstTrk1StopDll);
	g_hInstTrk1StopDll = NULL;
    }

}

#endif // _ZAWTRACK

#ifdef _DEBUG

//+---------------------------------------------------------------------------
//
//  Function:   InitDebugFlags, public
//
//  Synopsis:   Called to setup  global debugFlags
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI_(void) InitDebugFlags(void)
{
DWORD cbData;
DWORD cbType;
HKEY hkeyDebug;

    // always use Ansii version so can setup debug before
    // initializing WideWrap

    g_dwDebugLeakDetection = 0;
    g_dwDebugLogAsserts = 0;

    if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                          "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Syncmgr\\Debug"
						      ,0,KEY_READ,&hkeyDebug) )
    {
        cbType = REG_DWORD;
        cbData = sizeof(g_dwDebugLeakDetection);

        if (ERROR_SUCCESS != RegQueryValueExA(hkeyDebug,
		          "LeakDetection",
		          NULL,  
		          &cbType,    
		          (LPBYTE) &g_dwDebugLeakDetection,    
		          &cbData))
        {
	    g_dwDebugLeakDetection = 0;
        }

        cbType = REG_DWORD;
        cbData = sizeof(g_dwDebugLogAsserts);

        if (ERROR_SUCCESS != RegQueryValueExA(hkeyDebug,
		          "LogAsserts",
		          NULL,  
		          &cbType,    
		          (LPBYTE) &g_dwDebugLogAsserts,    
		          &cbData))
        {
	    g_dwDebugLogAsserts = 0;
        }

        RegCloseKey(hkeyDebug);
    }


}

//+---------------------------------------------------------------------------
//
//  Function:   FnAssert, public
//
//  Synopsis:   Displays the Assert dialog
//
//  Arguments:  [lpstrExptr] - Expression
//		[lpstrMsg] - Msg, if any, to append to the Expression
//		[lpstrFilename] - File Assert Occured in
//		[iLine] - Line Number of Assert
//
//  Returns:    Appropriate status code
//
//  Modifies:   
//
//  History:    05-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------


STDAPI FnAssert( LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine )
{
int iResult = 0;
char lpTemp[] = "";
char lpBuffer[512];
char lpLocBuffer[256];


    if (NULL == lpstrMsg)
	    lpstrMsg = lpTemp;

    if (!g_dwDebugLogAsserts)
    {

        wsprintfA(lpBuffer, "Assertion \"%s\" failed! %s", lpstrExpr, lpstrMsg);
        wsprintfA(lpLocBuffer, "File %s, line %d; (A=exit; R=break; I=continue)",
            lpstrFileName, iLine);

        iResult = MessageBoxA(NULL, lpLocBuffer, lpBuffer,
		        MB_ABORTRETRYIGNORE | MB_SYSTEMMODAL);

        if (iResult == IDRETRY)
        {
            DebugBreak();
        }
        else if (iResult == IDABORT)
        {
            FatalAppExitA(0, "Assertion failure");
        }
    }
    else
    {
	wsprintfA(lpBuffer, "Assertion \"%s\" failed! %s\n", lpstrExpr, lpstrMsg);
	wsprintfA(lpLocBuffer, "File %s, line %d\n\n",lpstrFileName, iLine);

	OutputDebugStringA(lpBuffer);
	OutputDebugStringA(lpLocBuffer);
    }

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   FnTrace, public
//
//  Synopsis:   Displays the Assert dialog
//
//  Arguments: 	[lpstrMsg] - Msg in trace
//		[lpstrFilename] - File TRACE Occured in
//		[iLine] - Line Number of TRACE
//
//  Returns:    Appropriate status code
//
//  Modifies:   
//
//  History:    14-Jan-98      rogerg        Created.
//
//----------------------------------------------------------------------------


STDAPI FnTrace(LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine )
{
int iResult = 0;
char lpTemp[] = "";
char lpBuffer[512];

    if (NULL == lpstrMsg)
	    lpstrMsg = lpTemp;

    // should have flag to turn tracing on instead of changing header.
    wsprintfA(lpBuffer, "%s  %s(%d)\r\n",lpstrMsg,lpstrFileName,iLine);

    OutputDebugStringA(lpBuffer);

    return NOERROR;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\lib\makefile.inc ===
SENSDIR = ..\..\SENS\CONN\IDL

$(O)\notify.idl : $(SENSDIR)\notify.idl
        copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\lib\lib.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       lib.h
//
//  Contents:   contains headers needed to build the lib project
//
//  Classes:
//
//  Notes:
//
//  History:    04-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------

// standard includes for  MobSync lib

// Version 401 is needed for RasGetAutoDialParam bug need to define WinVer 40 
// so work with IE 4.0.
//
#ifndef WINVER
#define WINVER 0x400
#elif WINVER < 0x400
#undef WINVER
#define WINVER 0x400
#endif

#include <objbase.h>
#include <windows.h>
#include <shellapi.h>
#include <commctrl.h>
#include <inetreg.h>
#include <sensapip.h>

#include "mobsync.h"
#include "mobsyncp.h"

#include "debug.h"
#include "alloc.h"
#include "critsect.h"
#include "widewrap.h"
#include "stringc.h"
#include "smartptr.hxx"
#include "xarray.hxx"
#include "osdefine.h"

#include "validate.h"
#include "netapi.h"
#include "listview.h"
#include "util.hxx"
#include "clsobj.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\lib\listview.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       listview.cpp
//
//  Contents:   Implements Mobsync Custom Listview/TreeView control
//
//  Classes:    CListView
//
//  Notes:
//
//  History:    23-Jul-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "lib.h"

//+---------------------------------------------------------------------------
//
//  Member:     CListView::CListView, public
//
//  Synopsis:   Constructor
//
//  Arguments:  hwnd - hwnd of the listView we are wrapping
//              hwndParent - Parent for this HWND.
//              idCtrl - ControlID for this item
//              msgNotify - messageID to use for sending notifyCommand to the Parent.
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CListView::CListView(HWND hwnd,HWND hwndParent,int idCtrl,UINT MsgNotify)
{
    Assert(hwnd);

    m_hwnd = hwnd;
    m_hwndParent = hwndParent; // if parent null we just don't send notify messages
    m_idCtrl = idCtrl;
    m_MsgNotify = MsgNotify;

    m_pListViewItems = NULL;
    m_iListViewNodeCount = 0;
    m_iListViewArraySize = 0;
    m_iNumColumns = 0;
    m_iCheckCount = 0;
    m_dwExStyle = 0;

    // Up to caller to setup listView as OwnerData
    Assert(GetWindowLongA(m_hwnd,GWL_STYLE) & LVS_OWNERDATA);
    ListView_SetCallbackMask(m_hwnd, LVIS_STATEIMAGEMASK); // set for checkmark

}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::~CListView, public
//
//  Synopsis:   Constructor
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

CListView::~CListView()
{
    DeleteAllItems();
}




//+---------------------------------------------------------------------------
//
//  Member:     CListView::DeleteAllItems, public
//
//  Synopsis:   Removes all items from the ListView
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::DeleteAllItems()
{
BOOL fReturn;

    fReturn = ListView_DeleteAllItems(m_hwnd);

    if (fReturn)
    {
        if (m_iListViewNodeCount)
        {
        LPLISTVIEWITEM pListViewCurItem;       

            Assert(m_pListViewItems);

            // loop through the listview items deleting any subitems
            pListViewCurItem = m_pListViewItems + m_iListViewNodeCount -1;

            while(pListViewCurItem >= m_pListViewItems)
            {
                if(pListViewCurItem->pSubItems)
                {
                    DeleteListViewItemSubItems(pListViewCurItem);
                }

                if (pListViewCurItem->lvItemEx.pszText)
                {
                    Assert(LVIF_TEXT & pListViewCurItem->lvItemEx.mask);
                    FREE(pListViewCurItem->lvItemEx.pszText);
                }

                if (pListViewCurItem->lvItemEx.pBlob)
                {
                    Assert(LVIFEX_BLOB & pListViewCurItem->lvItemEx.maskEx);
                    FREE(pListViewCurItem->lvItemEx.pBlob);
                }

                pListViewCurItem--;
            }

            m_iListViewNodeCount = 0;
        }

        // free our item buffer
        if (m_pListViewItems)
        {
            FREE(m_pListViewItems);
            m_pListViewItems = NULL;
            m_iListViewArraySize = 0;
        }

        m_iCheckCount = 0;
    }

    return fReturn;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetItemCount, public
//
//  Synopsis:   returns total number of items in the listview.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CListView::GetItemCount()
{
    return m_iListViewNodeCount;
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetSelectedCount, public
//
//  Synopsis:   returns number of selected items from the listview
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

UINT CListView::GetSelectedCount()
{
    Assert(m_hwnd);

    return ListView_GetSelectedCount(m_hwnd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetSelectionMark, public
//
//  Synopsis:   returns index of the selection mark
//
//  Arguments:  
//
//  Returns:    itemId of the selection
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CListView::GetSelectionMark()
{
int iNativeListViewId; 
int iReturnItem = -1;
LPLISTVIEWITEM pListViewItem;

    Assert(m_hwnd);

    iNativeListViewId =  ListView_GetSelectionMark(m_hwnd);

    if (-1 != iNativeListViewId)
    {
        pListViewItem = ListViewItemFromNativeListViewItemId(iNativeListViewId);

        if (pListViewItem)
        {   
            iReturnItem = pListViewItem->lvItemEx.iItem;

            Assert(pListViewItem->iNativeListViewItemId == iNativeListViewId);
        }
    }

    return iReturnItem;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetImageList, public
//
//  Synopsis:   returns specified imagelist 
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HIMAGELIST CListView::GetImageList(int iImageList)
{
    Assert(m_hwnd);
    return ListView_GetImageList(m_hwnd,iImageList);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetImageList, public
//
//  Synopsis:   sets specified imagelist 
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HIMAGELIST CListView::SetImageList(HIMAGELIST himage,int iImageList)
{
    Assert(m_hwnd);
    return ListView_SetImageList(m_hwnd,himage,iImageList);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetExtendedListViewStyle, public
//
//  Synopsis:   sets the list view style
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CListView::SetExtendedListViewStyle(DWORD dwExStyle)
{
    // !!Handle checkboxes ourselves.
    // AssertSz(0,"impl extended style with checkboxes");
    
    Assert(m_hwnd);
    ListView_SetExtendedListViewStyle(m_hwnd,dwExStyle);
    m_dwExStyle = dwExStyle;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::InsertItem, public
//
//  Synopsis:   wrapper for ListView_InsertItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::InsertItem(LPLVITEMEX pitem)
{
LPLISTVIEWITEM pNewListViewItem = NULL;
LPLISTVIEWITEM pListViewSubItems = NULL;
LPWSTR pszText = NULL;
LPLVBLOB pBlob = NULL;
int iListViewIndex; // location item will be inserted
int iParentIndex = LVI_ROOT;
BOOL fInsertNative = FALSE;
int iIndent = 0; // indent for the item.
int iNativeInsertAtItemID = -1;
    
    // Cannot use insert to add a subitem
    // and need at least one column
    if (0 != pitem->iSubItem || (0 == m_iNumColumns))
    {
        Assert(0 != m_iNumColumns);
        Assert(0 == pitem->iSubItem);
        goto error;
    }


    Assert(0 == (pitem->maskEx & ~(LVIFEX_VALIDFLAGMASK)));

    // if a parent is specified check for special flags and
    // calc iItem or determine given iItem is invalid
    // #define LVI_ROOT    -1; // itemID to pass in for ParenItemID for root
    // #define LVI_FIRST   -0x0FFFE
    // #define LVI_LAST    -0x0FFFF

    // While validatin Determine if item should be immediately added to the listview
    // by a) if has parent that is expanded and has an assigned listviewID
    // or b) this is a toplevel item.
    // this is done when validating the itemID and setting the fInsertNative var

   LPLISTVIEWITEM pParentItem;
   LISTVIEWITEM lviRootNode;
    
    // if have a valid parent look it up else use the root

    if ((LVIFEX_PARENT & pitem->maskEx) && !(LVI_ROOT == pitem->iParent) )
    {
         pParentItem = ListViewItemFromIndex(pitem->iParent);
    }
    else
    {
        pParentItem = &lviRootNode;

        lviRootNode.lvItemEx.iItem = LVI_ROOT;
        lviRootNode.lvItemEx.iIndent = -1;
        lviRootNode.fExpanded = TRUE;
    }

        
    if (NULL == pParentItem)
    {
        Assert(NULL != pParentItem);
        goto error;
    }

    // found parent so go ahead and set the iIndent
    iParentIndex = pParentItem->lvItemEx.iItem;
    iIndent = pParentItem->lvItemEx.iIndent + 1;
    fInsertNative = pParentItem->fExpanded;

    // if LVI_FIRST for item then parent item + 1
    // else we need to find either the next node
    // at the same level as the parent or hit the 
    // end of the list.
    if (LVI_FIRST == pitem->iItem)
    {
        iListViewIndex = pParentItem->lvItemEx.iItem + 1;
    }
    else
    {
    int iNextParentiItem = -1;
    LPLISTVIEWITEM pNextParent = pParentItem + 1;
    LPLISTVIEWITEM pLastItem = m_pListViewItems + m_iListViewNodeCount -1;

        // if parent is the root node then skip since know Nextparent is the
        // last node. 

        if (pParentItem != &lviRootNode)
        {
            // calc of last item assumes have at least one node
            // if we don't then how can we have a parent?
            if (m_iListViewNodeCount < 1)
            {
                goto error;
            }

            while (pNextParent <= pLastItem)
            {
                if (pNextParent->lvItemEx.iIndent == pParentItem->lvItemEx.iIndent)
                {
                    iNextParentiItem = pNextParent->lvItemEx.iItem;
                    break;
                }

                ++pNextParent;
            }
        }

        // if out of loop and NexParentItem is still -1 means hit the 
        // end of list
        if (-1 == iNextParentiItem)
        {
            if (m_iListViewNodeCount)
            {
                iNextParentiItem = pLastItem->lvItemEx.iItem + 1;
            }
            else
            {
                iNextParentiItem = 0;
            }
        }
      

        if (LVI_LAST == pitem->iItem)
        {
            iListViewIndex = iNextParentiItem;
        }
        else
        {
            // if user specified theitem it better fall within a valid range.
            if (pitem->iItem > iNextParentiItem ||
                    pitem->iItem <= pParentItem->lvItemEx.iItem)
            {
                Assert(pitem->iItem <= iNextParentiItem);
                Assert(pitem->iItem > pParentItem->lvItemEx.iItem);

                goto error;
            }

            iListViewIndex =  pitem->iItem;
        }

    }

    // make sure buffer is big enough
    // !!! Warning any pointers items in the ListView Array
    // will be invalid after the realloc/alloc.
    if (m_iListViewArraySize < (m_iListViewNodeCount + 1))
    {
    int iNewArraySize = m_iListViewNodeCount + 10;
    LPLISTVIEWITEM pListViewItemsOrig = m_pListViewItems;
    ULONG cbAlloc = iNewArraySize*sizeof(LISTVIEWITEM);

        if (m_pListViewItems)
        {
            // Review - if realloc fails is original buffer still in tact.
            m_pListViewItems = (LPLISTVIEWITEM) REALLOC(m_pListViewItems,cbAlloc);
        }
        else
        {
            m_pListViewItems = (LPLISTVIEWITEM) ALLOC(cbAlloc);
        }

        // if couldn't alloc or realloc failed then fail the insert
        if (NULL == m_pListViewItems)
        {
            m_pListViewItems = pListViewItemsOrig;
            goto error;
        }

        m_iListViewArraySize = iNewArraySize;
    }
    
    Assert(m_pListViewItems);
    if (NULL == m_pListViewItems)
    {
        goto error;
    }

    // if have subitems make sure we can allocate the subitems before
    // moving all the nodes. This is number of columns minus one since
    // column offset 0 is stored in main array 

    pListViewSubItems = NULL;
    if (m_iNumColumns > 1)
    {
    ULONG ulAllocSize = (m_iNumColumns -1)*sizeof(LISTVIEWITEM);
    int iSubItem;
    LPLISTVIEWITEM pCurSubItem;

        pListViewSubItems = (LPLISTVIEWITEM) ALLOC(ulAllocSize);

        if (NULL == pListViewSubItems)
        {
            goto error;
        }

        // fix up subItem values. 
        ZeroMemory(pListViewSubItems,ulAllocSize);

        pCurSubItem = pListViewSubItems;
        iSubItem = 1;

        while (iSubItem < m_iNumColumns)
        {
            pCurSubItem->lvItemEx.iItem = iListViewIndex;
            pCurSubItem->lvItemEx.iSubItem = iSubItem;

            ++iSubItem;
            ++pCurSubItem;
        }
            
    }

    // make sure can allocate text and anything else
    // that can faile if need to before move
    // everything down so don't have to undo.

    if (pitem->mask & LVIF_TEXT)
    {
    int cchSize;

        if (NULL == pitem->pszText)
        {
            pszText = NULL;
        }
        else
        {
        
            cchSize = (lstrlen(pitem->pszText) + 1)*sizeof(WCHAR);

            pszText = (LPWSTR) ALLOC(cchSize);

            if (NULL == pszText)
            {
                goto error;
            }

            memcpy(pszText,pitem->pszText,cchSize);
        }
    }

    if (pitem->maskEx & LVIFEX_BLOB)
    {
    ULONG cbSize;

        if (NULL == pitem->pBlob)
        {
            Assert(pitem->pBlob);
            goto error;
        }
        
        cbSize = pitem->pBlob->cbSize;
        pBlob =  (LPLVBLOB) ALLOC(cbSize);
        if (NULL == pBlob)
        {
            goto error;
        }
        
        memcpy(pBlob,pitem->pBlob,cbSize);

    }

    // !!!Nothing should fail after this line other than possibly
    // inserting into the Native ListView in which case 
    // it will still be in our list but not shown to the User.


    // Move existing elements down that item is inserted ahead of.
    // if the item is going to be immediately added to the ListView then 
     pNewListViewItem = m_pListViewItems + iListViewIndex;
    if (m_iListViewNodeCount)
    {
    LPLISTVIEWITEM pListViewMoveItem;

        pListViewMoveItem = m_pListViewItems + m_iListViewNodeCount -1;
        Assert(m_iListViewArraySize > m_iListViewNodeCount);

        while (pListViewMoveItem >= pNewListViewItem) // want >= so move node at current item location
        {
        int iMoveParent;

            ++(pListViewMoveItem->lvItemEx.iItem); // increment the iItem

            // if parent fails within move range increment the ParentId
            iMoveParent = pListViewMoveItem->lvItemEx.iParent;

            if ( (LVI_ROOT != iMoveParent) && (iMoveParent >= iListViewIndex))
            {
                ++(pListViewMoveItem->lvItemEx.iParent);
            }

            *(pListViewMoveItem + 1) = *(pListViewMoveItem);
            --pListViewMoveItem;
        }
    }


    // now insert the item at the specified location
    ++m_iListViewNodeCount;
    
    pNewListViewItem->pSubItems = pListViewSubItems;
    pNewListViewItem->fExpanded = TRUE; /// Review if want this to be user defined.but we expand children by default
    pNewListViewItem->iChildren = 0;
    pNewListViewItem->iNativeListViewItemId = -1;

    // fixup lvItem data
    pNewListViewItem->lvItemEx = *pitem;
    pNewListViewItem->lvItemEx.pszText = pszText;
    pNewListViewItem->lvItemEx.iItem = iListViewIndex;
    pNewListViewItem->lvItemEx.iIndent = iIndent;
 
    pNewListViewItem->lvItemEx.maskEx |= LVIFEX_PARENT; // always force valid parent
    pNewListViewItem->lvItemEx.pBlob = pBlob;
    pNewListViewItem->lvItemEx.iParent = iParentIndex; 

    // Review - For now Don't call SetItem so State CheckBox isn't updated.
    // Client must call SetItem after the insert to setup the ImageState
    // Assert that client isn't passing in a statImage on an Insert.  

    Assert(!(pNewListViewItem->lvItemEx.mask & LVIF_STATE)
            || !(pNewListViewItem->lvItemEx.stateMask &  LVIS_STATEIMAGEMASK)); 

    pNewListViewItem->lvItemEx.state = 0;
    pNewListViewItem->lvItemEx.stateMask = 0;

    // if have a parent other than the root incrment its children count
    // !! Note have to find again in case a realloc happened

    if (iParentIndex != LVI_ROOT)
    {
    pParentItem = ListViewItemFromIndex(iParentIndex);

        Assert(pParentItem);
        if (pParentItem)
        {
            ++(pParentItem->iChildren);
        }
    }


    if (fInsertNative)
    {
        // walk back and add 1 to
        // first item we come to that already is in the listview. if none assigned
        // iNativeInsertAtItemID should be zero.
        iNativeInsertAtItemID = 0;
        LPLISTVIEWITEM pListViewPrevItem;

        pListViewPrevItem = pNewListViewItem -1;
        while (pListViewPrevItem >= m_pListViewItems)
        {
            if (-1 != pListViewPrevItem->iNativeListViewItemId)
            {
                iNativeInsertAtItemID = pListViewPrevItem->iNativeListViewItemId + 1;
                break;
            }

            --pListViewPrevItem;
        }
    }
    else
    {
        iNativeInsertAtItemID = -1;
    }

    if (-1 != iNativeInsertAtItemID)
    {
    LV_ITEM lvi = { 0 };    
    LPLISTVIEWITEM pListViewMoveItem;
    LPLISTVIEWITEM pLastItem;

        Assert(fInsertNative);

        lvi.iItem = iNativeInsertAtItemID;
        pNewListViewItem->iNativeListViewItemId = ListView_InsertItem(m_hwnd,&lvi);
       
        Assert(iNativeInsertAtItemID == pNewListViewItem->iNativeListViewItemId);
        
        if (-1 != pNewListViewItem->iNativeListViewItemId)
        {
            // fix up NativeIds of items below
            pLastItem = m_pListViewItems + m_iListViewNodeCount - 1;
            pListViewMoveItem = pNewListViewItem + 1;

            while (pListViewMoveItem <= pLastItem)
            {
                if (-1 != pListViewMoveItem->iNativeListViewItemId)
                {
                    ++(pListViewMoveItem->iNativeListViewItemId);
                }

                ++pListViewMoveItem;
            }
        }

    }

    // after calling native listview fix up the state vars in local item to
    // not include the low byte
    pNewListViewItem->lvItemEx.state &= ~0xFF;
    pNewListViewItem->lvItemEx.stateMask &= ~0xFF;


    return iListViewIndex; // return new index even if fail to add to native listview

error:

    if (pListViewSubItems)
    {
        FREE(pListViewSubItems);
    }

    if (pszText)
    {
        FREE(pszText);
    }

    if (pBlob)
    {
        FREE(pBlob);
    }

    return FALSE;

}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::DeleteItem, public
//
//  Synopsis:   Deletes the specified lvItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::DeleteItem(int iItem)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(iItem);
LPLISTVIEWITEM pListViewCurItem;
LPLISTVIEWITEM pListViewLastItem;
int iNativeListViewId;
int iParent;

    if (NULL == pListViewItem || (m_iListViewNodeCount < 1))
    {
        Assert(pListViewItem);
        Assert(m_iListViewNodeCount > 0); // should be at least one item.
        return FALSE;
    }

    // delete the item data and then move all items below this one up 
    // in the array. if the Item is in the ListView and native delete succeeded
    // decrement their nativeID count.
    
    // !REMEMBER TO DECREMENT THE parents iChildren count if have a parent and
    // total count of number of items in the list view.

    if (0 != pListViewItem->iChildren)
    {
        Assert(0 == pListViewItem->iChildren); // don't support delete of parent nodes.
        return FALSE;
    }


    iNativeListViewId = pListViewItem->iNativeListViewItemId;
    iParent = pListViewItem->lvItemEx.iParent;
    
    // update toplevel vars and item info by calling
    // setitem to uncheck and clear text, and blob so
    LVITEMEX pitem;

    pitem.iItem = iItem;
    pitem.iSubItem = 0;
    pitem.mask = LVIF_TEXT;
    pitem.maskEx = LVIFEX_BLOB;

    pitem.pszText = NULL;
    pitem.pBlob = NULL;
    
    // only need to set the state if have checkboxes
    if (m_dwExStyle & LVS_EX_CHECKBOXES)
    {
        pitem.mask |= LVIF_STATE;
        pitem.state = LVIS_STATEIMAGEMASK_UNCHECK;
        pitem.stateMask = LVIS_STATEIMAGEMASK;
    }

    SetItem(&pitem);
    
     // update parent to tell it it has one less item.
    if (LVI_ROOT != iParent)
    {
    LPLISTVIEWITEM pListViewItemParent;

        if (pListViewItemParent = ListViewItemFromIndex(iParent))
        {
            --(pListViewItemParent->iChildren); 
            Assert(pListViewItemParent->iChildren >= 0);
        }

        Assert(pListViewItemParent);
    }

    // set the current item to the end of the list
    Assert(m_iListViewNodeCount >= 1); // if no nodes should have already bailed.
    pListViewLastItem = m_pListViewItems + m_iListViewNodeCount - 1;

    // delete the SubItems if any associated with the ListView.
    DeleteListViewItemSubItems(pListViewItem);
    Assert(NULL == pListViewItem->lvItemEx.pszText);
    Assert(NULL == pListViewItem->lvItemEx.pBlob);

    // delete the item from the native listView if fails will just have
    // a blank item at the bottom of the native listview. 
    if (-1 != iNativeListViewId)
    {
        ListView_DeleteItem(m_hwnd,iNativeListViewId);
    }

      // decrement the toplevel nodecount
    --m_iListViewNodeCount;

    pListViewCurItem = pListViewItem;

    // move items remaining in the ListView up updateing iNativeListViewId
    // if appropriate.
    while (pListViewCurItem < pListViewLastItem)
    {
        *(pListViewCurItem) = *(pListViewCurItem + 1);
       
        if ( (-1 != iNativeListViewId)
              && (-1 != pListViewCurItem->iNativeListViewItemId))
        {
            --pListViewCurItem->iNativeListViewItemId;
        }

        --(pListViewCurItem->lvItemEx.iItem); // decrement it iItem

        // if items parentID falls within pListViewItem and this item
        // range need to update our iParent.
        // parent should nevert be == iItem since don't allow nodes
        // with children to be deleted but check <= anyways
        if (LVI_ROOT != pListViewCurItem->lvItemEx.iParent)
        {
            if (iItem <= pListViewCurItem->lvItemEx.iParent)
            {
                --(pListViewCurItem->lvItemEx.iParent);
            }
        }

        ++pListViewCurItem;
    }


    return TRUE;

}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::DeleteChildren, public
//
//  Synopsis:   Deletes all child nodes associated with the item.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::DeleteChildren(int iItem)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(iItem);
LPLISTVIEWITEM pListViewCurItem;
LPLISTVIEWITEM pLastListViewItem;
int iNumChildren;

    if (!pListViewItem || m_iListViewNodeCount < 1)
    {
        Assert(pListViewItem);
        Assert(m_iListViewNodeCount >= 1); // should at least have one node.
        return FALSE;
    }
 
    iNumChildren = pListViewItem->iChildren;
    pLastListViewItem = m_pListViewItems + m_iListViewNodeCount - 1;

    if (0 > iNumChildren)
    {
        Assert(0 <= iNumChildren); // this count should never go negative.
        return FALSE;
    }

    // if no children just return;
    if (0 == iNumChildren)
    {
        return TRUE;
    }
    // verify all children don't have any children of there own. if they
    // do we don't support this. Also verify that don't run off
    // end of the list in which case we fail too.
    pListViewCurItem = pListViewItem  + iNumChildren;

    if (pListViewCurItem > pLastListViewItem)
    {
        AssertSz(0,"Children run off end of ListView");
        return FALSE;
    }

    while (pListViewCurItem > pListViewItem)
    {
        if (pListViewCurItem->iChildren > 0)
        {
            AssertSz(0,"Trying to DeleteChildren when Children have Children");
            return FALSE;
        }

        --pListViewCurItem;
    }

    // all items verified, just loop through deleting the items starting at the bottom.
    pListViewCurItem = pListViewItem  + iNumChildren;

    while (pListViewCurItem > pListViewItem)
    {
        DeleteItem(pListViewCurItem->lvItemEx.iItem); // if any fail delete what we can.
        --pListViewCurItem;
    }


    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetItem, public
//
//  Synopsis:   wrapper for ListView_SetItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::SetItem(LPLVITEMEX pitem)
{
int iNativeListViewItemId;
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(pitem->iItem,pitem->iSubItem,&iNativeListViewItemId);
LPLVITEMEX plvItemEx;
BOOL fCheckCountChanged = FALSE;
LVITEMSTATE fNewCheckCountState;
LPWSTR pszNewText = NULL;
LPLVBLOB pNewBlob = NULL;



    if (NULL == pListViewItem)
    {
        Assert(pListViewItem);
        return FALSE;
    }

    Assert(pListViewItem->lvItemEx.iSubItem == pitem->iSubItem);
    Assert(pListViewItem->lvItemEx.iSubItem > 0 
            || pListViewItem->iNativeListViewItemId == iNativeListViewItemId);
    

    plvItemEx = &(pListViewItem->lvItemEx);

     // allocate new text
    if (LVIF_TEXT & pitem->mask)
    {
    int cchSize;

        if (NULL == pitem->pszText)
        {
            pszNewText = NULL;
        }
        else
        {
            cchSize = (lstrlen(pitem->pszText) + 1)*sizeof(WCHAR);
            pszNewText = (LPWSTR) ALLOC(cchSize);

            if (NULL == pszNewText)
            {
                goto error;
            }

            memcpy(pszNewText,pitem->pszText,cchSize);

        }

    }

    // allocate new blob
    if (LVIFEX_BLOB & pitem->maskEx)
    {

        if (NULL == pitem->pBlob)
        {
            pNewBlob = NULL;
        }
        else
        {
            pNewBlob = (LPLVBLOB) ALLOC(pitem->pBlob->cbSize);

            if (NULL == pNewBlob)
            {
               goto error;
            }

            memcpy(pNewBlob,pitem->pBlob,pitem->pBlob->cbSize);

        }

    }

    // now that can't fail update the text and blob field appropriately
    if (LVIF_TEXT & pitem->mask)
    {
        if (plvItemEx->pszText)
        {
            FREE(plvItemEx->pszText);
        }

        plvItemEx->pszText = pszNewText;
        plvItemEx->mask |= LVIF_TEXT; 

        pszNewText = NULL; 
    }

    if (LVIFEX_BLOB & pitem->maskEx)
    {
        if (plvItemEx->pBlob)
        {
            FREE(plvItemEx->pBlob);
        }

        plvItemEx->pBlob = pNewBlob;
        plvItemEx->mask |= LVIFEX_BLOB; 

        pNewBlob = NULL;
    }



    if (LVIF_IMAGE & pitem->mask)
    {
        plvItemEx->mask |= LVIF_IMAGE; 
        plvItemEx->iImage = pitem->iImage;
    }

    if (LVIF_PARAM & pitem->mask)
    {
        plvItemEx->mask |= LVIF_PARAM; 
        plvItemEx->lParam = pitem->lParam;
    }

    // update the item state. 
    if (LVIF_STATE & pitem->mask)
    {
        plvItemEx->mask |= LVIF_STATE; 

        // only care about #define LVIS_OVERLAYMASK, LVIS_STATEIMAGEMASK
        if (pitem->stateMask & LVIS_OVERLAYMASK)
        {
            plvItemEx->stateMask |= LVIS_OVERLAYMASK;
            plvItemEx->state = (pitem->state & LVIS_OVERLAYMASK )
                                      +  (plvItemEx->state & ~LVIS_OVERLAYMASK);
        }

        if (pitem->stateMask & LVIS_STATEIMAGEMASK)
        {
            // update the m_iCheckCount (indeterminate doesn't contribute.
            if ( (plvItemEx->iSubItem == 0)
                && ( (pitem->state & LVIS_STATEIMAGEMASK) !=  (plvItemEx->state & LVIS_STATEIMAGEMASK)))
            {

                // don't set fCheckCountChange unless it actually did.
                if ( (pListViewItem->lvItemEx.state & LVIS_STATEIMAGEMASK) ==  LVIS_STATEIMAGEMASK_CHECK)
                {
                     fCheckCountChanged = TRUE;
                     fNewCheckCountState =  LVITEMEXSTATE_UNCHECKED;
                    --m_iCheckCount;
                }
                
                if ( (pitem->state  & LVIS_STATEIMAGEMASK) ==  LVIS_STATEIMAGEMASK_CHECK)
                {
                    fCheckCountChanged = TRUE;
                     fNewCheckCountState =  LVITEMEXSTATE_CHECKED;
                    ++m_iCheckCount;
                }

                Assert(m_iCheckCount >= 0);
                Assert(m_iCheckCount <= m_iListViewNodeCount);
            }  
            

            plvItemEx->stateMask |= LVIS_STATEIMAGEMASK;
            plvItemEx->state = (pitem->state & LVIS_STATEIMAGEMASK)
                                      +  (plvItemEx->state & ~LVIS_STATEIMAGEMASK);

        }
    }        

    // if the check count changed and we have checkboxes send the notification
    // if item state has changed send the count notification
     if (fCheckCountChanged && m_hwndParent && (m_dwExStyle & LVS_EX_CHECKBOXES))
     {
     NMLISTVIEWEXITEMCHECKCOUNT lvCheckCount;
 
         lvCheckCount.hdr.hwndFrom = m_hwnd;
         lvCheckCount.hdr.idFrom = m_idCtrl;
         lvCheckCount.hdr.code = LVNEX_ITEMCHECKCOUNT;
         lvCheckCount.iCheckCount = m_iCheckCount;

          lvCheckCount.iItemId = pitem->iItem;
          lvCheckCount.dwItemState = fNewCheckCountState; // new state of the item whose checkcount has changed.

         SendMessage(m_hwndParent,m_MsgNotify,m_idCtrl,(LPARAM) &lvCheckCount);
     }



    // if item is in the native list view, redraw item to reflect new state
    // bug  bug, doesn't handle subitems
    if (-1 != iNativeListViewItemId)
    {
        // if state changed pass it along for focus
        if ((LVIF_STATE & pitem->mask) && (0 == pitem->iSubItem))
        {
        int stateMask = pitem->stateMask   & 0xff;
            
            if (stateMask)
            {
                ListView_SetItemState(m_hwnd,iNativeListViewItemId,pitem->state,stateMask);
        
            }
            
        }

        ListView_RedrawItems(m_hwnd,iNativeListViewItemId,iNativeListViewItemId);
    }

    return TRUE;

error:

    if (pszNewText)
    {
        FREE(pszNewText);
    }

    if (pNewBlob)
    {
        FREE(pNewBlob);
    }

    return FALSE;

}




//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetItemState, public
//
//  Synopsis:   wrapper for ListView_SetItemState
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------
    
BOOL CListView::SetItemState(int iItem,UINT state,UINT mask)
{
LVITEMEX lvitemEx;

    lvitemEx.iItem = iItem;
    lvitemEx.iSubItem  = 0;
    lvitemEx.mask = LVIF_STATE ;
    lvitemEx.state = state;
    lvitemEx.stateMask = mask;
    lvitemEx.maskEx = 0;

    return SetItem(&lvitemEx);
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetItemlParam, public
//
//  Synopsis:   wrapper for setting the lParam
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::SetItemlParam(int iItem,LPARAM lParam)
{
LVITEMEX lvitemEx;

    lvitemEx.iItem = iItem;
    lvitemEx.iSubItem  = 0;
    lvitemEx.mask = LVIF_PARAM ;
    lvitemEx.lParam = lParam;
    lvitemEx.maskEx = 0;

    return SetItem(&lvitemEx);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetItemText, public
//
//  Synopsis:   wrapper for setting the item text.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::SetItemText(int iItem,int iSubItem,LPWSTR pszText)
{
LVITEMEX lvitemEx;

    lvitemEx.iItem = iItem;
    lvitemEx.iSubItem  = iSubItem;
    lvitemEx.mask = LVIF_TEXT;
    lvitemEx.pszText = pszText;
    lvitemEx.maskEx = 0;

    return SetItem(&lvitemEx);
}




//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetItem, public
//
//  Synopsis:   wrapper for ListView_GetItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::GetItem(LPLVITEMEX pitem)
{
int iNativeListViewItemId;
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(pitem->iItem,pitem->iSubItem,&iNativeListViewItemId);

    if (NULL == pListViewItem)
    {
        Assert(pListViewItem);
        return FALSE;
    }

     // add text first. Since it is the only item
    if (LVIF_TEXT & pitem->mask)
    {
        
        if (!(pListViewItem->lvItemEx.pszText) || (0 == pitem->cchTextMax)
            || !(pListViewItem->lvItemEx.mask & LVIF_TEXT) )
        {
            pitem->pszText = NULL;
        }
        else
        {
        int cchListTextSize = lstrlen(pListViewItem->lvItemEx.pszText);

            // NOTE. undefined what happens if cchTextMax not big enough.
            // we go ahead and terminate the string.
            lstrcpyn(pitem->pszText,pListViewItem->lvItemEx.pszText,pitem->cchTextMax);

            if ( (cchListTextSize + 1) > pitem->cchTextMax)
            {
            LPWSTR pwszBuf = pitem->pszText + pitem->cchTextMax -1;
                    
                *pwszBuf = NULL;
            }

        }   
    }

    if (LVIF_IMAGE & pitem->mask)
    {
        pitem->iImage = pListViewItem->lvItemEx.iImage;
    }

    if (LVIF_PARAM & pitem->mask)
    {
        pitem->lParam =  pListViewItem->lvItemEx.lParam;
    }

    // update the item state. 
    if (LVIF_STATE & pitem->mask)
    {
        pitem->state  = pListViewItem->lvItemEx.state;
    }        


    return TRUE;

}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetItemText, public
//
//  Synopsis:   wrapper for ListView_GetItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::GetItemText(int iItem,int iSubItem,LPWSTR pszText,int cchTextMax)
{
LVITEMEX lvitem;

    lvitem.mask = LVIF_TEXT;
    lvitem.maskEx = 0;

    lvitem.iItem = iItem;
    lvitem.iSubItem = iSubItem;
    lvitem.pszText = pszText;
    lvitem.cchTextMax = cchTextMax;
    
    return GetItem(&lvitem);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetItemlParam, public
//
//  Synopsis:   wrapper for gettting the lparam
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------


BOOL CListView::GetItemlParam(int iItem,LPARAM *plParam)
{
LVITEMEX lvitem;
BOOL fReturn;

    lvitem.mask = LVIF_PARAM;
    lvitem.maskEx = 0;

    lvitem.iItem = iItem;
    lvitem.iSubItem = 0;

    if (fReturn = GetItem(&lvitem))
    {
        *plParam = lvitem.lParam;
    }

    return fReturn;
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetHwnd, public
//
//  Synopsis:   return Hwnd of the ListView
//
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    07-Sep-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HWND CListView::GetHwnd()
{
    return m_hwnd;
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetParent, public
//
//  Synopsis:   return Hwnd of the ListViews Parent
//
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    07-Sep-98       rogerg        Created.
//
//----------------------------------------------------------------------------

HWND CListView::GetParent()
{
    return m_hwndParent;
}




//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetCheckState, public
//
//  Synopsis:   wrapper for ListView_GetCheckState
//
//              return state from LVITEMEXSTATE enum 
//              !!!return -1 if not item match to have same behavior as ListView
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CListView::GetCheckState(int iItem)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(iItem);
UINT state;
  
    if (NULL == pListViewItem)
    {
        return -1; // return -1 same as for native listbox
    }
    
    // check state is actually define -1 than the image. 
    // Don't know why. Just what the native listview does.
    // change whant supply our own image that will map exactly
    state = ((pListViewItem->lvItemEx.state & LVIS_STATEIMAGEMASK) >> 12) -1;

#ifdef _DEBUG
    if (-1 != pListViewItem->iNativeListViewItemId)
    {
    UINT lvState = ListView_GetCheckState(m_hwnd,pListViewItem->iNativeListViewItemId);

        Assert(state == lvState);
    }

#endif // _DEBUG
    
    // if this is a toplevel item then okay for state to be
    // negative -1. Should change this when go indeterminate.
    // Review - maybe just make -1 indeterinate state.
    if (-1 == state && 0 == pListViewItem->lvItemEx.iIndent)
    {
        state = LVITEMEXSTATE_INDETERMINATE;
    }

    Assert(state <= LVITEMEXSTATE_INDETERMINATE);
    return state; 
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetCheckedItemsCount, public
//
//  Synopsis:  returns the number of checked items in the list.
//
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CListView::GetCheckedItemsCount()
{
    return m_iCheckCount;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetColumn, public
//
//  Synopsis:   wrapper for ListView_SetColumn
//
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::SetColumn(int iCol,LV_COLUMN * pColumn)
{
    Assert(m_hwnd);
    return ListView_SetColumn(m_hwnd,iCol,pColumn);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::InsertColumn, public
//
//  Synopsis:   wrapper for ListView_InsertColumn
//
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CListView::InsertColumn(int iCol,LV_COLUMN * pColumn)
{
int iReturn;

    Assert(m_hwnd);

    iReturn =  ListView_InsertColumn(m_hwnd,iCol,pColumn);

    if (-1 != iReturn)
    {
        m_iNumColumns++;

        // need to realloc any existing listviewItems with subitems and move
        // the column appropriate

        //currently only support setting up columns before adding any items
        Assert(0 == m_iListViewNodeCount); 

    }

    return iReturn;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::SetColumnWidth, public
//
//  Synopsis:   wrapper for ListView_SetColumnWidth
//
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::SetColumnWidth(int iCol,int cx)
{

    Assert(m_hwnd);

    return ListView_SetColumnWidth(m_hwnd,iCol,cx);

}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::Expand, public
//
//  Synopsis:   expands all children of specified Item
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::Expand(int iItemId)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(iItemId);

    if (!pListViewItem)
    {
        return FALSE;
    }

    return ExpandCollapse(pListViewItem,TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::Collapse, public
//
//  Synopsis:   collapses all children of specified Item
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::Collapse(int iItemId)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(iItemId);

    if (!pListViewItem)
    {
        return FALSE;
    }

    return ExpandCollapse(pListViewItem,FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::FindItemFromBlob, public
//
//  Synopsis:   returns first item in list that matches blob
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

int CListView::FindItemFromBlob(LPLVBLOB pBlob)
{
LPLISTVIEWITEM pListViewItem;

    // if not items just return
    if (m_iListViewNodeCount < 1)
    {
        return -1;
    }

    pListViewItem = m_pListViewItems + m_iListViewNodeCount -1;  

    while(pListViewItem >= m_pListViewItems)
    {
        if (IsEqualBlob(pBlob,pListViewItem->lvItemEx.pBlob))
        {
            return pListViewItem->lvItemEx.iItem;
        }

        --pListViewItem;
    }

    return -1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::GetItemBlob, public
//
//  Synopsis:   finds blob is any associated with an
//              item and then fill in mem pointed
//              to by pBlob if cbSize in BlobStruc is >
//              specified cbBlockSize NULL is returned
//
//  Arguments:  
//
//  Returns:    NULL on failure
//              on success a pointer to the passed in buffer
//              strictly for convenience to the caller.
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LPLVBLOB CListView::GetItemBlob(int ItemId,LPLVBLOB pBlob,ULONG cbBlobSize)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromIndex(ItemId);
LPLVBLOB pItemBlob;

    if (!pListViewItem
        || (NULL == pListViewItem->lvItemEx.pBlob)
        || (NULL == pBlob))
    {
        Assert(pListViewItem);
        Assert(pBlob);
        return NULL;
    }

    pItemBlob = pListViewItem->lvItemEx.pBlob;

    // make sure out buffer is big enough
    if (cbBlobSize < pItemBlob->cbSize)
    {
        Assert(cbBlobSize >= pItemBlob->cbSize);
        return NULL;
    }

    memcpy(pBlob,pItemBlob,pItemBlob->cbSize);

    return pBlob;

}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::IsEqualBlob, private
//
//  Synopsis:   compares two blobs. Valid to pass in NULL put two NULLS is
//              not a match.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::IsEqualBlob(LPLVBLOB pBlob1,LPLVBLOB pBlob2)
{
    if (NULL == pBlob1 || NULL == pBlob2)
    {
        return FALSE;
    }

    // compare sizes
    if (pBlob1->cbSize != pBlob2->cbSize)
    {
        return FALSE;
    }

    if (0 != memcmp(pBlob1,pBlob2,pBlob2->cbSize))
    {
        return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::OnNotify, public
//
//  Synopsis:   Called by client whenever a native listview
//              notifiication is sent. We turn around, package
//              it up and send it as our notification message.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LRESULT CListView::OnNotify(LPNMHDR pnmv)
{
LPNMLISTVIEW pnlv = (LPNMLISTVIEW) pnmv; 
NMLISTVIEWEX nmvEx; 
LPLISTVIEWITEM pListViewItem;

    if ((NULL == pnmv) || ( ((int) pnmv->idFrom) != m_idCtrl) || (NULL == m_hwndParent))
    {
        Assert(pnmv);
        Assert( ((int) pnmv->idFrom) == m_idCtrl);
        Assert(m_hwndParent);
        return 0;
    }

    // take care of notifies we handle ourselves.
    switch(pnmv->code)
    {
        case LVN_GETDISPINFOW:
        case LVN_GETDISPINFOA:
        {
            OnGetDisplayInfo(pnmv->code,(LV_DISPINFO *) pnmv);
            return 0;
            break;
        }
        case LVN_SETDISPINFOW:
        case LVN_SETDISPINFOA:
        {
            OnSetDisplayInfo(pnmv->code,(LV_DISPINFO *) pnmv);
            return 0;
            break;
        }
        case NM_CUSTOMDRAW:
        {
           // return OnCustomDraw((NMCUSTOMDRAW *) pnmv);
            return 0;
            break;
        }
        case NM_DBLCLK:
        case NM_CLICK:
        {
        LV_HITTESTINFO lvhti;
        RECT Rect;

            lvhti.pt = pnlv->ptAction;

            // Have the ListView tell us what element this was on
            if (-1 != ListView_HitTest(m_hwnd, &lvhti))
            {

                // if flags are onitem change to either label or state depending
                // on the click positiion
                if (LVHT_ONITEM == lvhti.flags)
                {
                    lvhti.flags = LVHT_ONITEMLABEL; 

                    if (ListView_GetSubItemRect(m_hwnd,pnlv->iItem,0,LVIR_ICON,&Rect))
                    {
                        if (lvhti.pt.x < Rect.left)
                        {
                            lvhti.flags = LVHT_ONITEMSTATEICON; 
                        }
                        else if (lvhti.pt.x <= Rect.right)
                        {
                            // this doesn't ever get hit since icon is between label and state
                            // but its here for completeness.
                            lvhti.flags = LVHT_ONITEMICON; 
                        }

                    }

                }


                if (OnHandleUIEvent(pnmv->code,lvhti.flags,0,pnlv->iItem))
                {
                    return 0; // don't pass on clicks we process
                }
            }
            break;
        }
        case LVN_KEYDOWN:
        {
        LV_KEYDOWN* pnkd = (LV_KEYDOWN*) pnmv; 
        int iItem;
 
            if (-1 != (iItem = ListView_GetSelectionMark(m_hwnd)))
            {
                if(OnHandleUIEvent(pnmv->code,0,pnkd->wVKey,iItem))
                {
                    return 0;
                }
            }
    
            break;
        }
        default:
            break;
    }


    Assert(LVNEX_ITEMCHANGED == LVN_ITEMCHANGED);
    Assert(LVNEX_DBLCLK == NM_DBLCLK);
    Assert(LVNEX_CLICK == NM_CLICK);

    // only pass along notifications we know how to handle
    if (LVN_ITEMCHANGED != pnmv->code && NM_DBLCLK != pnmv->code && NM_CLICK != pnmv->code)
    {
        return 0;
    }

    // listview can send a iItem of -1 for example when
    // a double-click or click occurs in empty space. 
    // if get a -1 just pass through

    if (-1 == pnlv->iItem)
    {
        memcpy(&(nmvEx.nmListView),pnmv,sizeof(nmvEx.nmListView));
        nmvEx.iParent =  -1;  
        nmvEx.pBlob = NULL;

    }
    else
    {
        pListViewItem = ListViewItemFromNativeListViewItemId(pnlv->iItem);
        if (NULL == pListViewItem)
        {
            // if couldn't find itme 
            Assert(pListViewItem);
            return 0;
        }

        // assumes only pass along notifications of
        // type LPNMLISTVIEW

        // fix up the notify structure
        memcpy(&(nmvEx.nmListView),pnmv,sizeof(nmvEx.nmListView));
        nmvEx.nmListView.iItem = pListViewItem->lvItemEx.iItem; // make item point to our internal id

        nmvEx.iParent =  pListViewItem->lvItemEx.iParent;  
        nmvEx.pBlob = pListViewItem->lvItemEx.pBlob;
  
        if (LVIF_STATE & pnlv->uChanged )
        {
            // update our internal itemState for the item.
            // Note don't care about lower state bits
            if ( (pnlv->uNewState ^ pnlv->uOldState) &  LVIS_STATEIMAGEMASK)
            {
                pListViewItem->lvItemEx.state = (pnlv->uNewState & LVIS_STATEIMAGEMASK)
                               + (pListViewItem->lvItemEx.state & ~LVIS_STATEIMAGEMASK);
            }

            if ( (pnlv->uNewState ^ pnlv->uOldState) &  LVIS_OVERLAYMASK)
            {
                pListViewItem->lvItemEx.state = (pnlv->uNewState & LVIS_OVERLAYMASK)
                               + (pListViewItem->lvItemEx.state & ~LVIS_OVERLAYMASK);
            }

        }
    }

    // send off the message
    return SendMessage(m_hwndParent,m_MsgNotify,m_idCtrl,(LPARAM) &nmvEx);

}



//+---------------------------------------------------------------------------
//
//  Member:     CListView::ListViewItemFromNativeListViewItemId, private
//
//  Synopsis:  Given a native listview control itemId finds our internal ListViewItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LPLISTVIEWITEM CListView::ListViewItemFromNativeListViewItemId(int iNativeListViewItemId)
{
    return ListViewItemFromNativeListViewItemId(iNativeListViewItemId,0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::ListViewItemFromNativeListViewItemId, private
//
//  Synopsis:  Given a native listview control itemId finds our internal ListViewItem
//
//  Arguments:  iNativeListViewItemId - ItemId of the ListViewItem
//              iNativeListViewSubItemId - SubItemID of the ListViewItem
//              piNativeListViewItemId - [out] on succes iteId in nativelistview.
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LPLISTVIEWITEM CListView::ListViewItemFromNativeListViewItemId(int iNativeListViewItemId,
                                                    int iSubItem)
{
LPLISTVIEWITEM pListViewItem;

    if (-1 == iNativeListViewItemId)
    {
        return NULL;
    }

    if (NULL == m_pListViewItems || m_iListViewNodeCount < 1 
        ||  (iSubItem  > m_iNumColumns - 1))
    {
        Assert(NULL != m_pListViewItems);
        Assert(m_iListViewNodeCount >=  1);
        Assert(iSubItem <= (m_iNumColumns - 1));
        return NULL;
    }

    pListViewItem = m_pListViewItems + m_iListViewNodeCount -1;  

    while(pListViewItem >= m_pListViewItems)
    {
        if (iNativeListViewItemId == pListViewItem->iNativeListViewItemId)
        {
            break;
        }

        --pListViewItem;
    }

    if (pListViewItem < m_pListViewItems)
    {
        return NULL;
    }

    // if subItem is zero then we just return this listviewItem, else
    // need to walk forward the subItem array.
    
    if (0 == iSubItem)
    {
        return pListViewItem;
    }

    Assert(m_iNumColumns > 1); // should have already caught about but double-check
    
    pListViewItem = pListViewItem->pSubItems + iSubItem -1;

    return pListViewItem;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::ListViewItemFromIndex, private
//
//  Synopsis:   Finds internal listviewItem from ItemID we gave to client.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LPLISTVIEWITEM CListView::ListViewItemFromIndex(int iItemID)
{
    return ListViewItemFromIndex(iItemID,0,NULL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::ListViewItemFromIndex, private
//
//  Synopsis:   Finds internal listviewItem from ItemID we gave to client.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LPLISTVIEWITEM CListView::ListViewItemFromIndex(int iItemID,int iSubitem,int *piNativeListViewItemId)
{
LPLISTVIEWITEM pListViewItem;

    // if item isn't valid return NULL
    if (iItemID < 0 || iItemID >= m_iListViewNodeCount
            || (iSubitem  > m_iNumColumns - 1))
    {
        Assert(iItemID >= 0);
        Assert(iSubitem  <= m_iNumColumns - 1);

        // Assert(iItemID < m_iListViewNodeCount); choice dlg Calls GetCheckState until hits -1. 

        return NULL;
    }

    pListViewItem =  m_pListViewItems + iItemID;

    if (piNativeListViewItemId)
    {
        *piNativeListViewItemId = pListViewItem->iNativeListViewItemId;
    }

    if (0 == iSubitem)
    {
        return pListViewItem;
    }

    pListViewItem = pListViewItem->pSubItems + iSubitem -1;

    return pListViewItem;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::DeleteListViewItemSubItems, private
//
//  Synopsis:   Helper function to delete subItems associated with a ListViewItem
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    04-Aug-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CListView::DeleteListViewItemSubItems(LPLISTVIEWITEM pListItem)
{
LPLISTVIEWITEM pListViewSubItem;

    // if not subItems or number of columns isn't at least 2 bail.
    if ((NULL == pListItem->pSubItems) || (m_iNumColumns < 2))
    {
        Assert(NULL == pListItem->pSubItems && m_iNumColumns < 2); // should always match.
        return;
    }
            

    pListViewSubItem = pListItem->pSubItems + m_iNumColumns -2; // -2 ; covers first subItem and column of main item
   
    // free any text associated with the subItems
    Assert(m_iNumColumns > 1); 
    Assert(pListViewSubItem >= pListItem->pSubItems); 

    while (pListViewSubItem >= pListItem->pSubItems)
    {
        if (pListViewSubItem->lvItemEx.pszText)
        {
            Assert(LVIF_TEXT & pListViewSubItem->lvItemEx.mask);
            FREE(pListViewSubItem->lvItemEx.pszText);
        }

        --pListViewSubItem;
    }

    FREE(pListItem->pSubItems);
    pListItem->pSubItems = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::ExpandCollapse, private
//
//  Synopsis:   Expands or collapses children of given node.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::ExpandCollapse(LPLISTVIEWITEM pListViewItem,BOOL fExpand)
{
LPLISTVIEWITEM pCurListViewItem = pListViewItem + 1;
LPLISTVIEWITEM pLastListViewItem = m_pListViewItems + m_iListViewNodeCount -1;
int iIndent = pListViewItem->lvItemEx.iIndent;
int iInsertDeleteCount = 0;
LV_ITEM lvi = { 0 };    

    Assert(pListViewItem);
    Assert(m_iListViewNodeCount); 
    
    // if specified node isn't in the list view fail
    if (-1 == pListViewItem->iNativeListViewItemId)
    {
        Assert(-1 != pListViewItem->iNativeListViewItemId);
        return FALSE;
    }

    lvi.iItem = pListViewItem->iNativeListViewItemId + 1;
    
    while (pCurListViewItem <= pLastListViewItem 
            && pCurListViewItem->lvItemEx.iIndent > iIndent)
    {

        if (fExpand)
        {
            if ( (-1 == pCurListViewItem->iNativeListViewItemId)
                && (pCurListViewItem->lvItemEx.iIndent == iIndent + 1)) // only expand next level deep
            {
                pCurListViewItem->iNativeListViewItemId  = ListView_InsertItem(m_hwnd,&lvi);
                
                Assert(pCurListViewItem->iNativeListViewItemId  == lvi.iItem);
                if (-1 != pCurListViewItem->iNativeListViewItemId)
                {
                    ++lvi.iItem;
                    ++iInsertDeleteCount;
                }
            }
        }
        else
        {
           if (-1 != pCurListViewItem->iNativeListViewItemId)
            {
                pCurListViewItem->fExpanded = FALSE;
                if (ListView_DeleteItem(m_hwnd,lvi.iItem))
                {
                    pCurListViewItem->iNativeListViewItemId  = -1;
                    --iInsertDeleteCount;
                }
           }
        }

        ++pCurListViewItem;
    }

    // fixup nativeIds of any remaining items in the list
    while (pCurListViewItem <= pLastListViewItem)
    {
        if (-1 != pCurListViewItem->iNativeListViewItemId)
        {
            pCurListViewItem->iNativeListViewItemId += iInsertDeleteCount;
            Assert(pCurListViewItem->iNativeListViewItemId >= 0);
            Assert(pCurListViewItem->iNativeListViewItemId <  m_iListViewNodeCount);
        }
        
        ++pCurListViewItem;
    }

    pListViewItem->fExpanded = fExpand;

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CListView::OnGetDisplayInfo, private
//
//  Synopsis:   Handles Display info notification.
//
//  Arguments:  code -  code from notification header either
//                   LVN_GETDISPINFOW, LVN_GETDISPINFOA. need this
//                   so know how to handle Text.
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CListView::OnGetDisplayInfo(UINT code,LV_DISPINFO *plvdi)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromNativeListViewItemId(plvdi->item.iItem,
                                                                   plvdi->item.iSubItem);


    if (NULL == pListViewItem)
        return;

    // verify subitem iound matches item we asked for.
    Assert(pListViewItem->lvItemEx.iSubItem == plvdi->item.iSubItem);

    // The ListView needs text for this row
    if (plvdi->item.mask & LVIF_TEXT)
    {

        if (pListViewItem->lvItemEx.pszText)
        {
            if (LVN_GETDISPINFOW == code)
            {
                lstrcpyn(plvdi->item.pszText,pListViewItem->lvItemEx.pszText,plvdi->item.cchTextMax);
            }
            else
            {
            LV_DISPINFOA *plvdiA = (LV_DISPINFOA *) plvdi;
            XArray<CHAR> xszpszTextA;
            BOOL fOk;

                Assert(code == LVN_GETDISPINFOA);
                Assert(sizeof(LV_DISPINFOA) == sizeof(LV_DISPINFOW));

                *(plvdiA->item.pszText) = NULL; // return empty string on error.

                fOk = ConvertWideCharToMultiByte(pListViewItem->lvItemEx.pszText,xszpszTextA);
            
                if (fOk)
                {
                    lstrcpynA(plvdiA->item.pszText,xszpszTextA.Get(),plvdiA->item.cchTextMax);
                }
            }
            
        }
    }

    // The ListView needs an image
    if (plvdi->item.mask & LVIF_IMAGE)
    {
      // plvdi->item.iItem, plvdi->item.iSubItem, &(plvdi->item.iImage));
        plvdi->item.iImage = pListViewItem->lvItemEx.iImage;
    }

    // The ListView needs the indent level
    if (plvdi->item.mask & LVIF_INDENT)
    {
       // if (m_fThreadMessages)
       //     m_pTable->GetIndentLevel(plvdi->item.iItem, (LPDWORD) &(plvdi->item.iIndent));
       // else

        // for no checks on top-level set image state to empty pict and
        // indent to -1. Need additional State Logic if want to 
        // choose if toplevel checks are shown.
        plvdi->item.iIndent = pListViewItem->lvItemEx.iIndent;

        if ( (m_dwExStyle & LVS_EX_CHECKBOXES) && (0 == plvdi->item.iIndent) )
        {   
            plvdi->item.iIndent = -1;
        }
    }

    // The ListView needs the state image
    if (plvdi->item.mask & LVIF_STATE)
    {
       //nt iIcon = 0;
      //  _GetColumnStateImage(plvdi->item.iItem, plvdi->item.iSubItem, &iIcon);
        plvdi->item.state = pListViewItem->lvItemEx.state & LVIS_STATEIMAGEMASK;
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::OnSetDisplayInfo, private
//
//  Synopsis:   Handles Display info notification.
//
//  Arguments:  code -  code from notification header either
//                   LVN_SETDISPINFOW, LVN_SETDISPINFOA. need this
//                   so know how to handle Text.
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

void CListView::OnSetDisplayInfo(UINT code,LV_DISPINFO *plvdi)
{

    // The ListView needs text for this row
    if (plvdi->item.mask & LVIF_TEXT)
    {
        // plvdi->item.iSubItem
        // plvdi->item.pszText, plvdi->item.cchTextMax);
       // lstrcpy(plvdi->item.pszText,L"dude");
    }

    // The ListView needs an image
    if (plvdi->item.mask & LVIF_IMAGE)
    {
      // plvdi->item.iItem, plvdi->item.iSubItem, &(plvdi->item.iImage));
      //  plvdi->item.iImage = 1;
    }

    // The ListView needs the indent level
    if (plvdi->item.mask & LVIF_INDENT)
    {
       // if (m_fThreadMessages)
       //     m_pTable->GetIndentLevel(plvdi->item.iItem, (LPDWORD) &(plvdi->item.iIndent));
       // else
      //   plvdi->item.iIndent = 4;
    }

    // The ListView needs the state image
    if (plvdi->item.mask & LVIF_STATE)
    {
       //nt iIcon = 0;
      //  _GetColumnStateImage(plvdi->item.iItem, plvdi->item.iSubItem, &iIcon);
     //   plvdi->item.state = 1 << 12;

        AssertSz(0,"State Change");
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::OnCustomDraw, private
//
//  Synopsis:   Handles CustomDraw  notification.
//
//  Arguments:  
//
//  Returns:    
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

LRESULT CListView::OnCustomDraw(NMCUSTOMDRAW *pnmcd)
{

#ifdef _LISTVIEW_CUSTOMDRAW

LPNMLVCUSTOMDRAW  lplvcd = (LPNMLVCUSTOMDRAW) pnmcd;


     /*
     CDDS_PREPAINT is at the beginning of the paint cycle. You 
     implement custom draw by returning the proper value. In this 
     case, we're requesting item-specific notifications.
     */
     if(lplvcd->nmcd.dwDrawStage == CDDS_PREPAINT)
     {
        // Request prepaint notifications for each item.
        return CDRF_NOTIFYITEMDRAW;
     }

     /*
     Because we returned CDRF_NOTIFYITEMDRAW in response to
     CDDS_PREPAINT, CDDS_ITEMPREPAINT is sent when the control is
     about to paint an item.
     */
     if(lplvcd->nmcd.dwDrawStage == CDDS_ITEMPREPAINT){
        /*
        To change the font, select the desired font into the 
        provided HDC. We're changing the font for every third item
        in the control, starting with item zero.
        */

        if( 1 /* !(lplvcd->nmcd.dwItemSpec % 3) */)
        {
          // SelectObject(lplvcd->nmcd.hdc, g_hNewFont);
        }
        else
        {
           return(CDRF_DODEFAULT);
        }

        /*
        To change the text and background colors in a list view 
        control, set the clrText and clrTextBk members of the 
        NMLVCUSTOMDRAW structure to the desired color.

        This differs from most other controls that support 
        CustomDraw. To change the text and background colors for 
        the others, call SetTextColor and SetBkColor on the provided HDC.
        */
        lplvcd->clrText = RGB(126,126, 126);
       // lplvcd->clrTextBk = RGB(0,255,255);

        /*
        We changed the font, so we're returning CDRF_NEWFONT. This
        tells the control to recalculate the extent of the text.
        */
        return CDRF_NEWFONT;
        }

#endif //  _LISTVIEW_CUSTOMDRAW

     return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CListView::OnHandleUIEvent private
//
//  Synopsis:   sent when a click or double-click,keyboard, is sent to 
//              the listview
//
//  Arguments:  code -  indicates why this function was called
//                      Support NM_DBLCLK, NM_CLICK, LVN_KEYDOWN:
//
//              flags - flags from hitTest. Only valid for DBCLK and CLICK
//                          flag = LVHT_ONITEMSTATEICON | LVHT_ONITEMICON) |LVHT_ONITEMLABEL
//              wVKey - Virtual key code of key presses. Ony valide cfor LVN_KEYDOWN
//              iItemNative - ItemID in NativeListView
//
//
//  Returns:   TRUE - if handled event and notification shouldn't be passed on. 
//
//  Modifies:   
//
//  History:    23-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL CListView::OnHandleUIEvent(UINT code,UINT flags,WORD wVKey,int iItemNative)
{
LPLISTVIEWITEM pListViewItem = ListViewItemFromNativeListViewItemId(iItemNative);
int iStateMask;
BOOL fItemHasCheckBoxes; // for now this is hardcoded depending on the indent. Need to change this.
BOOL fToggleCheckBox = FALSE;
BOOL fExpand = FALSE;
BOOL fCollapse = FALSE;
BOOL fReturn = FALSE;

    if (NULL == pListViewItem)
    {
        return TRUE; // no need passing this on
    }

    fItemHasCheckBoxes = pListViewItem->lvItemEx.iIndent ? TRUE : FALSE;

   //  If Item has chechboxes toggle on keyboard space or mouse clicks
    //  over the itemState Icon.

    // double-clicks on itemIcon togles the whether the branch is expanded/collasse    
    // if left/right keyboard expand collapse

    switch(code)
    {
        case LVN_KEYDOWN:
        {
            switch(wVKey)
            {
                case VK_SPACE:
                    if (fItemHasCheckBoxes)
                    {
                        fToggleCheckBox = TRUE;
                    }
                   break;
                case VK_RIGHT:
                case VK_LEFT:
                    if (pListViewItem->iChildren)
                    {
                        fExpand = VK_RIGHT == wVKey ? TRUE : FALSE;
                        fCollapse = !fExpand;
                    }
                    break;
                default:
                    break;
            }
        }
        case NM_DBLCLK:
            if ( (flags & LVHT_ONITEMICON) && (pListViewItem->iChildren))
            {
                fExpand = pListViewItem->fExpanded ? FALSE : TRUE;
                fCollapse = !fExpand;
                break;
            }
            // double-click falls through to a click.
        case NM_CLICK:
            if ((flags & LVHT_ONITEMSTATEICON) 
                 && fItemHasCheckBoxes)
            {
                fToggleCheckBox = TRUE;
            }
            break;
        default:
            break;
    }


    if (fExpand || fCollapse)
    {
        // don't bother if already in current state
        if (pListViewItem->fExpanded != fExpand)
        {
            ExpandCollapse(pListViewItem,fExpand);
        }
        return TRUE;
    }
    else if (fToggleCheckBox)
    {
        // for now just toggle the state. if have children need to set them appropriately.
        iStateMask = LVITEMEXSTATE_CHECKED == GetCheckState(pListViewItem->lvItemEx.iItem) 
                        ? LVIS_STATEIMAGEMASK_UNCHECK : LVIS_STATEIMAGEMASK_CHECK;

        SetItemState(pListViewItem->lvItemEx.iItem,iStateMask,LVIS_STATEIMAGEMASK);
        
        return TRUE;
    }

    return fReturn; // default we pass it along
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\lib\netapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       netapi.cpp
//
//  Contents:   Network/SENS API wrappers
//
//  Classes:
//
//  Notes:
//
//  History:    08-Dec-97   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "lib.h"

//+---------------------------------------------------------------------------
//
//  Function:   ResetNetworkIdle, public
//
//  Synopsis:   post messages to wininet to keep wininet connection
//          from thinking it is idle so the connection isn't closed
//          in the middle of a sync.
//
//          Code supplied by Darren Mitchell.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-June-98       rogerg        Created.
//
//----------------------------------------------------------------------------

STDAPI ResetNetworkIdle()
{
#define WM_DIALMON_FIRST        WM_USER+100
#define WM_WINSOCK_ACTIVITY     WM_DIALMON_FIRST + 0

    // Inform dial monitor that stuff is going on to keep it from
    // hanging up any idle connections.
    HWND hwndMonitorWnd = FindWindow(TEXT("MS_AutodialMonitor"),NULL);
    if (hwndMonitorWnd)
    {
        PostMessage(hwndMonitorWnd,WM_WINSOCK_ACTIVITY,0,0);
    }

    hwndMonitorWnd = FindWindow(TEXT("MS_WebcheckMonitor"),NULL);
    if (hwndMonitorWnd)
    {
        PostMessage(hwndMonitorWnd,WM_WINSOCK_ACTIVITY,0,0);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\lib\stringc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       stringc.c
//
//  Contents:   SyncMgr string constants
//
//  History:    18-Feb-98   SusiA      Created.
//
//--------------------------------------------------------------------------

#include <objbase.h>

const WCHAR SZ_SYNCMGRNAME[] =  TEXT("Synchronization Manager");

const WCHAR REGSTR_WINLOGON[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
const WCHAR  REGSTR_DEFAULT_DOMAIN[] = TEXT("DefaultDomainName");

const WCHAR  CREATOR_SYNCMGR_TASK[] = L"SyncMgrInternalCreatorName";
const WCHAR  SCHED_COMMAND_LINE_ARG[] = L" /Schedule=";

// strings consts used for registration
// should have a preference class so these strings can be moved to the dll.
const WCHAR TOPLEVEL_REGKEY[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr");

const WCHAR HANDLERS_REGKEY[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr\\Handlers");
const WCHAR AUTOSYNC_REGKEY[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr\\AutoSync");
const WCHAR IDLESYNC_REGKEY[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr\\Idle");
const WCHAR SCHEDSYNC_REGKEY[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr\\SchedSync");
const WCHAR MANUALSYNC_REGKEY[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr\\Manual");
const WCHAR PROGRESS_REGKEY[]   = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr\\ProgressState");

const WCHAR SZ_IDLELASTHANDLERKEY[]  = TEXT("LastIdleHandler");
const WCHAR SZ_IDLERETRYMINUTESKEY[]  = TEXT("IdleRetryMinutes");
const WCHAR SZ_IDLEDELAYSHUTDOWNTIMEKEY[]  = TEXT("DelayShutDownTime");
const WCHAR SZ_IDLEREPEATESYNCHRONIZATIONKEY[] = TEXT("RepeatSynchronization");
const WCHAR SZ_IDLEWAITAFTERIDLEMINUTESKEY[] = TEXT("WaitMinutesAfterIdle");
const WCHAR SZ_IDLERUNONBATTERIESKEY[]    = TEXT("RunOnBattery");

const WCHAR SZ_REGISTRATIONFLAGSKEY[] = TEXT("RegistrationFlags");
const WCHAR SZ_REGISTRATIONTIMESTAMPKEY[] = TEXT("TimeStamp");

const WCHAR SZ_DEFAULTDOMAINANDUSERNAME[] = TEXT("Default");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\lib\validate.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       validate.cpp
//
//  Contents:   validation routines
//
//  Classes:
//
//  Notes:
//
//  History:    13-Aug-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#include "lib.h"



//+---------------------------------------------------------------------------
//
//  function:   IsValidSyncMgrItem
//
//  Synopsis:   validates SYNCMGRITEM
//
//  Arguments:  
//
//  Returns:   TRUE if valid.
//
//  Modifies:
//
//  History:    13-Aug-98       rogerg        Created.
//
//+---------------------------------------------------------------------------

BOOL IsValidSyncMgrItem(SYNCMGRITEM *poffItem)
{
BOOL fValid = TRUE;

    if (NULL == poffItem)
    {
        Assert(poffItem);
        return FALSE;
    }
    __try
    {
        if (poffItem->cbSize == sizeof(SYNCMGRITEMNT5B2))
        {
            // this is an old NT5b2 stucture. not really anything
            // to do other than make sure flags are valid for ths struct.

            Assert(0 == (poffItem->dwFlags & ~(SYNCMGRITEM_ITEMFLAGMASKNT5B2)));
            // for BETA2 go ahead and fall through since didn't validate 
            // and we can remove this.

        }
        else if (poffItem->cbSize == sizeof(SYNCMGRITEM))
        {
        
            if ( (0 != (poffItem->dwFlags & ~(SYNCMGRITEM_ITEMFLAGMASK) ) )
                || (SYNCMGRITEMSTATE_CHECKED <  poffItem->dwItemState) )
            {
                AssertSz(0,"Invalid SYNCMGRITEM returned from Enumerator");
                Assert(0 == (poffItem->dwFlags & ~(SYNCMGRITEM_ITEMFLAGMASK)));
                Assert(SYNCMGRITEMSTATE_CHECKED >= poffItem->dwItemState);

                fValid = FALSE;
            }
            else if (GUID_NULL == poffItem->ItemID)
            {
                AssertSz(0,"ItemID Cannot be GUID_NULL");
                fValid = FALSE;
            }
        }
        else
        {
            AssertSz(0,"Invalid SYNCMGRITEM returned from Enumerator");
            fValid = FALSE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //bogus non-NULL pointer.
        AssertSz(0,"Bogus, non-NULL SYNCMGRITEM pointer returned from Enumerator");
        fValid = FALSE;
    }
    return fValid;
}

//+---------------------------------------------------------------------------
//
//  function:   IsValidSyncMgrHandlerInfo
//
//  Synopsis:   validates SYNCMGRITEM
//
//  Arguments:  
//
//  Returns:   TRUE if valid.
//
//  Modifies:
//
//  History:    13-Aug-98       rogerg        Created.
//
//+---------------------------------------------------------------------------

BOOL IsValidSyncMgrHandlerInfo(LPSYNCMGRHANDLERINFO pSyncMgrHandlerInfo)
{
    // validate the arguments.
    __try
    {
        if ( (pSyncMgrHandlerInfo->cbSize != sizeof(SYNCMGRHANDLERINFO))
            || (0 != (pSyncMgrHandlerInfo->SyncMgrHandlerFlags & ~(SYNCMGRHANDLERFLAG_MASK))) )
        {
            AssertSz(0,"Invalid HandlerInfo Size returned from GetHandlerInfo");
            Assert(pSyncMgrHandlerInfo->cbSize == sizeof(SYNCMGRHANDLERINFO));
            Assert(0 == (pSyncMgrHandlerInfo->SyncMgrHandlerFlags & ~(SYNCMGRHANDLERFLAG_MASK)));

            return FALSE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        AssertSz(0,"Bogus, non-NULL LPSYNCMGRHANDLERINFO pointer.");
        return FALSE;
    }
    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Function:   IsValidSyncProgressItem, private
//
//  Synopsis:   Determines if the syncprogress item structure is valid
//
//  Arguments:  [lpProgItem] - Pointer to SyncProgress Item to validate.
//
//  Returns:    Returns true is the structure is valid.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

BOOL IsValidSyncProgressItem(LPSYNCMGRPROGRESSITEM lpProgItem)
{

    if (NULL == lpProgItem)
    {
        Assert(lpProgItem);
        return FALSE;
    }
    __try
    {
        if (lpProgItem->cbSize != sizeof(SYNCMGRPROGRESSITEM))
        {
            AssertSz(0,"SYNCMGRPROGRESSITEM cbSize Incorrect");
            return FALSE;
        }


        if (IsBadReadPtr(lpProgItem,sizeof(SYNCMGRPROGRESSITEM)) )
        {
            AssertSz(0,"ProgressItem Structure Memory Invalid");
            return FALSE;
        }


        if (lpProgItem->mask >= (SYNCMGRPROGRESSITEM_MAXVALUE << 1))
        {
            AssertSz(0,"Invalid ProgressItem Mask");
            return FALSE;
        }

        if (SYNCMGRPROGRESSITEM_STATUSTYPE & lpProgItem->mask)
        {
            if (lpProgItem->dwStatusType  >  SYNCMGRSTATUS_RESUMING)
            {
                AssertSz(0,"Unknown StatusType passed to Progress");
                return FALSE;
            }

        }

        if (SYNCMGRPROGRESSITEM_STATUSTEXT & lpProgItem->mask)
        {
            if (IsBadStringPtr(lpProgItem->lpcStatusText,-1) )
            {
                AssertSz(0,"Invalid status text");
                return FALSE;
            }


        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        AssertSz(0,"Bogus, non-NULL LPSYNCMGRPROGRESSITEM pointer.");
        return FALSE;
    }
    
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsValidSyncLogErrorInfo, private
//
//  Synopsis:   Determines if the ErrorInfomation is valid,
//
//  Arguments:  [lpLogError] - Pointer to LogError structure to validate.
//
//  Returns:    Returns true is the structure is valid.
//
//  Modifies:
//
//  History:    17-Nov-97       rogerg        Created.
//
//----------------------------------------------------------------------------

#define SYNCMGRLOGERROR_VALIDMASK (SYNCMGRLOGERROR_ERRORFLAGS | SYNCMGRLOGERROR_ERRORID | SYNCMGRLOGERROR_ITEMID)
#define SYNCMGRERRROFLAG_MASK (SYNCMGRERRORFLAG_ENABLEJUMPTEXT)

BOOL IsValidSyncLogErrorInfo(DWORD dwErrorLevel,const WCHAR *lpcErrorText,
                                        LPSYNCMGRLOGERRORINFO lpSyncLogError)
{

    if (SYNCMGRLOGLEVEL_ERROR < dwErrorLevel)
    {
        AssertSz(0,"Invalid ErrorLevel");
        return FALSE;
    }

    // must provide error text
    if ( (NULL == lpcErrorText) ||
            IsBadStringPtr(lpcErrorText,-1) )
    {
        AssertSz(0,"Invalid ErrorText");
        return FALSE;
    }

    // Optional to have the LogError information.
    __try
    {
        if (lpSyncLogError)
        {
            if (lpSyncLogError->cbSize != sizeof(SYNCMGRLOGERRORINFO))
            {
                AssertSz(0,"Unknown LogError cbSize");
                return FALSE;
            }

            if (IsBadReadPtr(lpSyncLogError,sizeof(SYNCMGRLOGERRORINFO)) )
            {
                AssertSz(0,"Log Structure Memory Invalid");
                return FALSE;
            }
    
            if (0 != (lpSyncLogError->mask & ~(SYNCMGRLOGERROR_VALIDMASK)) )
            {
                AssertSz(0,"Invalid LogError Mask");
                return FALSE;
            }

            if (lpSyncLogError->mask & SYNCMGRLOGERROR_ERRORFLAGS)
            {
                if (0 != (~(SYNCMGRERRROFLAG_MASK) & lpSyncLogError->dwSyncMgrErrorFlags))
                {
                    AssertSz(0,"Invalid LogError ErrorFlags");
                    return FALSE;
                }

            }

        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        AssertSz(0,"Bogus, non-NULL LPSYNCMGRLOGERRORINFO pointer.");
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\lib\util.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       util.cxx
//
//  Contents:   utility functions
//
//
//  History:    12-05-1997   SusiA
//
//---------------------------------------------------------------------------

#include "lib.h"
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif
#include "security.h"

extern "C" CRITICAL_SECTION g_CritSectCommonLib; // initialized by InitCommonLib
extern OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo.

typedef BOOLEAN (APIENTRY *PFNGETUSERNAMEEX) (EXTENDED_NAME_FORMAT NameFormat,
    LPWSTR lpNameBuffer, PULONG nSize );

STRING_FILENAME(szSecur32Dll, "SECUR32.DLL");
STRING_INTERFACE(szGetUserNameEx,"GetUserNameExW");
BOOL g_fLoadedSecur32 = FALSE;
HINSTANCE g_hinstSecur32 = NULL;
PFNGETUSERNAMEEX g_pfGetUserNameEx = NULL;


//--------------------------------------------------------------------------------
//
//  FUNCTION: RegGetCurrentUser(LPTSTR pszName, LPDWORD pdwCount)
//
//  PURPOSE:  Gets the currently logged on user name from the Reg
//
//--------------------------------------------------------------------------------

BOOL RegGetCurrentUser(LPTSTR pszName, LPDWORD pdwCount)
{
HRESULT hr = ERROR_SUCCESS;
HKEY hkeyUser;
DWORD dwDataSize = *pdwCount * sizeof(TCHAR);
DWORD dwType = REG_SZ;

     
    // Get the current user name from the reg
    if (ERROR_SUCCESS == (hr  = RegOpenKeyExXp(HKEY_CURRENT_USER, 
                            TOPLEVEL_REGKEY,0,KEY_QUERY_VALUE,&hkeyUser,FALSE /*fSetSecurity*/)))
    {
    
        hr = RegQueryValueEx(hkeyUser,TEXT("CurrentUserName"),
                             NULL, &dwType ,  
			     (LPBYTE) pszName,
			     &dwDataSize);
        
        *pdwCount = dwDataSize;
        RegCloseKey(hkeyUser);
    }
    
    if (ERROR_SUCCESS == hr)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
    
}

//--------------------------------------------------------------------------------
//
//  FUNCTION: RegSetCurrentUser(LPTSTR pszName)
//
//  PURPOSE:  sets the current user name in the reg
//
//--------------------------------------------------------------------------------

BOOL RegSetCurrentUser(LPTSTR pszName)
{
HRESULT hr = ERROR_SUCCESS;
HKEY hkeyUser;

    // write out the Handler to the Registry.
    if (ERROR_SUCCESS == (hr = RegCreateKeyEx(HKEY_CURRENT_USER, 
                            TOPLEVEL_REGKEY,0,NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_WRITE | KEY_CREATE_SUB_KEY,
                            NULL,&hkeyUser, NULL)))
    {

        hr = RegSetValueEx(hkeyUser,TEXT("CurrentUserName"),
                             NULL, REG_SZ ,  
			     (LPBYTE) pszName,
			     UNLEN + 1);

        RegCloseKey(hkeyUser);
    }

    if (ERROR_SUCCESS == hr)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CenterDialog
//
//  Synopsis:   Helper to center a dialog on screen.
//
//  Arguments:  [hDlg]   -- Dialog handle.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CenterDialog(HWND hDlg)
{
    RECT rc;
    GetWindowRect(hDlg, &rc);

    SetWindowPos(hDlg,
                 NULL,
                 ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
                 ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
                 0,
                 0,
                 SWP_NOSIZE | SWP_NOACTIVATE);
}

//+--------------------------------------------------------------------------
//
//  Function:   GetDomainAndMachineName
//
//  Synopsis:   Fill [ptszDomainAndMachineName] with "domain\machine" string
//
//  Arguments:  [ptszDomainAndMachineName] - buffer to receive string
//              [cchBuf]                - should be at least UNLEN
//
//  Modifies:   *[ptszDomainAndMachineName].
//
//  History:    01-12-1998   SusiA  Created
//
//  Notes:      If an error occurs while retrieving the domain name, only
//              the machine name is returned.  If even that cannot be
//              retrieved, the buffer is set to an empty string.
//
//---------------------------------------------------------------------------

VOID
GetDomainAndMachineName(
    LPTSTR ptszDomainAndMachineName,
    ULONG  cchBuf)
{

    HRESULT hr = E_FAIL;
    LONG  lr;
    HKEY hkWinlogon = NULL;
    ULONG cchRemain = cchBuf;

    do
    {
        //
        // Get the domain name of the currently logged on user.  Open the
        // winlogon key.
        //

        lr = RegOpenKeyExXp(HKEY_LOCAL_MACHINE,
                          REGSTR_WINLOGON,
                          0,
                          KEY_QUERY_VALUE,
                          &hkWinlogon,FALSE /*fSetSecurity*/);

        if (lr != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Query for the default domain, which is what the user logged on to.
        //

        ULONG cbBuf = cchBuf * sizeof(TCHAR);
        DWORD dwType;

        lr = RegQueryValueEx(hkWinlogon,
                             REGSTR_DEFAULT_DOMAIN,
                             NULL,
                             &dwType,
                             (LPBYTE) ptszDomainAndMachineName,
                             &cbBuf);

        if (lr != ERROR_SUCCESS)
        {
                        break;
        }

        Assert(dwType == REG_SZ);

        //
        // Account for the characters used up by the domain name, but
        // don't count the trailing NULL.
        //

        cchRemain -= (cbBuf / sizeof(TCHAR)) - 1;

        if (cchRemain < 2)
        {
                        break;
        }

        lstrcat(ptszDomainAndMachineName, TEXT("/"));
        cchRemain--;

        hr = S_OK;
    } while (0);

    //
    // If there was any problem with the domain name, put only the user name
    // in the buffer.
    //

    if (FAILED(hr))
    {
        *ptszDomainAndMachineName = TEXT('\0');
        cchRemain = cchBuf;
    }

    //
    // Get the machine name, which is going either at the start of the buffer
    // or just after the backslash appended to the domain name.
    //

    lr = GetComputerName(&ptszDomainAndMachineName[cchBuf - cchRemain], &cchRemain);

    if (!lr)
    {
        *ptszDomainAndMachineName = TEXT('\0');
    }

    if (hkWinlogon)
    {
        RegCloseKey(hkWinlogon);
    }
}

void LoadSecur32Dll()
{
    if (g_fLoadedSecur32)
        return;

    CCriticalSection cCritSect(&g_CritSectCommonLib,GetCurrentThreadId());

    cCritSect.Enter();

    // make sure not loaded again in case someone took lock first
    if (!g_fLoadedSecur32)
    {
        g_hinstSecur32 = LoadLibrary(szSecur32Dll);

        if (g_hinstSecur32)
        {
	    g_pfGetUserNameEx = (PFNGETUSERNAMEEX) GetProcAddress(g_hinstSecur32, szGetUserNameEx);

	    // won't get the export on NT 4.0
  	}

        g_fLoadedSecur32 = TRUE;
    }

    cCritSect.Leave();

}
//+--------------------------------------------------------------------------
//
//  Function:   GetNT4UserDomainName
//
//  Synopsis:   Fill [ptszDomainAndUserName] with "domain\user" string
//
//  Arguments:  [ptszDomainAndUserName] - buffer to receive string
//              [cchBuf]                - should be at least UNLEN
//
//  Modifies:   *[ptszDomainAndUserName].
//
//  History:    06-03-1997   DavidMun   Created
//
//  Notes:      If an error occurs while retrieving the domain name, only
//              the user name is returned.  If even that cannot be
//              retrieved, the buffer is set to an empty string.
//
//---------------------------------------------------------------------------

BOOL GetNT4UserDomainName(LPTSTR ptszDomainAndUserName,
        LPTSTR ptszSeparator,
        ULONG  cchBuf)
{
HKEY hkWinlogon = NULL;
ULONG cchRemain = cchBuf;
HRESULT hr = E_FAIL;
LONG  lr;
ULONG cchTemp = UNLEN + DNLEN + 1;

    do
    {
        //
        // Get the domain name of the currently logged on user.  Open the
        // winlogon key.
        //

        lr = RegOpenKeyExXp(HKEY_LOCAL_MACHINE,
                          REGSTR_WINLOGON,
                          0,
                          KEY_QUERY_VALUE,
                          &hkWinlogon,FALSE /*fSetSecurity*/);

        if (lr != ERROR_SUCCESS)
        {
            break;
        }

        //
        // Query for the default domain, which is what the user logged on to.
        //

        ULONG cbBuf = cchBuf * sizeof(TCHAR);
        DWORD dwType;

        lr = RegQueryValueEx(hkWinlogon,
                             REGSTR_DEFAULT_DOMAIN,
                             NULL,
                             &dwType,
                             (LPBYTE) ptszDomainAndUserName,
                             &cbBuf);

        if (lr != ERROR_SUCCESS)
        {
            break;
        }

        Assert(dwType == REG_SZ);

        //
        // Account for the characters used up by the domain name, but
        // don't count the trailing NULL.
        //

        cchRemain -= (cbBuf / sizeof(TCHAR)) - 1;

        if (cchRemain < 2)
        {
                        break;
        }

        lstrcat(ptszDomainAndUserName, ptszSeparator);
        cchRemain--;

        hr = S_OK;
    } while (0);

    //
    // If there was any problem with the domain name, put only the user name
    // in the buffer.
    //

    if (FAILED(hr))
    {
        *ptszDomainAndUserName = TEXT('\0');
        cchRemain = cchBuf;
    }

    //
    // Get the user name, which is going either at the start of the buffer
    // or just after the backslash appended to the domain name.
    //

    cchTemp = cchRemain;

    lr = GetUserName(&ptszDomainAndUserName[cchBuf - cchTemp], &cchTemp);
    if (hkWinlogon)
    {
        RegCloseKey(hkWinlogon);
    }


    return (S_OK == hr) ? TRUE: FALSE;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetDefaultDomainAndUserName
//
//  Synopsis:   Fill [ptszDomainAndUserName] with "domain\user" string
//
//  Arguments:  [ptszDomainAndUserName] - buffer to receive string
//              [cchBuf]                - should be at least UNLEN
//
//  Modifies:   *[ptszDomainAndUserName].
//
//  History:    06-03-1997   DavidMun   Created
//
//  Notes:      If an error occurs while retrieving the domain name, only
//              the user name is returned.  If even that cannot be
//              retrieved, the buffer is set to an empty string.
//
//---------------------------------------------------------------------------

// if output buffer is too small it gets truncated.

VOID
GetDefaultDomainAndUserName(
    LPTSTR ptszDomainAndUserName,
        LPTSTR ptszSeparator,
    ULONG  cchBuf)
{
HRESULT hr = E_FAIL;
LONG  lr = 0;
ULONG cchTemp = UNLEN + DNLEN + 1;
BOOL fIsNT = (g_OSVersionInfo.dwPlatformId ==  VER_PLATFORM_WIN32_NT);
    
    if (fIsNT)
    {
        LoadSecur32Dll();
        
        if (g_pfGetUserNameEx)
        {
            lr = g_pfGetUserNameEx(NameSamCompatible,ptszDomainAndUserName, &cchTemp);
           
            if (lr)
            {
            LPTSTR ptszWorker = ptszDomainAndUserName;

                while ( (TEXT('\0') != *ptszWorker) && *ptszWorker != TEXT('\\'))
                {
                    ptszWorker++;
                }

                if ( TEXT('\0') != *ptszWorker)
                {
                    *ptszWorker = ptszSeparator[0];
                }
            }
        }


        if ((NULL == g_pfGetUserNameEx) || (0 == lr))
        {
            GetNT4UserDomainName(ptszDomainAndUserName,ptszSeparator,cchBuf);
        }

    }
    else
    {
        // Win9x Stuff.

        cchTemp = cchBuf;

        if (!(lr = RegGetCurrentUser(ptszDomainAndUserName, &cchTemp)))
        {        
            cchTemp = cchBuf;

            lr = GetUserName(ptszDomainAndUserName,&cchTemp);

            if (!lr || (*ptszDomainAndUserName == NULL))
            {
                // on Win9x user can work without a user Name in this case
                // or any other GetUserName file the user is forced
                // to be called Default

                Assert(lstrlen(SZ_DEFAULTDOMAINANDUSERNAME) < cchBuf);

                lstrcpy(ptszDomainAndUserName,SZ_DEFAULTDOMAINANDUSERNAME);
            }

            // write out currentUser setting so can use next time.
            RegSetCurrentUser(ptszDomainAndUserName);
        }

    }

    Assert(NULL != *ptszDomainAndUserName);
    return;

}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL ConvertString(LPTSTR pszOut, LPWSTR pwszIn, DWORD dwSize)
//
//  PURPOSE: utility function for ANSI/UNICODE conversion
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL ConvertString(char * pszOut, LPWSTR pwszIn, DWORD dwSize)
{

    if(WideCharToMultiByte( CP_ACP,0,pwszIn,-1,pszOut,dwSize,NULL,NULL))
    {
            return TRUE;
    }
    return FALSE;

}

//+-------------------------------------------------------------------------------
//
//  FUNCTION: BOOL ConvertString(LPWSTR pwszOut, LPTSTR pszIn, DWORD dwSize)
//
//  PURPOSE: utility function for ANSI/UNICODE conversion
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------
BOOL ConvertString(LPWSTR pwszOut,char * pszIn, DWORD dwSize)
{

    if(MultiByteToWideChar( CP_ACP,0,pszIn,-1,pwszOut,dwSize))
    {
            return TRUE;
    }

    return FALSE;

}




//+-------------------------------------------------------------------------------
//
//  FUNCTION: Bogus function temporary until get transitioned to unicode
//      so I don't have to fix up every existing converstring call.
//
//  PURPOSE: utility function for ANSI/UNICODE conversion
//
//  RETURN VALUE: return TRUE if we process it ok.
//
//+-------------------------------------------------------------------------------

BOOL ConvertString(LPWSTR pszOut, LPWSTR pwszIn, DWORD dwSize)
{
#ifdef _UNICODE
    lstrcpy(pszOut,pwszIn);
#else
    AssertSz(0,"Shouldn't be called in ASCII mode");
#endif // _UNICODE
    return TRUE;
}


//+-------------------------------------------------------------------------------
//
//  Function:  ConvertMultiByteToWideChar
//
//  Synopsis:  Converts multibyte strings to Unicode
//
/// Arguments: [pszBufIn]   -- Input multibyte string
//             [cbBufIn]    -- Count of chars/bytes in input buffer
//             [xwszBufOut] -- Smart pointer to output Unicode string
//             [fOem]        -- If true use CP_OEMCP
//
//  Returns:   TRUE if we process it ok
//
//  History:   14-Jul-98   SitaramR    Created
//
//+-------------------------------------------------------------------------------

BOOL ConvertMultiByteToWideChar( const char *pszBufIn,
                                 ULONG cbBufIn,
                                 XArray<WCHAR>& xwszBufOut,
                                 BOOL fOem )
{
    Assert( pszBufIn != 0 );

    if ( 0 == cbBufIn )
    {
        xwszBufOut[0] = 0;
        return TRUE;
    }

    BOOL fOk;
    if ( xwszBufOut.Get() == 0 )
    {
    ULONG cbBufOut;

        cbBufOut = (-1 == cbBufIn) ? lstrlenA(pszBufIn) + 1: cbBufIn;
        cbBufOut += 6; // give it a little extra room

        fOk = xwszBufOut.Init(cbBufOut);
        if ( !fOk )
            return FALSE;
    }

    UINT codePage = CP_ACP;
    if ( fOem && !AreFileApisANSI() )
        codePage = CP_OEMCP;

    ULONG cwcBufOut = (ULONG)xwszBufOut.Count();
    ULONG cwcConvert = 0;

    do
    {
        cwcConvert = MultiByteToWideChar( codePage,
                                          MB_PRECOMPOSED,
                                          pszBufIn,
                                          cbBufIn,
                                          xwszBufOut.Get(),
                                          cwcBufOut - 1 );
        if ( 0 == cwcConvert )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                //
                // Double buffer size and then retry
                //
                delete xwszBufOut.Acquire();

                cwcBufOut *= 2;
                fOk = xwszBufOut.Init( cwcBufOut );
                if ( !fOk )
                    return FALSE;
            }
            else
            {
                //
                // Error during conversion
                //
                Assert( FALSE );
                return FALSE;
            }
        }
        else
            xwszBufOut[cwcConvert] = 0;

    } while ( 0 == cwcConvert );

    return TRUE;
}



//+-------------------------------------------------------------------------------
//
//  Function:  ConvertMultiByteToWideChar
//
//  Synopsis:  Converts multibyte strings to Unicode
//
/// Arguments: [pszBufIn]   -- Input to null terminated multibyte string
//             [xwszBufOut] -- Smart pointer to output Unicode string
//             [fOem]        -- If true use CP_OEMCP
//
//  Returns:   TRUE if we process it ok
//
//  History:   14-Jul-98   SitaramR    Created
//
//+-------------------------------------------------------------------------------

BOOL ConvertMultiByteToWideChar( const char *pszBufIn,
                                 XArray<WCHAR>& xwszBufOut,
                                 BOOL fOem )
{
    if ( pszBufIn == 0)
    {
    void *pBuf;

        if (pBuf = xwszBufOut.Acquire())
        {
            delete pBuf;
        }

        return TRUE;
     }

    BOOL fRet = ConvertMultiByteToWideChar( pszBufIn,
                                            -1 /* lstrlenA(pszBufIn) + 1 */,
                                            xwszBufOut,
                                            fOem );

    return fRet;
}


//+-------------------------------------------------------------------------------
//
//  Function:  ConvertWideCharToMultiByte
//
//  Synopsis:  Converts Unicode to multibyte strings
//
/// Arguments: [pwszBufIn]   -- Input Unicode string
//             [cwcBufIn]    -- Count of wide chars in input buffer
//             [xwszBufOut]  -- Smart pointer to output multibyte string
//             [fOem]        -- If true use CP_OEMCP
//
//  Returns:   TRUE if we process it ok
//
//  History:   14-Jul-98   SitaramR    Created
//
//+-------------------------------------------------------------------------------

BOOL ConvertWideCharToMultiByte( const WCHAR *pwszBufIn,
                                 ULONG cwcBufIn,
                                 XArray<char>& xszBufOut,
                                 BOOL fOem )
{
    Assert( pwszBufIn != 0 );

    if ( 0 == cwcBufIn )
    {
        xszBufOut[0] = 0;
        return TRUE;
    }

    BOOL fOk;
    if ( xszBufOut.Get() == 0 )
    {
    ULONG cbBufOut;

        cbBufOut = (-1 == cwcBufIn) ? lstrlenX(pwszBufIn) + 1: cwcBufIn;
        cbBufOut += 6; // give it a little extra room.

        fOk = xszBufOut.Init(cbBufOut);
        if ( !fOk )
            return FALSE;
    }

    UINT codePage = CP_ACP;
    if ( fOem && !AreFileApisANSI() )
        codePage = CP_OEMCP;

    ULONG cbConvert;
    ULONG cbBufOut = (ULONG)xszBufOut.Count();

    do
    {
        cbConvert = WideCharToMultiByte( codePage,
                                         WC_COMPOSITECHECK,
                                         pwszBufIn,
                                         cwcBufIn,
                                         xszBufOut.Get(),
                                         cbBufOut - 1,
                                         NULL,
                                         NULL );

        if ( 0 == cbConvert )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                //
                // Double buffer size and then retry
                //
                delete xszBufOut.Acquire();

                cbBufOut *= 2;
                fOk = xszBufOut.Init( cbBufOut );
                if ( !fOk )
                    return FALSE;
            }
            else
            {
                //
                // Error during conversion
                //
                Assert( FALSE );
                return FALSE;
            }
        }
        else
            xszBufOut[cbConvert] = 0;
    } while ( 0 == cbConvert );

    return TRUE;
}



//+-------------------------------------------------------------------------------
//
//  Function:  ConvertWideCharToMultiByte
//
//  Synopsis:  Converts Unicode to multibyte strings
//
/// Arguments: [pwszBufIn]   -- Input to null terminated Unicode string
//             [xwszBufOut]  -- Smart pointer to output multibyte string
//             [fOem]        -- If true use CP_OEMCP
//
//  Returns:   TRUE if we process it ok
//
//  History:   14-Jul-98   SitaramR    Created
//
//+-------------------------------------------------------------------------------

BOOL ConvertWideCharToMultiByte( const WCHAR *pwszBufIn,
                                 XArray<char>& xszBufOut,
                                 BOOL fOem )
{
    if ( pwszBufIn == 0)
    {
    void *pBuf;

        if (pBuf = xszBufOut.Acquire())
        {
            delete pBuf;
        }

        return TRUE;
    }

    BOOL fRet = ConvertWideCharToMultiByte( pwszBufIn,
                                            lstrlenX(pwszBufIn) + 1,
                                            xszBufOut,
                                            fOem );

    return fRet;
}


//
// Local constants
//
// DEFAULT_TIME_FORMAT - what to use if there's a problem getting format
//                       from system.
//
#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))
#define DEFAULT_TIME_FORMAT         TEXT("hh:mm tt")
#define GET_LOCALE_INFO(lcid)                           \
        {                                               \
            cch = GetLocaleInfo(LOCALE_USER_DEFAULT,    \
                                (lcid),                 \
                                tszScratch,             \
                                ARRAYLEN(tszScratch));  \
            if (!cch)                                   \
            {                                           \
                break;                                  \
            }                                           \
        }
//+--------------------------------------------------------------------------
//
//  Function:   UpdateTimeFormat
//
//  Synopsis:   Construct a time format containing hour and minute for use
//              with the date picker control.
//
//  Arguments:  [tszTimeFormat] - buffer to fill with time format
//              [cchTimeFormat] - size in chars of buffer
//
//  Modifies:   *[tszTimeFormat]
//
//  History:    11-18-1996   DavidMun   Created
//
//  Notes:      This is called on initialization and for wininichange
//              processing.
//
//---------------------------------------------------------------------------
void
UpdateTimeFormat(
        LPTSTR tszTimeFormat,
        ULONG  cchTimeFormat)
{
    ULONG cch;
    TCHAR tszScratch[80];
    BOOL  fAmPm;
    BOOL  fAmPmPrefixes;
    BOOL  fLeadingZero;

    do
    {
        GET_LOCALE_INFO(LOCALE_ITIME);
        fAmPm = (*tszScratch == TEXT('0'));

        if (fAmPm)
        {
            GET_LOCALE_INFO(LOCALE_ITIMEMARKPOSN);
            fAmPmPrefixes = (*tszScratch == TEXT('1'));
        }

        GET_LOCALE_INFO(LOCALE_ITLZERO);
        fLeadingZero = (*tszScratch == TEXT('1'));

        GET_LOCALE_INFO(LOCALE_STIME);

        //
        // See if there's enough room in destination string
        //

        cch = 1                     +  // terminating nul
              1                     +  // first hour digit specifier "h"
              2                     +  // minutes specifier "mm"
              (fLeadingZero != 0)   +  // leading hour digit specifier "h"
              lstrlen(tszScratch)   +  // separator string
              (fAmPm ? 3 : 0);         // space and "tt" for AM/PM

        if (cch > cchTimeFormat)
        {
            cch = 0; // signal error
        }
    } while (0);

    //
    // If there was a problem in getting locale info for building time string
    // just use the default and bail.
    //

    if (!cch)
    {
        lstrcpy(tszTimeFormat, DEFAULT_TIME_FORMAT);
        return;
    }

    //
    // Build a time string that has hours and minutes but no seconds.
    //

    tszTimeFormat[0] = TEXT('\0');

    if (fAmPm)
    {
        if (fAmPmPrefixes)
        {
            lstrcpy(tszTimeFormat, TEXT("tt "));
        }

        lstrcat(tszTimeFormat, TEXT("h"));

        if (fLeadingZero)
        {
            lstrcat(tszTimeFormat, TEXT("h"));
        }
    }
    else
    {
        lstrcat(tszTimeFormat, TEXT("H"));

        if (fLeadingZero)
        {
            lstrcat(tszTimeFormat, TEXT("H"));
        }
    }

    lstrcat(tszTimeFormat, tszScratch); // separator
    lstrcat(tszTimeFormat, TEXT("mm"));

    if (fAmPm && !fAmPmPrefixes)
    {
        lstrcat(tszTimeFormat, TEXT(" tt"));
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   FillInStartDateTime
//
//  Synopsis:   Fill [pTrigger]'s starting date and time values from the
//              values in the date/time picker controls.
//
//  Arguments:  [hwndDatePick] - handle to control with start date
//              [hwndTimePick] - handle to control with start time
//              [pTrigger]     - trigger to init
//
//  Modifies:   *[pTrigger]
//
//  History:    12-08-1997   SusiA      Stole from task scheduler
//
//---------------------------------------------------------------------------

VOID FillInStartDateTime( HWND hwndDatePick, HWND hwndTimePick,TASK_TRIGGER *pTrigger)
{
    SYSTEMTIME st;

    DateTime_GetSystemtime(hwndDatePick, &st);

    pTrigger->wBeginYear  = st.wYear;
    pTrigger->wBeginMonth = st.wMonth;
    pTrigger->wBeginDay   = st.wDay;

    DateTime_GetSystemtime(hwndTimePick, &st);

    pTrigger->wStartHour   = st.wHour;
    pTrigger->wStartMinute = st.wMinute;
}


//+---------------------------------------------------------------------------
//
//  function:     InsertListViewColumn, private
//
//  Synopsis:   Inserts a column into the ListView..
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    30-Jul-98       rogerg        Created.
//
//----------------------------------------------------------------------------


BOOL InsertListViewColumn(CListView *pListView,int iColumnId,LPWSTR pszText,int fmt,int cx)
{
LV_COLUMN columnInfo;

    columnInfo.mask = LVCF_FMT  | LVCF_TEXT  | LVCF_WIDTH  | LVCF_SUBITEM;
    columnInfo.fmt = fmt;
    columnInfo.cx = cx;
    columnInfo.pszText = pszText;
    columnInfo.iSubItem = 0;


    return pListView->InsertColumn(iColumnId,&columnInfo);
}


//+--------------------------------------------------------------------------
//
//  Function:   InitResizeItem
//
//  Synopsis:   Setups the ResizeInfo Structure.
//
//              !!Can either pass in a ParentScreenRect or
//              function will calculate. If passing in
//              make sure you don't include the NC area
//              of the window. See code below GetClientRect on parent
//              then ClientToScreen.
//
//  Arguments:
//
//  Modifies:
//
//  History:    30-07-1998   rogerg
//
//---------------------------------------------------------------------------

BOOL InitResizeItem(int iCtrlId,DWORD dlgResizeFlags,HWND hwndParent,
                        LPRECT pParentClientRect,DLGRESIZEINFO *pDlgResizeInfo)
{
RECT rectCtrl;
RECT rectLocalParentScreenRect;

    Assert(pDlgResizeInfo);

    Assert(0 == pParentClientRect->left); // catch any case not handing in ClientRect.

    pDlgResizeInfo->iCtrlId = -1;  // set ctrlId to -1 so GetDlgItem will fail in resize


    // if dont' have parentScreenRect get it ourselves
    if (!pParentClientRect)
    {
        pParentClientRect = &rectLocalParentScreenRect;

        if (!GetClientRect(hwndParent,&rectLocalParentScreenRect))
        {
            AssertSz(0,"Unable to get Parent Rects");
            return FALSE;
        }

    }

    Assert(pParentClientRect);

    if (!GetWindowRect(GetDlgItem(hwndParent,iCtrlId),&rectCtrl))
    {
        AssertSz(0,"Failed to GetWindowRect");
        return FALSE;
    }

    MapWindowPoints(NULL,hwndParent,(LPPOINT) &rectCtrl,2);

    pDlgResizeInfo->iCtrlId  = iCtrlId;
    pDlgResizeInfo->hwndParent =  hwndParent;
    pDlgResizeInfo->dlgResizeFlags = dlgResizeFlags;

    // calc the offsets
 
    pDlgResizeInfo->rectParentOffsets.left = rectCtrl.left - pParentClientRect->left;
    pDlgResizeInfo->rectParentOffsets.top = rectCtrl.top - pParentClientRect->top;

    pDlgResizeInfo->rectParentOffsets.right = pParentClientRect->right - rectCtrl.right;
    pDlgResizeInfo->rectParentOffsets.bottom = pParentClientRect->bottom - rectCtrl.bottom;

    return TRUE;

}


//+--------------------------------------------------------------------------
//
//  Function:   ResizeItems
//
//  Synopsis:   Resizes the Item.
//
//
//  Arguments:
//
//  Modifies:
//
//  History:    30-07-1998   rogerg
//
//---------------------------------------------------------------------------

void ResizeItems(ULONG cbNumItems,DLGRESIZEINFO *pDlgResizeInfo)
{
RECT rectLocalParentClientCoord; // used if caller doesn't pass in parent coords.
DWORD dlgResizeFlags;
LPRECT  prectOffsets;
RECT rectClient;
HWND hwndCtrl;
HWND hwndLastParent = NULL;
LPRECT prectParentClientCoords = NULL;
ULONG ulCount;
DLGRESIZEINFO *pCurDlgResizeInfo;
int x,y,cx,cy;


    if (!pDlgResizeInfo)
    {
        Assert(pDlgResizeInfo);
    }


    for (ulCount = 0; ulCount < cbNumItems; ulCount++)
    {

        pCurDlgResizeInfo = &(pDlgResizeInfo[ulCount]);

        dlgResizeFlags =  pCurDlgResizeInfo->dlgResizeFlags;
        prectOffsets =    &(pCurDlgResizeInfo->rectParentOffsets);

        // if not pinright or pin bottom there is nothing
        // to do.
        if (!(dlgResizeFlags & DLGRESIZEFLAG_PINRIGHT) &&
                !(dlgResizeFlags &  DLGRESIZEFLAG_PINBOTTOM) )
        {
            continue;
        }

        if (NULL == prectParentClientCoords || (hwndLastParent != pCurDlgResizeInfo->hwndParent))
        {
            prectParentClientCoords = &rectLocalParentClientCoord;

            if (!GetClientRect(pCurDlgResizeInfo->hwndParent,&rectLocalParentClientCoord))
            {
                prectParentClientCoords = NULL; // if GetClientRect failed for a recalc on next item
                continue;
            }

            hwndLastParent = pCurDlgResizeInfo->hwndParent; // set lastparent now that we calc'd the rect.        
        }

        Assert(prectParentClientCoords);

        hwndCtrl = GetDlgItem(pCurDlgResizeInfo->hwndParent,pCurDlgResizeInfo->iCtrlId);

        if ( (NULL == hwndCtrl) || !(GetWindowRect(hwndCtrl,&rectClient)) )
        {
            continue;
        }

        // get current values
        x = (prectParentClientCoords->left + prectOffsets->left);
        y = (prectParentClientCoords->top + prectOffsets->top);

        cx = WIDTH(rectClient);
        cy = HEIGHT(rectClient);

        // if pinned both right and left adjust the width
        if ((dlgResizeFlags & DLGRESIZEFLAG_PINLEFT)
            && (dlgResizeFlags & DLGRESIZEFLAG_PINRIGHT))
        {
            cx = prectParentClientCoords->right - (prectOffsets->right + prectOffsets->left);
        }

        // if pinned both top and bottom adjust height
        if ((dlgResizeFlags & DLGRESIZEFLAG_PINTOP)
            && (dlgResizeFlags & DLGRESIZEFLAG_PINBOTTOM))
        {
            cy = prectParentClientCoords->bottom - (prectOffsets->bottom + prectOffsets->top);
        }

        // adjust the x position if pin right
        if (dlgResizeFlags & DLGRESIZEFLAG_PINRIGHT)
        { 
            x = (prectParentClientCoords->right - prectOffsets->right)  - cx;
        }

        // adjust the y position if pin bottom
        if (dlgResizeFlags & DLGRESIZEFLAG_PINBOTTOM)
        {
            y = (prectParentClientCoords->bottom - prectOffsets->bottom)   - cy;
        }

        SetWindowPos(hwndCtrl, 0,x,y,cx,cy,SWP_NOZORDER | SWP_NOACTIVATE);
    }

    // now that the items are moved, loop through them again invalidating
    // any items with the nocopy bits flag set

    for (ulCount = 0; ulCount < cbNumItems; ulCount++)
    {
        pCurDlgResizeInfo = &(pDlgResizeInfo[ulCount]);

        if (pCurDlgResizeInfo->dlgResizeFlags & DLGRESIZEFLAG_NOCOPYBITS)
        {
            hwndCtrl = GetDlgItem(pCurDlgResizeInfo->hwndParent,pCurDlgResizeInfo->iCtrlId);

            if (hwndCtrl && GetClientRect(hwndCtrl,&rectClient))
            {
                InvalidateRect(hwndCtrl,&rectClient,FALSE);
            }
        }

    }


}


//+--------------------------------------------------------------------------
//
//  Function:   CalcListViewWidth
//
//  Synopsis:   Calcs width of listview - scroll bars
//
//
//  Arguments:
//
//  Modifies:
//
//  History:    30-07-1998   rogerg
//
//---------------------------------------------------------------------------

int CalcListViewWidth(HWND hwndList,int iDefault)
{
NONCLIENTMETRICSA metrics;
RECT rcClientRect;


    metrics.cbSize = sizeof(metrics);

    // explicitly ask for ANSI version of SystemParametersInfo since we just
    // care about the ScrollWidth and don't want to conver the LOGFONT info.
    if (GetClientRect(hwndList,&rcClientRect)
        && SystemParametersInfoA(SPI_GETNONCLIENTMETRICS,sizeof(metrics),(PVOID) &metrics,0))
    {
        // subtract off scroll bar distance
        rcClientRect.right -= (metrics.iScrollWidth);
    }
    else
    {
        rcClientRect.right = iDefault;  // if fail, use default
    }


    return rcClientRect.right;
}


//+--------------------------------------------------------------------------
//
//  Function:   SetCtrlFont
//
//  Synopsis:   Sets the appropriate font on the hwnd
//              based on the platform and langID passed in.
//
//
//  Arguments:
//
//  Modifies:
//
//  History:    25-09-1998   rogerg
//
//---------------------------------------------------------------------------

// Example:  SetCtrlFont(hwndList,g_OSVersionInfo.dwPlatformId,g_LangIdSystem);

void SetCtrlFont(HWND hwnd,DWORD dwPlatformID,LANGID langId)
{

    // IE is in the process of cleaning up their controls as
    // of 8/27/98 the controls we would need to set the font on are
    // Edit,Static and ListBox (listView is okay). Haven't tested the Combo Box

    // If want to turn this on need to make sure all the proper controls
    // are wrapped for now we don't do anything

#if _SETFONTOURSELF

    // if on Win95J platform need to do font substitution ourselfs.
    // Review what we do on Win98
    if ((VER_PLATFORM_WIN32_WINDOWS == dwPlatformID)
        && (LANG_JAPANESE == PRIMARYLANGID(langId)) )
    {
        SendMessage(hwnd,WM_SETFONT, (WPARAM) GetStockObject(DEFAULT_GUI_FONT),0);
    }

#endif // _SETFONTOURSELF

    return;

}

//+--------------------------------------------------------------------------
//
//  Function:   IsHwndRightToLeft
//
//  Synopsis:   determine if hwnd is right to left.
//
//
//  Arguments:
//
//  Modifies:
//
//  History:    04-02-1999   rogerg
//
//---------------------------------------------------------------------------

BOOL IsHwndRightToLeft(HWND hwnd)
{
LONG_PTR ExStyles;

    if (NULL == hwnd)
    {
        Assert(hwnd);
        return FALSE;
    }

    ExStyles = GetWindowLongPtr(hwnd,GWL_EXSTYLE);

    if (WS_EX_LAYOUTRTL  & ExStyles)
    {
        // this is righ to left
        return TRUE;
    }

    return FALSE;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetDateFormatReadingFlags
//
//  Synopsis:   returns necessary flags settings for passing proper
//              Reading order flags to GetDateFormat()
//
//
//  Arguments:
//
//  Modifies:
//
//  History:    09-07-1999   rogerg
//
//---------------------------------------------------------------------------

DWORD GetDateFormatReadingFlags(HWND hwnd)
{
DWORD dwDateReadingFlags = 0;
LCID locale = GetUserDefaultLCID();

     // only set on NT 5.0 or higher.
    if ( (VER_PLATFORM_WIN32_NT == g_OSVersionInfo.dwPlatformId)
         && ( 5 <= g_OSVersionInfo.dwMajorVersion) )
    {
        if ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC)
            || (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW))
        {
        LONG_PTR dwExStyle = GetWindowLongPtr(hwnd, GWL_EXSTYLE);

            if ((!!(dwExStyle & WS_EX_RTLREADING)) != (!!(dwExStyle & WS_EX_LAYOUTRTL)))
            {
                dwDateReadingFlags = DATE_RTLREADING;
            }
            else
            {
                dwDateReadingFlags = DATE_LTRREADING;
            }
         }  
    }
 
    return dwDateReadingFlags;
}

#ifdef _SETSECURITY

//+--------------------------------------------------------------------------
//
//  Function:   SetRegKeySecurityEveryone
//
//  Synopsis:   Gives Everyone all access to the specified RegKey.
//
//
//  Arguments:
//
//  Modifies:
//
//  History:    01-19-1999   rogerg
//
//---------------------------------------------------------------------------

BOOL SetRegKeySecurityEveryone(HKEY hKeyParent,LPCWSTR lpSubKey)
{
BOOL fResult = FALSE;
HKEY hKey = NULL;


    if (VER_PLATFORM_WIN32_NT  != g_OSVersionInfo.dwPlatformId)
    {
        return TRUE;
    }

    // key must be openned with WRITE_DAC

    if (ERROR_SUCCESS != RegOpenKeyExXp(hKeyParent,
	lpSubKey,
	REG_OPTION_OPEN_LINK, WRITE_DAC,&hKey,FALSE /*fSetSecurity*/) )
    {
        hKey = NULL;
    }

    if (hKey)
    {
    SECURITY_DESCRIPTOR SecurityDescriptor;

        // Initialize an empty security descriptor and use this to set DACL. Since
        // no DACL list in new Security Descriptor everyone will get access to the Key.
        if (InitializeSecurityDescriptor(&SecurityDescriptor,SECURITY_DESCRIPTOR_REVISION))
        {
            if (ERROR_SUCCESS == RegSetKeySecurity(hKey,
                (SECURITY_INFORMATION) DACL_SECURITY_INFORMATION,
                &SecurityDescriptor) )
            {
                fResult = TRUE;
            }
        }

        RegCloseKey(hKey);
    }

    Assert(TRUE == fResult); // debugging lets find out when this fails.
    return fResult;
}

#endif // _SETSECURITY

//+--------------------------------------------------------------------------
//
//  Function:   QueryHandleException
//
//  Synopsis:   in debug prompts user how to handle the exception
//              return always handle.
//
//
//  Arguments:
//
//  Modifies:
//
//  History:    01-04-1999   rogerg
//
//---------------------------------------------------------------------------

extern DWORD g_dwDebugLogAsserts; // conform to logAsserts

BOOL QueryHandleException(void)
{
#ifndef _DEBUG
    return EXCEPTION_EXECUTE_HANDLER;
#else // _DEBUG

    int iMsgResult = 0;
    BOOL fQueryResult = EXCEPTION_EXECUTE_HANDLER;

    // if logging asserts just execute the handler
    if (g_dwDebugLogAsserts)
    {
        return EXCEPTION_EXECUTE_HANDLER;
    }

    iMsgResult = MessageBoxA(NULL,
                    "An Exception Occured.\nWould you like to Debug this Exception?", 
                    "Exception Failure.",
		    MB_YESNO | MB_SYSTEMMODAL);

    if (iMsgResult == IDYES)
    {
        fQueryResult = EXCEPTION_CONTINUE_SEARCH;
    }

    // ask the User what they want to do
    return fQueryResult;

#endif // _DEBUG
}




// convert a hex char to an int - used by str to guid conversion
// we wrote our own, since the ole one is slow, and requires ole32.dll
// we use ansi strings here, since guids won't get internationalized
int GetDigit(LPSTR lpstr)
{
char ch = *lpstr;

    if (ch >= '0' && ch <= '9')
        return(ch - '0');
    if (ch >= 'a' && ch <= 'f')
        return(ch - 'a' + 10);
    if (ch >= 'A' && ch <= 'F')
        return(ch - 'A' + 10);
    return(0);
}
// walk the string, writing pairs of bytes into the byte stream (guid)
// we need to write the bytes into the byte stream from right to left
// or left to right as indicated by fRightToLeft
void ConvertField(LPBYTE lpByte,LPSTR * ppStr,int iFieldSize,BOOL fRightToLeft)
{
int i;

for (i=0;i<iFieldSize ;i++ )
{
// don't barf on the field separators
if ('-' == **ppStr) (*ppStr)++;
if (fRightToLeft == TRUE)
{
// work from right to left within the byte stream
*(lpByte + iFieldSize - (i+1)) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
}
else
{
// work from  left to right within the byte stream
*(lpByte + i) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
}
*ppStr+=2; // get next two digit pair
}
} // ConvertField

int WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr)
{

int rval;
BOOL bDefault;

// use the default code page (CP_ACP)
// -1 indicates WStr must be null terminated
rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,"-",&bDefault);

return rval;

} // WideToAnsi
int AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr)
{
int rval;

rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);

return rval;
}  // AnsiToWide


// convert the passed in string to a real GUID
// walk the guid, setting each byte in the guid to the two digit hex pair in the
// passed string
HRESULT GUIDFromString(LPWSTR lpWStr, GUID * pGuid)
{
BYTE * lpByte; // byte index into guid
int iFieldSize; // size of current field we're converting
// since its a guid, we can do a "brute force" conversion
char lpTemp[GUID_STRING_SIZE];
char *lpStr = lpTemp;

WideToAnsi(lpStr,lpWStr,GUID_STRING_SIZE);

// make sure we have a {xxxx-...} type guid
if ('{' !=  *lpStr) return E_FAIL;
lpStr++;

lpByte = (BYTE *)pGuid;
// data 1
iFieldSize = sizeof(unsigned long);
ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
lpByte += iFieldSize;

// data 2
iFieldSize = sizeof(unsigned short);
ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
lpByte += iFieldSize;

// data 3
iFieldSize = sizeof(unsigned short);
ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
lpByte += iFieldSize;

// data 4
iFieldSize = 8*sizeof(unsigned char);
ConvertField(lpByte,&lpStr,iFieldSize,FALSE);
lpByte += iFieldSize;

// make sure we ended in the right place
if ('}' != *lpStr)
{
memset(pGuid,0,sizeof(GUID));
return E_FAIL;
}

return S_OK;
}// GUIDFromString


// following are routines for calling sens service directly to write HKLM data
// for us on a locked down machine

#define _SENSCALLS
#define _SENSINTERNAL

#ifdef _SENSCALLS

#include "notify.h"

// may or may not need depending on if in sensapip.h

DWORD SyncMgrExecCmd(DWORD nCmdID, DWORD nCmdOpt);

typedef enum SYNCMGRCMDEXECID
{
    SYNCMGRCMDEXECID_UPDATERUNKEY = 1, 
    SYNCMGRCMDEXECID_RESETREGSECURITY = 2,
} SYNCMGRCMDEXECID;


#ifdef _SENSINTERNAL
// functions for if want to call sens internal without
// dependency on sensapip.lib

// these defines are from Sens common.h
#define SENS_PROTSEQ  TEXT("ncalrpc")
#define SENS_ENDPOINT TEXT("senssvc")


RPC_STATUS GetSensNotifyBindHandle(RPC_BINDING_HANDLE *phSensNotify)
{
RPC_STATUS status = RPC_S_OK;
WCHAR * BindingString = NULL;

    status = RpcStringBindingCompose(
                 NULL,               // NULL ObjUuid
                 SENS_PROTSEQ,
                 NULL,               // Local machine
                 SENS_ENDPOINT,
                 NULL,               // No Options
                 &BindingString
                 );

    if (BindingString != NULL)
    {
        *phSensNotify = NULL;

        status = RpcBindingFromStringBinding(BindingString,phSensNotify);

        if (status == RPC_S_OK)
        {
            RPC_SECURITY_QOS RpcSecQos;

            RpcSecQos.Version= RPC_C_SECURITY_QOS_VERSION_1;
            RpcSecQos.ImpersonationType= RPC_C_IMP_LEVEL_IMPERSONATE;
            RpcSecQos.IdentityTracking= RPC_C_QOS_IDENTITY_DYNAMIC;
            RpcSecQos.Capabilities= RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;

            status= RpcBindingSetAuthInfoEx(*phSensNotify,
                                L"NT Authority\\System",
                                RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                RPC_C_AUTHN_WINNT,
                                NULL,
                                RPC_C_AUTHZ_NONE,
                                (RPC_SECURITY_QOS *)&RpcSecQos);

            if (RPC_S_OK != status)
            {
                RpcBindingFree(phSensNotify);
                *phSensNotify = NULL;
            }
        }
        RpcStringFree(&BindingString);
    }

    return (status);
}



RPC_STATUS SyncMgrExecCmdInternal(DWORD nCmdID, DWORD nCmdOpt)
{
RPC_STATUS status;
RPC_BINDING_HANDLE hSensNotify;

    status = GetSensNotifyBindHandle(&hSensNotify);
    
    if (RPC_S_OK != status)
    {
        return status;
    }
    
    status = RPC_SyncMgrExecCmd(hSensNotify,nCmdID,nCmdOpt);

    RpcBindingFree(&hSensNotify);
    
    return status;
}

#endif // _SENSINTERNAL

//+--------------------------------------------------------------------------
//
//  Function:   SyncMgrExecCmdp
//
//  Synopsis:  helper function that actually calls into sensapip.lib
//
//
//  Arguments:
//
//  Modifies:
//
//  History:   03-11-99 rogerg  created
//
//---------------------------------------------------------------------------

BOOL SyncMgrExecCmdp(DWORD nCmdID, DWORD nCmdOpt)
{
RPC_STATUS RpcStatus;
HRESULT hr;
BOOL fReturn = FALSE;

    __try
    {

#ifdef _SENSINTERNAL
	RpcStatus = SyncMgrExecCmdInternal(nCmdID,nCmdOpt);
#else
        RpcStatus = SyncMgrExecCmd(nCmdID,nCmdOpt);
#endif // _SENSINTERNAL
        fReturn = (RPC_S_OK == RpcStatus ) ? TRUE: FALSE;

    }
    __except(QueryHandleException())
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
        AssertSz(0,"Exception Calling SensApip_SyncMgrExecCmd");
    }

    return fReturn;
}


#endif // _SENSCALLS


//+--------------------------------------------------------------------------
//
//  Function:   SyncMgrExecCmd_UpdateRunKey
//
//  Synopsis:  Calls SENS Service to write or remove the run Key
//
//
//  Arguments:
//
//  Modifies:
//
//  History:   03-11-99 rogerg  created
//
//---------------------------------------------------------------------------

BOOL SyncMgrExecCmd_UpdateRunKey(BOOL fSet)
{
BOOL fReturn = FALSE;
CCriticalSection cCritSect(&g_CritSectCommonLib,GetCurrentThreadId());

    // IF NOT NT 5.0 or higher just return
    if ( (g_OSVersionInfo.dwPlatformId !=  VER_PLATFORM_WIN32_NT)
        ||  (g_OSVersionInfo.dwMajorVersion < 5))
    { 
        return FALSE;
    }

    cCritSect.Enter(); // DoRpcSetup in Sensapip is not thread safe.
#ifdef _SENSCALLS
    fReturn = SyncMgrExecCmdp(
            SYNCMGRCMDEXECID_UPDATERUNKEY,fSet ? 1 : 0);
#endif // _SENSCALLS
    cCritSect.Leave();


    return fReturn;
}

//+--------------------------------------------------------------------------
//
//  Function:   SyncMgrExecCmd_ResetRegSecurity
//
//  Synopsis:  Calls SENS Service to reset the security on regkeys 
//              to everyone.
//
//
//  Arguments:
//
//  Modifies:
//
//  History:   03-11-99 rogerg  created
//
//---------------------------------------------------------------------------

BOOL SyncMgrExecCmd_ResetRegSecurity(void)
{
BOOL fReturn = FALSE;
CCriticalSection cCritSect(&g_CritSectCommonLib,GetCurrentThreadId());

    // IF NOT NT 5.0 or higher just return
    if ( (g_OSVersionInfo.dwPlatformId !=  VER_PLATFORM_WIN32_NT)
        ||  (g_OSVersionInfo.dwMajorVersion < 5))
    { 
        return FALSE;
    }

    cCritSect.Enter(); // DoRpcSetup in Sensapip is not thread safe.
#ifdef _SENSCALLS
    fReturn = SyncMgrExecCmdp(SYNCMGRCMDEXECID_RESETREGSECURITY,0);
#endif // _SENSCALLS
    cCritSect.Leave(); 

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\lib\widewrap.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1998
//
//  File:       widewrap.cxx
//
//  Contents:   Unicode wrapper API
//
//  Functions:  About fifty Win32 function wrappers
//
//  Notes:      'sz' is used instead of the "correct" hungarian 'psz'
//              throughout to enhance readability.
//
//              Not all of every Win32 function is wrapped here.  Some
//              obscurely-documented features may not be handled correctly
//              in these wrappers. Caller beware.
//
//  History:    28-Dec-93   ErikGav   Created
//              06-14-94    KentCe    Various Chicago build fixes.
//              21-Dec-94   BruceMa   Use olewcstombs + other fixes
//              21-Feb-95   BruceMa   Add support for AreFileApisANSI
//              29-Feb-96   JeffE     Add lots of wide character rtns
//              15-Jul-98   SitaramR  Fixed MultiByte <-> Unicode conversions
//
//----------------------------------------------------------------------------
//
//      Bugs noticed don't have time to fix.
//          Feb 4th 1997
//
//   1. delete(FileX (and many others) why is it sz[MAX_PATH*2]?
//   2. Return from UnicodeToAnsi/UnicodeToAnsiOem is being ignored
//   3. Convert/ConvertOem - since return from UnicodeToAnsi[Oem] is
//      being ignored, bogus ANSI/OEM string could come back causing
//      problems later.  E.g, in LoadLibraryX we could end up passing
//      bogus stuff to LoadLibraryA
//   4. GetDriveTypeX (and many other places) "return 0" is the wrong
//      thing change if (sz == ERR) to return DRIVE_UNKNOWN
//   5. SearchPathX do lpPath and lpExtension need to be ConvertOem?
//   6. Convert/ConvertOem are bad names.  Use better names.
//
//----------------------------------------------------------------------------

#include "lib.h"

#define HFINDFILE HANDLE
#define ERR ((char*) -1)

#define CairoleAssert // Review - replace with our asserts
#define Win4Assert

#undef ALLOC
#undef FREE

#ifdef __cplusplus
extern "C" {
#endif

// notes:
// ConvertWideCharToMultiByte if pass in null doesn't change output
// string, should it set it to NULL.

CRITICAL_SECTION g_CritSectCommonLib;
BOOL g_fWideWrap_Unicode = FALSE;

// list of wide functions not available on Win9x + IE4
// Shell32!SHGetFileInfoW
// Shell32!Shell_NotifyIconW

typedef BOOL (WINAPI *SHELL_NOTIFYICONW)(DWORD dwMessage, PNOTIFYICONDATAW lpData );
typedef BOOL (WINAPI *SHELL_NOTIFYICONA)(DWORD dwMessage, PNOTIFYICONDATAA lpData );
typedef DWORD_PTR (WINAPI *SHGETFILEINFOW)(LPCWSTR pszPath,
                            DWORD dwFileAttributes, SHFILEINFOW FAR *psfi,
                            UINT cbFileInfo,UINT uFlags);
typedef DWORD_PTR (WINAPI *SHGETFILEINFOA)(LPCSTR pszPath,
                            DWORD dwFileAttributes, SHFILEINFOA FAR *psfi,
                            UINT cbFileInfo,UINT uFlags);

STRING_FILENAME(szShell32, "SHELL32.DLL");

STRING_INTERFACE(szShell_NotifyIconW,"Shell_NotifyIconW");
STRING_INTERFACE(szShell_NotifyIconA,"Shell_NotifyIconA");
STRING_INTERFACE(szShGetFileInfoA,"SHGetFileInfoA");
STRING_INTERFACE(szShGetFileInfoW,"SHGetFileInfoW");

BOOL g_fLoadedShell32 = FALSE;
HINSTANCE g_hinstShell32 = NULL;
SHELL_NOTIFYICONW g_pfShell_NotifyIconW = NULL;
SHELL_NOTIFYICONA g_pfShell_NotifyIconA = NULL;
SHGETFILEINFOW g_pfShGetFileInfoW = NULL;
SHGETFILEINFOA g_pfShGetFileInfoA = NULL;

// list of exports we use from OleAut32.
typedef BSTR (APIENTRY *PFNSYSALLOCSTRING)(const OLECHAR *);
typedef void (APIENTRY *PFNSYSFREESTRING)(BSTR);
typedef HRESULT (APIENTRY *PFNLOADREGTYPELIB)(REFGUID rguid,
			WORD wVerMajor,WORD wVerMinor,LCID lcid,ITypeLib FAR* FAR* pptlib);

STRING_FILENAME(szOleAut32Dll, "OLEAUT32.DLL");

STRING_INTERFACE(szSysAllocString,"SysAllocString");
STRING_INTERFACE(szSysFreeString,"SysFreeString");
STRING_INTERFACE(szLoadRegTypeLib,"LoadRegTypeLib");

BOOL g_fLoadedOleAut32 = FALSE;
HINSTANCE g_hinstOleAut32 = NULL;
PFNSYSALLOCSTRING g_pfSysAllocString = NULL;
PFNSYSFREESTRING g_pfSysFreeString = NULL;
PFNLOADREGTYPELIB g_pfLoadRegTypeLib = NULL;


// list of exports we use from UserEnv.
typedef BOOL (APIENTRY *PFNGETUSERPROFILEDIRECTORY)(HANDLE  hToken,LPWSTR lpProfileDir,LPDWORD lpcchSize);

STRING_FILENAME(szUserEnvDll, "USERENV.DLL");

STRING_INTERFACE(szGetUserProfileDirectory,"GetUserProfileDirectoryW");

BOOL g_fLoadedUserEnv = FALSE;
HINSTANCE g_hinstUserEnv = NULL;
PFNGETUSERPROFILEDIRECTORY g_pfGetUserProfileDirectory = NULL;

// list of exports used from User32.dll
typedef BOOL (WINAPI *PFNALLOWSETFOREGROUNDWINDOW)(DWORD dwProcessId);

STRING_FILENAME(szUser32Dll, "USER32.DLL");

STRING_INTERFACE(szAllowSetForegroundWindow,"AllowSetForegroundWindow");


BOOL g_fLoadedUser32 = FALSE;
HINSTANCE g_hinstUser32 = NULL;
PFNALLOWSETFOREGROUNDWINDOW g_pfAllowSetForegroundWindow = NULL;

// delcartions for imports from imm32.dll
typedef HIMC (WINAPI *PFNIMMASSOCIATECONTEXT)(HWND hWnd,HIMC hIMC);

STRING_FILENAME(szIMM32Dll, "IMM32.DLL");

STRING_INTERFACE(szImmAssociateContext,"ImmAssociateContext");

BOOL g_fLoadedIMM32 = FALSE;
HINSTANCE g_hinstIMM32 = NULL;
PFNIMMASSOCIATECONTEXT g_pfImmAssociateContext = NULL;



// global vars

OSVERSIONINFOA g_OSVersionInfo; // osVersionInfo.


// Note: this should really be in its own file but due to closeness
// of IE5 release leave here for now.

// must be called before any other routine to setup variables and
// try to dynamically load wide exports not available on Win9x

// globals shared by Common.

// !!! InitCommonLib function is not thread safe. must be called on main thread before
//   other threads are created

void InitCommonLib(BOOL fUnicode)
{
    InitializeCriticalSection(&g_CritSectCommonLib);	

    g_fWideWrap_Unicode = fUnicode;

    g_OSVersionInfo.dwOSVersionInfoSize = sizeof(g_OSVersionInfo);
    if (!GetVersionExA(&g_OSVersionInfo))
    {
        AssertSz(0,"GetVersionEx Failed");

        // if Can't get Version information base it off of Unicode Flag
        g_OSVersionInfo.dwPlatformId =  fUnicode ? 
                        (VER_PLATFORM_WIN32_NT) : (VER_PLATFORM_WIN32_WINDOWS);
    }

//    g_fWideWrap_Unicode = FALSE;
}


// must be called to Uninit CommonLib.
// !!Warning COM has already been unitialized at this point.
// !!Warning, not thread safe.

void UnInitCommonLib(void)
{
    DeleteCriticalSection(&g_CritSectCommonLib);
}


// returns TRUE if WideWrap is set to Unicode, False if ANSI
BOOL WideWrapIsUnicode()
{
BOOL fIsUnicode;
CCriticalSection cCritSect(&g_CritSectCommonLib,GetCurrentThreadId());

    cCritSect.Enter();
    fIsUnicode = g_fWideWrap_Unicode;
    cCritSect.Leave();

    return fIsUnicode;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUserTextualSid
//
//  Synopsis:   Get a user SID and convert to its string representation
//
//----------------------------------------------------------------------------

BOOL 
GetUserTextualSid(
    LPTSTR TextualSid,  // buffer for Textual representaion of Sid
    LPDWORD cchSidSize  // required/provided TextualSid buffersize
    )
{
    if (!g_fWideWrap_Unicode)
    {
        TextualSid[0] = TEXT('\0');
        *cchSidSize = 0;
        return TRUE;
    }

    HANDLE      hToken;
    BYTE        buf[MAX_PATH];
    PTOKEN_USER ptgUser = (PTOKEN_USER)buf;
    DWORD       cbBuffer=MAX_PATH;

    BOOL        bSuccess;

    PSID pSid;
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD cchSidCopy;

//
    // obtain current process token
    //
    if(!OpenProcessToken(
                GetCurrentProcess(), // target current process
                TOKEN_QUERY,         // TOKEN_QUERY access
                &hToken              // resultant hToken
                ))
    {
        return FALSE;
    }

    //
    // obtain user identified by current process' access token
    //
    bSuccess = GetTokenInformation(
                hToken,    // identifies access token
                TokenUser, // TokenUser info type
                ptgUser,   // retrieved info buffer
                cbBuffer,  // size of buffer passed-in
                &cbBuffer  // required buffer size
                );

    // close token handle.  do this even if error above
    CloseHandle(hToken);

    if(!bSuccess) 
    {
        return FALSE;
    }

    pSid = ptgUser->User.Sid;
    
        //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid)) return FALSE;

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute approximate buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidCopy = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*cchSidSize < cchSidCopy) {
        *cchSidSize = cchSidCopy;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidCopy = wsprintf(TextualSid, TEXT("S-%lu-"), SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for(dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell the caller how many chars we provided, not including NULL
    //
    *cchSidSize = cchSidCopy;

    return TRUE;
}


// loads exports we need from the shell32dll
void LoadShell32Dll()
{

    if (g_fLoadedShell32)
        return;

    CCriticalSection cCritSect(&g_CritSectCommonLib,GetCurrentThreadId());

    cCritSect.Enter();

    // make sure not loaded again in case someone took lock first
    if (!g_fLoadedShell32)
    {

        g_hinstShell32 = LoadLibrary(szShell32);

        if (g_hinstShell32)
        {
	    g_pfShell_NotifyIconW = (SHELL_NOTIFYICONW) GetProcAddress(g_hinstShell32, szShell_NotifyIconW);
	    g_pfShell_NotifyIconA = (SHELL_NOTIFYICONA) GetProcAddress(g_hinstShell32, szShell_NotifyIconA);

            g_pfShGetFileInfoW = (SHGETFILEINFOW) GetProcAddress(g_hinstShell32, szShGetFileInfoW);
            g_pfShGetFileInfoA = (SHGETFILEINFOA) GetProcAddress(g_hinstShell32, szShGetFileInfoA);
        }

        // should always get the Ansi exports
        Assert(g_pfShell_NotifyIconA);
        Assert(g_pfShGetFileInfoA);

        g_fLoadedShell32 = TRUE;
    }

    cCritSect.Leave();
}

// load exports from OleAutomation
// up to caller to check exports they need are valid after making this call

void LoadOleAut32Dll()
{
    if (g_fLoadedOleAut32)
        return;

    CCriticalSection cCritSect(&g_CritSectCommonLib,GetCurrentThreadId());

    cCritSect.Enter();

    // make sure not loaded again in case someone took lock first
    if (!g_fLoadedOleAut32)
    {
        g_hinstOleAut32 = LoadLibrary(szOleAut32Dll);

        if (g_hinstOleAut32)
        {
	    g_pfSysAllocString = (PFNSYSALLOCSTRING) GetProcAddress(g_hinstOleAut32, szSysAllocString);
	    g_pfSysFreeString = (PFNSYSFREESTRING) GetProcAddress(g_hinstOleAut32, szSysFreeString);

            g_pfLoadRegTypeLib = (PFNLOADREGTYPELIB) GetProcAddress(g_hinstOleAut32, szLoadRegTypeLib);
        }

        // should always get the exports.
        Assert(g_pfSysAllocString);
        Assert(g_pfSysFreeString);
        Assert(g_pfLoadRegTypeLib);

        g_fLoadedOleAut32 = TRUE;
    }

    cCritSect.Leave();

}


STDAPI_(BSTR) SysAllocStringX(const OLECHAR *sz)
{
     LoadOleAut32Dll();

     Assert(g_pfSysAllocString);

    if (g_pfSysAllocString)
    {
        return (*g_pfSysAllocString)(sz);
    }

    return NULL;
}


STDAPI_(void) SysFreeStringX(BSTR bsz)
{
    LoadOleAut32Dll();

    Assert(g_pfSysFreeString);

    if (g_pfSysFreeString)
    {
        (*g_pfSysFreeString)(bsz);
    }
}

STDAPI LoadRegTypeLibX(REFGUID rguid, WORD wVerMajor, WORD wVerMinor,
            LCID lcid, ITypeLib ** pptlib)
{
    LoadOleAut32Dll();

    Assert(g_pfLoadRegTypeLib);

    if (g_pfLoadRegTypeLib)
    {
        return (*g_pfLoadRegTypeLib)(rguid,wVerMajor,wVerMinor,lcid,pptlib);
    }

    return E_OUTOFMEMORY;
}


void LoadUserEnvDll()
{
    if (g_fLoadedUserEnv)
        return;

    CCriticalSection cCritSect(&g_CritSectCommonLib,GetCurrentThreadId());

    cCritSect.Enter();

    // make sure not loaded again in case someone took lock first
    if (!g_fLoadedUserEnv)
    {
        g_hinstUserEnv = LoadLibrary(szUserEnvDll);

        if (g_hinstUserEnv)
        {
	    g_pfGetUserProfileDirectory = (PFNGETUSERPROFILEDIRECTORY) GetProcAddress(g_hinstUserEnv, szGetUserProfileDirectory);
        }

        // should always get the exports.
        Assert(g_pfGetUserProfileDirectory);

        g_fLoadedUserEnv = TRUE;
    }

    cCritSect.Leave();

}

BOOL
WINAPI
GetUserProfileDirectoryX(HANDLE  hToken,LPWSTR lpProfileDir,LPDWORD lpcchSize)
{

    LoadUserEnvDll();

    Assert(g_pfGetUserProfileDirectory);

    if (g_pfGetUserProfileDirectory)
    {
        return (*g_pfGetUserProfileDirectory)(hToken,lpProfileDir,lpcchSize);
    }

    // by definition on falue size is filled with necessary buffer size.
    // since we don't know this set it to zero. If caller then reallocates and
    // tries again it will still fail

    *lpcchSize = 0;
    return FALSE;
}



// delay load for User

void LoadUser32Dll()
{
    if (g_fLoadedUser32)
        return;

    CCriticalSection cCritSect(&g_CritSectCommonLib,GetCurrentThreadId());

    cCritSect.Enter();

    // make sure not loaded again in case someone took lock first
    if (!g_fLoadedUser32)
    {
        g_hinstUser32 = LoadLibrary(szUser32Dll);

        if (g_hinstUser32)
        {
	    g_pfAllowSetForegroundWindow = 
                (PFNALLOWSETFOREGROUNDWINDOW) GetProcAddress(g_hinstUser32, 
                                                    szAllowSetForegroundWindow);
        }

        g_fLoadedUser32 = TRUE;
    }

    cCritSect.Leave();

}


BOOL WINAPI AllowSetForegroundWindowX(
    DWORD dwProcessId)
{

    LoadUser32Dll();

    // okay to not get export since might not be on NT 5.0
    if (g_pfAllowSetForegroundWindow)
    {
        return (*g_pfAllowSetForegroundWindow)(dwProcessId);
    }

    return FALSE;
}


// delay load for IME calls

void LoadIMM32Dll()
{
    if (g_fLoadedIMM32)
        return;

    CCriticalSection cCritSect(&g_CritSectCommonLib,GetCurrentThreadId());

    cCritSect.Enter();

    // make sure not loaded again in case someone took lock first
    if (!g_fLoadedIMM32)
    {
        g_hinstIMM32 = LoadLibrary(szIMM32Dll);

        if (g_hinstIMM32)
        {
	    g_pfImmAssociateContext = 
                (PFNIMMASSOCIATECONTEXT) GetProcAddress(g_hinstIMM32, 
                                                    szImmAssociateContext);
        }

        g_fLoadedIMM32 = TRUE;
    }

    cCritSect.Leave();

}


HIMC WINAPI ImmAssociateContextX(HWND hWnd,HIMC hIMC)
{

    LoadIMM32Dll();

    // okay to not get export since might not be on NT 5.0
    if (g_pfImmAssociateContext)
    {
        return (*g_pfImmAssociateContext)(hWnd,hIMC);
    }

    return NULL;
}


int LoadStringX(  HINSTANCE hInstance, UINT uID,LPWSTR lpwszBuffer,int nBufferMax)
{
int iReturn = 0;

    if (g_fWideWrap_Unicode)
    {
        iReturn = LoadStringW(hInstance,uID,lpwszBuffer,nBufferMax);
        return iReturn;
    }

    XArray<CHAR> xszString;
    BOOL fOk = xszString.Init( nBufferMax );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }

    iReturn = LoadStringA(hInstance, uID, xszString.Get(), nBufferMax);

    if ( iReturn == 0 )
        return 0;

    XArray<WCHAR> xwszBuffer;
    fOk = ConvertMultiByteToWideChar( xszString.Get(), iReturn+1, xwszBuffer );
    if ( !fOk )
        return 0;

    iReturn = lstrlenX( xwszBuffer.Get() );
    if ( iReturn >= nBufferMax)
    {
        //
        // Truncate to fit
        //
        iReturn = nBufferMax -1;
        lstrcpynX( lpwszBuffer, xwszBuffer.Get(), iReturn );
        lpwszBuffer[iReturn] = 0;
    }
    else
        lstrcpyX( lpwszBuffer, xwszBuffer.Get() );

    return iReturn;
}

#if 0
HANDLE WINAPI CreateFileX(LPCWSTR pwsz, DWORD fdwAccess, DWORD fdwShareMask,
        LPSECURITY_ATTRIBUTES lpsa, DWORD fdwCreate, DWORD fdwAttrsAndFlags,
        HANDLE hTemplateFile)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFile\n");
    #endif

    CHAR  sz[MAX_PATH * 2];
    UnicodeToAnsiOem(sz, pwsz, sizeof(sz));

    return CreateFileA(sz, fdwAccess, fdwShareMask, lpsa, fdwCreate,
            fdwAttrsAndFlags, hTemplateFile);
}
#endif
BOOL WINAPI DeleteFileX(LPCWSTR pwsz)
{
BOOL fReturn = FALSE;

    Assert(pwsz);

    if (g_fWideWrap_Unicode)
    {
        fReturn = DeleteFileW(pwsz);
    }
    else
    {
        XArray<CHAR> xszString;
        BOOL fOk = ConvertWideCharToMultiByte( pwsz, xszString );
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

        fReturn = DeleteFileA(xszString.Get());
    }
    return fReturn;
}

BOOL WINAPI ExpandEnvironmentStringsX(
    LPCWSTR lpSrc,
    LPWSTR lpDstW,
    DWORD nSize
    )
{
BOOL fReturn = FALSE;

    Assert(lpSrc);
    Assert(lpDstW);
    
    if (g_fWideWrap_Unicode)
    {
        fReturn = ExpandEnvironmentStringsW(lpSrc,lpDstW,nSize);
    }
    else
    {
        XArray<CHAR> xszSrc;
        XArray<CHAR> xszDst;

        BOOL fOk = ConvertWideCharToMultiByte( lpSrc, xszSrc);
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }
        
        fOk = xszDst.Init( nSize + 1);
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

        fReturn = ExpandEnvironmentStringsA(xszSrc.Get(), xszDst.Get(), nSize);

        XArray<WCHAR> xszDstW;
        fOk = ConvertMultiByteToWideChar( xszDst.Get(), xszDstW);
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }
        wcscpy(lpDstW,xszDstW.Get());
    }

    return fReturn;

}
#if 0

UINT WINAPI RegisterClipboardFormatX(LPCWSTR pwszFormat)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegisterClipboardFormat\n");
    #endif

    UINT ret;
    CHAR sz[200];

    UnicodeToAnsi(sz, pwszFormat, sizeof(sz));

    ret = RegisterClipboardFormatA(sz);

    return ret;
}

int WINAPI GetClipboardFormatNameX(UINT format, LPWSTR pwsz,
    int cchMaxCount)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetClipboardFormatName\n");
    #endif

    LPSTR sz;
    int i;

    sz = (char *) ALLOC(cchMaxCount*sizeof(char));
    if (sz == NULL)
    {
        return 0;
    }

    i = GetClipboardFormatNameA(format, sz, cchMaxCount);

    if (i)
    {
        AnsiToUnicode(pwsz, sz, lstrlenA(sz) + 1);
    }
    if (sz)
    {
        FREE( sz);
    }
    return i;
}
#endif

LONG APIENTRY RegOpenKeyX(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult)
{
    return RegOpenKeyEx(hKey,pwszSubKey,NULL,KEY_READ | KEY_WRITE,phkResult);
}

#if 0
LONG APIENTRY RegQueryValueX(HKEY hKey, LPCWSTR pwszSubKey, LPWSTR pwszValue,
    PLONG   lpcbValue)
{
    LONG ret;
    if (g_fWideWrap_Unicode)
    {
        ret = RegQueryValueW(hKey, pwszSubKey, pwszValue, lpcbValue);
        return ret;
    }

    LONG cbOldSize = *lpcbValue;
    LONG  cb;

    XArray<CHAR> xszSubKey;
    BOOL fOk = ConvertWideCharToMultiByte( pwszSubKey, xszSubKey );
    if ( !fOk )
        return ERROR_OUTOFMEMORY;

    ret = RegQueryValueA(hKey, xszSubKey.Get(), NULL, &cb);

    // If the caller was just asking for the size of the value, jump out
    //  now, without actually retrieving and converting the value.

    if (pwszValue == NULL)
    {
        // Adjust size of buffer to report, to account for CHAR -> WCHAR
        *lpcbValue = cb * sizeof(WCHAR);
    }

    if (ret == ERROR_SUCCESS)
    {
        // If the caller was asking for the value, but allocated too small
        // of a buffer, set the buffer size and jump out.

        if (*lpcbValue < (LONG) (cb * sizeof(WCHAR)))
        {
            // Adjust size of buffer to report, to account for CHAR -> WCHAR
            *lpcbValue = cb * sizeof(WCHAR);
            return ERROR_MORE_DATA;
        }

        // Otherwise, retrieve and convert the value.

        XArray<CHAR> xszValue;
        fOk = xszValue.Init( cb );
        if ( !fOk )
            return ERROR_OUTOFMEMORY;

        ret = RegQueryValueA(hKey, xszSubKey.Get(), xszValue.Get(), &cb);

        if (ret == ERROR_SUCCESS)
        {
            XArray<WCHAR> xwszValueOut;
            fOk = ConvertMultiByteToWideChar( xszValue.Get(), xwszValueOut );
            if ( !fOk )
                return ERROR_OUTOFMEMORY;

            // Adjust size of buffer to report, to account for CHAR -> WCHAR
            *lpcbValue = lstrlenX(xwszValueOut.Get()) * sizeof(WCHAR);

            if ( *lpcbValue < cbOldSize )
                 lstrcpyX( pwszValue, xwszValueOut.Get() );
            else
                return ERROR_MORE_DATA;
        }
    }

    return ret;
}
#endif

LONG APIENTRY RegSetValueExX(
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    )
{
LONG lResult = E_UNEXPECTED;

    if (g_fWideWrap_Unicode)
    {
        lResult = RegSetValueExW(hKey,lpValueName,Reserved,dwType,lpData,cbData);
    }
    else
    {
    LPSTR lpValueNameA = NULL;
    LPSTR lpDataA = NULL;

        Assert(0 == Reserved);
        Assert(lpData);

        // only supports dwType of REG_SZ and REG_DWORD
        if ( (dwType != REG_SZ) &&  (dwType != REG_DWORD) && (dwType != REG_BINARY))
        {
            Assert(dwType == REG_SZ || dwType == REG_DWORD || dwType == REG_BINARY);
            return E_INVALIDARG;
        }

        XArray<CHAR> xszValueName;
        BOOL fOk = ConvertWideCharToMultiByte( lpValueName, xszValueName );
        if ( !fOk )
            return ERROR_OUTOFMEMORY;

        lpValueNameA = xszValueName.Get();

        XArray<CHAR> xszData;
        if (dwType == REG_SZ)
        {
            fOk = ConvertWideCharToMultiByte( (WCHAR *)lpData, xszData );
            if ( !fOk )
                return ERROR_OUTOFMEMORY;

            lpDataA = xszData.Get();
            lpData = (BYTE *) lpDataA;

            if (lpDataA)
            {
                cbData = lstrlenA(lpDataA) + 1;
            }
        }

        if (lpData)
        {
            lResult = RegSetValueExA(hKey,lpValueNameA,Reserved,dwType,lpData,cbData);
        }
    }

    return lResult;

}

#if 0
LONG APIENTRY RegSetValueX(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType,
    LPCWSTR lpData, DWORD cbData)
{
    LONG ret;
    if (g_fWideWrap_Unicode)
    {
        ret = RegSetValueW( hKey, lpSubKey, dwType, lpData, cbData);
        return ret;
    }

    XArray<CHAR> xszKey;
    BOOL fOk = ConvertWideCharToMultiByte( lpSubKey, xszKey );
    if ( !fOk )
        return ERROR_OUTOFMEMORY;

    if ( dwType == REG_EXPAND_SZ
         || dwType == REG_MULTI_SZ
         || dwType == REG_SZ )
    {
        //
        // Convert string data to multibyte
        //

        XArray<CHAR> xszValue;
        fOk = ConvertWideCharToMultiByte( lpData, cbData, xszValue );
        if ( !fOk )
            return ERROR_OUTOFMEMORY;

        ret = RegSetValueA(hKey, xszKey.Get(), dwType, xszValue.Get(), lstrlenA(xszValue.Get()) + 1 );
    }
    else
        ret = RegSetValueA(hKey, xszKey.Get(), dwType, (LPSTR)lpData, cbData);

    return ret;
}
#endif

LONG
APIENTRY
RegDeleteValueX (
    HKEY hKey,
    LPCWSTR lpValueName
    )
{
LONG ret;

    if (g_fWideWrap_Unicode)
    {
        ret = RegDeleteValueW( hKey,lpValueName);
        return ret;
    }

    XArray<CHAR> xszValue;
    BOOL fOk = ConvertWideCharToMultiByte( lpValueName, xszValue );
    if ( !fOk )
        return ERROR_OUTOFMEMORY;

    ret = RegDeleteValueA(hKey,xszValue.Get());

    return ret;
}

LONG
APIENTRY
RegCreateKeyExXp(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL fSetSecurity)
{
LONG lResult = E_UNEXPECTED;
DWORD dwDispositionLocal;
LPDWORD lpdwDispositionLocal;

    lpdwDispositionLocal = lpdwDisposition ? lpdwDisposition : &dwDispositionLocal;

    if (g_fWideWrap_Unicode)
    {
        lResult = RegCreateKeyExW(hKey,lpSubKey,Reserved,
                    lpClass,dwOptions,samDesired,lpSecurityAttributes,
                    phkResult,lpdwDispositionLocal);
    }
    else
    {
        lResult = ERROR_SUCCESS;

        XArray<CHAR> xszSubKey;
        XArray<CHAR> xszClass;
        LPSTR lpSubKeyA;
        LPSTR lpClassA;

        BOOL fOk = ConvertWideCharToMultiByte( lpSubKey, xszSubKey );
        if ( !fOk )
        {
            lResult =  ERROR_OUTOFMEMORY;
        }

        if (ERROR_SUCCESS == lResult)
        {
            lpSubKeyA = xszSubKey.Get();

            fOk = ConvertWideCharToMultiByte( lpClass, xszClass );
            if ( !fOk )
            {
                lResult = ERROR_OUTOFMEMORY;
            }
        }

        if (ERROR_SUCCESS == lResult)
        {
            lpClassA = xszClass.Get();

            lResult = RegCreateKeyExA(hKey,lpSubKeyA,Reserved,
                                      lpClassA,dwOptions,samDesired,lpSecurityAttributes,
                                      phkResult,lpdwDispositionLocal);
        }
    }


    // On NT Set the Security of any keys we create to Access Everyone
    if (VER_PLATFORM_WIN32_NT  == g_OSVersionInfo.dwPlatformId)
    {
        // on a success and the disposition is a new key setup the security.
        if ( (ERROR_SUCCESS == lResult) && (REG_CREATED_NEW_KEY == *lpdwDispositionLocal))
        {
	    // NOTE; if create included subkeys \\connection\\clsid only the 
	    // last key is set by SetRegSecurity. 

#ifdef _SETSECURITY
            SetRegKeySecurityEveryone(hKey,lpSubKey);
#endif // _SETSECURITY
        }
    }

#ifdef _SETSECURITY
    if ((ERROR_ACCESS_DENIED == lResult) && (fSetSecurity) )
    {
	    SyncMgrExecCmd_ResetRegSecurity();
	    lResult = RegCreateKeyExXp(hKey,lpSubKey,Reserved,lpClass,dwOptions,samDesired,
					    lpSecurityAttributes,phkResult,lpdwDisposition,FALSE /* fSetSecurity */);
    }
#endif // _SETSECURITY

    return lResult;
}


LONG
APIENTRY
RegCreateKeyExX(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
	return RegCreateKeyExXp(hKey,lpSubKey,Reserved,lpClass,dwOptions,samDesired,
						lpSecurityAttributes,phkResult,
                                                lpdwDisposition,FALSE /* fSetSecurity */);
}


BOOL GetUserNameX(
    LPWSTR lpBuffer,
    LPDWORD pnSize
)
{
BOOL fReturn = FALSE;

    if (g_fWideWrap_Unicode)
    {
        fReturn = GetUserNameW(lpBuffer,pnSize);
    }
    else
    {
        DWORD dwSizeA = *pnSize;
        DWORD dwOldSize = dwSizeA;

        XArray<CHAR> xszBufIn;
        BOOL fOk = xszBufIn.Init( dwSizeA );
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

        fReturn = GetUserNameA( xszBufIn.Get(), &dwSizeA );

        if (fReturn)
        {
            XArray<WCHAR> xwszBufOut;
            fOk = ConvertMultiByteToWideChar( xszBufIn.Get(), xwszBufOut );
            if ( !fOk )
            {
                SetLastError( ERROR_OUTOFMEMORY );
                return FALSE;
            }

            *pnSize = lstrlenX(xwszBufOut.Get()) + 1;

            if ( *pnSize < dwOldSize )
            {
                lstrcpyX( lpBuffer, xwszBufOut.Get() );
                return TRUE;
            }
            else
            {
                SetLastError( ERROR_MORE_DATA );
                return FALSE;
            }
        }
    }

    return fReturn;
}

UINT WINAPI RegisterWindowMessageX(LPCWSTR lpString)
{
    UINT ret;

    if (g_fWideWrap_Unicode)
    {
        ret = RegisterWindowMessageW(lpString);
        return ret;
    }

    XArray<CHAR> xszString;
    BOOL fOk = ConvertWideCharToMultiByte( lpString, xszString );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }

    ret = RegisterWindowMessageA( xszString.Get() );

    return ret;
}

LONG
APIENTRY
RegOpenKeyExXp(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult,
    BOOL fSetSecurity)
{
LONG ret;

    if (g_fWideWrap_Unicode)
    {
        ret = RegOpenKeyExW( hKey, lpSubKey, ulOptions, samDesired, phkResult );
    }
    else
    {

        XArray<CHAR> xszSubKey;
        BOOL fOk = ConvertWideCharToMultiByte( lpSubKey, xszSubKey );
        if ( !fOk )
            return ERROR_OUTOFMEMORY;

        ret = RegOpenKeyExA(hKey, xszSubKey.Get(), ulOptions, samDesired, phkResult);
    }

#ifdef _SETSECURITY
    if ((ERROR_ACCESS_DENIED == ret) && (fSetSecurity) )
    {
        SyncMgrExecCmd_ResetRegSecurity();
        ret = RegOpenKeyExXp(hKey,lpSubKey,ulOptions,samDesired,phkResult,FALSE /* fSetSecurity */);
    }
#endif // _SETSECURITY

    return ret;
}


LONG
APIENTRY
RegOpenKeyExX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    return RegOpenKeyExXp(hKey,lpSubKey,ulOptions,samDesired,phkResult,TRUE /* fSetSecurity */);
}

LONG
APIENTRY
RegQueryValueExX(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    LONG ret;
    if (g_fWideWrap_Unicode)
    {
        ret = RegQueryValueExW( hKey, lpValueName, lpReserved, lpType, lpData, lpcbData );
        return ret;
    }

    LPBYTE lpTempBuffer;
    DWORD dwTempType;
    DWORD cb, cbRequired;
    LPSTR sz;

    DWORD dwDataOldSize = 0;
    if ( lpcbData != NULL )
        dwDataOldSize = *lpcbData;

    XArray<CHAR> xszValueName;
    BOOL fOk = ConvertWideCharToMultiByte( lpValueName, xszValueName );
    if ( !fOk )
        return ERROR_OUTOFMEMORY;

    sz = xszValueName.Get();

    ret = RegQueryValueExA(hKey, sz, lpReserved, &dwTempType, NULL, &cb);

    // If the caller was just asking for the size of the value, jump out
    //  now, without actually retrieving and converting the value.

    if (lpData == NULL)
    {
        switch (dwTempType)
        {
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
        case REG_SZ:

            // Adjust size of buffer to report, to account for CHAR -> WCHAR

            if (lpcbData != NULL)
                *lpcbData = cb * sizeof(WCHAR);
            break;

        default:

            if (lpcbData != NULL)
                *lpcbData = cb;
            break;
        }

        // Set the type, if required.
        if (lpType != NULL)
        {
            *lpType = dwTempType;
        }

        goto Exit;
    }


    if (ret == ERROR_SUCCESS)
    {
        //
        // Determine the size of buffer needed
        //

        switch (dwTempType)
        {
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
        case REG_SZ:

            cbRequired = cb * sizeof(WCHAR);
            break;

        default:

            cbRequired = cb;
            break;
        }

        // If the caller was asking for the value, but allocated too small
        // of a buffer, set the buffer size and jump out.

        if (lpcbData != NULL && *lpcbData < cbRequired)
        {
            // Adjust size of buffer to report, to account for CHAR -> WCHAR
            *lpcbData = cbRequired;

            // Set the type, if required.
            if (lpType != NULL)
            {
                *lpType = dwTempType;
            }

            ret = ERROR_MORE_DATA;
            goto Exit;
        }

        // Otherwise, retrieve and convert the value.
        XArray<CHAR> xszTempBuffer;
        XArray<WCHAR> xwszValueOut;
        BOOL fOk;

        switch (dwTempType)
        {
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
        case REG_SZ:

            fOk = xszTempBuffer.Init( cbRequired );
            if ( !fOk )
                return ERROR_OUTOFMEMORY;

            lpTempBuffer = (BYTE *) xszTempBuffer.Get();

            ret = RegQueryValueExA(hKey,
                                  sz,
                                  lpReserved,
                                  &dwTempType,
                                  lpTempBuffer,
                                  &cb);

            if (ret == ERROR_SUCCESS)
            {
                switch (dwTempType)
                {
                case REG_EXPAND_SZ:
                case REG_SZ:

                    fOk = ConvertMultiByteToWideChar( (char *) lpTempBuffer,
                                                      cb,
                                                      xwszValueOut );
                    if ( !fOk )
                        return ERROR_OUTOFMEMORY;

                    *lpcbData = (lstrlenX(xwszValueOut.Get()) + 1) * sizeof(WCHAR);

                    if ( *lpcbData < dwDataOldSize )
                        lstrcpyX( (WCHAR *)lpData, xwszValueOut.Get() );
                    else
                        return ERROR_MORE_DATA;

                    // Set the type, if required.
                    if (lpType != NULL)
                    {
                        *lpType = dwTempType;
                    }

                    break;

                case REG_MULTI_SZ:

                    AssertSz(0,"E_NOTIMPL");

                  #if MULTI_SZ
                    LPWSTR pwszTempWide;
                    LPSTR pszTempNarrow;
                    ULONG ulStringLength;

                    Assert( !"MultiToWideChar conversion is improper" );

                    pszTempNarrow = (LPSTR) lpTempBuffer;
                    pwszTempWide = (LPWSTR) lpData;

                    while (*pszTempNarrow != NULL)
                    {
                        ulStringLength = lstrlenA(pszTempNarrow) + 1;
                        AnsiToUnicode(pwszTempWide,
                                      pszTempNarrow,
                                      ulStringLength);

                        // Compiler will scale appropriately here
                        pszTempNarrow += ulStringLength;
                        pwszTempWide += ulStringLength;
                    }
                    *pwszTempWide = NULL; // let's not forget MULTI_SZ end NULL
                  #endif // MULTI_SZ
                    break;
                }
            }

            break;

        default:

            //
            // No conversion of out parameters needed.  Just call narrow
            // version with args passed in, and return directly.
            //

            ret = RegQueryValueExA(hKey,
                                   sz,
                                   lpReserved,
                                   lpType,
                                   lpData,
                                   lpcbData);

        }
    }

Exit:

    return ret;
}

HWND
WINAPI
CreateWindowExX( DWORD dwExStyle,
                 LPCWSTR lpClassName,
                 LPCWSTR lpWindowName,
                 DWORD dwStyle,
                 int X,
                 int Y,
                 int nWidth,
                 int nHeight,
                 HWND hWndParent ,
                 HMENU hMenu,
                 HINSTANCE hInstance,
                 LPVOID lpParam )
{
    HWND ret = NULL;
    if (g_fWideWrap_Unicode)
    {
        ret = CreateWindowExW( dwExStyle,
                               lpClassName,
                               lpWindowName,
                               dwStyle,
                               X,
                               Y,
                               nWidth,
                               nHeight,
                               hWndParent,
                               hMenu,
                               hInstance,
                               lpParam );
        return ret;
    }

    LPSTR szClass;
    BOOL fOk;
    XArray<CHAR> xszClass;

    if (HIWORD(lpClassName) == 0)
        szClass = (LPSTR) lpClassName;
    else
    {
        fOk = ConvertWideCharToMultiByte( lpClassName, xszClass );
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return NULL;
        }

        szClass = xszClass.Get();
    }

    XArray<CHAR> xszWindow;
    fOk = ConvertWideCharToMultiByte( lpWindowName, xszWindow );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return NULL;
    }

    ret = CreateWindowExA ( dwExStyle,
                            szClass,
                            xszWindow.Get(),
                            dwStyle,
                            X,
                            Y,
                            nWidth,
                            nHeight,
                            hWndParent,
                            hMenu,
                            hInstance,
                            lpParam);

    return ret;
}

#if 0
HWND
WINAPI
CreateWindowX(  LPCWSTR lpClassName,
                LPCWSTR lpWindowName,
                DWORD dwStyle,
                int X,
                int Y,
                int nWidth,
                int nHeight,
                HWND hWndParent ,
                HMENU hMenu,
                HINSTANCE hInstance,
                LPVOID lpParam )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateWindow\n");
    #endif

    return CreateWindowExX(0, lpClassName, lpWindowName, dwStyle, X, Y,
            nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}
#endif


HWND WINAPI CreateDialogParamX(
      HINSTANCE hInstance,
      LPCWSTR lpwszTemplateName,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam
)
{
    HWND hwndDialog = NULL;
    if (g_fWideWrap_Unicode)
    {
        hwndDialog = CreateDialogParamW( hInstance,
                                         lpwszTemplateName,
                                         hWndParent,
                                         lpDialogFunc,
                                         dwInitParam );
        return hwndDialog;
    }

    LPSTR pszTemplateName;

    XArray<CHAR> xszTemplate;

    if (HIWORD(lpwszTemplateName) == 0)
    {
        //
        // Is it an atom?
        //
        pszTemplateName = (LPSTR) lpwszTemplateName;
    }
    else
    {
        //
        // Otherwise convert the string
        //
        BOOL fOk = ConvertWideCharToMultiByte( lpwszTemplateName, xszTemplate );
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return NULL;
        }

        pszTemplateName = xszTemplate.Get();
    }

    if (pszTemplateName)
        hwndDialog = CreateDialogParamA(hInstance,pszTemplateName,hWndParent,lpDialogFunc,dwInitParam);

    return hwndDialog;
}

INT_PTR
WINAPI
DialogBoxParamX(
    IN HINSTANCE hInstance,
    IN LPCWSTR lpTemplateName,
    IN HWND hWndParent,
    IN DLGPROC lpDialogFunc,
    IN LPARAM dwInitParam)
{
INT_PTR iReturn = -1;

    if (g_fWideWrap_Unicode)
    {
        iReturn = DialogBoxParamW(hInstance,lpTemplateName,hWndParent,lpDialogFunc,dwInitParam);
    }
    else
    {
    LPSTR lpTemplateNameA;

        Assert(0 == HIWORD(lpTemplateName)); // only support atoms

        if (0 == HIWORD(lpTemplateName))
        {
            lpTemplateNameA = (LPSTR) lpTemplateName;

            iReturn = DialogBoxParamA(hInstance,lpTemplateNameA,hWndParent,lpDialogFunc,dwInitParam);

        }

    }

    return iReturn;

}

ATOM
WINAPI
RegisterClassX(
    CONST WNDCLASSW *lpWndClass)
{
    ATOM      ret;
    if (g_fWideWrap_Unicode)
    {
        ret = RegisterClassW( lpWndClass );
        return ret;
    }

    WNDCLASSA wc;

    Win4Assert(sizeof(WNDCLASSA) == sizeof(WNDCLASSW));

    memcpy(&wc, lpWndClass, sizeof(WNDCLASS));

    XArray<CHAR> xszMenu;
    BOOL fOk = ConvertWideCharToMultiByte( lpWndClass->lpszMenuName, xszMenu );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }
    wc.lpszMenuName = xszMenu.Get();

    XArray<CHAR> xszClass;

    if (HIWORD(lpWndClass->lpszClassName) == 0)
        wc.lpszClassName = (LPSTR) lpWndClass->lpszClassName;
    else
    {
        fOk = ConvertWideCharToMultiByte( lpWndClass->lpszClassName, xszClass );
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return 0;
        }

        wc.lpszClassName = xszClass.Get();
    }

    ret = RegisterClassA(&wc);

    return ret;
}

#if 0
BOOL
WINAPI
UnregisterClassX(
    LPCWSTR lpClassName,
    HINSTANCE hInstance)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("UnregisterClass\n");
    #endif

    LPSTR sz;
    BOOL  ret;
    BOOL  fAtom = FALSE;

    if (HIWORD(lpClassName) == 0)
    {
        sz = (LPSTR) lpClassName;
        fAtom = TRUE;
    }
    else
    {
        sz = Convert(lpClassName);
        if (sz == ERR)
            return FALSE;
    }

    ret = UnregisterClassA(sz, hInstance);
    if (!fAtom) FREE(sz);
    return ret;
}


HANDLE
WINAPI
GetPropX(
    HWND hWnd,
    LPCWSTR lpString)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetProp\n");
    #endif

    HANDLE ret;
    LPSTR  sz;
    BOOL   fAtom = FALSE;

    if (HIWORD(lpString)==0)
    {
        fAtom = TRUE;
        sz = (LPSTR) lpString;
    }
    else
    {
        sz = Convert(lpString);
        if (sz == ERR)
            return NULL;
    }

    ret = GetPropA(hWnd, sz);
    if (!fAtom) FREE(sz);
    return ret;
}


BOOL
WINAPI
SetPropX(
    HWND hWnd,
    LPCWSTR lpString,
    HANDLE hData)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("SetProp\n");
    #endif

    BOOL  ret;
    LPSTR sz;
    BOOL  fAtom = FALSE;

    if (HIWORD(lpString)==0)
    {
        sz = (LPSTR) lpString;
        fAtom = TRUE;
    }
    else
    {
        sz = Convert(lpString);
        if (sz == ERR)
            return NULL;
    }

    ret = SetPropA(hWnd, sz, hData);
    if (!fAtom) FREE(sz);
    return ret;
}


HANDLE
WINAPI
RemovePropX(
    HWND hWnd,
    LPCWSTR lpString)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RemoveProp\n");
    #endif

    HANDLE ret;
    LPSTR  sz;
    BOOL   fAtom = FALSE;

    if (HIWORD(lpString)==0)
    {
        sz = (LPSTR) lpString;
        fAtom = TRUE;
    }
    else
    {
        sz = Convert(lpString);
        if (sz == ERR)
            return NULL;
    }

    ret = RemovePropA(hWnd, sz);
    if (!fAtom) FREE(sz);
    return ret;
}


UINT
WINAPI
GetProfileIntX(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT     nDefault
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetProfileInt\n");
    #endif

    LPSTR szApp;
    LPSTR szKey;
    UINT  ret;

    szApp = Convert(lpAppName);
    if (szApp==ERR)
    {
        return nDefault;
    }

    szKey = Convert(lpKeyName);
    if (szApp==ERR)
    {
        if (szApp)
            FREE( szApp);
        return nDefault;
    }

    ret = GetProfileIntA(szApp, szKey, nDefault);
    if (szApp)
        FREE( szApp);
    if (szKey)
        FREE( szKey);
    return ret;
}

ATOM
WINAPI
GlobalAddAtomX(
    LPCWSTR lpString
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GlobalAddAtom\n");
    #endif

    ATOM ret;
    LPSTR sz;

    sz = Convert(lpString);
    if (sz==ERR)
    {
        return NULL;
    }

    ret = GlobalAddAtomA(sz);
    if (sz)
        FREE(sz);
    return ret;
}

UINT
WINAPI
GlobalGetAtomNameX(
    ATOM nAtom,
    LPWSTR pwszBuffer,
    int nSize
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GlobalGetAtomName\n");
    #endif

    LPSTR sz;
    UINT ret;

    sz = (char *) ALLOC(nSize*sizeof(char));
    if (sz == NULL)
    {
        return 0;
    }

    ret = GlobalGetAtomNameA(nAtom, sz, nSize);
    if (ret)
    {
        AnsiToUnicode(pwszBuffer, sz, lstrlenA(sz) + 1);
    }
    if (sz)
        FREE(sz);
    return ret;
}
#endif

DWORD
WINAPI
GetModuleFileNameX(
    HINSTANCE hModule,
    LPWSTR pwszFilename,
    DWORD nSize
    )
{
    DWORD ret;
    if (g_fWideWrap_Unicode)
    {
        ret = GetModuleFileNameW( hModule, pwszFilename, nSize );
        return ret;
    }

    XArray<CHAR> xszFileName;
    BOOL fOk = xszFileName.Init( nSize );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }

    ret = GetModuleFileNameA(hModule, xszFileName.Get(), nSize);
    if (ret == 0 )
        return ret;

    XArray<WCHAR> xwszName;
    fOk = ConvertMultiByteToWideChar( xszFileName.Get(), ret, xwszName );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }

    ret = lstrlenX( xwszName.Get() );
    if ( ret >= nSize)
    {
        //
        // Truncate to fit
        //
        ret = nSize -1;
        lstrcpynX( pwszFilename, xwszName.Get(), ret );
        pwszFilename[ret] = 0;
    }
    else
        lstrcpyX( pwszFilename, xwszName.Get() );

    return ret;
}

#if 0
LPWSTR
WINAPI
CharPrevX(
    LPCWSTR lpszStart,
    LPCWSTR lpszCurrent)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CharPrev\n");
    #endif

    if (lpszCurrent == lpszStart)
    {
        return (LPWSTR) lpszStart;
    }
    else
    {
        return (LPWSTR) lpszCurrent - 1;
    }
}

HFONT WINAPI CreateFontX(int a, int b, int c, int d, int e, DWORD f,
                         DWORD g, DWORD h, DWORD i, DWORD j, DWORD k,
                         DWORD l, DWORD m, LPCWSTR pwsz)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFont\n");
    #endif

    LPSTR sz;
    HFONT ret;

    sz = Convert(pwsz);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = CreateFontA(a,b,c,d,e,f,g,h,i,j,k,l,m,sz);
    if (sz)
        FREE(sz);
    return ret;
}
#endif


HINSTANCE
WINAPI
LoadLibraryX(
    LPCWSTR pwszFileName
    )
{
    HINSTANCE ret;
    if (g_fWideWrap_Unicode)
    {
        ret = LoadLibraryW( pwszFileName );
        return ret;
    }

    XArray<CHAR> xszName;
    BOOL fOk = ConvertWideCharToMultiByte( pwszFileName, xszName, TRUE );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return NULL;
    }

    ret = LoadLibraryA( xszName.Get() );

    return ret;
}

#if 0
HMODULE
WINAPI
LoadLibraryExX(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("LoadLibrary\n");
    #endif

    HINSTANCE ret;
    LPSTR sz;

    sz = ConvertOem(lpLibFileName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = LoadLibraryExA(sz, hFile, dwFlags);
    if (sz)
        FREE(sz);
    return ret;
}
#endif

LONG
APIENTRY
RegDeleteKeyXp(
    HKEY hKey,
    LPCWSTR pwszSubKey,
    BOOL fSetSecurity
    )
{
LONG ret;

    if (g_fWideWrap_Unicode)
    {
        ret = RegDeleteKeyW( hKey, pwszSubKey );
    }
    else
    {
        XArray<CHAR> xszSubKey;
        BOOL fOk = ConvertWideCharToMultiByte( pwszSubKey, xszSubKey );
        if ( !fOk )
            return ERROR_OUTOFMEMORY;

        ret = RegDeleteKeyA(hKey, xszSubKey.Get() );
    }

    if ((ERROR_ACCESS_DENIED == ret) && (fSetSecurity) )
    {
        SyncMgrExecCmd_ResetRegSecurity();
        ret = RegDeleteKeyXp(hKey,pwszSubKey,FALSE /*fSetSecurity*/);

    }

    return ret;
}


LONG
APIENTRY
RegDeleteKeyX(
    HKEY hKey,
    LPCWSTR pwszSubKey
    )
{
    return RegDeleteKeyXp(hKey,pwszSubKey,TRUE /*fSetSecurity*/);
}

BOOL
APIENTRY
CreateProcessX(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    BOOL ret = FALSE;
    if (g_fWideWrap_Unicode)
    {
        ret = CreateProcessW( lpApplicationName,
                              lpCommandLine,
                              lpProcessAttributes,
                              lpThreadAttributes,
                              bInheritHandles,
                              dwCreationFlags,
                              lpEnvironment,
                              lpCurrentDirectory,
                              lpStartupInfo,
                              lpProcessInformation );
        return ret;
    }

    STARTUPINFOA si;
    LPSTR        szApp = NULL;
    LPSTR        szCommand = NULL;
    LPSTR        szDir = NULL;

    memcpy(&si, lpStartupInfo, sizeof(STARTUPINFO));

    si.lpTitle = NULL;

    XArray<CHAR> xszDesktop;
    BOOL fOk = ConvertWideCharToMultiByte( lpStartupInfo->lpDesktop, xszDesktop );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }
    si.lpDesktop = xszDesktop.Get();

    XArray<CHAR> xszTitle;
    fOk = ConvertWideCharToMultiByte( lpStartupInfo->lpTitle, xszTitle );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }
    si.lpTitle = xszTitle.Get();

    XArray<CHAR> xszAppName;
    fOk = ConvertWideCharToMultiByte( lpApplicationName, xszAppName, TRUE );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }
    szApp = xszAppName.Get();

    XArray<CHAR> xszCommand;
    fOk = ConvertWideCharToMultiByte( lpCommandLine, xszCommand, TRUE );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }
    szCommand = xszCommand.Get();

    XArray<CHAR> xszCurDir;
    fOk = ConvertWideCharToMultiByte( lpCurrentDirectory, xszCurDir, TRUE );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }
    szDir = xszCurDir.Get();

    ret = CreateProcessA(szApp, szCommand, lpProcessAttributes,
                lpThreadAttributes, bInheritHandles, dwCreationFlags,
                lpEnvironment, szDir, &si, lpProcessInformation);

    return ret;
}

LONG
APIENTRY
RegEnumKeyExX(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )
{
    LONG  ret = ERROR_OUTOFMEMORY;
    if (g_fWideWrap_Unicode)
    {
        ret = RegEnumKeyExW( hKey,
                           dwIndex,
                           lpName,
                           lpcbName,
                           lpReserved,
                           lpClass,
                           lpcbClass,
                           lpftLastWriteTime );
        return ret;
    }


    LPSTR szName;

    XArray<CHAR> xszName;
    BOOL fOk = xszName.Init( *lpcbName );
    if ( !fOk )
        return ERROR_OUTOFMEMORY;

    szName = xszName.Get();

    DWORD dwNameOldSize = *lpcbName;
    DWORD dwClassOldSize = 0;

    LPSTR szClass = NULL;
    XArray<CHAR> xszClass;
    if (lpClass != NULL)
    {
        fOk = xszClass.Init( *lpcbClass );
        if ( !fOk )
            return ERROR_OUTOFMEMORY;

        szClass = xszClass.Get();

        dwClassOldSize = *lpcbClass;
    }

    //
    //  Return lengths do not include zero char.
    //
    ret = RegEnumKeyExA(hKey, dwIndex, szName, lpcbName, lpReserved,
                       szClass, lpcbClass, lpftLastWriteTime);

    if (ret == ERROR_SUCCESS)
    {
        XArray<WCHAR> xwszNameOut;
        fOk = ConvertMultiByteToWideChar( szName,
                                          *lpcbName + 1,
                                          xwszNameOut );
        if ( !fOk )
            return ERROR_OUTOFMEMORY;

        if ( lstrlenX(xwszNameOut.Get()) < dwNameOldSize )
             lstrcpyX( lpName, xwszNameOut.Get() );
        else
            return ERROR_MORE_DATA;

        if (szClass)
        {
            XArray<WCHAR> xwszClassOut;
            fOk = ConvertMultiByteToWideChar( szClass,
                                              *lpcbClass + 1,
                                              xwszClassOut );
            if ( !fOk )
                return ERROR_OUTOFMEMORY;

            if ( lstrlenX(xwszClassOut.Get()) < dwClassOldSize)
                 lstrcpyX( lpClass, xwszClassOut.Get() );
            else
                return ERROR_MORE_DATA;
        }
    }

    return ret;
}

#if 0
BOOL
WINAPI
AppendMenuX(
    HMENU hMenu,
    UINT uFlags,
    UINT uIDnewItem,
    LPCWSTR lpnewItem
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("AppendMenu\n");
    #endif

    BOOL  ret;
    LPSTR sz;

    if (uFlags == MF_STRING)
    {
        sz = Convert(lpnewItem);
        if (sz==ERR)
        {
            return FALSE;
        }
    }
    else
    {
        sz = (LPSTR) lpnewItem;
    }

    ret = AppendMenuA(hMenu, uFlags, uIDnewItem, sz);

    if (uFlags == MF_STRING)
    {
        if (sz)
            FREE(sz);
    }

    return ret;
}


HANDLE
WINAPI
OpenEventX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("OpenEvent\n");
    #endif

    LPSTR sz;
    HANDLE ret;

    sz = Convert(lpName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = OpenEventA(dwDesiredAccess, bInheritHandle, sz);
    if (sz)
        FREE(sz);
    return ret;
}
#endif

HANDLE
WINAPI
CreateEventX(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )
{
    HANDLE ret;
    if (g_fWideWrap_Unicode)
    {
        ret = CreateEventW( lpEventAttributes,
                            bManualReset,
                            bInitialState,
                            lpName );
        return ret;
    }

    XArray<CHAR> xszName;
    BOOL fOk = ConvertWideCharToMultiByte( lpName, xszName );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }

    ret = CreateEventA(lpEventAttributes, bManualReset, bInitialState, xszName.Get() );

    return ret;
}

HANDLE
WINAPI
CreateMutexX(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    )
{
HANDLE ret;

    if (g_fWideWrap_Unicode)
    {
        ret = CreateMutexW( lpEventAttributes,
                            bInitialOwner,
                            lpName );
        return ret;
    }

    XArray<CHAR> xszName;
    BOOL fOk = ConvertWideCharToMultiByte( lpName, xszName );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }

    ret = CreateMutexA(lpEventAttributes,bInitialOwner, xszName.Get() );

    return ret;
}

#if 0

UINT
WINAPI
GetDriveTypeX(
    LPCWSTR lpRootPathName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetDriveType\n");
    #endif

    LPSTR sz;
    UINT ret;

    sz = ConvertOem(lpRootPathName);
    if (sz == ERR)
    {
        return 0;
    }

    ret = GetDriveTypeA(sz);
    if (sz)
        FREE(sz);
    return ret;
}

DWORD
WINAPI
GetFileAttributesX(
    LPCWSTR lpFileName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetFileAttributes\n");
    #endif

    LPSTR sz;
    DWORD ret;

    sz = ConvertOem(lpFileName);
    if (sz == ERR)
        return 0xFFFFFFFF;

    ret = GetFileAttributesA(sz);
    if (sz)
        FREE(sz);
    return ret;
}
#endif


LONG
APIENTRY
RegEnumKeyX(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    )
{
    LONG ret;
    if (g_fWideWrap_Unicode)
    {
        ret = RegEnumKeyW( hKey,
                           dwIndex,
                           lpName,
                           cbName );
        return ret;
    }

    CHAR sz[MAX_PATH+1];

    //
    //  Return lengths do not include zero char.
    //
    Assert( cbName <= MAX_PATH + 1 );

    ret = RegEnumKeyA(hKey, dwIndex, sz, cbName);
    if (ret == ERROR_SUCCESS)
    {
        XArray<WCHAR> xwszName;
        BOOL fOk = ConvertMultiByteToWideChar( sz, xwszName );
        if ( !fOk )
            return ERROR_OUTOFMEMORY;

        if ( lstrlenX(xwszName.Get()) < cbName)
        {
            lstrcpyX( lpName, xwszName.Get() );
        }
        else
            return ERROR_MORE_DATA;
    }

    return ret;
}

#if 0
LONG
APIENTRY
RegEnumValueX(
    HKEY hkey,
    DWORD dwIndex,
    LPWSTR wszName,
    LPDWORD pcbName,
    LPDWORD pReserved,
    LPDWORD ptype,
    LPBYTE  pValue,
    LPDWORD pcbValue)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegEnumValue\n");
    #endif

  //  CHAR szName[KEY_LEN+1];
    CHAR szName[MAX_PATH+1]; // reiview this length
    LONG ret;
    DWORD dwGivenSize= *pcbName;

    Win4Assert(dwGivenSize <= MAX_PATH+1);
    //
    //  Return lengths do not include zero char.
    //
    ret = RegEnumValueA(hkey, dwIndex, szName, pcbName, pReserved, ptype, pValue, pcbValue);
    if (ret == ERROR_SUCCESS)
    {
        AnsiToUnicode(wszName, szName, dwGivenSize);
    }
    return ret;
}

HFINDFILE
WINAPI
FindFirstFileX(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW pwszFd
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("FindFirstFile\n");
    #endif

    WIN32_FIND_DATAA fd;
    CHAR             sz[MAX_PATH * 2];
    HFINDFILE        ret;
    int              len = lstrlenX(lpFileName) + 1;

    UnicodeToAnsiOem(sz, lpFileName, sizeof(sz));
    ret = FindFirstFileA(sz, &fd);
    if (ret != INVALID_HANDLE_VALUE)
    {
        memcpy(pwszFd, &fd, sizeof(FILETIME)*3 + sizeof(DWORD)*5);
        AnsiToUnicodeOem(pwszFd->cFileName, fd.cFileName,
                         lstrlenA(fd.cFileName) + 1);
        AnsiToUnicodeOem(pwszFd->cAlternateFileName, fd.cAlternateFileName,
                         14);
    }

    return ret;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   wsprintfX
//
//  Synopsis:   internal implementation of wsprintf
//
//  Arguments:  [pwszOut]    --
//              [pwszFormat] --
//              [...]        --
//
//  Returns:    size of string.
//
//  History:    26-Aug-98    Rogerg
//
//
//----------------------------------------------------------------------------


#ifndef _M_ALPHA

int WINAPIV wsprintfX(LPWSTR pwszOut, LPCWSTR pwszFormat, ...)
{
va_list arglist;
LPCWSTR pwszFmtPos;
LPWSTR pwszBufPos;
ULONG cbSkipLen;

    // need to loop through format pushing items into the out buffer.
    // Then use the out buffer string as what is actually passed to
    // the real API.

    pwszFmtPos = pwszFormat;
    pwszBufPos = pwszOut;

    va_start(arglist, pwszFormat);

    while (*pwszFmtPos) {

        cbSkipLen = 0;

        if (*(pwszFmtPos) == '%')		
        {

            switch (*(pwszFmtPos + 1))
            {
                case 'l':
                {
                    Assert('u' == *(pwszFmtPos + 2));
                    cbSkipLen = 3; // go ahead and skip %lu
                    //fall through
                }
                case 'u':
                {
                    DWORD dw = va_arg(arglist,ULONG);

                    _ltow(dw, pwszBufPos, 10 );
                    pwszBufPos += lstrlenX(pwszBufPos);

                    if (0 == cbSkipLen)
                    {
                        cbSkipLen = 2; // if no %lu case, skip %u
                    }

                    break;
                }
                case 'w':
                {

                    Assert('s' == *(pwszFmtPos + 2));
                    cbSkipLen = 3; // go ahead and skip %ws
                    // fall through
                }
                case 's':
                {
                DWORD cch;
                WCHAR *pwsz = va_arg(arglist, LPWSTR);

                    if (0 == cbSkipLen)
                    {
                        cbSkipLen = 2; // if no %ws case, skip %s
                    }

                    Assert(pwsz);

                    if (pwsz)
                    {
                        cch = lstrlenX(pwsz);
                        lstrcpynX(pwszBufPos,pwsz,cch);
                        pwszBufPos += cch;
                    }

                    break;
                }
                case 'd':
                {
                DWORD dw = va_arg(arglist,long);

                    _itow(dw, pwszBufPos, 10 );
                    pwszBufPos += lstrlenX(pwszBufPos);

                    cbSkipLen = 2; // go ahead and skip %d
                    break;
                }
                
                default:
                   AssertSz(0,"Uknown % passed to wsprintf");
                   break;
            }
        }

        if (cbSkipLen)
        {
            pwszFmtPos += cbSkipLen;
        }
        else
        {
            *pwszBufPos = *pwszFmtPos;
            *pwszBufPos++;
            *pwszFmtPos++;	
        }

    }

    *pwszBufPos = NULL; // terminate the string.

    return lstrlenX(pwszOut);
}

#endif // #ifndef _M_ALPHA


BOOL
WINAPI
GetComputerNameX(
    LPWSTR pwszName,
    LPDWORD lpcchBuffer
    )
{
    BOOL ret;
    if (g_fWideWrap_Unicode)
    {
        ret = GetComputerNameW( pwszName, lpcchBuffer );
        return ret;
    }

    DWORD OldSize = *lpcchBuffer;

    XArray<CHAR> xszNameIn;
    BOOL fOk = xszNameIn.Init( OldSize );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }

    ret = GetComputerNameA( xszNameIn.Get(), lpcchBuffer );
    if ( ret == 0 )
        return ret;

    XArray<WCHAR> xwszNameOut;
    fOk = ConvertMultiByteToWideChar( xszNameIn.Get(), xwszNameOut );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }

    *lpcchBuffer = lstrlenX( xwszNameOut.Get() );

    if ( *lpcchBuffer < OldSize - 1 )
    {
        lstrcpyX( pwszName, xwszNameOut.Get() );
        return ret;
    }
    else
    {
        SetLastError( ERROR_MORE_DATA );
        return 0;
    }
}


LRESULT
DefWindowProcX(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam)
{
    if (g_fWideWrap_Unicode)
    {
        return DefWindowProcW(hWnd,Msg,wParam,lParam);
    }
    else
    {
        return DefWindowProcA(hWnd,Msg,wParam,lParam);
    }

}

#if 0
DWORD
WINAPI
GetFullPathNameX(
    LPCWSTR lpFileName,
    DWORD   cchBuffer,
    LPWSTR  lpPathBuffer,
    LPWSTR *lppFilePart
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetFullPathName\n");
    #endif

    LPSTR szFileName;
    CHAR  szPathBuffer[MAX_PATH];
    LPSTR szFilePart;
    DWORD ret;


    szFileName = ConvertOem(lpFileName);
    if (szFileName == ERR)
        return 0;

    ret = GetFullPathNameA(szFileName, cchBuffer, szPathBuffer, &szFilePart);

    AnsiToUnicodeOem(lpPathBuffer, szPathBuffer, cchBuffer);

    *lppFilePart = lpPathBuffer + (szFilePart - szPathBuffer);

    if (szFileName)
        FREE( szFileName);

    return ret;
}


DWORD
WINAPI
GetShortPathNameX(
    LPCWSTR lpszFullPath,
    LPWSTR  lpszShortPath,
    DWORD   cchBuffer
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetShortPathName\n");
    #endif

    LPSTR szFullPath;
    CHAR  szShortBuffer[MAX_PATH];
    DWORD ret;


    szFullPath = Convert(lpszFullPath);
    if (szFullPath == ERR)
        return 0;

    if (lpszShortPath == NULL)
    {
        ret = GetShortPathNameA(szFullPath, NULL, cchBuffer);
    }
    else
    {
        ret = GetShortPathNameA(szFullPath, szShortBuffer, sizeof(szShortBuffer));

        if (ret != 0)
        {
            //
            //  Only convert the actual data, not the whole buffer.
            //
            if (cchBuffer > ret + 1)
                cchBuffer = ret + 1;

            AnsiToUnicode(lpszShortPath, szShortBuffer, cchBuffer);
        }
    }

    FREE( szFullPath);

    return ret;
}
#endif


DWORD
WINAPI
SearchPathX(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    )
{
    DWORD ret;
    if (g_fWideWrap_Unicode)
    {
        ret = SearchPathW( lpPath,
                           lpFileName,
                           lpExtension,
                           nBufferLength,
                           lpBuffer,
                           lpFilePart );
        return ret;
    }

    LPSTR lpszFileName;
    CHAR  szBuffer[MAX_PATH];

    XArray<CHAR> xszFileName;
    BOOL fOk = ConvertWideCharToMultiByte( lpFileName, xszFileName, TRUE );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }

    lpszFileName = xszFileName.Get();

    ret = SearchPathA(NULL, lpszFileName, NULL, sizeof(szBuffer), szBuffer, NULL);
    if ( ret == 0 )
        return ret;

    XArray<WCHAR> xwszBufOut;
    fOk = ConvertMultiByteToWideChar( szBuffer, xwszBufOut, TRUE );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return FALSE;
    }

    if ( lstrlenX(xwszBufOut.Get()) < nBufferLength )
    {
        lstrcpyX( lpBuffer, xwszBufOut.Get() );
        return ret;
    }
    else
    {
        SetLastError( ERROR_MORE_DATA );
        return 0;
    }

    return ret;
}

#if 0
ATOM
WINAPI
GlobalFindAtomX(
    LPCWSTR lpString
    )
{
    LPSTR lpszString;
    ATOM  retAtom;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("GlobalFindAtom\n");
    #endif

    lpszString = Convert(lpString);
    if (lpszString == ERR)
        return 0;

    retAtom = GlobalFindAtomA(lpszString);

    FREE( lpszString);

    return retAtom;
}


int
WINAPI
GetClassNameX(
    HWND hWnd,
    LPWSTR lpClassName,
    int nMaxCount)
{
    LPSTR lpszClassName = NULL;
    int  ret;

    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetClassName\n");
    #endif

    lpszClassName = (CHAR *) ALLOC(nMaxCount);
    if (lpszClassName == NULL)
    {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    ret = GetClassNameA(hWnd, lpszClassName, nMaxCount);

    if (ret)
    {
        AnsiToUnicode(lpClassName, lpszClassName, lstrlenA(lpszClassName) + 1);
    }

    FREE( lpszClassName);

    return ret;
}


LPWSTR
WINAPI
CharLowerX(
    LPWSTR lpsz)
{
    if (((DWORD)lpsz & 0xffff0000) == 0)
    {
        return (LPWSTR)towlower ((wchar_t)lpsz);
    } else {
        return _wcslwr (lpsz);
    }
}

LPWSTR
WINAPI
CharUpperX(
    LPWSTR lpsz)
{
    if (((DWORD)lpsz & 0xffff0000) == 0)
    {
        return (LPWSTR)towupper ((wchar_t)lpsz);
    } else {
        return _wcsupr (lpsz);
    }
}

BOOL
WINAPI
GetStringTypeX(
    DWORD    dwInfoType,
    LPCWSTR  lpSrcStr,
    int      cchSrc,
    LPWORD   lpCharType)
{
    // Convert the source string to MBS. If we don't get the same number
    // of characters, this algorithm doesn't work.

    int OriginalLength = cchSrc == -1 ? lstrlenX (lpSrcStr) + 1 : cchSrc;
    LPSTR lpConvertedString = (LPSTR) ALLOC(OriginalLength+1);

    if (lpConvertedString == NULL)
    {
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    if (WideCharToMultiByte (CP_ACP,
                             WC_COMPOSITECHECK,
                             lpSrcStr,
                             cchSrc,
                             lpConvertedString,
                             OriginalLength,
                             NULL,
                             NULL) != OriginalLength)
    {
        FREE( lpConvertedString);
        SetLastError (ERROR_NO_UNICODE_TRANSLATION);
        return FALSE;
    }

    BOOL Result;

    Result = GetStringTypeA (GetThreadLocale (),
                             dwInfoType,
                             lpConvertedString,
                             OriginalLength,
                             lpCharType);
    FREE( lpConvertedString);
    return Result;
}

BOOL
WINAPI
IsCharAlphaX(
    WCHAR ch)
{
    return iswctype (ch, _UPPER | _LOWER);
}

BOOL
WINAPI
IsCharAlphaNumericX(
    WCHAR ch)
{
    return iswctype (ch, _UPPER | _LOWER | _DIGIT);
}
#endif

LPWSTR
WINAPI
lstrcatX(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    LPWSTR lpDest = lpString1;

    Assert(lpString1);
    Assert(lpString2);

    while (*lpDest) {
        lpDest++;
    }

    while (*lpDest++ = *lpString2++) ;

    return lpString1;
}

int
WINAPI
lstrcmpX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    Assert(lpString1);
    Assert(lpString2);

    return wcscmp(lpString1, lpString2);
}


int  
strnicmpX(
    LPWSTR lpString1, 
    LPWSTR lpString2,
    size_t count
    )
{
int nRet = 0;

    Assert(lpString1);
    Assert(lpString2);

    while (count-- && 
           !(nRet = toupper(*lpString1)
		    - toupper(*lpString2)) &&
          *lpString1)
    {
      lpString1++;
      lpString2++;
    }

    return nRet;

}

LPWSTR
WINAPI
lstrcpyX(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    LPWSTR lpDest = lpString1;

    Assert(lpString1);
    Assert(lpString2);

    while( *lpDest++ = *lpString2++ )
        ;

    return lpString1;
}

LPWSTR
WINAPI
lstrcpynX(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    )
{
    LPWSTR dst;

    Assert(lpString1);
    Assert(lpString2);

    if (iMaxLength)
    {
        dst = lpString1;

        while (iMaxLength && *lpString2)
        {
            *dst++ = *lpString2++;
            iMaxLength--;
        }

        *dst = L'\0';
    }

    return lpString1;
}

int
WINAPI
lstrcmpiX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    Assert(lpString1);
    Assert(lpString2);

    return _wcsicmp(lpString1, lpString2);
}

DWORD
WINAPI
lstrlenX(
    LPCWSTR lpString
    )
{
LPWSTR eos = (LPWSTR) lpString;

    Assert(lpString)

    if (!lpString)
        return 0;

    __try
    {
        while (*eos++);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        AssertSz(0,"Invalid String");
        return 0;
    }

    return (int) (eos - lpString - 1);
}

BOOL
WINAPI
SetFileAttributesX(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    )
{
BOOL fReturn = FALSE;

    if (g_fWideWrap_Unicode)
    {
        return SetFileAttributesW(lpFileName,dwFileAttributes);
    }
    else
    {
    XArray<CHAR> xszFileName;
    BOOL fOk;

        fOk = ConvertWideCharToMultiByte(lpFileName,xszFileName);
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return 0;
        }

        fReturn = SetFileAttributesA(xszFileName.Get(),dwFileAttributes);
    }

    return fReturn;
}

int
WINAPI
MessageBoxX(
    HWND hWnd,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType)
{
int iReturn = 0; // MessageBox returns 0 if fails because out of memory

        if (g_fWideWrap_Unicode)
        {
                return MessageBoxW(hWnd,lpText,lpCaption,uType);
        }
        else
        {
        XArray<CHAR> xszText;
        XArray<CHAR> xszCaption;
        BOOL fOkText,fOkCaption;

                Assert(lpText && lpCaption);

                fOkText = ConvertWideCharToMultiByte(lpText,xszText);
                fOkCaption = ConvertWideCharToMultiByte(lpCaption,xszCaption);

                if (!fOkText || !fOkCaption)
                {
                        SetLastError( ERROR_OUTOFMEMORY );
                        return 0;
                }

                iReturn = MessageBoxA(hWnd,xszText.Get(),xszCaption.Get(),uType);
        }

    return iReturn;
}

#if 0

HANDLE
WINAPI
CreateFileMappingX(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    )
{
    LPSTR lpszAName=NULL;
    HANDLE ret;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFileMapping\n");
    #endif

    lpszAName = Convert(lpName);

    if (lpszAName == ERR)
    {
        return 0;
    }

    ret = CreateFileMappingA(
        hFile,
        lpFileMappingAttributes,
        flProtect,
        dwMaximumSizeHigh,
        dwMaximumSizeLow,
        lpszAName);

    if(NULL != lpszAName)
        FREE( lpszAName);

    return ret;
}


HANDLE
WINAPI
OpenFileMappingX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    LPSTR lpszAName=NULL;
    HANDLE ret;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFileMapping\n");
    #endif

    lpszAName = Convert(lpName);

    if (lpszAName == ERR)
    {
        return 0;
    }

    ret = OpenFileMappingA(
        dwDesiredAccess,
        bInheritHandle,
        lpszAName);

    if(NULL != lpszAName)
        FREE( lpszAName);

    return ret;
}
#endif

DWORD_PTR
WINAPI
SHGetFileInfoX(
    LPCWSTR pszPath,
    DWORD dwFileAttributes,
    SHFILEINFOW FAR *psfi,
    UINT cbFileInfo,
    UINT uFlags)
{
DWORD_PTR dw = 0;

    LoadShell32Dll();

    if (g_fWideWrap_Unicode && g_pfShGetFileInfoW)
    {
        dw = g_pfShGetFileInfoW( pszPath,
                             dwFileAttributes,
                             psfi,
                             cbFileInfo,
                             uFlags );
        return dw;
    }

    if (NULL == g_pfShGetFileInfoA)
    {
   	Assert(g_pfShGetFileInfoA); // should always have the ansi export
        return 0;
    }

    XArray<CHAR> xszPath;
    BOOL fOk = ConvertWideCharToMultiByte( pszPath, xszPath, TRUE );
    if ( !fOk )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return 0;
    }

    SHFILEINFOA sfi;
    Assert(cbFileInfo == sizeof(SHFILEINFOW));
    Assert(psfi);

    memset(&sfi, 0, sizeof(sfi));
    dw = g_pfShGetFileInfoA( xszPath.Get(), dwFileAttributes, &sfi, sizeof(sfi), uFlags);

    if (dw)
    {
        psfi->hIcon = sfi.hIcon;
        psfi->iIcon = sfi.iIcon;
        psfi->dwAttributes = sfi.dwAttributes;

        XArray<WCHAR> xwszDisplay;
        fOk = ConvertMultiByteToWideChar( sfi.szDisplayName, xwszDisplay, TRUE );
        if ( !fOk )
        {

            SetLastError( ERROR_OUTOFMEMORY );
            return 0;
        }

        XArray<WCHAR> xwszType;
        fOk = ConvertMultiByteToWideChar( sfi.szTypeName, xwszType, TRUE );
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return 0;
        }

        if ( lstrlenX(xwszDisplay.Get()) < ARRAY_SIZE(psfi->szDisplayName)
             && lstrlenX(xwszType.Get()) < ARRAY_SIZE(psfi->szTypeName) )
        {
            lstrcpyX( psfi->szDisplayName, xwszDisplay.Get() );
            lstrcpyX( psfi->szTypeName, xwszType.Get() );

            return dw;
        }
        else
            return 0;
    }

    return 0;
}

HICON LoadIconX(
    HINSTANCE hInstance,
    LPCWSTR lpIconName
)
{
    Assert(0 == HIWORD(lpIconName)); // only support resource IDs

    return LoadIconA(hInstance,(LPSTR) lpIconName);
}


HCURSOR LoadCursorX(
    HINSTANCE hInstance,
    LPCWSTR lpCursorName
)
{
    Assert(0 == HIWORD(lpCursorName)); // only support resource IDs

    return LoadCursorA(hInstance,(LPSTR) lpCursorName);
}

HANDLE LoadImageX(
    HINSTANCE hinst,
    LPCWSTR lpszName,
    UINT uType,
    int cxDesired,
    int cyDesired,
    UINT fuLoad
)
{
HANDLE hReturn = NULL;

    if (g_fWideWrap_Unicode)
    {
        return LoadImageW(hinst,lpszName,uType,cxDesired,cyDesired,fuLoad);
    }
    else
    {
    XArray<CHAR> xszName;
    LPSTR pszNameA;
    BOOL fOk = TRUE;

        Assert(lpszName);

         if (0 == HIWORD(lpszName))
         {
            pszNameA = (LPSTR) lpszName;
         }
         else
         {

            fOk = ConvertWideCharToMultiByte(lpszName,xszName);

            if (!fOk)
            {
                SetLastError(E_OUTOFMEMORY);
                return NULL;
            }

            pszNameA = xszName.Get();
         }

        hReturn = LoadImageA(hinst,pszNameA,uType,cxDesired,cyDesired,fuLoad);
    }

    return hReturn;
}


HRSRC FindResourceX(
    HMODULE hModule,
    LPCWSTR lpName,
    LPCWSTR lpType
)
{
HRSRC hResult = NULL;

    if (g_fWideWrap_Unicode)
    {
        return FindResourceW(hModule,lpName,lpType);
    }
    else
    {
    XArray<CHAR> xszName;
    XArray<CHAR> xszType;
    LPSTR pszNameA,pszTypeA;
    BOOL fOkName = TRUE,fOkType = TRUE;

        Assert(lpType && lpName);

        // if hiword is zero it is an ID
        if (0 == HIWORD(lpName))
        {
            pszNameA = (LPSTR) lpName;
        }
        else
        {
            fOkName = ConvertWideCharToMultiByte(lpName,xszName);
        }

        if (0 == HIWORD(lpType))
        {
            pszTypeA = (LPSTR) lpType;
        }
        else
        {
            fOkType = ConvertWideCharToMultiByte(lpType,xszType);
        }

        if (!fOkName || !fOkType)
        {
            SetLastError(E_OUTOFMEMORY);
            return NULL;
        }

        hResult = FindResourceA(hModule,pszNameA,pszTypeA);
    }

    return hResult;
}


BOOL
WINAPI
Shell_NotifyIconX(
    DWORD dwMessage,
    PNOTIFYICONDATAW lpData)
{
BOOL fResult = FALSE;

    LoadShell32Dll();

    if (g_fWideWrap_Unicode && g_pfShell_NotifyIconW)
    {
        fResult = g_pfShell_NotifyIconW( dwMessage, lpData );
        return fResult;
    }

    if (NULL == g_pfShell_NotifyIconA)
    {
    	Assert(g_pfShell_NotifyIconA); // should always have the ansi export
        return FALSE;
    }

    NOTIFYICONDATAA DataA;
    DataA.cbSize = sizeof(NOTIFYICONDATAA);
    DataA.hWnd = lpData->hWnd;
    DataA.uID = lpData->uID;
    DataA.uFlags = lpData->uFlags;
    DataA.uCallbackMessage = lpData->uCallbackMessage;
    DataA.hIcon = lpData->hIcon;

    *DataA.szTip = '\0';

    if (DataA.uFlags & NIF_TIP)
    {
        XArray<CHAR> xszTip;
        BOOL fOk = ConvertWideCharToMultiByte( lpData->szTip, xszTip );
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

        ULONG ccLen = lstrlenA( xszTip.Get() );
        if ( ccLen >=  ARRAY_SIZE(DataA.szTip) )
            ccLen = ARRAY_SIZE(DataA.szTip) - 1;

        strncpy( DataA.szTip, xszTip.Get(), ccLen+1 );
    }

    fResult = g_pfShell_NotifyIconA(dwMessage,&DataA);

    return fResult;
}

// helper function for sending listview item messages
BOOL ListView_SendItemMessage(HWND hwnd,UINT MsgW,UINT MsgA,LV_ITEMW *pItem,
                              BOOL fInParam,BOOL fOutParam)
{
BOOL fReturn = FALSE;

    if (g_fWideWrap_Unicode /* ListView_GetUnicodeFormat(hwnd) */)
    {
         fReturn = (BOOL)SendMessageW((hwnd), MsgW, 0, (LPARAM)(LV_ITEMW FAR*)(pItem));
    }
    else
    {
    LV_ITEMA itemA;

        Assert(sizeof(LV_ITEMA) == sizeof(LV_ITEMW))

        memcpy(&itemA,pItem,sizeof(LV_ITEMA));

        DWORD dwOldSize = pItem->cchTextMax;
        BOOL fOk;
        XArray<CHAR> xszText;

        if ((itemA.mask & LVIF_TEXT) && (LPSTR_TEXTCALLBACKA != itemA.pszText))
        {
            itemA.pszText = NULL;

            if (fInParam)
            {
                fOk = ConvertWideCharToMultiByte( pItem->pszText, xszText );
                if ( !fOk )
                {
                    SetLastError( ERROR_OUTOFMEMORY );
                    return FALSE;
                }

                itemA.pszText = xszText.Get();
                itemA.cchTextMax = lstrlenA(itemA.pszText) + 1;
            }
            else
            {
                fOk = xszText.Init( itemA.cchTextMax );
                if ( !fOk )
                {
                    SetLastError( ERROR_OUTOFMEMORY );
                    return FALSE;
                }
                itemA.pszText = xszText.Get();
            }
        }

       if (itemA.pszText || !(itemA.mask & LVIF_TEXT) )
       {
           fReturn = (BOOL)SendMessageA((hwnd), MsgA, 0, (LPARAM)(LV_ITEMA FAR*)(&itemA));

           if (fOutParam && fReturn)
           {
           LPWSTR pszTextW = pItem->pszText;

                memcpy(pItem,&itemA,sizeof(LV_ITEMA));
                pItem->pszText = pszTextW;

                if ( (itemA.mask & LVIF_TEXT) )
                {
                    XArray<WCHAR> xwszTextOut;
                    fOk = ConvertMultiByteToWideChar( itemA.pszText, xwszTextOut );
                    if ( !fOk )
                    {
                        SetLastError( ERROR_OUTOFMEMORY );
                        return FALSE;
                    }

                    if ( lstrlenX(xwszTextOut.Get()) >= dwOldSize )
                         return FALSE;

                    lstrcpyX( pItem->pszText, xwszTextOut.Get() );
                }
           }
       }
    }

    return fReturn;
}

BOOL
ListView_GetItemX(
    HWND hwnd,
    LV_ITEM * pitem)
{
    return ListView_SendItemMessage(hwnd,LVM_GETITEMW,LVM_GETITEMA,pitem,FALSE,TRUE);
}

BOOL
ListView_SetItemX(
    HWND hwnd,
    LV_ITEM * pitem)
{
    return ListView_SendItemMessage(hwnd,LVM_SETITEMW,LVM_SETITEMA,pitem,TRUE,FALSE);
}

BOOL
ListView_InsertItemX(
    HWND hwnd,
    LV_ITEM * pitem)
{
    return ListView_SendItemMessage(hwnd,LVM_INSERTITEMW,LVM_INSERTITEMA,pitem,TRUE,FALSE);
}


// helper function for sending listview column messages
BOOL ListView_SendColumnMessage(HWND hwnd,int iCol,UINT MsgW,UINT MsgA,LV_COLUMN *pColumn,
                                BOOL fInParam,BOOL fOutParam,BOOL fReturnsIndex)
{
BOOL fReturn = FALSE;

    if (g_fWideWrap_Unicode /* ListView_GetUnicodeFormat(hwnd) */)
    {
         fReturn = (BOOL)SendMessageW((hwnd), MsgW, iCol, (LPARAM)(LV_COLUMNW FAR*)(pColumn));
    }
    else
    {
    LV_COLUMNA ColumnA;

        Assert(sizeof(LV_COLUMNA) == sizeof(LV_COLUMNW))

        memcpy(&ColumnA,pColumn,sizeof(LV_COLUMNA));
        ColumnA.pszText = NULL;

        DWORD dwOldSize = pColumn->cchTextMax;
        BOOL fOk;
        XArray<CHAR> xszText;

        if (ColumnA.mask & LVCF_TEXT)
        {

            if (fInParam)
            {
                fOk = ConvertWideCharToMultiByte( pColumn->pszText, xszText );
                if ( !fOk )
                {
                    SetLastError( ERROR_OUTOFMEMORY );
                    return FALSE;
                }

                ColumnA.pszText = xszText.Get();
                ColumnA.cchTextMax = lstrlenA(ColumnA.pszText) + 1;
            }
            else
            {
                fOk = xszText.Init( ColumnA.cchTextMax );
                if ( !fOk )
                {
                    SetLastError( ERROR_OUTOFMEMORY );
                    return FALSE;
                }
                ColumnA.pszText = xszText.Get();
            }
        }


       if (ColumnA.pszText || !(ColumnA.mask & LVCF_TEXT))
       {
           fReturn = (BOOL)SendMessageA((hwnd), MsgA,iCol, (LPARAM)(LV_COLUMNA FAR*)(&ColumnA));

           if ( ((fReturnsIndex && fReturn != -1)
                    || (fReturn && !fReturnsIndex)) && fOutParam)
           {
           LPWSTR pszTextW = pColumn->pszText;

                memcpy(pColumn,&ColumnA,sizeof(LV_COLUMNA));
                pColumn->pszText = pszTextW;

                if (ColumnA.mask & LVCF_TEXT)
                {
                    XArray<WCHAR> xwszTextOut;
                    fOk = ConvertMultiByteToWideChar( ColumnA.pszText, xwszTextOut );
                    if ( !fOk )
                    {
                        SetLastError( ERROR_OUTOFMEMORY );
                        return FALSE;
                    }

                    if ( lstrlenX(xwszTextOut.Get()) >= dwOldSize )
                        return FALSE;

                    lstrcpyX( pColumn->pszText, xwszTextOut.Get() );
                }
           }
       }

    }

    return fReturn;
}

BOOL
ListView_SetColumnX(
    HWND hwnd,
    int iCol,
    LV_COLUMN * pColumn)
{
    return ListView_SendColumnMessage(hwnd,iCol,LVM_SETCOLUMNW,LVM_SETCOLUMNA,pColumn,TRUE,FALSE,FALSE);
}

int
ListView_InsertColumnX(
    HWND hwnd,
    int iCol,
    LV_COLUMN * pColumn)
{
    return ListView_SendColumnMessage(hwnd,iCol,LVM_INSERTCOLUMNW,LVM_INSERTCOLUMNA,pColumn,TRUE,FALSE,TRUE);
}


HPROPSHEETPAGE
WINAPI CreatePropertySheetPageX(LPCPROPSHEETPAGEW ppsh)
{
HPROPSHEETPAGE fhReturn = NULL;

    if (g_fWideWrap_Unicode)
    {
        fhReturn = CreatePropertySheetPageW(ppsh);
    }
    else
    {
        // only support pages that don't have any strings to convert
        Assert(sizeof(LPCPROPSHEETPAGEW) == sizeof(LPCPROPSHEETPAGEA));
        Assert(0 == HIWORD(ppsh->pszTemplate));
        Assert(0 == HIWORD(ppsh->pszIcon));
        Assert(0 == HIWORD(ppsh->pszTitle));
        Assert(NULL == ppsh->pszHeaderTitle); // these aren't defined in _WIN32_IE < 0x0400
        Assert(NULL == ppsh->pszHeaderSubTitle);

        // since not strings can call Ansi version
        fhReturn = CreatePropertySheetPageA((LPCPROPSHEETPAGEA) ppsh);
    }

    return fhReturn;
}



INT_PTR
WINAPI PropertySheetX(
    LPCPROPSHEETHEADERW ppsh)
{
INT_PTR piReturn = -1;

    // don't support passing in an array or property sheet structures
    // or loading the icon
    Assert(!(ppsh->dwFlags & PSH_PROPSHEETPAGE));
    Assert(!(ppsh->dwFlags & PSH_USEICONID));

    if (g_fWideWrap_Unicode)
    {
        piReturn = PropertySheetW(ppsh);
    }
    else
    {
    PROPSHEETHEADERA pshA;

        Assert(sizeof(PROPSHEETHEADERA) == sizeof(PROPSHEETHEADERW));

        memcpy(&pshA,ppsh,sizeof(pshA));

        // if have a title an not a resource id allocate a string
        XArray<CHAR> xszCaption;
        if (0 != HIWORD(ppsh->pszCaption))
        {
            BOOL fOk = ConvertWideCharToMultiByte( ppsh->pszCaption, xszCaption );
            if ( !fOk )
            {
                SetLastError( ERROR_OUTOFMEMORY );
                return piReturn;
            }

            pshA.pszCaption = xszCaption.Get();
        }

        piReturn = PropertySheetA(&pshA);
    }

    return piReturn;
}

// helper function for sending listview column messages
BOOL ComboEx_SendComboMessage(
           HWND hwnd,UINT MsgW,UINT MsgA,
           PCCOMBOEXITEMW pComboExItemW,
           BOOL fInParam,BOOL fOutParam,BOOL fReturnsIndex)
{
BOOL fReturn = FALSE;

    if (g_fWideWrap_Unicode)
    {
         fReturn = (BOOL)SendMessageW((hwnd), MsgW, 0, (LPARAM) pComboExItemW);
    }
    else
    {
    COMBOBOXEXITEMA ComboExItemA;

        Assert(sizeof(COMBOBOXEXITEMA) == sizeof(COMBOBOXEXITEMW))

        memcpy(&ComboExItemA,pComboExItemW,sizeof(COMBOBOXEXITEMA));
        ComboExItemA.pszText = NULL;

        DWORD dwOldSize = pComboExItemW->cchTextMax;
        BOOL fOk;
        XArray<CHAR> xszText;

        if (ComboExItemA.mask & CBEIF_TEXT )
        {
            if (fInParam)
            {
                fOk = ConvertWideCharToMultiByte( pComboExItemW->pszText, xszText );
                if ( !fOk )
                {
                    SetLastError( ERROR_OUTOFMEMORY );
                    return FALSE;
                }

                ComboExItemA.pszText = xszText.Get();
                ComboExItemA.cchTextMax = lstrlenA(ComboExItemA.pszText) + 1;
            }
            else
            {
                fOk = xszText.Init( ComboExItemA.cchTextMax );
                if ( !fOk )
                {
                    SetLastError( ERROR_OUTOFMEMORY );
                    return FALSE;
                }
                ComboExItemA.pszText = xszText.Get();
            }
        }


       if (ComboExItemA.pszText || !(ComboExItemA.mask & CBEIF_TEXT ))
       {
           fReturn = (BOOL)SendMessageA((hwnd), MsgA, 0, (LPARAM) &ComboExItemA);

           if ( ((fReturnsIndex && fReturn != -1)
                    || (fReturn && !fReturnsIndex)) &&  fOutParam)
           {
           LPWSTR pszTextW = pComboExItemW->pszText;

                memcpy((void*) pComboExItemW,&ComboExItemA,sizeof(COMBOBOXEXITEMA));
                (LPWSTR) pComboExItemW->pszText = pszTextW;

                if (ComboExItemA.mask & CBEIF_TEXT )
                {
                    XArray<WCHAR> xwszTextOut;
                    fOk = ConvertMultiByteToWideChar( ComboExItemA.pszText, xwszTextOut );
                    if ( !fOk )
                    {
                        SetLastError( ERROR_OUTOFMEMORY );
                        return FALSE;
                    }

                    if ( lstrlenX(xwszTextOut.Get()) >= dwOldSize )
                        return FALSE;

                    lstrcpyX( pComboExItemW->pszText, xwszTextOut.Get() );

                }
           }
       }

    }

    return fReturn;
}

int ComboEx_InsertItemX(HWND hwnd,PCCOMBOEXITEMW pComboExItemW)
{
   return ComboEx_SendComboMessage(hwnd,CBEM_INSERTITEMW,CBEM_INSERTITEMA,
            pComboExItemW,TRUE,FALSE,TRUE);
}

BOOL ComboEx_GetItemX(HWND hwnd,PCCOMBOEXITEMW pComboExItemW)
{
    return ComboEx_SendComboMessage(hwnd,CBEM_GETITEMW,CBEM_GETITEMA,
            pComboExItemW,FALSE,TRUE,FALSE);

}

int TabCtrl_InsertItemX(HWND hwnd,int iItem,LPTCITEMW ptcItem)
{
int iReturn = -1;

    if (g_fWideWrap_Unicode)
    {
         iReturn = (int)SendMessage(hwnd,TCM_INSERTITEMW, (WPARAM)iItem,
                    (LPARAM) ptcItem);
    }
    else
    {
    TCITEMA tcItemA;
    XArray<CHAR> xszText;
    BOOL fOk;

        Assert(sizeof(TCITEMA) == sizeof(TCITEMW));

        memcpy(&tcItemA,ptcItem,sizeof(tcItemA));

        if (ptcItem->mask & TCIF_TEXT)
        {
            fOk = ConvertWideCharToMultiByte( ptcItem->pszText, xszText);
            if ( !fOk )
            {
                return -1;
            }

            tcItemA.pszText = xszText.Get();
        }

        iReturn = (int)SendMessage(hwnd,TCM_INSERTITEMA,(WPARAM)iItem,(LPARAM) &tcItemA);
    }


    return iReturn;
}

BOOL Animate_OpenX(HWND hwnd,LPWSTR szName)
{
    // only support resource IDs
    Assert(0 == HIWORD(szName));

    return (BOOL)SendMessage(hwnd,ACM_OPENA,0,(LPARAM) szName);
}



BOOL
DateTime_SetFormatX(
        HWND hwnd,
        LPCWSTR pszTimeFormat)
{
BOOL fReturn = FALSE;

    if (g_fWideWrap_Unicode)
    {
        return (BOOL)SendMessage(hwnd,DTM_SETFORMATW,0,(LPARAM) pszTimeFormat);
    }
    else
    {
    XArray<CHAR> xszTimeFormat;
    BOOL fOk;

        Assert(pszTimeFormat);

        fOk = ConvertWideCharToMultiByte(pszTimeFormat,xszTimeFormat);
        if (!fOk)
        {
            SetLastError(E_OUTOFMEMORY);
            return FALSE;
        }

        fReturn = (BOOL)SendMessage(hwnd,DTM_SETFORMATA,0,(LPARAM) xszTimeFormat.Get());
    }

    return fReturn;
}

int
WINAPI
GetDateFormatX(
    LCID             Locale,
    DWORD            dwFlags,
    CONST SYSTEMTIME *lpDate,
    LPCWSTR          lpFormat,
    LPWSTR          lpDateStr,
    int              cchDate)
{
int iReturn = 0;

    if (g_fWideWrap_Unicode)
    {
        return GetDateFormatW(Locale,dwFlags,lpDate,lpFormat,lpDateStr,cchDate);
    }
    else
    {
    XArray<CHAR> xszFormat;
    XArray<CHAR> xszDateStr;
    BOOL fOkFormat,fOkDateStr = TRUE;

        Assert(lpDateStr || cchDate == 0);

        fOkFormat = ConvertWideCharToMultiByte(lpFormat,xszFormat);

        if (cchDate)
        {
            fOkDateStr = xszDateStr.Init(cchDate);
        }

        if (!fOkFormat || !fOkDateStr)
        {
            SetLastError(E_OUTOFMEMORY);
            return FALSE;
        }

        iReturn = GetDateFormatA(Locale,dwFlags,lpDate,xszFormat.Get(),xszDateStr.Get(),cchDate);

        if (iReturn && cchDate)
        {
        XArray<WCHAR> xwszDateStr;
        BOOL fOk;

            fOk = ConvertMultiByteToWideChar(xszDateStr.Get(), xwszDateStr );

            if ( !fOk )
            {
                SetLastError( ERROR_OUTOFMEMORY );
                return 0;
            }

            int cwcLen = lstrlenX( xwszDateStr.Get() );
            if ( cwcLen >=  cchDate)
	    {
		SetLastError(ERROR_INSUFFICIENT_BUFFER);
		return 0;
	    }
	    else
	    {
		iReturn = cwcLen+1;
		lstrcpynX( lpDateStr, xwszDateStr.Get(),iReturn);
	    }
	}
    }

    return iReturn;
}


int
WINAPI
GetTimeFormatX(
    LCID             Locale,
    DWORD            dwFlags,
    CONST SYSTEMTIME *lpTime,
    LPCWSTR          lpFormat,
    LPWSTR          lpTimeStr,
    int              cchTime)
{
int iReturn = 0;

    if (g_fWideWrap_Unicode)
    {
        return GetTimeFormatW(Locale,dwFlags,lpTime,lpFormat,lpTimeStr,cchTime);
    }
    else
    {
    XArray<CHAR> xszFormat;
    XArray<CHAR> xszTimeStr;
    BOOL fOkFormat,fOkTimeStr = TRUE;

        Assert(lpTimeStr || cchTime == 0);

        fOkFormat = ConvertWideCharToMultiByte(lpFormat,xszFormat);

        if (cchTime)
        {
            fOkTimeStr = xszTimeStr.Init(cchTime);
        }

        if (!fOkFormat || !fOkTimeStr)
        {
            SetLastError(E_OUTOFMEMORY);
            return 0;
        }

        iReturn = GetTimeFormatA(Locale,dwFlags,lpTime,xszFormat.Get(),xszTimeStr.Get(),cchTime);

        if (iReturn && cchTime)
        {
        XArray<WCHAR> xwszTimeStr;
        BOOL fOk = ConvertMultiByteToWideChar(xszTimeStr.Get(), xwszTimeStr );

            if ( !fOk )
            {
                SetLastError( ERROR_OUTOFMEMORY );
                return 0;
            }

            int cwcLen = lstrlenX( xwszTimeStr.Get() );
            if ( cwcLen >=  cchTime)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                return 0;
            }

            iReturn = cwcLen + 1;
            lstrcpynX( lpTimeStr, xwszTimeStr.Get(),iReturn);
        }
    }

    return iReturn;
}




int DrawTextX(
    HDC hDC,
    LPCWSTR lpString,
    int nCount,
    LPRECT lpRect,
    UINT uFormat
)
{
int iReturn = 0;

    if (g_fWideWrap_Unicode)
    {
        iReturn = DrawTextW(hDC,lpString,nCount,lpRect,uFormat);
    }
    else
    {
        XArray<CHAR> xszString;
        BOOL fOk = ConvertWideCharToMultiByte( lpString, xszString );
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return 0;
        }

        nCount = lstrlenA(xszString.Get());

        iReturn = DrawTextA(hDC,xszString.Get(),nCount,lpRect,uFormat);
    }

    return iReturn;
}

HWND
WINAPI
FindWindowExX(
    HWND hwndParent,
    HWND hwndChildAfter,
    LPCWSTR lpszClass,
    LPCWSTR lpszWindow
)
{
HWND hwnd = NULL;

    if (g_fWideWrap_Unicode)
    {
        hwnd = FindWindowExW(hwndParent,hwndChildAfter,lpszClass,
                            lpszWindow);
    }
    else
    {
        LPSTR lpszWindowA;
        XArray<CHAR> xszWindow;

        if ( lpszWindow )
        {
            BOOL fOk = ConvertWideCharToMultiByte( lpszWindow, xszWindow );
            if ( !fOk )
            {
                SetLastError( ERROR_OUTOFMEMORY );
                return NULL;
            }
            lpszWindowA = xszWindow.Get();
        }
        else
            lpszWindowA = NULL;

        LPSTR lpszClassA = NULL;
        LPSTR ClassArg = NULL;
        XArray<CHAR> xszClass;

        if (0 != HIWORD(lpszClass))
        {
            BOOL fOk = ConvertWideCharToMultiByte( lpszClass, xszClass );
            if ( !fOk )
            {
                SetLastError( ERROR_OUTOFMEMORY );
                return NULL;
            }
            ClassArg = lpszClassA = xszClass.Get();
        }
        else
        {
            ClassArg = (LPSTR) lpszClass;
        }

        hwnd = FindWindowExA(hwndParent,hwndChildAfter,ClassArg,
                            lpszWindowA);
    }

    return hwnd;

}

HWND
WINAPI
FindWindowX(
    IN LPCWSTR lpszClass,
    IN LPCWSTR lpszWindow)
{
HWND hwnd = NULL;

    if (g_fWideWrap_Unicode)
    {
        hwnd = FindWindowW(lpszClass,lpszWindow);
    }
    else
    {
        LPSTR lpszWindowA;
        XArray<CHAR> xszWindow;

        if ( lpszWindow )
        {
            BOOL fOk = ConvertWideCharToMultiByte( lpszWindow, xszWindow );
            if ( !fOk )
            {
                SetLastError( ERROR_OUTOFMEMORY );
                return NULL;
            }
            lpszWindowA = xszWindow.Get();
        }
        else
            lpszWindowA = NULL;

        LPSTR lpszClassA = NULL;
        LPSTR ClassArg = NULL;
        XArray<CHAR> xszClass;

        if (0 != HIWORD(lpszClass))
        {
            BOOL fOk = ConvertWideCharToMultiByte( lpszClass, xszClass );
            if ( !fOk )
            {
                SetLastError( ERROR_OUTOFMEMORY );
                return NULL;
            }
            ClassArg = lpszClassA = xszClass.Get();
        }
        else
        {
            ClassArg = (LPSTR) lpszClass;
        }

        hwnd = FindWindowA(ClassArg,lpszWindowA);
    }

    return hwnd;

}

BOOL SetWindowTextX(
    HWND hWnd,
    LPCWSTR lpString
)
{
BOOL fReturn = FALSE;

    Assert(lpString);

    if (g_fWideWrap_Unicode)
    {
        fReturn = SetWindowTextW(hWnd,lpString);
    }
    else
    {
        XArray<CHAR> xszString;
        BOOL fOk = ConvertWideCharToMultiByte( lpString, xszString );
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

        // !!! This function turns around and calls WM_SETTEXT which doesn't
        // have a A and W version so if have a misatch between what the
        // window expects and us sending Ansi garbage will appear.
        fReturn = SetWindowTextA(hWnd,xszString.Get());
    }

    return fReturn;
}


int ListBox_AddStringX(
    HWND hWnd,
    LPCWSTR lpString
)
{
    int iReturn;

    Assert(lpString);

    if (g_fWideWrap_Unicode)
    {
        iReturn = (int)SendMessageW(hWnd,LB_ADDSTRING, 0L, (LPARAM)(LPCTSTR)(lpString));
    }
    else
    {
        XArray<CHAR> xszString;
        BOOL fOk = ConvertWideCharToMultiByte( lpString, xszString );
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }

        // !!! This function turns around and sends LB_ADDSTRING which doesn't
        // have a A and W version so if have a misatch between what the
        // window expects and us sending Ansi garbage will appear. 
        iReturn = (int)SendMessageA(hWnd,LB_ADDSTRING, 0L, (LPARAM)(LPCSTR)(xszString.Get()));
    }

    return iReturn;
}

int GetWindowTextX(
    HWND hWnd,
    LPTSTR lpString,
    int nMaxCount
)
{
int iReturn = 0;

    Assert(lpString && (nMaxCount > 0));

    if (g_fWideWrap_Unicode)
    {
        iReturn = GetWindowTextW(hWnd,lpString,nMaxCount);
    }
    else
    {
        int nMaxCountA = nMaxCount;

        XArray<CHAR> xszString;
        BOOL fOk = xszString.Init( nMaxCountA );
        if ( !fOk )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return 0;
        }

        LPSTR lpStringA =  xszString.Get();

        if (lpStringA)
        {
            *lpString = NULL;
            iReturn = GetWindowTextA(hWnd,lpStringA,nMaxCountA);

            if (iReturn)
            {
                XArray<WCHAR> xwszStringOut;
                BOOL fOk = ConvertMultiByteToWideChar( lpStringA, xwszStringOut );
                if ( !fOk )
                {
                    SetLastError( ERROR_OUTOFMEMORY );
                    return 0;
                }

                int cwcLen = lstrlenX( xwszStringOut.Get() );
                if ( cwcLen >=  nMaxCount )
                    cwcLen = nMaxCount - 1;

                iReturn = cwcLen + 1;
                lstrcpynX( lpString, xwszStringOut.Get(),iReturn);
            }
        }
    }

    return iReturn;
}


BOOL
WINAPI
WinHelpX(
    HWND hWndMain,
    LPCWSTR lpszHelp,
    UINT uCommand,
    ULONG_PTR dwData
    )
{

    if (g_fWideWrap_Unicode)
    {
        WinHelpW(hWndMain,lpszHelp,uCommand,dwData);
    }
    else
    {
        LPSTR lpszHelpA = NULL;
        XArray<CHAR> xszHelp;

        if (lpszHelp)
        {
            BOOL fOk = ConvertWideCharToMultiByte( lpszHelp, xszHelp );
            if ( !fOk )
            {
                SetLastError( ERROR_OUTOFMEMORY );
                return FALSE;
            }
            lpszHelpA = xszHelp.Get();
        }

        if (lpszHelpA || (NULL == lpszHelp))
        {
            WinHelpA(hWndMain,lpszHelpA,uCommand,dwData);
        }
    }

    return FALSE;
}

HFONT
WINAPI
CreateFontIndirectX(
        CONST LOGFONTW *pLogFontW)
{
HFONT hfReturn = NULL;

    if (g_fWideWrap_Unicode)
    {
        return CreateFontIndirectW(pLogFontW);
    }
    else
    {
    LOGFONTA LogFontA;
    XArray<CHAR> xszLogFont;
    BOOL fOk = ConvertWideCharToMultiByte( pLogFontW->lfFaceName, xszLogFont);
    int cchFontA;

        // all items in the logFont structure up
        // until the lfFaceName are the same
        memcpy(&LogFontA,pLogFontW,sizeof(LogFontA));

        if (!fOk)
        {
            return NULL;
        }

        cchFontA = lstrlenA(xszLogFont.Get());
        if (cchFontA >= LF_FACESIZE)
        {
            return NULL;
        }

        strncpy(LogFontA.lfFaceName,xszLogFont.Get(),cchFontA + 1);

        hfReturn = CreateFontIndirectA(&LogFontA);

    }

    return hfReturn;
}

DWORD
WINAPI
FormatMessageX(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
    )
{
DWORD dwReturn = 0;

    // we don't support arguments
    Assert(NULL == Arguments);
    Assert(lpBuffer);

    if (Arguments || (NULL == lpBuffer))
    {
        return 0;
    }

    if (g_fWideWrap_Unicode)
    {
        return  FormatMessageW(dwFlags,lpSource,dwMessageId,dwLanguageId,
                        lpBuffer,nSize,Arguments);
    }
    else
    {
    XArray<CHAR> xszBuffer;
    BOOL fOk = xszBuffer.Init(nSize);

        if (!fOk)
        {
            return 0;
        }

        dwReturn = FormatMessageA(dwFlags,lpSource,dwMessageId,dwLanguageId,
                                xszBuffer.Get(),nSize,Arguments);

        if (dwReturn)
        {
        XArray<WCHAR> xwszStringOut;
        BOOL fOk = ConvertMultiByteToWideChar(xszBuffer.Get(), xwszStringOut );

            *lpBuffer = NULL;

            if ( !fOk )
            {
                SetLastError( ERROR_OUTOFMEMORY );
                return 0;
            }

                        // if buffer isn't big enough fail
            int cwcLen = lstrlenX( xwszStringOut.Get() );
            if ( cwcLen >=  (int) nSize )
            {
                    return 0;
            }

            dwReturn = cwcLen + 1;
            lstrcpynX( lpBuffer, xwszStringOut.Get(),dwReturn);
        }

    }

    return dwReturn;
}

// code stolen from base\process.cp
BOOL
WINAPI
IsBadStringPtrX(
    LPCWSTR lpsz,
    UINT cchMax
    )
{
LPCWSTR EndAddress;
LPCWSTR StartAddress;
WCHAR c;

    // If the structure has zero length, then do not probe the structure for
    // read accessibility.
    if (cchMax != 0)
    {
        if (lpsz == NULL)
        {
            return TRUE;
        }

        StartAddress = lpsz;
        EndAddress = (LPCWSTR)((PSZ)StartAddress + (cchMax*2) - 2);

        __try
        {
            c = *(WCHAR *)StartAddress;
            while ( c && StartAddress != EndAddress )
            {
                StartAddress++;
                c = *(WCHAR *)StartAddress;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return TRUE;
        }
    }

    return FALSE;
}



BOOL
APIENTRY
GetTextExtentPointX(
    HDC hdc,
    LPCWSTR lpszStr,
    int cchString, // specifies length of in param string.
    LPSIZE lpSize
    )
{
BOOL fReturn = FALSE;

    if (g_fWideWrap_Unicode)
    {
        return GetTextExtentPointW(hdc,lpszStr,cchString,lpSize);
    }
    else
    {
    XArray<CHAR> xsStr;
    int cchStringA;
    BOOL fOk;

        Assert(lpszStr && (cchString > 0));

        // verify cchString is the stringLength or
        // the calculation of cchStringA will not be accurate.
        Assert(cchString == (int) lstrlenX(lpszStr));

        fOk = ConvertWideCharToMultiByte(lpszStr,xsStr);

        if (!fOk)
        {
            SetLastError(E_OUTOFMEMORY);
            return FALSE;
        }

        cchStringA = lstrlenA(xsStr.Get());

        fReturn = GetTextExtentPointA(hdc,xsStr.Get(),cchStringA,lpSize);

    }

    return fReturn;
}



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\alloc.h ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#ifndef _SAMPLEALLOC_
#define _SAMPLEALLOC_

inline void* __cdecl operator new (size_t size);
inline void __cdecl operator delete(void FAR* lpv);


LPVOID ALLOC(ULONG cb);
void FREE(void* pv);
LPVOID REALLOC(void *pv,ULONG cb); 

#ifdef _DEBUG

#define MEMINITVALUE 0xff
#define MEMFREEVALUE 0xfe

#endif // DEBUG


#endif // _SAMPLEALLOC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\alloc.cpp ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#include "precomp.h"

//+-------------------------------------------------------------------
//
//  Function:    ::operator new
//
//  Synopsis:   Our operator new implementation
//
//  Arguments:  [size] -- Size of memory to allocate
//
//
//  Notes:
//
//--------------------------------------------------------------------

inline void* __cdecl operator new (size_t size)
{
    return(ALLOC(size));
}


//+-------------------------------------------------------------------
//
//  Function:    ::operator delete
//
//  Synopsis:   Our operator deleteimplementation
//
//  Arguments:  lpv-- Pointer to memory to free
//
//
//  Notes:
//
//--------------------------------------------------------------------

inline void __cdecl operator delete(void FAR* lpv)
{
    FREE(lpv);
}


//+---------------------------------------------------------------------------
//
//  function:   ALLOC, public
//
//  Synopsis:   memory allocator
//
//  Arguments:  [cb] - requested size of memory to alloc.
//
//  Returns:    Pointer to newly allocated memory, NULL on failure
//
//  Modifies:
//
//----------------------------------------------------------------------------

LPVOID ALLOC(ULONG cb)
{
void *pv;

    pv = LocalAlloc(LMEM_FIXED,cb);

#ifdef _DEBUG
    if (NULL != pv) // under debug always initialize to -1 to catch unitialize errors.
    {
        memset(pv,MEMINITVALUE,cb);
    }
#endif // _DEBUG

    return pv;
}


//+---------------------------------------------------------------------------
//
//  function:   FREE, public
//
//  Synopsis:   memory destructor
//
//  Arguments:  [pv] - pointer to memory to be released.
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------


void FREE(void* pv)
{
#ifdef _DEBUG
    if (NULL != pv) // under debug always initialize to -1 to catch unitialize errors.
    {
    UINT cb;

        Assert(LMEM_INVALID_HANDLE != LocalFlags(pv));

        cb = LocalSize(pv); // returns zero on failure
        memset(pv,MEMFREEVALUE,cb);
    }

    Assert(pv);

#endif // _DEBUG

    LocalFree(pv);
}


//+---------------------------------------------------------------------------
//
//  function:   REALLOC, public
//
//  Synopsis:   reallocs memory
//
//  Arguments:  [pv] - pointer to memory to be released.
//              [cb] - size to resize the memory to.
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LPVOID REALLOC(void *pv,ULONG cb)
{

    Assert(pv);

    pv =  LocalReAlloc(pv,cb,LMEM_MOVEABLE);

    return pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\cfact.cpp ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#include "precomp.h"

//
// Global variables
//

EXTERN_C const GUID CLSID_SyncMgrHandler;

extern UINT      g_cRefThisDll;    // Reference count of this DLL.
extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.


//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::CClassFactory, public
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

CClassFactory::CClassFactory()
{
    m_cRef = 0L;

    g_cRefThisDll++;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::~CClassFactory, public
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

CClassFactory::~CClassFactory()
{
    g_cRefThisDll--;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::QueryInterface public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid,
                                                   LPVOID FAR *ppv)
{
    *ppv = NULL;

    // Any interface on this object is the object pointer
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;

        AddRef();

        return NOERROR;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::AddRef, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::Release, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (--m_cRef)
        return m_cRef;

    delete this;

    return 0L;
}


//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::CreateInstance, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                                      REFIID riid,
                                                      LPVOID *ppvObj)
{
HRESULT hr = NOERROR;

    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    LPSYNCMGRSYNCHRONIZE pSyncMgrHandler = new CSyncMgrHandler();

    if (NULL == pSyncMgrHandler)
        return E_OUTOFMEMORY;

    hr =  pSyncMgrHandler->QueryInterface(riid, ppvObj);
    pSyncMgrHandler->Release(); // remove our reference.

    return hr;

}


//+---------------------------------------------------------------------------
//
//  Member:     CClassFactory::LockServer, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
       ++g_cRefThisDll;
    }
    else
    {
       --g_cRefThisDll;
    }

    return NOERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\debug.cpp ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#include "precomp.h"


//+---------------------------------------------------------------------------
//
//  Function:   FnAssert, public
//
//  Synopsis:   Displays the Assert dialog
//
//  Arguments:  [lpstrExptr] - Expression
//      [lpstrMsg] - Msg, if any, to append to the Expression
//      [lpstrFilename] - File Assert Occured in
//      [iLine] - Line Number of Assert
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//
//----------------------------------------------------------------------------

#if DBG == 1

STDAPI FnAssert( LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine )
{
int iResult;
char lpTemp[] = "";
char lpBuffer[512];
char lpLocBuffer[256];


    if (NULL == lpstrMsg)
        lpstrMsg = lpTemp;

    wsprintfA(lpBuffer, "Assertion \"%s\" failed! %s", lpstrExpr, lpstrMsg);
    wsprintfA(lpLocBuffer, "File %s, line %d; (A=exit; R=break; I=continue)",
             lpstrFileName, iLine);
    iResult = MessageBoxA(NULL, lpLocBuffer, lpBuffer,
                         MB_ABORTRETRYIGNORE | MB_SYSTEMMODAL);

    if (iResult == IDRETRY)
    {
        DebugBreak();
    }
    else if (iResult == IDABORT)
    {
        FatalAppExitA(0, "Assertion failure");
    }
    return NOERROR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\debug.h ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#ifndef _SAMPLEDEBUG_
#define _SAMPLEDEBUG_


#if (DBG == 1)
#undef DEBUG
#undef _DEBUG

#define DEBUG 1
#define _DEBUG 1

#endif // DGB
#if DEBUG

STDAPI FnAssert( LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine );

#undef Assert
#undef AssertSz
#undef Puts
#undef TRACE

#define Assert(a) { if (!(a)) FnAssert(#a, NULL, __FILE__, __LINE__); }
#define AssertSz(a, b) { if (!(a)) FnAssert(#a, b, __FILE__, __LINE__); }
#define Puts(s) OutputDebugStringA(s)
#define TRACE(s)  OutputDebugStringA(s)

#else // !DEBUG

#define Assert(a)
#define AssertSz(a, b)
#define Puts(s)
#define TRACE(s)

#endif  // DEBUG


#endif // _SAMPLEDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\critsect.cpp ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#include "precomp.h"

//+---------------------------------------------------------------------------
//
//  Member:     CLockHandler::CLockHandler, public
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

CLockHandler::CLockHandler()
{
    m_dwLockThreadId = 0;
    InitializeCriticalSection(&m_CriticalSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLockHandler::~CLockHandler, public
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

CLockHandler::~CLockHandler()
{
    Assert (0 == m_dwLockThreadId);
    DeleteCriticalSection(&m_CriticalSection);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLockHandler::Lock, public
//
//  Synopsis:   Adds a lock to the specified class
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CLockHandler::Lock(DWORD dwThreadId)
{
    EnterCriticalSection(&m_CriticalSection);

    m_dwLockThreadId = dwThreadId;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLockHandler::UnLock, public
//
//  Synopsis:   Removes a lock to the specified class
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CLockHandler::UnLock()
{
    m_dwLockThreadId = 0;
    LeaveCriticalSection(&m_CriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\cfact.h ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#ifndef _SYNCHNDLR_H
#define _SYNCHNDLR_H

class CClassFactory : public IClassFactory
{
protected:
    ULONG   m_cRef;

public:
    CClassFactory();
    ~CClassFactory();

    //IUnknown members
    STDMETHODIMP        QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    //IClassFactory members
    STDMETHODIMP        CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP        LockServer(BOOL);

};
typedef CClassFactory *LPCClassFactory;


#endif // _SYNCHNDLR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\critsect.h ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------


#ifndef _CRITSECT_
#define _CRITSECT_

class CLock;

class CCriticalSection
{
DWORD cRefs;
CRITICAL_SECTION *m_pcsect;
DWORD m_dwThreadID;

public:
    inline CCriticalSection(CRITICAL_SECTION *pcsect,DWORD dwThreadID)
    {
    m_pcsect = pcsect;
    cRefs = 0;
    m_dwThreadID = dwThreadID;
    };


    inline ~CCriticalSection()
    {
    AssertSz(0 == cRefs,"UnReleased Critical Section");
    Assert(m_dwThreadID == GetCurrentThreadId());

    while(cRefs--) // unwind any left over cRefs
    {
        LeaveCriticalSection(m_pcsect);
    }

    };

    inline void Enter()
    {
    EnterCriticalSection(m_pcsect);

    Assert(m_dwThreadID == GetCurrentThreadId());
    ++cRefs;

    Assert(1 == cRefs); // we don't allow nested calls.
    };

    inline void Leave()
    {
    Assert(m_dwThreadID == GetCurrentThreadId());
    Assert(0 < cRefs);

    if (0 >= cRefs)
        return;

    --cRefs;
    Assert(0 == cRefs);

    LeaveCriticalSection(m_pcsect);
    };

};


class CLockHandler {

public:
    CLockHandler();
    ~CLockHandler();

    void Lock(DWORD dwThreadId);
    void UnLock();
    inline DWORD GetLockThreadId() { return m_dwLockThreadId; };

private:
    CRITICAL_SECTION m_CriticalSection; // critical section for the queue.
    DWORD m_dwLockThreadId; // thread that has the lock.

    friend CLock;
};


// helper class for making sure locks on the queue are released.
class CLock
{
DWORD cRefs;
CLockHandler *m_pLockHandler;
DWORD m_dwThreadID;

public:
    inline CLock(CLockHandler *pLockHandler)
    {
    m_pLockHandler = pLockHandler;
    cRefs = 0;
    m_dwThreadID = GetCurrentThreadId();
    };


    inline ~CLock()
    {
    AssertSz(0 == cRefs,"UnReleased Lock");
    Assert(m_dwThreadID == GetCurrentThreadId());

    while(cRefs--) // unwind any left over cRefs
    {
        m_pLockHandler->UnLock();
    }

    };

    inline void Enter()
    {
    Assert(m_dwThreadID == GetCurrentThreadId());

    ++cRefs;
    Assert(1 == cRefs); // we don't allow nested calls.
    m_pLockHandler->Lock(m_dwThreadID);
    };

    inline void Leave()
    {
    Assert(m_dwThreadID == GetCurrentThreadId());
    Assert(0 < cRefs);

    if (0 >= cRefs)
        return;

    --cRefs;
    Assert(0 == cRefs);
    m_pLockHandler->UnLock();

    };

};

#define ASSERT_LOCKHELD(pLockHandler) Assert(pLockHandler->GetLockThreadId() == GetCurrentThreadId());
#define ASSERT_LOCKNOTHELD(pLockHandler) Assert(pLockHandler->GetLockThreadId() == 0);

#endif // _CRITSECT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\dllmain.cpp ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#include "precomp.h"

// if writing own handler need to change CLSID value in guid.h
EXTERN_C const GUID CLSID_SyncMgrHandler;

TCHAR szCLSIDDescription[] = TEXT("Sample Synchronization Manager Handler");
WCHAR wszCLSIDDescription[] = L"Sample Synchronization Handler Handler";

//
// Global variables
//

UINT      g_cRefThisDll = 0;    // Reference count of this DLL.
HINSTANCE g_hmodThisDll = NULL; // Handle to this DLL itself.
CSettings *g_pSettings = NULL;  // ptr to global settings class.

//+---------------------------------------------------------------------------
//
//  Function:     DllMain, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // Extension DLL one-time initialization
        g_hmodThisDll = hInstance;

        g_pSettings = new CSettings;
        if (NULL == g_pSettings)
        {
            return FALSE;
        }

        //initialize the common controls for property sheets
    INITCOMMONCONTROLSEX controlsEx;
    controlsEx.dwSize = sizeof(INITCOMMONCONTROLSEX);
    controlsEx.dwICC = ICC_USEREX_CLASSES | ICC_WIN95_CLASSES;
    InitCommonControlsEx(&controlsEx);

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    DWORD cRefs;
    CSettings *pSettings = g_pSettings;  // ptr to global settings class.

        g_pSettings = NULL;
        Assert(0 == g_cRefThisDll);

        if (pSettings)
        {
            cRefs = pSettings->Release();
            Assert(0 == cRefs);
        }

    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:     DllRegisterServer, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDAPI DllRegisterServer(void)
{
HRESULT  hr = NOERROR;
#ifndef _UNICODE
WCHAR   wszID[GUID_SIZE+1];
#endif // !_UNICODE
TCHAR    szID[GUID_SIZE+1];
TCHAR    szCLSID[GUID_SIZE+1];
TCHAR    szModulePath[MAX_PATH];

  // Obtain the path to this module's executable file for later use.
  GetModuleFileName(
    g_hmodThisDll,
    szModulePath,
    sizeof(szModulePath)/sizeof(TCHAR));

  /*-------------------------------------------------------------------------
    Create registry entries for the DllSndBall Component.
  -------------------------------------------------------------------------*/
  // Create some base key strings.
#ifdef _UNICODE
  StringFromGUID2(CLSID_SyncMgrHandler, szID, GUID_SIZE);
#else
  BOOL fUsedDefaultChar;

  StringFromGUID2(CLSID_SyncMgrHandler, wszID, GUID_SIZE);

  WideCharToMultiByte(CP_ACP ,0,
    wszID,-1,szID,GUID_SIZE + 1,
    NULL,&fUsedDefaultChar);

#endif // _UNICODE

  lstrcpy(szCLSID, TEXT("CLSID\\"));
  lstrcat(szCLSID, szID);

  // Create entries under CLSID.

  SetRegKeyValue(HKEY_CLASSES_ROOT,
    szCLSID,
    NULL,
    szCLSIDDescription);

  SetRegKeyValue(HKEY_CLASSES_ROOT,
    szCLSID,
    TEXT("InProcServer32"),
    szModulePath);

  AddRegNamedValue(
    szCLSID,
    TEXT("InProcServer32"),
    TEXT("ThreadingModel"),
    TEXT("Apartment"));

  // register with SyncMgr
    LPSYNCMGRREGISTER lpSyncMgrRegister;

    hr = CoCreateInstance(CLSID_SyncMgr,NULL,CLSCTX_SERVER,IID_ISyncMgrRegister,
                                            (LPVOID *) &lpSyncMgrRegister);

    if (SUCCEEDED(hr))
    {
        hr = lpSyncMgrRegister->RegisterSyncMgrHandler(CLSID_SyncMgrHandler,
            wszCLSIDDescription,0 /* dwSyncMgrRegisterFlags */);

        AssertSz(SUCCEEDED(hr),"Registration Failed");

        lpSyncMgrRegister->Release();
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:     DllUnregisterServer, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDAPI DllUnregisterServer(void)
{
HRESULT hr;

  // UnRegister with SyncMgr
    LPSYNCMGRREGISTER lpSyncMgrRegister;

    hr = CoCreateInstance(CLSID_SyncMgr,NULL,CLSCTX_SERVER,IID_ISyncMgrRegister,
                                            (LPVOID *) &lpSyncMgrRegister);

    if (SUCCEEDED(hr))
    {
        hr = lpSyncMgrRegister->UnregisterSyncMgrHandler(CLSID_SyncMgrHandler,0);
        lpSyncMgrRegister->Release();
    }

    return hr;




}

//+---------------------------------------------------------------------------
//
//  Function:     DllCanUnloadNow, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDAPI DllCanUnloadNow(void)
{
    return (g_cRefThisDll == 0) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:     DllGetClassObject, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvOut)
{
    *ppvOut = NULL;

    if (IsEqualIID(rclsid, CLSID_SyncMgrHandler))
    {
        CClassFactory *pcf = new CClassFactory;

        return pcf->QueryInterface(riid, ppvOut);
    }

    return CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\dllmain.h ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#ifndef _DLLMAIN_
#define _DLLMAIN_

STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);
STDAPI DllCanUnloadNow(void);
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvOut);

#endif // _DLLMAIN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\guid.c ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#pragma data_seg(".text")
#define INITGUID
#include <objbase.h>
#include <initguid.h>

#include <mobsync.h>
#include "guid.h"


#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\enum.h ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

// header file for handler specific items

#ifndef _ENUMERATOR_CLASS_
#define _ENUMERATOR_CLASS_

// structure for keeping track of items as a whole

typedef struct  _tagGENERICITEM
{
    DWORD cbSize;   // total size of item (this structure + whatever caller needs for data)
    _tagGENERICITEM *pNextGenericItem;

}  GENERICITEM;

typedef GENERICITEM *LPGENERICITEM;

typedef struct  _tagGENERICITEMLIST
{
    DWORD _cRefs;               // reference count on this structure
    DWORD dwNumItems;           // number of items in  array.
    LPGENERICITEM pFirstGenericItem;       // ptr to first Item in linked list
} GENERICITEMLIST;

typedef GENERICITEMLIST *LPGENERICITEMLIST;


class CGenericEnum
{
public:
    DWORD m_cRef;
    DWORD m_cOffset;
    LPGENERICITEMLIST m_pGenericItemList; // array of items
    LPGENERICITEM m_pNextItem;

public:
    CGenericEnum(LPGENERICITEMLIST  pGenericItemList,DWORD cOffset);
    ~CGenericEnum();
        virtual void DeleteThisObject()  = 0;

    //IUnknown members
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

        STDMETHODIMP Next(ULONG celt,LPGENERICITEM rgelt,ULONG *pceltFetched);
        STDMETHODIMP Clone(CGenericEnum **ppenum);

        STDMETHODIMP Skip(ULONG celt);
        STDMETHODIMP Reset();
};


// helper functions for managing list.
DWORD AddRef_ItemList(LPGENERICITEMLIST pGenericItemList);
DWORD Release_ItemList(LPGENERICITEMLIST pGenericItemList);
LPGENERICITEMLIST CreateItemList();
LPGENERICITEMLIST DuplicateItemList(LPGENERICITEMLIST pItemList);
LPGENERICITEM AddNewItemToList(LPGENERICITEMLIST lpGenericList,ULONG cbSize);
BOOL AddItemToList(LPGENERICITEMLIST lpGenericList,LPGENERICITEM pGenericItem);
BOOL DeleteItemFromList(LPGENERICITEMLIST lpGenericList,LPGENERICITEM pGenericItem);
LPGENERICITEM CreateNewListItem(ULONG cbSize);


#endif // #define _ENUMERATOR_CLASS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\enum.cpp ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------


#include "precomp.h"

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.

//+---------------------------------------------------------------------------
//
//  Member:     CGenericEnum::CGenericEnum, public
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

CGenericEnum::CGenericEnum(LPGENERICITEMLIST pGenericItemList,DWORD cOffset)
{
DWORD dwItemIndex;
m_cRef                   = 1;   // give the intial reference
m_pGenericItemList   = pGenericItemList;
m_cOffset                = cOffset;

    AddRef_ItemList(m_pGenericItemList); // increment our hold on shared memory.

    // set the current item to point to next record.
    m_pNextItem = m_pGenericItemList->pFirstGenericItem;
    dwItemIndex = cOffset;

    // this is a bug if this happens so assert in final.
    if (dwItemIndex > m_pGenericItemList->dwNumItems)
        dwItemIndex = 0;

    // move the nextItem pointer to the proper position
    while(dwItemIndex--)
    {
    m_pNextItem = m_pNextItem->pNextGenericItem;
    ++m_cOffset;

    if (NULL == m_pNextItem)
        break; // Again, another error.
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericEnum::~CGenericEnum, public
//
//  Synopsis:   Destructor.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

CGenericEnum::~CGenericEnum()
{
    Release_ItemList(m_pGenericItemList); // decrement our hold on shared memory.
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericEnum::QueryInterface, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CGenericEnum::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericEnum::Addref, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CGenericEnum::AddRef()
{
    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericEnum::Release, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CGenericEnum::Release()
{
    if (--m_cRef)
        return m_cRef;

    DeleteThisObject();

    return 0L;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericEnum::Next, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CGenericEnum::Next(ULONG celt, LPGENERICITEM rgelt,ULONG *pceltFetched)
{
HRESULT hr = NOERROR;
ULONG ulFetchCount = celt;
ULONG ulNumFetched = 0;
LPGENERICITEM pGenericItem;

    if ( (m_cOffset + celt) > m_pGenericItemList->dwNumItems)
    {
    ulFetchCount = m_pGenericItemList->dwNumItems - m_cOffset;
    hr = S_FALSE;
    }

    pGenericItem = rgelt;

    while (ulFetchCount--)
    {
    *pGenericItem = *(m_pNextItem->pNextGenericItem);
    m_pNextItem = m_pNextItem->pNextGenericItem; // add error checking
    ++m_cOffset;
        ++ulNumFetched;
    ++pGenericItem;
    }

    if (pceltFetched)
    {
        *pceltFetched = ulNumFetched;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericEnum::Skip, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CGenericEnum::Skip(ULONG celt)
{
HRESULT hr;

    if ( (m_cOffset + celt) > m_pGenericItemList->dwNumItems)
    {
    m_cOffset = m_pGenericItemList->dwNumItems;
    m_pNextItem = NULL;
    hr = S_FALSE;
    }
    else
    {
    while (celt--)
    {
        ++m_cOffset;
        m_pNextItem = m_pNextItem->pNextGenericItem;
    }

    hr = NOERROR;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericEnum::Reset, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CGenericEnum::Reset()
{
    m_pNextItem = m_pGenericItemList->pFirstGenericItem;
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericEnum::Clone, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CGenericEnum::Clone(CGenericEnum **ppenum)
{
    return E_NOTIMPL;
}


// help functions for managing enum list
// helper functions for managing the Generics list.
// properly increments and destroys shared Genericlist in memory.


//+---------------------------------------------------------------------------
//
//  Function:     AddRef_ItemList, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

DWORD AddRef_ItemList(LPGENERICITEMLIST pGenericItemList)
{
    return ++pGenericItemList->_cRefs;
}

//+---------------------------------------------------------------------------
//
//  Function:     Release_ItemList, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

DWORD Release_ItemList(LPGENERICITEMLIST pGenericItemList)
{
DWORD cRefs;

    // bug, not threadsafe
    cRefs = --pGenericItemList->_cRefs;

    if (0 == pGenericItemList->_cRefs)
    {
    LPGENERICITEM pCurItem = pGenericItemList->pFirstGenericItem;

        while(pCurItem)
        {
        LPGENERICITEM pFreeItem = pCurItem;

            pCurItem = pCurItem->pNextGenericItem;
            FREE(pFreeItem);
        }

    FREE(pGenericItemList);
    }

    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Function:     CreateItemList, public
//
//  Synopsis: create an new list and initialize it to nothing
//            and set the refcount to 1.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LPGENERICITEMLIST CreateItemList()
{
LPGENERICITEMLIST lpGenericList = (LPGENERICITEMLIST) ALLOC(sizeof(GENERICITEMLIST));

    if (lpGenericList)
    {
    memset(lpGenericList,0,sizeof(GENERICITEMLIST));
    AddRef_ItemList(lpGenericList);
    }

    return lpGenericList;
}

//+---------------------------------------------------------------------------
//
//  Function:     DuplicateList, public
//
//  Synopsis:   Duplicates the list
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LPGENERICITEMLIST DuplicateItemList(LPGENERICITEMLIST pItemList)
{
LPGENERICITEMLIST lpNewItemList;
LPGENERICITEM pCurItem;

    lpNewItemList = CreateItemList();
    if (!lpNewItemList)
    {
        return NULL;
    }

    pCurItem = pItemList->pFirstGenericItem;

    while (pCurItem)
    {
    LPGENERICITEM pNewItemInList;

        Assert(pCurItem->cbSize >= sizeof(GENERICITEM));

        pNewItemInList = CreateNewListItem(pCurItem->cbSize);

        if (pNewItemInList)
        {
            memcpy(pNewItemInList,pCurItem,pCurItem->cbSize);
            pNewItemInList->pNextGenericItem = NULL;
            AddItemToList(lpNewItemList,pNewItemInList);
        }

        pCurItem = pCurItem->pNextGenericItem;
    }

    return lpNewItemList;
}


//+---------------------------------------------------------------------------
//
//  Function:     AddNewItemToList, public
//
//  Synopsis: allocates space for a new item and adds it to the list,
//      if successfull returns pointer to new item so caller can initialize it.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LPGENERICITEM AddNewItemToList(LPGENERICITEMLIST lpGenericList,ULONG cbSize)
{
LPGENERICITEM pNewGenericItem;

    pNewGenericItem = CreateNewListItem(cbSize);

    if (pNewGenericItem)
    {
        if (!AddItemToList(lpGenericList,pNewGenericItem))
        {
            FREE(pNewGenericItem);
            pNewGenericItem = NULL;
        }
    }

    return pNewGenericItem;
}


//+---------------------------------------------------------------------------
//
//  Function:     AddItemToList, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL AddItemToList(LPGENERICITEMLIST lpGenericList,LPGENERICITEM pNewGenericItem)
{
LPGENERICITEM pGenericItem;

    if (!pNewGenericItem || !lpGenericList)
    {
        Assert(lpGenericList);
        Assert(pNewGenericItem);
        return FALSE;
    }

    if (pNewGenericItem)
    {
        Assert(pNewGenericItem->cbSize >= sizeof(GENERICITEM));

        pGenericItem = lpGenericList->pFirstGenericItem;

        if (NULL == pGenericItem)
        {
            lpGenericList->pFirstGenericItem = pNewGenericItem;
        }
        else
        {
            while (pGenericItem->pNextGenericItem)
                pGenericItem = pGenericItem->pNextGenericItem;

            pGenericItem->pNextGenericItem = pNewGenericItem;

        }

    ++lpGenericList->dwNumItems;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:     DeleteItemFromList, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL DeleteItemFromList(LPGENERICITEMLIST lpGenericList,LPGENERICITEM pGenericItem)
{

    if (!pGenericItem || !lpGenericList)
    {
        Assert(lpGenericList);
        Assert(pGenericItem);
        return FALSE;
    }

    if (pGenericItem)
    {
    LPGENERICITEM pCurItem;
    GENERICITEM  GenericItemTempHead;

        Assert(pGenericItem->cbSize >= sizeof(GENERICITEM));

        GenericItemTempHead.pNextGenericItem = lpGenericList->pFirstGenericItem;
        pCurItem = &GenericItemTempHead;


        while(pCurItem->pNextGenericItem)
        {

            if (pCurItem->pNextGenericItem == pGenericItem)
            {

                pCurItem->pNextGenericItem = pGenericItem->pNextGenericItem;
                FREE(pGenericItem);


                // update the head
                lpGenericList->pFirstGenericItem = GenericItemTempHead.pNextGenericItem;

                // update the number of items in the list
                --lpGenericList->dwNumItems;

                return TRUE;
            }

            pCurItem = pCurItem->pNextGenericItem;
        }

    }

    AssertSz(0,"Didn't find item in List");
    return FALSE; // didn't find anything.
}

//+---------------------------------------------------------------------------
//
//  Function:     CreateNewListItem, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LPGENERICITEM CreateNewListItem(ULONG cbSize)
{
LPGENERICITEM pNewGenericItem;

    // size must be at least size of the base generic item.
    if (cbSize < sizeof(GENERICITEM))
    return NULL;

     pNewGenericItem = (LPGENERICITEM) ALLOC(cbSize);

    // add item to the end of the list so if commit we do
    // it in the same order items were added.

    if (pNewGenericItem)
    {
    // initialize to zero, and then add it to the list.
    memset(pNewGenericItem,0,cbSize);
        pNewGenericItem->cbSize = cbSize;
    }

    return pNewGenericItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\guid.h ===
#ifndef _GUIDDECL_
#define _GUIDDECL_

// DEFINE A NEW CLSID FOR EACH HANDLER
// {97484BA5-26C7-11d1-9A39-0020AFDA97B0}

DEFINE_GUID(CLSID_SyncMgrHandler,0x97484ba5, 0x26c7, 0x11d1, 0x9a, 0x39, 0x0, 0x20, 0xaf, 0xda, 0x97, 0xb0);

#endif _GUIDDECL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\handler.h ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#ifndef _HANDER_IMPL_
#define _HANDER_IMPL_

// itemList used  keeping track of items to sync.
typedef struct  _tagHANDLERITEM_SYNCSTATUS
{
    GENERICITEM  genericItem;
    SYNCMGRITEMID ItemID;
    BOOL fCancelled; // set if cancel comes in after called to PrePrepareForSync.
    BOOL fSynchronizing; // set when actually performing a sync.
    BOOL fSynchronizeComplete; // set when actually performing a sync.
    BOOL fUnresolvedConflicts; // conflict occured during sync and were not resolved
    DWORD dwSyncMgrResultStatus; // result of sync on item.
}  HANDLERITEM_SYNCSTATUS;
typedef HANDLERITEM_SYNCSTATUS *LPHANDLERITEM_SYNCSTATUS;


// file object used to keep track of items.
typedef struct  _tagFILEOBJECT
{
    GENERICITEM  genericItem;
    TCHAR fName[MAX_PATH];
    BOOL fDirectory;
    BOOL fLastUpdateValid;
    FILETIME ftLastUpdate;
    LPGENERICITEMLIST pChildList;
}  FILEOBJECT;
typedef FILEOBJECT *LPFILEOBJECT;

typedef GENERICITEMLIST FILEOBJECTLIST;
typedef LPGENERICITEMLIST LPFILEOBJECTLIST;

class CSyncMgrHandler :  public  ISyncMgrSynchronize, public CLockHandler
{
private:
    DWORD   m_dwSyncFlags;
    DWORD m_cRef;
    LPSYNCMGRSYNCHRONIZECALLBACK m_pSyncMgrSynchronizeCallback;
        LPGENERICITEMLIST m_pItemsToSyncList;
        HANDLE m_phThread;  // handle to worker thread
        HWND m_hwndWorker;        // hwnd of WorkerThread hwnd.
        HWND m_hwndHandler;     // hwnd of window on same thread as handler.
        BOOL m_fSynchronizing; // flag set when actually synchronizing data.
        BOOL m_fPrepareForSync; // flag set when actually synchronizing data.
        BOOL m_fStopped; // indicates if a StopSetItemStatus has come in.

public:
        CSyncMgrHandler();
    ~CSyncMgrHandler();

        /* IUnknown */

        STDMETHODIMP        QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

        /* ISyncMgrSynchronize methods */
    STDMETHODIMP    Initialize(DWORD dwReserved,DWORD dwSyncFlags,
                    DWORD cbCookie,const BYTE *lpCooke);
    STDMETHODIMP    GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);

    STDMETHODIMP    EnumSyncMgrItems(ISyncMgrEnumItems **ppenumOffineItems);
    STDMETHODIMP    GetItemObject(REFSYNCMGRITEMID ItemID,REFIID riid,void** ppv);
    STDMETHODIMP    ShowProperties(HWND hWndParent,REFSYNCMGRITEMID ItemID);
    STDMETHODIMP    SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack);
    STDMETHODIMP    PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID* pItemIDs,HWND hWndParent,
                    DWORD dwReserved);
    STDMETHODIMP    Synchronize(HWND hWndParent);
    STDMETHODIMP    SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus);
    STDMETHODIMP    ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID);

        // methods called on worker thread.
    void ShowPropertiesCall(HWND hWndParent,REFSYNCMGRITEMID ItemID);
    void PrepareForSyncCall(ULONG cbNumItems,SYNCMGRITEMID* pItemIDs,HWND hWndParent,
                    DWORD dwReserved);
    void SynchronizeCall(HWND hWndParent);
    void ShowErrorCall(HWND hWndParent,REFSYNCMGRERRORID ErrorID);

private:
        STDMETHODIMP CreateWorkerThread();
        LPSYNCMGRSYNCHRONIZECALLBACK GetProgressCallback();
        void Progress(ISyncMgrSynchronizeCallback *lpCallBack,REFSYNCMGRITEMID pItemID,
                                UINT mask,TCHAR *pStatusText,DWORD dwStatusType,
                                int iProgValue,int iMaxValue);
        void ProgressSetItemStatusType(ISyncMgrSynchronizeCallback *lpCallBack,
                                    REFSYNCMGRITEMID pItemID,DWORD dwSyncMgrStatus);
        void ProgressSetItemStatusText(ISyncMgrSynchronizeCallback *lpCallBack,
                                    REFSYNCMGRITEMID pItemID,TCHAR *pStatusText);
        void ProgressSetItemProgValue(ISyncMgrSynchronizeCallback *lpCallBack,
                                    REFSYNCMGRITEMID pItemID,int iProgValue);
        void ProgressSetItemProgMaxValue(ISyncMgrSynchronizeCallback *lpCallBack,
                                    REFSYNCMGRITEMID pItemID,int iProgMaxValue);

        void LogError(ISyncMgrSynchronizeCallback *lpCallBack,REFSYNCMGRITEMID pItemID,
                      DWORD dwErrorLevel,TCHAR *lpErrorText,DWORD mask,DWORD dwSyncMgrErrorFlags,
                      SYNCMGRERRORID ErrorID);
        void LogError(ISyncMgrSynchronizeCallback *lpCallBack,REFSYNCMGRITEMID pItemID,
                      DWORD dwErrorLevel,TCHAR *lpErrorText);
        void LogError(ISyncMgrSynchronizeCallback *lpCallBack,
                      DWORD dwErrorLevel,TCHAR *lpErrorText);

        // helper methods specific to this handler.
        LPFILEOBJECTLIST CreateDirFileListFromPath(TCHAR *pDirName,BOOL fRecursive);
        LPFILEOBJECTLIST GetFilesForDir(TCHAR *pDirName,BOOL fRecursive);
        void ReleaseFileObjectList(LPFILEOBJECTLIST pfObjList,BOOL fRecursive);
        ULONG CountNumberOfFilesInList(LPFILEOBJECTLIST pfObjList,BOOL fRecursive);
        LPFILEOBJECT FindFileItemWithName(LPFILEOBJECTLIST pDir,TCHAR *pfName);
        BOOL CopyFileFullPath(TCHAR *pszFile1,TCHAR *pszFile2);
        void CopyFiles( LPHANDLERITEM_SYNCSTATUS pHandlerItemID,
                                LPHANDLERITEMSETTINGS pHandlerSyncItem,
                                LPSYNCMGRSYNCHRONIZECALLBACK pCallback,
                                DWORD *pdwCurProgValue,TCHAR *pszDir1,LPFILEOBJECTLIST pDir1,
                                TCHAR *pszDir2);
        void ReconcileDir(HWND hWndParent,LPHANDLERITEM_SYNCSTATUS pHandlerItemID,
                                LPHANDLERITEMSETTINGS pHandlerSyncItem,
                                LPSYNCMGRSYNCHRONIZECALLBACK pCallback,
                                DWORD *pdwCurProgValue,
                                TCHAR *pszDir1,LPFILEOBJECTLIST pDir1,
                                TCHAR *pszDir2,LPFILEOBJECTLIST pDir2);
        void SyncDirs(HWND hWndParent,LPHANDLERITEM_SYNCSTATUS pHandlerItemID,
                                LPHANDLERITEMSETTINGS pHandlerSyncItem);

friend LRESULT CALLBACK  HandlerThreadWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
};


// wrapper object for Callback so can send any callback messges back to
// the main thread we were created on to conform to COM standards
class CCallbackWrapper: public ISyncMgrSynchronizeCallback
{
public:
    CCallbackWrapper(HWND hwndCallback);
    ~CCallbackWrapper();

    //IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    // Callback methods.
    STDMETHODIMP Progress(REFSYNCMGRITEMID ItemID,LPSYNCMGRPROGRESSITEM lpSyncProgressItem);
    STDMETHODIMP PrepareForSyncCompleted(HRESULT hr);
    STDMETHODIMP SynchronizeCompleted(HRESULT hr);
    STDMETHODIMP ShowPropertiesCompleted(HRESULT hr);
    STDMETHODIMP ShowErrorCompleted(HRESULT hr,ULONG cbNumItems,SYNCMGRITEMID *pItemIDs);

    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP LogError(DWORD dwErrorLevel,const WCHAR *lpcErrorText,LPSYNCMGRLOGERRORINFO lpSyncLogError);
    STDMETHODIMP DeleteLogError(REFSYNCMGRERRORID ErrorID,DWORD dwReserved);
    STDMETHODIMP EstablishConnection( WCHAR const * lpwszConnection, DWORD dwReserved);
private:

    ULONG m_cRef;
    HWND  m_hwndCallback;
};




// CSyncMgrHandler creates a worker thread in ::Initialize to use for async syncmgrCalls.
// the following are delclarations for the worker thread.

// structure passed in CreateThread.
typedef struct _tagWorkerThreadArgs
{
/* [in ]  */ HANDLE hEvent; // Event to wait on for new thread to be created.
/* [in ]  */ CSyncMgrHandler *pThis; // point to class worker thread for
/* [out]  */  HWND hwnd;  // on return code of NOERROR contains workerThread hwnd.
/* [out]  */  HRESULT hr; // return code of thread.
}  WorkerThreadArgs;

DWORD WINAPI WorkerThread( LPVOID lpArg );

// structures and Wnd messages for posting to Worker Threads hwnd.
typedef struct _tagPREPAREFORSYNCMSG
{
ULONG cbNumItems;
HWND hWndParent;
DWORD dwReserved;
SYNCMGRITEMID* pItemIDs;
} PREPAREFORSYNCMSG;

typedef struct _tagSYNCHRONIZEMSG
{
HWND hWndParent;
} SYNCHRONIZEMSG;

typedef struct _tagSHOWPROPERTIESMSG
{
HWND hWndParent;
SYNCMGRITEMID ItemID;
} SHOWPROPERTIESMSG;

typedef struct _tagSHOWERRORMSG
{
HWND hWndParent;
SYNCMGRERRORID ErrorID;
} SHOWERRORMSG;

typedef struct _tagPROGRESSMSG
{
SYNCMGRITEMID ItemID;
LPSYNCMGRPROGRESSITEM lpSyncProgressItem;
} PROGRESSMSG;

typedef struct _tagPREPAREFORSYNCCOMPLETEDMSG
{
HRESULT hr;
} PREPAREFORSYNCCOMPLETEDMSG;

typedef struct _tagSYNCHRONIZECOMPLETEDMSG
{
HRESULT hr;
} SYNCHRONIZECOMPLETEDMSG;

typedef struct _tagSHOWPROPERTIESCOMPLETEDMSG
{
HRESULT hr;
} SHOWPROPERTIESCOMPLETEDMSG;

typedef struct _tagSHOWERRORCOMPLETEDMSG
{
HRESULT hr;
ULONG cbNumItems;
SYNCMGRITEMID *pItemIDs;
} SHOWERRORCOMPLETEDMSG;

typedef struct _tagENABLEMODELESSMSG
{
BOOL fEnable;
} ENABLEMODELESSMSG;

typedef struct _tagLOGERRORMSG
{
DWORD dwErrorLevel;
const WCHAR *lpcErrorText;
LPSYNCMGRLOGERRORINFO lpSyncLogError;
} LOGERRORMSG;


typedef struct _tagDELETELOGERRORMSG
{
SYNCMGRERRORID ErrorID;
DWORD dwReserved;
} DELETELOGERRORMSG;

typedef struct _tagESTABLISHCONNECTIONMSG
{
WCHAR const * lpwszConnection;
DWORD dwReserved;
} ESTABLISHCONNECTIONMSG;

typedef struct _tagMETHODARGS
{
    DWORD dwWorkerMsg;
    BOOL fAsync; // indicates this is an async call.
    HRESULT hr; // only valid for synchronouse calls
    union
    {
        PREPAREFORSYNCMSG PrepareForSyncMsg;
        SYNCHRONIZEMSG SynchronizeMsg;
        SHOWPROPERTIESMSG ShowPropertiesMsg;
        SHOWERRORMSG ShowErrorMsg;

        PROGRESSMSG ProgressMsg;
        PREPAREFORSYNCCOMPLETEDMSG PrepareForSyncCompletedMsg;
        SYNCHRONIZECOMPLETEDMSG SynchronizeCompletedMsg;
        SHOWPROPERTIESCOMPLETEDMSG ShowPropertiesCompletedMsg;
        SHOWERRORCOMPLETEDMSG ShowErrorCompletedMsg;
        ENABLEMODELESSMSG EnableModelessMsg;
        LOGERRORMSG LogErrorMsg;
        DELETELOGERRORMSG DeleteLogErrorMsg;
        ESTABLISHCONNECTIONMSG EstablishConnectionMsg;
    };
} METHODARGS; // list of possible member for calling ThreadWndProc

// definitions for handler messages
#define WM_WORKERMSG_SHOWPROPERTIES (WM_USER+1)
#define WM_WORKERMSG_PREPFORSYNC (WM_USER+2)
#define WM_WORKERMSG_SYNCHRONIZE  (WM_USER+3)
#define WM_WORKERMSG_SHOWERROR (WM_USER+4)
#define WM_WORKERMSG_RELEASE  (WM_USER+5)

// worker messages for Callback wrapper
#define WM_WORKERMSG_PROGRESS                   (WM_USER+20)
#define WM_WORKERMSG_PREPAREFORSYNCCOMPLETED     (WM_USER+21)
#define WM_WORKERMSG_SYNCHRONIZECOMPLETED       (WM_USER+22)
#define WM_WORKERMSG_SHOWPROPERTIESCOMPLETED    (WM_USER+23)
#define WM_WORKERMSG_SHOWERRORCOMPLETED         (WM_USER+24)
#define WM_WORKERMSG_ENABLEMODELESS             (WM_USER+25)
#define WM_WORKERMSG_LOGERROR                   (WM_USER+26)
#define WM_WORKERMSG_DELETELOGERROR             (WM_USER+27)
#define WM_WORKERMSG_ESTABLISHCONNECTION        (WM_USER+28)

#define DWL_THREADWNDPROCCLASS 0 // window long offset to MsgService Hwnd this ptr.

#define SZ_SAMPLESYNCMGRHANDLERWNDCLASS TEXT("Sample SyncMgr HandlerThread hwnd")
#define SZ_SAMPLESYNCMGRWORKERWNDCLASS TEXT("Sample SyncMgr WorkThread hwnd")

LRESULT CALLBACK  HandlerThreadWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
LRESULT CALLBACK  WorkerThreadWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
BOOL RegisterHandlerWndClasses(void);

#endif // #define _HANDER_IMPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\handler.cpp ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#include "precomp.h"

extern UINT      g_cRefThisDll;    // Reference count of this DLL.
extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.
extern CSettings *g_pSettings;  // ptr to global settings class.

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::CSyncMgrHandler, public
//
//  Synopsis:   Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

CSyncMgrHandler::CSyncMgrHandler()
{
    g_cRefThisDll++;

    m_cRef = 1;
    m_phThread = NULL;
    m_pSyncMgrSynchronizeCallback = NULL;
    m_pItemsToSyncList = NULL;
    m_dwSyncFlags = 0;
    m_hwndWorker = FALSE;
    m_hwndHandler = FALSE;
    m_fSynchronizing = FALSE;
    m_fPrepareForSync = FALSE;
    m_fStopped = FALSE;

}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::~CSyncMgrHandler, public
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

CSyncMgrHandler::~CSyncMgrHandler()
{
    Assert(NULL == m_pSyncMgrSynchronizeCallback);

    Assert(NULL == m_pItemsToSyncList);


    if (m_phThread)
    {
    HANDLE hThread = m_phThread;

        m_phThread = NULL;

        PostMessage(m_hwndWorker,WM_WORKERMSG_RELEASE,0,0);

        WaitForSingleObject(hThread,INFINITE); // wait for thread to go away
        CloseHandle(hThread);
    }

    if (m_hwndHandler)
    {
        DestroyWindow(m_hwndHandler);
        m_hwndHandler = NULL;
    }

    g_cRefThisDll--;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::QueryInteface, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSyncMgrHandler::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPUNKNOWN)this;
    }
    else if (IsEqualIID(riid, IID_ISyncMgrSynchronize))
    {
        *ppv = (LPSYNCMGRSYNCHRONIZE)this;
    }
    if (*ppv)
    {
        AddRef();

        return NOERROR;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::AddRef, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSyncMgrHandler::AddRef()
{
    return ++m_cRef;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::Release, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSyncMgrHandler::Release()
{
    if (--m_cRef)
        return m_cRef;

   delete this;

   return 0L;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::Initialize, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSyncMgrHandler::Initialize(DWORD dwReserved,DWORD dwSyncFlags,
                    DWORD cbCookie,const BYTE *lpCooke)
{
HRESULT hr = NOERROR;

    m_dwSyncFlags = dwSyncFlags;

    RegisterHandlerWndClasses();

    // create hwnd for main class.
    m_hwndHandler = CreateWindowEx(0,
              SZ_SAMPLESYNCMGRHANDLERWNDCLASS,
              TEXT(""),
              // must use WS_POPUP so the window does not get
              // assigned a hot key by user.
              (WS_DISABLED | WS_POPUP),
              CW_USEDEFAULT,
              CW_USEDEFAULT,
              CW_USEDEFAULT,
              CW_USEDEFAULT,
              NULL,
              NULL,
              g_hmodThisDll,
              this);

    if (NULL == m_hwndHandler)
    {
        hr =  E_UNEXPECTED;
    }


    if (NOERROR == hr)
    {
        hr = CreateWorkerThread();
    }

    // if hr is not NOERROR then clean up.
    if (NOERROR != hr)
    {
        if (m_phThread)
        {
        HANDLE hThread = m_phThread;

            m_phThread = NULL;

            PostMessage(m_hwndWorker,WM_WORKERMSG_RELEASE,0,0);

            WaitForSingleObject(hThread,INFINITE); // wait for thread to go away
            CloseHandle(hThread);
        }

        if (m_hwndHandler)
        {
            DestroyWindow(m_hwndHandler);
            m_hwndHandler = NULL;
        }

    }


    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::CreateWorkerThread, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

HRESULT CSyncMgrHandler::CreateWorkerThread()
{
HRESULT hr = E_FAIL;
HANDLE hNewThread = NULL;
DWORD dwThreadID;
WorkerThreadArgs ThreadArgs;


    ThreadArgs.hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    ThreadArgs.pThis = this;

    if (ThreadArgs.hEvent)
    {
    hNewThread = CreateThread(NULL,0,WorkerThread,&ThreadArgs,0,&dwThreadID);

    if (hNewThread)
    {
       WaitForSingleObject(ThreadArgs.hEvent,INFINITE);
       if (NOERROR == ThreadArgs.hr)
       {
                m_hwndWorker = ThreadArgs.hwnd;
                m_phThread = hNewThread;
        hr = NOERROR;
       }
       else
       {
        CloseHandle(hNewThread);
        hr = ThreadArgs.hr;
       }

    }
    else
    {
        hr = GetLastError();
    }

    CloseHandle(ThreadArgs.hEvent);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::GetHandlerInfo, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSyncMgrHandler::GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{
LPSYNCMGRHANDLERINFO pSyncInfo;

    if (!ppSyncMgrHandlerInfo)
    {
        Assert(ppSyncMgrHandlerInfo)
        return E_INVALIDARG;
    }

    pSyncInfo = (LPSYNCMGRHANDLERINFO) CoTaskMemAlloc(sizeof(SYNCMGRHANDLERINFO));

    if (pSyncInfo)
    {
        pSyncInfo->cbSize = sizeof(SYNCMGRHANDLERINFO);
        pSyncInfo->hIcon = LoadIcon(g_hmodThisDll,MAKEINTRESOURCE(IDI_SAMPLEHANDLERICON));
        pSyncInfo->SyncMgrHandlerFlags = SYNCMGRHANDLER_HASPROPERTIES;
        pSyncInfo->SyncMgrHandlerFlags |= SYNCMGRHANDLER_ALWAYSLISTHANDLER;
        lstrcpyW(pSyncInfo->wszHandlerName,L"Sample Handler");
    }

    *ppSyncMgrHandlerInfo = pSyncInfo;

    return *ppSyncMgrHandlerInfo ? NOERROR : E_OUTOFMEMORY;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::GetItemObject, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSyncMgrHandler::GetItemObject(REFSYNCMGRITEMID ItemID,REFIID riid,void** ppv)
{

    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::EnumSyncMgrItems, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSyncMgrHandler::EnumSyncMgrItems(ISyncMgrEnumItems** ppenumOffineItems)
{

    Assert(g_pSettings);

    if (g_pSettings)
    {
        return g_pSettings->EnumSyncMgrItems(ppenumOffineItems);
    }

    return E_UNEXPECTED;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::ShowProperties, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSyncMgrHandler::ShowProperties(HWND hWndParent,REFSYNCMGRITEMID ItemID)
{
METHODARGS *pMethodArgs;

    pMethodArgs = (METHODARGS*) ALLOC(sizeof(METHODARGS));

    if (NULL == pMethodArgs)
    {
        Assert(pMethodArgs);
        return E_OUTOFMEMORY;
    }

    pMethodArgs->fAsync = TRUE;
    pMethodArgs->dwWorkerMsg = WM_WORKERMSG_SHOWPROPERTIES;
    pMethodArgs->ShowPropertiesMsg.hWndParent = hWndParent;
    pMethodArgs->ShowPropertiesMsg.ItemID = ItemID;

    PostMessage(m_hwndWorker,WM_WORKERMSG_SHOWPROPERTIES,0,(LPARAM) pMethodArgs);

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::ShowPropertiesCall, private
//
//  Synopsis:   Called on WorkerThread
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::ShowPropertiesCall(HWND hWndParent,REFSYNCMGRITEMID ItemID)
{
LPSYNCMGRSYNCHRONIZECALLBACK pCallback = GetProgressCallback();
HRESULT hr = NOERROR;

    Assert(g_pSettings);

    if (g_pSettings)
    {
        hr = g_pSettings->ShowProperties(hWndParent,ItemID);
    }

    if (pCallback)
    {
        pCallback->ShowPropertiesCompleted(hr);
        pCallback->Release();
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::SetProgressCallback, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSyncMgrHandler::SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack)
{
LPSYNCMGRSYNCHRONIZECALLBACK pCallbackCurrent;
CLock clock(this);

    clock.Enter();

    pCallbackCurrent = m_pSyncMgrSynchronizeCallback;

    m_pSyncMgrSynchronizeCallback = lpCallBack;

    if (m_pSyncMgrSynchronizeCallback)
        m_pSyncMgrSynchronizeCallback->AddRef();

    if (pCallbackCurrent)
        pCallbackCurrent->Release();


    clock.Leave();

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::GetProgressCallback, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LPSYNCMGRSYNCHRONIZECALLBACK CSyncMgrHandler::GetProgressCallback()
{
#ifdef _USECURRENTTHREADFORCALLBACK
LPSYNCMGRSYNCHRONIZECALLBACK pCallback;
CLock clock(this);

    clock.Enter();

    pCallback = m_pSyncMgrSynchronizeCallback;

    if (pCallback)
    {
        pCallback->AddRef();
    }


    clock.Leave();

    return pCallback;
#else
    return new CCallbackWrapper(m_hwndHandler);
#endif

}


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::PrepareForSync, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSyncMgrHandler::PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID *pItemIDs,
                            HWND hWndParent,DWORD dwReserved)

{
METHODARGS *pMethodArgs;
SYNCMGRITEMID *pItemIdCopy;
LPSYNCMGRSYNCHRONIZECALLBACK pCallback = GetProgressCallback();
CLock clock(this);

    if (!pCallback)
    {
        Assert(pCallback);
        return E_UNEXPECTED;
    }

    pMethodArgs = (METHODARGS*) ALLOC(sizeof(METHODARGS));
    pItemIdCopy = (SYNCMGRITEMID *) ALLOC(sizeof(SYNCMGRITEMID) * cbNumItems);

    // create items list before kicking off async call so can handle case
    // skip and stop come in before PrepareForSyncCall is handled.

    clock.Enter();

    m_fStopped = FALSE; // always reset stop on a new PrepareForSync, (for example retry came in)
    m_fPrepareForSync = TRUE;

    Assert(NULL == m_pItemsToSyncList);
    m_pItemsToSyncList = CreateItemList();

     // lookup and request a lock on the items to synchronize
    // we then place the ones that we found and have permission into our
    // own private sync queue.

    if (g_pSettings && m_pItemsToSyncList)
    {
    ULONG ulIndex;
    SYNCMGRITEMID *pCurItemID;

        pCurItemID = pItemIDs;

        for (ulIndex = 0 ; ulIndex < cbNumItems; ++ulIndex)
        {
        BOOL fAdded = FALSE;;

            if (g_pSettings->RequestItemLock(this,*pCurItemID))
            {
            LPHANDLERITEM_SYNCSTATUS pNewItem;

                pNewItem = (LPHANDLERITEM_SYNCSTATUS) AddNewItemToList(m_pItemsToSyncList,sizeof(HANDLERITEM_SYNCSTATUS));

                if (pNewItem)
                {
                    pNewItem->ItemID = *pCurItemID;
                    fAdded = TRUE;
                }
                else
                {
                    // not enough memory to allocate itemList,
                    LogError(pCallback,(*pCurItemID),SYNCMGRLOGLEVEL_ERROR,
                                    TEXT("Not Enough Memory to Synchronize"));

                    // update progress for this item
                    ProgressSetItemStatusType(pCallback,(*pCurItemID),SYNCMGRSTATUS_FAILED);
                }

            }


            if (!fAdded)
            {
                // if another instance already syncing set progress
                // to complete since done but don't update statustext
                // so we dont' stomp the running instance.

                Progress(pCallback,(*pCurItemID),
                    SYNCMGRPROGRESSITEM_PROGVALUE | SYNCMGRPROGRESSITEM_MAXVALUE,
                    NULL,0,100,100);
            }


            ++pCurItemID;
        }
    }


    if (NULL == pMethodArgs || NULL == pItemIdCopy || NULL == m_pItemsToSyncList)
    {
        Assert(pMethodArgs);
        Assert(pItemIdCopy);

        if (pMethodArgs)
        {
            FREE(pMethodArgs);
        }

        if (pItemIdCopy)
        {
            FREE(pItemIdCopy);
        }

        if (m_pItemsToSyncList)
        {
            if (0 == Release_ItemList(m_pItemsToSyncList))
            {
                m_pItemsToSyncList = NULL;
            }
        }

        clock.Leave();

        pCallback->Release();
        m_fPrepareForSync = FALSE;

        return E_OUTOFMEMORY;
    }

    clock.Leave();

    // now make the async call
    pMethodArgs->fAsync = TRUE;
    pMethodArgs->dwWorkerMsg = WM_WORKERMSG_PREPFORSYNC;
    pMethodArgs->PrepareForSyncMsg.cbNumItems = cbNumItems;
    pMethodArgs->PrepareForSyncMsg.hWndParent = hWndParent;
    pMethodArgs->PrepareForSyncMsg.dwReserved = dwReserved;

    memcpy(pItemIdCopy,pItemIDs,sizeof(SYNCMGRITEMID) * cbNumItems);
    pMethodArgs->PrepareForSyncMsg.pItemIDs = pItemIdCopy;

    pCallback->Release();

    PostMessage(m_hwndWorker,WM_WORKERMSG_PREPFORSYNC,0,(LPARAM) pMethodArgs);

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::PrepareForSyncCall, private
//
//  Synopsis:   Called on WorkerThread
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::PrepareForSyncCall(ULONG cbNumItems,SYNCMGRITEMID* pItemIDs,HWND hWndParent,
                    DWORD dwReserved)
{
LPSYNCMGRSYNCHRONIZECALLBACK pCallback = GetProgressCallback();
CLock clock(this);

    if (!pCallback)
    {
        Assert(pCallback);
        return;
    }

    clock.Enter();

    // if a stop came in then release the sync list if any
    if (m_fStopped && m_pItemsToSyncList)
    {
        if (0 == Release_ItemList(m_pItemsToSyncList))
        {
            m_pItemsToSyncList = NULL;
        }
    }

    m_fPrepareForSync = FALSE;

    clock.Leave();

    // currently all PrepareForSync is handled before the async call since we
    // just create a list and store it.

    pCallback->PrepareForSyncCompleted(NOERROR);
    pCallback->Release();


    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::Synchronize, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSyncMgrHandler::Synchronize(HWND hWndParent)
{
METHODARGS *pMethodArgs;
CLock clock(this);

    clock.Enter();
    m_fSynchronizing = TRUE;
    clock.Leave();

    pMethodArgs = (METHODARGS*) ALLOC(sizeof(METHODARGS));

    if (NULL == pMethodArgs)
    {
        Assert(pMethodArgs);
        return E_OUTOFMEMORY;
    }

    pMethodArgs->fAsync = TRUE;
    pMethodArgs->dwWorkerMsg = WM_WORKERMSG_SYNCHRONIZE;
    pMethodArgs->SynchronizeMsg.hWndParent = hWndParent;

    PostMessage(m_hwndWorker,WM_WORKERMSG_SYNCHRONIZE,0,(LPARAM) pMethodArgs);

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::SynchronizeCall, private
//
//  Synopsis:   Called on WorkerThread
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::SynchronizeCall(HWND hWndParent)
{
LPSYNCMGRSYNCHRONIZECALLBACK pCallback = GetProgressCallback();
CLock clock(this);

    if (!pCallback)
    {
        Assert(pCallback);
        clock.Enter();
        m_fSynchronizing = FALSE;
        clock.Leave();
        return;
    }

    clock.Enter();

    // should either have a syncList or receive a Stop Item request.
    Assert(m_pItemsToSyncList || m_fStopped);

    if (m_pItemsToSyncList)
    {
    LPHANDLERITEM_SYNCSTATUS pCurItem;

        if (g_pSettings)
        {
            // get first item in the list, sync, remove, repeat
            // until no more items in the list.
            while (pCurItem = (LPHANDLERITEM_SYNCSTATUS)
                            m_pItemsToSyncList->pFirstGenericItem)
            {
            FILETIME ft;
            SYSTEMTIME sysTime;
            HANDLERITEMSETTINGS HANDLERITEMSETTINGS;

               // if already cancelled such as setItemstatus came in while not synchronizing
               // then just skip over

               if (!pCurItem->fSynchronizeComplete)
               {
                   Assert(sizeof(HANDLERITEM_SYNCSTATUS) == pCurItem->genericItem.cbSize);
                   Assert(FALSE == pCurItem->fSynchronizing);

                   if (g_pSettings->CopyHandlerSyncInfo(pCurItem->ItemID,&HANDLERITEMSETTINGS))
                   {
                        pCurItem->fSynchronizing = TRUE; // set synchronizing before releasing lock.
                        // release lock and call call helper to do the real sync work.

                        clock.Leave();
                        SyncDirs(hWndParent,pCurItem,&HANDLERITEMSETTINGS);
                        clock.Enter();

                        // assert that noboday changed the state on us while
                        // the sync was in progress.

                        Assert(TRUE == pCurItem->fSynchronizing);
                        Assert(FALSE == pCurItem->fSynchronizeComplete);

                        pCurItem->fSynchronizing = FALSE;
                        pCurItem->fSynchronizeComplete = TRUE;
                   }

                   // only update file time if item wasn't cancelled,
                   // no failures occured and no
                   // unresolved conflicts.
                   if (!pCurItem->fUnresolvedConflicts && !pCurItem->fCancelled
                       && (SYNCMGRSTATUS_SUCCEEDED == pCurItem->dwSyncMgrResultStatus) )
                   {
                       GetSystemTime(&sysTime);
                       SystemTimeToFileTime(&sysTime,&ft);
                   }
                   else
                   {
                        ft = HANDLERITEMSETTINGS.ft;
                   }

                   // tell settings class we are done syncing.
                    g_pSettings->ReleaseItemLock(this,pCurItem->ItemID,&ft);
                    DeleteItemFromList(m_pItemsToSyncList, (LPGENERICITEM) pCurItem);
                }
            }
        }

        // release the item list if this is the last ref then null out
        // the member var
        if (0 == Release_ItemList(m_pItemsToSyncList))
        {
            m_pItemsToSyncList = NULL;
        }

    }


    m_fSynchronizing = FALSE;
    clock.Leave();


    if (pCallback)
    {
        pCallback->SynchronizeCompleted(NOERROR);
        pCallback->Release();
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::SetItemStatus, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSyncMgrHandler::SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus)
{
LPSYNCMGRSYNCHRONIZECALLBACK pCallback = GetProgressCallback();
CLock clock(this);

    if (!pCallback)
    {
        Assert(pCallback);
        return E_UNEXPECTED;
    }

    clock.Enter();

    if (m_pItemsToSyncList)
    {
    LPHANDLERITEM_SYNCSTATUS  pCurItem =   (LPHANDLERITEM_SYNCSTATUS) m_pItemsToSyncList->pFirstGenericItem;

        while (pCurItem)
        {
        LPHANDLERITEM_SYNCSTATUS  pCurItemNext;


           pCurItemNext = (LPHANDLERITEM_SYNCSTATUS) pCurItem->genericItem.pNextGenericItem;

           Assert(sizeof(HANDLERITEM_SYNCSTATUS) == pCurItem->genericItem.cbSize);

           if ((SYNCMGRSTATUS_SKIPPED == dwSyncMgrStatus &&
               ItemID == pCurItem->ItemID)
               || SYNCMGRSTATUS_STOPPED == dwSyncMgrStatus)
           {
                pCurItem->fCancelled = TRUE;

                if (!pCurItem->fSynchronizeComplete)
                {
                    pCurItem->dwSyncMgrResultStatus = dwSyncMgrStatus;
                }

                // if not currently synchronizing and synchronization is
                // not already done on this item set the progress accordingly
                if (!pCurItem->fSynchronizing && !pCurItem->fSynchronizeComplete)
                {
                    ProgressSetItemStatusType(pCallback,pCurItem->ItemID,dwSyncMgrStatus);
                    ProgressSetItemProgMaxValue(pCallback,pCurItem->ItemID,10);
                    ProgressSetItemProgValue(pCallback,pCurItem->ItemID,10);

                    pCurItem->fSynchronizeComplete = TRUE;

                    // if we have a syncList
                    // then delete the items from the list
                    // and relesae the lock
                    // Note: this code relies on  PrepareForSync
                    // not yielding while setting up item table.

                    g_pSettings->ReleaseItemLock(this,pCurItem->ItemID);
                    DeleteItemFromList(m_pItemsToSyncList, (LPGENERICITEM) pCurItem);

                }

                if (SYNCMGRSTATUS_SKIPPED == dwSyncMgrStatus)
                {
                    break; // if skipped done when found a match.
                }
           }

           pCurItem = pCurItemNext;
        }
    }

    // if not in a synchronize or prepareForSync call when stop is
    // pressed release the itemList.
    if ((SYNCMGRSTATUS_STOPPED == dwSyncMgrStatus)
        && !m_fSynchronizing && !m_fPrepareForSync)
    {
        m_fStopped = TRUE;

        if (m_pItemsToSyncList)
        {
            if (0 == Release_ItemList(m_pItemsToSyncList))
            {
                m_pItemsToSyncList = NULL;
            }
        }
    }


    clock.Leave();

    pCallback->Release();
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::ShowError, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSyncMgrHandler::ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID)
{
METHODARGS *pMethodArgs;

    pMethodArgs = (METHODARGS*) ALLOC(sizeof(METHODARGS));

    if (NULL == pMethodArgs)
    {
        Assert(pMethodArgs);
        return E_OUTOFMEMORY;
    }

    pMethodArgs->fAsync = TRUE;
    pMethodArgs->dwWorkerMsg = WM_WORKERMSG_SHOWERROR;
    pMethodArgs->ShowErrorMsg.hWndParent = hWndParent;
    pMethodArgs->ShowErrorMsg.ErrorID = ErrorID;

    PostMessage(m_hwndWorker,WM_WORKERMSG_SHOWERROR,0,(LPARAM) pMethodArgs);

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::ShowErrorCall, private
//
//  Synopsis:   Called on Worker Thread
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::ShowErrorCall(HWND hWndParent,REFSYNCMGRERRORID ErrorID)
{
LPSYNCMGRSYNCHRONIZECALLBACK pCallback = GetProgressCallback();

    if (pCallback)
    {
        pCallback->ShowErrorCompleted(NOERROR,0,NULL);
        pCallback->Release();
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::Progress, private
//
//  Synopsis:   Helper method for sending progress information.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::Progress(ISyncMgrSynchronizeCallback *lpCallBack,REFSYNCMGRITEMID pItemID,
                                UINT mask,TCHAR *pStatusText,DWORD dwStatusType,
                                int iProgValue,int iMaxValue)
{
SYNCMGRPROGRESSITEM syncProg;
    Assert(lpCallBack);

    syncProg.cbSize = sizeof(SYNCMGRPROGRESSITEM);
    syncProg.mask = mask;

    if (SYNCMGRPROGRESSITEM_STATUSTEXT & mask)
    {
    #ifdef _UNICODE
        syncProg.lpcStatusText = pStatusText;
    #else
        WCHAR wszStatusText[MAX_PATH];

       MultiByteToWideChar(CP_ACP, 0,
                    pStatusText,
                    -1, wszStatusText,MAX_PATH);

        syncProg.lpcStatusText = wszStatusText;
    #endif // _UNICODE
    }

    syncProg.dwStatusType = dwStatusType;
    syncProg.iProgValue = iProgValue;
    syncProg.iMaxValue = iMaxValue;

    lpCallBack->Progress(pItemID,&syncProg);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::ProgressSetItemStatusType, private
//
//  Synopsis:   Helper method for sending progress information.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::ProgressSetItemStatusType(ISyncMgrSynchronizeCallback *lpCallBack,
                            REFSYNCMGRITEMID pItemID,DWORD dwSyncMgrStatus)
{
    Progress(lpCallBack,pItemID,SYNCMGRPROGRESSITEM_STATUSTYPE,
                    NULL,dwSyncMgrStatus,0,0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::ProgressSetItemStatusText, private
//
//  Synopsis:   Helper method for sending progress information.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::ProgressSetItemStatusText(ISyncMgrSynchronizeCallback *lpCallBack,
                            REFSYNCMGRITEMID pItemID,TCHAR *pStatusText)
{
    Progress(lpCallBack,pItemID,SYNCMGRPROGRESSITEM_STATUSTEXT,
                    pStatusText,0,0,0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::ProgressSetItemProgValue, private
//
//  Synopsis:   Helper method for sending progress information.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::ProgressSetItemProgValue(ISyncMgrSynchronizeCallback *lpCallBack,
                            REFSYNCMGRITEMID pItemID,int iProgValue)
{
    Progress(lpCallBack,pItemID,SYNCMGRPROGRESSITEM_PROGVALUE,
                    NULL,0,iProgValue,0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::ProgressSetItemMaxValue, private
//
//  Synopsis:   Helper method for sending progress information.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::ProgressSetItemProgMaxValue(ISyncMgrSynchronizeCallback *lpCallBack,
                            REFSYNCMGRITEMID pItemID,int iProgMaxValue)
{
    Progress(lpCallBack,pItemID,SYNCMGRPROGRESSITEM_MAXVALUE,
                    NULL,0,0,iProgMaxValue);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::LogError, private
//
//  Synopsis:   Helper method for logging Error information.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::LogError(ISyncMgrSynchronizeCallback *lpCallBack,REFSYNCMGRITEMID pItemID,
              DWORD dwErrorLevel,TCHAR *lpErrorText,DWORD mask,DWORD dwSyncMgrErrorFlags,
              SYNCMGRERRORID ErrorID)
{
SYNCMGRLOGERRORINFO logError;
WCHAR *pwszErrorText;

    Assert(lpCallBack);

    logError.cbSize = sizeof(SYNCMGRLOGERRORINFO);
    logError.mask = mask | SYNCMGRLOGERROR_ERRORID | SYNCMGRLOGERROR_ERRORFLAGS;
    logError.dwSyncMgrErrorFlags = dwSyncMgrErrorFlags | SYNCMGRERRORFLAG_ENABLEJUMPTEXT;
    logError.ErrorID = ErrorID;
    logError.ItemID = pItemID;

#ifdef _UNICODE
    pwszErrorText = lpErrorText;
#else
    WCHAR wszErrorText[MAX_PATH];

   MultiByteToWideChar(CP_ACP, 0,
                lpErrorText,
                -1, wszErrorText,MAX_PATH);

    pwszErrorText = wszErrorText;
#endif // _UNICODE

    lpCallBack->LogError(dwErrorLevel,pwszErrorText,&logError);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::LogError, private
//
//  Synopsis:   Helper method for logging Error information.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::LogError(ISyncMgrSynchronizeCallback *lpCallBack,REFSYNCMGRITEMID pItemID,
                      DWORD dwErrorLevel,TCHAR *lpErrorText)
{
    LogError(lpCallBack,pItemID,dwErrorLevel,lpErrorText,SYNCMGRLOGERROR_ITEMID,0,GUID_NULL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::LogError, private
//
//  Synopsis:   Helper method for logging Error information.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::LogError(ISyncMgrSynchronizeCallback *lpCallBack,
                      DWORD dwErrorLevel,TCHAR *lpErrorText)
{
    LogError(lpCallBack,GUID_NULL,dwErrorLevel,lpErrorText,0,0,GUID_NULL);
}

////******
///
//  methods specific to this implementation to sync up file directories
//
///*******


//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::GetFilesForDir, private
//
//  Synopsis:   creates a list of files for the given directory.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LPFILEOBJECTLIST CSyncMgrHandler::GetFilesForDir(TCHAR *pDirName,BOOL fRecursive)

{
LPFILEOBJECTLIST pDirList;
HANDLE hFind;
BOOL bMore;
WIN32_FIND_DATA finddata;
TCHAR szSearch[MAX_PATH];

    pDirList = CreateItemList();

    if (!pDirList)
    {
        return NULL;
    }

    wsprintf(szSearch,TEXT("%s\\*.*"),pDirName);

    hFind = FindFirstFile(szSearch, &finddata);
    bMore = (hFind != (HANDLE) -1);

    while (bMore) {

            if ( (lstrcmp(finddata.cFileName, TEXT(".")) != 0) &&
                           ( lstrcmp(finddata.cFileName, TEXT("..")) != 0) )
            {
            LPFILEOBJECT pFileObject = (LPFILEOBJECT) AddNewItemToList(pDirList,sizeof(FILEOBJECT));
            BOOL bIsDir;

                if (!pFileObject) // if alloc ever fails just bail.
                {
                    break;
                }

                // init the data.
                lstrcpy(pFileObject->fName,finddata.cFileName);

                bIsDir = (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE;
                pFileObject->fDirectory = bIsDir;

                if (!bIsDir)
                {
                HANDLE hFile;
                FILETIME ftCreate;
                FILETIME ftLastAccess;

                    // Review - need to check failure
                    // and if way to get modified with openning file.

                    wsprintf(szSearch,TEXT("%s\\%s"),pDirName,pFileObject->fName);

                    hFile = CreateFile(szSearch, GENERIC_READ, 0, NULL,
                                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);


                    if (GetFileTime(hFile, &ftCreate,
                                    &ftLastAccess,&(pFileObject->ftLastUpdate)) )
                    {
                        pFileObject->fLastUpdateValid = TRUE;
                    }

                    CloseHandle(hFile);

                }
                else
                {
                    // if this is a directory and recursive, get children
                    if (fRecursive)
                    {
                    TCHAR szFullPath[MAX_PATH];

                        // fullpath is current dir name + \ + this dir name.
                        wsprintf(szFullPath,TEXT("%s\\%s"),pDirName,pFileObject->fName);

                        pFileObject->pChildList =
                                GetFilesForDir(szFullPath,fRecursive);
                    }
                }
            }

            bMore = FindNextFile(hFind, &finddata);
    }

    FindClose(hFind);

    return pDirList;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::CreateDirFileListFromPath, private
//
//  Synopsis:   creates a new FileObjectList for the given Directory
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LPFILEOBJECTLIST CSyncMgrHandler::CreateDirFileListFromPath(TCHAR *pDirName,BOOL fRecursive)
{
LPFILEOBJECTLIST pDirObj;
BOOL fValidDir = FALSE;

    if (!IsValidDir(pDirName))
    {
        return NULL;
    }

    pDirObj = CreateItemList();

    if (pDirObj)
    {
    LPFILEOBJECT pFileObject;

        // go ahead and add this as the toplevel dir
        pFileObject = (LPFILEOBJECT) AddNewItemToList(pDirObj,sizeof(FILEOBJECT));

        if (pFileObject)
        {
            pFileObject->fDirectory = TRUE;
            lstrcpy(pFileObject->fName,pDirName);

            pFileObject->pChildList = GetFilesForDir(pFileObject->fName,fRecursive);

        }
    }

    return pDirObj;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::ReleaseFileObjectList, private
//
//  Synopsis:   releases the fileobject list.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::ReleaseFileObjectList(LPFILEOBJECTLIST pfObjList,BOOL fRecursive)
{
LPFILEOBJECT pCurItem;

    if (!pfObjList)
    {
        Assert(pfObjList)
        return;
    }

    // see if object has any childs and free them if they do.

    pCurItem= (LPFILEOBJECT) pfObjList->pFirstGenericItem;

    while(pCurItem)
    {
        Assert(sizeof(FILEOBJECT ) == pCurItem->genericItem.cbSize);

        if (pCurItem->fDirectory)
        {
            Assert(pCurItem->pChildList || (!fRecursive));

            if (pCurItem->pChildList)
            {
                ReleaseFileObjectList(pCurItem->pChildList,fRecursive);
            }
        }

        pCurItem = (LPFILEOBJECT) pCurItem->genericItem.pNextGenericItem;
    }

    Release_ItemList(pfObjList);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::CountNumberofFilesInList, private
//
//  Synopsis:   returns a total count of the number of items in the list.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

ULONG CSyncMgrHandler::CountNumberOfFilesInList(LPFILEOBJECTLIST pfObjList,BOOL fRecursive)
{
LPFILEOBJECT pCurItem;
ULONG ulTotalCount = 0;

    if (!pfObjList)
    {
        Assert(pfObjList)
        return 0;
    }

    // see if object has any childs and free them if they do.
    pCurItem= (LPFILEOBJECT) pfObjList->pFirstGenericItem;

    while(pCurItem)
    {
        Assert(sizeof(FILEOBJECT ) == pCurItem->genericItem.cbSize);

        if (pCurItem->fDirectory)
        {
            Assert(pCurItem->pChildList || (!fRecursive));

            if (pCurItem->pChildList)
            {
                ulTotalCount += CountNumberOfFilesInList(pCurItem->pChildList,fRecursive);
            }
        }
        else
        {
            ++ulTotalCount;
        }

        pCurItem = (LPFILEOBJECT) pCurItem->genericItem.pNextGenericItem;
    }

    return ulTotalCount;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::FindFileItemWithName, private
//
//  Synopsis:  trys to find the items with with the specified filename in
//              the fileobject list.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LPFILEOBJECT CSyncMgrHandler::FindFileItemWithName(LPFILEOBJECTLIST pDir,TCHAR *pfName)
{
LPFILEOBJECT pCurItem = NULL;

    if (!pDir)
    {
        Assert(pDir)
        return NULL;
    }

    // see if object has any childs and free them if they do.
    pCurItem= (LPFILEOBJECT) pDir->pFirstGenericItem;

    while(pCurItem)
    {
        Assert(sizeof(FILEOBJECT ) == pCurItem->genericItem.cbSize);

        if (0 == lstrcmp(pfName,pCurItem->fName))
        {
            break;
        }

        pCurItem = (LPFILEOBJECT) pCurItem->genericItem.pNextGenericItem;
    }

    return pCurItem;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::CopyfileFullPath, private
//
//  Synopsis:   copies file1 to file2 along with attribs.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL CSyncMgrHandler::CopyFileFullPath(TCHAR *pszFile1,TCHAR *pszFile2)
{
HANDLE hfile;
DWORD dwAttribs;
FILETIME ftCreate,ftLastAccess,ftLastWrite;
BOOL fOk;

    fOk = CopyFile(pszFile1, pszFile2, FALSE);

    if (fOk)
    {
    BOOL fFileTime = FALSE;

        // having copied the file, now copy the times, attributes
        // if fail to get go ahead and say copy succeeded.

        hfile = CreateFile(pszFile1, GENERIC_READ, 0, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (INVALID_HANDLE_VALUE != hfile)
        {

            fFileTime = GetFileTime(hfile, &ftCreate,
                            &ftLastAccess, &ftLastWrite);
            CloseHandle(hfile);
        }


        if (fFileTime)
        {
            hfile = CreateFile(pszFile2, GENERIC_WRITE, 0, NULL,
                            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

            if (INVALID_HANDLE_VALUE != hfile)
            {
                SetFileTime(hfile, &ftCreate,
                                   &ftLastAccess,
                                   &ftLastWrite);

                CloseHandle(hfile);
            }
        }

        // update attributes
        dwAttribs = GetFileAttributes(pszFile1);
        if (-1 != dwAttribs)
        {
            SetFileAttributes(pszFile2,dwAttribs);
        }

    }

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::CopyFiles, private
//
//  Synopsis:   copies all files from dir1 to dir2
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::CopyFiles( LPHANDLERITEM_SYNCSTATUS pHandlerItemID,
                                LPHANDLERITEMSETTINGS pHANDLERITEMSETTINGS,
                                LPSYNCMGRSYNCHRONIZECALLBACK pCallback,
                                DWORD *pdwCurProgValue,
                                TCHAR *pszDir1,
                                LPFILEOBJECTLIST pDir1,
                                TCHAR *pszDir2)
{
LPFILEOBJECT pCurDir1Item;
LPFILEOBJECT pNextDir1Item;

    // anything left is list when done is unique and needs to be copied
    // walk through each list moving the items.
    pNextDir1Item = (LPFILEOBJECT) pDir1->pFirstGenericItem;

    while(pNextDir1Item)
    {

       // each time through the loop check for if item is cancelled
       // and if so return;
       if (pHandlerItemID->fCancelled)
            return;

        Assert(sizeof(FILEOBJECT ) == pNextDir1Item->genericItem.cbSize);
        pCurDir1Item = pNextDir1Item;

        pNextDir1Item = (LPFILEOBJECT) pNextDir1Item->genericItem.pNextGenericItem;

        if (pCurDir1Item->fDirectory)
        {
            if (pCurDir1Item->pChildList)
            {
            TCHAR szDir1[MAX_PATH];
            TCHAR szDir2[MAX_PATH];

                wsprintf(szDir1,TEXT("%s\\%s"),pszDir1,pCurDir1Item->fName);
                wsprintf(szDir2,TEXT("%s\\%s"),pszDir2,pCurDir1Item->fName);

                // create destination dir if necessary.
                CreateDirectory(szDir2,NULL);

                CopyFiles(pHandlerItemID,pHANDLERITEMSETTINGS,pCallback,pdwCurProgValue,
                                szDir1,pCurDir1Item->pChildList,szDir2);
            }

        }
        else
        {
        TCHAR szFullPath1[MAX_PATH];
        TCHAR szFullPath2[MAX_PATH];
        TCHAR szProgress[MAX_PATH];

            wsprintf(szProgress,TEXT("Copying %s"),pCurDir1Item->fName);
            ProgressSetItemStatusText(pCallback,pHANDLERITEMSETTINGS->ItemID,szProgress);

            wsprintf(szFullPath1,TEXT("%s\\%s"),pszDir1,pCurDir1Item->fName);
            wsprintf(szFullPath2,TEXT("%s\\%s"),pszDir2,pCurDir1Item->fName);

            // copy the file over
            if (FALSE == CopyFileFullPath(szFullPath1,szFullPath2))
            {
                wsprintf(szProgress,TEXT("Error Copying %s"),pCurDir1Item->fName);

                LogError(pCallback,pHANDLERITEMSETTINGS->ItemID,SYNCMGRLOGLEVEL_ERROR,
                                    szProgress);
            }

            // update the progress bar value.
             *pdwCurProgValue += 1;
            ProgressSetItemProgValue(pCallback,pHANDLERITEMSETTINGS->ItemID,*pdwCurProgValue);

            // always release, even on
            DeleteItemFromList(pDir1,(LPGENERICITEM) pCurDir1Item);

        }

    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::reconcileDir, private
//
//  Synopsis:  does main job of reconciling dir1 and dir2
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::ReconcileDir(HWND hWndParent,
                                LPHANDLERITEM_SYNCSTATUS pHandlerItemID,
                                LPHANDLERITEMSETTINGS pHANDLERITEMSETTINGS,
                                LPSYNCMGRSYNCHRONIZECALLBACK pCallback,
                                DWORD *pdwCurProgValue,
                                TCHAR *pszDir1,LPFILEOBJECTLIST pDir1,
                                TCHAR *pszDir2,LPFILEOBJECTLIST pDir2)
{
LPFILEOBJECT pCurDir1Item;
LPFILEOBJECT pCurDir1NextItem;
LPFILEOBJECT pCurDir2Item;

    if (!pDir1 || !pDir2 || !pCallback)
    {
        Assert(pCallback);
        Assert(pDir1);
        Assert(pDir1);
        return;
    }
    // loop through dir finding and comparing matches,
    // if find matching dirs call ReconcileDir
    pCurDir1NextItem= (LPFILEOBJECT) pDir1->pFirstGenericItem;

    while(pCurDir1NextItem)
    {
        Assert(sizeof(FILEOBJECT ) == pCurDir1NextItem->genericItem.cbSize);

        // each time through the loop check for if item is cancelled
        // and if so return;
       if (pHandlerItemID->fCancelled)
            return;

        pCurDir1Item = pCurDir1NextItem;
        pCurDir1NextItem = (LPFILEOBJECT) pCurDir1Item->genericItem.pNextGenericItem;

        pCurDir2Item = FindFileItemWithName(pDir2,pCurDir1Item->fName);

        // if found match, deal with it, else leave in list and
        // catch on the copy pass.
        if (pCurDir2Item)
        {
            // if both directies
            if (pCurDir1Item->fDirectory && pCurDir2Item->fDirectory)
            {
                if (pCurDir1Item->pChildList && pCurDir2Item->pChildList)
                {
                TCHAR szDir1[MAX_PATH];
                TCHAR szDir2[MAX_PATH];

                    wsprintf(szDir1,TEXT("%s\\%s"),pszDir1,pCurDir1Item->fName);
                    wsprintf(szDir2,TEXT("%s\\%s"),pszDir2,pCurDir2Item->fName);

                    ReconcileDir(hWndParent,pHandlerItemID,pHANDLERITEMSETTINGS,
                                  pCallback,
                                  pdwCurProgValue,
                                  szDir1,pCurDir1Item->pChildList,
                                  szDir2,pCurDir2Item->pChildList);

                }
                else
                {
                    // one of the directories didn't have a child list and
                    // one did.

                     if (pCurDir1Item->pChildList)
                     {
                        *pdwCurProgValue += CountNumberOfFilesInList(pCurDir1Item->pChildList,pHANDLERITEMSETTINGS->fRecursive);
                        ReleaseFileObjectList(pCurDir1Item->pChildList,pHANDLERITEMSETTINGS->fRecursive);
                        pCurDir1Item->pChildList = NULL;
                     }

                     *pdwCurProgValue += 1;
                     DeleteItemFromList(pDir1,(LPGENERICITEM) pCurDir1Item);

                     if (pCurDir2Item->pChildList)
                     {
                        *pdwCurProgValue += CountNumberOfFilesInList(pCurDir2Item->pChildList,pHANDLERITEMSETTINGS->fRecursive);
                        ReleaseFileObjectList(pCurDir2Item->pChildList,pHANDLERITEMSETTINGS->fRecursive);
                        pCurDir2Item->pChildList = NULL;
                     }

                     *pdwCurProgValue += 1;
                     DeleteItemFromList(pDir2,(LPGENERICITEM) pCurDir2Item);

                    // update the progress value.
                    ProgressSetItemProgValue(pCallback,pHANDLERITEMSETTINGS->ItemID,*pdwCurProgValue);

                }
            }
            else if (!pCurDir1Item->fDirectory && !pCurDir2Item->fDirectory)
            {
            FILETIME *pftLastUpdate = &(pHANDLERITEMSETTINGS->ft);
            int iFileCompare;
            BOOL fCopy = FALSE;

                ProgressSetItemStatusText(pCallback,pHANDLERITEMSETTINGS->ItemID,pCurDir1Item->fName);

                // if filestimes are the same do nothing
                // both filetimes are greater than < last sync time, conflict,
                // else copy newer file over.

                if (0 != (iFileCompare  = CompareFileTime(&(pCurDir1Item->ftLastUpdate),&(pCurDir2Item->ftLastUpdate)) ))
                {
                int iFile1UpdateTimeCompare = CompareFileTime(&(pCurDir1Item->ftLastUpdate),pftLastUpdate);
                int iFile2UpdateTimeCompare = CompareFileTime(&(pCurDir2Item->ftLastUpdate),pftLastUpdate);

                    if (iFile1UpdateTimeCompare ==  iFile2UpdateTimeCompare)
                    {
                    RFCDLGPARAM rfcParam;
                    int iResolution;
                    TCHAR szNetModifiedOnBuf[MAX_PATH];
                    TCHAR szLocalModifiedOnBuf[MAX_PATH];

                        // !!! Conflict
                        memset(&rfcParam,0,sizeof(RFCDLGPARAM));

                        rfcParam.dwFlags = 0;
                        rfcParam.pszFilename = pCurDir1Item->fName;
                        rfcParam.pszLocation = pszDir1;
                        rfcParam.pszNewName = pCurDir2Item->fName;
                        rfcParam.pszNetworkModifiedOn
                                = FormatDateTime(&(pCurDir1Item->ftLastUpdate),szNetModifiedOnBuf,sizeof(szNetModifiedOnBuf)/sizeof(TCHAR));
                        rfcParam.pszLocalModifiedOn
                                = FormatDateTime(&(pCurDir2Item->ftLastUpdate),szLocalModifiedOnBuf,sizeof(szLocalModifiedOnBuf)/sizeof(TCHAR));


                       // if can show UI call enable modeless, and show
                        // conflict dialog, else log and error and treat
                        // as if use chose to keep both.

                        if ( (m_dwSyncFlags & SYNCMGRFLAG_MAYBOTHERUSER)
                             && (S_OK ==  pCallback->EnableModeless(TRUE)) )
                        {
                            iResolution = SyncMgrResolveConflict(hWndParent,&rfcParam);
                            pCallback->EnableModeless(FALSE);
                        }
                        else
                        {
                        TCHAR szLogText[MAX_PATH];

                            iResolution = RFC_KEEPBOTH;

                            wsprintf(szLogText,TEXT("Conflict occured - %s"),pCurDir1Item->fName);

                            LogError(pCallback,pHANDLERITEMSETTINGS->ItemID,SYNCMGRLOGLEVEL_WARNING,
                                        szLogText);

                        }

                        switch (iResolution)
                        {
                        case RFC_KEEPNETWORK: // treat dir1 as network copy
                            iFileCompare = 1;
                            fCopy = TRUE;
                            break;
                        case RFC_KEEPLOCAL: // treat dir2 as local copy.
                            iFileCompare = - 1;
                            fCopy = TRUE;
                            break;
                        case RFC_KEEPBOTH: // if keep both wait until next sync.
                        default:
                            fCopy = FALSE;
                            pHandlerItemID->fUnresolvedConflicts = TRUE;
                            break;
                        }


                    }
                    else
                    {
                        fCopy = TRUE;
                    }


                    if (fCopy)
                    {
                    TCHAR szProgressText[MAX_PATH];
                    TCHAR szFile1FullPath[MAX_PATH],szFile2FullPath[MAX_PATH];
                    BOOL fOk;

                        wsprintf(szProgressText,TEXT("Updating %s"),pCurDir1Item->fName);
                        ProgressSetItemStatusText(pCallback,pHANDLERITEMSETTINGS->ItemID,szProgressText);

                        wsprintf(szFile1FullPath,TEXT("%s\\%s"),pszDir1,pCurDir1Item->fName);
                        wsprintf(szFile2FullPath,TEXT("%s\\%s"),pszDir2,pCurDir2Item->fName);

                         // copy newer file.
                         if (0 < iFileCompare)
                         {
                            // 1 > 2.
                            fOk = CopyFileFullPath(szFile1FullPath,szFile2FullPath);
                         }
                         else
                         {
                            fOk = CopyFileFullPath(szFile2FullPath,szFile1FullPath);

                         }

                    }


                }

                // when done incmrement the progress value and release the items.
                *pdwCurProgValue += 2; // incrent progress by 2 since we handled both files.
                ProgressSetItemProgValue(pCallback,pHANDLERITEMSETTINGS->ItemID,*pdwCurProgValue);

                // always release, even on error since don't want copy to kick in.
                DeleteItemFromList(pDir1,(LPGENERICITEM) pCurDir1Item);
                DeleteItemFromList(pDir2,(LPGENERICITEM) pCurDir2Item);

            }
            else
            {
            TCHAR szLogError[MAX_PATH];

                wsprintf(szLogError,TEXT("%s is a Directory in one location and file in another.")
                                    ,pCurDir1Item->fName);
                LogError(pCallback,pHANDLERITEMSETTINGS->ItemID,SYNCMGRLOGLEVEL_ERROR,szLogError);

                // release both dir and file.
                 if (pCurDir1Item->fDirectory && pCurDir1Item->pChildList)
                 {
                    *pdwCurProgValue += CountNumberOfFilesInList(pCurDir1Item->pChildList,pHANDLERITEMSETTINGS->fRecursive);
                    ReleaseFileObjectList(pCurDir1Item->pChildList,pHANDLERITEMSETTINGS->fRecursive);
                    pCurDir1Item->pChildList = NULL;
                 }

                *pdwCurProgValue += 1;
                DeleteItemFromList(pDir1,(LPGENERICITEM) pCurDir1Item);

                 if (pCurDir2Item->fDirectory && pCurDir2Item->pChildList)
                 {
                    *pdwCurProgValue += CountNumberOfFilesInList(pCurDir2Item->pChildList,pHANDLERITEMSETTINGS->fRecursive);
                    ReleaseFileObjectList(pCurDir2Item->pChildList,pHANDLERITEMSETTINGS->fRecursive);
                    pCurDir2Item->pChildList = NULL;
                 }

                *pdwCurProgValue += 1;
                DeleteItemFromList(pDir2, (LPGENERICITEM) pCurDir2Item);


                // update the progress value.
                ProgressSetItemProgValue(pCallback,pHANDLERITEMSETTINGS->ItemID,*pdwCurProgValue);


            }

        }

    }

   // Anything left is a copy
   // This sample doesn't properly handle the following cases
   //  1)  file has been deleted in one folder and not the other - next sync file will be
   //       copied back to folder it was delted from
   //  2)  File has been renamed in one folder and not the other - next sync both files will
   //        appear.

   CopyFiles(pHandlerItemID,pHANDLERITEMSETTINGS,pCallback,pdwCurProgValue,pszDir1,pDir1,pszDir2);
   CopyFiles(pHandlerItemID,pHANDLERITEMSETTINGS,pCallback,pdwCurProgValue,pszDir2,pDir2,pszDir1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSyncMgrHandler::SyncDirs, private
//
//  Synopsis:   Called by SynchronizeCall(). Sets up dirlists
//              for synchronization and then calls the ReconcileDir function.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSyncMgrHandler::SyncDirs(HWND hWndParent,LPHANDLERITEM_SYNCSTATUS pHandlerItemID,
                                        LPHANDLERITEMSETTINGS pHANDLERITEMSETTINGS)
{
LPSYNCMGRSYNCHRONIZECALLBACK pCallback = GetProgressCallback();
LPFILEOBJECTLIST pfObjDir1 = NULL,pfObjDir2 = NULL;
ULONG ulProgressMaxValue = 0;
ULONG ulProgressCurValue = 0;
TCHAR szStatusText[MAX_PATH];

    // if already cancelled go on.
    if (pHandlerItemID->fCancelled)
        goto synccomplete;

    // synchronizing flag should be TRUE so SetItemStatus knows this is
    Assert(TRUE == pHandlerItemID->fSynchronizing);

    pHandlerItemID->dwSyncMgrResultStatus = SYNCMGRSTATUS_SUCCEEDED;

    ProgressSetItemStatusType(pCallback,pHANDLERITEMSETTINGS->ItemID,SYNCMGRSTATUS_UPDATING);

    wsprintf(szStatusText,TEXT("Scanning %s"),pHANDLERITEMSETTINGS->dir1);
    ProgressSetItemStatusText(pCallback,pHANDLERITEMSETTINGS->ItemID,szStatusText);

    pfObjDir1 = CreateDirFileListFromPath(pHANDLERITEMSETTINGS->dir1,
                                                pHANDLERITEMSETTINGS->fRecursive);

    if (pHandlerItemID->fCancelled)
        goto synccomplete;

    if (!pfObjDir1)
    {
         wsprintf(szStatusText,TEXT("Error Scanning %s"),pHANDLERITEMSETTINGS->dir1);
         LogError(pCallback,pHANDLERITEMSETTINGS->ItemID,SYNCMGRLOGLEVEL_ERROR,szStatusText);
         pHandlerItemID->dwSyncMgrResultStatus = SYNCMGRSTATUS_FAILED;
    }
    else
    {
        wsprintf(szStatusText,TEXT("Scanning %s"),pHANDLERITEMSETTINGS->dir2);
        ProgressSetItemStatusText(pCallback,pHANDLERITEMSETTINGS->ItemID,szStatusText);

        pfObjDir2 = CreateDirFileListFromPath(pHANDLERITEMSETTINGS->dir2,
                                                    pHANDLERITEMSETTINGS->fRecursive);

        if (!pfObjDir2)
        {
             wsprintf(szStatusText,TEXT("Error Scanning %s"),pHANDLERITEMSETTINGS->dir2);
             LogError(pCallback,pHANDLERITEMSETTINGS->ItemID,SYNCMGRLOGLEVEL_ERROR,szStatusText);
             pHandlerItemID->dwSyncMgrResultStatus = SYNCMGRSTATUS_FAILED;
        }
    }

    if (pHandlerItemID->fCancelled)
        goto synccomplete;

    if (pfObjDir1 && pfObjDir2)
    {
        // Calc the progress Item MaxValue which is the total
        // number of items to sync.
        ulProgressMaxValue += CountNumberOfFilesInList(pfObjDir1,pHANDLERITEMSETTINGS->fRecursive);
        ulProgressMaxValue += CountNumberOfFilesInList(pfObjDir2,pHANDLERITEMSETTINGS->fRecursive);

        ProgressSetItemProgMaxValue(pCallback,pHANDLERITEMSETTINGS->ItemID,ulProgressMaxValue);
        ProgressSetItemProgValue(pCallback,pHANDLERITEMSETTINGS->ItemID,0);

        // want to kick Reconcil off pointing to childlist of each toplevel dir
        if (pfObjDir1->pFirstGenericItem && pfObjDir2->pFirstGenericItem)
        {
        LPFILEOBJECTLIST pfObjStartDir1,pfObjStartDir2;
        TCHAR *pszDir1Name,*pszDir2Name;

            pfObjStartDir1 = ((LPFILEOBJECT) pfObjDir1->pFirstGenericItem)->pChildList;
            pfObjStartDir2 = ((LPFILEOBJECT) pfObjDir2->pFirstGenericItem)->pChildList;

            pszDir1Name = ((LPFILEOBJECT) pfObjDir1->pFirstGenericItem)->fName;
            pszDir2Name = ((LPFILEOBJECT) pfObjDir2->pFirstGenericItem)->fName;

            if (pfObjStartDir1 && pfObjStartDir2)
            {
                ReconcileDir(hWndParent,pHandlerItemID,pHANDLERITEMSETTINGS,pCallback,&ulProgressCurValue,
                                        pszDir1Name,pfObjStartDir1,pszDir2Name,pfObjStartDir2);
            }
        }
    }

synccomplete:

    // set progress to max and clear status
    ProgressSetItemProgValue(pCallback,pHANDLERITEMSETTINGS->ItemID,ulProgressMaxValue);
    ProgressSetItemStatusText(pCallback,pHANDLERITEMSETTINGS->ItemID,TEXT(""));

    // update item status based on result.
    ProgressSetItemStatusType(pCallback,pHANDLERITEMSETTINGS->ItemID,pHandlerItemID->dwSyncMgrResultStatus);

    if (pCallback)
    {
        pCallback->Release();
    }

    if (pfObjDir1)
    {
        ReleaseFileObjectList(pfObjDir1,pHANDLERITEMSETTINGS->fRecursive);
    }

    if (pfObjDir2)
    {
        ReleaseFileObjectList(pfObjDir2,pHANDLERITEMSETTINGS->fRecursive);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   HandlerThreadWndProc, private
//
//  Synopsis:   WndProc for hwnd on thread handler was created on
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LRESULT CALLBACK  HandlerThreadWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{
CSyncMgrHandler *pThis = (CSyncMgrHandler *) GetWindowLong(hWnd, DWL_THREADWNDPROCCLASS);
METHODARGS *pMethodArgs = (METHODARGS *) lParam;
BOOL fMethodCall = FALSE;

    switch (msg)
    {
    case WM_CREATE :
        {
        CREATESTRUCT *pCreateStruct = (CREATESTRUCT *) lParam;

        SetWindowLong(hWnd, DWL_THREADWNDPROCCLASS,(LONG) pCreateStruct->lpCreateParams );
        pThis = (CSyncMgrHandler *) pCreateStruct->lpCreateParams ;
        }
        break;
        case WM_DESTROY:
        break;
        case WM_WORKERMSG_PROGRESS:
            Assert(pMethodArgs);
            fMethodCall = TRUE;

            if (pMethodArgs)
            {
                pMethodArgs->hr = E_UNEXPECTED;

                if (pThis->m_pSyncMgrSynchronizeCallback)
                {
                PROGRESSMSG *pMsg = &(pMethodArgs->ProgressMsg);

                    Assert(msg == pMethodArgs->dwWorkerMsg);

                    pMethodArgs->hr =
                        pThis->m_pSyncMgrSynchronizeCallback->Progress(
                                   pMsg->ItemID,
                                   pMsg->lpSyncProgressItem);
                }

                Assert(!pMethodArgs->fAsync);
            }
            break;
        case WM_WORKERMSG_PREPAREFORSYNCCOMPLETED:
            Assert(pMethodArgs);
            fMethodCall = TRUE;

            if (pMethodArgs)
            {
                pMethodArgs->hr = E_UNEXPECTED;

                if (pThis->m_pSyncMgrSynchronizeCallback)
                {
                PREPAREFORSYNCCOMPLETEDMSG *pMsg = &(pMethodArgs->PrepareForSyncCompletedMsg);

                    Assert(msg == pMethodArgs->dwWorkerMsg);

                    pMethodArgs->hr =
                        pThis->m_pSyncMgrSynchronizeCallback->PrepareForSyncCompleted(
                                   pMsg->hr);
                }

                Assert(!pMethodArgs->fAsync);
            }
            break;
        case WM_WORKERMSG_SYNCHRONIZECOMPLETED:
            Assert(pMethodArgs);
            fMethodCall = TRUE;

            if (pMethodArgs)
            {
                pMethodArgs->hr = E_UNEXPECTED;

                if (pThis->m_pSyncMgrSynchronizeCallback)
                {
                SYNCHRONIZECOMPLETEDMSG *pMsg = &(pMethodArgs->SynchronizeCompletedMsg);

                    Assert(msg == pMethodArgs->dwWorkerMsg);

                    pMethodArgs->hr =
                        pThis->m_pSyncMgrSynchronizeCallback->SynchronizeCompleted(
                                   pMsg->hr);
                }

                Assert(!pMethodArgs->fAsync);
            }
            break;
        case WM_WORKERMSG_SHOWPROPERTIESCOMPLETED:
            Assert(pMethodArgs);
            fMethodCall = TRUE;

            if (pMethodArgs)
            {
                pMethodArgs->hr = E_UNEXPECTED;

                if (pThis->m_pSyncMgrSynchronizeCallback)
                {
                SHOWPROPERTIESCOMPLETEDMSG *pMsg = &(pMethodArgs->ShowPropertiesCompletedMsg);

                    Assert(msg == pMethodArgs->dwWorkerMsg);

                    pMethodArgs->hr =
                        pThis->m_pSyncMgrSynchronizeCallback->ShowPropertiesCompleted(
                                  pMsg->hr);
                }

                Assert(!pMethodArgs->fAsync);
            }
            break;
        case WM_WORKERMSG_SHOWERRORCOMPLETED:
            Assert(pMethodArgs);
            fMethodCall = TRUE;

            if (pMethodArgs)
            {
                pMethodArgs->hr = E_UNEXPECTED;

                if (pThis->m_pSyncMgrSynchronizeCallback)
                {
                SHOWERRORCOMPLETEDMSG *pMsg = &(pMethodArgs->ShowErrorCompletedMsg);

                    Assert(msg == pMethodArgs->dwWorkerMsg);

                    pMethodArgs->hr =
                        pThis->m_pSyncMgrSynchronizeCallback->ShowErrorCompleted(
                                   pMsg->hr,
                                   pMsg->cbNumItems,
                                   pMsg->pItemIDs
                                   );
                }

                Assert(!pMethodArgs->fAsync);
            }
            break;
        case WM_WORKERMSG_ENABLEMODELESS:
            Assert(pMethodArgs);
            fMethodCall = TRUE;

            if (pMethodArgs)
            {
                pMethodArgs->hr = E_UNEXPECTED;

                if (pThis->m_pSyncMgrSynchronizeCallback)
                {
                ENABLEMODELESSMSG *pMsg = &(pMethodArgs->EnableModelessMsg);

                    Assert(msg == pMethodArgs->dwWorkerMsg);

                    pMethodArgs->hr =
                        pThis->m_pSyncMgrSynchronizeCallback->EnableModeless(
                            pMsg->fEnable);
                }

                Assert(!pMethodArgs->fAsync);
            }
            break;
        case WM_WORKERMSG_LOGERROR:
            Assert(pMethodArgs);
            fMethodCall = TRUE;

            if (pMethodArgs)
            {
                pMethodArgs->hr = E_UNEXPECTED;

                if (pThis->m_pSyncMgrSynchronizeCallback)
                {
                LOGERRORMSG *pMsg = &(pMethodArgs->LogErrorMsg);

                    Assert(msg == pMethodArgs->dwWorkerMsg);

                    pMethodArgs->hr =
                        pThis->m_pSyncMgrSynchronizeCallback->LogError(
                                   pMsg->dwErrorLevel,
                                   pMsg->lpcErrorText,
                                   pMsg->lpSyncLogError);
                }

                Assert(!pMethodArgs->fAsync);
            }
            break;
        case WM_WORKERMSG_DELETELOGERROR:
            Assert(pMethodArgs);
            fMethodCall = TRUE;

            if (pMethodArgs)
            {
                pMethodArgs->hr = E_UNEXPECTED;

                if (pThis->m_pSyncMgrSynchronizeCallback)
                {
                DELETELOGERRORMSG *pMsg = &(pMethodArgs->DeleteLogErrorMsg);

                    Assert(msg == pMethodArgs->dwWorkerMsg);

                    pMethodArgs->hr =
                        pThis->m_pSyncMgrSynchronizeCallback->DeleteLogError(
                                   pMsg->ErrorID,
                                   pMsg->dwReserved);
                }

                Assert(!pMethodArgs->fAsync);
            }
            break;
        case WM_WORKERMSG_ESTABLISHCONNECTION:
            Assert(pMethodArgs);
            fMethodCall = TRUE;

            if (pMethodArgs)
            {
                pMethodArgs->hr = E_UNEXPECTED;

                if (pThis->m_pSyncMgrSynchronizeCallback)
                {
                ESTABLISHCONNECTIONMSG *pMsg = &(pMethodArgs->EstablishConnectionMsg);

                    Assert(msg == pMethodArgs->dwWorkerMsg);

                    pMethodArgs->hr =
                        pThis->m_pSyncMgrSynchronizeCallback->EstablishConnection(
                                   pMsg->lpwszConnection,
                                   pMsg->dwReserved
                                   );
                }

                Assert(!pMethodArgs->fAsync);
            }
            break;
    default:
        break;
    }

    // if this was a method call and async then free methodArgs,
    // on synchronous calls up to the caller to free.
    if (fMethodCall && pMethodArgs && pMethodArgs->fAsync)
    {
        FREE(pMethodArgs);
    }

    return DefWindowProc(hWnd, msg, wParam, lParam);
}





//+---------------------------------------------------------------------------
//
//  Function:   WorkerThreadWndProc, private
//
//  Synopsis:   WndProc for hwnd on the worker thread.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LRESULT CALLBACK  WorkerThreadWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{
CSyncMgrHandler *pThis = (CSyncMgrHandler *) GetWindowLong(hWnd, DWL_THREADWNDPROCCLASS);
METHODARGS *pMethodArgs = (METHODARGS *) lParam;
BOOL fMethodCall = FALSE;

    switch (msg)
    {
    case WM_CREATE :
        {
        CREATESTRUCT *pCreateStruct = (CREATESTRUCT *) lParam;

        SetWindowLong(hWnd, DWL_THREADWNDPROCCLASS,(LONG) pCreateStruct->lpCreateParams );
        pThis = (CSyncMgrHandler *) pCreateStruct->lpCreateParams ;
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0); // shut down this thread.
        break;
    case WM_WORKERMSG_SHOWPROPERTIES:
            Assert(pMethodArgs);
            fMethodCall = TRUE;
            if (pMethodArgs)
            {
            SHOWPROPERTIESMSG *pShowPropertiesMsg = &(pMethodArgs->ShowPropertiesMsg);

                Assert(WM_WORKERMSG_SHOWPROPERTIES == pMethodArgs->dwWorkerMsg);

                pThis->ShowPropertiesCall(pShowPropertiesMsg->hWndParent,
                                                pShowPropertiesMsg->ItemID);


                Assert(pMethodArgs->fAsync);
            }

        break;
    case WM_WORKERMSG_PREPFORSYNC:

            Assert(pMethodArgs);
            fMethodCall = TRUE;

            if (pMethodArgs)
            {
            PREPAREFORSYNCMSG *pPrepareForSyncMsg = &(pMethodArgs->PrepareForSyncMsg);

                Assert(WM_WORKERMSG_PREPFORSYNC == pMethodArgs->dwWorkerMsg);

            pThis->PrepareForSyncCall(pPrepareForSyncMsg->cbNumItems,
                           pPrepareForSyncMsg->pItemIDs,
               pPrepareForSyncMsg->hWndParent,
                           pPrepareForSyncMsg->dwReserved);

                if (pPrepareForSyncMsg->pItemIDs)
                {
                    FREE(pPrepareForSyncMsg->pItemIDs);
                }

                Assert(pMethodArgs->fAsync);
            }
        break;
    case WM_WORKERMSG_SYNCHRONIZE:
            Assert(pMethodArgs);
            fMethodCall = TRUE;
            if (pMethodArgs)
            {
            SYNCHRONIZEMSG *pSynchronizeMsg = &(pMethodArgs->SynchronizeMsg);

                Assert(WM_WORKERMSG_SYNCHRONIZE == pMethodArgs->dwWorkerMsg);
                Assert(pMethodArgs->fAsync);
                pThis->SynchronizeCall(pSynchronizeMsg->hWndParent);

            }

        break;
    case WM_WORKERMSG_SHOWERROR:
            Assert(pMethodArgs);

            fMethodCall = TRUE;
            if (pMethodArgs)
            {
            SHOWERRORMSG *pShowErrorMsg = &(pMethodArgs->ShowErrorMsg);

                Assert(pMethodArgs->fAsync);
                Assert(WM_WORKERMSG_SHOWERROR == pMethodArgs->dwWorkerMsg);

                pThis->ShowErrorCall(pShowErrorMsg->hWndParent,
                                                pShowErrorMsg->ErrorID);

            }

        break;
        case WM_WORKERMSG_RELEASE:
            DestroyWindow(hWnd);
            break;
    default:
        break;
    }

    // if this was a method call and async then free methodArgs,
    // on synchronous calls up to the caller to free.
    if (fMethodCall && pMethodArgs && pMethodArgs->fAsync)
    {
        FREE(pMethodArgs);
    }

    return DefWindowProc(hWnd, msg, wParam, lParam);
}


//+---------------------------------------------------------------------------
//
//  Function:   WorkerThread, private
//
//  Synopsis:   ThreadProc for WorkerThread.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

DWORD WINAPI WorkerThread( LPVOID lpArg )
{
MSG msg;
HRESULT hr;
HRESULT hrCoInitialize;
WorkerThreadArgs *pThreadArgs = (WorkerThreadArgs *) lpArg;
HWND hwndWorker;

   pThreadArgs->hr = NOERROR;

   hrCoInitialize = CoInitialize(NULL);

   // need to do a PeekMessage and then set an event to make sure
   // a message loop is created before the first PostMessage is sent.

   PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

   // initialize the dialog box before returning to main thread.
   if (FAILED(hrCoInitialize) )
   {
    pThreadArgs->hr = E_OUTOFMEMORY;
   }
   else
   {

    hwndWorker = CreateWindowEx(0,
              SZ_SAMPLESYNCMGRWORKERWNDCLASS,
              TEXT(""),
              // must use WS_POPUP so the window does not get
              // assigned a hot key by user.
              (WS_DISABLED | WS_POPUP),
              CW_USEDEFAULT,
              CW_USEDEFAULT,
              CW_USEDEFAULT,
              CW_USEDEFAULT,
              NULL,
              NULL,
              g_hmodThisDll,
              pThreadArgs->pThis);

        pThreadArgs->hwnd = hwndWorker;
    pThreadArgs->hr =  hwndWorker ? NOERROR : E_UNEXPECTED;
    }

   hr = pThreadArgs->hr;

   // let the caller know the thread is done initializing.
   if (pThreadArgs->hEvent)
     SetEvent(pThreadArgs->hEvent);


   if (NOERROR == hr)
   {
       // sit in loop receiving messages.
       while (GetMessage(&msg, NULL, 0, 0))
       {
         TranslateMessage(&msg);
         DispatchMessage(&msg);
    }
   }

   if (SUCCEEDED(hrCoInitialize))
       CoUninitialize();

   return 0;
}

BOOL g_fWndRegistered = FALSE;

BOOL RegisterHandlerWndClasses(void)
{

    if (!g_fWndRegistered)
    {
    ATOM aWndClass;
    WNDCLASS        xClass;

        // register class for window created on handler thread.
    xClass.style         = 0;
    xClass.lpfnWndProc   = HandlerThreadWndProc;
    xClass.cbClsExtra    = 0;

    xClass.cbWndExtra    = sizeof(DWORD); // room for class this ptr
    xClass.hInstance     = g_hmodThisDll;
    xClass.hIcon         = NULL;
    xClass.hCursor       = NULL;
    xClass.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
    xClass.lpszMenuName  = NULL;
    xClass.lpszClassName = SZ_SAMPLESYNCMGRHANDLERWNDCLASS;

    aWndClass = RegisterClass( &xClass );

        // Register windows class.we need for handling thread communication
    xClass.style         = 0;
    xClass.lpfnWndProc   = WorkerThreadWndProc;
    xClass.cbClsExtra    = 0;

    xClass.cbWndExtra    = sizeof(DWORD); // room for class this ptr
    xClass.hInstance     = g_hmodThisDll;
    xClass.hIcon         = NULL;
    xClass.hCursor       = NULL;
    xClass.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
    xClass.lpszMenuName  = NULL;
    xClass.lpszClassName = SZ_SAMPLESYNCMGRWORKERWNDCLASS;

    aWndClass = RegisterClass( &xClass );



        g_fWndRegistered = TRUE;
    }


    return g_fWndRegistered;


}


// implementation of callback wrappers so all callback calls are sent to
// syncmgr on the thread we were created on. We only implement the
// methods we call.

CCallbackWrapper::CCallbackWrapper(HWND hwndCallback)
{

    Assert(hwndCallback);

    m_hwndCallback = hwndCallback;
    m_cRef = 1;

}

CCallbackWrapper::~CCallbackWrapper()
{
    m_hwndCallback = NULL;

    Assert(0 == m_cRef);
}


//IUnknown methods
STDMETHODIMP CCallbackWrapper::QueryInterface(REFIID, LPVOID FAR *)
{
    return E_NOTIMPL;
}

STDMETHODIMP_(ULONG) CCallbackWrapper::AddRef()
{
    ++m_cRef;

    return m_cRef;
}

STDMETHODIMP_(ULONG) CCallbackWrapper::Release()
{
DWORD cRefs;

    --m_cRef;

    cRefs = m_cRef;

    if (0 == m_cRef)
    {
        delete this;
    }

    return cRefs;
}

// Callback methods.
STDMETHODIMP CCallbackWrapper::Progress(REFSYNCMGRITEMID ItemID,LPSYNCMGRPROGRESSITEM lpSyncProgressItem)
{
METHODARGS MethodArgs;

    MethodArgs.fAsync = FALSE;
    MethodArgs.hr = E_UNEXPECTED;


    MethodArgs.dwWorkerMsg = WM_WORKERMSG_PROGRESS;
    MethodArgs.ProgressMsg.ItemID = ItemID;
    MethodArgs.ProgressMsg.lpSyncProgressItem = lpSyncProgressItem;

    if (m_hwndCallback)
    {
        SendMessage(m_hwndCallback,MethodArgs.dwWorkerMsg,0,(LPARAM) &MethodArgs);
    }

    return MethodArgs.hr;
}

STDMETHODIMP CCallbackWrapper::PrepareForSyncCompleted(HRESULT hr)
{
METHODARGS MethodArgs;

    MethodArgs.fAsync = FALSE;
    MethodArgs.hr = E_UNEXPECTED;

    MethodArgs.dwWorkerMsg = WM_WORKERMSG_PREPAREFORSYNCCOMPLETED;
    MethodArgs.PrepareForSyncCompletedMsg.hr = hr;

    if (m_hwndCallback)
    {
        SendMessage(m_hwndCallback,MethodArgs.dwWorkerMsg,0,(LPARAM) &MethodArgs);
    }

    return MethodArgs.hr;
}

STDMETHODIMP CCallbackWrapper::SynchronizeCompleted(HRESULT hr)
{
METHODARGS MethodArgs;

    MethodArgs.fAsync = FALSE;
    MethodArgs.hr = E_UNEXPECTED;

    MethodArgs.dwWorkerMsg = WM_WORKERMSG_SYNCHRONIZECOMPLETED;
    MethodArgs.SynchronizeCompletedMsg.hr = hr;

    if (m_hwndCallback)
    {
        SendMessage(m_hwndCallback,MethodArgs.dwWorkerMsg,0,(LPARAM) &MethodArgs);
    }

    return MethodArgs.hr;
}

STDMETHODIMP CCallbackWrapper::ShowPropertiesCompleted(HRESULT hr)
{
METHODARGS MethodArgs;

    MethodArgs.fAsync = FALSE;
    MethodArgs.hr = E_UNEXPECTED;

    MethodArgs.dwWorkerMsg = WM_WORKERMSG_SHOWPROPERTIESCOMPLETED;
    MethodArgs.ShowPropertiesCompletedMsg.hr = hr;

    if (m_hwndCallback)
    {
        SendMessage(m_hwndCallback,MethodArgs.dwWorkerMsg,0,(LPARAM) &MethodArgs);
    }

    return MethodArgs.hr;

}

STDMETHODIMP CCallbackWrapper::ShowErrorCompleted(HRESULT hr,ULONG cbNumItems,SYNCMGRITEMID *pItemIDs)
{
METHODARGS MethodArgs;

    MethodArgs.fAsync = FALSE;
    MethodArgs.hr = E_UNEXPECTED;

    MethodArgs.dwWorkerMsg = WM_WORKERMSG_SHOWERRORCOMPLETED;
    MethodArgs.ShowErrorCompletedMsg.hr = hr;
    MethodArgs.ShowErrorCompletedMsg.cbNumItems = cbNumItems;
    MethodArgs.ShowErrorCompletedMsg.pItemIDs = pItemIDs;

    if (m_hwndCallback)
    {
        SendMessage(m_hwndCallback,MethodArgs.dwWorkerMsg,0,(LPARAM) &MethodArgs);
    }

    return MethodArgs.hr;
}

STDMETHODIMP CCallbackWrapper::EnableModeless(BOOL fEnable)
{
METHODARGS MethodArgs;

    MethodArgs.fAsync = FALSE;
    MethodArgs.hr = E_UNEXPECTED;

    MethodArgs.dwWorkerMsg = WM_WORKERMSG_ENABLEMODELESS;
    MethodArgs.EnableModelessMsg.fEnable = fEnable;

    if (m_hwndCallback)
    {
        SendMessage(m_hwndCallback,MethodArgs.dwWorkerMsg,0,(LPARAM) &MethodArgs);
    }

    return MethodArgs.hr;
}

STDMETHODIMP CCallbackWrapper::LogError(DWORD dwErrorLevel,const WCHAR *lpcErrorText,LPSYNCMGRLOGERRORINFO lpSyncLogError)
{
METHODARGS MethodArgs;

    MethodArgs.fAsync = FALSE;
    MethodArgs.hr = E_UNEXPECTED;


    MethodArgs.dwWorkerMsg = WM_WORKERMSG_LOGERROR;
    MethodArgs.LogErrorMsg.dwErrorLevel = dwErrorLevel;
    MethodArgs.LogErrorMsg.lpcErrorText = lpcErrorText;
    MethodArgs.LogErrorMsg.lpSyncLogError = lpSyncLogError;

    if (m_hwndCallback)
    {
        SendMessage(m_hwndCallback,MethodArgs.dwWorkerMsg,0,(LPARAM) &MethodArgs);
    }

    return MethodArgs.hr;
}

STDMETHODIMP CCallbackWrapper::DeleteLogError(REFSYNCMGRERRORID ErrorID,DWORD dwReserved)
{
METHODARGS MethodArgs;

    MethodArgs.fAsync = FALSE;
    MethodArgs.hr = E_UNEXPECTED;


    MethodArgs.dwWorkerMsg = WM_WORKERMSG_DELETELOGERROR;
    MethodArgs.DeleteLogErrorMsg.ErrorID = ErrorID;
    MethodArgs.DeleteLogErrorMsg.dwReserved = dwReserved;

    if (m_hwndCallback)
    {
        SendMessage(m_hwndCallback,MethodArgs.dwWorkerMsg,0,(LPARAM) &MethodArgs);
    }

    return MethodArgs.hr;
}

STDMETHODIMP CCallbackWrapper::EstablishConnection( WCHAR const * lpwszConnection, DWORD dwReserved)
{
METHODARGS MethodArgs;

    MethodArgs.fAsync = FALSE;
    MethodArgs.hr = E_UNEXPECTED;


    MethodArgs.dwWorkerMsg = WM_WORKERMSG_ESTABLISHCONNECTION;
    MethodArgs.EstablishConnectionMsg.lpwszConnection = lpwszConnection;
    MethodArgs.EstablishConnectionMsg.dwReserved = dwReserved;

    if (m_hwndCallback)
    {
        SendMessage(m_hwndCallback,MethodArgs.dwWorkerMsg,0,(LPARAM) &MethodArgs);
    }

    return MethodArgs.hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\helper.h ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#ifndef _HELPERSTUFF_
#define _HELPERSTUFF_

int CalcListViewWidth(HWND hwndList,int iDefault);
BOOL IsValidDir(TCHAR *pDirName);
TCHAR *FormatDateTime(FILETIME *pft,TCHAR *pszDatetimeBuf,DWORD cbBufSize);

LPWSTR lstrcpyX(LPWSTR lpString1,LPCWSTR lpString2);

#undef lstrcpyW
#define lstrcpyW lstrcpyX

#endif // _HELPERSTUFF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\helper.cpp ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

// just some stuff to help out.

#include "precomp.h"

//+---------------------------------------------------------------------------
//
//  Function:   CalcListViewWidth, public
//
//  Synopsis:   Given a ListView determines width of client size
//              subtracting off the scrollbar.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

int CalcListViewWidth(HWND hwndList,int iDefault)
{
NONCLIENTMETRICSA metrics;
RECT rcClientRect;


    metrics.cbSize = sizeof(metrics);

    // explicitly ask for ANSI version of SystemParametersInfo since we just
    // care about the ScrollWidth and don't want to conver the LOGFONT info.
    if (GetClientRect(hwndList,&rcClientRect)
        && SystemParametersInfoA(SPI_GETNONCLIENTMETRICS,sizeof(metrics),(PVOID) &metrics,0))
    {
        // subtract off scroll bar distance
        rcClientRect.right -= (metrics.iScrollWidth);
    }
    else
    {
        rcClientRect.right = iDefault;  // if fail, use default
    }


    return rcClientRect.right;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsValidDir, public
//
//  Synopsis:   Determines pDirName is a valid fullpath to a directory.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL IsValidDir(TCHAR *pDirName)
{
BOOL fReturn = FALSE;
HANDLE hFind;
WIN32_FIND_DATA finddata;

    hFind = FindFirstFile(pDirName, &finddata);

    if (hFind != (HANDLE) -1)
    {

       fReturn = (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? TRUE : FALSE;
       FindClose(hFind);
    }

    return fReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   FormatDateTime, public
//
//  Synopsis:   Formats the filetime into a string.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

TCHAR *FormatDateTime(FILETIME *pft,TCHAR *pszDatetimeBuf,DWORD cbBufSize)
{
TCHAR * pDateTime = pszDatetimeBuf;
int cchWritten;
SYSTEMTIME sysTime;
FILETIME ftLocal;

  FileTimeToLocalFileTime(pft,&ftLocal);
  FileTimeToSystemTime(&ftLocal,&sysTime);

    // insert date in form of date<space>hour
    *pDateTime = NULL;

    // want to insert the date
    if (cchWritten = GetDateFormat(NULL,DATE_SHORTDATE,&sysTime,NULL,pDateTime,cbBufSize))
    {
        pDateTime += (cchWritten -1); // move number of characters written. (cchWritten includes the NULL)
        *pDateTime = TEXT(' '); // pDateTime is now ponting at the NULL character.
        ++pDateTime;

        // no try to get the hours if fails we make sure that the last char is NULL;
        if (!GetTimeFormat(NULL,TIME_NOSECONDS,&sysTime,NULL,pDateTime,cbBufSize - cchWritten))
        {
            *pDateTime = NULL;
        }
    }


    return pszDatetimeBuf;
}



//+---------------------------------------------------------------------------
//
//  Function:   lstrcpyX, public
//
//  Synopsis:   Implements WideChar strcpy so can use on Win9x
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LPWSTR lstrcpyX(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    LPWSTR lpDest = lpString1;

    Assert(lpString1);
    Assert(lpString2);

    while( *lpDest++ = *lpString2++ )
        ;
    return lpString1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\precomp.h ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#include <objbase.h>
#include <windows.h>
#include <shlobj.h>
#include <commctrl.h>
#include <advpub.h>

#include <mobsync.h>

#include "resource.h"

#include "debug.h"
#include "alloc.h"
#include "critsect.h"
#include "helper.h"
#include "enum.h"

#include "guid.h"
#include "settings.h"
#include "cfact.h"
#include "reg.h"
#include "dllmain.h"

#include "handler.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\reg.h ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------


#ifndef _REGROUTINES_
#define _REGROUTINES_


#define GUID_SIZE 128
#define MAX_STRING_LENGTH 256

BOOL SetRegKeyValue(HKEY hKeyTop,LPTSTR pszKey,LPTSTR pszSubkey,LPTSTR pszValue);
BOOL AddRegNamedValue(LPTSTR pszKey,LPTSTR pszSubkey,LPTSTR pszValueName,LPTSTR pszValue);

HKEY CreateHandlerPrefKey(CLSID CLSIDServer);

STDMETHODIMP Reg_SetItemSettingsForHandlerItem(CLSID CLSIDServer,SYNCMGRITEMID ItemID,LPSAMPLEITEMSETTINGS pSampleItemSettings);
STDMETHODIMP Reg_GetItemSettingsForHandlerItem(HKEY hKeyHandler,SYNCMGRITEMID ItemID,LPSAMPLEITEMSETTINGS pSampleItemSettings);
STDMETHODIMP Reg_DeleteItemIdForHandlerItem(CLSID CLSIDServer,SYNCMGRITEMID ItemID);


#endif // _REGROUTINES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\reg.cpp ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

#include "precomp.h"

#define HANDLERITEMSKEY TEXT("\\HandlerItems")

#define HANDLERVALUE_DIR1           TEXT("Dir1")
#define HANDLERVALUE_DIR2           TEXT("Dir2")
#define HANDLERVALUE_DISPLAYNAME    TEXT("DisplayName")
#define HANDLERVALUE_FILETIME           TEXT("TimeStamp")
#define HANDLERVALUE_RECURSIVE           TEXT("Recursive")


//+---------------------------------------------------------------------------
//
//  Function:   SetRegKeyValue, private
//
//  Synopsis:   Internal utility function to set a Key, Subkey, and value
//              in the system Registry under HKEY_CLASSES_ROOT.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL SetRegKeyValue(
       HKEY hKeyTop,
       LPTSTR pszKey,
       LPTSTR pszSubkey,
       LPTSTR pszValue)
{
  BOOL bOk = FALSE;
  LONG ec;
  HKEY hKey;
  TCHAR szKey[MAX_STRING_LENGTH];

  lstrcpy(szKey, pszKey);

  if (NULL != pszSubkey)
  {
    lstrcat(szKey, TEXT("\\"));
    lstrcat(szKey, pszSubkey);
  }

  ec = RegCreateKeyEx(
         hKeyTop,
         szKey,
         0,
         NULL,
         REG_OPTION_NON_VOLATILE,
         KEY_READ | KEY_WRITE,
         NULL,
         &hKey,
         NULL);

  if (NULL != pszValue && ERROR_SUCCESS == ec)
  {
    ec = RegSetValueEx(
           hKey,
           NULL,
           0,
           REG_SZ,
           (BYTE *)pszValue,
           (lstrlen(pszValue)+1)*sizeof(TCHAR));
    if (ERROR_SUCCESS == ec)
      bOk = TRUE;
    RegCloseKey(hKey);
  }

  return bOk;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetRegKeyValue, private
//
//  Synopsis:   Internal utility function to get a Key value
//              in the system Registry.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LRESULT GetRegKeyValue(HKEY hkeyParent, LPCTSTR pcszSubKey,
                                   LPCTSTR pcszValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen)
{
LONG lResult;
HKEY hkeySubKey;

    lResult = RegOpenKeyEx(hkeyParent, pcszSubKey, 0, KEY_QUERY_VALUE,
                           &hkeySubKey);

    if (lResult == ERROR_SUCCESS)
    {
        LONG lResultClose;

        lResult = RegQueryValueEx(hkeySubKey, pcszValue, NULL, pdwValueType,
                                  pbyteBuf, pdwcbBufLen);

        lResultClose = RegCloseKey(hkeySubKey);

        if (lResult == ERROR_SUCCESS)
            lResult = lResultClose;
    }

    return(lResult);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetRegKeyValue, private
//
//  Synopsis:   Internal utility function to add a named data value to an
//              existing Key (with optional Subkey) in the system Registry
//              under HKEY_CLASSES_ROOT.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL AddRegNamedValue(
       LPTSTR pszKey,
       LPTSTR pszSubkey,
       LPTSTR pszValueName,
       LPTSTR pszValue)
{
  BOOL bOk = FALSE;
  LONG ec;
  HKEY hKey;
  TCHAR szKey[MAX_STRING_LENGTH];

  lstrcpy(szKey, pszKey);

  if (NULL != pszSubkey)
  {
    lstrcat(szKey, TEXT("\\"));
    lstrcat(szKey, pszSubkey);
  }

  ec = RegOpenKeyEx(
         HKEY_CLASSES_ROOT,
         szKey,
         0,
         KEY_READ | KEY_WRITE,
         &hKey);

  if (NULL != pszValue && ERROR_SUCCESS == ec)
  {
    ec = RegSetValueEx(
           hKey,
           pszValueName,
           0,
           REG_SZ,
           (BYTE *)pszValue,
           (lstrlen(pszValue)+1)*sizeof(TCHAR));
    if (ERROR_SUCCESS == ec)
      bOk = TRUE;
    RegCloseKey(hKey);
  }

  return bOk;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegGetTimeStamp, private
//
//  Synopsis:   Reads in TimeStamp Value under the specified HKEY
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL RegGetTimeStamp(HKEY hKey, FILETIME *pft)
{
DWORD dwType;
FILETIME ft;
LONG lr;
DWORD dwSize = sizeof(FILETIME);

    Assert(pft);

    lr = RegQueryValueEx( hKey,
                          HANDLERVALUE_FILETIME,
                          NULL,
                          &dwType,
                          (BYTE *)&ft,
                          &dwSize );


    if ( lr == ERROR_SUCCESS )
    {
        Assert( dwSize == sizeof(FILETIME) && dwType == REG_BINARY );
        *pft = ft;
    }
    else
    {
        // set the filetime to way back when to
        // any compares will just say older instead
        // of having to check success code
        (*pft).dwLowDateTime = 0;
        (*pft).dwHighDateTime = 0;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegWriteTimeStamp, private
//
//  Synopsis:   Writes out TimeStamp Value under the specified HKEY
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL RegWriteTimeStamp(HKEY hkey,FILETIME *pft)
{
LRESULT lr;

    lr = RegSetValueEx( hkey,
            HANDLERVALUE_FILETIME,
            NULL,
            REG_BINARY,
            (BYTE *) pft,
            sizeof(FILETIME) );

    return (ERROR_SUCCESS == lr) ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateHandlerPrefKey, private
//
//  Synopsis:   given a server clsid does work of openning up the
//              handler perf key
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

HKEY CreateHandlerPrefKey(CLSID CLSIDServer)
{
TCHAR szFullKeyName[MAX_PATH];
TCHAR szGUID[GUID_SIZE+1];
LONG lResult = -1;
HKEY hKey;

#ifdef _UNICODE
  StringFromGUID2(CLSIDServer, szGUID, GUID_SIZE);
#else
  BOOL fUsedDefaultChar;
  WCHAR wszID[GUID_SIZE+1];

  // convert clsidServer
  StringFromGUID2(CLSIDServer, wszID, GUID_SIZE);

  WideCharToMultiByte(CP_ACP ,0,
    wszID,-1,szGUID,GUID_SIZE + 1,
    NULL,&fUsedDefaultChar);

#endif // _UNICODE

  lstrcpy(szFullKeyName, TEXT("CLSID\\"));
  lstrcat(szFullKeyName, szGUID);
  lstrcat(szFullKeyName,HANDLERITEMSKEY);

  // try to open handler items keyfs
  lResult = RegCreateKeyEx(
         HKEY_CLASSES_ROOT,
         szFullKeyName,
         0,NULL,REG_OPTION_NON_VOLATILE,
         KEY_READ | KEY_WRITE,NULL,
         &hKey,NULL);

  return (ERROR_SUCCESS == lResult) ? hKey : NULL;

}

//+---------------------------------------------------------------------------
//
//  Function:   CreateHandlerItemPrefKey, private
//
//  Synopsis:   creates perf key for specified ItemID
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

HKEY CreateHandlerItemPrefKey(HKEY hkeyHandler,SYNCMGRITEMID ItemID)
{
TCHAR szGUID[GUID_SIZE+1];
LONG lResult = -1;
HKEY hKeyItem;

 // try to open/create item key
    #ifdef _UNICODE
      StringFromGUID2(ItemID, szGUID, GUID_SIZE);
    #else
      BOOL fUsedDefaultChar;
      WCHAR wszID[GUID_SIZE+1];

      // convert clsidServer
      StringFromGUID2(ItemID, wszID, GUID_SIZE);

      WideCharToMultiByte(CP_ACP ,0,
        wszID,-1,szGUID,GUID_SIZE + 1,
        NULL,&fUsedDefaultChar);

    #endif // _UNICODE

  // try to open handler items keyfs
   lResult = RegCreateKeyEx(
         hkeyHandler,
         szGUID,
         0,NULL,REG_OPTION_NON_VOLATILE,
         KEY_READ | KEY_WRITE,NULL,
         &hKeyItem,NULL);

  return (ERROR_SUCCESS == lResult) ? hKeyItem : NULL;

}


//+---------------------------------------------------------------------------
//
//  Function:   CreateHandlerItemPrefKey, private
//
//  Synopsis:   creates perf key for specified ItemID
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

HKEY CreateHandlerItemPrefKey(CLSID CLSIDServer,SYNCMGRITEMID ItemID)
{
HKEY hKeyHandler;
HKEY hKeyItem;

  if (hKeyHandler = CreateHandlerPrefKey(CLSIDServer))
  {
      hKeyItem = CreateHandlerItemPrefKey(hKeyHandler,ItemID);

      RegCloseKey(hKeyHandler); // close handler key.
  }

  return hKeyItem;

}

//+---------------------------------------------------------------------------
//
//  Function:   Reg_GetItemSettingsForHandlerItem, public
//
//  Synopsis:   Returns settings for the specified Item.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP Reg_GetItemSettingsForHandlerItem(HKEY hKeyHandler,SYNCMGRITEMID ItemID,
                                         LPSAMPLEITEMSETTINGS pSampleItemSettings)
{
HKEY hKey;
TCHAR *pDisplayName;
DWORD dwType;
DWORD dwSize;

    hKey = CreateHandlerItemPrefKey(hKeyHandler,ItemID);
    if (!hKey)
    {
        Assert(hKey);
        return E_UNEXPECTED;
    }


    pSampleItemSettings->syncmgrItem.ItemID = ItemID;


   // write out our info.
    #ifdef _UNICODE
        pDisplayName = pSampleItemSettings->syncmgrItem.wszItemName;
    #else
      char szDisplayName[MAX_SYNCMGRITEMNAME];

      pDisplayName = szDisplayName;
    #endif // _UNICODE

    // read in the values,
    dwType = REG_SZ;
    dwSize = MAX_SYNCMGRITEMNAME*sizeof(TCHAR);
    RegQueryValueEx( hKey,
                          HANDLERVALUE_DISPLAYNAME,
                          NULL,
                          &dwType,
                          (BYTE *) pDisplayName,
                          &dwSize);

    #ifndef _UNICODE

      MultiByteToWideChar(CP_ACP, 0,
                            pDisplayName,-1,
                            pSampleItemSettings->syncmgrItem.wszItemName,
                           MAX_SYNCMGRITEMNAME);

    #endif

    dwType = REG_SZ;
    dwSize = MAX_PATH*sizeof(TCHAR);
    RegQueryValueEx( hKey,
                          HANDLERVALUE_DIR1,
                          NULL,
                          &dwType,
                          (BYTE *) pSampleItemSettings->dir1,
                          &dwSize);
    dwType = REG_SZ;
    dwSize = MAX_PATH*sizeof(TCHAR);
    RegQueryValueEx( hKey,
                          HANDLERVALUE_DIR2,
                          NULL,
                          &dwType,
                          (BYTE *) pSampleItemSettings->dir2,
                          &dwSize);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    RegQueryValueEx( hKey,
                          HANDLERVALUE_RECURSIVE,
                          NULL,
                          &dwType,
                          (BYTE *) &(pSampleItemSettings->fRecursive),
                          &dwSize);

    RegGetTimeStamp(hKey,&(pSampleItemSettings->syncmgrItem.ftLastUpdate));



    RegCloseKey(hKey);

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   Reg_SetItemSettingsForHandlerItem, public
//
//  Synopsis:   Writes out settings for a handler item.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP Reg_SetItemSettingsForHandlerItem(CLSID CLSIDServer,SYNCMGRITEMID ItemID,LPSAMPLEITEMSETTINGS pSampleItemSettings)
{
HKEY hKey;
TCHAR *pDisplayName;

    hKey = CreateHandlerItemPrefKey(CLSIDServer,ItemID);
    if (!hKey)
    {
        Assert(hKey);
        return E_UNEXPECTED;
    }

   // write out our info.
    #ifdef _UNICODE
        pDisplayName = pSampleItemSettings->syncmgrItem.wszItemName;
    #else
      BOOL fUsedDefaultChar;
      char szDisplayName[MAX_SYNCMGRITEMNAME];

      WideCharToMultiByte(CP_ACP ,0,
        pSampleItemSettings->syncmgrItem.wszItemName,-1,
            szDisplayName,MAX_SYNCMGRITEMNAME,
        NULL,&fUsedDefaultChar);

      pDisplayName = szDisplayName;
    #endif // _UNICODE

    RegSetValueEx(hKey,HANDLERVALUE_DISPLAYNAME,
           0,
           REG_SZ,
           (BYTE *) pDisplayName,
           (lstrlen(pDisplayName) + 1)*sizeof(TCHAR));


    RegSetValueEx(hKey,HANDLERVALUE_DIR1,
           0,
           REG_SZ,
           (BYTE *) pSampleItemSettings->dir1,
           (lstrlen(pSampleItemSettings->dir1) + 1)*sizeof(TCHAR));

    RegSetValueEx(hKey,HANDLERVALUE_DIR2,
           0,
           REG_SZ,
           (BYTE *) pSampleItemSettings->dir2,
           (lstrlen(pSampleItemSettings->dir2) + 1)*sizeof(TCHAR));

    RegSetValueEx(hKey,HANDLERVALUE_RECURSIVE,
           0,
           REG_DWORD,
           (BYTE *) &(pSampleItemSettings->fRecursive),
           sizeof(DWORD));

    RegWriteTimeStamp(hKey,&(pSampleItemSettings->syncmgrItem.ftLastUpdate));

    RegCloseKey(hKey);

   return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   Reg_DeleteItemIdForHandlerItem, public
//
//  Synopsis:   Deletes an Items preferences from the registry..
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP Reg_DeleteItemIdForHandlerItem(CLSID CLSIDServer,SYNCMGRITEMID ItemID)
{
HKEY hKeyHandler;

    if (hKeyHandler = CreateHandlerPrefKey( CLSIDServer))
    {
    TCHAR szGUID[GUID_SIZE+1];

        #ifdef _UNICODE
          StringFromGUID2(ItemID, szGUID, GUID_SIZE);
        #else
          BOOL fUsedDefaultChar;
          WCHAR wszID[GUID_SIZE+1];

          // convert clsidServer
          StringFromGUID2(ItemID, wszID, GUID_SIZE);

          WideCharToMultiByte(CP_ACP ,0,
            wszID,-1,szGUID,GUID_SIZE + 1,
            NULL,&fUsedDefaultChar);

         #endif // _UNICODE

        RegDeleteKey(hKeyHandler,szGUID);

        RegCloseKey(hKeyHandler);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
// Used by Handler.rc
//
#define IDI_SAMPLEHANDLERICON           129
#define IDI_SAMPLEHANDLERITEMICON       130
#define IDD_CONFIGDIALOG                200
#define IDC_CONFIGDIALOG_ITEMLIST       201
#define IDC_CONFIGDIALOG_CONFIGTEXT     202
#define IDC_CONFIGDIALOG_ADD            203
#define IDC_CONFIGDIALOG_REMOVE         204
#define IDC_CONFIGDIALOG_EDIT           205
#define IDC_CONFIGDIALOG_SUMMARYTEXT    206

#define  IDD_ITEMCONFIGDIALOG                   300
#define  IDC_ITEMCONFIGDIALOG_STATIC_DISPLAYNAME    301
#define  IDC_ITEMCONFIGDIALOG_EDIT_DISPLAYNAME      302
#define  IDC_ITEMCONFIGDIALOG_STATIC_DIR1NAME       303
#define  IDC_ITEMCONFIGDIALOG_EDIT_DIR1NAME         304
#define  IDC_ITEMCONFIGDIALOG_STATIC_DIR2NAME       305
#define  IDC_ITEMCONFIGDIALOG_EDIT_DIR2NAME         306
#define  IDC_ITEMCONFIGDIALOG_INCLUDESUBDIRS        307

#define  IDS_CONFIG_TAB             500
#define  IDS_CONFIG_TITLE           501
#define  IDS_ITEMCONFIG_TAB         502

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        301
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\settings.h ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------


#ifndef _SAMPLESETTINGS
#define _SAMPLESETTINGS

class CSettings;
class CSyncMgrHandler;

// setting information that is given out publicly
typedef struct _tagHANDLERITEMSETTINGS
{
    // all the info we need to perform a sync.
    GUID ItemID;
    TCHAR szItemName[MAX_SYNCMGRITEMNAME];
    TCHAR dir1[MAX_PATH];
    TCHAR dir2[MAX_PATH];
    BOOL fRecursive;
    FILETIME ft;
} HANDLERITEMSETTINGS;
typedef HANDLERITEMSETTINGS *LPHANDLERITEMSETTINGS;


// private settings information.

// structure for enumerator items. first item is the GENERICITEM so
// can use the gerneric enumerator class.
// structure passed as lParam to configuration dialog

typedef struct _tagSAMPLEITEMSETTINGS
{
    GENERICITEM  genericItem;
    SYNCMGRITEM syncmgrItem; // item as passed in enumerator.

    // handler specific data
    TCHAR dir1[MAX_PATH];
    TCHAR dir2[MAX_PATH];
    BOOL fRecursive;

    BOOL fSyncLock; // handler has put a lock on this item.
    CSyncMgrHandler *pLockHandler; // ptr to handler who has lock on item.

} SAMPLEITEMSETTINGS;

typedef SAMPLEITEMSETTINGS *LPSAMPLEITEMSETTINGS;


// definitions for global settings class

typedef struct _tagCONFIGSETTINGSLPARAM
{
    CSettings *pSettings;
    HRESULT hr;
} CONFIGSETTINGSLPARAM;


typedef struct _tagITEMCONFIGSETTINGSLPARAM
{
    CSettings *pSettings;
    BOOL fNewItem;
    SYNCMGRITEMID ItemID;
    LPSAMPLEITEMSETTINGS pItemSettings;
    HRESULT hr;

    // vars used internally by dialog
    BOOL fDirty;
} ITEMCONFIGSETTINGSLPARAM;


typedef struct _tagCONFIGITEMLISTVIEWLPARAM
{
  SYNCMGRITEMID ItemID;
} CONFIGITEMLISTVIEWLPARAM;


BOOL CALLBACK ConfigureDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK ItemConfigDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);

class CSettings : CLockHandler {

public:
    CSettings();
    ~CSettings();

    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    STDMETHODIMP    EnumSyncMgrItems(ISyncMgrEnumItems **ppenumOffineItems);
    STDMETHODIMP    ShowProperties(HWND hWndParent,REFSYNCMGRITEMID ItemID);
    BOOL RequestItemLock(CSyncMgrHandler *pLockHandler,REFSYNCMGRITEMID ItemID);
    BOOL ReleaseItemLock(CSyncMgrHandler *pLockHandler,REFSYNCMGRITEMID ItemID);
    BOOL ReleaseItemLock(CSyncMgrHandler *pLockHandler,REFSYNCMGRITEMID ItemID,FILETIME *pfUpdateTime);
    BOOL CopyHandlerSyncInfo(REFSYNCMGRITEMID ItemID,
                        /* [in,out] */ LPHANDLERITEMSETTINGS pHandlerSyncItem);
private:
    LPSAMPLEITEMSETTINGS FindItemSettings(REFSYNCMGRITEMID ItemID);
    STDMETHODIMP ReadSettings(BOOL fForce);
    BOOL WriteItemSettings(LPSAMPLEITEMSETTINGS pSampleItemSettings);
    BOOL DeleteItemSettings(LPSAMPLEITEMSETTINGS pSampleItemSettings);
    BOOL ReleaseItemLockX(CSyncMgrHandler *pLockHandler,REFSYNCMGRITEMID ItemID,
                            BOOL fUpdateft,FILETIME *pfUpdateTime);


    STDMETHODIMP ShowItemProperties(HWND hWndParent,BOOL fNew,
            LPSAMPLEITEMSETTINGS pItemSettings,SYNCMGRITEMID ItemID);
    int Alert(HWND hWnd,LPCTSTR lpText);

    // methods used by configuration properties dialog
    void OnConfigDlgInit(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam,
                                        UINT uMessage, WPARAM wParam, LPARAM lParam);
    void OnConfigDlgDestroy(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam,
                                        UINT uMessage, WPARAM wParam,LPARAM lParam);
    void OnConfigDlgNotify(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam,
                                        UINT uMessage, WPARAM wParam,LPARAM lParam);
    void OnConfigDlgCommand(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam,
                                        UINT uMessage, WPARAM wParam,LPARAM lParam);
    void OnConfigDlgAdd(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam);
    void OnConfigDlgRemove(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam,
                                SYNCMGRITEMID ItemID,int iSelection);
    void OnConfigDlgEdit(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam,
                                SYNCMGRITEMID ItemID,int iSelection);

    int ConfigDlgAddListViewItem(HWND hWndList,SYNCMGRITEM syncMgrItem,int iItem,int iIconIndex);
    BOOL ConfigDlgDeleteListViewItem(HWND hWndList,int iItem);

    // methods used by Item properties dialog
    void OnItemConfigDlgInit(HWND hWnd,ITEMCONFIGSETTINGSLPARAM *pItemConfigDlglParam,
                                        UINT uMessage, WPARAM wParam, LPARAM lParam);
    void OnItemConfigDlgDestroy(HWND hWnd,ITEMCONFIGSETTINGSLPARAM *pItemConfigDlglParam,
                                        UINT uMessage, WPARAM wParam,LPARAM lParam);
    void OnItemConfigDlgNotify(HWND hWnd,ITEMCONFIGSETTINGSLPARAM *pItemConfigDlglParam,
                                        UINT uMessage, WPARAM wParam,LPARAM lParam);
    void OnItemConfigDlgCommand(HWND hWnd,ITEMCONFIGSETTINGSLPARAM *pItemConfigDlglParam,
                                        UINT uMessage, WPARAM wParam,LPARAM lParam);
    BOOL OnItemConfigDlgApply(HWND hWnd,ITEMCONFIGSETTINGSLPARAM *pItemConfigDlglParam,
                                        UINT uMessage, WPARAM wParam,LPARAM lParam);

    LPSAMPLEITEMSETTINGS ItemConfigDlgGetItemSettings(ITEMCONFIGSETTINGSLPARAM *pItemConfigDlglParam);

private:
    LPGENERICITEMLIST m_pHandlerItems;
    LONG m_cRefs;

    friend BOOL CALLBACK ConfigureDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    friend BOOL CALLBACK ItemConfigDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);

};


// Enumerator for ISyncMgrEnumItems
class CEnumSyncMgrItems : public CGenericEnum , public ISyncMgrEnumItems
{
public:
    CEnumSyncMgrItems(LPGENERICITEMLIST  pContactItemList,DWORD cOffset);
    virtual void DeleteThisObject();

    //IUnknown members
    STDMETHODIMP            QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();

    //IEnumSyncMgrItems members
    STDMETHODIMP Next(ULONG celt, LPSYNCMGRITEM rgelt,ULONG *pceltFetched);
    STDMETHODIMP Clone(ISyncMgrEnumItems **ppenum);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
};


#endif // _SAMPLESETTINGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\handler.h ===
// header file for handler specific items

#ifndef _HANDER_IMPL_
#define _HANDER_IMPL_

// DEFINE A NEW CLSID FOR EACH HANDLER
// {97484BA1-26C7-11d1-9A39-0020AFDA97B0}
DEFINE_GUID(CLSID_OneStopHandler,0x97484ba2, 0x26c7, 0x11d1, 0x9a, 0x39, 0x0, 0x20, 0xaf, 0xda, 0x97, 0xb0);



// declarations specific to briefcase
#include "resource.h"


DEFINE_GUID(CLSID_BriefCase,
	0x85BBD920,0x42A0,0x1069,0xA2,0xE4,0x08,0x00,0x2B,0x30,0x30,0x9D);

DEFINE_GUID(IID_IBriefcaseStg, 
	0x8BCE1FA1L, 0x0921, 0x101B, 0xB1, 0xFF, 0x00, 0xDD, 0x01, 0x0C, 0xCC, 0x48);

DEFINE_GUID(IID_IBriefcaseStg2, 
	 0x8BCE1FA1L, 0x1921, 0x101B, 0xB1, 0xFF, 0x00, 0xDD, 0x01, 0x0C, 0xCC, 0x48);

// end declarations specific to briefcase

class CBriefHandler :  public COneStopHandler
{
private: 	

public:
    STDMETHODIMP DestroyHandler();
    STDMETHODIMP Initialize(DWORD dwReserved,DWORD dwSyncFlags,
		    DWORD cbCookie,const BYTE *lpCooke);
    STDMETHODIMP GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);
    STDMETHODIMP PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID *pItemIDs,
		    HWND hwndParent,DWORD dwReserved);
    STDMETHODIMP Synchronize(HWND hwndParent);
    STDMETHODIMP SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus);
    STDMETHODIMP ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID);
    STDMETHODIMP ShowProperties(HWND hWndParent,REFSYNCMGRITEMID ItemID);
};

COneStopHandler*  CreateHandlerObject();

#endif // #define _HANDER_IMPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\sample\settings.cpp ===
//==========================================================================
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------

// global settings class created in DLLMain
// manages user settings and keeps track of what items are synchronizing
// between all instances.

#include "precomp.h"

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.
extern CSettings *g_pSettings;  // ptr to global settings class.

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::CSettings, public
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

CSettings::CSettings()
{

    m_cRefs = 1;
    m_pHandlerItems = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::~CSettings, public
//
//  Synopsis:   Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

CSettings::~CSettings()
{
    Assert(0 == m_cRefs);

    if (m_pHandlerItems)
    {
    LPGENERICITEMLIST pHandlerItems = m_pHandlerItems;

        m_pHandlerItems = NULL;
        Release_ItemList(pHandlerItems);
    }

}


//+---------------------------------------------------------------------------
//
//  Member:     CSettings::AddRef, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSettings::AddRef()
{
DWORD cRefs;

    Assert(m_cRefs >= 1); // should never zero bounce.
    cRefs = InterlockedIncrement((LONG *)& m_cRefs);
    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::Release, public
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSettings::Release()
{
DWORD cRefs;

    cRefs = InterlockedDecrement( (LONG *) &m_cRefs);

    Assert(cRefs >= 0); // should never go negative.
    if (0 == cRefs)
    {
        delete this;
    }

    return cRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::EnumSyncMgrItems, public
//
//  Synopsis:   Returns a SyncMgrEnum enumerator of current items
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSettings::EnumSyncMgrItems(ISyncMgrEnumItems** ppenumOffineItems)
{
CLock clock(this);

    clock.Enter();

    ReadSettings(FALSE /* fForce */); // make sure settings have been read in

    *ppenumOffineItems = NULL;

    if (m_pHandlerItems)
    {
    LPGENERICITEMLIST pDupList;

        // snapshot itemlist for enum so don't have to
        // worry about changes.
        pDupList = DuplicateItemList(m_pHandlerItems);
        if (pDupList)
        {
        *ppenumOffineItems = new  CEnumSyncMgrItems(pDupList,0);
            Release_ItemList(pDupList);
        }

    }

    clock.Leave();

    return *ppenumOffineItems ? NOERROR: E_OUTOFMEMORY;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSettings::ShowProperties, public
//
//  Synopsis:   Displays the property page for the requested item.
//              it ItemID == GUID_NULL the top-level property page
//              is shown.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSettings::ShowProperties(HWND hWndParent,REFSYNCMGRITEMID ItemID)
{
HRESULT hr = NOERROR;
DWORD dwResult;
CLock clock(this);

    clock.Enter();
    ReadSettings(FALSE /* fForce */); // make sure settings are read in.a
    clock.Leave();

    if (GUID_NULL == ItemID)
    {
    PROPSHEETPAGE psp [1];
    HPROPSHEETPAGE hpsp [1];
    PROPSHEETHEADER psh;
    CONFIGSETTINGSLPARAM configlParam;

        configlParam.pSettings = this;
        configlParam.hr = NOERROR;

        memset(psp,0,sizeof(psp));
        memset(&psh,0,sizeof(psh));

        psp[0].dwSize = sizeof (psp[0]);
        psp[0].dwFlags = PSP_DEFAULT | PSP_USETITLE;
        psp[0].hInstance = g_hmodThisDll;
        psp[0].pszTemplate = MAKEINTRESOURCE(IDD_CONFIGDIALOG);
        psp[0].pszIcon = NULL;
        psp[0].pfnDlgProc = (DLGPROC) ConfigureDlgProc;
        psp[0].pszTitle = MAKEINTRESOURCE(IDS_CONFIG_TAB);
        psp[0].lParam = (LPARAM) &configlParam;

        if (hpsp[0] = CreatePropertySheetPage(&(psp[0])))
        {

            psh.dwSize = sizeof (psh);
            psh.dwFlags = PSH_DEFAULT | PSH_USEHICON;
            psh.hwndParent = hWndParent;
            psh.hInstance = g_hmodThisDll;
            psh.pszIcon = NULL;
            psh.hIcon =  LoadIcon(g_hmodThisDll, MAKEINTRESOURCE(IDI_SAMPLEHANDLERICON));
            psh.pszCaption = MAKEINTRESOURCE(IDS_CONFIG_TITLE);
            psh.nPages = 1;
            psh.phpage = hpsp;
            psh.pfnCallback = NULL;
            psh.nStartPage = 0;

            dwResult = PropertySheet(&psh);

            hr = configlParam.hr;
        }

    }
    else
    {
        if (S_OK == ShowItemProperties(hWndParent,FALSE /*fNewItem */,
                    NULL,ItemID))
        {
            hr = S_SYNCMGR_ENUMITEMS;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::RequestItemLock, public
//
//  Synopsis:   Called by handler Requests a Lock on the Item
//              once given the lock no other handler instance
//              can obtain it. This ensures only one handler
//              instance is synchronizing an item at a time.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL CSettings::RequestItemLock(CSyncMgrHandler *pLockHandler,REFSYNCMGRITEMID ItemID)
{
LPSAMPLEITEMSETTINGS pItemSettings;
CLock clock(this);

    clock.Enter();

    pItemSettings = FindItemSettings(ItemID);

    if (pItemSettings && !(pItemSettings->fSyncLock))
    {
        Assert(NULL == pItemSettings->pLockHandler);

        pItemSettings->fSyncLock = TRUE;
        pItemSettings->pLockHandler = pLockHandler;

        clock.Leave();
        return TRUE;
    }

    clock.Leave();
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSettings::ReleaseItemLock, public
//
//  Synopsis:   Called by Handler to inform settings that it is
//              done synchronizing an Item and no longer needs the lock.
//              Filetime field request the last update time be upated.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL CSettings::ReleaseItemLock(CSyncMgrHandler *pLockHandler,REFSYNCMGRITEMID ItemID
                                ,FILETIME *pftLastUpdate)
{
    return ReleaseItemLockX(pLockHandler,ItemID,TRUE,pftLastUpdate);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::ReleaseItemLock, public
//
//  Synopsis:   Called by Handler to inform settings that it is
//              done synchronizing an Item and no longer needs the lock.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL CSettings::ReleaseItemLock(CSyncMgrHandler *pLockHandler,REFSYNCMGRITEMID ItemID)
{
    return ReleaseItemLockX(pLockHandler,ItemID,FALSE,NULL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::ReleaseItemLockX, private
//
//  Synopsis:   private call to release synchronize call and update filetime
//              if necessary.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL CSettings::ReleaseItemLockX(CSyncMgrHandler *pLockHandler,REFSYNCMGRITEMID ItemID,
                            BOOL fUpdateft,FILETIME *pftLastUpdate)
{
LPSAMPLEITEMSETTINGS pItemSettings;
CLock clock(this);

    clock.Enter();

    pItemSettings = FindItemSettings(ItemID);

    if (pItemSettings)
    {
        Assert(TRUE == pItemSettings->fSyncLock);
        Assert(pLockHandler == pItemSettings->pLockHandler);

        if (pItemSettings->pLockHandler == pLockHandler)
        {
            pItemSettings->fSyncLock = FALSE;
            pItemSettings->pLockHandler = NULL;

            if (fUpdateft)
            {
                pItemSettings->syncmgrItem.ftLastUpdate = *pftLastUpdate;

                // write out item to registry to update the last update time.
                WriteItemSettings(pItemSettings);
            }
        }

        clock.Leave();
        return TRUE;
    }

    clock.Leave();
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSettings::CopyHandlerSyncInfo, public
//
//  Synopsis:   Called by handler to obtain information it
//              needs on an item to perform a synchronization.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL CSettings::CopyHandlerSyncInfo(REFSYNCMGRITEMID ItemID,
                        /* [in,out] */ LPHANDLERITEMSETTINGS pHandlerSyncItem)
{
LPSAMPLEITEMSETTINGS pItemSettings;
BOOL fReturn = FALSE;
CLock clock(this);

    clock.Enter();

    pItemSettings = FindItemSettings(ItemID);

    Assert(pHandlerSyncItem);

    if (pItemSettings && pHandlerSyncItem)
    {

        pHandlerSyncItem->ItemID = ItemID;
        pHandlerSyncItem->ft = pItemSettings->syncmgrItem.ftLastUpdate;
        pHandlerSyncItem->fRecursive = pItemSettings->fRecursive;

        lstrcpyn(pHandlerSyncItem->dir1,pItemSettings->dir1,
            sizeof(pHandlerSyncItem->dir1)/sizeof(TCHAR));
        lstrcpyn(pHandlerSyncItem->dir2,pItemSettings->dir2,
            sizeof(pHandlerSyncItem->dir2)/sizeof(TCHAR));

#ifndef _UNICODE
        WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK,
                            pItemSettings->syncmgrItem.wszItemName,
                            -1, pHandlerSyncItem->szItemName,
                            sizeof(pHandlerSyncItem->szItemName)/sizeof(TCHAR), NULL, NULL);

#else
        lstrcpyn(pHandlerSyncItem->szItemName,
            pItemSettings->syncmgrItem.wszItemName,
            sizeof(pHandlerSyncItem->szItemName));
#endif // _UNICODE

        fReturn = TRUE;
    }

    clock.Leave();
    return fReturn;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSettings::ReadSettings, private
//
//  Synopsis:   Called to Read in Settings from Registry
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSettings::ReadSettings(BOOL fForce)
{
HKEY hkeyHandlerPerf;

    ASSERT_LOCKHELD(this);

    // if not forced to refresh and already have a list just re-use it.
    if (!fForce && m_pHandlerItems)
    {
        return NOERROR;
    }

    Assert(NULL == m_pHandlerItems);

    m_pHandlerItems = CreateItemList();

    if (!m_pHandlerItems)
    {
        return E_OUTOFMEMORY;
    }

   // loop through registered items loading them in.
   if (hkeyHandlerPerf =  CreateHandlerPrefKey(CLSID_SyncMgrHandler))
   {
    TCHAR lpName[256];
    WCHAR *pszName;
    DWORD cbName = 256;
    CLSID clsid;
    DWORD dwIndex = 0;

        while ( ERROR_SUCCESS == RegEnumKey(hkeyHandlerPerf,dwIndex,
                lpName,cbName) )
        {
        #ifndef _UNICODE
            WCHAR  pwszItemID[MAX_SYNCMGRITEMNAME];

            MultiByteToWideChar(CP_ACP, 0,
                                lpName,
                                -1, pwszItemID,MAX_SYNCMGRITEMNAME);

            pszName = pwszItemID;
        #else
            pszName = lpName;
        #endif // _UNICODE

            if (NOERROR == CLSIDFromString(pszName,&clsid) )
            {
            LPSAMPLEITEMSETTINGS pSampleItem;

                // set up item list,
                pSampleItem = (LPSAMPLEITEMSETTINGS) AddNewItemToList(m_pHandlerItems,sizeof(SAMPLEITEMSETTINGS));

                if (!pSampleItem)
                {
                    continue;
                }

                // setup values we don't get from preferences.
                pSampleItem->syncmgrItem.cbSize = sizeof(SYNCMGRITEM);
                pSampleItem->syncmgrItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;

                pSampleItem->syncmgrItem.hIcon =
                            LoadIcon(g_hmodThisDll,MAKEINTRESOURCE(IDI_SAMPLEHANDLERICON));

                pSampleItem->syncmgrItem.dwFlags =
                                    SYNCMGRITEM_HASPROPERTIES | SYNCMGRITEM_LASTUPDATETIME;

                 // read in items from preferences
                Reg_GetItemSettingsForHandlerItem(hkeyHandlerPerf,
                        clsid,
                        pSampleItem);

            }

            dwIndex++;
        }


        RegCloseKey(hkeyHandlerPerf);

   }

    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSettings::WriteItemSettings, private
//
//  Synopsis:   Called to write out settings to the Registry
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL CSettings::WriteItemSettings(LPSAMPLEITEMSETTINGS pSampleItemSettings)
{

    ASSERT_LOCKHELD(this);

    Reg_SetItemSettingsForHandlerItem(CLSID_SyncMgrHandler,
                        pSampleItemSettings->syncmgrItem.ItemID,
                        pSampleItemSettings);

    return TRUE;
}

// deletes item settings from the registry
BOOL CSettings::DeleteItemSettings(LPSAMPLEITEMSETTINGS pSampleItemSettings)
{
    ASSERT_LOCKHELD(this);

    Reg_DeleteItemIdForHandlerItem(CLSID_SyncMgrHandler,
                        pSampleItemSettings->syncmgrItem.ItemID);


    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSettings::WriteItemSettings, private
//
//  Synopsis:   Finds item settings in list for the specified ItemID
//              caller must have put a lock on the settings list
//              and not release it until it is done using the
//              structure pointed to by the return value.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LPSAMPLEITEMSETTINGS  CSettings::FindItemSettings(REFSYNCMGRITEMID ItemID)
{
LPSAMPLEITEMSETTINGS pItemSettings = NULL;

    ASSERT_LOCKHELD(this);

    ReadSettings(FALSE /* fForce */); // make sure settings are read in.a

    if (m_pHandlerItems)
    {

        pItemSettings = (LPSAMPLEITEMSETTINGS) m_pHandlerItems->pFirstGenericItem;

        while (pItemSettings)
        {
            Assert(sizeof(SAMPLEITEMSETTINGS) == pItemSettings->genericItem.cbSize);

            if (ItemID == pItemSettings->syncmgrItem.ItemID)
            {
                break;
            }

            pItemSettings = (LPSAMPLEITEMSETTINGS) pItemSettings->genericItem.pNextGenericItem;
        }

    }

    AssertSz(pItemSettings,"Item not Found");

    return pItemSettings;
}



//+---------------------------------------------------------------------------
//
//  Member:     CSettings::ShowItemProperties, private
//
//  Synopsis:   called internally by class to show item properties
//              if fNewItem is set to true then the pItemSettings
//              argument is used. else need to lookup pItemSettings
//              from ItemID each time it is needed.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CSettings::ShowItemProperties(HWND hWndParent,BOOL fNewItem,
                                            LPSAMPLEITEMSETTINGS pItemSettings,
                                            SYNCMGRITEMID ItemID)
{
HRESULT hr = NOERROR;
PROPSHEETPAGE psp [1];
HPROPSHEETPAGE hpsp [1];
PROPSHEETHEADER psh;
ITEMCONFIGSETTINGSLPARAM ItemConfiglParam;
TCHAR szLocalDisplayNameBuf[MAX_SYNCMGRITEMNAME];
TCHAR *pDisplayName;
WCHAR *pwszDisplayName = NULL;
CLock clock(this);

    ItemConfiglParam.pSettings = this;
    ItemConfiglParam.hr = NOERROR;

    ItemConfiglParam.fNewItem = fNewItem;

    // if new item save to use settings, else use ItemID and look up
    // in list when need in case item deleted by someone else.

    clock.Enter(); // setup lock to get the display Name.

    if (fNewItem)
    {
        Assert(pItemSettings);
        ItemConfiglParam.pItemSettings = pItemSettings;
        ItemConfiglParam.ItemID = GUID_NULL;

        pwszDisplayName = pItemSettings->syncmgrItem.wszItemName;
    }
    else
    {
    LPSAMPLEITEMSETTINGS pTempItemSettings;

        Assert(NULL == pItemSettings);
        ItemConfiglParam.pItemSettings = NULL;
        ItemConfiglParam.ItemID = ItemID;

        if (pTempItemSettings = FindItemSettings(ItemID))
        {
            pwszDisplayName = pTempItemSettings->syncmgrItem.wszItemName;
        }
    }

    // convert the display name before release lock to properly handler
    // existing items.
    pDisplayName = szLocalDisplayNameBuf;
    *szLocalDisplayNameBuf = NULL;

    if (pwszDisplayName)
    {
    #if _UNICODE
         lstrcpy(szLocalDisplayNameBuf,pwszDisplayName);
    #else
        WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK,
                            pwszDisplayName,
                            -1, szLocalDisplayNameBuf,MAX_SYNCMGRITEMNAME, NULL, NULL);

    #endif // _UNICODE
    }

    clock.Leave();

    memset(psp,0,sizeof(psp));
    memset(&psh,0,sizeof(psh));

    psp[0].dwSize = sizeof (psp[0]);
    psp[0].dwFlags = PSP_DEFAULT | PSP_USETITLE;
    psp[0].hInstance = g_hmodThisDll;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_ITEMCONFIGDIALOG);
    psp[0].pszIcon = NULL;
    psp[0].pfnDlgProc = (DLGPROC) ItemConfigDlgProc;
    psp[0].pszTitle = MAKEINTRESOURCE(IDS_ITEMCONFIG_TAB);
    psp[0].lParam = (LPARAM) &ItemConfiglParam;

    if (hpsp[0] = CreatePropertySheetPage(&(psp[0])))
    {

        psh.dwSize = sizeof (psh);
        psh.dwFlags = PSH_DEFAULT | PSH_USEHICON;
        psh.hwndParent = hWndParent;
        psh.hInstance = g_hmodThisDll;
        psh.pszIcon = NULL;
        psh.hIcon =  LoadIcon(g_hmodThisDll, MAKEINTRESOURCE(IDI_SAMPLEHANDLERITEMICON));
        psh.pszCaption = pDisplayName;
        psh.nPages = 1;
        psh.phpage = hpsp;
        psh.pfnCallback = NULL;
        psh.nStartPage = 0;

        PropertySheet(&psh);

        hr = ItemConfiglParam.hr;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSettings::Alert, private
//
//  Synopsis:   Simple helper to show a message box.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

int CSettings::Alert(HWND hWnd,LPCTSTR lpText)
{
    return ::MessageBox(hWnd,lpText,TEXT("Sample Handler"),MB_OK | MB_ICONERROR);
}



//+---------------------------------------------------------------------------
//
//  Member:     CSettings::ConfigDlgAddListViewItem, private
//
//  Synopsis:   Adds a ListViewItem to the Config Dialog.
//
//  Arguments:
//
//  Returns:    -1 on falure
//
//  Modifies:
//
//----------------------------------------------------------------------------

int CSettings::ConfigDlgAddListViewItem(HWND hWndList,SYNCMGRITEM syncMgrItem,int iItem
                                         ,int iIconIndex)
{
LV_ITEM lvItem;
CONFIGITEMLISTVIEWLPARAM *pConfigItemListViewlParam;
int iResult = -1;


    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.iItem = iItem;
    lvItem.iSubItem = 0;

    #ifdef _UNICODE
        lvItem.pszText = syncMgrItem.wszItemName;
    #else
        char TextBuf[MAX_PATH];

        *TextBuf = NULL;
        WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, syncMgrItem.wszItemName,
                            -1, TextBuf,MAX_PATH, NULL, NULL);

        lvItem.pszText = TextBuf;

    #endif // _UNICODE

    if (iIconIndex >= 0)
    {
        lvItem.mask |= LVIF_IMAGE;
        lvItem.iImage = iIconIndex;
    }

    // need to store somethin in lParam so can get Item from it.
    pConfigItemListViewlParam = (CONFIGITEMLISTVIEWLPARAM *) ALLOC(sizeof(CONFIGITEMLISTVIEWLPARAM));

    if (pConfigItemListViewlParam)
    {

        pConfigItemListViewlParam->ItemID = syncMgrItem.ItemID;
    lvItem.lParam = (LPARAM) pConfigItemListViewlParam;

    //add the item to the list
    iResult = ListView_InsertItem(hWndList, &lvItem);

        if (-1 == iResult)
        {
            FREE(pConfigItemListViewlParam);
        }

    }

    return iResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::OnConfigDlgInit, private
//
//  Synopsis:   Initializes the Config Dialog.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSettings::OnConfigDlgInit(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam,
                                        UINT uMessage, WPARAM wParam,LPARAM lParam)
{
HWND hwndList = GetDlgItem(hWnd,IDC_CONFIGDIALOG_ITEMLIST);


    if (hwndList)
    {
    int iItem = 0;
    LV_COLUMN columnInfo;
    HIMAGELIST himage;
    int iIconIndex = -1;
    ISyncMgrEnumItems *pEnumItems;

        ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT);

    // Insert the Proper columns
    columnInfo.mask = LVCF_FMT  | LVCF_TEXT  | LVCF_WIDTH  | LVCF_SUBITEM;
    columnInfo.fmt = LVCFMT_LEFT;
    columnInfo.cx = CalcListViewWidth(hwndList,300);
    columnInfo .pszText = TEXT("Items");
    columnInfo.iSubItem = 0;
    ListView_InsertColumn(hwndList,0,&columnInfo);

    // create an imagelist
        himage = ImageList_Create( GetSystemMetrics(SM_CXSMICON),
                         GetSystemMetrics(SM_CYSMICON),ILC_COLOR | ILC_MASK,5,20);
    if (himage)
    {
       ListView_SetImageList(hwndList,himage,LVSIL_SMALL);
    }

    HICON hIcon = LoadIcon(g_hmodThisDll,MAKEINTRESOURCE(IDI_SAMPLEHANDLERITEMICON));
        if (hIcon)
        {
            iIconIndex = ImageList_AddIcon(himage,hIcon);
        }


        // loop though item enumerator adding the info.
        if (NOERROR == EnumSyncMgrItems(&pEnumItems))
        {
        SYNCMGRITEM syncMgrItem;
        ULONG fetched;

            while (NOERROR == pEnumItems->Next(1,&syncMgrItem,&fetched))
            {

                if (-1 != ConfigDlgAddListViewItem(hwndList,syncMgrItem,iItem,iIconIndex))
                {
                    iItem++;
                }


            }

            pEnumItems->Release();
        }

    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::DeleteListViewItem, private
//
//  Synopsis:   deletes an Item from the Config Dialog ListView
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL CSettings::ConfigDlgDeleteListViewItem(HWND hWndList,int iItem)
{
LV_ITEM lvItem;
CONFIGITEMLISTVIEWLPARAM *pConfigItemListViewlParam;
BOOL fResult = FALSE;

    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = iItem;

    if (ListView_GetItem(hWndList, &lvItem))
    {

        pConfigItemListViewlParam = (CONFIGITEMLISTVIEWLPARAM *) lvItem.lParam;

        if (ListView_DeleteItem(hWndList,iItem))
        {
            fResult = TRUE;

            if (pConfigItemListViewlParam)
            {
                FREE(pConfigItemListViewlParam);
            }
        }
    }

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::OnConfigDlgDestroy, private
//
//  Synopsis:   called to cleanup the dialog
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSettings::OnConfigDlgDestroy(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam,
                                        UINT uMessage, WPARAM wParam,LPARAM lParam)
{
HWND hwndListView = GetDlgItem(hWnd,IDC_CONFIGDIALOG_ITEMLIST);
int iItemCount;
int iItem;

    if (!hwndListView)
    {
        return;
    }

    iItemCount = ListView_GetItemCount(hwndListView);

    for(iItem = 0; iItem < iItemCount; iItem++)
    {
        ConfigDlgDeleteListViewItem(hwndListView,0); // delete list view items to cleanup lParam
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CSettings::OnConfigDlgNotify, private
//
//  Synopsis:   handles WM_NOTIFY messages for the Config Dialog
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSettings::OnConfigDlgNotify(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam,
                                        UINT uMessage, WPARAM wParam,LPARAM lParam)
{
LPNMHDR pnmhdr = (LPNMHDR)lParam;
int iCtrlId = wParam;

    // enable/disable edit and remove button based on listview selection.
    if (IDC_CONFIGDIALOG_ITEMLIST == iCtrlId)
    {
    LPNMLISTVIEW pnmv = (LPNMLISTVIEW) pnmhdr;

        switch (pnmhdr->code)
        {
            case LVN_ITEMCHANGED:
        {
        if (  (pnmv->uChanged == LVIF_STATE)  &&
              ((pnmv->uNewState ^ pnmv->uOldState) & LVIS_SELECTED))
        {
                BOOL fEnable = FALSE;

                    if (pnmv->uNewState & LVIS_SELECTED)
                    {
                        fEnable = TRUE;
                    }

                    EnableWindow(GetDlgItem(hWnd,IDC_CONFIGDIALOG_REMOVE),fEnable);
                    EnableWindow(GetDlgItem(hWnd,IDC_CONFIGDIALOG_EDIT),fEnable);
        }
                break;
        }
            case NM_DBLCLK:
        {
            LV_ITEM lvItem;
            CONFIGITEMLISTVIEWLPARAM *pConfigItemListViewlParam;
            SYNCMGRITEMID ItemID;

               // grab itemid out of the lParam.
            lvItem.mask = LVIF_PARAM;
            lvItem.iItem = pnmv->iItem;

            if (FALSE == ListView_GetItem(GetDlgItem(hWnd,IDC_CONFIGDIALOG_ITEMLIST),&lvItem))
                {
                    return;
                }

            pConfigItemListViewlParam = (CONFIGITEMLISTVIEWLPARAM *) lvItem.lParam;

                if (NULL == pConfigItemListViewlParam)
                {
                    return;
                }

                ItemID = pConfigItemListViewlParam->ItemID;

            OnConfigDlgEdit(hWnd,pConfigSettingslParam,ItemID,pnmv->iItem);

                break;
        }
        default:
                break;
        }
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::OnConfigDlgAdd, private
//
//  Synopsis:   Implements what happens when User hits Add in the Config Dialog
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSettings::OnConfigDlgAdd(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam)
{
LPSAMPLEITEMSETTINGS pSettings = (LPSAMPLEITEMSETTINGS) CreateNewListItem(sizeof(SAMPLEITEMSETTINGS));

    if (pSettings)
    {
    HRESULT hr;
    SYNCMGRITEMID offType;

        // generate an ID for the item.
        CoCreateGuid(&offType);
        pSettings->syncmgrItem.ItemID = offType;
        pSettings->syncmgrItem.cbSize = sizeof(SYNCMGRITEM);
        pSettings->syncmgrItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;

        pSettings->syncmgrItem.hIcon =
                    LoadIcon(g_hmodThisDll,MAKEINTRESOURCE(IDI_SAMPLEHANDLERICON));

        pSettings->syncmgrItem.dwFlags =
                            SYNCMGRITEM_HASPROPERTIES | SYNCMGRITEM_LASTUPDATETIME;

        // if wanted to setup default fields for item dialog on first create
        // do it here.

        hr = ShowItemProperties(hWnd,TRUE /* fNew */, pSettings,GUID_NULL);

        // if user hits okay/apply while in ShowItems
        // the item has been added to now add it to the global list

        if ( (S_OK == hr) &&
            AddItemToList(m_pHandlerItems,(LPGENERICITEM) pSettings))
        {
        HWND hWndList;
        HICON hIcon;
        int iIconIndex = -1;
        HIMAGELIST himage;


            hWndList = GetDlgItem(hWnd,IDC_CONFIGDIALOG_ITEMLIST);

            if (hWndList)
            {

                himage = ListView_GetImageList(hWndList,LVSIL_SMALL);

            hIcon = LoadIcon(g_hmodThisDll,MAKEINTRESOURCE(IDI_SAMPLEHANDLERITEMICON));
                if (hIcon && himage)
                {
                    iIconIndex = ImageList_AddIcon(himage,hIcon);
                }

                // add new item to the UI.
                ConfigDlgAddListViewItem(hWndList,pSettings->syncmgrItem,0,iIconIndex);
            }

            // need to reenum when return from showProperties if item was added.
            pConfigSettingslParam->hr = S_SYNCMGR_ENUMITEMS;

        }
        else
        {
            FREE(pSettings);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::OnConfigDlgAdd, private
//
//  Synopsis:   Implements what happens when User hits Remove in the Config Dialog
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSettings::OnConfigDlgRemove(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam,
                                            SYNCMGRITEMID ItemID,int iItem)
{
LPSAMPLEITEMSETTINGS  pSettings;
CLock clock(this);

    Assert(iItem >= 0);

    clock.Enter();
    pSettings =  FindItemSettings(ItemID);

    if (pSettings && iItem >= 0)
    {
    HWND hwndListView = GetDlgItem(hWnd,IDC_CONFIGDIALOG_ITEMLIST);

        DeleteItemSettings(pSettings); // delete item from the registry

        DeleteItemFromList(m_pHandlerItems, (LPGENERICITEM) pSettings);// remove from enum list

        // now remove from UI
        if (hwndListView)
        {
            ConfigDlgDeleteListViewItem(hwndListView,iItem);
        }

        // on remove force a re-enum when return from ShowProperties.
        pConfigSettingslParam->hr = S_SYNCMGR_ENUMITEMS;
    }


    clock.Leave();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSettings::OnConfigDlgEdit, private
//
//  Synopsis:   Implements what happens when User hits Edit in the Config Dialog
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSettings::OnConfigDlgEdit(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam,
                                        SYNCMGRITEMID ItemID,int iSelection)
{

    if (S_OK == ShowItemProperties(hWnd,FALSE /* fNew */,NULL,ItemID))
    {
    HWND hwndListView =  GetDlgItem(hWnd,IDC_CONFIGDIALOG_ITEMLIST);
    LPSAMPLEITEMSETTINGS pSettings;
    CLock clock(this);

        clock.Enter();

        // update the listview to the new display name.
        // get settings again in case list changed.
        if (hwndListView &&
            (pSettings =  FindItemSettings(ItemID)))
        {
        TCHAR *pDisplayName;

        #if _UNICODE
                pDisplayName = pSettings->syncmgrItem.wszItemName;
        #else
            char TextBuf[MAX_PATH];

            *TextBuf = NULL;
            WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK,
                                pSettings->syncmgrItem.wszItemName,
                                -1, TextBuf,MAX_PATH, NULL, NULL);

            pDisplayName = TextBuf;

        #endif // _UNICODE

            ListView_SetItemText(hwndListView,iSelection,0,pDisplayName);

        }

        // if user change anything re-enum on return to ShowProperties
        // in case the display name was changed.

        clock.Leave();

        pConfigSettingslParam->hr = S_SYNCMGR_ENUMITEMS;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CSettings::OnConfigDlgAdd, private
//
//  Synopsis:   Handles WM_COMMAND messages to Config Dialog
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSettings::OnConfigDlgCommand(HWND hWnd,CONFIGSETTINGSLPARAM *pConfigSettingslParam,
                                        UINT uMessage, WPARAM wParam,LPARAM lParam)
{
WORD wNotifyCode =  HIWORD(wParam);
WORD wID =  LOWORD(wParam);
HWND hwndCtl =  (HWND)lParam;
HWND hwndListView = GetDlgItem(hWnd,IDC_CONFIGDIALOG_ITEMLIST);

    if (BN_CLICKED == wNotifyCode) // all just respond to clicked
    {
        switch (wID)
        {
        case IDC_CONFIGDIALOG_REMOVE:
        case IDC_CONFIGDIALOG_EDIT:
        {
        int iSelection;
        LV_ITEM lvItem;
        CONFIGITEMLISTVIEWLPARAM *pConfigItemListViewlParam;
        SYNCMGRITEMID ItemID;

            if (!hwndListView || (-1 == (iSelection = ListView_GetSelectionMark(hwndListView))))
            {
                return;
            }

            // grab itemid out of the lParam.
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iSelection;

        if (FALSE == ListView_GetItem(hwndListView, &lvItem) )
            {
                return;
            }

        pConfigItemListViewlParam = (CONFIGITEMLISTVIEWLPARAM *) lvItem.lParam;

            if (NULL == pConfigItemListViewlParam)
            {
                return;
            }

            ItemID = pConfigItemListViewlParam->ItemID;

            switch (wID)
            {
            case IDC_CONFIGDIALOG_REMOVE:
                OnConfigDlgRemove(hWnd,pConfigSettingslParam,ItemID,iSelection);
                break;
        case  IDC_CONFIGDIALOG_EDIT:
                OnConfigDlgEdit(hWnd,pConfigSettingslParam,ItemID,iSelection);
                break;
            default:
                break;
            }

            break;
        }
    case  IDC_CONFIGDIALOG_ADD:
            OnConfigDlgAdd(hWnd,pConfigSettingslParam);
            break;
        default:
            break;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  function:   ConfigureDlgProc, private
//
//  Synopsis:   wndProc for Configuration Dialog
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL CALLBACK ConfigureDlgProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
WORD wNotifyCode = HIWORD(wParam); // notification code
BOOL bResult = FALSE;
CONFIGSETTINGSLPARAM *pConfigSettingslParam = (CONFIGSETTINGSLPARAM *) GetWindowLong(hWnd,DWL_USER);

    if (WM_INITDIALOG == uMessage)
    {
        pConfigSettingslParam =  (CONFIGSETTINGSLPARAM *) ((PROPSHEETPAGE *) lParam)->lParam;
        SetWindowLong(hWnd, DWL_USER, (LONG) pConfigSettingslParam);

        pConfigSettingslParam->pSettings->OnConfigDlgInit(hWnd,pConfigSettingslParam,uMessage,wParam,lParam);
    }
    else if (pConfigSettingslParam)
    {
        switch (uMessage)
        {
            case WM_DESTROY:
                pConfigSettingslParam->pSettings->OnConfigDlgDestroy(hWnd,pConfigSettingslParam,uMessage,wParam,lParam);
            break;
            case WM_NOTIFY:
                switch (((NMHDR FAR *)lParam)->code)
                {
                    case PSN_APPLY:

                        // if anything changed mark OK even if later cancel, can't undo
                        break;
                  default:
                        pConfigSettingslParam->pSettings->OnConfigDlgNotify(hWnd,pConfigSettingslParam,uMessage,wParam,lParam);
                     break;
                }
                break;
        case WM_COMMAND:
                pConfigSettingslParam->pSettings->OnConfigDlgCommand(hWnd,pConfigSettingslParam,uMessage,wParam,lParam);
            break;
        default:
                break;
        }
    }

    return bResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::ItemConfigDlgGetItemSettings, private
//
//  Synopsis:   Gets ptr to ItemSettings for specified Item.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

LPSAMPLEITEMSETTINGS CSettings::ItemConfigDlgGetItemSettings(ITEMCONFIGSETTINGSLPARAM *pItemConfigDlglParam)
{
LPSAMPLEITEMSETTINGS pSampleItem = NULL;

    ASSERT_LOCKHELD(this);

    if (pItemConfigDlglParam->fNewItem)
    {
        pSampleItem = pItemConfigDlglParam->pItemSettings;
    }
    else
    {
        pSampleItem = FindItemSettings(pItemConfigDlglParam->ItemID);
    }

    return pSampleItem;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::OnItemConfigDlgInit, private
//
//  Synopsis:   Handles WM_INITDIALOG message for Item Property Page
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSettings::OnItemConfigDlgInit(HWND hWnd,ITEMCONFIGSETTINGSLPARAM *pItemConfigDlglParam,
                                    UINT uMessage, WPARAM wParam, LPARAM lParam)
{
LPSAMPLEITEMSETTINGS pSampleItem;
CLock clock(this);
    clock.Enter();

    pSampleItem = ItemConfigDlgGetItemSettings(pItemConfigDlglParam);


    pItemConfigDlglParam->hr = S_FALSE; // by default nothing has changed.

    // fill in the dialog values.
    if (pSampleItem)
    {
    HWND hwndCtrl;
    #ifndef _UNICODE
    char TextBuf[MAX_PATH];
    #endif // _UNICODE

        hwndCtrl = GetDlgItem(hWnd,IDC_ITEMCONFIGDIALOG_EDIT_DISPLAYNAME);
        if (hwndCtrl)
        {
        TCHAR *pDisplayName;

        #if _UNICODE
                pDisplayName = pSampleItem->syncmgrItem.wszItemName;
        #else
            *TextBuf = NULL;
            WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK,
                                pSampleItem->syncmgrItem.wszItemName,
                                -1, TextBuf,MAX_PATH, NULL, NULL);

            pDisplayName = TextBuf;

        #endif // _UNICODE

           SendMessage(hwndCtrl,EM_SETLIMITTEXT,MAX_SYNCMGRITEMNAME,0);
           SetWindowText(hwndCtrl,pDisplayName);
        }

        hwndCtrl = GetDlgItem(hWnd,IDC_ITEMCONFIGDIALOG_EDIT_DIR1NAME);
        if (hwndCtrl)
        {
            SendMessage(hwndCtrl,EM_SETLIMITTEXT,sizeof(pSampleItem->dir1),0);
            SendMessage(hwndCtrl,WM_SETTEXT,0,(LPARAM) pSampleItem->dir1);
        }

        hwndCtrl = GetDlgItem(hWnd,IDC_ITEMCONFIGDIALOG_EDIT_DIR2NAME);
        if (hwndCtrl)
        {
            SendMessage(hwndCtrl,EM_SETLIMITTEXT,sizeof(pSampleItem->dir2),0);
            SendMessage(hwndCtrl,WM_SETTEXT,0,(LPARAM) pSampleItem->dir2);
        }

        CheckDlgButton(hWnd,IDC_ITEMCONFIGDIALOG_INCLUDESUBDIRS,pSampleItem->fRecursive);

    }

    pItemConfigDlglParam->fDirty = FALSE;

    clock.Leave();
}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::OnItemConfigDlgDetroy, private
//
//  Synopsis:   Handles WM_DESTROY message for Item Property Page
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSettings::OnItemConfigDlgDestroy(HWND hWnd,ITEMCONFIGSETTINGSLPARAM *pItemConfigDlglParam,
                                    UINT uMessage, WPARAM wParam,LPARAM lParam)
{

}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::OnItemConfigDlgNotify, private
//
//  Synopsis:   Handles WM_NOTIFY message for Item Property Page
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSettings::OnItemConfigDlgNotify(HWND hWnd,ITEMCONFIGSETTINGSLPARAM *pItemConfigDlglParam,
                                        UINT uMessage, WPARAM wParam,LPARAM lParam)
{


}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::OnItemConfigDlgCommand, private
//
//  Synopsis:   Handles WM_COMMAND message for Item Property Page
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CSettings::OnItemConfigDlgCommand(HWND hWnd,ITEMCONFIGSETTINGSLPARAM *pItemConfigDlglParam,
                                        UINT uMessage, WPARAM wParam,LPARAM lParam)
{
WORD wNotifyCode = HIWORD(wParam); // notification code
WORD wID = LOWORD(wParam);         // item, control, or accelerator identifier
HWND hwndCtl = (HWND) lParam;      // handle of control

    if ((EN_CHANGE == wNotifyCode) || (BN_CLICKED == wNotifyCode))
    {
        pItemConfigDlglParam->fDirty = TRUE;
        PropSheet_Changed(GetParent(hWnd), hWnd);
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CSettings::OnItemConfigDlgApply, private
//
//  Synopsis:   Called when APPLY or Okay is pressed on item Properties page.
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL CSettings::OnItemConfigDlgApply(HWND hWnd,ITEMCONFIGSETTINGSLPARAM *pItemConfigDlglParam,
                                    UINT uMessage, WPARAM wParam,LPARAM lParam)
{
BOOL fResult = TRUE;
CLock clock(this);

    if (pItemConfigDlglParam->fDirty)
    {
    LPSAMPLEITEMSETTINGS pSampleItem;
    HWND hwndCtrl;
    TCHAR dir1[MAX_PATH];
    TCHAR dir2[MAX_PATH];
    TCHAR DisplayName[MAX_SYNCMGRITEMNAME];
    WCHAR *pDisplayName;
    BOOL fRecursive = FALSE;
    BOOL fPersist = TRUE;

    // get dialog values, if couldn't find don't return error so user can still cancel
    // dialog

        hwndCtrl = GetDlgItem(hWnd,IDC_ITEMCONFIGDIALOG_EDIT_DISPLAYNAME);
        if (hwndCtrl)
        {
            if (0 >= GetWindowText(hwndCtrl,DisplayName,sizeof(DisplayName)/sizeof(TCHAR)))
            {
                Alert(hWnd,TEXT("Display Name Is Not Valid."));
                SetFocus(hwndCtrl);
                return FALSE;
            }

            #if _UNICODE
                pDisplayName = DisplayName;
            #else
                WCHAR wszTextBuf[MAX_SYNCMGRITEMNAME];

                MultiByteToWideChar(CP_ACP, 0,
                                    DisplayName,
                                    -1, wszTextBuf,MAX_SYNCMGRITEMNAME);

                pDisplayName = wszTextBuf;

            #endif // _UNICODE

        }
        else
        {
            fPersist = FALSE;
        }


        // get the new dir names.
        hwndCtrl = GetDlgItem(hWnd,IDC_ITEMCONFIGDIALOG_EDIT_DIR1NAME);
        if (hwndCtrl)
        {
            if (0 >= GetWindowText(hwndCtrl,dir1,sizeof(dir1)/sizeof(TCHAR)))
            {
                Alert(hWnd,TEXT("Dir1 Name Is Not Valid."));
               return FALSE;
            }
        }
        else
        {
            fPersist = FALSE;
        }

        hwndCtrl = GetDlgItem(hWnd,IDC_ITEMCONFIGDIALOG_EDIT_DIR2NAME);
        if (hwndCtrl)
        {
            if (0 >= GetWindowText(hwndCtrl,dir2,sizeof(dir2)/sizeof(TCHAR)))
            {
                Alert(hWnd,TEXT("Dir2 Name Is Not Valid."));
                return FALSE;
            }
        }
        else
        {
            fPersist = FALSE;
        }

        // verify dir paths
        if (!IsValidDir(dir1))
        {
            Alert(hWnd,TEXT("Dir1 Name Is Not a Valid directory"));
            return FALSE;
        }

        if (!IsValidDir(dir2))
        {
            Alert(hWnd,TEXT("Dir2 Name Is Not a Valid directory"));
            return FALSE;
        }


        fRecursive = IsDlgButtonChecked(hWnd,IDC_ITEMCONFIGDIALOG_INCLUDESUBDIRS);

        // if everything validated write it out.
        clock.Enter();
        pSampleItem = ItemConfigDlgGetItemSettings(pItemConfigDlglParam);
        if (fPersist && pSampleItem)
        {

            lstrcpyW(pSampleItem->syncmgrItem.wszItemName,pDisplayName);
            lstrcpy(pSampleItem->dir1,dir1);
            lstrcpy(pSampleItem->dir2,dir2);
            pSampleItem->fRecursive = fRecursive;
            WriteItemSettings(pSampleItem);

            pItemConfigDlglParam->hr = S_OK; // only say items saved okay when dirty and saved properly
        }

        clock.Leave();
    }

    return fResult;
}


//+---------------------------------------------------------------------------
//
//  fucntion:   ItemConfigureDlgProc, private
//
//  Synopsis:   wndproc for Items Property page
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

BOOL CALLBACK ItemConfigDlgProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
WORD wNotifyCode = HIWORD(wParam); // notification code
BOOL bResult = FALSE;
ITEMCONFIGSETTINGSLPARAM *pItemConfigDlglParam = (ITEMCONFIGSETTINGSLPARAM *) GetWindowLong(hWnd,DWL_USER);

    if (WM_INITDIALOG == uMessage)
    {
        pItemConfigDlglParam =  (ITEMCONFIGSETTINGSLPARAM *) ((PROPSHEETPAGE *) lParam)->lParam;
        SetWindowLong(hWnd, DWL_USER, (LONG) pItemConfigDlglParam);

        pItemConfigDlglParam->pSettings->OnItemConfigDlgInit(hWnd,pItemConfigDlglParam,uMessage,wParam,lParam);

    }
    else if (pItemConfigDlglParam)
    {
        switch (uMessage)
        {
            case WM_DESTROY:
                pItemConfigDlglParam->pSettings->OnItemConfigDlgDestroy(hWnd,pItemConfigDlglParam,uMessage,wParam,lParam);
            break;
            case WM_NOTIFY:
                switch (((NMHDR FAR *)lParam)->code)
                {
                    case PSN_APPLY:

                        // after a successful apply the item has changed.
                        // so set return value to S_OK:
                        if (pItemConfigDlglParam->pSettings->OnItemConfigDlgApply(hWnd,pItemConfigDlglParam,uMessage,wParam,lParam))
                        {
                           SetWindowLong(hWnd,DWL_MSGRESULT,PSNRET_NOERROR);
                        }
                        else
                        {
                            SetWindowLong(hWnd,DWL_MSGRESULT,PSNRET_INVALID);
                        }

                        return TRUE; // !!!return true so SetWindowLong DWL_MSGRESULT is applied
                        break;
                    default:
                        pItemConfigDlglParam->pSettings->OnItemConfigDlgNotify(hWnd,pItemConfigDlglParam,uMessage,wParam,lParam);
                        break;
                }
                break;
        case WM_COMMAND:
                pItemConfigDlglParam->pSettings->OnItemConfigDlgCommand(hWnd,pItemConfigDlglParam,uMessage,wParam,lParam);
        break;
        default:
                break;
        }
    }

    return bResult;
}

// implementation for item enumerator used and managed by settings.

//+---------------------------------------------------------------------------
//
//  Member:    CEnumSyncMgrItems::CEnumSyncMgrItems, public
//
//  Synopsis:  contructor
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

CEnumSyncMgrItems::CEnumSyncMgrItems(LPGENERICITEMLIST pGenericItemList,DWORD cOffset)
    : CGenericEnum(pGenericItemList,cOffset)
{
}


//+---------------------------------------------------------------------------
//
//  Member:    CEnumSyncMgrItems::DeleteThisObject, public
//
//  Synopsis:  called by generic Enum when refcount hits zero
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

void CEnumSyncMgrItems::DeleteThisObject()
{
    delete this;
}


//+---------------------------------------------------------------------------
//
//  Member:    CEnumSyncMgrItems::QueryInteface, public
//
//  Synopsis:  must override generic implementation.
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CEnumSyncMgrItems::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPUNKNOWN) this;
    }
    else if (IsEqualIID(riid, IID_ISyncMgrEnumItems))
    {
        *ppv = (LPSYNCMGRENUMITEMS) this;
    }
    if (*ppv)
    {
        AddRef();

        return NOERROR;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
//  Member:    CEnumSyncMgrItems::AddRef, public
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEnumSyncMgrItems::AddRef()
{
    return CGenericEnum::AddRef();
}

//+---------------------------------------------------------------------------
//
//  Member:    CEnumSyncMgrItems::Release, public
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CEnumSyncMgrItems::Release()
{
    return CGenericEnum::Release();
}


//+---------------------------------------------------------------------------
//
//  Member:    CEnumSyncMgrItems::Next, public
//
//  Synopsis:  must override generic implementation.
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CEnumSyncMgrItems::Next(ULONG celt, LPSYNCMGRITEM rgelt,ULONG *pceltFetched)
{
HRESULT hr = NOERROR;
ULONG ulFetchCount = celt;
ULONG ulTransferCount = 0;
LPSYNCMGRITEM pGenericItem;

    if ( (m_cOffset + celt) > m_pGenericItemList->dwNumItems)
    {
    ulFetchCount = m_pGenericItemList->dwNumItems - m_cOffset;
    hr = S_FALSE;
    }

    pGenericItem = rgelt;

    while (ulFetchCount--)
    {
    LPSAMPLEITEMSETTINGS pNextSyncMgrItem;

        Assert(m_pNextItem->cbSize == sizeof(SAMPLEITEMSETTINGS));

        pNextSyncMgrItem = (LPSAMPLEITEMSETTINGS) m_pNextItem;

    memcpy(pGenericItem,&(pNextSyncMgrItem->syncmgrItem),sizeof(SYNCMGRITEM));
    m_pNextItem = m_pNextItem->pNextGenericItem; // add error checking
    ++m_cOffset;
        ++ulTransferCount;
    ++pGenericItem;
    }

    if (pceltFetched)
    {
        *pceltFetched = ulTransferCount;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:    CEnumSyncMgrItems::Skip, public
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CEnumSyncMgrItems::Skip(ULONG celt)
{
    return CGenericEnum::Skip(celt);
}


//+---------------------------------------------------------------------------
//
//  Member:    CEnumSyncMgrItems::Reset, public
//
//  Synopsis:
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CEnumSyncMgrItems::Reset()
{
    return CGenericEnum::Reset();
}


//+---------------------------------------------------------------------------
//
//  Member:    CEnumSyncMgrItems::Clone, public
//
//  Synopsis:  must override generic implementation.
//
//  Returns:
//
//  Modifies:
//
//----------------------------------------------------------------------------

STDMETHODIMP CEnumSyncMgrItems::Clone(ISyncMgrEnumItems **ppenum)
{
*ppenum = new  CEnumSyncMgrItems(m_pGenericItemList,m_cOffset);

    return *ppenum ? NOERROR : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\base.h ===
// put handler specific declarations that the base class needs here.

#ifndef _BASESTUFF_
#define _BASESTUFF_

// #include "..\rover\FILESYNC\SYNCUI\INC\brfcasep.h"
#include "rover\FILESYNC\SYNCUI\INC\brfcasep.h"

// structure for adding any item specific data.
// warning: must contain OFFLINEHANDLERITEM structure first so 
//    can use common enumerator.

typedef struct _HANDLERITEM
{
SYNCMGRHANDLERITEM baseItem;
TCHAR szBriefcasePath[MAX_PATH];
LPBRIEFCASESTG pbrfstg;
} HANDLERITEM;

typedef HANDLERITEM *LPHANDLERITEM;

#endif // _BASESTUFF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\handler.cpp ===
// implementation for app specific data


#pragma data_seg(".text")
#define INITGUID
#include <objbase.h>
#include <initguid.h>
#include "SyncHndl.h"
#include "handler.h"
#include "priv.h"
#include "base.h"
#pragma data_seg()


#include <tchar.h>

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.

char szCLSIDDescription[] = "Briefcase OneStop Handler";

void StripBriefcaseIni(TCHAR *szBriefCasePath)
{
TCHAR *pszTemp;

    pszTemp = szBriefCasePath + _tcslen(szBriefCasePath);

    while (pszTemp > szBriefCasePath && *pszTemp != '\\')
    {
	    --pszTemp;
    }

    *pszTemp = '\0';
}

COneStopHandler*  CreateHandlerObject()
{
	return new CBriefHandler();
}

STDMETHODIMP CBriefHandler::DestroyHandler()
{
    delete this;
    return NOERROR;
}


STDMETHODIMP CBriefHandler::Initialize(DWORD dwReserved,DWORD dwSyncFlags,
				DWORD cbCookie,const BYTE *lpCookie)
{
HRESULT hr = E_FAIL;
DWORD dwBriefcaseCount = 0; // number of briefcases on this machine.
LPBRIEFCASESTG pbrfstg = NULL;
 

	// if no data, then enumerate all available briefcase files
	// if there is cookie data, only get the specified briefcase

	// briefcase specific.

	// see if briefcase is available and if there is at least one item

	hr = CoCreateInstance(CLSID_BriefCase, NULL, CLSCTX_INPROC_SERVER,
							IID_IBriefcaseStg2, (void **) &pbrfstg);


	if (NOERROR == hr)
	{
	TCHAR szBriefCasePath[MAX_PATH];
	HRESULT hrEnum;

		if (0 != cbCookie)
		{
		    memcpy(szBriefCasePath,lpCookie,cbCookie);
		    hrEnum = NOERROR;
		}
		else
		{

		    hrEnum =  pbrfstg->FindFirst(szBriefCasePath,MAX_PATH);
		    
		    // actually get path all the way to the briefcase INI,
		    //  Just need folder

		    if (NOERROR == hrEnum)
                    {	
		       StripBriefcaseIni(szBriefCasePath);
                    }

		}

		while (NOERROR == hrEnum)
		{
		ULONG ulPathLength;


		    ulPathLength = _tcslen(szBriefCasePath);

		    if (ulPathLength > 0 && ulPathLength < MAX_PATH)
		    {  // found a valid briefcase
		    LPHANDLERITEM pOfflineItem;
		    LPSYNCMGRHANDLERITEMS pOfflineItemsHolder;
		    TCHAR *pszFriendlyName;
		    #ifndef UNICODE
		    WCHAR wszBriefcaseName[MAX_PATH];
		    #endif // UNICODE

			// add the item to the enumerator.
			if (NULL == (pOfflineItemsHolder = GetOfflineItemsHolder()) )
			{  // if first item, set up the enumerator.
				pOfflineItemsHolder = CreateOfflineHandlerItemsList();

				// if still NULL, break out of loop
				if (NULL == pOfflineItemsHolder)
					break;

				SetOfflineItemsHolder(pOfflineItemsHolder);
			}

			// add the item to the list.
			if (pOfflineItem = (LPHANDLERITEM) AddOfflineItemToList(pOfflineItemsHolder,sizeof(HANDLERITEM))  )
			{
		//	OFFLINEITEMID offType;

				memcpy(pOfflineItem->szBriefcasePath,szBriefCasePath,
						(ulPathLength + 1) * sizeof(TCHAR));
				
				// add briefcase specific data
				pOfflineItem->baseItem.offlineItem.cbSize = sizeof(SYNCMGRITEM);

				pOfflineItem->baseItem.offlineItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;
			
				pOfflineItem->baseItem.offlineItem.hIcon = 
							LoadIcon(g_hmodThisDll,MAKEINTRESOURCE(IDI_BRIEFCASE));

				// set HASPROPERTIES flag for testing
				pOfflineItem->baseItem.offlineItem.dwFlags = SYNCMGRITEM_HASPROPERTIES;

				// for now, just use the path as the description
				// need to change this.

				pszFriendlyName = szBriefCasePath + ulPathLength;
				while ( (pszFriendlyName  - 1) >= szBriefCasePath
					&& TEXT('\\') != *(pszFriendlyName -1))
				{
				    --pszFriendlyName;
				}

				// if we are not already unicode, have to convert now
				#ifndef UNICODE
					MultiByteToWideChar(CP_ACP,0,pszFriendlyName,-1,
								pOfflineItem->baseItem.offlineItem.wszItemName,MAX_SYNCMGRITEMNAME);
				#else

					// already unicode, just copy it in.
					memcpy(pOfflineItem->baseItem.offlineItem.wszItemName,
							pszFriendlyName,(ulPathLength + 1)*sizeof(TCHAR));

				#endif // UNICODE

				#ifndef UNICODE
				    MultiByteToWideChar(CP_ACP,0,szBriefCasePath,-1,
							    wszBriefcaseName,MAX_PATH);

				    GetItemIdForHandlerItem(CLSID_OneStopHandler,
					wszBriefcaseName, 
					&pOfflineItem->baseItem.offlineItem.ItemID,TRUE);
				
				#else
				    GetItemIdForHandlerItem(CLSID_OneStopHandler,
					szBriefCasePath, 
					&pOfflineItem->baseItem.offlineItem.ItemID,TRUE);

				#endif // UNICODE



				// don't do anything on the status for now.
				// pOfflineItem->offlineItem.wszStatus = NULL;

				++dwBriefcaseCount; // increment the briefcase count.
			}

		    }

		     if (0 != cbCookie)
		     {
			 hrEnum = S_FALSE;
		     }
		     else
		     {
			hrEnum =  pbrfstg->FindNext(szBriefCasePath,MAX_PATH);
			if (NOERROR == hrEnum)
				{	
				   StripBriefcaseIni(szBriefCasePath);
				}
		     }
		}

	}
	
	if (pbrfstg)
		pbrfstg->Release();

	return dwBriefcaseCount ? S_OK: S_FALSE; // if have at least one briefcase then return true.
}


STDMETHODIMP CBriefHandler::GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{

    return E_NOTIMPL;
}

// for test, just pull up a message box.

STDMETHODIMP CBriefHandler::ShowProperties(HWND hwnd,REFSYNCMGRITEMID dwItemID)
{
    
    MessageBox(hwnd,TEXT("Briefcase"),TEXT("Handler"),1);
    return NOERROR;
}


STDMETHODIMP CBriefHandler::PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID *pItemIDs,
		    HWND hwndParent,DWORD dwReserved)
{
HRESULT hr = NOERROR;
LPSYNCMGRSYNCHRONIZECALLBACK pCallback = GetOfflineSynchronizeCallback();
LPHANDLERITEM pOfflineItem = (LPHANDLERITEM) GetOfflineItemsHolder()->pFirstOfflineItem;

    if (!pOfflineItem)
    {
        return S_FALSE;
    }

	// loop through the selected offline items 

	while (pOfflineItem)
	{
	ULONG NumItemsCount = cbNumItems;
	SYNCMGRITEMID *pCurItemID = pItemIDs;

	    // see if item has been specified to sync, if not, update the state
	    // to reflect this else go ahead and prepare.

	    pOfflineItem->baseItem.offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;
	    while (NumItemsCount--)
	    {
		if (IsEqualGUID(*pCurItemID,pOfflineItem->baseItem.offlineItem.ItemID))
		{
		    pOfflineItem->baseItem.offlineItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;
		    break;
		}

		++pCurItemID;
	    }
	    

	    if (SYNCMGRITEMSTATE_CHECKED == pOfflineItem->baseItem.offlineItem.dwItemState)
	    {
	    LPBRIEFCASESTG pbrfstg =  NULL;

		hr = CoCreateInstance(CLSID_BriefCase, NULL, CLSCTX_INPROC_SERVER,
								IID_IBriefcaseStg2, (void **) &pbrfstg);

		if (NOERROR == hr)
		{
		    if (NOERROR == (hr = 
				    pbrfstg->Initialize(pOfflineItem->szBriefcasePath,hwndParent)) )
		    {
			hr = pbrfstg->PrepForSync(hwndParent ,GetOfflineSynchronizeCallback(),
					pOfflineItem->baseItem.offlineItem.ItemID);
		    }

		    if (NOERROR == hr)
		    {
			pOfflineItem->pbrfstg = pbrfstg;
		    }
		    else
		    {
		    LPSYNCMGRSYNCHRONIZECALLBACK pCallback = GetOfflineSynchronizeCallback();

			pbrfstg->Release();

			// let user know that the sync is done
			if (pCallback)
			{
			SYNCMGRPROGRESSITEM progItem;

			    progItem.mask = SYNCMGRPROGRESSITEM_STATUSTYPE
					    | SYNCMGRPROGRESSITEM_PROGVALUE
					    | SYNCMGRPROGRESSITEM_MAXVALUE;


			    progItem.dwStatusType = SYNCMGRSTATUS_SUCCEEDED;
			    progItem.iProgValue = 1;
			    progItem.iMaxValue = 1;
		
			    pCallback->Progress((pOfflineItem->baseItem.offlineItem.ItemID),
						&progItem);
			}

		    }
		}

		    
	    }

	    pOfflineItem = (LPHANDLERITEM) pOfflineItem->baseItem.pNextOfflineItem;
	}

    if (pCallback)
	pCallback->PrepareForSyncCompleted(NOERROR);

	return S_OK; // always return S_OK
}

STDMETHODIMP CBriefHandler::Synchronize(HWND hwnd)
{
HRESULT hr = NOERROR;
LPHANDLERITEM pOfflineItem = (LPHANDLERITEM) GetOfflineItemsHolder()->pFirstOfflineItem;
LPSYNCMGRSYNCHRONIZECALLBACK pCallback = GetOfflineSynchronizeCallback();

    if (!pOfflineItem)
    {
        return S_FALSE;
    }

	while (pOfflineItem)
	{
	LPBRIEFCASESTG pbrfstg = NULL;

	    if (NULL != (pbrfstg= pOfflineItem->pbrfstg)
		    && SYNCMGRITEMSTATE_CHECKED ==  pOfflineItem->baseItem.offlineItem.dwItemState)
	    {
		hr = pbrfstg->Synchronize(hwnd ,GetOfflineSynchronizeCallback(),
				    pOfflineItem->baseItem.offlineItem.ItemID);



		pbrfstg->Release();

		// let user know that the sync is done
		if (pCallback)
		{
		SYNCMGRPROGRESSITEM progItem;

		    progItem.mask = SYNCMGRPROGRESSITEM_STATUSTYPE
				    | SYNCMGRPROGRESSITEM_PROGVALUE
				    | SYNCMGRPROGRESSITEM_MAXVALUE;


		    progItem.dwStatusType = FAILED(hr) ? SYNCMGRSTATUS_FAILED : SYNCMGRSTATUS_SUCCEEDED;
		    progItem.iProgValue = 1;
		    progItem.iMaxValue = 1;
	
		    pCallback->Progress((pOfflineItem->baseItem.offlineItem.ItemID),
					&progItem);
		}

	    }

	    pOfflineItem = (LPHANDLERITEM) pOfflineItem->baseItem.pNextOfflineItem;
	}

    if (pCallback)
	pCallback->SynchronizeCompleted(NOERROR);

	return NOERROR; // always return NOERROR for now.
}

STDMETHODIMP CBriefHandler::SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus)
{

    return E_NOTIMPL;
}

STDMETHODIMP CBriefHandler::ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID)
{

#ifdef _OBSOLETE
LPHANDLERITEM pOfflineItem = (LPHANDLERITEM) GetOfflineItemsHolder()->pFirstOfflineItem;

	while (pOfflineItem) // loop through showing the results.
	{
	LPBRIEFCASESTG pbrfstg = NULL;

		if (NULL != (pbrfstg= pOfflineItem->pbrfstg))
		{
			pbrfstg->ShowError(hwnd,dwErrorID);
			pOfflineItem->pbrfstg = NULL;
			
			pbrfstg->Release();
		}

		pOfflineItem = (LPHANDLERITEM) pOfflineItem->baseItem.pNextOfflineItem;
	}

	return NOERROR; // always return NOERROR for now.

#endif // _OBSOLETE

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SyncHndl.rc
//
#define IDI_ICON1                       129
#define IDI_ICON2                       130
#define IDI_ICON3                       131
#define IDD_GAKPAGE                     132
#define IDI_ICON4                       133
#define IDI_ICON5                       134
#define IDI_ICON6                       135
#define IDI_BRIEFCASE                    138
#define IDC_RED                         1000
#define IDC_CHECK1                      1000
#define IDC_GREEN                       1001
#define IDC_CHECK2                      1001
#define IDC_BLUE                        1002
#define IDC_CONNECTSPEEDS               1002
#define IDC_RADIO1                      1003
#define IDC_RADIO2                      1004
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        139
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\priv.h ===
//--------------------------------------------------------------
// common user interface routines
//
//
//--------------------------------------------------------------

#ifndef STRICT
#define STRICT
#endif

#define INC_OLE2        // WIN32, get ole2 from windows.h

#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>


#include "mobsync.h"


#define ResultFromShort(i)  ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, 0, (USHORT)(i)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\brfcase.c ===
/*
 * brfcase.c - Briefcase ADT module.
 */

/*



*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "findbc.h"


/* Constants
 ************/

/* database file attributes */

#define DB_FILE_ATTR                (FILE_ATTRIBUTE_HIDDEN)

/* database cache lengths */

#define DEFAULT_DATABASE_CACHE_LEN  (32)
#define MAX_DATABASE_CACHE_LEN      (32 * 1024)

/* string table allocation constants */

#define NUM_NAME_HASH_BUCKETS       (67)


/* Types
 ********/

/* briefcase database description */

typedef struct _brfcasedb
{
   /*
    * handle to path of folder of open database (stored in briefcase path list)
    */

   HPATH hpathDBFolder;

   /* name of database file */

   LPTSTR pszDBName;

   /* handle to open cached database file */

   HCACHEDFILE hcfDB;

   /*
    * handle to path of folder that database was last saved in (stored in
    * briefcase's path list), only valid during OpenBriefcase() and
    * SaveBriefcase()
    */

   HPATH hpathLastSavedDBFolder;
}
BRFCASEDB;
DECLARE_STANDARD_TYPES(BRFCASEDB);

/*
 * briefcase flags
 *
 * N.b., the private BR_ flags must not collide with the public OB_ flags!
 */

typedef enum _brfcaseflags
{
   /* The briefcase database has been opened. */

   BR_FL_DATABASE_OPENED      = 0x00010000,

   /* The pimkRoot field is valid. */

   BR_FL_ROOT_MONIKER_VALID   = 0x00020000,

#ifdef DEBUG

   /* Briefcase is being deleted. */

   BR_FL_BEING_DELETED        = 0x01000000,

#endif

   /* flag combinations */

   ALL_BR_FLAGS               = (BR_FL_DATABASE_OPENED |
                                 BR_FL_ROOT_MONIKER_VALID
#ifdef DEBUG
                                 | BR_FL_BEING_DELETED
#endif
                                ),

   ALL_BRFCASE_FLAGS          = (ALL_OB_FLAGS |
                                 ALL_BR_FLAGS)
}
BRFCASEFLAGS;

/* briefcase structure */

typedef struct _brfcase
{
   /* flags */

   DWORD dwFlags;

   /* handle to name string table */

   HSTRINGTABLE hstNames;

   /* handle to list of paths */

   HPATHLIST hpathlist;

   /* handle to array of pointers to twin families */

   HPTRARRAY hpaTwinFamilies;

   /* handle to array of pointers to folder pairs */

   HPTRARRAY hpaFolderPairs;

   /*
    * handle to parent window, only valid if OB_FL_ALLOW_UI is set in dwFlags
    * field
    */

   HWND hwndOwner;

   /* briewfcase database folder moniker */

   PIMoniker pimkRoot;

   /* database description */

   BRFCASEDB bcdb;
}
BRFCASE;
DECLARE_STANDARD_TYPES(BRFCASE);

/* database briefcase structure */

typedef struct _dbbrfcase
{
   /* old handle to folder that database was saved in */

   HPATH hpathLastSavedDBFolder;
}
DBBRFCASE;
DECLARE_STANDARD_TYPES(DBBRFCASE);

#ifdef DEBUG

/* debug flags */

typedef enum _dbdebugflags
{
   BRFCASE_DFL_NO_DB_SAVE     = 0x0001,

   BRFCASE_DFL_NO_DB_RESTORE  = 0x0002,

   ALL_BRFCASE_DFLAGS         = (BRFCASE_DFL_NO_DB_SAVE |
                                 BRFCASE_DFL_NO_DB_RESTORE)
}
DBDEBUGFLAGS;

#endif


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_SHARED)

/*
 * RAIDRAID: (16273) The use of MnrcsBriefcase in a shared data section is
 * broken under NT.  To run under NT, this code should be changed to use a
 * shared mutex.
 */

/* critical section used for briefcase access serialization */

PRIVATE_DATA NONREENTRANTCRITICALSECTION MnrcsBriefcase =
{
   { 0 },

#ifdef DEBUG
   INVALID_THREAD_ID,
#endif   /* DEBUG */

   FALSE
};

/* open briefcases */

PRIVATE_DATA HLIST MhlistOpenBriefcases = NULL;

/* database cache size */

PRIVATE_DATA DWORD MdwcbMaxDatabaseCacheLen = MAX_DATABASE_CACHE_LEN;

#pragma data_seg()

#ifdef DEBUG

#pragma data_seg(DATA_SEG_SHARED)

/* debug flags */

PRIVATE_DATA DWORD MdwBriefcaseModuleFlags = 0;

#pragma data_seg(DATA_SEG_READ_ONLY)

/* .ini file switch descriptions */

PRIVATE_DATA CBOOLINISWITCH cbisNoDatabaseSave =
{
   IST_BOOL,
   TEXT("NoDatabaseSave"),
   &MdwBriefcaseModuleFlags,
   BRFCASE_DFL_NO_DB_SAVE
};

PRIVATE_DATA CBOOLINISWITCH cbisNoDatabaseRestore =
{
   IST_BOOL,
   TEXT("NoDatabaseRestore"),
   &MdwBriefcaseModuleFlags,
   BRFCASE_DFL_NO_DB_RESTORE
};

PRIVATE_DATA CUNSDECINTINISWITCH cdiisMaxDatabaseCacheLen =
{
   IST_UNS_DEC_INT,
   TEXT("MaxDatabaseCacheLen"),
   (PUINT)&MdwcbMaxDatabaseCacheLen
};

PRIVATE_DATA const PCVOID MrgcpcvisBriefcaseModule[] =
{
   &cbisNoDatabaseSave,
   &cbisNoDatabaseRestore,
   &cdiisMaxDatabaseCacheLen
};

#pragma data_seg()

#endif   /* DEBUG */


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE TWINRESULT OpenBriefcaseDatabase(PBRFCASE, LPCTSTR);
PRIVATE_CODE TWINRESULT CloseBriefcaseDatabase(PBRFCASEDB);
PRIVATE_CODE BOOL CreateBriefcase(PBRFCASE *, DWORD, HWND);
PRIVATE_CODE void UnlinkBriefcase(PBRFCASE);
PRIVATE_CODE TWINRESULT DestroyBriefcase(PBRFCASE);
PRIVATE_CODE TWINRESULT MyWriteDatabase(PBRFCASE);
PRIVATE_CODE TWINRESULT MyReadDatabase(PBRFCASE, DWORD);

#ifdef DEBUG

PRIVATE_CODE BOOL DestroyBriefcaseWalker(PVOID, PVOID);

#endif

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCBRFCASE(PCBRFCASE);
PRIVATE_CODE BOOL IsValidPCBRFCASEDB(PCBRFCASEDB);
PRIVATE_CODE BOOL IsValidPCOPENBRFCASEINFO(PCOPENBRFCASEINFO);

#endif


/*
** OpenBriefcaseDatabase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT OpenBriefcaseDatabase(PBRFCASE pbr, LPCTSTR pcszPath)
{
   TWINRESULT tr;
   TCHAR rgchCanonicalPath[MAX_SEPARATED_PATH_LEN];
   DWORD dwOutFlags;
   TCHAR rgchNetResource[MAX_PATH_LEN];
   LPTSTR pszRootPathSuffix;

   ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));

   if (GetCanonicalPathInfo(pcszPath, rgchCanonicalPath, &dwOutFlags,
                            rgchNetResource, &pszRootPathSuffix))
   {
      LPTSTR pszDBName;

      pszDBName = (LPTSTR)ExtractFileName(pszRootPathSuffix);

      ASSERT(IS_SLASH(*(pszDBName - 1)));

      if (StringCopy(pszDBName, &(pbr->bcdb.pszDBName)))
      {
         if (pszDBName == pszRootPathSuffix)
         {
            /* Database in root. */

            *pszDBName = TEXT('\0');

            ASSERT(IsRootPath(rgchCanonicalPath));
         }
         else
         {
            ASSERT(pszDBName > pszRootPathSuffix);
            *(pszDBName - 1) = TEXT('\0');
         }

         tr = TranslatePATHRESULTToTWINRESULT(
                  AddPath(pbr->hpathlist, rgchCanonicalPath,
                          &(pbr->bcdb.hpathDBFolder)));

         if (tr == TR_SUCCESS)
         {
            if (IsPathVolumeAvailable(pbr->bcdb.hpathDBFolder))
            {
               TCHAR rgchDBPath[MAX_PATH_LEN];
               CACHEDFILE cfDB;

               GetPathString(pbr->bcdb.hpathDBFolder, rgchDBPath);
               CatPath(rgchDBPath, pbr->bcdb.pszDBName);

               /* Assume sequential reads and writes. */

               /* Share read access, but not write access. */

               cfDB.pcszPath = rgchDBPath;
               cfDB.dwOpenMode = (GENERIC_READ | GENERIC_WRITE);
               cfDB.dwSharingMode = FILE_SHARE_READ;
               cfDB.psa = NULL;
               cfDB.dwCreateMode = OPEN_ALWAYS;
               cfDB.dwAttrsAndFlags = (DB_FILE_ATTR | FILE_FLAG_SEQUENTIAL_SCAN);
               cfDB.hTemplateFile = NULL;
               cfDB.dwcbDefaultCacheSize = DEFAULT_DATABASE_CACHE_LEN;

               tr = TranslateFCRESULTToTWINRESULT(
                     CreateCachedFile(&cfDB, &(pbr->bcdb.hcfDB)));

               if (tr == TR_SUCCESS)
               {
                  pbr->bcdb.hpathLastSavedDBFolder = NULL;

                  ASSERT(IS_FLAG_CLEAR(pbr->dwFlags, BR_FL_DATABASE_OPENED));
                  SET_FLAG(pbr->dwFlags, BR_FL_DATABASE_OPENED);
               }
               else
               {
                  DeletePath(pbr->bcdb.hpathDBFolder);
OPENBRIEFCASEDATABASE_BAIL:
                  FreeMemory(pbr->bcdb.pszDBName);
               }
            }
            else
            {
               tr = TR_UNAVAILABLE_VOLUME;
               goto OPENBRIEFCASEDATABASE_BAIL;
            }
         }
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TWINRESULTFromLastError(TR_INVALID_PARAMETER);

   return(tr);
}


/*
** CloseBriefcaseDatabase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT CloseBriefcaseDatabase(PBRFCASEDB pbcdb)
{
   TWINRESULT tr;
   TCHAR rgchDBPath[MAX_PATH_LEN];
   FILESTAMP fsDB;

   tr = CloseCachedFile(pbcdb->hcfDB) ? TR_SUCCESS : TR_BRIEFCASE_WRITE_FAILED;

   if (tr == TR_SUCCESS)
      TRACE_OUT((TEXT("CloseBriefcaseDatabase(): Closed cached briefcase database file %s\\%s."),
                 DebugGetPathString(pbcdb->hpathDBFolder),
                 pbcdb->pszDBName));
   else
      WARNING_OUT((TEXT("CloseBriefcaseDatabase(): Failed to close cached briefcase database file %s\\%s."),
                   DebugGetPathString(pbcdb->hpathDBFolder),
                   pbcdb->pszDBName));

   /* Try not to leave a 0-length database laying around. */

   GetPathString(pbcdb->hpathDBFolder, rgchDBPath);
   CatPath(rgchDBPath, pbcdb->pszDBName);

   MyGetFileStamp(rgchDBPath, &fsDB);

   if (fsDB.fscond == FS_COND_EXISTS &&
       (! fsDB.dwcbLowLength && ! fsDB.dwcbHighLength))
   {
      if (DeleteFile(rgchDBPath))
         WARNING_OUT((TEXT("CloseBriefcaseDatabase(): Deleted 0 length database %s\\%s."),
                      DebugGetPathString(pbcdb->hpathDBFolder),
                      pbcdb->pszDBName));
   }

   FreeMemory(pbcdb->pszDBName);
   DeletePath(pbcdb->hpathDBFolder);

   return(tr);
}


/*
** CreateBriefcase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreateBriefcase(PBRFCASE *ppbr, DWORD dwInFlags,
                                  HWND hwndOwner)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_WRITE_PTR(ppbr, PBRFCASE));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_BRFCASE_FLAGS));
   ASSERT(IS_FLAG_CLEAR(dwInFlags, OB_FL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));

   if (AllocateMemory(sizeof(**ppbr), ppbr))
   {
      DWORD dwCPLFlags;

      dwCPLFlags = (RLI_IFL_CONNECT |
                    RLI_IFL_UPDATE |
                    RLI_IFL_LOCAL_SEARCH);

      if (IS_FLAG_SET(dwInFlags, OB_FL_ALLOW_UI))
         SET_FLAG(dwCPLFlags, RLI_IFL_ALLOW_UI);

      if (CreatePathList(dwCPLFlags, hwndOwner, &((*ppbr)->hpathlist)))
      {
         NEWSTRINGTABLE nszt;

         nszt.hbc = NUM_NAME_HASH_BUCKETS;

         if (CreateStringTable(&nszt, &((*ppbr)->hstNames)))
         {
            if (CreateTwinFamilyPtrArray(&((*ppbr)->hpaTwinFamilies)))
            {
               if (CreateFolderPairPtrArray(&((*ppbr)->hpaFolderPairs)))
               {
                  HNODE hnode;

                  if (InsertNodeAtFront(MhlistOpenBriefcases, NULL, (*ppbr), &hnode))
                  {
                     (*ppbr)->dwFlags = dwInFlags;
                     (*ppbr)->hwndOwner = hwndOwner;

                     bResult = TRUE;
                  }
                  else
                  {
                     DestroyFolderPairPtrArray((*ppbr)->hpaFolderPairs);
CREATEBRIEFCASE_BAIL1:
                     DestroyTwinFamilyPtrArray((*ppbr)->hpaTwinFamilies);
CREATEBRIEFCASE_BAIL2:
                     DestroyStringTable((*ppbr)->hstNames);
CREATEBRIEFCASE_BAIL3:
                     DestroyPathList((*ppbr)->hpathlist);
CREATEBRIEFCASE_BAIL4:
                     FreeMemory((*ppbr));
                  }
               }
               else
                  goto CREATEBRIEFCASE_BAIL1;
            }
            else
               goto CREATEBRIEFCASE_BAIL2;
         }
         else
            goto CREATEBRIEFCASE_BAIL3;
      }
      else
         goto CREATEBRIEFCASE_BAIL4;
   }

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*ppbr, CBRFCASE));

   return(bResult);
}


/*
** UnlinkBriefcase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void UnlinkBriefcase(PBRFCASE pbr)
{
   BOOL bContinue;
   HNODE hnode;

   ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));

   for (bContinue = GetFirstNode(MhlistOpenBriefcases, &hnode);
        bContinue;
        bContinue = GetNextNode(hnode, &hnode))
   {
      PBRFCASE pbrTest;

      pbrTest = GetNodeData(hnode);

      ASSERT(IS_VALID_STRUCT_PTR(pbrTest, CBRFCASE));

      if (pbrTest == pbr)
      {
         DeleteNode(hnode);
         break;
      }
   }

   ASSERT(bContinue);

   return;
}


/*
** DestroyBriefcase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT DestroyBriefcase(PBRFCASE pbr)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));

#ifdef DEBUG

   SET_FLAG(pbr->dwFlags, BR_FL_BEING_DELETED);

#endif

   if (IS_FLAG_SET(pbr->dwFlags, BR_FL_DATABASE_OPENED))
      tr = CloseBriefcaseDatabase(&(pbr->bcdb));
   else
      tr = TR_SUCCESS;

   if (IS_FLAG_SET(pbr->dwFlags, BR_FL_ROOT_MONIKER_VALID))
      pbr->pimkRoot->lpVtbl->Release(pbr->pimkRoot);

   DestroyFolderPairPtrArray(pbr->hpaFolderPairs);

   DestroyTwinFamilyPtrArray(pbr->hpaTwinFamilies);

   ASSERT(! GetStringCount(pbr->hstNames));
   DestroyStringTable(pbr->hstNames);

   ASSERT(! GetPathCount(pbr->hpathlist));
   DestroyPathList(pbr->hpathlist);

   FreeMemory(pbr);

   return(tr);
}


/*
** MyWriteDatabase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT MyWriteDatabase(PBRFCASE pbr)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));

   ASSERT(IS_FLAG_SET(pbr->dwFlags, BR_FL_DATABASE_OPENED));

#ifdef DEBUG
   if (IS_FLAG_CLEAR(MdwBriefcaseModuleFlags, BRFCASE_DFL_NO_DB_SAVE))
#endif
   {
      /* Grow the database cache in preparation for writing. */

      ASSERT(MdwcbMaxDatabaseCacheLen > 0);

      if (SetCachedFileCacheSize(pbr->bcdb.hcfDB, MdwcbMaxDatabaseCacheLen)
          != FCR_SUCCESS)
         WARNING_OUT((TEXT("MyWriteDatabase(): Unable to grow database cache to %lu bytes.  Using default database write cache of %lu bytes."),
                      MdwcbMaxDatabaseCacheLen,
                      (DWORD)DEFAULT_DATABASE_CACHE_LEN));

      /* Write the database. */

      tr = WriteTwinDatabase(pbr->bcdb.hcfDB, (HBRFCASE)pbr);

      if (tr == TR_SUCCESS)
      {
         if (CommitCachedFile(pbr->bcdb.hcfDB))
         {
            /* Shrink the database cache back down to its default size. */

            EVAL(SetCachedFileCacheSize(pbr->bcdb.hcfDB,
                                        DEFAULT_DATABASE_CACHE_LEN)
                 == FCR_SUCCESS);

            TRACE_OUT((TEXT("MyWriteDatabase(): Wrote database %s\\%s."),
                       DebugGetPathString(pbr->bcdb.hpathDBFolder),
                       pbr->bcdb.pszDBName));
         }
         else
            tr = TR_BRIEFCASE_WRITE_FAILED;
      }
   }
#ifdef DEBUG
   else
   {
      WARNING_OUT((TEXT("MyWriteDatabase(): Twin database %s\\%s not saved, by request."),
                   DebugGetPathString(pbr->bcdb.hpathDBFolder),
                   pbr->bcdb.pszDBName));

      tr = TR_SUCCESS;
   }
#endif

   return(tr);
}


/*
** MyReadDatabase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT MyReadDatabase(PBRFCASE pbr, DWORD dwInFlags)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_OB_FLAGS));

#ifdef DEBUG
   if (IS_FLAG_CLEAR(MdwBriefcaseModuleFlags, BRFCASE_DFL_NO_DB_RESTORE))
#endif
   {
      DWORD dwcbDatabaseSize;

      /* Is there an exising database to read? */

      dwcbDatabaseSize = GetCachedFileSize(pbr->bcdb.hcfDB);

      if (dwcbDatabaseSize > 0)
      {
         DWORD dwcbMaxCacheSize;

         /* Yes.  Grow the database cache in preparation for reading. */

         /*
          * Use file length instead of MdwcbMaxDatabaseCacheLen if file length
          * is smaller.
          */

         ASSERT(MdwcbMaxDatabaseCacheLen > 0);

         if (dwcbDatabaseSize < MdwcbMaxDatabaseCacheLen)
         {
            dwcbMaxCacheSize = dwcbDatabaseSize;

            WARNING_OUT((TEXT("MyReadDatabase(): Using file size %lu bytes as read cache size for database %s\\%s."),
                         dwcbDatabaseSize,
                         DebugGetPathString(pbr->bcdb.hpathDBFolder),
                         pbr->bcdb.pszDBName));
         }
         else
            dwcbMaxCacheSize = MdwcbMaxDatabaseCacheLen;

         if (TranslateFCRESULTToTWINRESULT(SetCachedFileCacheSize(
                                                            pbr->bcdb.hcfDB,
                                                            dwcbMaxCacheSize))
             != TR_SUCCESS)
            WARNING_OUT((TEXT("MyReadDatabase(): Unable to grow database cache to %lu bytes.  Using default database read cache of %lu bytes."),
                         dwcbMaxCacheSize,
                         (DWORD)DEFAULT_DATABASE_CACHE_LEN));

         tr = ReadTwinDatabase((HBRFCASE)pbr, pbr->bcdb.hcfDB);

         if (tr == TR_SUCCESS)
         {
            ASSERT(! pbr->bcdb.hpathLastSavedDBFolder ||
                   IS_VALID_HANDLE(pbr->bcdb.hpathLastSavedDBFolder, PATH));

            if (pbr->bcdb.hpathLastSavedDBFolder)
            {
               if (IS_FLAG_SET(dwInFlags, OB_FL_TRANSLATE_DB_FOLDER) &&
                   ComparePaths(pbr->bcdb.hpathLastSavedDBFolder,
                                pbr->bcdb.hpathDBFolder) != CR_EQUAL)
                  tr = MyTranslateFolder((HBRFCASE)pbr,
                                         pbr->bcdb.hpathLastSavedDBFolder,
                                         pbr->bcdb.hpathDBFolder);

               DeletePath(pbr->bcdb.hpathLastSavedDBFolder);
               pbr->bcdb.hpathLastSavedDBFolder = NULL;
            }

            if (tr == TR_SUCCESS)
               TRACE_OUT((TEXT("MyReadDatabase(): Read database %s\\%s."),
                          DebugGetPathString(pbr->bcdb.hpathDBFolder),
                          pbr->bcdb.pszDBName));
         }

         /* Shrink the database cache back down to its default size. */

         EVAL(TranslateFCRESULTToTWINRESULT(SetCachedFileCacheSize(
                                                   pbr->bcdb.hcfDB,
                                                   DEFAULT_DATABASE_CACHE_LEN))
              == TR_SUCCESS);
      }
      else
      {
         tr = TR_SUCCESS;

         WARNING_OUT((TEXT("MyReadDatabase(): Database %s\\%s not found."),
                      DebugGetPathString(pbr->bcdb.hpathDBFolder),
                      pbr->bcdb.pszDBName));
      }
   }
#ifdef DEBUG
   else
   {
      WARNING_OUT((TEXT("MyReadDatabase(): Twin database %s\\%s not read, by request."),
                   DebugGetPathString(pbr->bcdb.hpathDBFolder),
                   pbr->bcdb.pszDBName));

      tr = TR_SUCCESS;
   }
#endif

   return(tr);
}


#ifdef DEBUG

/*
** DestroyBriefcaseWalker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/

#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL DestroyBriefcaseWalker(PVOID pbr, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));
   ASSERT(! pvUnused);

   EVAL(DestroyBriefcase(pbr) == TR_SUCCESS);

   return(TRUE);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */

#endif


#ifdef VSTF

/*
** IsValidPCBRFCASE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCBRFCASE(PCBRFCASE pcbr)
{
   BOOL bResult = FALSE;

   if (IS_VALID_READ_PTR(pcbr, CBRFCASE))
   {
      if (FLAGS_ARE_VALID(pcbr->dwFlags, ALL_BRFCASE_FLAGS))
      {
#ifdef DEBUG
         if (IS_FLAG_SET(pcbr->dwFlags, BR_FL_BEING_DELETED))
            bResult = TRUE;
         else
#endif
            bResult = (IS_VALID_HANDLE(pcbr->hstNames, STRINGTABLE) &&
                       IS_VALID_HANDLE(pcbr->hpathlist, PATHLIST) &&
                       IS_VALID_HANDLE(pcbr->hpaTwinFamilies, PTRARRAY) &&
                       IS_VALID_HANDLE(pcbr->hpaFolderPairs, PTRARRAY) &&
                       (IS_FLAG_CLEAR(pcbr->dwFlags, OB_FL_ALLOW_UI) ||
                        IS_VALID_HANDLE(pcbr->hwndOwner, WND)) &&
                       (IS_FLAG_CLEAR(pcbr->dwFlags, BR_FL_ROOT_MONIKER_VALID) ||
                        IS_VALID_STRUCT_PTR(pcbr->pimkRoot, CIMoniker)) &&
                       (IS_FLAG_CLEAR(pcbr->dwFlags, BR_FL_DATABASE_OPENED) ||
                        (IS_FLAG_SET(pcbr->dwFlags, OB_FL_OPEN_DATABASE) &&
                         IS_VALID_STRUCT_PTR(&(pcbr->bcdb), CBRFCASEDB))));
      }
   }

   return(bResult);
}


/*
** IsValidPCBRFCASEDB()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCBRFCASEDB(PCBRFCASEDB pcbcdb)
{
   return(IS_VALID_READ_PTR(pcbcdb, CBRFCASEDB) &&
          IS_VALID_HANDLE(pcbcdb->hpathDBFolder, PATH) &&
          IS_VALID_STRING_PTR(pcbcdb->pszDBName, STR) &&
          IS_VALID_HANDLE(pcbcdb->hcfDB, CACHEDFILE) &&
          (! pcbcdb->hpathLastSavedDBFolder ||
           IS_VALID_HANDLE(pcbcdb->hpathLastSavedDBFolder, PATH)));
}


/*
** IsValidPCOPENBRFCASEINFO()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCOPENBRFCASEINFO(PCOPENBRFCASEINFO pcobri)
{
   return(IS_VALID_READ_PTR(pcobri, COPENBRFCASEINFO) &&
          EVAL(pcobri->ulSize == sizeof(*pcobri)) &&
          FLAGS_ARE_VALID(pcobri->dwFlags, ALL_OB_FLAGS) &&
          ((IS_FLAG_CLEAR(pcobri->dwFlags, OB_FL_ALLOW_UI) &&
            ! pcobri->hwndOwner) ||
           (IS_FLAG_SET(pcobri->dwFlags, OB_FL_ALLOW_UI) &&
            IS_VALID_HANDLE(pcobri->hwndOwner, WND))) &&
          ((IS_FLAG_CLEAR(pcobri->dwFlags, OB_FL_OPEN_DATABASE) &&
            ! pcobri->hvid &&
            ! (pcobri->rgchDatabasePath[0]))) ||
          ((IS_FLAG_SET(pcobri->dwFlags, OB_FL_OPEN_DATABASE) &&
            IS_VALID_HANDLE(pcobri->hvid, VOLUMEID) &&
            IS_VALID_STRING_PTR(pcobri->rgchDatabasePath, CSTR))));
}

#endif


/****************************** Public Functions *****************************/


#ifdef DEBUG

/*
** SetBriefcaseModuleIniSwitches()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SetBriefcaseModuleIniSwitches(void)
{
   BOOL bResult;

   bResult = SetIniSwitches(MrgcpcvisBriefcaseModule,
                            ARRAY_ELEMENTS(MrgcpcvisBriefcaseModule));

   if (! EVAL(MdwcbMaxDatabaseCacheLen > 0))
   {
      MdwcbMaxDatabaseCacheLen = 1;

      WARNING_OUT((TEXT("SetBriefcaseModuleIniSwitches(): Using maximum database cache length of %lu."),
                   MdwcbMaxDatabaseCacheLen));
   }

   ASSERT(FLAGS_ARE_VALID(MdwBriefcaseModuleFlags, ALL_BRFCASE_DFLAGS));

   return(bResult);
}

#endif


/*
** InitBriefcaseModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InitBriefcaseModule(void)
{
   NEWLIST nl;

   ASSERT(! MhlistOpenBriefcases);

   /* Create the module list of open briefcases. */

   ReinitializeNonReentrantCriticalSection(&MnrcsBriefcase);

   nl.dwFlags = 0;

   return(CreateList(&nl, &MhlistOpenBriefcases));
}


/*
** ExitBriefcaseModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ExitBriefcaseModule(void)
{

#ifdef DEBUG

   if (MhlistOpenBriefcases)
   {
      /* Destroy all open briefcases. */

      /*
       * Don't destroy the list of open briefcases in the retail build.  Assume
       * that callers will have closed all open briefcases, so that there are
       * no remaining connections to shut down.
       */

      EVAL(WalkList(MhlistOpenBriefcases, &DestroyBriefcaseWalker, NULL));

      /* Now wipe out the list. */

      DestroyList(MhlistOpenBriefcases);
      MhlistOpenBriefcases = NULL;
   }
   else
      WARNING_OUT((TEXT("ExitBriefcaseModule() called when MhlistOpenBriefcases is NULL.")));

#endif

   return;
}


/*
** GetBriefcaseNameStringTable()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HSTRINGTABLE GetBriefcaseNameStringTable(HBRFCASE hbr)
{
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   return(((PCBRFCASE)hbr)->hstNames);
}


/*
** GetBriefcaseTwinFamilyPtrArray()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HPTRARRAY GetBriefcaseTwinFamilyPtrArray(HBRFCASE hbr)
{
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   return(((PCBRFCASE)hbr)->hpaTwinFamilies);
}


/*
** GetBriefcaseFolderPairPtrArray()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HPTRARRAY GetBriefcaseFolderPairPtrArray(HBRFCASE hbr)
{
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   return(((PCBRFCASE)hbr)->hpaFolderPairs);
}


/*
** GetBriefcasePathList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HPATHLIST GetBriefcasePathList(HBRFCASE hbr)
{
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   return(((PCBRFCASE)hbr)->hpathlist);
}


/*
** GetBriefcaseRootMoniker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT GetBriefcaseRootMoniker(HBRFCASE hbr, PIMoniker *pimk)
{
   HRESULT hr;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_WRITE_PTR(pimk, CIMoniker));

   if (IS_FLAG_CLEAR(((PCBRFCASE)hbr)->dwFlags, BR_FL_ROOT_MONIKER_VALID))
   {
      if (IS_FLAG_SET(((PCBRFCASE)hbr)->dwFlags, BR_FL_DATABASE_OPENED))
      {
         TCHAR rgchRoot[MAX_PATH_LEN];
         WCHAR rgwchUnicodeRoot[MAX_PATH_LEN];
         PIMoniker pimkRoot;

         GetPathString(((PCBRFCASE)hbr)->bcdb.hpathDBFolder, rgchRoot);

#ifdef UNICODE

         hr = CreateFileMoniker(rgchRoot, &pimkRoot);
#else
       
         /* Translate ANSI string into Unicode for OLE. */

         if (0 == MultiByteToWideChar(CP_ACP, 0, rgchRoot, -1, rgwchUnicodeRoot,
                                 ARRAY_ELEMENTS(rgwchUnicodeRoot)))
         {
            hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
         }
         else
         {            
            hr = CreateFileMoniker(rgwchUnicodeRoot, &pimkRoot);
         }

#endif

         if (SUCCEEDED(hr))
         {
            ((PBRFCASE)hbr)->pimkRoot = pimkRoot;
            SET_FLAG(((PBRFCASE)hbr)->dwFlags, BR_FL_ROOT_MONIKER_VALID);

            TRACE_OUT((TEXT("GetBriefcaseRootMoniker(): Created briefcase root moniker %s."),
                       rgchRoot));
         }
      }
      else
         hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND);
   }
   else
      hr = S_OK;

   if (SUCCEEDED(hr))
      *pimk = ((PCBRFCASE)hbr)->pimkRoot;

   ASSERT(FAILED(hr) ||
          IS_VALID_STRUCT_PTR(*pimk, CIMoniker));

   return(hr);
}


/*
** BeginExclusiveBriefcaseAccess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL BeginExclusiveBriefcaseAccess(void)
{
   return(EnterNonReentrantCriticalSection(&MnrcsBriefcase));
}


/*
** EndExclusiveBriefcaseAccess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void EndExclusiveBriefcaseAccess(void)
{
   LeaveNonReentrantCriticalSection(&MnrcsBriefcase);

   return;
}


#ifdef DEBUG

/*
** BriefcaseAccessIsExclusive()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL BriefcaseAccessIsExclusive(void)
{
   return(NonReentrantCriticalSectionIsOwned(&MnrcsBriefcase));
}

#endif   /* DEBUG */


/*
** IsValidHBRFCASE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHBRFCASE(HBRFCASE hbr)
{
   return(IS_VALID_STRUCT_PTR((PCBRFCASE)hbr, CBRFCASE));
}


/*
** WriteBriefcaseInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT WriteBriefcaseInfo(HCACHEDFILE hcf, HBRFCASE hbr)
{
   TWINRESULT tr;
   DBBRFCASE dbbr;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   /* Set up briefcase database structure. */

   ASSERT(IS_VALID_HANDLE(((PCBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder, PATH));

   dbbr.hpathLastSavedDBFolder = ((PCBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder;

   /* Save briefcase database structure. */

   if (WriteToCachedFile(hcf, (PCVOID)&dbbr, sizeof(dbbr), NULL))
   {
      tr = TR_SUCCESS;

      TRACE_OUT((TEXT("WriteBriefcaseInfo(): Wrote last saved database folder %s."),
                 DebugGetPathString(dbbr.hpathLastSavedDBFolder)));
   }
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


/*
** ReadBriefcaseInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT ReadBriefcaseInfo(HCACHEDFILE hcf, HBRFCASE hbr,
                                    HHANDLETRANS hhtFolderTrans)
{
   TWINRESULT tr;
   DBBRFCASE dbbr;
   DWORD dwcbRead;
   HPATH hpath;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));

   /* Read briefcase database structure. */

   if ((ReadFromCachedFile(hcf, &dbbr, sizeof(dbbr), &dwcbRead) &&
        dwcbRead == sizeof(dbbr)) &&
       TranslateHandle(hhtFolderTrans, (HGENERIC)(dbbr.hpathLastSavedDBFolder),
                       (PHGENERIC)&hpath))
   {
      HPATH hpathLastSavedDBFolder;

      /*
       * Bump last saved database folder path's lock count in the briefcase's
       * path list.
       */

      if (CopyPath(hpath, ((PCBRFCASE)hbr)->hpathlist, &hpathLastSavedDBFolder))
      {
         ((PBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder = hpathLastSavedDBFolder;

         tr = TR_SUCCESS;

         TRACE_OUT((TEXT("ReadBriefcaseInfo(): Read last saved database folder %s."),
                    DebugGetPathString(((PBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder)));
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


/***************************** Exported Functions ****************************/


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | OpenBriefcase | Opens an existing briefcase database, or
creates a new briefcase.

@parm PCSTR | pcszPath | A pointer to a path string indicating the briefcase
database to be opened or created.  This parameter is ignored unless the
OB_FL_OPEN_DATABASE flag is set in dwFlags.

@parm DWORD | dwInFlags | A bit mask of flags.  This parameter may be any
combination of the following values:
   OB_FL_OPEN_DATABASE - Open the briefcase database specified by pcszPath.
   OB_FL_TRANSLATE_DB_FOLDER - Translate the folder where the briefcase
   database was last saved to the folder where the briefcase database was
   opened.
   OB_FL_ALLOW_UI - Allow interaction with the user during briefcase
   operations.

@parm HWND | hwndOwner | A handle to the parent window to be used when
requesting user interaction.  This parameter is ignored if the OB_FL_ALLOW_UI
flag is clear.

@parm PHBRFCASE | phbr | A pointer to an HBRFCASE to be filled in with a
handle to the open briefcase.  *phbr is only valid if TR_SUCCESS is returned.

@rdesc If the briefcase was opened or created successfully, TR_SUCCESS is
returned, and *phbr contains a handle to the open briefcase.  Otherwise, the
briefcase was not opened or created successfully, the return value indicates
the error that occurred, and *phbr is undefined.

@comm If the OB_FL_OPEN_DATABASE flag is set in dwFlags, the database specified
by pcszPath is associated with the briefcase.  If the database specified does
not exist, the database is created.<nl>
If the OB_FL_OPEN_DATABASE flag is clear in dwFlags, no persistent database is
associated with the briefcase.  SaveBriefcase() will fail if called on a
briefcase with no associated database.<nl>
Once the caller is finished with the briefcase handle returned by
OpenBriefcase(), CloseBriefcase() should be called to release the briefcase.
SaveBriefcase() may be called before CloseBriefcase() to save the current
contents of the briefcase.

@xref SaveBriefcase CloseBriefcase

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI OpenBriefcase(LPCTSTR pcszPath, DWORD dwInFlags,
                                           HWND hwndOwner, PHBRFCASE phbr)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(OpenBriefcase);

#ifdef EXPV
      /* Verify parameters. */

      if (FLAGS_ARE_VALID(dwInFlags, ALL_OB_FLAGS) &&
          IS_VALID_WRITE_PTR(phbr, HBRFCASE) &&
          (IS_FLAG_CLEAR(dwInFlags, OB_FL_OPEN_DATABASE) ||
           IS_VALID_STRING_PTR(pcszPath, CSTR)) &&
          (IS_FLAG_CLEAR(dwInFlags, OB_FL_ALLOW_UI) ||
           IS_VALID_HANDLE(hwndOwner, WND)))
#endif
      {
         PBRFCASE pbr;

         if (CreateBriefcase(&pbr, dwInFlags, hwndOwner))
         {
            if (IS_FLAG_SET(dwInFlags, OB_FL_OPEN_DATABASE))
            {
               tr = OpenBriefcaseDatabase(pbr, pcszPath);

               if (tr == TR_SUCCESS)
               {
                  tr = MyReadDatabase(pbr, dwInFlags);

                  if (tr == TR_SUCCESS)
                  {
                     if (IS_FLAG_SET(dwInFlags, OB_FL_LIST_DATABASE))
                        EVAL(AddBriefcaseToSystem(pcszPath) == TR_SUCCESS);

                     *phbr = (HBRFCASE)pbr;
                  }
                  else
                  {
OPENBRIEFCASE_BAIL:
                     UnlinkBriefcase(pbr);
                     EVAL(DestroyBriefcase(pbr) == TR_SUCCESS);
                  }
               }
               else
                  goto OPENBRIEFCASE_BAIL;
            }
            else
            {
               *phbr = (HBRFCASE)pbr;
               tr = TR_SUCCESS;

               TRACE_OUT((TEXT("OpenBriefcase(): Opened briefcase %#lx with no associated database, by request."),
                          *phbr));
            }
         }
         else
            tr = TR_OUT_OF_MEMORY;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(OpenBriefcase, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | SaveBriefcase | Saves the contents of an open briefcase to a
briefcase database.

@parm HBRFCASE | hbr | A handle to the briefcase to be saved.  This handle may
be obtained by calling OpenBriefcase() with a briefcase database path and with
the OB_FL_OPEN_DATABASE flag set.  SaveBriefcase() will return
TR_INVALID_PARAMETER if called on a briefcase with no associated briefcase
database.

@rdesc If the contents of the briefcase was saved to the briefcase database
successfully, TR_SUCCESS is returned.  Otherwise, the contents of the briefcase
was not saved to the briefcase database successfully, and the return value
indicates the error that occurred.

@xref OpenBriefcase CloseBriefcase

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI SaveBriefcase(HBRFCASE hbr)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(SaveBriefcase);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE) &&
          IS_FLAG_SET(((PBRFCASE)hbr)->dwFlags, BR_FL_DATABASE_OPENED))
#endif
      {
         ((PBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder = ((PCBRFCASE)hbr)->bcdb.hpathDBFolder;

         tr = MyWriteDatabase((PBRFCASE)hbr);

         ((PBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder = NULL;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(SaveBriefcase, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | CloseBriefcase | Closes an open briefcase.

@parm HBRFCASE | hbr | A handle to the briefcase to be closed.  This handle may
be obtained by calling OpenBriefcase().

@rdesc If the briefcase was closed successfully, TR_SUCCESS is returned.
Otherwise, the briefcase was not closed successfully, and the return value
indicates the error that occurred.

@xref OpenBriefcase SaveBriefcase

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI CloseBriefcase(HBRFCASE hbr)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(CloseBriefcase);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE))
#endif
      {
         UnlinkBriefcase((PBRFCASE)hbr);

         tr = DestroyBriefcase((PBRFCASE)hbr);
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(CloseBriefcase, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | DeleteBriefcase | Deletes a closed briefcase's database file.

@parm PCSTR | pcszPath | A pointer to a path string indicating the briefcase
database that is to be deleted.

@rdesc If the briefcase database was deleted successfully, TR_SUCCESS is
returned.  Otherwise, the briefcase database was not deleted successfully, and
the return value indicates the error that occurred.

@comm Clients should call DeleteBriefcase() instead of DeleteFile() to delete
an unwanted briefcase database so that the the synchronization engine may
verify that the given briefcase database is not in use before deleting it.

@xref OpenBriefcase SaveBriefcase CloseBriefcase

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI DeleteBriefcase(LPCTSTR pcszPath)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(DeleteBriefcase);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_STRING_PTR(pcszPath, CSTR))
#endif
      {
         /*
          * RAIDRAID: (16275) Check database header here to verify that the
          * file is a briefcase database file.
          */

         if (DeleteFile(pcszPath))
         {
            EVAL(RemoveBriefcaseFromSystem(pcszPath) == TR_SUCCESS);

            tr = TR_SUCCESS;
         }
         else
         {
            switch (GetLastError())
            {
               /* Returned when file opened by local machine. */
               case ERROR_SHARING_VIOLATION:
                  tr = TR_BRIEFCASE_LOCKED;
                  break;

               default:
                  tr = TR_BRIEFCASE_OPEN_FAILED;
                  break;
            }
         }
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(DeleteBriefcase, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | GetOpenBriefcaseInfo | Describes an open briefcase.

@parm HBRFCASE | hbr | A handle to the open briefcase to be described.

@parm POPENBRFCASEINFO | pobri | A pointer to an OPENBRFCASEINFO to be filled
in with information describing the open briefcase.  The ulSize field of the
OPENBRFCASEINFO structure should be filled in with sizeof(OPENBRFCASEINFO)
before calling GetOpenBriefcaseInfo().

@rdesc If the open briefcase was described successfully, TR_SUCCESS is
returned.  Otherwise, the open briefcase was not described successfully, and
the return value indicates the error that occurred.

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI GetOpenBriefcaseInfo(HBRFCASE hbr,
                                                  POPENBRFCASEINFO pobri)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(GetBriefcaseInfo);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE) &&
          IS_VALID_WRITE_PTR(pobri, OPENBRFCASEINFO) &&
          EVAL(pobri->ulSize == sizeof(*pobri)))
#endif
      {
         pobri->dwFlags = (((PBRFCASE)hbr)->dwFlags & ~ALL_BR_FLAGS);

         if (IS_FLAG_SET(((PBRFCASE)hbr)->dwFlags, OB_FL_ALLOW_UI))
            pobri->hwndOwner = ((PBRFCASE)hbr)->hwndOwner;
         else
         {
            pobri->hwndOwner = NULL;

            WARNING_OUT((TEXT("GetBriefcaseInfo(): Briefcase %#lx has no associated parent window."),
                         hbr));
         }

         if (IS_FLAG_SET(((PBRFCASE)hbr)->dwFlags, BR_FL_DATABASE_OPENED))
         {
            pobri->hvid = (HVOLUMEID)(((PCBRFCASE)hbr)->bcdb.hpathDBFolder);
            GetPathString(((PCBRFCASE)hbr)->bcdb.hpathDBFolder,
                          pobri->rgchDatabasePath);
            CatPath(pobri->rgchDatabasePath, ((PCBRFCASE)hbr)->bcdb.pszDBName);
         }
         else
         {
            pobri->hvid = NULL;
            pobri->rgchDatabasePath[0] = TEXT('\0');

            WARNING_OUT((TEXT("GetBriefcaseInfo(): Briefcase %#lx has no associated database."),
                         hbr));
         }

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      ASSERT(tr != TR_SUCCESS ||
             IS_VALID_STRUCT_PTR(pobri, COPENBRFCASEINFO));

      DebugExitTWINRESULT(GetBriefcaseInfo, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | ClearBriefcaseCache | Wipes out cached information in an open
briefcase.

@parm HBRFCASE | hbr | A handle to the open briefcase whose cached information
is to be cleared.

@rdesc If the open briefcase's cached information was cleared successfully,
TR_SUCCESS is returned.  Otherwise, the briefcase's cached information was not
cleared successfully, and the return value indicates the error that occurred.

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI ClearBriefcaseCache(HBRFCASE hbr)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(ClearBriefcaseCache);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE))
#endif
      {
         ClearPathListInfo(((PBRFCASE)hbr)->hpathlist);

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(ClearBriefcaseCache, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\brfcase.h ===
/*
 * brfcase.h - Briefcase ADT description.
 */


/* Prototypes
 *************/

/* brfcase.c */

extern BOOL SetBriefcaseModuleIniSwitches(void);
extern BOOL InitBriefcaseModule(void);
extern void ExitBriefcaseModule(void);
extern HSTRINGTABLE GetBriefcaseNameStringTable(HBRFCASE);
extern HPTRARRAY GetBriefcaseTwinFamilyPtrArray(HBRFCASE);
extern HPTRARRAY GetBriefcaseFolderPairPtrArray(HBRFCASE);
extern HPATHLIST GetBriefcasePathList(HBRFCASE);
extern HRESULT GetBriefcaseRootMoniker(HBRFCASE, PIMoniker *);
extern BOOL BeginExclusiveBriefcaseAccess(void);
extern void EndExclusiveBriefcaseAccess(void);

#ifdef DEBUG

extern BOOL BriefcaseAccessIsExclusive(void);

#endif

extern BOOL IsValidHBRFCASE(HBRFCASE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\copy.h ===
/*
 * copy.h - File copy handler module description.
 */


/* Prototypes
 *************/

/* copy.c */

extern void BeginCopy(void);
extern void EndCopy(void);
extern TWINRESULT CopyHandler(PRECNODE, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
extern BOOL NotifyReconciliationStatus(RECSTATUSPROC, UINT, LPARAM, LPARAM);
extern BOOL CreateFolders(LPCTSTR, HPATH);
extern BOOL DestroySubtree(LPCTSTR, HPATH);

#ifdef DEBUG

extern BOOL IsValidRecStatusProcMsg(UINT);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\comc.h ===
/*
 * comc.h - Shared routines description.
 */


/* Prototypes
 *************/

/* comc.c */

extern void CatPath(LPTSTR, LPCTSTR);
extern COMPARISONRESULT MapIntToComparisonResult(int);
extern void MyLStrCpyN(LPTSTR, LPCTSTR, int);

#ifdef DEBUG

extern BOOL IsStringContained(LPCTSTR, LPCTSTR);

#endif   /* DEBUG */

#if defined(_SYNCENG_) || defined(_LINKINFO_)

extern void DeleteLastPathElement(LPTSTR);
extern LONG GetDefaultRegKeyValue(HKEY, LPCTSTR, LPTSTR, PDWORD);
extern BOOL StringCopy(LPCTSTR, LPTSTR *);
extern void CopyRootPath(LPCTSTR, LPTSTR);
extern COMPARISONRESULT ComparePathStrings(LPCTSTR, LPCTSTR);
extern BOOL MyStrChr(LPCTSTR, TCHAR, LPCTSTR *);
extern BOOL PathExists(LPCTSTR);
extern BOOL IsDrivePath(LPCTSTR);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidDriveType(UINT);
extern BOOL IsValidPathSuffix(LPCTSTR);

#endif   /* DEBUG || VSTF */

#ifdef DEBUG

extern BOOL IsRootPath(LPCTSTR);
extern BOOL IsTrailingSlashCanonicalized(LPCTSTR);
extern BOOL IsFullPath(LPCTSTR);
extern BOOL IsCanonicalPath(LPCTSTR);
extern BOOL IsValidCOMPARISONRESULT(COMPARISONRESULT);

#endif   /* DEBUG */

#endif   /* _SYNCENG_ || _LINKINFO_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\clsiface.h ===
/*
 * clsiface.h - Class interface cache ADT description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HCLSIFACECACHE);
DECLARE_STANDARD_TYPES(HCLSIFACECACHE);


/* Prototypes
 *************/

/* rhcache.c */

extern BOOL CreateClassInterfaceCache(PHCLSIFACECACHE);
extern void DestroyClassInterfaceCache(HCLSIFACECACHE);
extern HRESULT GetClassInterface(HCLSIFACECACHE, PCCLSID, PCIID, PVOID *);

#ifdef DEBUG

extern BOOL IsValidHCLSIFACECACHE(HCLSIFACECACHE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\comc.c ===
/*
 * comc.c - Shared routines.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/****************************** Public Functions *****************************/


/*
** CatPath()
**
** Appends a filename to a path string.
**
** Arguments:     pszPath - path string that file name is to be appended to
**                pcszSubPath - path to append
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., truncates path to MAX_PATH_LEN characters in length.
**
** Examples:
**
**    input path        input file name      output path
**    ----------        ---------------      -----------
**    c:\               foo                  c:\foo
**    c:                foo                  c:foo
**    c:\foo\bar\       goo                  c:\foo\bar\goo
**    c:\foo\bar\       \goo                 c:\foo\bar\goo
**    c:\foo\bar\       goo\shoe             c:\foo\bar\goo\shoe
**    c:\foo\bar\       \goo\shoe\           c:\foo\bar\goo\shoe\
**    foo\bar\          goo                  foo\bar\goo
**    <empty string>    <empty string>       <empty string>
**    <empty string>    foo                  foo
**    foo               <empty string>       foo
**    fred              bird                 fred\bird
*/
PUBLIC_CODE void CatPath(LPTSTR pszPath, LPCTSTR pcszSubPath)
{
   LPTSTR pcsz;
   LPTSTR pcszLast;

   ASSERT(IS_VALID_STRING_PTR(pszPath, STR));
   ASSERT(IS_VALID_STRING_PTR(pcszSubPath, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPath, STR, MAX_PATH_LEN - lstrlen(pszPath)));

   /* Find last character in path string. */

   for (pcsz = pcszLast = pszPath; *pcsz; pcsz = CharNext(pcsz))
      pcszLast = pcsz;

   if (IS_SLASH(*pcszLast) && IS_SLASH(*pcszSubPath))
      pcszSubPath++;
   else if (! IS_SLASH(*pcszLast) && ! IS_SLASH(*pcszSubPath))
   {
      if (*pcszLast && *pcszLast != COLON && *pcszSubPath)
         *pcsz++ = TEXT('\\');
   }

   MyLStrCpyN(pcsz, pcszSubPath, MAX_PATH_LEN - (pcsz - pszPath));

   ASSERT(IS_VALID_STRING_PTR(pszPath, STR));

   return;
}


/*
** MapIntToComparisonResult()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT MapIntToComparisonResult(int nResult)
{
   COMPARISONRESULT cr;

   /* Any integer is valid input. */

   if (nResult < 0)
      cr = CR_FIRST_SMALLER;
   else if (nResult > 0)
      cr = CR_FIRST_LARGER;
   else
      cr = CR_EQUAL;

   return(cr);
}


/*
** MyLStrCpyN()
**
** Like lstrcpy(), but the copy is limited to ucb bytes.  The destination
** string is always null-terminated.
**
** Arguments:     pszDest - pointer to destination buffer
**                pcszSrc - pointer to source string
**                ncb - maximum number of bytes to copy, including null
**                      terminator
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., this function behaves quite differently than strncpy()!  It does not
** pad out the destination buffer with null characters, and it always null
** terminates the destination string.
*/
PUBLIC_CODE void MyLStrCpyN(LPTSTR pszDest, LPCTSTR pcszSrc, int ncch)
{
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszDest, STR, ncch * sizeof(TCHAR)));
   ASSERT(IS_VALID_STRING_PTR(pcszSrc, CSTR));
   ASSERT(ncch > 0);

   while (ncch > 1)
   {
      ncch--;

      *pszDest = *pcszSrc;

      if (*pcszSrc)
      {
         pszDest++;
         pcszSrc++;
      }
      else
         break;
   }

   if (ncch == 1)
      *pszDest = TEXT('\0');

   ASSERT(IS_VALID_STRING_PTR(pszDest, STR));
   ASSERT(lstrlen(pszDest) < ncch);
   ASSERT(lstrlen(pszDest) <= lstrlen(pcszSrc));

   return;
}


#ifdef DEBUG

/*
** IsStringContained()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsStringContained(LPCTSTR pcszBigger, LPCTSTR pcszSuffix)
{
   ASSERT(IS_VALID_STRING_PTR(pcszBigger, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszSuffix, CSTR));

   return(pcszSuffix >= pcszBigger &&
          pcszSuffix <= pcszBigger + lstrlen(pcszBigger));
}

#endif


#if defined(_SYNCENG_) || defined(_LINKINFO_)

/*
** DeleteLastPathElement()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DeleteLastPathElement(LPTSTR pszPath)
{
   LPTSTR psz;
   LPTSTR pszLastSep;

   ASSERT(IS_VALID_STRING_PTR(pszPath, STR));

   psz = pszPath;
   pszLastSep = psz;

   while (*psz)
   {
      if (*psz == TEXT('\\'))
         pszLastSep = psz;

      psz = CharNext(psz);
   }

   /*
    * Now truncate the path at the last separator found, or the beginning of
    * the path if no path separators were found.
    */

   *pszLastSep = TEXT('\0');

   ASSERT(IS_VALID_STRING_PTR(pszPath, STR));

   return;
}


/*
** GetDefaultRegKeyValue()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LONG GetDefaultRegKeyValue(HKEY hkeyParent, LPCTSTR pcszSubKey,
                                  LPTSTR pszBuf, PDWORD pdwcbBufLen)
{
   LONG lResult;
   HKEY hkeySubKey;

   ASSERT(IS_VALID_HANDLE(hkeyParent, KEY));
   ASSERT(IS_VALID_STRING_PTR(pcszSubKey, CSTR));
   ASSERT(! pszBuf ||
          IS_VALID_WRITE_BUFFER_PTR(pszBuf, STR, *pdwcbBufLen));

   lResult = RegOpenKeyEx(hkeyParent, pcszSubKey, 0, KEY_QUERY_VALUE,
                          &hkeySubKey);

   if (lResult == ERROR_SUCCESS)
   {
      DWORD dwValueType;

      lResult = RegQueryValueEx(hkeySubKey, NULL, NULL, &dwValueType,
                                (PBYTE)pszBuf, pdwcbBufLen);

      if (lResult == ERROR_SUCCESS)
      {
         ASSERT(dwValueType == REG_SZ);
         /* (+ 1) for null terminator. */
         ASSERT(! pszBuf ||
                (DWORD)(lstrlen(pszBuf) + 1) * sizeof(TCHAR) == *pdwcbBufLen);

         TRACE_OUT((TEXT("GetDefaultRegKeyValue(): Default key value for subkey %s is \"%s\"."),
                    pcszSubKey,
                    pszBuf));
      }
      else
         TRACE_OUT((TEXT("GetDefaultRegKeyValue(): RegQueryValueEx() for subkey %s failed, returning %ld."),
                    pcszSubKey,
                    lResult));

      EVAL(RegCloseKey(hkeySubKey) == ERROR_SUCCESS);
   }
   else
      TRACE_OUT((TEXT("GetDefaultRegKeyValue(): RegOpenKeyEx() for subkey %s failed, returning %ld."),
                 pcszSubKey,
                 lResult));

   return(lResult);
}


/*
** StringCopy()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL StringCopy(LPCTSTR pcszSrc, LPTSTR *ppszCopy)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRING_PTR(pcszSrc, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszCopy, LPTSTR));

   /* (+ 1) for null terminator. */

   bResult = AllocateMemory((lstrlen(pcszSrc) + 1) * sizeof(TCHAR), ppszCopy);

   if (bResult)
      lstrcpy(*ppszCopy, pcszSrc);

   ASSERT(! bResult ||
          IS_VALID_STRING_PTR(*ppszCopy, STR));

   return(bResult);
}


/*
** ComparePathStrings()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT ComparePathStrings(LPCTSTR pcszFirst, LPCTSTR pcszSecond)
{
   ASSERT(IS_VALID_STRING_PTR(pcszFirst, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszSecond, CSTR));

   return(MapIntToComparisonResult(lstrcmpi(pcszFirst, pcszSecond)));
}


/*
** MyStrChr()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL MyStrChr(LPCTSTR pcsz, TCHAR chTarget, LPCTSTR *ppcszTarget)
{
   LPCTSTR pcszFound;

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(! ppcszTarget || IS_VALID_WRITE_PTR(ppcszTarget, LPCTSTR));

   /* This works correctly if chTarget is the null terminator '\0'. */

   while (*pcsz && *pcsz != chTarget)
      pcsz = CharNext(pcsz);

   if (*pcsz == chTarget)
      pcszFound = pcsz;
   else
      pcszFound = NULL;

   if (ppcszTarget)
      *ppcszTarget = pcszFound;

   return(pcszFound != NULL);
}


/*
** PathExists()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL PathExists(LPCTSTR pcszPath)
{
   DWORD dwErrMode;
   BOOL fResult;

   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));

   dwErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

   fResult = (GetFileAttributes(pcszPath) != -1);

   SetErrorMode(dwErrMode);

   return fResult;
}


/*
** IsDrivePath()
**
** Determines whether or not a path is in "c:\" form.
**
** Arguments:     pcszPath - path to examine
**
** Returns:       TRUE if path is in "c:\" form.  FALSE if not.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsDrivePath(LPCTSTR pcszFullPath)
{
   BOOL bResult;

   ASSERT(IsFullPath(pcszFullPath));

   if (lstrlen(pcszFullPath) >= 3 &&
       IsCharAlpha(pcszFullPath[0]) &&
       pcszFullPath[1] == COLON &&
       IS_SLASH(pcszFullPath[2]))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidDriveType()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidDriveType(UINT uDriveType)
{
   BOOL bResult;

   switch (uDriveType)
   {
      case DRIVE_UNKNOWN:
      case DRIVE_NO_ROOT_DIR:
      case DRIVE_REMOVABLE:
      case DRIVE_FIXED:
      case DRIVE_REMOTE:
      case DRIVE_CDROM:
      case DRIVE_RAMDISK:
         bResult = TRUE;
         break;

      default:
         ERROR_OUT((TEXT("IsValidDriveType(): Invalid drive type %u."),
                    uDriveType));
         bResult = FALSE;
         break;
   }

   return(bResult);
}


/*
** IsValidPathSuffix()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** A path suffix should not begin or end with a slash.
*/
PUBLIC_CODE BOOL IsValidPathSuffix(LPCTSTR pcszPathSuffix)
{
   return(IS_VALID_STRING_PTR(pcszPathSuffix, CSTR) &&
          EVAL(lstrlen(pcszPathSuffix) < MAX_PATH_LEN) &&
          EVAL(! IS_SLASH(*pcszPathSuffix)) &&
          EVAL(! IS_SLASH(*CharPrev(pcszPathSuffix, pcszPathSuffix + lstrlen(pcszPathSuffix)))));
}

#endif   /* DEBUG || VSTF */


#ifdef DEBUG

/*
** IsRootPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsRootPath(LPCTSTR pcszFullPath)
{
   TCHAR rgchCanonicalPath[MAX_PATH_LEN];
   DWORD dwOutFlags;
   TCHAR rgchNetResource[MAX_PATH_LEN];
   LPTSTR pszRootPathSuffix;

   ASSERT(IsFullPath(pcszFullPath));

   return(GetCanonicalPathInfo(pcszFullPath, rgchCanonicalPath, &dwOutFlags,
                               rgchNetResource, &pszRootPathSuffix) &&
          ! *pszRootPathSuffix);
}


/*
** IsTrailingSlashCanonicalized()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsTrailingSlashCanonicalized(LPCTSTR pcszFullPath)
{
   BOOL bResult;
   BOOL bSlashLast;
   LPCTSTR pcszLastPathChar;

   ASSERT(IsFullPath(pcszFullPath));

   /* Make sure that the path only ends in a slash for root paths. */

   pcszLastPathChar = CharPrev(pcszFullPath, pcszFullPath + lstrlen(pcszFullPath));

   ASSERT(pcszLastPathChar >= pcszFullPath);

   bSlashLast = IS_SLASH(*pcszLastPathChar);

   /* Is this a root path? */

   if (IsRootPath(pcszFullPath))
      bResult = bSlashLast;
   else
      bResult = ! bSlashLast;

   return(bResult);
}


/*
** IsFullPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsFullPath(LPCTSTR pcszPath)
{
   BOOL bResult = FALSE;
   TCHAR rgchFullPath[MAX_PATH_LEN];

   if (IS_VALID_STRING_PTR(pcszPath, CSTR) &&
       EVAL(lstrlen(pcszPath) < MAX_PATH_LEN))
   {
      DWORD dwPathLen;
      LPTSTR pszFileName;

      dwPathLen = GetFullPathName(pcszPath, ARRAYSIZE(rgchFullPath), rgchFullPath,
                                  &pszFileName);

      if (EVAL(dwPathLen > 0) &&
          EVAL(dwPathLen < ARRAYSIZE(rgchFullPath)))
         bResult = EVAL(ComparePathStrings(pcszPath, rgchFullPath) == CR_EQUAL);
   }

   return(bResult);
}


/*
** IsCanonicalPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsCanonicalPath(LPCTSTR pcszPath)
{
   return(EVAL(IsFullPath(pcszPath)) &&
          EVAL(IsTrailingSlashCanonicalized(pcszPath)));

}


/*
** IsValidCOMPARISONRESULT()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidCOMPARISONRESULT(COMPARISONRESULT cr)
{
   BOOL bResult;

   switch (cr)
   {
      case CR_FIRST_SMALLER:
      case CR_EQUAL:
      case CR_FIRST_LARGER:
         bResult = TRUE;
         break;

      default:
         WARNING_OUT((TEXT("IsValidCOMPARISONRESULT(): Unknown COMPARISONRESULT %d."),
                      cr));
         bResult = FALSE;
         break;
   }

   return(bResult);
}

#endif   /* DEBUG */

#endif   /* _SYNCENG_ || _LINKINFO_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\copy.c ===
/*
 * copy.c - File copy handler module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "oleutil.h"


/* Constants
 ************/

/* size of file copy buffer in bytes */

#define COPY_BUF_SIZE               (64 * 1024)


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_SHARED)

/* lock count for file copy buffer */

PRIVATE_DATA ULONG MulcCopyBufLock = 0;

/* buffer for file copying */

PRIVATE_DATA PBYTE MpbyteCopyBuf = NULL;

/* length of file copy buffer in bytes */

PRIVATE_DATA UINT MucbCopyBufLen = 0;

#pragma data_seg()


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE TWINRESULT SimpleCopy(PRECNODE, RECSTATUSPROC, LPARAM);
PRIVATE_CODE TWINRESULT CreateDestinationFolders(PCRECNODE);
PRIVATE_CODE TWINRESULT CreateCopyBuffer(void);
PRIVATE_CODE void DestroyCopyBuffer(void);
PRIVATE_CODE TWINRESULT CopyFileByHandle(HANDLE, HANDLE, RECSTATUSPROC, LPARAM, ULONG, PULONG);
PRIVATE_CODE TWINRESULT CopyFileByName(PCRECNODE, PRECNODE, RECSTATUSPROC, LPARAM, ULONG, PULONG);
PRIVATE_CODE ULONG DetermineCopyScale(PCRECNODE);
PRIVATE_CODE BOOL IsCopyDestination(PCRECNODE);
PRIVATE_CODE BOOL SetDestinationTimeStamps(PCRECNODE);
PRIVATE_CODE BOOL DeleteFolderProc(LPCTSTR, PCWIN32_FIND_DATA, PVOID);

#ifdef DEBUG

PRIVATE_CODE BOOL CopyBufferIsOk(void);
PRIVATE_CODE BOOL VerifyRECITEMAndSrcRECNODE(PCRECNODE);

#endif


/*
** SimpleCopy()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT SimpleCopy(PRECNODE prnSrc, RECSTATUSPROC rsp,
                              LPARAM lpCallbackData)
{
   TWINRESULT tr;
   ULONG ulScale;
   PRECNODE prnDest;
   ULONG ulCurrent = 0;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(prnSrc, CRECNODE));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));

   ulScale = DetermineCopyScale(prnSrc);

   /* Copy the source file to each destination file. */

   tr = TR_SUCCESS;

   BeginCopy();

   for (prnDest = prnSrc->priParent->prnFirst;
        prnDest;
        prnDest = prnDest->prnNext)
   {
      if (prnDest != prnSrc)
      {
         if (IsCopyDestination(prnDest))
         {
            tr = CopyFileByName(prnSrc, prnDest, rsp, lpCallbackData,
                                ulScale, &ulCurrent);

            if (tr != TR_SUCCESS)
               break;

            ASSERT(ulCurrent <= ulScale);
         }
      }
   }

   EndCopy();

   return(tr);
}


/*
** CreateDestinationFolders()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT CreateDestinationFolders(PCRECNODE pcrnSrc)
{
   TWINRESULT tr = TR_SUCCESS;
   PCRECNODE pcrnDest;

   for (pcrnDest = pcrnSrc->priParent->prnFirst;
        pcrnDest;
        pcrnDest = pcrnDest->prnNext)
   {
      if (pcrnDest->rnaction == RNA_COPY_TO_ME)
      {
         tr = CreateFolders(pcrnDest->pcszFolder,
                            ((PCOBJECTTWIN)(pcrnDest->hObjectTwin))->hpath);

         if (tr != TR_SUCCESS)
            break;
      }
   }

   return(tr);
}


/*
** CreateCopyBuffer()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT CreateCopyBuffer(void)
{
   TWINRESULT tr;

   ASSERT(CopyBufferIsOk());

   /* Has the copy buffer already been allocated? */

   if (MpbyteCopyBuf)
      /* Yes. */
      tr = TR_SUCCESS;
   else
   {
      /* No.  Allocate it. */

      if (AllocateMemory(COPY_BUF_SIZE, &MpbyteCopyBuf))
      {
         MucbCopyBufLen = COPY_BUF_SIZE;
         tr = TR_SUCCESS;

         TRACE_OUT((TEXT("CreateCopyBuffer(): %u byte file copy buffer allocated."),
                    MucbCopyBufLen));
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }

   ASSERT(CopyBufferIsOk());

   return(tr);
}


/*
** DestroyCopyBuffer()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyCopyBuffer(void)
{
   ASSERT(CopyBufferIsOk());

   /* Has the copy buffer already been allocated? */

   if (MpbyteCopyBuf)
   {
      /* Yes.  Free it. */

      FreeMemory(MpbyteCopyBuf);
      MpbyteCopyBuf = NULL;
      TRACE_OUT((TEXT("DestroyCopyBuffer(): %u byte file copy buffer freed."),
                 MucbCopyBufLen));
      MucbCopyBufLen = 0;
   }

   ASSERT(CopyBufferIsOk());

   return;
}


/*
** CopyFileByHandle()
**
** Copies one file to another.
**
** Arguments:     hfSrc - file handle to open source file
**                hfDest - file handle to open destination file
**
** Returns:       TWINRESULT
**
** Side Effects:  Leaves the file pointer of each file at the end of the file.
*/
PRIVATE_CODE TWINRESULT CopyFileByHandle(HANDLE hfSrc, HANDLE hfDest,
                                    RECSTATUSPROC rsp, LPARAM lpCallbackData,
                                    ULONG ulScale, PULONG pulcbTotal)
{
   TWINRESULT tr;

   /* lpCallbackData may be any value. */
   /* ulScale may be any value. */

   ASSERT(IS_VALID_HANDLE(hfSrc, FILE));
   ASSERT(IS_VALID_HANDLE(hfDest, FILE));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSROC));
   ASSERT(IS_VALID_WRITE_PTR(pulcbTotal, ULONG));

   /* Make sure the copy buffer has been created. */

   tr = CreateCopyBuffer();

   if (tr == TR_SUCCESS)
   {
      BeginCopy();

      /* Move to the beginning of the files. */

      if (SetFilePointer(hfSrc, 0, NULL, FILE_BEGIN) != INVALID_SEEK_POSITION)
      {
         if (SetFilePointer(hfDest, 0, NULL, FILE_BEGIN) != INVALID_SEEK_POSITION)
         {
            do
            {
               DWORD dwcbRead;

               if (ReadFile(hfSrc, MpbyteCopyBuf, MucbCopyBufLen, &dwcbRead,
                            NULL))
               {
                  if (dwcbRead)
                  {
                     DWORD dwcbWritten;

                     if (WriteFile(hfDest, MpbyteCopyBuf, dwcbRead,
                                   &dwcbWritten, NULL) &&
                         dwcbWritten == dwcbRead)
                     {
                        RECSTATUSUPDATE rsu;

                        ASSERT(*pulcbTotal <= ULONG_MAX - dwcbRead);

                        *pulcbTotal += dwcbRead;

                        rsu.ulProgress = *pulcbTotal;
                        rsu.ulScale = ulScale;

                        if (! NotifyReconciliationStatus(rsp, RS_DELTA_COPY,
                                                         (LPARAM)&rsu,
                                                         lpCallbackData))
                           tr = TR_ABORT;
                     }
                     else
                        tr = TR_DEST_WRITE_FAILED;
                  }
                  else
                     /* Hit EOF.  Stop. */
                     break;
               }
               else
                  tr = TR_SRC_READ_FAILED;
            } while (tr == TR_SUCCESS);
         }
         else
            tr = TR_DEST_WRITE_FAILED;
      }
      else
         tr = TR_SRC_READ_FAILED;

      EndCopy();
   }

   return(tr);
}

// MakeAnsiPath
//
// Copys path pszIn to pszOut, ensuring that pszOut has a valid ANSI mapping

void MakeAnsiPath(LPTSTR pszIn, LPTSTR pszOut)
{
#ifdef UNICODE
    CHAR szAnsi[MAX_PATH];
    pszOut[0] = L'\0';

    WideCharToMultiByte(CP_ACP, 0, pszIn, -1, szAnsi, ARRAYSIZE(szAnsi), NULL, NULL);
    MultiByteToWideChar(CP_ACP, 0, szAnsi,   -1, pszOut, MAX_PATH);
    if (lstrcmp(pszOut, pszIn))
    {
        // Cannot convert losslessly from Unicode -> Ansi, so get the short path

        lstrcpyn(pszOut, pszIn, MAX_PATH);
        SheShortenPath(pszOut, TRUE);
    }
#else
    lstrcpyn(pszOut, pszIn, MAX_PATH);
#endif
}

/*
** CopyFileByName()
**
** Copies one file over another.
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  Copies source file's time stamp to destination file.
*/
PRIVATE_CODE TWINRESULT CopyFileByName(PCRECNODE pcrnSrc, PRECNODE prnDest,
                                  RECSTATUSPROC rsp, LPARAM lpCallbackData,
                                  ULONG ulScale, PULONG pulcbTotal)
{
   TWINRESULT tr;
   TCHAR rgchSrcPath[MAX_PATH_LEN];
   TCHAR rgchDestPath[MAX_PATH_LEN];

   /* lpCallbackData may be any value. */
   /* ulScale may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pcrnSrc, CRECNODE));
   ASSERT(IS_VALID_STRUCT_PTR(prnDest, CRECNODE));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSROC));
   ASSERT(IS_VALID_WRITE_PTR(pulcbTotal, ULONG));

   /* Create source path string. */

   ComposePath(rgchSrcPath, pcrnSrc->pcszFolder, pcrnSrc->priParent->pcszName);
   ASSERT(lstrlen(rgchSrcPath) < ARRAYSIZE(rgchSrcPath));

   /* Create destination path string. */

   ComposePath(rgchDestPath, prnDest->pcszFolder, prnDest->priParent->pcszName);
   ASSERT(lstrlen(rgchDestPath) < ARRAYSIZE(rgchDestPath));

   /* Check volumes. */

   if (MyIsPathOnVolume(rgchSrcPath, (HPATH)(pcrnSrc->hvid)) &&
       MyIsPathOnVolume(rgchDestPath, (HPATH)(prnDest->hvid)))
   {
      FILESTAMP fsSrc;
      FILESTAMP fsDest;

      /* Compare current file stamps with recorded file stamps. */

      MyGetFileStamp(rgchSrcPath, &fsSrc);
      MyGetFileStamp(rgchDestPath, &fsDest);

      if (! MyCompareFileStamps(&(pcrnSrc->fsCurrent), &fsSrc) &&
          ! MyCompareFileStamps(&(prnDest->fsCurrent), &fsDest))
      {
         HANDLE hfSrc;

         /* Open source file.  Assume source file will be read sequentially. */

         hfSrc = CreateFile(rgchSrcPath, GENERIC_READ, FILE_SHARE_READ, NULL,
                            OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

         if (hfSrc != INVALID_HANDLE_VALUE)
         {
            HANDLE hfDest;

            /*
             * Create destination file.  Assume destination file will be
             * written sequentially.
             */

            TCHAR szAnsiPath[MAX_PATH];
            MakeAnsiPath(rgchDestPath, szAnsiPath);

            hfDest = CreateFile(szAnsiPath, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS,
                        (FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN),
                        NULL);

            if (hfDest != INVALID_HANDLE_VALUE)
            {
               /* Everything is cool.  Copy the file. */

               tr = CopyFileByHandle(hfSrc, hfDest, rsp,
                                     lpCallbackData, ulScale,
                                     pulcbTotal);

               if (tr == TR_SUCCESS)
               {
                  /*
                   * Set the destination file's time stamp to the source
                   * file's time stamp to assist clients that don't maintain
                   * a persistent briefcase database, like MPR.  Failure to
                   * set the time stamp is not fatal.
                   */

                  if (! SetFileTime(hfDest, NULL, NULL,
                                    &(pcrnSrc->fsCurrent.ftMod)))
                     WARNING_OUT((TEXT("CopyFileByName(): Failed to set last modification time stamp of destination file %s to match source file %s."),
                                  rgchDestPath,
                                  rgchSrcPath));
               }

               /* Failing to close the destination file is fatal here. */

               if (! CloseHandle(hfDest) && tr == TR_SUCCESS)
                  tr = TR_DEST_WRITE_FAILED;
            }
            else
               tr = TR_DEST_OPEN_FAILED;

            /* Failing to close the source file successfully is not fatal. */

            CloseHandle(hfSrc);
         }
         else
            tr = TR_SRC_OPEN_FAILED;
      }
      else
         tr = TR_FILE_CHANGED;
   }
   else
      tr = TR_UNAVAILABLE_VOLUME;

#ifdef DEBUG

   if (tr == TR_SUCCESS)
      TRACE_OUT((TEXT("CopyFileByName(): %s\\%s copied to %s\\%s."),
                 pcrnSrc->pcszFolder,
                 pcrnSrc->priParent->pcszName,
                 prnDest->pcszFolder,
                 prnDest->priParent->pcszName));

   else
      TRACE_OUT((TEXT("CopyFileByName(): Failed to copy %s\\%s to %s\\%s."),
                 pcrnSrc->pcszFolder,
                 pcrnSrc->priParent->pcszName,
                 prnDest->pcszFolder,
                 prnDest->priParent->pcszName));

#endif

   return(tr);
}


/*
** DetermineCopyScale()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG DetermineCopyScale(PCRECNODE pcrnSrc)
{
   DWORD dwcbSrcFileLen;
   PCRECNODE pcrn;
   ULONG ulScale = 0;

   ASSERT(IS_VALID_STRUCT_PTR(pcrnSrc, CRECNODE));

   /*
    * RAIDRAID: (16257) If anyone tries to copy more than 4 Gb of files, this
    * scaling calculation is broken.
    */

   ASSERT(! pcrnSrc->fsCurrent.dwcbHighLength);
   dwcbSrcFileLen = pcrnSrc->fsCurrent.dwcbLowLength;

   for (pcrn = pcrnSrc->priParent->prnFirst; pcrn; pcrn = pcrn->prnNext)
   {
      if (pcrn != pcrnSrc)
      {
         if (IsCopyDestination(pcrn))
         {
            ASSERT(ulScale < ULONG_MAX - dwcbSrcFileLen);
            ulScale += dwcbSrcFileLen;
         }
      }
   }

   TRACE_OUT((TEXT("DetermineCopyScale(): Scale for %s is %lu."),
              pcrnSrc->priParent->pcszName,
              ulScale));

   return(ulScale);
}


/*
** IsCopyDestination()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsCopyDestination(PCRECNODE pcrn)
{
   BOOL bDest = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(pcrn, CRECNODE));

   switch (pcrn->priParent->riaction)
   {
      case RIA_COPY:
         switch (pcrn->rnaction)
         {
            case RNA_COPY_TO_ME:
               bDest = TRUE;
               break;

            default:
               break;
         }
         break;

      case RIA_MERGE:
         switch (pcrn->rnaction)
         {
            case RNA_COPY_TO_ME:
            case RNA_MERGE_ME:
               bDest = TRUE;
               break;

            default:
               break;
         }
         break;

      default:
         ERROR_OUT((TEXT("IsCopyDestination(): Bad RECITEM action %d."),
                    pcrn->priParent->riaction));
         break;
   }

   return(bDest);
}


/*
** SetDestinationTimeStamps()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetDestinationTimeStamps(PCRECNODE pcrnSrc)
{
   BOOL bResult = TRUE;
   PCRECNODE pcrn;

   ASSERT(IS_VALID_STRUCT_PTR(pcrnSrc, CRECNODE));

   for (pcrn = pcrnSrc->priParent->prnFirst;
        pcrn;
        pcrn = pcrn->prnNext)
   {
      if (pcrn->rnaction == RNA_COPY_TO_ME)
      {
         TCHAR rgchPath[MAX_PATH_LEN];
         HANDLE hfDest;

         ComposePath(rgchPath, pcrn->pcszFolder, pcrn->priParent->pcszName);
         ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

         hfDest = CreateFile(rgchPath, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL, NULL);

         if (hfDest != INVALID_HANDLE_VALUE)
         {
            if (! SetFileTime(hfDest, NULL, NULL, &(pcrnSrc->fsCurrent.ftMod)))
               bResult = FALSE;

            if (! CloseHandle(hfDest))
               bResult = FALSE;
         }
         else
            bResult = FALSE;

         if (bResult)
            TRACE_OUT((TEXT("SetDestinationTimeStamps(): Set last modification time stamp of %s to match last modification time stamp of %s\\%s."),
                       rgchPath,
                       pcrnSrc->pcszFolder,
                       pcrnSrc->priParent->pcszName));
         else
            WARNING_OUT((TEXT("SetDestinationTimeStamps(): Failed to set last modification time stamp of %s to match last modification time stamp of %s\\%s."),
                         rgchPath,
                         pcrnSrc->pcszFolder,
                         pcrnSrc->priParent->pcszName));
      }
   }

   return(bResult);
}


/*
** DeleteFolderProc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL DeleteFolderProc(LPCTSTR pcszFolder, PCWIN32_FIND_DATA pcwfd,
                                   PVOID ptr)
{
   ASSERT(IsCanonicalPath(pcszFolder));
   ASSERT(IS_VALID_READ_PTR(pcwfd, CWIN32_FIND_DATA));
   ASSERT(IS_VALID_WRITE_PTR(ptr, TWINRESULT));

   if (IS_ATTR_DIR(pcwfd->dwFileAttributes))
   {
      TCHAR rgchPath[MAX_PATH_LEN];

      ComposePath(rgchPath, pcszFolder, pcwfd->cFileName);
      ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

      if (RemoveDirectory(rgchPath))
      {
         WARNING_OUT((TEXT("DeleteFolderProc(): Removed folder %s."),
                      rgchPath));

         NotifyShell(rgchPath, NSE_DELETE_FOLDER);
      }
      else
      {
         WARNING_OUT((TEXT("DeleteFolderProc(): Failed to remove folder %s."),
                      rgchPath));

         *(PTWINRESULT)ptr = TR_DEST_WRITE_FAILED;
      }
   }
   else
      TRACE_OUT((TEXT("DeleteFolderProc(): Skipping file %s\\%s."),
                 pcszFolder,
                 pcwfd->cFileName));

   return(TRUE);
}


#ifdef DEBUG

/*
** CopyBufferIsOk()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CopyBufferIsOk(void)
{
   /* Are the module copy buffer variables in a correct state? */

   return((! MucbCopyBufLen &&
           ! MpbyteCopyBuf) ||
          (MucbCopyBufLen > 0 &&
           IS_VALID_WRITE_BUFFER_PTR(MpbyteCopyBuf, BYTE, MucbCopyBufLen)));
}


/*
** VerifyRECITEMAndSrcRECNODE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL VerifyRECITEMAndSrcRECNODE(PCRECNODE pcrnSrc)
{
   /* Do the RECITEM and source RECNODE actions match? */

   return((pcrnSrc->priParent->riaction == RIA_COPY &&
           pcrnSrc->rnaction == RNA_COPY_FROM_ME) ||
          (pcrnSrc->priParent->riaction == RIA_MERGE &&
           pcrnSrc->rnaction == RNA_MERGE_ME));
}

#endif


/****************************** Public Functions *****************************/


/*
** BeginCopy()
**
** Increments copy buffer lock count.
**
** Arguments:
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void BeginCopy(void)
{
   ASSERT(CopyBufferIsOk());

   ASSERT(MulcCopyBufLock < ULONG_MAX);
   MulcCopyBufLock++;

   ASSERT(CopyBufferIsOk());

   return;
}


/*
** EndCopy()
**
** Decrements copy buffer lock count.
**
** Arguments:
**
** Returns:       void
**
** Side Effects:  Frees copy buffer if lock count goes to 0.
*/
PUBLIC_CODE void EndCopy(void)
{
   ASSERT(CopyBufferIsOk());

   /* Is the copy buffer still locked? */

   if (! --MulcCopyBufLock)
      DestroyCopyBuffer();

   ASSERT(CopyBufferIsOk());

   return;
}


/*
** CopyHandler()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT CopyHandler(PRECNODE prnSrc, RECSTATUSPROC rsp,
                                   LPARAM lpCallbackData, DWORD dwFlags,
                                   HWND hwndOwner, HWND hwndProgressFeedback)
{
   TWINRESULT tr;
   RECSTATUSUPDATE rsu;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(prnSrc, CRECNODE));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_RI_FLAGS));
   ASSERT(IS_FLAG_CLEAR(dwFlags, RI_FL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_FLAG_CLEAR(dwFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
          IS_VALID_HANDLE(hwndProgressFeedback, WND));

   ASSERT(VerifyRECITEMAndSrcRECNODE(prnSrc));

   /* 0% complete. */

   rsu.ulScale = 1;
   rsu.ulProgress = 0;

   if (NotifyReconciliationStatus(rsp, RS_BEGIN_COPY, (LPARAM)&rsu,
                                  lpCallbackData))
   {
      tr = CreateDestinationFolders(prnSrc);

      if (tr == TR_SUCCESS)
      {
         TCHAR rgchPath[MAX_PATH_LEN];
         CLSID clsidReconciler;
         HRESULT hr;

         ComposePath(rgchPath, prnSrc->pcszFolder, prnSrc->priParent->pcszName);
         ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

         if (SUCCEEDED(GetCopyHandlerClassID(rgchPath, &clsidReconciler)))
         {
            hr = OLECopy(prnSrc, &clsidReconciler, rsp, lpCallbackData,
                         dwFlags, hwndOwner, hwndProgressFeedback);

            if (SUCCEEDED(hr))
            {
               if (hr != S_FALSE)
               {
                  /*
                   * Set the destination files' time stamps to the source
                   * file's time stamp to assist clients that don't maintain
                   * a persistent briefcase database, like MPR.  Failure to
                   * set the time stamps is not fatal.
                   */

                  ASSERT(hr == REC_S_IDIDTHEUPDATES);
                  TRACE_OUT((TEXT("CopyHandler(): OLECopy() on %s returned %s."),
                             rgchPath,
                             GetHRESULTString(hr)));

                  if (! SetDestinationTimeStamps(prnSrc))
                     WARNING_OUT((TEXT("CopyHandler(): SetDestinationTimeStamps() failed.  Not all destination files have been marked with source file's time stamp.")));

                  tr = TR_SUCCESS;
               }
               else
               {
                  WARNING_OUT((TEXT("CopyHandler(): OLECopy() on %s returned %s.  Resorting to internal copy routine."),
                               rgchPath,
                               GetHRESULTString(hr)));

                  /*
                   * Update the source RECNODE's file stamp in case it was
                   * changed by the reconciler.
                   */

                  MyGetFileStampByHPATH(((PCOBJECTTWIN)(prnSrc->hObjectTwin))->hpath,
                     GetString(((PCOBJECTTWIN)(prnSrc->hObjectTwin))->ptfParent->hsName),
                     &(prnSrc->fsCurrent));

                  tr = SimpleCopy(prnSrc, rsp, lpCallbackData);
               }
            }
            else
               tr = TranslateHRESULTToTWINRESULT(hr);
         }
         else
            tr = SimpleCopy(prnSrc, rsp, lpCallbackData);

         if (tr == TR_SUCCESS)
         {
            /* 100% complete. */

            rsu.ulScale = 1;
            rsu.ulProgress = 1;

            /* Don't allow abort here. */

            NotifyReconciliationStatus(rsp, RS_END_COPY, (LPARAM)&rsu,
                                       lpCallbackData);
         }
      }
   }
   else
      tr = TR_ABORT;

   return(tr);
}


/*
** NotifyReconciliationStatus()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL NotifyReconciliationStatus(RECSTATUSPROC rsp, UINT uMsg, LPARAM lp,
                                       LPARAM lpCallbackData)
{
   BOOL bContinue;

   /* lp may be any value. */
   /* lpCallbackData may be any value. */

   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSROC));
   ASSERT(IsValidRecStatusProcMsg(uMsg));

   if (rsp)
   {
      TRACE_OUT((TEXT("NotifyReconciliationStatus(): Calling RECSTATUSPROC with message %s, ulProgress %lu, ulScale %lu, callback data %#lx."),
                 GetRECSTATUSPROCMSGString(uMsg),
                 ((PCRECSTATUSUPDATE)lp)->ulProgress,
                 ((PCRECSTATUSUPDATE)lp)->ulScale,
                 lpCallbackData));

      bContinue = (*rsp)(uMsg, lp, lpCallbackData);
   }
   else
   {
      TRACE_OUT((TEXT("NotifyReconciliationStatus(): Not calling NULL RECSTATUSPROC with message %s, ulProgress %lu, ulScale %lu, callback data %#lx."),
                 GetRECSTATUSPROCMSGString(uMsg),
                 ((PCRECSTATUSUPDATE)lp)->ulProgress,
                 ((PCRECSTATUSUPDATE)lp)->ulScale,
                 lpCallbackData));

      bContinue = TRUE;
   }

   if (! bContinue)
      WARNING_OUT((TEXT("NotifyReconciliationStatus(): Client callback aborted reconciliation.")));

   return(bContinue);
}


/*
** CreateFolders()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT CreateFolders(LPCTSTR pcszPath, HPATH hpath)
{
   TWINRESULT tr;

   ASSERT(IsCanonicalPath(pcszPath));
   ASSERT(IS_VALID_HANDLE(hpath, PATH));

   if (MyIsPathOnVolume(pcszPath, hpath))
   {
      TCHAR rgchPath[MAX_PATH_LEN];
      LPTSTR pszRootEnd;
      LPTSTR pszHackSlash;

      /* Create working copy of path. */

      ASSERT(lstrlen(pcszPath) < ARRAYSIZE(rgchPath));
      lstrcpy(rgchPath, pcszPath);

      pszRootEnd = FindEndOfRootSpec(rgchPath, hpath);

      /*
       * Hack off the path at each successive slash, and check to see if that
       * folder needs to be created.
       */

      tr = TR_SUCCESS;

      pszHackSlash = pszRootEnd;

      while (*pszHackSlash)
      {
         TCHAR chReplaced;

         while (*pszHackSlash && *pszHackSlash != TEXT('\\'))
            pszHackSlash = CharNext(pszHackSlash);

         /* Replace the slash with a null terminator to set the current folder. */

         chReplaced = *pszHackSlash;
         *pszHackSlash = TEXT('\0');

         /* Does the folder exist? */

         if (! PathExists(rgchPath))
         {
            /* No.  Try to create it. */

            TCHAR szAnsiPath[MAX_PATH];
            MakeAnsiPath(rgchPath, szAnsiPath);

            if (CreateDirectory(szAnsiPath, NULL))
            {
               WARNING_OUT((TEXT("CreateFolders(): Created folder %s."),
                            rgchPath));

               NotifyShell(rgchPath, NSE_CREATE_FOLDER);
            }
            else
            {
               WARNING_OUT((TEXT("CreateFolders(): Failed to create folder %s."),
                            rgchPath));

               tr = TR_DEST_OPEN_FAILED;
               break;
            }
         }

         *pszHackSlash = chReplaced;

         if (chReplaced)
            pszHackSlash++;
      }
   }
   else
      tr = TR_UNAVAILABLE_VOLUME;

   return(tr);
}


/*
** DestroySubtree()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT DestroySubtree(LPCTSTR pcszPath, HPATH hpath)
{
   TWINRESULT tr;

   ASSERT(IsCanonicalPath(pcszPath));
   ASSERT(IS_VALID_HANDLE(hpath, PATH));

   if (MyIsPathOnVolume(pcszPath, hpath))
   {
      tr = ExpandSubtree(hpath, &DeleteFolderProc, &tr);

      if (tr == TR_SUCCESS)
      {
         if (RemoveDirectory(pcszPath))
         {
            WARNING_OUT((TEXT("DestroySubtree(): Subtree %s removed successfully."),
                         pcszPath));

            NotifyShell(pcszPath, NSE_DELETE_FOLDER);
         }
         else
         {
            if (PathExists(pcszPath))
            {
               /* Still there. */

               WARNING_OUT((TEXT("DestroySubtree(): Failed to remove subtree root %s."),
                            pcszPath));

               tr = TR_DEST_WRITE_FAILED;
            }
            else
               /* Already gone. */
               tr = TR_SUCCESS;
         }
      }
   }
   else
      tr = TR_UNAVAILABLE_VOLUME;

   return(tr);
}


#ifdef DEBUG

/*
** IsValidRecStatusProcMsg()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidRecStatusProcMsg(UINT uMsg)
{
   BOOL bResult;

   switch (uMsg)
   {
      case RS_BEGIN_COPY:
      case RS_DELTA_COPY:
      case RS_END_COPY:
      case RS_BEGIN_MERGE:
      case RS_DELTA_MERGE:
      case RS_END_MERGE:
      case RS_BEGIN_DELETE:
      case RS_DELTA_DELETE:
      case RS_END_DELETE:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidRecStatusProcMsg(): Invalid RecStatusProc() message %u."),
                    uMsg));
         break;
   }

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\clsiface.c ===
/*
 * clsiface.c - Class interface cache ADT module.
 */


/*



*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "oleutil.h"


/* Constants
 ************/

/* class interface cache pointer array allocation parameters */

#define NUM_START_CLS_IFACES           (0)
#define NUM_CLS_IFACES_TO_ADD          (16)


/* Types
 ********/

/* class interface cache */

typedef struct _clsifacecache
{
   HPTRARRAY hpa;
}
CLSIFACECACHE;
DECLARE_STANDARD_TYPES(CLSIFACECACHE);

/* class interface */

typedef struct _clsiface
{
   /* class ID */

   PCCLSID pcclsid;

   /* interface ID */

   PCIID pciid;

   /* interface */

   PVOID pvInterface;
}
CLSIFACE;
DECLARE_STANDARD_TYPES(CLSIFACE);

/* class interface search structure for ClassInterfaceSearchCmp() */

typedef struct _clsifacesearchinfo
{
   /* class ID */

   PCCLSID pcclsid;

   /* interface ID */

   PCIID pciid;
}
CLSIFACESEARCHINFO;
DECLARE_STANDARD_TYPES(CLSIFACESEARCHINFO);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL CreateClassInterfacePtrArray(PHPTRARRAY);
PRIVATE_CODE void DestroyClassInterfacePtrArray(HPTRARRAY);
PRIVATE_CODE HRESULT CreateClassInterface(PCCLSIFACECACHE, PCCLSID, PCIID, PCLSIFACE *);
PRIVATE_CODE void DestroyClassInterface(PCLSIFACE);
PRIVATE_CODE COMPARISONRESULT ClassInterfaceSortCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT ClassInterfaceSearchCmp(PCVOID, PCVOID);

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCCLSIFACECACHE(PCCLSIFACECACHE);
PRIVATE_CODE BOOL IsValidPCCLSIFACE(PCCLSIFACE);
PRIVATE_CODE BOOL IsValidPCCLSIFACESEARCHINFO(PCCLSIFACESEARCHINFO);

#endif


/*
** CreateClassInterfacePtrArray()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreateClassInterfacePtrArray(PHPTRARRAY phpa)
{
   NEWPTRARRAY npa;

   ASSERT(IS_VALID_WRITE_PTR(phpa, HPTRARRAY));

   npa.aicInitialPtrs = NUM_START_CLS_IFACES;
   npa.aicAllocGranularity = NUM_CLS_IFACES_TO_ADD;
   npa.dwFlags = NPA_FL_SORTED_ADD;

   return(CreatePtrArray(&npa, phpa));
}


/*
** DestroyClassInterfacePtrArray()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyClassInterfacePtrArray(HPTRARRAY hpa)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   /* First free all class interfaces in array. */

   aicPtrs = GetPtrCount(hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      DestroyClassInterface(GetPtr(hpa, ai));

   /* Now wipe out the array. */

   DestroyPtrArray(hpa);

   return;
}


/*
** CreateClassInterface()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT CreateClassInterface(PCCLSIFACECACHE pccic,
                                          PCCLSID pcclsid, PCIID pciid,
                                          PCLSIFACE *ppci)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRUCT_PTR(pccic, CCLSIFACECACHE));
   ASSERT(IS_VALID_STRUCT_PTR(pcclsid, CCLSID));
   ASSERT(IS_VALID_STRUCT_PTR(pciid, CIID));
   ASSERT(IS_VALID_WRITE_PTR(ppci, PCLSIFACE));

   if (AllocateMemory(sizeof(**ppci), ppci))
   {
      /* Use inproc servers and local servers. */

      hr = CoCreateInstance(pcclsid, NULL, CLSCTX_SERVER, pciid,
                            &((*ppci)->pvInterface));

      if (SUCCEEDED(hr))
      {
         ARRAYINDEX ai;

         (*ppci)->pcclsid = pcclsid;
         (*ppci)->pciid = pciid;

         if (! AddPtr(pccic->hpa, ClassInterfaceSortCmp, *ppci, &ai))
         {
            hr = E_OUTOFMEMORY;
CREATECLASSINTERFACE_BAIL:
            FreeMemory(*ppci);
         }
      }
      else
      {
         WARNING_OUT((TEXT("CreateClassInterface(): CoCreateInstance() failed, returning %s."),
                      GetHRESULTString(hr)));

         goto CREATECLASSINTERFACE_BAIL;
      }
   }
   else
      hr = E_OUTOFMEMORY;

   ASSERT(FAILED(hr) ||
          IS_VALID_STRUCT_PTR(*ppci, CCLSIFACE));

   return(hr);
}


/*
** DestroyClassInterface()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyClassInterface(PCLSIFACE pci)
{
   ASSERT(IS_VALID_STRUCT_PTR(pci, CCLSIFACE));

   ((PCIUnknown)(pci->pvInterface))->lpVtbl->Release(pci->pvInterface);
   FreeMemory(pci);

   return;
}


/*
** ClassInterfaceSortCmp()
**
** Pointer comparison function used to sort an array of pointers to class
** interfaces.
**
** Arguments:     pcci1 - pointer to first class interface
**                pcci2 - pointer to second class interface
**
** Returns:
**
** Side Effects:  none
**
** The class interfaces are sorted by:
**    1) CLSID
**    2) IID
*/
PRIVATE_CODE COMPARISONRESULT ClassInterfaceSortCmp(PCVOID pcci1, PCVOID pcci2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pcci1, CCLSIFACE));
   ASSERT(IS_VALID_STRUCT_PTR(pcci2, CCLSIFACE));

   cr = CompareClassIDs(((PCCLSIFACE)pcci1)->pcclsid,
                        ((PCCLSIFACE)pcci2)->pcclsid);

   if (cr == CR_EQUAL)
      cr = CompareInterfaceIDs(((PCCLSIFACE)pcci1)->pciid,
                               ((PCCLSIFACE)pcci2)->pciid);

   return(cr);
}


/*
** ClassInterfaceSearchCmp()
**
** Pointer comparison function used to search an array of pointers to class
** interfaces.
**
** Arguments:     pccisi - pointer to class interface search information
**                pcci - pointer to class interface to examine
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE COMPARISONRESULT ClassInterfaceSearchCmp(PCVOID pccisi,
                                                      PCVOID pcci)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pccisi, CCLSIFACESEARCHINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pcci, CCLSIFACE));

   cr = CompareClassIDs(((PCCLSIFACESEARCHINFO)pccisi)->pcclsid,
                        ((PCCLSIFACE)pcci)->pcclsid);

   if (cr == CR_EQUAL)
      cr = CompareInterfaceIDs(((PCCLSIFACESEARCHINFO)pccisi)->pciid,
                               ((PCCLSIFACE)pcci)->pciid);

   return(cr);
}


#ifdef DEBUG

/*
** IsValidPCCLSIFACECACHE()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCCLSIFACECACHE(PCCLSIFACECACHE pccic)
{
   return(IS_VALID_READ_PTR(pccic, CLSIFACECACHE) &&
          IS_VALID_HANDLE(pccic->hpa, PTRARRAY));
}


/*
** IsValidPCCLSIFACE()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCCLSIFACE(PCCLSIFACE pcci)
{
   return(IS_VALID_READ_PTR(pcci, CCLSIFACE) &&
          IS_VALID_STRUCT_PTR(pcci->pcclsid, CCLSID) &&
          IS_VALID_STRUCT_PTR(pcci->pciid, CIID) &&
          IS_VALID_STRUCT_PTR(pcci->pvInterface, CInterface));
}


/*
** IsValidPCCLSIFACESEARCHINFO()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCCLSIFACESEARCHINFO(PCCLSIFACESEARCHINFO pccisi)
{
   return(IS_VALID_READ_PTR(pccisi, CCLSIFACESEARCHINFO) &&
          IS_VALID_STRUCT_PTR(pccisi->pcclsid, CCLSID) &&
          IS_VALID_STRUCT_PTR(pccisi->pciid, CIID));
}

#endif


/****************************** Public Functions *****************************/


/*
** CreateClassInterfaceCache()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreateClassInterfaceCache(PHCLSIFACECACHE phcic)
{
   BOOL bResult = FALSE;
   PCLSIFACECACHE pcic;

   ASSERT(IS_VALID_WRITE_PTR(phcic, HCLSIFACECACHE));

   if (AllocateMemory(sizeof(*pcic), &pcic))
   {
      if (CreateClassInterfacePtrArray(&(pcic->hpa)))
      {
         *phcic = (HCLSIFACECACHE)pcic;
         bResult = TRUE;
      }
      else
         FreeMemory(pcic);
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phcic, CLSIFACECACHE));

   return(bResult);
}


/*
** DestroyClassInterfaceCache()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyClassInterfaceCache(HCLSIFACECACHE hcic)
{
   ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));

   DestroyClassInterfacePtrArray(((PCLSIFACECACHE)hcic)->hpa);
   FreeMemory(hcic);

   return;
}


/*
** GetClassInterface()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** N.b., this function assumes that pcclsid and pciid are valid until hcic is
** destroyed with DestroyClassInterfaceCache().
*/
PUBLIC_CODE HRESULT GetClassInterface(HCLSIFACECACHE hcic, PCCLSID pcclsid,
                                      PCIID pciid, PVOID *ppvInterface)
{
   HRESULT hr;
   CLSIFACESEARCHINFO cisi;
   ARRAYINDEX ai;
   PCLSIFACE pci;

   ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));

   /* Is this class interface already in the cache? */

   cisi.pcclsid = pcclsid;
   cisi.pciid = pciid;

   if (SearchSortedArray(((PCCLSIFACECACHE)hcic)->hpa,
                         &ClassInterfaceSearchCmp, &cisi, &ai))
   {
      /* Yes.  Use it. */

      pci = GetPtr(((PCCLSIFACECACHE)hcic)->hpa, ai);

      hr = S_OK;
   }
   else
      /* No.  Add it. */
      hr = CreateClassInterface((PCCLSIFACECACHE)hcic, pcclsid, pciid, &pci);

   if (SUCCEEDED(hr))
   {
      ASSERT(IS_VALID_STRUCT_PTR(pci, CCLSIFACE));

      *ppvInterface = pci->pvInterface;
   }

   ASSERT(FAILED(hr) ||
          IS_VALID_STRUCT_PTR(*ppvInterface, CInterface));

   return(hr);
}


#ifdef DEBUG

/*
** IsValidHCLSIFACECACHE()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHCLSIFACECACHE(HCLSIFACECACHE hcic)
{
   return(IS_VALID_STRUCT_PTR((PCCLSIFACECACHE)hcic, CCLSIFACECACHE));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\debug.c ===
/*
 * debug.c - Debug functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Constants
 ************/

#ifdef DEBUG

#define LOG_FILE_NAME               TEXT("debug.log")

#endif


/* Types
 ********/

#ifdef DEBUG

/* debug flags */

typedef enum _debugdebugflags
{
   DEBUG_DFL_ENABLE_TRACE_MESSAGES  = 0x0001,

   DEBUG_DFL_LOG_TRACE_MESSAGES     = 0x0002,

   DEBUG_DFL_DUMP_THREAD_ID         = 0x0004,

   DEBUG_DFL_DUMP_LAST_ERROR        = 0x0008,

   ALL_DEBUG_DFLAGS                 = (DEBUG_DFL_ENABLE_TRACE_MESSAGES |
                                       DEBUG_DFL_LOG_TRACE_MESSAGES |
                                       DEBUG_DFL_DUMP_THREAD_ID |
                                       DEBUG_DFL_DUMP_LAST_ERROR)
}
DEBUGDEBUGFLAGS;

#endif


/* Global Variables
 *******************/

#ifdef DEBUG

#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* parameters used by SpewOut() */

PUBLIC_DATA DWORD GdwSpewFlags = 0;
PUBLIC_DATA UINT GuSpewSev = 0;
PUBLIC_DATA UINT GuSpewLine = 0;
PUBLIC_DATA LPCTSTR GpcszSpewFile = NULL;

#pragma data_seg()

#endif   /* DEBUG */


/* Module Variables
 *******************/

#ifdef DEBUG

#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* TLS slot used to store stack depth for SpewOut() indentation */

PRIVATE_DATA DWORD MdwStackDepthSlot = TLS_OUT_OF_INDEXES;

/* hack stack depth counter used until MdwStackDepthSlot is not available */

PRIVATE_DATA ULONG MulcHackStackDepth = 0;

#pragma data_seg(DATA_SEG_SHARED)

/* debug flags */

PRIVATE_DATA DWORD MdwDebugModuleFlags = 0;

#pragma data_seg(DATA_SEG_READ_ONLY)

/* .ini file switch descriptions */

PRIVATE_DATA CBOOLINISWITCH cbisEnableTraceMessages =
{
   IST_BOOL,
   TEXT("EnableTraceMessages"),
   &MdwDebugModuleFlags,
   DEBUG_DFL_ENABLE_TRACE_MESSAGES
};

PRIVATE_DATA CBOOLINISWITCH cbisLogTraceMessages =
{
   IST_BOOL,
   TEXT("LogTraceMessages"),
   &MdwDebugModuleFlags,
   DEBUG_DFL_LOG_TRACE_MESSAGES
};

PRIVATE_DATA CBOOLINISWITCH cbisDumpThreadID =
{
   IST_BOOL,
   TEXT("DumpThreadID"),
   &MdwDebugModuleFlags,
   DEBUG_DFL_DUMP_THREAD_ID
};

PRIVATE_DATA CBOOLINISWITCH cbisDumpLastError =
{
   IST_BOOL,
   TEXT("DumpLastError"),
   &MdwDebugModuleFlags,
   DEBUG_DFL_DUMP_LAST_ERROR
};

PRIVATE_DATA const PCVOID MrgcpcvisDebugModule[] =
{
   &cbisLogTraceMessages,
   &cbisEnableTraceMessages,
   &cbisDumpThreadID,
   &cbisDumpLastError
};

#pragma data_seg()

#endif   /* DEBUG */


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE BOOL LogOutputDebugString(LPCTSTR);
PRIVATE_CODE BOOL IsValidSpewSev(UINT);

#endif   /* DEBUG */


#ifdef DEBUG

/*
** LogOutputDebugString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL LogOutputDebugString(LPCTSTR pcsz)
{
   BOOL bResult = FALSE;
   UINT ucb;
   TCHAR rgchLogFile[MAX_PATH_LEN];

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   ucb = GetWindowsDirectory(rgchLogFile, ARRAYSIZE(rgchLogFile));

   if (ucb > 0 && ucb < ARRAYSIZE(rgchLogFile))
   {
      HANDLE hfLog;

      lstrcat(rgchLogFile, TEXT("\\"));
      lstrcat(rgchLogFile, LOG_FILE_NAME);

      hfLog = CreateFile(rgchLogFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
                         FILE_FLAG_WRITE_THROUGH, NULL);

      if (hfLog != INVALID_HANDLE_VALUE)
      {
         if (SetFilePointer(hfLog, 0, NULL, FILE_END) != INVALID_SEEK_POSITION)
         {
            DWORD dwcbWritten;

            bResult = WriteFile(hfLog, pcsz, lstrlen(pcsz)*SIZEOF(TCHAR), &dwcbWritten, NULL);

            if (! CloseHandle(hfLog) && bResult)
               bResult = FALSE;
         }
      }
   }

   return(bResult);
}


/*
** IsValidSpewSev()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidSpewSev(UINT uSpewSev)
{
   BOOL bResult;

   switch (uSpewSev)
   {
      case SPEW_TRACE:
      case SPEW_WARNING:
      case SPEW_ERROR:
      case SPEW_FATAL:
         bResult = TRUE;
         break;

      default:
         ERROR_OUT((TEXT("IsValidSpewSev(): Invalid debug spew severity %u."),
                    uSpewSev));
         bResult = FALSE;
         break;
   }

   return(bResult);
}

#endif   /* DEBUG */


/****************************** Public Functions *****************************/


#ifdef DEBUG

/*
** SetDebugModuleIniSwitches()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SetDebugModuleIniSwitches(void)
{
   BOOL bResult;

   bResult = SetIniSwitches(MrgcpcvisDebugModule,
                            ARRAY_ELEMENTS(MrgcpcvisDebugModule));

   ASSERT(FLAGS_ARE_VALID(MdwDebugModuleFlags, ALL_DEBUG_DFLAGS));

   return(bResult);
}


/*
** InitDebugModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InitDebugModule(void)
{
   ASSERT(MdwStackDepthSlot == TLS_OUT_OF_INDEXES);

   MdwStackDepthSlot = TlsAlloc();

   if (MdwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      EVAL(TlsSetValue(MdwStackDepthSlot, (PVOID)MulcHackStackDepth));

      TRACE_OUT((TEXT("InitDebugModule(): Using thread local storage slot %lu for debug stack depth counter."),
                 MdwStackDepthSlot));
   }
   else
      WARNING_OUT((TEXT("InitDebugModule(): TlsAlloc() failed to allocate thread local storage for debug stack depth counter.")));

   return(TRUE);
}


/*
** ExitDebugModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ExitDebugModule(void)
{
   if (MdwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      MulcHackStackDepth = (ULONG)TlsGetValue(MdwStackDepthSlot);

      /* Leave MulcHackStackDepth == 0 if TlsGetValue() fails. */

      EVAL(TlsFree(MdwStackDepthSlot));
      MdwStackDepthSlot = TLS_OUT_OF_INDEXES;
   }

   return;
}


/*
** StackEnter()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void StackEnter(void)
{
   if (MdwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      ULONG ulcDepth;

      ulcDepth = (ULONG)TlsGetValue(MdwStackDepthSlot);

      ASSERT(ulcDepth < ULONG_MAX);

      EVAL(TlsSetValue(MdwStackDepthSlot, (PVOID)(ulcDepth + 1)));
   }
   else
   {
      ASSERT(MulcHackStackDepth < ULONG_MAX);
      MulcHackStackDepth++;
   }

   return;
}


/*
** StackLeave()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void StackLeave(void)
{
   if (MdwStackDepthSlot != TLS_OUT_OF_INDEXES)
   {
      ULONG ulcDepth;

      ulcDepth = (ULONG)TlsGetValue(MdwStackDepthSlot);

      if (EVAL(ulcDepth > 0))
         EVAL(TlsSetValue(MdwStackDepthSlot, (PVOID)(ulcDepth - 1)));
   }
   else
   {
      if (EVAL(MulcHackStackDepth > 0))
         MulcHackStackDepth--;
   }

   return;
}


/*
** GetStackDepth()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE ULONG GetStackDepth(void)
{
   ULONG ulcDepth;

   if (MdwStackDepthSlot != TLS_OUT_OF_INDEXES)
      ulcDepth = (ULONG)TlsGetValue(MdwStackDepthSlot);
   else
      ulcDepth = MulcHackStackDepth;

   return(ulcDepth);
}


/*
** SpewOut()
**
** Spews out a formatted message to the debug terminal.
**
** Arguments:     pcszFormat - pointer to wvsprintf() format string
**                ... - formatting arguments ala wvsprintf()
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., this function assumes the global variables GdwSpewFlags, GuSpewSev,
** GpcszSpewModule, GpcszSpewFile, and GpcszSpewLine are filled in.
**
** SpewOut() uses global variables to set the message parameters in order to
** permit printf()-style macro expansion.
*/
PUBLIC_CODE void __cdecl SpewOut(LPCTSTR pcszFormat, ...)
{
   va_list  arglist;

   ASSERT(IS_VALID_STRING_PTR(pcszFormat, CSTR));

   ASSERT(FLAGS_ARE_VALID(GdwSpewFlags, ALL_SPEW_FLAGS));
   ASSERT(IsValidSpewSev(GuSpewSev));
   ASSERT(IS_FLAG_CLEAR(GdwSpewFlags, SPEW_FL_SPEW_LOCATION) ||
          (IS_VALID_STRING_PTR(GpcszSpewFile, CSTR) &&
           IS_VALID_STRING_PTR(GpcszSpewModule, CSTR)));

   if (GuSpewSev != SPEW_TRACE || IS_FLAG_SET(MdwDebugModuleFlags, DEBUG_DFL_ENABLE_TRACE_MESSAGES))
   {
      int nMsgLen;
      TCHAR rgchMsg[1024];

      if (IS_FLAG_SET(GdwSpewFlags, SPEW_FL_SPEW_PREFIX))
      {
#pragma data_seg(DATA_SEG_SHARED)
         static TCHAR SrgchSpewLeader[] = TEXT("                                                                                ");
#pragma data_seg()
         ULONG ulcStackDepth;
         TCHAR chReplaced;
         LPTSTR pszSpewLeaderEnd;
         LPCTSTR pcszSpewPrefix;

         /* Build spew message space leader string. */

         ulcStackDepth = GetStackDepth();

         if (ulcStackDepth < ARRAYSIZE(SrgchSpewLeader))
            pszSpewLeaderEnd = SrgchSpewLeader + ulcStackDepth;
         else
            pszSpewLeaderEnd = SrgchSpewLeader + ARRAYSIZE(SrgchSpewLeader) - 1;

         chReplaced = *pszSpewLeaderEnd;
         *pszSpewLeaderEnd = TEXT('\0');

         /* Determine spew prefix. */

         switch (GuSpewSev)
         {
            case SPEW_TRACE:
               pcszSpewPrefix = TEXT("t");
               break;

            case SPEW_WARNING:
               pcszSpewPrefix = TEXT("w");
               break;

            case SPEW_ERROR:
               pcszSpewPrefix = TEXT("e");
               break;

            case SPEW_FATAL:
               pcszSpewPrefix = TEXT("f");
               break;

            default:
               pcszSpewPrefix = TEXT("u");
               ERROR_OUT((TEXT("SpewOut(): Invalid GuSpewSev %u."),
                          GuSpewSev));
               break;
         }

         nMsgLen = wsprintf(rgchMsg, TEXT("%s%s %s "), SrgchSpewLeader, pcszSpewPrefix, GpcszSpewModule);

         /* Restore spew leader. */

         *pszSpewLeaderEnd = chReplaced;

         ASSERT(nMsgLen < ARRAYSIZE(rgchMsg));
      }
      else
         nMsgLen = 0;

      /* Append thread ID. */

      if (IS_FLAG_SET(MdwDebugModuleFlags, DEBUG_DFL_DUMP_THREAD_ID))
      {
         nMsgLen += wsprintf(rgchMsg + nMsgLen, TEXT("%#lx "), GetCurrentThreadId());

         ASSERT(nMsgLen < ARRAYSIZE(rgchMsg));
      }

      /* Build position string. */

      if (IS_FLAG_SET(GdwSpewFlags, SPEW_FL_SPEW_LOCATION))
      {
         nMsgLen += wsprintf(rgchMsg + nMsgLen, TEXT("(%s line %u): "), GpcszSpewFile, GuSpewLine);

         ASSERT(nMsgLen < ARRAYSIZE(rgchMsg));
      }

      /* Append message string. */

      va_start(arglist,pcszFormat);
      nMsgLen += wvsprintf(rgchMsg + nMsgLen, pcszFormat, arglist);
      va_end(arglist);

      ASSERT(nMsgLen < ARRAYSIZE(rgchMsg));

      if (IS_FLAG_SET(GdwSpewFlags, DEBUG_DFL_DUMP_THREAD_ID))
      {
         if (GuSpewSev == SPEW_ERROR ||
             GuSpewSev == SPEW_FATAL)
         {
            nMsgLen += wsprintf(rgchMsg + nMsgLen, TEXT(" (GetLastError() == %lu)"), GetLastError());

            ASSERT(nMsgLen < ARRAYSIZE(rgchMsg));
         }
      }

      nMsgLen += wsprintf(rgchMsg + nMsgLen, TEXT("\r\n"));

      ASSERT(nMsgLen < ARRAYSIZE(rgchMsg));

      OutputDebugString(rgchMsg);

      if (IS_FLAG_SET(MdwDebugModuleFlags, DEBUG_DFL_LOG_TRACE_MESSAGES))
      {
         LogOutputDebugString(rgchMsg);
         LogOutputDebugString(TEXT("\r\n"));
      }
   }

   /* Break here on errors and fatal errors. */

   if (GuSpewSev == SPEW_ERROR || GuSpewSev == SPEW_FATAL)
      DebugBreak();

   return;
}

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\db.h ===
/*
 * db.c - Twin database module description.
 */


/* Types
 ********/

/* database header version numbers */

#define HEADER_MAJOR_VER         (0x0001)
#define HEADER_MINOR_VER         (0x0005)

/* old (but supported) version numbers */

#define HEADER_M8_MINOR_VER      (0x0004)


typedef struct _dbversion
{
    DWORD dwMajorVer;
    DWORD dwMinorVer;
}
DBVERSION;
DECLARE_STANDARD_TYPES(DBVERSION);


/* Prototypes
 *************/

/* db.c */

extern TWINRESULT WriteTwinDatabase(HCACHEDFILE, HBRFCASE);
extern TWINRESULT ReadTwinDatabase(HBRFCASE, HCACHEDFILE);
extern TWINRESULT WriteDBSegmentHeader(HCACHEDFILE, LONG, PCVOID, UINT);
extern TWINRESULT TranslateFCRESULTToTWINRESULT(FCRESULT);

/* path.c */

extern TWINRESULT WritePathList(HCACHEDFILE, HPATHLIST);
extern TWINRESULT ReadPathList(HCACHEDFILE, HPATHLIST, PHHANDLETRANS);

/* brfcase.c */

extern TWINRESULT WriteBriefcaseInfo(HCACHEDFILE, HBRFCASE);
extern TWINRESULT ReadBriefcaseInfo(HCACHEDFILE, HBRFCASE, HHANDLETRANS);

/* string.c */

extern TWINRESULT WriteStringTable(HCACHEDFILE, HSTRINGTABLE);
extern TWINRESULT ReadStringTable(HCACHEDFILE, HSTRINGTABLE, PHHANDLETRANS);

/* twin.c */

extern TWINRESULT WriteTwinFamilies(HCACHEDFILE, HPTRARRAY);
extern TWINRESULT ReadTwinFamilies(HCACHEDFILE, HBRFCASE, PCDBVERSION, HHANDLETRANS, HHANDLETRANS);

/* foldtwin.c */

extern TWINRESULT WriteFolderPairList(HCACHEDFILE, HPTRARRAY);
extern TWINRESULT ReadFolderPairList(HCACHEDFILE, HBRFCASE, HHANDLETRANS, HHANDLETRANS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\debug.h ===
/*
 * debug.h - Debug macros and their retail translations.
 */


/* Macros
 *********/

/* debug output macros */

/*
 * Do not call SPEW_OUT directly.  Instead, call TRACE_OUT, WARNING_OUT,
 * ERROR_OUT, or FATAL_OUT.
 */

/*
 * call like printf(), but with an extra pair of parentheses:
 *
 * ERROR_OUT(("'%s' too big by %d bytes.", pszName, nExtra));
 */

#ifdef DEBUG

#define SPEW_OUT(args) \
   ((void)(GpcszSpewFile = TEXT(__FILE__), GuSpewLine = __LINE__, SpewOut args, 0))

#define PLAIN_TRACE_OUT(args) \
   (GdwSpewFlags = 0, GuSpewSev = SPEW_TRACE, SPEW_OUT(args))

#define TRACE_OUT(args) \
   (GdwSpewFlags = SPEW_FL_SPEW_PREFIX, GuSpewSev = SPEW_TRACE, SPEW_OUT(args))

#define WARNING_OUT(args) \
   (GdwSpewFlags = SPEW_FL_SPEW_PREFIX | SPEW_FL_SPEW_LOCATION, GuSpewSev = SPEW_WARNING, SPEW_OUT(args))

#define ERROR_OUT(args) \
   (GdwSpewFlags = SPEW_FL_SPEW_PREFIX | SPEW_FL_SPEW_LOCATION, GuSpewSev = SPEW_ERROR, SPEW_OUT(args))

#define FATAL_OUT(args) \
   (GdwSpewFlags = SPEW_FL_SPEW_PREFIX | SPEW_FL_SPEW_LOCATION, GuSpewSev = SPEW_FATAL, SPEW_OUT(args))

#else

#define PLAIN_TRACE_OUT(args)
#define TRACE_OUT(args)
#define WARNING_OUT(args)
#define ERROR_OUT(args)
#define FATAL_OUT(args)

#endif

/* parameter validation macros */

/*
 * call as:
 *
 * bPTwinOK = IS_VALID_READ_PTR(ptwin, CTWIN);
 *
 * bHTwinOK = IS_VALID_HANDLE(htwin, TWIN);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (ERROR_OUT((TEXT("invalid %s read pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (ERROR_OUT((TEXT("invalid %s write pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRA(ptr, type) \
   (IsBadStringPtrA((ptr), (UINT)-1) ? \
    (ERROR_OUT((TEXT("invalid %s pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, type) \
   (IsBadStringPtrW((ptr), (UINT)-1) ? \
    (ERROR_OUT((TEXT("invalid %s pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#ifdef UNICODE
#define IS_VALID_STRING_PTR(ptr, type) IS_VALID_STRING_PTRW(ptr, type)
#else
#define IS_VALID_STRING_PTR(ptr, type) IS_VALID_STRING_PTRA(ptr, type)
#endif

#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((PROC)(ptr)) ? \
    (ERROR_OUT((TEXT("invalid %s code pointer - %#08lx"), (LPCTSTR)TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
   (IsBadReadPtr((ptr), len) ? \
    (ERROR_OUT((TEXT("invalid %s read pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
   (IsBadWritePtr((ptr), len) ? \
    (ERROR_OUT((TEXT("invalid %s write pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (ERROR_OUT((TEXT("invalid flags set - %#08lx"), ((dwFlags) & (~(dwAllFlags))))), FALSE) : \
    TRUE)

#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTR(ptr, type) \
   (! IsBadStringPtr((ptr), (UINT)-1))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((PROC)(ptr)))

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
   (! IsBadReadPtr((ptr), len))

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
   (! IsBadWritePtr((ptr), len))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#endif

/* handle validation macros */

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

/* structure validation macros */

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (ERROR_OUT((TEXT("invalid %s pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif

/* debug assertion macro */

/*
 * ASSERT() may only be used as a statement, not as an expression.
 *
 * call as:
 *
 * ASSERT(pszRest);
 */

#ifdef DEBUG

#define ASSERT(exp) \
   if (exp) \
      ; \
   else \
      ERROR_OUT((TEXT("assertion failed '%s'"), (LPCTSTR)TEXT(#exp)))

#else

#define ASSERT(exp)

#endif

/* debug evaluation macro */

/*
 * EVAL() may be used as an expression.
 *
 * call as:
 *
 * if (EVAL(pszFoo))
 *    bResult = TRUE;
 */

#ifdef DEBUG

#define EVAL(exp) \
   ((exp) || (ERROR_OUT((TEXT("evaluation failed '%s'"), (LPCTSTR)TEXT(#exp))), 0))

#else

#define EVAL(exp) \
   (exp)

#endif

/* debug break */

#ifndef DEBUG

#define DebugBreak()

#endif

/* debug exported function entry */

#ifdef DEBUG

#define DebugEntry(szFunctionName) \
   (TRACE_OUT((TEXT(#szFunctionName) TEXT("() entered."))), StackEnter())

#else

#define DebugEntry(szFunctionName)

#endif

/* debug exported function exit */

#ifdef DEBUG

#define DebugExitVOID(szFunctionName) \
   (StackLeave(), TRACE_OUT((TEXT("%s() exiting."), TEXT(#szFunctionName))))

#define DebugExit(szFunctionName, szResult) \
   (StackLeave(), TRACE_OUT((TEXT("%s() exiting, returning %s."), TEXT(#szFunctionName), szResult)))

#define DebugExitINT(szFunctionName, n) \
   DebugExit(szFunctionName, GetINTString(n))

#define DebugExitULONG(szFunctionName, ul) \
   DebugExit(szFunctionName, GetULONGString(ul))

#define DebugExitBOOL(szFunctionName, bool) \
   DebugExit(szFunctionName, GetBOOLString(bool))

#define DebugExitHRESULT(szFunctionName, hr) \
   DebugExit(szFunctionName, GetHRESULTString(hr))

#define DebugExitCOMPARISONRESULT(szFunctionName, cr) \
   DebugExit(szFunctionName, GetCOMPARISONRESULTString(cr))

#define DebugExitTWINRESULT(szFunctionName, tr) \
   DebugExit(szFunctionName, GetTWINRESULTString(tr))

#define DebugExitRECRESULT(szFunctionName, rr) \
   DebugExit(szFunctionName, GetRECRESULTString(rr))

#else

#define DebugExitVOID(szFunctionName)
#define DebugExit(szFunctionName, szResult)
#define DebugExitINT(szFunctionName, n)
#define DebugExitULONG(szFunctionName, ul)
#define DebugExitBOOL(szFunctionName, bool)
#define DebugExitHRESULT(szFunctionName, hr)
#define DebugExitCOMPARISONRESULT(szFunctionName, cr)
#define DebugExitTWINRESULT(szFunctionName, tr)
#define DebugExitRECRESULT(szFunctionName, rr)

#endif


/* Types
 ********/

/* GdwSpewFlags flags */

typedef enum _spewflags
{
   SPEW_FL_SPEW_PREFIX     = 0x0001,

   SPEW_FL_SPEW_LOCATION   = 0x0002,

   ALL_SPEW_FLAGS          = (SPEW_FL_SPEW_PREFIX |
                              SPEW_FL_SPEW_LOCATION)
}
SPEWFLAGS;

/* GuSpewSev values */

typedef enum _spewsev
{
   SPEW_TRACE              = 1,

   SPEW_WARNING            = 2,

   SPEW_ERROR              = 3,

   SPEW_FATAL              = 4
}
SPEWSEV;


/* Prototypes
 *************/

/* debug.c */

#ifdef DEBUG

extern BOOL SetDebugModuleIniSwitches(void);
extern BOOL InitDebugModule(void);
extern void ExitDebugModule(void);
extern void StackEnter(void);
extern void StackLeave(void);
extern ULONG GetStackDepth(void);
extern void __cdecl SpewOut(LPCTSTR pcszFormat, ...);

#endif


/* Global Variables
 *******************/

#ifdef DEBUG

/* debug.c */

extern DWORD GdwSpewFlags;
extern UINT GuSpewSev;
extern UINT GuSpewLine;
extern LPCTSTR GpcszSpewFile;

/* defined by client */

extern LPCTSTR GpcszSpewModule;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\cstring.h ===
/*
 * string.h - String table ADT description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HSTRING);
DECLARE_STANDARD_TYPES(HSTRING);
DECLARE_HANDLE(HSTRINGTABLE);
DECLARE_STANDARD_TYPES(HSTRINGTABLE);

/* count of hash buckets in a string table */

typedef UINT HASHBUCKETCOUNT;
DECLARE_STANDARD_TYPES(HASHBUCKETCOUNT);

/* string table hash function */

typedef HASHBUCKETCOUNT (*STRINGTABLEHASHFUNC)(LPCTSTR, HASHBUCKETCOUNT);

/* new string table */

typedef struct _newstringtable
{
   HASHBUCKETCOUNT hbc;
   STRINGTABLEHASHFUNC HashFunc;
}
NEWSTRINGTABLE;
DECLARE_STANDARD_TYPES(NEWSTRINGTABLE);


/* Prototypes
 *************/

/* string.c */

extern BOOL CreateStringTable(PCNEWSTRINGTABLE, PHSTRINGTABLE);
extern void DestroyStringTable(HSTRINGTABLE);
extern BOOL AddString(LPCTSTR, HSTRINGTABLE, PHSTRING);
extern void DeleteString(HSTRING);
extern void LockString(HSTRING);
extern COMPARISONRESULT CompareStringsI(HSTRING, HSTRING);
extern LPCTSTR GetString(HSTRING);

#if defined(DEBUG) || defined (VSTF)

extern BOOL IsValidHSTRING(HSTRING);
extern BOOL IsValidHSTRINGTABLE(HSTRINGTABLE);

#endif

#ifdef DEBUG

extern ULONG GetStringCount(HSTRINGTABLE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\dllinit.c ===
/*
 * dllinit.c - Initialization and termination routines.
 */

/*

Implementation Notes
--------------------

   Here are a few conventions I have attempted to follow in the object
synchronization engine:

1) Functions have only one exit point.

2) When calling a function that takes one or more pointers to variables to be
filled in with a result, the caller may only depend upon the variables being
filled in correctly if the function returns success.

3) AllocateMemory() and FreeMemory() are called instead of _fmalloc() and
_ffree() to allow debug manipulation of the heap.

4) Two layers of parameter validation have been implemented - validation of
parameters passed in from external callers and validation of parameters passed
in from internal callers.  #defining EXPV enables the external parameter
validation layer.  The internal parameter validation layer is only included in
the debug build.  The external parameter validation layer fails any call with
an invalid parameter, returning TR_INVALID_PARAMETER.  The internal parameter
validation layer displays a debug message when a call is made with an invalid
parameter, but allows the call to proceed.  External parameter validation is
available in all builds.  Internal parameter validation is only available in
the DEBUG build.

5) In addition to the two layers of parameter validation, validation of fields
of structures passed as arguments may be enabled by #defining VSTF.  Full
parent and child structure field validation can be quite time-consuming.  Field
validation for external structure parameters is available in all builds.  Field
validation for internal structure parameters is only available in the DEBUG
build.  (Full parameter and structure field validation has proven very valuable
in debugging.)

6) Some debug bounds check ASSERT()s use floating point math.  These floating
point bounds checks are only enabled if DBLCHECK is #defined.  Defining
DBLCHECK requires linking with the CRT library for floating point support.

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "init.h"


/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL MyAttachProcess(HMODULE);
PRIVATE_CODE BOOL MyDetachProcess(HMODULE);


/* Global Variables
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

/* serialization control structure */

PUBLIC_DATA CSERIALCONTROL g_cserctrl =
{
   MyAttachProcess,
   MyDetachProcess,
   NULL,
   NULL
};

#pragma data_seg()

#ifdef DEBUG

#pragma data_seg(DATA_SEG_READ_ONLY)

/* .ini file name and section used by inifile.c!SetIniSwitches() */

PUBLIC_DATA LPCTSTR GpcszIniFile = TEXT("rover.ini");
PUBLIC_DATA LPCTSTR GpcszIniSection = TEXT("SyncEngineDebugOptions");

/* module name used by debug.c!SpewOut() */

PUBLIC_DATA LPCTSTR GpcszSpewModule = TEXT("SyncEng");

#pragma data_seg()

#endif


/***************************** Private Functions *****************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** MyAttachProcess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL MyAttachProcess(HMODULE hmod)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   DebugEntry(MyAttachProcess);

   bResult = (ProcessInitOLEPigModule() &&
              ProcessInitStorageModule());

   DebugExitBOOL(MyAttachProcess, bResult);

   return(bResult);
}


/*
** MyDetachProcess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL MyDetachProcess(HMODULE hmod)
{
   BOOL bResult = TRUE;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   DebugEntry(MyDetachProcess);

   ProcessExitStorageModule();

   ProcessExitOLEPigModule();

   DebugExitBOOL(MyDetachProcess, bResult);

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/****************************** Public Functions *****************************/


#ifdef DEBUG

/*
** SetAllIniSwitches()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SetAllIniSwitches(void)
{
   BOOL bResult;

   bResult = SetDebugModuleIniSwitches();
   bResult = SetSerialModuleIniSwitches() && bResult;
   bResult = SetMemoryManagerModuleIniSwitches() && bResult;
   bResult = SetBriefcaseModuleIniSwitches() && bResult;

   return(bResult);
}

#endif


/*
** InitializeDLL()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InitializeDLL(void)
{
   BOOL bResult;

#ifdef DEBUG
   DebugEntry(InitializeDLL);

   EVAL(InitDebugModule());

#endif

   bResult = (InitMemoryManagerModule() &&
              InitBriefcaseModule());

#ifdef DEBUG

   SpewHeapSummary(0);

#endif

   DebugExitBOOL(InitializeDLL, bResult);

   return(bResult);
}


/*
** TerminateDLL()
**
**
**
** Arguments:
**
** Returns:       TRUE
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL TerminateDLL(void)
{
   BOOL bResult = TRUE;

   DebugEntry(TerminateDLL);

#ifdef DEBUG

   SpewHeapSummary(0);

   TRACE_OUT((TEXT("TerminateDLL(): Starting heap cleanup.")));

#endif

   ExitBriefcaseModule();

#ifdef DEBUG

   TRACE_OUT((TEXT("TerminateDLL(): Heap cleanup complete.")));

   SpewHeapSummary(SHS_FL_SPEW_USED_INFO);

#endif

   ExitMemoryManagerModule();

#ifdef DEBUG

   ExitDebugModule();

#endif

   DebugExitBOOL(TerminateDLL, bResult);

   return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\db.c ===
/*
 * db.c - Twin database module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"


/* Constants
 ************/

/* database header magic id string */

#define MAGIC_HEADER             "DDSH\x02\x05\x01\x14"

/* length of MAGIC_HEADER (no null terminator) */

#define MAGIC_HEADER_LEN         (8)

/* Types
 ********/

typedef struct _dbheader
{
   BYTE rgbyteMagic[MAGIC_HEADER_LEN];
   DWORD dwcbHeaderLen;
   DWORD dwMajorVer;
   DWORD dwMinorVer;
}
DBHEADER;
DECLARE_STANDARD_TYPES(DBHEADER);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE TWINRESULT WriteDBHeader(HCACHEDFILE, PDBHEADER);
PRIVATE_CODE TWINRESULT ReadDBHeader(HCACHEDFILE, PDBHEADER);
PRIVATE_CODE TWINRESULT CheckDBHeader(PCDBHEADER);
PRIVATE_CODE TWINRESULT WriteTwinInfo(HCACHEDFILE, HBRFCASE);
PRIVATE_CODE TWINRESULT ReadTwinInfo(HCACHEDFILE, HBRFCASE, PCDBVERSION);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCDBHEADER(PCDBHEADER);

#endif


/*
** WriteDBHeader()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT WriteDBHeader(HCACHEDFILE hcf, PDBHEADER pdbh)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pdbh, CDBHEADER));

   if (WriteToCachedFile(hcf, (PCVOID)pdbh, sizeof(*pdbh), NULL))
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


/*
** ReadDBHeader()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT ReadDBHeader(HCACHEDFILE hcf, PDBHEADER pdbh)
{
   TWINRESULT tr;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(pdbh, DBHEADER));

   if (ReadFromCachedFile(hcf, pdbh, sizeof(*pdbh), &dwcbRead) &&
       dwcbRead == sizeof(*pdbh))
      tr = CheckDBHeader(pdbh);
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


/*
** CheckDBHeader()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT CheckDBHeader(PCDBHEADER pcdbh)
{
   TWINRESULT tr = TR_CORRUPT_BRIEFCASE;

   ASSERT(IS_VALID_READ_PTR(pcdbh, CDBHEADER));

   if (MyMemComp(pcdbh->rgbyteMagic, MAGIC_HEADER, MAGIC_HEADER_LEN) == CR_EQUAL)
   {
      /* Treat older databases as corrupt.  Support M8 databases. */

      if (pcdbh->dwMajorVer == HEADER_MAJOR_VER && 
          (pcdbh->dwMinorVer == HEADER_MINOR_VER || pcdbh->dwMinorVer == HEADER_M8_MINOR_VER))
      {
         if (pcdbh->dwcbHeaderLen == sizeof(*pcdbh))
            tr = TR_SUCCESS;
      }
      else if (pcdbh->dwMajorVer > HEADER_MAJOR_VER ||
               (pcdbh->dwMajorVer == HEADER_MAJOR_VER &&
                pcdbh->dwMinorVer > HEADER_MINOR_VER))
      {
         tr = TR_NEWER_BRIEFCASE;

         WARNING_OUT((TEXT("CheckDBHeader(): Newer database version %lu.%lu."),
                      pcdbh->dwMajorVer,
                      pcdbh->dwMinorVer));
      }
      else
      {
         tr = TR_CORRUPT_BRIEFCASE;

         WARNING_OUT((TEXT("CheckDBHeader(): Treating old database version %lu.%lu as corrupt.  Current database version is %lu.%lu."),
                      pcdbh->dwMajorVer,
                      pcdbh->dwMinorVer,
                      (DWORD)HEADER_MAJOR_VER,
                      (DWORD)HEADER_MINOR_VER));
      }
   }

   return(tr);
}


/*
** WriteTwinInfo()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT WriteTwinInfo(HCACHEDFILE hcf, HBRFCASE hbr)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   tr = WritePathList(hcf, GetBriefcasePathList(hbr));

   if (tr == TR_SUCCESS)
   {
      tr = WriteBriefcaseInfo(hcf, hbr);

      if (tr == TR_SUCCESS)
      {
         tr = WriteStringTable(hcf, GetBriefcaseNameStringTable(hbr));

         if (tr == TR_SUCCESS)
         {
            tr = WriteTwinFamilies(hcf, GetBriefcaseTwinFamilyPtrArray(hbr));

            if (tr == TR_SUCCESS)
               tr = WriteFolderPairList(hcf, GetBriefcaseFolderPairPtrArray(hbr));
         }
      }
   }

   return(tr);
}


/*
** ReadTwinInfo()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT ReadTwinInfo(HCACHEDFILE hcf, HBRFCASE hbr,
                                     PCDBVERSION pcdbver)
{
   TWINRESULT tr;
   HHANDLETRANS hhtPathTrans;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_READ_PTR(pcdbver, DBVERSION));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   tr = ReadPathList(hcf, GetBriefcasePathList(hbr), &hhtPathTrans);

   if (tr == TR_SUCCESS)
   {
      tr = ReadBriefcaseInfo(hcf, hbr, hhtPathTrans);

      if (tr == TR_SUCCESS)
      {
         HHANDLETRANS hhtNameTrans;

         tr = ReadStringTable(hcf, GetBriefcaseNameStringTable(hbr), &hhtNameTrans);

         if (tr == TR_SUCCESS)
         {
            tr = ReadTwinFamilies(hcf, hbr, pcdbver, hhtPathTrans, hhtNameTrans);

            if (tr == TR_SUCCESS)
               tr = ReadFolderPairList(hcf, hbr, hhtPathTrans, hhtNameTrans);

            DestroyHandleTranslator(hhtNameTrans);
         }
      }

      DestroyHandleTranslator(hhtPathTrans);
   }

   return(tr);
}


#ifdef VSTF

/*
** IsValidPCDBHEADER()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCDBHEADER(PCDBHEADER pcdbh)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pcdbh, CDBHEADER) &&
       EVAL(MyMemComp(pcdbh->rgbyteMagic, MAGIC_HEADER, MAGIC_HEADER_LEN) == CR_EQUAL) &&
       EVAL(pcdbh->dwcbHeaderLen == sizeof(*pcdbh)) &&
       EVAL(pcdbh->dwMajorVer == HEADER_MAJOR_VER) &&
       EVAL(pcdbh->dwMinorVer == HEADER_MINOR_VER || pcdbh->dwMinorVer == HEADER_M8_MINOR_VER))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
** WriteTwinDatabase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT WriteTwinDatabase(HCACHEDFILE hcf, HBRFCASE hbr)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   if (! SeekInCachedFile(hcf, 0, FILE_BEGIN))
   {
      DBHEADER dbh;

      /* Set up database header. */

      CopyMemory(dbh.rgbyteMagic, MAGIC_HEADER, MAGIC_HEADER_LEN);
      dbh.dwcbHeaderLen = sizeof(dbh);
      dbh.dwMajorVer = HEADER_MAJOR_VER;
      dbh.dwMinorVer = HEADER_MINOR_VER;

      tr = WriteDBHeader(hcf, &dbh);

      if (tr == TR_SUCCESS)
      {
         TRACE_OUT((TEXT("WriteTwinDatabase(): Wrote database header version %lu.%lu."),
                    dbh.dwMajorVer,
                    dbh.dwMinorVer));

         tr = WriteTwinInfo(hcf, hbr);

         if (tr == TR_SUCCESS && ! SetEndOfCachedFile(hcf))
            tr = TR_BRIEFCASE_WRITE_FAILED;
      }
   }
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


/*
** ReadTwinDatabase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT ReadTwinDatabase(HBRFCASE hbr, HCACHEDFILE hcf)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   if (! SeekInCachedFile(hcf, 0, FILE_BEGIN))
   {
      DBHEADER dbh;

      tr = ReadDBHeader(hcf, &dbh);

      if (tr == TR_SUCCESS)
      {
         TRACE_OUT((TEXT("ReadTwinDatabase(): Read database header version %lu.%lu."),
                    dbh.dwMajorVer,
                    dbh.dwMinorVer));

         tr = ReadTwinInfo(hcf, hbr, (PCDBVERSION)&dbh.dwMajorVer);

         if (tr == TR_SUCCESS)
            ASSERT(GetCachedFilePointerPosition(hcf) == GetCachedFileSize(hcf));
      }
   }
   else
      tr = TR_BRIEFCASE_READ_FAILED;

   return(tr);
}


/*
** WriteDBSegmentHeader()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT WriteDBSegmentHeader(HCACHEDFILE hcf,
                                       LONG lcbDBSegmentHeaderOffset,
                                       PCVOID pcvSegmentHeader,
                                       UINT ucbSegmentHeaderLen)
{
   TWINRESULT tr;
   DWORD dwcbStartOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(lcbDBSegmentHeaderOffset >= 0);
   ASSERT(ucbSegmentHeaderLen > 0);
   ASSERT(IS_VALID_READ_BUFFER_PTR(pcvSegmentHeader, BYTE, ucbSegmentHeaderLen));

   dwcbStartOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbStartOffset != INVALID_SEEK_POSITION &&
       SeekInCachedFile(hcf, lcbDBSegmentHeaderOffset, SEEK_SET) != INVALID_SEEK_POSITION &&
       WriteToCachedFile(hcf, pcvSegmentHeader, ucbSegmentHeaderLen, NULL) &&
       SeekInCachedFile(hcf, dwcbStartOffset, SEEK_SET) != INVALID_SEEK_POSITION)
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


/*
** TranslateFCRESULTToTWINRESULT()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT TranslateFCRESULTToTWINRESULT(FCRESULT fcr)
{
   TWINRESULT tr;

   switch (fcr)
   {
      case FCR_SUCCESS:
         tr = TR_SUCCESS;
         break;

      case FCR_OUT_OF_MEMORY:
         tr = TR_OUT_OF_MEMORY;
         break;

      case FCR_OPEN_FAILED:
         tr = TR_BRIEFCASE_OPEN_FAILED;
         break;

      case FCR_CREATE_FAILED:
         tr = TR_BRIEFCASE_OPEN_FAILED;
         break;

      case FCR_WRITE_FAILED:
         tr = TR_BRIEFCASE_WRITE_FAILED;
         break;

      default:
         ASSERT(fcr == FCR_FILE_LOCKED);
         tr = TR_BRIEFCASE_LOCKED;
         break;
   }

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\expandft.h ===
/*
 * expandft.h - Routines for expanding folder twins to object twins
 *              description.
 */


/* Types
 ********/

/* subtree enumeration callback function called by ExpandSubtree() */

typedef TWINRESULT (*EXPANDSUBTREEPROC)(LPCTSTR, PCWIN32_FIND_DATA, PVOID);


/* Prototypes
 *************/

/* expandft.c */

extern BOOL ExpandSubtree(HPATH, EXPANDSUBTREEPROC, PVOID);
extern TWINRESULT ExpandFolderTwinsIntersectingTwinList(HTWINLIST, CREATERECLISTPROC, LPARAM);
extern BOOL NamesIntersect(LPCTSTR, LPCTSTR);

#ifdef DEBUG

extern BOOL IsValidTWINRESULT(TWINRESULT);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\expandft.c ===
/*
 * expandft.c - Routines for expanding folder twins to object twins.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"


/* Constants
 ************/

/* for subtree folder searching */

#define STAR_DOT_STAR            TEXT("*.*")


/* Macros
 *********/

/* name component macros used by NameComponentsIntersect() */

#define COMPONENT_CHARS_MATCH(ch1, ch2)   (CharLower((PTSTR)(DWORD)ch1) == CharLower((PTSTR)(DWORD)ch2) || (ch1) == QMARK || (ch2) == QMARK)

#define IS_COMPONENT_TERMINATOR(ch)       (! (ch) || (ch) == PERIOD || (ch) == ASTERISK)


/* Types
 ********/

/* find structure used by ExpandSubtree() */

typedef struct _findstate
{
   HANDLE hff;

   WIN32_FIND_DATA wfd;
}
FINDSTATE;
DECLARE_STANDARD_TYPES(FINDSTATE);

/* information structure passed to GenerateObjectTwinFromFolderTwinProc() */

typedef struct _expandsubtreetwininfo
{
   PFOLDERPAIR pfp;

   UINT ucbSubtreeRootPathLen;

   HCLSIFACECACHE hcic;

   CREATERECLISTPROC crlp;

   LPARAM lpCallbackData;

   TWINRESULT tr;
}
EXPANDSUBTREETWININFO;
DECLARE_STANDARD_TYPES(EXPANDSUBTREETWININFO);


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

/*
 * folder names to be avoided during subtree expansion (comparison is
 * case-insensitive)
 */

PRIVATE_DATA CONST LPCTSTR MrgcpcszFoldersToAvoid[] =
{
   TEXT("."),
   TEXT("..")
};

#pragma data_seg()


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL SetObjectTwinFileStamp(POBJECTTWIN, PVOID);
PRIVATE_CODE void MarkFolderTwinDeletionPending(PFOLDERPAIR);
PRIVATE_CODE void UnmarkFolderTwinDeletionPending(PFOLDERPAIR);
PRIVATE_CODE TWINRESULT ExpandFolderTwin(PFOLDERPAIR, HCLSIFACECACHE, CREATERECLISTPROC, LPARAM);
PRIVATE_CODE BOOL GenerateObjectTwinFromFolderTwinProc(LPCTSTR, PCWIN32_FIND_DATA, PVOID);
PRIVATE_CODE TWINRESULT ExpandSubtreeTwin(PFOLDERPAIR, HCLSIFACECACHE, CREATERECLISTPROC, LPARAM);
PRIVATE_CODE BOOL IsFolderToExpand(LPCTSTR);
PRIVATE_CODE TWINRESULT FakeObjectTwinFromFolderTwin(PCFOLDERPAIR, LPCTSTR, LPCTSTR, HCLSIFACECACHE, POBJECTTWIN *, POBJECTTWIN *);
PRIVATE_CODE TWINRESULT AddFolderObjectTwinFromFolderTwin(PCFOLDERPAIR, LPCTSTR, HCLSIFACECACHE);
PRIVATE_CODE TWINRESULT AddFileObjectTwinFromFolderTwin(PCFOLDERPAIR, LPCTSTR, PCWIN32_FIND_DATA, HCLSIFACECACHE);
PRIVATE_CODE BOOL NameComponentsIntersect(LPCTSTR, LPCTSTR);
PRIVATE_CODE BOOL AttributesMatch(DWORD, DWORD);
PRIVATE_CODE void PrepareForFolderTwinExpansion(HBRFCASE);
PRIVATE_CODE TWINRESULT MyExpandIntersectingFolderTwins(PFOLDERPAIR, HCLSIFACECACHE, CREATERECLISTPROC, LPARAM);
PRIVATE_CODE TWINRESULT HalfExpandIntersectingFolderTwins(PFOLDERPAIR, HCLSIFACECACHE, CREATERECLISTPROC, LPARAM);

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCEXPANDSUBTREETWININFO(PCEXPANDSUBTREETWININFO);

#endif


/*
** SetObjectTwinFileStampCondition()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetObjectTwinFileStampCondition(POBJECTTWIN pot,
                                                  PVOID fscond)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(IsValidFILESTAMPCONDITION((FILESTAMPCONDITION)fscond));

   ZeroMemory(&(pot->fsCurrent), sizeof(pot->fsCurrent));
   pot->fsCurrent.fscond = (FILESTAMPCONDITION)fscond;

   SetStubFlag(&(pot->stub), STUB_FL_FILE_STAMP_VALID);

   return(TRUE);
}


/*
** MarkFolderTwinDeletionPending()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void MarkFolderTwinDeletionPending(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   if (IsStubFlagClear(&(pfp->stub), STUB_FL_DELETION_PENDING))
   {
      TCHAR rgchRootPath[MAX_PATH_LEN];

      GetPathRootString(pfp->hpath, rgchRootPath);

      if (PathExists(rgchRootPath))
      {
         SetStubFlag(&(pfp->stub), STUB_FL_DELETION_PENDING);

         TRACE_OUT((TEXT("MarkFolderTwinDeletionPending(): Folder twin deletion pending for deleted folder %s."),
                    DebugGetPathString(pfp->hpath)));
      }
      else
         WARNING_OUT((TEXT("MarkFolderTwinDeletionPending(): Root path %s of folder %s does not exist."),
                      rgchRootPath,
                      DebugGetPathString(pfp->hpath)));
   }

   return;
}


/*
** UnmarkFolderTwinDeletionPending()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void UnmarkFolderTwinDeletionPending(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   if (IsStubFlagSet(&(pfp->stub), STUB_FL_DELETION_PENDING))
      WARNING_OUT((TEXT("UnmarkFolderTwinDeletionPending(): Folder twin %s was deleted but has been recreated."),
                   DebugGetPathString(pfp->hpath)));

   ClearStubFlag(&(pfp->stub), STUB_FL_DELETION_PENDING);

   return;
}


/*
** ExpandFolderTwin()
**
** Expands a single folder of half of a folder pair into object twins.
**
** Arguments:     pfp - pointer to folder pair whose folder is to be expanded
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT ExpandFolderTwin(PFOLDERPAIR pfp, HCLSIFACECACHE hcic,
                                         CREATERECLISTPROC crlp,
                                         LPARAM lpCallbackData)
{
   TWINRESULT tr = TR_SUCCESS;
   TCHAR rgchSearchSpec[MAX_PATH_LEN];

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
   ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));
   ASSERT(! crlp ||
          IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));

   ASSERT(IsPathVolumeAvailable(pfp->hpath));
   ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_SUBTREE));
   ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_USED));

   /* Build search specification. */

   GetPathString(pfp->hpath, rgchSearchSpec);

   if (PathExists(rgchSearchSpec))
   {
      WIN32_FIND_DATA wfd;
      HANDLE hff;

      UnmarkFolderTwinDeletionPending(pfp);

      TRACE_OUT((TEXT("ExpandFolderTwin(): Expanding folder %s for objects matching %s."),
                 rgchSearchSpec,
                 GetString(pfp->pfpd->hsName)));

      tr = AddFolderObjectTwinFromFolderTwin(pfp, EMPTY_STRING, hcic);

      if (tr == TR_SUCCESS)
      {
         CatPath(rgchSearchSpec, GetString(pfp->pfpd->hsName));

         hff = FindFirstFile(rgchSearchSpec, &wfd);

         /* Did we find a matching object? */

         if (hff != INVALID_HANDLE_VALUE)
         {
            /* Yes. */

            do
            {
               /* Ping. */

               if (NotifyCreateRecListStatus(crlp, CRLS_DELTA_CREATE_REC_LIST,
                                             0, lpCallbackData))
               {
                  if (AttributesMatch(pfp->pfpd->dwAttributes,
                                      wfd.dwFileAttributes))
                  {
                     TRACE_OUT((TEXT("ExpandFolderTwin(): Found matching object %s."),
                                &(wfd.cFileName)));

                     tr = AddFileObjectTwinFromFolderTwin(pfp, EMPTY_STRING,
                                                          &wfd, hcic);

                     if (tr != TR_SUCCESS)
                        break;
                  }
               }
               else
                  tr = TR_ABORT;

            } while (FindNextFile(hff, &wfd));
         }

         if (hff != INVALID_HANDLE_VALUE)
            FindClose(hff);
      }

      TRACE_OUT((TEXT("ExpandFolderTwin(): Folder expansion complete.")));
   }
   else
      MarkFolderTwinDeletionPending(pfp);

   return(tr);
}


/*
** GenerateObjectTwinFromFolderTwinProc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GenerateObjectTwinFromFolderTwinProc(LPCTSTR pcszFolder,
                                                       PCWIN32_FIND_DATA pcwfd,
                                                       PVOID pvpesti)
{
   TWINRESULT tr;
   PEXPANDSUBTREETWININFO pesti = pvpesti;

   ASSERT(IsCanonicalPath(pcszFolder));
   ASSERT(IS_VALID_READ_PTR(pcwfd, CWIN32_FIND_DATA));
   ASSERT(IS_VALID_STRUCT_PTR(pesti, CEXPANDSUBTREETWININFO));

   /* Ping. */

   if (NotifyCreateRecListStatus(pesti->crlp, CRLS_DELTA_CREATE_REC_LIST, 0,
                                 pesti->lpCallbackData))
   {
      if (IS_ATTR_DIR(pcwfd->dwFileAttributes))
      {
         TCHAR rgchFolder[MAX_PATH_LEN];

         /* Add any folder as a folder object twin. */

         ComposePath(rgchFolder, pcszFolder, pcwfd->cFileName);
         ASSERT(lstrlen(rgchFolder) < ARRAYSIZE(rgchFolder));

         tr = AddFolderObjectTwinFromFolderTwin(
                                    pesti->pfp,
                                    rgchFolder + (pesti->ucbSubtreeRootPathLen / sizeof(TCHAR)),
                                    pesti->hcic);
      }
      else
      {
         /* Does this file match the requested attributes? */

         if (NamesIntersect(pcwfd->cFileName,
                            GetString(pesti->pfp->pfpd->hsName)) &&
             AttributesMatch(pesti->pfp->pfpd->dwAttributes,
                             pcwfd->dwFileAttributes))
         {
            /* Yes.  Twin it. */

            TRACE_OUT((TEXT("GenerateObjectTwinFromFolderTwinProc(): Found matching object %s in subfolder %s."),
                       pcwfd->cFileName,
                       pcszFolder));

            tr = AddFileObjectTwinFromFolderTwin(
                                    pesti->pfp,
                                    pcszFolder + (pesti->ucbSubtreeRootPathLen / sizeof(TCHAR)),
                                    pcwfd, pesti->hcic);
         }
         else
         {
            TRACE_OUT((TEXT("GenerateObjectTwinFromFolderTwinProc(): Skipping unmatched object %s in subfolder %s."),
                       pcwfd->cFileName,
                       pcszFolder));

            tr = TR_SUCCESS;
         }
      }
   }
   else
      tr = TR_ABORT;

   pesti->tr = tr;

   ASSERT(IS_VALID_STRUCT_PTR(pvpesti, CEXPANDSUBTREETWININFO));

   return(tr == TR_SUCCESS);
}


/*
** ExpandSubtreeTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT ExpandSubtreeTwin(PFOLDERPAIR pfp, HCLSIFACECACHE hcic,
                                          CREATERECLISTPROC crlp,
                                          LPARAM lpCallbackData)
{
   TWINRESULT tr = TR_SUCCESS;
   TCHAR rgchPath[MAX_PATH_LEN];

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
   ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));
   ASSERT(! crlp ||
          IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));

   ASSERT(IsPathVolumeAvailable(pfp->hpath));
   ASSERT(IsStubFlagSet(&(pfp->stub), STUB_FL_SUBTREE));
   ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_USED));

   GetPathString(pfp->hpath, rgchPath);

   if (PathExists(rgchPath))
   {
      UnmarkFolderTwinDeletionPending(pfp);

      tr = AddFolderObjectTwinFromFolderTwin(pfp, EMPTY_STRING, hcic);

      if (tr == TR_SUCCESS)
      {
         EXPANDSUBTREETWININFO esti;

         esti.pfp = pfp;
         esti.ucbSubtreeRootPathLen = lstrlen(rgchPath) * sizeof(TCHAR); // UNICODE really cb?
         esti.hcic = hcic;
         esti.crlp = crlp;
         esti.lpCallbackData = lpCallbackData;
         esti.tr = TR_SUCCESS;

         tr = ExpandSubtree(pfp->hpath, &GenerateObjectTwinFromFolderTwinProc,
                            &esti);

         ASSERT(tr != TR_SUCCESS ||
                esti.tr == TR_SUCCESS);

         if (tr == TR_SUCCESS ||
             tr == TR_ABORT)
            tr = esti.tr;
      }
   }
   else
      MarkFolderTwinDeletionPending(pfp);

   return(tr);
}


/*
** IsFolderToExpand()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsFolderToExpand(LPCTSTR pcszFolder)
{
   BOOL bExpandMe = TRUE;
   int i;

   for (i = 0; i < ARRAY_ELEMENTS(MrgcpcszFoldersToAvoid); i++)
   {
      if (ComparePathStrings(pcszFolder, MrgcpcszFoldersToAvoid[i])
          == CR_EQUAL)
      {
         bExpandMe = FALSE;
         break;
      }
   }

   return(bExpandMe);
}


/*
** FakeObjectTwinFromFolderTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT FakeObjectTwinFromFolderTwin(PCFOLDERPAIR pcfp,
                                                     LPCTSTR pcszSubPath,
                                                     LPCTSTR pcszName,
                                                     HCLSIFACECACHE hcic,
                                                     POBJECTTWIN *ppot1,
                                                     POBJECTTWIN *ppot2)
{
   TWINRESULT tr = TR_OUT_OF_MEMORY;
   HPATHLIST hpl;
   HPATH hpath1;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_STRING_PTR(pcszSubPath, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));
   ASSERT(IS_VALID_WRITE_PTR(ppot1, POBJECTTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppot2, POBJECTTWIN));

   /* If the common sub path is non-empty, append it to the path strings. */

   hpl = GetBriefcasePathList(pcfp->pfpd->hbr);

   if (AddChildPath(hpl, pcfp->hpath, pcszSubPath, &hpath1))
   {
      HPATH hpath2;

      if (AddChildPath(hpl, pcfp->pfpOther->hpath, pcszSubPath, &hpath2))
      {
         /* Add the two object twins. */

         tr = TwinObjects(pcfp->pfpd->hbr, hcic, hpath1, hpath2, pcszName,
                          ppot1, ppot2);

         DeletePath(hpath2);
      }

      DeletePath(hpath1);
   }

   return(tr);
}


/*
** AddFolderObjectTwinFromFolderTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT AddFolderObjectTwinFromFolderTwin(PCFOLDERPAIR pcfp,
                                                          LPCTSTR pcszSubPath,
                                                          HCLSIFACECACHE hcic)
{
   TWINRESULT tr;
   POBJECTTWIN pot1;
   POBJECTTWIN pot2;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_STRING_PTR(pcszSubPath, CSTR));
   ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));

   /* Add the two object twins. */

   tr = FakeObjectTwinFromFolderTwin(pcfp, pcszSubPath, EMPTY_STRING, hcic,
                                     &pot1, &pot2);

   /* An attempted redundant add is ok. */

   if (tr == TR_DUPLICATE_TWIN)
      tr = TR_SUCCESS;

   if (tr == TR_SUCCESS)
      /* Cache folder object twin file stamps. */
      SetObjectTwinFileStampCondition(pot1, (PVOID)FS_COND_EXISTS);

   return(tr);
}


/*
** AddFileObjectTwinFromFolderTwin()
**
** Adds a pair of object twins generated by a folder twin.
**
** Arguments:     pfp - pointer to folder pair that generated the two object
**                      twins
**                pcszSubPath - common path off of folder pair roots describing
**                              object's location
**                pcszName - name of object twins
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT AddFileObjectTwinFromFolderTwin(PCFOLDERPAIR pcfp,
                                                    LPCTSTR pcszSubPath,
                                                    PCWIN32_FIND_DATA pcwfd,
                                                    HCLSIFACECACHE hcic)
{
   TWINRESULT tr;
   POBJECTTWIN pot1;
   POBJECTTWIN pot2;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_STRING_PTR(pcszSubPath, CSTR));
   ASSERT(IS_VALID_READ_PTR(pcwfd, CWIN32_FIND_DATA));
   ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));

   /* Add the two object twins. */

   tr = FakeObjectTwinFromFolderTwin(pcfp, pcszSubPath, pcwfd->cFileName, hcic,
                                     &pot1, &pot2);

   /* An attempted redundant add is ok. */

   if (tr == TR_DUPLICATE_TWIN)
      tr = TR_SUCCESS;

   if (tr == TR_SUCCESS)
   {
      /* Cache object twin file stamp. */

      CopyFileStampFromFindData(pcwfd, &(pot1->fsCurrent));

      SetStubFlag(&(pot1->stub), STUB_FL_FILE_STAMP_VALID);
   }

   return(tr);
}


/*
** NameComponentsIntersect()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL NameComponentsIntersect(LPCTSTR pcszComponent1,
                                          LPCTSTR pcszComponent2)
{
   BOOL bIntersect;

   ASSERT(IS_VALID_STRING_PTR(pcszComponent1, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszComponent2, CSTR));

   while (! IS_COMPONENT_TERMINATOR(*pcszComponent1) && ! IS_COMPONENT_TERMINATOR(*pcszComponent2) &&
          COMPONENT_CHARS_MATCH(*pcszComponent1, *pcszComponent2))
   {
      pcszComponent1 = CharNext(pcszComponent1);
      pcszComponent2 = CharNext(pcszComponent2);
   }

   if (*pcszComponent1 == ASTERISK ||
       *pcszComponent2 == ASTERISK ||
       *pcszComponent1 == *pcszComponent2)
      bIntersect = TRUE;
   else
   {
      LPCTSTR pcszTrailer;

      if (! *pcszComponent1 || *pcszComponent1 == PERIOD)
         pcszTrailer = pcszComponent2;
      else
         pcszTrailer = pcszComponent1;

      while (*pcszTrailer == QMARK)
         pcszTrailer++;

      if (IS_COMPONENT_TERMINATOR(*pcszTrailer))
         bIntersect = TRUE;
      else
         bIntersect = FALSE;
   }

   return(bIntersect);
}


/*
** AttributesMatch()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** An object's attributes match the master attributes iff the object's
** attributes do not contain any set bits that are not also set in the master
** attributes.
*/
PRIVATE_CODE BOOL AttributesMatch(DWORD dwMasterAttributes,
                                  DWORD dwObjectAttributes)
{
   // We don't consider a difference in compression to be enough to call
   // the file different, especially since that attribute is impossible
   // to reconcile in some cases.

   dwObjectAttributes &= ~(FILE_ATTRIBUTE_COMPRESSED);

   return(! (dwObjectAttributes & (~dwMasterAttributes)));
}


/*
** PrepareForFolderTwinExpansion()
**
**
**
** Arguments:
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., this function should be called before the outermost call to
** MyExpandIntersectingFolderTwins().
*/
PRIVATE_CODE void PrepareForFolderTwinExpansion(HBRFCASE hbr)
{
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   ClearFlagInArrayOfStubs(GetBriefcaseFolderPairPtrArray(hbr), STUB_FL_USED);

   EVAL(EnumObjectTwins(hbr,
                        (ENUMGENERATEDOBJECTTWINSPROC)&ClearStubFlagWrapper,
                        (PVOID)STUB_FL_FILE_STAMP_VALID));

   return;
}


/*
** MyExpandIntersectingFolderTwins()
**
** Expands all folder twins intersecting a pair of folder twins.
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  Marks expanded folder pairs used.
**
** N.b., PrepareForFolderTwinExpansion(pfp->pfpd->hbr) should be called before
** the first time this function is called.
*/
PRIVATE_CODE TWINRESULT MyExpandIntersectingFolderTwins(PFOLDERPAIR pfp,
                                                        HCLSIFACECACHE hcic,
                                                        CREATERECLISTPROC crlp,
                                                        LPARAM lpCallbackData)
{
   TWINRESULT tr;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
   ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));
   ASSERT(! crlp ||
          IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));

   /*
    * N.b., pfp may already be marked used here, but may intersect folder twins
    * that have not yet been expanded.
    */

   tr = HalfExpandIntersectingFolderTwins(pfp, hcic, crlp, lpCallbackData);

   if (tr == TR_SUCCESS)
   {
      ASSERT(IsStubFlagSet(&(pfp->stub), STUB_FL_USED));

      tr = HalfExpandIntersectingFolderTwins(pfp->pfpOther, hcic, crlp,
                                             lpCallbackData);
   }

   return(tr);
}


/*
** HalfExpandIntersectingFolderTwins()
**
** Expands all folder twins intersecting one half of a pair of folder twins.
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  Marks expanded folder pairs used.
**
** N.b., this function is only meant to be called from
** MyExpandIntersectingFolderTwins().
*/
PRIVATE_CODE TWINRESULT HalfExpandIntersectingFolderTwins(
                                                      PFOLDERPAIR pfp,
                                                      HCLSIFACECACHE hcic,
                                                      CREATERECLISTPROC crlp,
                                                      LPARAM lpCallbackData)
{
   TWINRESULT tr = TR_SUCCESS;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
   ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));
   ASSERT(! crlp ||
          IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));

   if (IsStubFlagClear(&(pfp->stub), STUB_FL_UNLINKED))
   {
      BOOL bArgIsSubtree;
      HPTRARRAY hpaFolderPairs;
      ARRAYINDEX ai;
      ARRAYINDEX aicFolderPairs;

      bArgIsSubtree = IsStubFlagSet(&(pfp->stub), STUB_FL_SUBTREE);

      hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pfp->pfpd->hbr);
      aicFolderPairs = GetPtrCount(hpaFolderPairs);

      for (ai = 0; ai < aicFolderPairs; ai++)
      {
         PFOLDERPAIR pfpCur;

         pfpCur = (PFOLDERPAIR)GetPtr(hpaFolderPairs, ai);

         ASSERT(IS_VALID_STRUCT_PTR(pfpCur, CFOLDERPAIR));

         if (IsStubFlagClear(&(pfpCur->stub), STUB_FL_USED) &&
             NamesIntersect(GetString(pfp->pfpd->hsName),
                            GetString(pfpCur->pfpd->hsName)))
         {
            BOOL bCurIsSubtree;
            BOOL bExpand = FALSE;

            bCurIsSubtree = IsStubFlagSet(&(pfpCur->stub), STUB_FL_SUBTREE);

            if (bCurIsSubtree)
            {
               if (bArgIsSubtree)
                  bExpand = SubtreesIntersect(pfp->hpath, pfpCur->hpath);
               else
                  bExpand = IsPathPrefix(pfp->hpath, pfpCur->hpath);
            }
            else
            {
               if (bArgIsSubtree)
                  bExpand = IsPathPrefix(pfpCur->hpath, pfp->hpath);
               else
                  bExpand = (ComparePaths(pfp->hpath, pfpCur->hpath) == CR_EQUAL);
            }

            /* Expand folder twin and mark it used. */

            if (bExpand)
            {
               /*
                * Mark all generated object twins as non-existent or unavailable.
                * Expand available folder twin.
                */

               if (IsPathVolumeAvailable(pfp->hpath))
               {
                  EVAL(EnumGeneratedObjectTwins(pfp,
                                                &SetObjectTwinFileStampCondition,
                                                (PVOID)FS_COND_DOES_NOT_EXIST));

                  if (bCurIsSubtree)
                     tr = ExpandSubtreeTwin(pfpCur, hcic, crlp, lpCallbackData);
                  else
                     tr = ExpandFolderTwin(pfpCur, hcic, crlp, lpCallbackData);

                  if (tr != TR_SUCCESS)
                     break;
               }
               else
               {
                  EVAL(EnumGeneratedObjectTwins(pfp, &SetObjectTwinFileStampCondition,
                                                (PVOID)FS_COND_UNAVAILABLE));

                  WARNING_OUT((TEXT("HalfExpandIntersectingFolderTwins(): Unavailable folder %s skipped."),
                               DebugGetPathString(pfp->hpath)));
               }

               SetStubFlag(&(pfp->stub), STUB_FL_USED);
            }
         }
      }
   }

   return(tr);
}


#ifdef DEBUG

/*
** IsValidPCEXPANDSUBTREETWININFO()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCEXPANDSUBTREETWININFO(PCEXPANDSUBTREETWININFO pcesi)
{
   /* lpCallbackData may be any value. */

   return(IS_VALID_READ_PTR(pcesi, CEXPANDSUBTREETWININFO) &&
          IS_VALID_STRUCT_PTR(pcesi->pfp, CFOLDERPAIR) &&
          EVAL(pcesi->ucbSubtreeRootPathLen > 0) &&
          IS_VALID_HANDLE(pcesi->hcic, CLSIFACECACHE) &&
          IsValidTWINRESULT(pcesi->tr));
}

#endif


/****************************** Public Functions *****************************/


/*
** ExpandSubtree()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ExpandSubtree(HPATH hpathRoot, EXPANDSUBTREEPROC esp,
                               PVOID pvRefData)
{
   TWINRESULT tr;
   PFINDSTATE pfs;

   /* pvRefData may be any value. */

   ASSERT(IS_VALID_HANDLE(hpathRoot, PATH));
   ASSERT(IS_VALID_CODE_PTR(esp, EXPANDSUBTREEPROC));

   ASSERT(IsPathVolumeAvailable(hpathRoot));

   if (AllocateMemory(MAX_FOLDER_DEPTH * sizeof(pfs[0]), &pfs))
   {
      /* Copy subtree root folder to beginning of search path buffer. */

      TCHAR rgchSearchSpec[MAX_PATH_LEN];
      LPTSTR pszPathSuffix;
      int iFind;
      LPTSTR pszStartOfSubPath;
      BOOL bFound;
#ifdef DEBUG
      /* Are we leaking WIN32_FIND_DATA structures? */
      ULONG ulcOpenFinds = 0;
#endif

      GetPathRootString(hpathRoot, rgchSearchSpec);
      pszPathSuffix = rgchSearchSpec + lstrlen(rgchSearchSpec);
      GetPathSuffixString(hpathRoot, pszPathSuffix);

      pszStartOfSubPath = rgchSearchSpec + lstrlen(rgchSearchSpec);

      TRACE_OUT((TEXT("ExpandSubtree(): Expanding subtree rooted at %s."),
                 rgchSearchSpec));

      /* Append *.* file specification. */

      CatPath(rgchSearchSpec, STAR_DOT_STAR);

      /* Begin search at subtree root. */

      iFind = 0;

      pfs[iFind].hff = FindFirstFile(rgchSearchSpec, &(pfs[iFind].wfd));

#ifdef DEBUG
      if (pfs[iFind].hff != INVALID_HANDLE_VALUE)
         ulcOpenFinds++;
#endif

      bFound = (pfs[iFind].hff != INVALID_HANDLE_VALUE);

      /* Rip off *.*. */

      DeleteLastPathElement(pszPathSuffix);

      /* Search subtree depth first. */

      tr = TR_SUCCESS;

      while (bFound && tr == TR_SUCCESS)
      {
         /* Did we find a directory to expand? */

         if (IS_ATTR_DIR(pfs[iFind].wfd.dwFileAttributes))
         {
            if (IsFolderToExpand(pfs[iFind].wfd.cFileName))
            {
               /* Yes.  Dive down into it. */

               /* Append the new directory to the current search path. */

               CatPath(rgchSearchSpec, pfs[iFind].wfd.cFileName);

               TRACE_OUT((TEXT("ExpandSubtree(): Diving into subfolder %s."),
                          rgchSearchSpec));

               /* Append *.* file specification. */

               CatPath(rgchSearchSpec, STAR_DOT_STAR);

               /* Start search in the new directory. */

               ASSERT(iFind < INT_MAX);
               iFind++;
               pfs[iFind].hff = FindFirstFile(rgchSearchSpec, &(pfs[iFind].wfd));

               bFound = (pfs[iFind].hff != INVALID_HANDLE_VALUE);

#ifdef DEBUG
               if (bFound)
                  ulcOpenFinds++;
#endif

               /* Rip off *.*. */

               DeleteLastPathElement(pszPathSuffix);
            }
            else
               /* Continue search in this directory. */
               bFound = FindNextFile(pfs[iFind].hff, &(pfs[iFind].wfd));
         }
         else
         {
            /* Found a file. */

            TRACE_OUT((TEXT("ExpandSubtree(): Found file %s\\%s."),
                       rgchSearchSpec,
                       pfs[iFind].wfd.cFileName));

            if ((*esp)(rgchSearchSpec, &(pfs[iFind].wfd), pvRefData))
               bFound = FindNextFile(pfs[iFind].hff, &(pfs[iFind].wfd));
            else
               tr = TR_ABORT;
         }

         if (tr == TR_SUCCESS)
         {
            while (! bFound)
            {
               /* Find failed.  Climb back up one directory level. */

               if (pfs[iFind].hff != INVALID_HANDLE_VALUE)
               {
                  FindClose(pfs[iFind].hff);
#ifdef DEBUG
                  ulcOpenFinds--;
#endif
               }

               if (iFind > 0)
               {
                  DeleteLastPathElement(pszPathSuffix);
                  iFind--;

                  if (IsFolderToExpand(pfs[iFind].wfd.cFileName))
                  {
                     TRACE_OUT((TEXT("ExpandSubtree(): Found folder %s\\%s."),
                                rgchSearchSpec,
                                pfs[iFind].wfd.cFileName));

                     if (! (*esp)(rgchSearchSpec, &(pfs[iFind].wfd), pvRefData))
                     {
                        tr = TR_ABORT;
                        break;
                     }
                  }

                  bFound = FindNextFile(pfs[iFind].hff, &(pfs[iFind].wfd));
               }
               else
               {
                  ASSERT(! iFind);
                  break;
               }
            }
         }
      }

      if (tr != TR_SUCCESS)
      {
         /* Close all open find operations on failure. */

         while (iFind >= 0)
         {
            if (pfs[iFind].hff != INVALID_HANDLE_VALUE)
            {
               FindClose(pfs[iFind].hff);
               iFind--;
#ifdef DEBUG
               ulcOpenFinds--;
#endif
            }
         }
      }

      ASSERT(! ulcOpenFinds);

      FreeMemory(pfs);

      TRACE_OUT((TEXT("ExpandSubtree(): Subtree expansion complete.")));
   }
   else
      tr = TR_OUT_OF_MEMORY;

   return(tr);
}


/*
** ClearStubFlagWrapper()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ClearStubFlagWrapper(PSTUB pstub, PVOID dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(pstub, CSTUB));
   ASSERT(FLAGS_ARE_VALID((DWORD)dwFlags, ALL_STUB_FLAGS));

   ClearStubFlag(pstub, (DWORD)dwFlags);

   return(TRUE);
}


/*
** SetStubFlagWrapper()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SetStubFlagWrapper(PSTUB pstub, PVOID dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(pstub, CSTUB));
   ASSERT(FLAGS_ARE_VALID((DWORD)dwFlags, ALL_STUB_FLAGS));

   SetStubFlag(pstub, (DWORD)dwFlags);

   return(TRUE);
}


/*
** ExpandIntersectingFolderTwins()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  Leaves only the folder pairs expanded marked used.
*/
PUBLIC_CODE TWINRESULT ExpandIntersectingFolderTwins(PFOLDERPAIR pfp,
                                                     CREATERECLISTPROC crlp,
                                                     LPARAM lpCallbackData)
{
   TWINRESULT tr;
   HCLSIFACECACHE hcic;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
   ASSERT(! crlp ||
          IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));

   ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_UNLINKED));

   if (CreateClassInterfaceCache(&hcic))
   {
      /* Prepare for call to MyExpandIntersectingFolderTwins(). */

      PrepareForFolderTwinExpansion(pfp->pfpd->hbr);

      tr = MyExpandIntersectingFolderTwins(pfp, hcic, crlp, lpCallbackData);

      DestroyClassInterfaceCache(hcic);
   }
   else
      tr = TR_OUT_OF_MEMORY;

   return(tr);
}


/*
** ExpandFolderTwinsIntersectingTwinList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  Leaves only the folder pairs expanded marked used.
*/
PUBLIC_CODE TWINRESULT ExpandFolderTwinsIntersectingTwinList(
                                                      HTWINLIST htl,
                                                      CREATERECLISTPROC crlp,
                                                      LPARAM lpCallbackData)
{
   TWINRESULT tr;
   HCLSIFACECACHE hcic;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_HANDLE(htl, TWINLIST));
   ASSERT(! crlp ||
          IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));

   if (CreateClassInterfaceCache(&hcic))
   {
      ARRAYINDEX aicTwins;
      ARRAYINDEX ai;

      tr = TR_SUCCESS;

      /* Prepare for calls to MyExpandIntersectingFolderTwins(). */

      PrepareForFolderTwinExpansion(GetTwinListBriefcase(htl));

      aicTwins = GetTwinListCount(htl);

      for (ai = 0; ai < aicTwins; ai++)
      {
         HTWIN htwin;

         htwin = GetTwinFromTwinList(htl, ai);

         /* Expand only live folder twins. */

         if (((PCSTUB)htwin)->st == ST_FOLDERPAIR)
         {
            tr = MyExpandIntersectingFolderTwins((PFOLDERPAIR)htwin, hcic,
                                                 crlp, lpCallbackData);

            if (tr != TR_SUCCESS)
               break;
         }
      }

      DestroyClassInterfaceCache(hcic);
   }
   else
      tr = TR_OUT_OF_MEMORY;

   return(tr);
}


/*
** TryToGenerateObjectTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT TryToGenerateObjectTwin(HBRFCASE hbr, HPATH hpathFolder,
                                               LPCTSTR pcszName,
                                               PBOOL pbGenerated,
                                               POBJECTTWIN *ppot)
{
   TWINRESULT tr;
   HCLSIFACECACHE hcic;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pbGenerated, BOOL));
   ASSERT(IS_VALID_WRITE_PTR(ppot, POBJECTTWIN));

   if (CreateClassInterfaceCache(&hcic))
   {
      HPTRARRAY hpaFolderPairs;
      ARRAYINDEX aicPtrs;
      ARRAYINDEX ai;

      tr = TR_SUCCESS;
      *pbGenerated = FALSE;

      hpaFolderPairs = GetBriefcaseFolderPairPtrArray(hbr);

      aicPtrs = GetPtrCount(hpaFolderPairs);
      ASSERT(! (aicPtrs % 2));

      for (ai = 0; ai < aicPtrs; ai++)
      {
         PCFOLDERPAIR pcfp;

         pcfp = GetPtr(hpaFolderPairs, ai);

         if (FolderTwinGeneratesObjectTwin(pcfp, hpathFolder, pcszName))
         {
            TCHAR rgchSubPath[MAX_PATH_LEN];
            LPCTSTR pcszSubPath;
            POBJECTTWIN potOther;

            if (IsStubFlagSet(&(pcfp->stub), STUB_FL_SUBTREE))
               pcszSubPath = FindChildPathSuffix(pcfp->hpath, hpathFolder,
                                                 rgchSubPath);
            else
               pcszSubPath = EMPTY_STRING;

            tr = FakeObjectTwinFromFolderTwin(pcfp, pcszSubPath, pcszName,
                                              hcic, ppot, &potOther);

            if (tr == TR_SUCCESS)
               *pbGenerated = TRUE;
            else
               ASSERT(tr != TR_DUPLICATE_TWIN);

            break;
         }
      }

      DestroyClassInterfaceCache(hcic);
   }
   else
      tr = TR_OUT_OF_MEMORY;

   ASSERT(tr != TR_SUCCESS ||
          ! *pbGenerated ||
          IS_VALID_STRUCT_PTR(*ppot, COBJECTTWIN));

   return(tr);
}


/*
** NamesIntersect()
**
** Determines whether or not two names may refer to the same object.  Both
** names may contain wildcards ('*' or '?').
**
** Arguments:     pcszName1 - first name
**                pcszName2 - second name
**
** Returns:       TRUE if the two names intersect.  FALSE if not.
**
** Side Effects:  none
**
** A "name" is broken up into two components: a "base" and an optional
** "extension", e.g., "BASE" or "BASE.EXT".
**
** "Intersecting names" are defined as follows:
**
**    1) An asterisk matches 0 or more characters in the base or extension.
**    2) Any characters after an asterisk in the base or extension are ignored.
**    3) A question mark matches exactly one character, or no character if it
**       appears at the end of the base or extension.
**
** N.b., this function does not perform any checking on the validity of the two
** names.
*/
PUBLIC_CODE BOOL NamesIntersect(LPCTSTR pcszName1, LPCTSTR pcszName2)
{
   BOOL bIntersect = FALSE;

   ASSERT(IS_VALID_STRING_PTR(pcszName1, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszName2, CSTR));

   if (NameComponentsIntersect(pcszName1, pcszName2))
   {
      LPCTSTR pcszExt1;
      LPCTSTR pcszExt2;

      /* Get extensions, skipping leading periods. */

      pcszExt1 = ExtractExtension(pcszName1);
      if (*pcszExt1 == PERIOD)
         pcszExt1 = CharNext(pcszExt1);

      pcszExt2 = ExtractExtension(pcszName2);
      if (*pcszExt2 == PERIOD)
         pcszExt2 = CharNext(pcszExt2);

      bIntersect = NameComponentsIntersect(pcszExt1, pcszExt2);
   }

   return(bIntersect);
}


#ifdef DEBUG

/*
** IsValidTWINRESULT()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidTWINRESULT(TWINRESULT tr)
{
   BOOL bResult;

   switch (tr)
   {
      case TR_SUCCESS:
      case TR_RH_LOAD_FAILED:
      case TR_SRC_OPEN_FAILED:
      case TR_SRC_READ_FAILED:
      case TR_DEST_OPEN_FAILED:
      case TR_DEST_WRITE_FAILED:
      case TR_ABORT:
      case TR_UNAVAILABLE_VOLUME:
      case TR_OUT_OF_MEMORY:
      case TR_FILE_CHANGED:
      case TR_DUPLICATE_TWIN:
      case TR_DELETED_TWIN:
      case TR_HAS_FOLDER_TWIN_SRC:
      case TR_INVALID_PARAMETER:
      case TR_REENTERED:
      case TR_SAME_FOLDER:
      case TR_SUBTREE_CYCLE_FOUND:
      case TR_NO_MERGE_HANDLER:
      case TR_MERGE_INCOMPLETE:
      case TR_TOO_DIFFERENT:
      case TR_BRIEFCASE_LOCKED:
      case TR_BRIEFCASE_OPEN_FAILED:
      case TR_BRIEFCASE_READ_FAILED:
      case TR_BRIEFCASE_WRITE_FAILED:
      case TR_CORRUPT_BRIEFCASE:
      case TR_NEWER_BRIEFCASE:
      case TR_NO_MORE:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidTWINRESULT(): Invalid TWINRESULT %d."),
                    tr));
         break;
   }

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\fcache.h ===
/*
 * fcache.h - File cache ADT description.
 */


/* Types
 ********/

/* return code */

typedef enum _fcresult
{
   FCR_SUCCESS,
   FCR_OUT_OF_MEMORY,
   FCR_OPEN_FAILED,
   FCR_CREATE_FAILED,
   FCR_WRITE_FAILED,
   FCR_FILE_LOCKED
}
FCRESULT;
DECLARE_STANDARD_TYPES(FCRESULT);

/* handles */

#ifdef NOFCACHE
typedef HANDLE HCACHEDFILE;
#else
DECLARE_HANDLE(HCACHEDFILE);
#endif
DECLARE_STANDARD_TYPES(HCACHEDFILE);

/* cached file description */

typedef struct _cachedfile
{
   LPCTSTR pcszPath;

   DWORD dwcbDefaultCacheSize;

   DWORD dwOpenMode;

   DWORD dwSharingMode;

   PSECURITY_ATTRIBUTES psa;

   DWORD dwCreateMode;

   DWORD dwAttrsAndFlags;

   HANDLE hTemplateFile;
}
CACHEDFILE;
DECLARE_STANDARD_TYPES(CACHEDFILE);


/* Prototypes
 *************/

/* fcache.c */

extern FCRESULT CreateCachedFile(PCCACHEDFILE, PHCACHEDFILE);
extern FCRESULT SetCachedFileCacheSize(HCACHEDFILE, DWORD);
extern DWORD SeekInCachedFile(HCACHEDFILE, DWORD, DWORD);
extern BOOL SetEndOfCachedFile(HCACHEDFILE);
extern DWORD GetCachedFilePointerPosition(HCACHEDFILE);
extern DWORD GetCachedFileSize(HCACHEDFILE);
extern BOOL ReadFromCachedFile(HCACHEDFILE, PVOID, DWORD, PDWORD);
extern BOOL WriteToCachedFile(HCACHEDFILE, PCVOID, DWORD, PDWORD);
extern BOOL CommitCachedFile(HCACHEDFILE);
extern HANDLE GetFileHandle(HCACHEDFILE);
extern BOOL CloseCachedFile(HCACHEDFILE);
extern HANDLE GetFileHandle(HCACHEDFILE);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidHCACHEDFILE(HCACHEDFILE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\file.h ===
/*
 * file.h - File routines module description.
 */


/* Constants
 ************/

/*
 * maximum length of unique name created by MakeUniqueName(), including null
 * terminator
 */

#define MAX_UNIQUE_NAME_LEN            (8 + 1 + 3 + 1)

/* file-related flag combinations */

#define ALL_FILE_ACCESS_FLAGS          (GENERIC_READ |\
                                        GENERIC_WRITE)

#define ALL_FILE_SHARING_FLAGS         (FILE_SHARE_READ |\
                                        FILE_SHARE_WRITE)

#ifdef WINNT
#define ALL_FILE_ATTRIBUTES            (FILE_ATTRIBUTE_READONLY |\
                                            FILE_ATTRIBUTE_HIDDEN |\
                                            FILE_ATTRIBUTE_SYSTEM |\
                                            FILE_ATTRIBUTE_DIRECTORY |\
                                            FILE_ATTRIBUTE_ARCHIVE |\
                                            FILE_ATTRIBUTE_NORMAL |\
                                            FILE_ATTRIBUTE_TEMPORARY)
#else
#define ALL_FILE_ATTRIBUTES            (FILE_ATTRIBUTE_READONLY |\
                                            FILE_ATTRIBUTE_HIDDEN |\
                                            FILE_ATTRIBUTE_SYSTEM |\
                                            FILE_ATTRIBUTE_DIRECTORY |\
                                            FILE_ATTRIBUTE_ARCHIVE |\
                                            FILE_ATTRIBUTE_NORMAL |\
                                            FILE_ATTRIBUTE_TEMPORARY |\
                                            FILE_ATTRIBUTE_ATOMIC_WRITE |\
                                            FILE_ATTRIBUTE_XACTION_WRITE )
#endif


#define ALL_FILE_FLAGS                 (FILE_FLAG_WRITE_THROUGH |\
                                        FILE_FLAG_OVERLAPPED |\
                                        FILE_FLAG_NO_BUFFERING |\
                                        FILE_FLAG_RANDOM_ACCESS |\
                                        FILE_FLAG_SEQUENTIAL_SCAN |\
                                        FILE_FLAG_DELETE_ON_CLOSE |\
                                        FILE_FLAG_BACKUP_SEMANTICS |\
                                        FILE_FLAG_POSIX_SEMANTICS)

#define ALL_FILE_ATTRIBUTES_AND_FLAGS  (ALL_FILE_ATTRIBUTES |\
                                        ALL_FILE_FLAGS)


/* Macros
 *********/

/* file attribute manipulation */

#define IS_ATTR_DIR(attr)              (IS_FLAG_SET((attr), FILE_ATTRIBUTE_DIRECTORY))
#define IS_ATTR_VOLUME(attr)           (IS_FLAG_SET((attr), FILE_ATTRIBUTE_VOLUME))


/* Prototypes
 *************/

PUBLIC_CODE void BeginComp(void);
PUBLIC_CODE void EndComp(void);
PUBLIC_CODE TWINRESULT CompareFilesByHandle(HANDLE, HANDLE, PBOOL);
PUBLIC_CODE TWINRESULT CompareFilesByName(HPATH, HPATH, PBOOL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\findbc.h ===
/*
 * findbc.h - Briefcase enumeration module description.
 */


/* Prototypes
 *************/

/* findbc.c */

extern TWINRESULT AddBriefcaseToSystem(LPCTSTR);
extern TWINRESULT RemoveBriefcaseFromSystem(LPCTSTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\foldtwin.c ===
/*
 * foldtwin.c - Folder twin ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "subcycle.h"


/* Constants
 ************/

/* pointer array allocation constants */

#define NUM_START_FOLDER_TWIN_PTRS     (16)
#define NUM_FOLDER_TWIN_PTRS_TO_ADD    (16)


/* Types
 ********/

/* internal new folder twin description */

typedef struct _inewfoldertwin
{
   HPATH hpathFirst;
   HPATH hpathSecond;
   HSTRING hsName;
   DWORD dwAttributes;
   HBRFCASE hbr;
   DWORD dwFlags;
}
INEWFOLDERTWIN;
DECLARE_STANDARD_TYPES(INEWFOLDERTWIN);

/* database folder twin list header */

typedef struct _dbfoldertwinlistheader
{
   LONG lcFolderPairs;
}
DBFOLDERTWINLISTHEADER;
DECLARE_STANDARD_TYPES(DBFOLDERTWINLISTHEADER);

/* database folder twin structure */

typedef struct _dbfoldertwin
{
   /* shared stub flags */

   DWORD dwStubFlags;

   /* old handle to first folder path */

   HPATH hpath1;

   /* old handle to second folder path */

   HPATH hpath2;

   /* old handle to name string */

   HSTRING hsName;

   /* attributes to match */

   DWORD dwAttributes;
}
DBFOLDERTWIN;
DECLARE_STANDARD_TYPES(DBFOLDERTWIN);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE TWINRESULT MakeINewFolderTwin(HBRFCASE, PCNEWFOLDERTWIN, PINEWFOLDERTWIN);
PRIVATE_CODE void ReleaseINewFolderTwin(PINEWFOLDERTWIN);
PRIVATE_CODE TWINRESULT TwinFolders(PCINEWFOLDERTWIN, PFOLDERPAIR *);
PRIVATE_CODE BOOL FindFolderPair(PCINEWFOLDERTWIN, PFOLDERPAIR *);
PRIVATE_CODE BOOL CreateFolderPair(PCINEWFOLDERTWIN, PFOLDERPAIR *);
PRIVATE_CODE BOOL CreateHalfOfFolderPair(HPATH, HBRFCASE, PFOLDERPAIR *);
PRIVATE_CODE void DestroyHalfOfFolderPair(PFOLDERPAIR);
PRIVATE_CODE BOOL CreateSharedFolderPairData(PCINEWFOLDERTWIN, PFOLDERPAIRDATA *);
PRIVATE_CODE void DestroySharedFolderPairData(PFOLDERPAIRDATA);
PRIVATE_CODE COMPARISONRESULT FolderPairSortCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT FolderPairSearchCmp(PCVOID, PCVOID);
PRIVATE_CODE BOOL RemoveSourceFolderTwin(POBJECTTWIN, PVOID);
PRIVATE_CODE void UnlinkHalfOfFolderPair(PFOLDERPAIR);
PRIVATE_CODE BOOL FolderTwinIntersectsFolder(PCFOLDERPAIR, HPATH);
PRIVATE_CODE TWINRESULT CreateListOfFolderTwins(HBRFCASE, ARRAYINDEX, HPATH, PFOLDERTWIN *, PARRAYINDEX);
PRIVATE_CODE void DestroyListOfFolderTwins(PFOLDERTWIN);
PRIVATE_CODE TWINRESULT AddFolderTwinToList(PFOLDERPAIR, PFOLDERTWIN, PFOLDERTWIN *);
PRIVATE_CODE TWINRESULT TransplantFolderPair(PFOLDERPAIR, HPATH, HPATH);
PRIVATE_CODE TWINRESULT WriteFolderPair(HCACHEDFILE, PFOLDERPAIR);
PRIVATE_CODE TWINRESULT ReadFolderPair(HCACHEDFILE, HBRFCASE, HHANDLETRANS, HHANDLETRANS);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCNEWFOLDERTWIN(PCNEWFOLDERTWIN);
PRIVATE_CODE BOOL IsValidPCFOLDERTWINLIST(PCFOLDERTWINLIST);
PRIVATE_CODE BOOL IsValidPCFOLDERTWIN(PCFOLDERTWIN);
PRIVATE_CODE BOOL IsValidFolderPairHalf(PCFOLDERPAIR);
PRIVATE_CODE BOOL IsValidPCFOLDERPAIRDATA(PCFOLDERPAIRDATA);

#endif

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCINEWFOLDERTWIN(PCINEWFOLDERTWIN);
PRIVATE_CODE BOOL AreFolderPairsValid(HPTRARRAY);

#endif


/*
** MakeINewFolderTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT MakeINewFolderTwin(HBRFCASE hbr,
                                           PCNEWFOLDERTWIN pcnftSrc,
                                           PINEWFOLDERTWIN pinftDest)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_STRUCT_PTR(pcnftSrc, CNEWFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(pinftDest, CINEWFOLDERTWIN));

   if (AddString(pcnftSrc->pcszName, GetBriefcaseNameStringTable(hbr),
                 GetHashBucketIndex, &(pinftDest->hsName)))
   {
      HPATHLIST hpl;

      hpl = GetBriefcasePathList(hbr);

      tr = TranslatePATHRESULTToTWINRESULT(
            AddPath(hpl, pcnftSrc->pcszFolder1, &(pinftDest->hpathFirst)));

      if (tr == TR_SUCCESS)
      {
         tr = TranslatePATHRESULTToTWINRESULT(
               AddPath(hpl, pcnftSrc->pcszFolder2, &(pinftDest->hpathSecond)));

         if (tr == TR_SUCCESS)
         {
            pinftDest->dwAttributes = pcnftSrc->dwAttributes;
            pinftDest->dwFlags = pcnftSrc->dwFlags;
            pinftDest->hbr = hbr;
         }
         else
         {
            DeletePath(pinftDest->hpathFirst);
MAKEINEWFOLDERTWIN_BAIL:
            DeleteString(pinftDest->hsName);
         }
      }
      else
         goto MAKEINEWFOLDERTWIN_BAIL;
   }
   else
      tr = TR_OUT_OF_MEMORY;

   ASSERT(tr != TR_SUCCESS ||
          IS_VALID_STRUCT_PTR(pinftDest, CINEWFOLDERTWIN));

   return(tr);
}


/*
** ReleaseINewFolderTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void ReleaseINewFolderTwin(PINEWFOLDERTWIN pinft)
{
   ASSERT(IS_VALID_STRUCT_PTR(pinft, CINEWFOLDERTWIN));

   DeletePath(pinft->hpathFirst);
   DeletePath(pinft->hpathSecond);
   DeleteString(pinft->hsName);

   return;
}


/*
** TwinFolders()
**
** Twins two folders.
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT TwinFolders(PCINEWFOLDERTWIN pcinft, PFOLDERPAIR *ppfp)
{
   PFOLDERPAIR pfp;
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pcinft, CINEWFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppfp, PFOLDERPAIR));

   /* Are the two folders the same? */

   if (ComparePaths(pcinft->hpathFirst, pcinft->hpathSecond) != CR_EQUAL)
   {
      /* Look for the two folders in existing folder pairs. */

      if (FindFolderPair(pcinft, &pfp))
      {
         /* Found a existing matching folder pair.  Complain. */

         *ppfp = pfp;

         tr = TR_DUPLICATE_TWIN;
      }
      else
      {
         /*
          * No existing matching folder pairs found.  Only allowing twinning to
          * paths whose roots are available.
          */

         if (IsPathVolumeAvailable(pcinft->hpathFirst) &&
             IsPathVolumeAvailable(pcinft->hpathSecond))
         {
            /*
             * If this is a new folder subtree pair, check to see if it would
             * create a cycle.
             */

            if (IS_FLAG_SET(pcinft->dwFlags, NFT_FL_SUBTREE))
               tr = CheckForSubtreeCycles(
                        GetBriefcaseFolderPairPtrArray(pcinft->hbr),
                        pcinft->hpathFirst, pcinft->hpathSecond,
                        pcinft->hsName);
            else
               tr = TR_SUCCESS;

            if (tr == TR_SUCCESS)
            {
               if (CreateFolderPair(pcinft, &pfp))
               {
                  *ppfp = pfp;

                  TRACE_OUT((TEXT("TwinFolders(): Creating %s twin pair %s and %s, files %s."),
                             IS_FLAG_SET(pcinft->dwFlags, NFT_FL_SUBTREE) ? TEXT("subtree") : TEXT("folder"),
                             DebugGetPathString(pcinft->hpathFirst),
                             DebugGetPathString(pcinft->hpathSecond),
                             GetString(pcinft->hsName)));
               }
               else
                  tr = TR_OUT_OF_MEMORY;
            }
         }
         else
            tr = TR_UNAVAILABLE_VOLUME;
      }
   }
   else
      tr = TR_SAME_FOLDER;

   return(tr);
}


/*
** FindFolderPair()
**
** Looks for a folder pair matching the given description.
**
** Arguments:     pcinft - pointer to INEWFOLDERTWIN describing folder pair to
**                          search for
**
** Returns:       Pointer to PFOLDERPAIR if found.  NULL if not found.
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FindFolderPair(PCINEWFOLDERTWIN pcinft, PFOLDERPAIR *ppfp)
{
   ARRAYINDEX aiFirst;

   ASSERT(IS_VALID_STRUCT_PTR(pcinft, CINEWFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppfp, PFOLDERPAIR));

   /*
    * Search all folder pairs containing the first folder.  Then scan all these
    * folder pairs for the second folder.
    */

   *ppfp = NULL;

   if (SearchSortedArray(GetBriefcaseFolderPairPtrArray(pcinft->hbr),
                         &FolderPairSearchCmp, pcinft->hpathFirst, &aiFirst))
   {
      ARRAYINDEX aicPtrs;
      HPTRARRAY hpaFolderPairs;
      LONG ai;
      PFOLDERPAIR pfp;

      /*
       * aiFirst holds the index of the first folder pair that
       * contains the first folder name.
       */

      /*
       * Now search each of these folder pairs for all paired folders
       * using the second folder name.
       */

      hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pcinft->hbr);

      aicPtrs = GetPtrCount(hpaFolderPairs);
      ASSERT(aicPtrs > 0);
      ASSERT(! (aicPtrs % 2));
      ASSERT(aiFirst >= 0);
      ASSERT(aiFirst < aicPtrs);

      for (ai = aiFirst; ai < aicPtrs; ai++)
      {
         pfp = GetPtr(hpaFolderPairs, ai);

         ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

         /* Does this folder pair match the proposed folder pair? */

         if (ComparePaths(pfp->hpath, pcinft->hpathFirst) == CR_EQUAL)
         {
            /*
             * An existing pair of folder twins is considered the same as a
             * proposed new pair of folder twins when the two pairs of folder
             * twins share the same:
             *    1) pair of PATHs
             *    2) name specification
             *    3) file attributes
             *    4) subtree flag setting
             */

            if (ComparePaths(pfp->pfpOther->hpath, pcinft->hpathSecond) == CR_EQUAL &&
                CompareNameStringsByHandle(pfp->pfpd->hsName, pcinft->hsName) == CR_EQUAL &&
                pfp->pfpd->dwAttributes == pcinft->dwAttributes &&
                ((IS_FLAG_SET(pfp->stub.dwFlags, STUB_FL_SUBTREE) &&
                  IS_FLAG_SET(pcinft->dwFlags, NFT_FL_SUBTREE)) ||
                 (IS_FLAG_CLEAR(pfp->stub.dwFlags, STUB_FL_SUBTREE) &&
                  IS_FLAG_CLEAR(pcinft->dwFlags, NFT_FL_SUBTREE))))
            {
               /* Yes. */

               *ppfp = pfp;
               break;
            }
         }
         else
            break;
      }
   }

   return(*ppfp != NULL);
}


/*
** CreateFolderPair()
**
** Creates a new folder pair, and adds them to a briefcase's list of folder
** pairs.
**
** Arguments:     pcinft - pointer to INEWFOLDERTWIN describing folder pair to
**                         create
**                ppfp - pointer to PFOLDERPAIR to be filled in with pointer to
**                       half of new folder pair representing
**                       pcnft->pcszFolder1
**
** Returns:
**
** Side Effects:  Adds the new folder pair to the global array of folder pairs.
**
** N.b., this function does not first check to see if the folder pair already
** exists in the global list of folder pairs.
*/
PRIVATE_CODE BOOL CreateFolderPair(PCINEWFOLDERTWIN pcinft, PFOLDERPAIR *ppfp)
{
   BOOL bResult = FALSE;
   PFOLDERPAIRDATA pfpd;

   ASSERT(IS_VALID_STRUCT_PTR(pcinft, CINEWFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppfp, PFOLDERPAIR));

   /* Try to create the shared folder data structure. */

   if (CreateSharedFolderPairData(pcinft, &pfpd))
   {
      PFOLDERPAIR pfpNew1;
      BOOL bPtr1Loose = TRUE;

      if (CreateHalfOfFolderPair(pcinft->hpathFirst, pcinft->hbr, &pfpNew1))
      {
         PFOLDERPAIR pfpNew2;

         if (CreateHalfOfFolderPair(pcinft->hpathSecond, pcinft->hbr,
                                    &pfpNew2))
         {
            HPTRARRAY hpaFolderPairs;
            ARRAYINDEX ai1;

            /* Combine the two folder pair halves. */

            pfpNew1->pfpd = pfpd;
            pfpNew1->pfpOther = pfpNew2;

            pfpNew2->pfpd = pfpd;
            pfpNew2->pfpOther = pfpNew1;

            /* Set flags. */

            if (IS_FLAG_SET(pcinft->dwFlags, NFT_FL_SUBTREE))
            {
               SetStubFlag(&(pfpNew1->stub), STUB_FL_SUBTREE);
               SetStubFlag(&(pfpNew2->stub), STUB_FL_SUBTREE);
            }

            /*
             * Try to add the two folder pairs to the global list of folder
             * pairs.
             */

            hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pcinft->hbr);

            if (AddPtr(hpaFolderPairs, FolderPairSortCmp, pfpNew1, &ai1))
            {
               ARRAYINDEX ai2;

               bPtr1Loose = FALSE;

               if (AddPtr(hpaFolderPairs, FolderPairSortCmp, pfpNew2, &ai2))
               {
                  ASSERT(IS_VALID_STRUCT_PTR(pfpNew1, CFOLDERPAIR));
                  ASSERT(IS_VALID_STRUCT_PTR(pfpNew2, CFOLDERPAIR));

                  if (ApplyNewFolderTwinsToTwinFamilies(pfpNew1))
                  {
                     *ppfp = pfpNew1;
                     bResult = TRUE;
                  }
                  else
                  {
                     DeletePtr(hpaFolderPairs, ai2);

CREATEFOLDERPAIR_BAIL1:
                     DeletePtr(hpaFolderPairs, ai1);

CREATEFOLDERPAIR_BAIL2:
                     /*
                      * Don't try to remove pfpNew2 from the global list of
                      * folder pairs here since it was never added
                      * successfully.
                      */
                     DestroyHalfOfFolderPair(pfpNew2);

CREATEFOLDERPAIR_BAIL3:
                     /*
                      * Don't try to remove pfpNew1 from the global list of
                      * folder pairs here since it was never added
                      * successfully.
                      */
                     DestroyHalfOfFolderPair(pfpNew1);

CREATEFOLDERPAIR_BAIL4:
                     DestroySharedFolderPairData(pfpd);
                  }
               }
               else
                  goto CREATEFOLDERPAIR_BAIL1;
            }
            else
               goto CREATEFOLDERPAIR_BAIL2;
         }
         else
            goto CREATEFOLDERPAIR_BAIL3;
      }
      else
         goto CREATEFOLDERPAIR_BAIL4;
   }

   return(bResult);
}


/*
** CreateHalfOfFolderPair()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreateHalfOfFolderPair(HPATH hpathFolder, HBRFCASE hbr,
                                    PFOLDERPAIR *ppfp)
{
   BOOL bResult = FALSE;
   PFOLDERPAIR pfpNew;

   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_WRITE_PTR(ppfp, PFOLDERPAIR));

   /* Try to create a new FOLDERPAIR structure. */

   if (AllocateMemory(sizeof(*pfpNew), &pfpNew))
   {
      /* Try to add the folder string to the folder string table. */

      if (CopyPath(hpathFolder, GetBriefcasePathList(hbr), &(pfpNew->hpath)))
      {
         /* Fill in the fields of the new FOLDERPAIR structure. */

         InitStub(&(pfpNew->stub), ST_FOLDERPAIR);

         *ppfp = pfpNew;
         bResult = TRUE;
      }
      else
         FreeMemory(pfpNew);
   }

   return(bResult);
}


/*
** DestroyHalfOfFolderPair()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyHalfOfFolderPair(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   TRACE_OUT((TEXT("DestroyHalfOfFolderPair(): Destroying folder twin %s."),
              DebugGetPathString(pfp->hpath)));

   /* Has the other half of this folder pair already been destroyed? */

   if (IsStubFlagClear(&(pfp->stub), STUB_FL_BEING_DELETED))
      /* No.  Indicate that this half has already been deleted. */
      SetStubFlag(&(pfp->pfpOther->stub), STUB_FL_BEING_DELETED);

   /* Destroy FOLDERPAIR fields. */

   DeletePath(pfp->hpath);
   FreeMemory(pfp);

   return;
}


/*
** CreateSharedFolderPairData()
**
** Creates a shared folder pair data structure.
**
** Arguments:     pcinft - pointer to INEWFOLDERTWIN describing folder pair
**                          being created
**
** Returns:       Pointer to new folder pair data structure if successful.
**                NULL if unsuccessful.
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreateSharedFolderPairData(PCINEWFOLDERTWIN pcinft,
                                        PFOLDERPAIRDATA *ppfpd)
{
   PFOLDERPAIRDATA pfpd;

   ASSERT(IS_VALID_STRUCT_PTR(pcinft, CINEWFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppfpd, PFOLDERPAIRDATA));

   /* Try to allocate a new shared folder pair data data structure. */

   *ppfpd = NULL;

   if (AllocateMemory(sizeof(*pfpd), &pfpd))
   {
      /* Fill in the FOLDERPAIRDATA structure fields. */

      LockString(pcinft->hsName);
      pfpd->hsName = pcinft->hsName;

      pfpd->dwAttributes = pcinft->dwAttributes;
      pfpd->hbr = pcinft->hbr;

      ASSERT(! IS_ATTR_DIR(pfpd->dwAttributes));

      CLEAR_FLAG(pfpd->dwAttributes, FILE_ATTRIBUTE_DIRECTORY);

      *ppfpd = pfpd;

      ASSERT(IS_VALID_STRUCT_PTR(*ppfpd, CFOLDERPAIRDATA));
   }

   return(*ppfpd != NULL);
}


/*
** DestroySharedFolderPairData()
**
** Destroys shared folder pair data.
**
** Arguments:     pfpd - pointer to shared folder pair data to destroy
**
** Returns:       void
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroySharedFolderPairData(PFOLDERPAIRDATA pfpd)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfpd, CFOLDERPAIRDATA));

   /* Destroy FOLDERPAIRDATA fields. */

   DeleteString(pfpd->hsName);
   FreeMemory(pfpd);

   return;
}


/*
** FolderPairSortCmp()
**
** Pointer comparison function used to sort the global array of folder pairs.
**
** Arguments:     pcfp1 - pointer to FOLDERPAIR describing first folder pair
**                pcfp2 - pointer to FOLDERPAIR describing second folder pair
**
** Returns:
**
** Side Effects:  none
**
** Folder pairs are sorted by:
**    1) path
**    2) pointer value
*/
PRIVATE_CODE COMPARISONRESULT FolderPairSortCmp(PCVOID pcfp1, PCVOID pcfp2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp1, CFOLDERPAIR));
   ASSERT(IS_VALID_STRUCT_PTR(pcfp2, CFOLDERPAIR));

   cr = ComparePaths(((PCFOLDERPAIR)pcfp1)->hpath,
                     ((PCFOLDERPAIR)pcfp2)->hpath);

   if (cr == CR_EQUAL)
      cr = ComparePointers(pcfp1, pcfp2);

   return(cr);
}


/*
** FolderPairSearchCmp()
**
** Pointer comparison function used to search the global array of folder pairs
** for the first folder pair for a given folder.
**
** Arguments:     hpath - folder pair to search for
**                pcfp - pointer to FOLDERPAIR to examine
**
** Returns:
**
** Side Effects:  none
**
** Folder pairs are searched by:
**    1) path
*/
PRIVATE_CODE COMPARISONRESULT FolderPairSearchCmp(PCVOID hpath, PCVOID pcfp)
{
   ASSERT(IS_VALID_HANDLE((HPATH)hpath, PATH));
   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));

   return(ComparePaths((HPATH)hpath, ((PCFOLDERPAIR)pcfp)->hpath));
}


/*
** RemoveSourceFolderTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/

#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL RemoveSourceFolderTwin(POBJECTTWIN pot, PVOID pv)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pv);

   if (EVAL(pot->ulcSrcFolderTwins > 0))
      pot->ulcSrcFolderTwins--;

   /*
    * If there are no more source folder twins for this object twin, and this
    * object twin is not a separate "orphan" object twin, wipe it out.
    */

   if (! pot->ulcSrcFolderTwins &&
       IsStubFlagClear(&(pot->stub), STUB_FL_FROM_OBJECT_TWIN))
      EVAL(DestroyStub(&(pot->stub)) == TR_SUCCESS);

   return(TRUE);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** UnlinkHalfOfFolderPair()
**
** Unlinks one half of a pair of folder twins.
**
** Arguments:     pfp - pointer to folder pair half to unlink
**
** Returns:       void
**
** Side Effects:  Removes a source folder twin from each of the object twin's
**                in the folder pair's list of generated object twins.  May
**                cause object twins and twin families to be destroyed.
*/
PRIVATE_CODE void UnlinkHalfOfFolderPair(PFOLDERPAIR pfp)
{
   HPTRARRAY hpaFolderPairs;
   ARRAYINDEX aiUnlink;

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   TRACE_OUT((TEXT("UnlinkHalfOfFolderPair(): Unlinking folder twin %s."),
              DebugGetPathString(pfp->hpath)));

   /* Search for the folder pair to be unlinked. */

   hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pfp->pfpd->hbr);

   if (EVAL(SearchSortedArray(hpaFolderPairs, &FolderPairSortCmp, pfp,
                              &aiUnlink)))
   {
      /* Unlink folder pair. */

      ASSERT(GetPtr(hpaFolderPairs, aiUnlink) == pfp);

      DeletePtr(hpaFolderPairs, aiUnlink);

      /*
       * Don't mark folder pair stub unlinked here.  Let caller do that after
       * both folder pair halves have been unlinked.
       */

      /* Remove a source folder twin from all generated object twins. */

      EVAL(EnumGeneratedObjectTwins(pfp, &RemoveSourceFolderTwin, NULL));
   }

   return;
}


/*
** FolderTwinIntersectsFolder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FolderTwinIntersectsFolder(PCFOLDERPAIR pcfp, HPATH hpathFolder)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));

   if (IsStubFlagSet(&(pcfp->stub), STUB_FL_SUBTREE))
      bResult = IsPathPrefix(hpathFolder, pcfp->hpath);
   else
      bResult = (ComparePaths(hpathFolder, pcfp->hpath) == CR_EQUAL);

   return(bResult);
}


/*
** CreateListOfFolderTwins()
**
** Creates a list of folder twins from a block of folder pairs.
**
** Arguments:     aiFirst - index of first folder pair in the array of folder
**                          pairs
**                hpathFolder - folder that list of folder twins is to be
**                              created for
**                ppftHead - pointer to PFOLDERTWIN to be filled in with
**                           pointer to first folder twin in new list
**                paic - pointer to ARRAYINDEX to be filled in with number of
**                       folder twins in new list
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT CreateListOfFolderTwins(HBRFCASE hbr, ARRAYINDEX aiFirst,
                                           HPATH hpathFolder,
                                           PFOLDERTWIN *ppftHead,
                                           PARRAYINDEX paic)
{
   TWINRESULT tr;
   PFOLDERPAIR pfp;
   HPATH hpath;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;
   PFOLDERTWIN pftHead;
   HPTRARRAY hpaFolderTwins;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_WRITE_PTR(ppftHead, PFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(paic, ARRAYINDEX));

   /*
    * Get the handle to the common folder that the list of folder twins is
    * being prepared for.
    */

   hpaFolderTwins = GetBriefcaseFolderPairPtrArray(hbr);

   pfp = GetPtr(hpaFolderTwins, aiFirst);

   hpath = pfp->hpath;

   /*
    * Add the other half of each matching folder pair to the folder twin list
    * as a folder twin.
    */

   aicPtrs = GetPtrCount(hpaFolderTwins);
   ASSERT(aicPtrs > 0);
   ASSERT(! (aicPtrs % 2));
   ASSERT(aiFirst >= 0);
   ASSERT(aiFirst < aicPtrs);

   /* Start with an empty list of folder twins. */

   pftHead = NULL;

   /*
    * A pointer to the first folder pair is already in pfp, but we'll look it
    * up again.
    */

   TRACE_OUT((TEXT("CreateListOfFolderTwins(): Creating list of folder twins of folder %s."),
              DebugGetPathString(hpath)));

   tr = TR_SUCCESS;

   for (ai = aiFirst; ai < aicPtrs && tr == TR_SUCCESS; ai++)
   {
      pfp = GetPtr(hpaFolderTwins, ai);

      if (ComparePaths(pfp->hpath, hpathFolder) == CR_EQUAL)
         tr = AddFolderTwinToList(pfp, pftHead, &pftHead);
      else
         break;
   }

   TRACE_OUT((TEXT("CreateListOfFolderTwins(): Finished creating list of folder twins of folder %s."),
              DebugGetPathString(hpath)));

   if (tr == TR_SUCCESS)
   {
      /* Success!  Fill in the result parameters. */

      *ppftHead = pftHead;
      *paic = ai - aiFirst;
   }
   else
      /* Free any folder twins that have been added to the list. */
      DestroyListOfFolderTwins(pftHead);

   return(tr);
}


/*
** DestroyListOfFolderTwins()
**
** Wipes out the folder twins in a folder twin list.
**
** Arguments:     pftHead - pointer to first folder twin in list
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyListOfFolderTwins(PFOLDERTWIN pftHead)
{
   while (pftHead)
   {
      PFOLDERTWIN pftOldHead;

      ASSERT(IS_VALID_STRUCT_PTR(pftHead, CFOLDERTWIN));

      UnlockStub(&(((PFOLDERPAIR)(pftHead->hftSrc))->stub));
      UnlockStub(&(((PFOLDERPAIR)(pftHead->hftOther))->stub));

      pftOldHead = pftHead;
      pftHead = (PFOLDERTWIN)(pftHead->pcftNext);

      FreeMemory((LPTSTR)(pftOldHead->pcszSrcFolder));
      FreeMemory((LPTSTR)(pftOldHead->pcszOtherFolder));

      FreeMemory(pftOldHead);
   }

   return;
}


/*
** AddFolderTwinToList()
**
** Adds a folder twin to a list of folder twins.
**
** Arguments:     pfpSrc - pointer to source folder pair to be added
**                pftHead - pointer to head of folder twin list, may be NULL
**                ppft - pointer to PFOLDERTWIN to be filled in with pointer
**                         to new folder twin, ppft may be &pftHead
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT AddFolderTwinToList(PFOLDERPAIR pfpSrc,
                                            PFOLDERTWIN pftHead,
                                            PFOLDERTWIN *ppft)
{
   TWINRESULT tr = TR_OUT_OF_MEMORY;
   PFOLDERTWIN pftNew;

   ASSERT(IS_VALID_STRUCT_PTR(pfpSrc, CFOLDERPAIR));
   ASSERT(! pftHead || IS_VALID_STRUCT_PTR(pftHead, CFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppft, PFOLDERTWIN));

   /* Try to create a new FOLDERTWIN structure. */

   if (AllocateMemory(sizeof(*pftNew), &pftNew))
   {
      LPTSTR pszFirstFolder;

      if (AllocatePathString(pfpSrc->hpath, &pszFirstFolder))
      {
         LPTSTR pszSecondFolder;

         if (AllocatePathString(pfpSrc->pfpOther->hpath, &pszSecondFolder))
         {
            /* Fill in FOLDERTWIN structure fields. */

            pftNew->pcftNext = pftHead;
            pftNew->hftSrc = (HFOLDERTWIN)pfpSrc;
            pftNew->hvidSrc = (HVOLUMEID)(pfpSrc->hpath);
            pftNew->pcszSrcFolder = pszFirstFolder;
            pftNew->hftOther = (HFOLDERTWIN)(pfpSrc->pfpOther);
            pftNew->hvidOther = (HVOLUMEID)(pfpSrc->pfpOther->hpath);
            pftNew->pcszOtherFolder = pszSecondFolder;
            pftNew->pcszName = GetString(pfpSrc->pfpd->hsName);

            pftNew->dwFlags = 0;

            if (IsStubFlagSet(&(pfpSrc->stub), STUB_FL_SUBTREE))
               pftNew->dwFlags = FT_FL_SUBTREE;

            LockStub(&(pfpSrc->stub));
            LockStub(&(pfpSrc->pfpOther->stub));

            *ppft = pftNew;
            tr = TR_SUCCESS;

            TRACE_OUT((TEXT("AddFolderTwinToList(): Added folder twin %s of folder %s matching objects %s."),
                       pftNew->pcszSrcFolder,
                       pftNew->pcszOtherFolder,
                       pftNew->pcszName));
         }
         else
         {
            FreeMemory(pszFirstFolder);
ADDFOLDERTWINTOLIST_BAIL:
            FreeMemory(pftNew);
         }
      }
      else
         goto ADDFOLDERTWINTOLIST_BAIL;
   }

   ASSERT(tr != TR_SUCCESS ||
          IS_VALID_STRUCT_PTR(*ppft, CFOLDERTWIN));

   return(tr);
}


/*
** TransplantFolderPair()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT TransplantFolderPair(PFOLDERPAIR pfp,
                                             HPATH hpathOldFolder,
                                             HPATH hpathNewFolder)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
   ASSERT(IS_VALID_HANDLE(hpathOldFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hpathNewFolder, PATH));

   /* Is this folder pair rooted in the renamed folder's subtree? */

   if (IsPathPrefix(pfp->hpath, hpathOldFolder))
   {
      TCHAR rgchPathSuffix[MAX_PATH_LEN];
      LPCTSTR pcszSubPath;
      HPATH hpathNew;

      /* Yes.  Change the folder pair's root. */

      pcszSubPath = FindChildPathSuffix(hpathOldFolder, pfp->hpath,
                                        rgchPathSuffix);

      if (AddChildPath(GetBriefcasePathList(pfp->pfpd->hbr), hpathNewFolder,
                       pcszSubPath, &hpathNew))
      {
         if (IsStubFlagSet(&(pfp->stub), STUB_FL_SUBTREE))
         {
            ASSERT(IsStubFlagSet(&(pfp->pfpOther->stub), STUB_FL_SUBTREE));

            BeginTranslateFolder(pfp);

            tr = CheckForSubtreeCycles(
                     GetBriefcaseFolderPairPtrArray(pfp->pfpd->hbr), hpathNew,
                     pfp->pfpOther->hpath, pfp->pfpd->hsName);

            EndTranslateFolder(pfp);
         }
         else
            tr = TR_SUCCESS;

         if (tr == TR_SUCCESS)
         {
            TRACE_OUT((TEXT("TransplantFolderPair(): Transplanted folder twin %s to %s."),
                       DebugGetPathString(pfp->hpath),
                       DebugGetPathString(hpathNew)));

            DeletePath(pfp->hpath);
            pfp->hpath = hpathNew;
         }
         else
            DeletePath(hpathNew);
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TR_SUCCESS;

   return(tr);
}


/*
** WriteFolderPair()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT WriteFolderPair(HCACHEDFILE hcf, PFOLDERPAIR pfp)
{
   TWINRESULT tr;
   DBFOLDERTWIN dbft;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   /* Set up folder pair database structure. */

   dbft.dwStubFlags = (pfp->stub.dwFlags & DB_STUB_FLAGS_MASK);
   dbft.hpath1 = pfp->hpath;
   dbft.hpath2 = pfp->pfpOther->hpath;
   dbft.hsName = pfp->pfpd->hsName;
   dbft.dwAttributes = pfp->pfpd->dwAttributes;

   /* Save folder pair database structure. */

   if (WriteToCachedFile(hcf, (PCVOID)&dbft, sizeof(dbft), NULL))
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


/*
** ReadFolderPair()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT ReadFolderPair(HCACHEDFILE hcf, HBRFCASE hbr,
                                  HHANDLETRANS hhtFolderTrans,
                                  HHANDLETRANS hhtNameTrans)
{
   TWINRESULT tr = TR_CORRUPT_BRIEFCASE;
   DBFOLDERTWIN dbft;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtNameTrans, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &dbft, sizeof(dbft), &dwcbRead) &&
       dwcbRead == sizeof(dbft))
   {
      INEWFOLDERTWIN inft;

      if (TranslateHandle(hhtFolderTrans, (HGENERIC)(dbft.hpath1), (PHGENERIC)&(inft.hpathFirst)))
      {
         if (TranslateHandle(hhtFolderTrans, (HGENERIC)(dbft.hpath2), (PHGENERIC)&(inft.hpathSecond)))
         {
            if (TranslateHandle(hhtNameTrans, (HGENERIC)(dbft.hsName), (PHGENERIC)&(inft.hsName)))
            {
               PFOLDERPAIR pfp;

               inft.dwAttributes = dbft.dwAttributes;
               inft.hbr = hbr;

               if (IS_FLAG_SET(dbft.dwStubFlags, STUB_FL_SUBTREE))
                  inft.dwFlags = NFT_FL_SUBTREE;
               else
                  inft.dwFlags = 0;

               if (CreateFolderPair(&inft, &pfp))
                  tr = TR_SUCCESS;
               else
                  tr = TR_OUT_OF_MEMORY;
            }
         }
      }
   }

   return(tr);
}


#ifdef VSTF

/*
** IsValidPCNEWFOLDERTWIN()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCNEWFOLDERTWIN(PCNEWFOLDERTWIN pcnft)
{
   return(IS_VALID_READ_PTR(pcnft, CNEWFOLDERTWIN) &&
          EVAL(pcnft->ulSize == sizeof(*pcnft)) &&
          IS_VALID_STRING_PTR(pcnft->pcszFolder1, CSTR) &&
          IS_VALID_STRING_PTR(pcnft->pcszFolder2, CSTR) &&
          IS_VALID_STRING_PTR(pcnft->pcszName, CSTR) &&
          FLAGS_ARE_VALID(pcnft->dwAttributes, ALL_FILE_ATTRIBUTES) &&
          FLAGS_ARE_VALID(pcnft->dwFlags, ALL_NFT_FLAGS));
}


/*
** IsValidPCFOLDERTWINLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCFOLDERTWINLIST(PCFOLDERTWINLIST pcftl)
{
   BOOL bResult = FALSE;

   if (IS_VALID_READ_PTR(pcftl, CFOLDERTWINLIST) &&
       IS_VALID_HANDLE(pcftl->hbr, BRFCASE))
   {
      PCFOLDERTWIN pcft;
      ULONG ulcFolderTwins = 0;

      for (pcft = pcftl->pcftFirst;
           pcft && IS_VALID_STRUCT_PTR(pcft, CFOLDERTWIN);
           pcft = pcft->pcftNext)
      {
         ASSERT(ulcFolderTwins < ULONG_MAX);
         ulcFolderTwins++;
      }

      if (! pcft && EVAL(ulcFolderTwins == pcftl->ulcItems))
         bResult = TRUE;
   }

   return(bResult);
}


/*
** IsValidPCFOLDERTWIN()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCFOLDERTWIN(PCFOLDERTWIN pcft)
{
   /* dwUser may be any value. */

   return(IS_VALID_READ_PTR(pcft, CFOLDERTWIN) &&
          IS_VALID_HANDLE(pcft->hftSrc, FOLDERTWIN) &&
          IS_VALID_HANDLE(pcft->hvidSrc, VOLUMEID) &&
          IS_VALID_STRING_PTR(pcft->pcszSrcFolder, CSTR) &&
          IS_VALID_HANDLE(pcft->hftOther, FOLDERTWIN) &&
          IS_VALID_HANDLE(pcft->hvidOther, VOLUMEID) &&
          IS_VALID_STRING_PTR(pcft->pcszOtherFolder, CSTR) &&
          IS_VALID_STRING_PTR(pcft->pcszName, CSTR) &&
          FLAGS_ARE_VALID(pcft->dwFlags, ALL_FT_FLAGS));
}


/*
** IsValidFolderPairHalf()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidFolderPairHalf(PCFOLDERPAIR pcfp)
{
   return(IS_VALID_READ_PTR(pcfp, CFOLDERPAIR) &&
          IS_VALID_STRUCT_PTR(&(pcfp->stub), CSTUB) &&
          FLAGS_ARE_VALID(GetStubFlags(&(pcfp->stub)), ALL_FOLDER_TWIN_FLAGS) &&
          IS_VALID_HANDLE(pcfp->hpath, PATH) &&
          IS_VALID_STRUCT_PTR(pcfp->pfpd, CFOLDERPAIRDATA) &&
          (IsStubFlagSet(&(pcfp->stub), STUB_FL_BEING_DELETED) ||
           IS_VALID_READ_PTR(pcfp->pfpOther, CFOLDERPAIR)));
}


/*
** IsValidPCFOLDERPAIRDATA()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCFOLDERPAIRDATA(PCFOLDERPAIRDATA pcfpd)
{
   /* Don't validate hbr. */

   return(IS_VALID_READ_PTR(pcfpd, CFOLDERPAIRDATA) &&
          IS_VALID_HANDLE(pcfpd->hsName, STRING));
}

#endif


#ifdef DEBUG

/*
** IsValidPCINEWFOLDERTWIN()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCINEWFOLDERTWIN(PCINEWFOLDERTWIN pcinft)
{
   return(IS_VALID_READ_PTR(pcinft, CINEWFOLDERTWIN) &&
          IS_VALID_HANDLE(pcinft->hpathFirst, PATH) &&
          IS_VALID_HANDLE(pcinft->hpathSecond, PATH) &&
          IS_VALID_HANDLE(pcinft->hsName, STRING) &&
          FLAGS_ARE_VALID(pcinft->dwAttributes, ALL_FILE_ATTRIBUTES) &&
          FLAGS_ARE_VALID(pcinft->dwFlags, ALL_NFT_FLAGS) &&
          IS_VALID_HANDLE(pcinft->hbr, BRFCASE));
}


/*
** AreFolderPairsValid()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL AreFolderPairsValid(HPTRARRAY hpaFolderPairs)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpaFolderPairs, PTRARRAY));

   aicPtrs = GetPtrCount(hpaFolderPairs);
   ASSERT(! (aicPtrs % 2));

   for (ai = 0;
        ai < aicPtrs && IS_VALID_STRUCT_PTR(GetPtr(hpaFolderPairs, ai), CFOLDERPAIR);
        ai++)
      ;

   return(ai == aicPtrs);
}

#endif


/****************************** Public Functions *****************************/


/*
** CreateFolderPairPtrArray()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreateFolderPairPtrArray(PHPTRARRAY phpa)
{
   NEWPTRARRAY npa;

   ASSERT(IS_VALID_WRITE_PTR(phpa, HPTRARRAY));

   /* Try to create a folder pair pointer array. */

   npa.aicInitialPtrs = NUM_START_FOLDER_TWIN_PTRS;
   npa.aicAllocGranularity = NUM_FOLDER_TWIN_PTRS_TO_ADD;
   npa.dwFlags = NPA_FL_SORTED_ADD;

   return(CreatePtrArray(&npa, phpa));
}


/*
** DestroyFolderPairPtrArray()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyFolderPairPtrArray(HPTRARRAY hpa)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   /* Free all folder pairs in pointer array. */

   aicPtrs = GetPtrCount(hpa);
   ASSERT(! (aicPtrs % 2));

   for (ai = 0; ai < aicPtrs; ai++)
   {
      PFOLDERPAIR pfp;
      PFOLDERPAIR pfpOther;
      PFOLDERPAIRDATA pfpd;
      BOOL bDeleteFolderPairData;

      pfp = GetPtr(hpa, ai);

      ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

      /* Copy fields needed after folder pair half's demise. */

      pfpOther = pfp->pfpOther;
      pfpd = pfp->pfpd;
      bDeleteFolderPairData = IsStubFlagSet(&(pfp->stub), STUB_FL_BEING_DELETED);

      DestroyHalfOfFolderPair(pfp);

      /* Has the other half of this folder pair already been destroyed? */

      if (bDeleteFolderPairData)
         /* Yes.  Destroy the pair's shared data. */
         DestroySharedFolderPairData(pfpd);
   }

   /* Now wipe out the pointer array. */

   DestroyPtrArray(hpa);

   return;
}


/*
** LockFolderPair()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void LockFolderPair(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_UNLINKED));
   ASSERT(IsStubFlagClear(&(pfp->pfpOther->stub), STUB_FL_UNLINKED));

   ASSERT(pfp->stub.ulcLock < ULONG_MAX);
   pfp->stub.ulcLock++;

   ASSERT(pfp->pfpOther->stub.ulcLock < ULONG_MAX);
   pfp->pfpOther->stub.ulcLock++;

   return;
}


/*
** UnlockFolderPair()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void UnlockFolderPair(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   if (EVAL(pfp->stub.ulcLock > 0))
      pfp->stub.ulcLock--;

   if (EVAL(pfp->pfpOther->stub.ulcLock > 0))
      pfp->pfpOther->stub.ulcLock--;

   if (! pfp->stub.ulcLock &&
       IsStubFlagSet(&(pfp->stub), STUB_FL_UNLINKED))
   {
      ASSERT(! pfp->pfpOther->stub.ulcLock);
      ASSERT(IsStubFlagSet(&(pfp->pfpOther->stub), STUB_FL_UNLINKED));

      DestroyFolderPair(pfp);
   }

   return;
}


/*
** UnlinkFolderPair()
**
** Unlinks a folder pair.
**
** Arguments:     pfp - pointer to folder pair to be unlinked
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT UnlinkFolderPair(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_UNLINKED));
   ASSERT(IsStubFlagClear(&(pfp->pfpOther->stub), STUB_FL_UNLINKED));

   /* Unlink both halves of the folder pair. */

   UnlinkHalfOfFolderPair(pfp);
   UnlinkHalfOfFolderPair(pfp->pfpOther);

   SetStubFlag(&(pfp->stub), STUB_FL_UNLINKED);
   SetStubFlag(&(pfp->pfpOther->stub), STUB_FL_UNLINKED);

   return(TR_SUCCESS);
}


/*
** DestroyFolderPair()
**
** Destroys a folder pair.
**
** Arguments:     pfp - pointer to folder pair to destroy
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyFolderPair(PFOLDERPAIR pfp)
{
   PFOLDERPAIRDATA pfpd;

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   /* Destroy both FOLDERPAIR halves, and shared data. */

   pfpd = pfp->pfpd;

   DestroyHalfOfFolderPair(pfp->pfpOther);
   DestroyHalfOfFolderPair(pfp);

   DestroySharedFolderPairData(pfpd);

   return;
}


/*
** MyTranslateFolder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT MyTranslateFolder(HBRFCASE hbr, HPATH hpathOld,
                                         HPATH hpathNew)
{
   TWINRESULT tr = TR_SUCCESS;
   HPTRARRAY hpaFolderPairs;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hpathOld, PATH));
   ASSERT(IS_VALID_HANDLE(hpathNew, PATH));

   /*
    * Change folders of all folder pairs rooted in pcszOldFolder's subtree to
    * being rooted in pcszNewFolder's subtree.
    */

   hpaFolderPairs = GetBriefcaseFolderPairPtrArray(hbr);
   aicPtrs = GetPtrCount(hpaFolderPairs);
   ASSERT(! (aicPtrs % 2));

   for (ai = 0; ai < aicPtrs; ai++)
   {
      tr = TransplantFolderPair(GetPtr(hpaFolderPairs, ai), hpathOld,
                                hpathNew);

      if (tr != TR_SUCCESS)
         break;
   }

   if (tr == TR_SUCCESS)
   {
      HPTRARRAY hpaTwinFamilies;

      /* Restore folder pair array to sorted order. */

      SortPtrArray(hpaFolderPairs, &FolderPairSortCmp);

      TRACE_OUT((TEXT("MyTranslateFolder(): Sorted folder pair array after folder translation.")));

      /*
       * Change folders of all object twins in pcszOldFolder's old subtree to
       * being in pcszNewFolder's subtree.
       */

      hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(hbr);

      aicPtrs = GetPtrCount(hpaTwinFamilies);

      for (ai = 0; ai < aicPtrs; ai++)
      {
         PTWINFAMILY ptf;
         BOOL bContinue;
         HNODE hnode;

         ptf = GetPtr(hpaTwinFamilies, ai);

         ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

         /*
          * Walk each twin family's list of object twins looking for object
          * twins in the translated folder's subtree.
          */

         for (bContinue = GetFirstNode(ptf->hlistObjectTwins, &hnode);
              bContinue;
              bContinue = GetNextNode(hnode, &hnode))
         {
            POBJECTTWIN pot;

            pot = (POBJECTTWIN)GetNodeData(hnode);

            tr = TransplantObjectTwin(pot, hpathOld, hpathNew);

            if (tr != TR_SUCCESS)
               break;
         }

         if (tr != TR_SUCCESS)
            break;
      }

      /* Twin family array is still in sorted order. */
   }

   return(tr);
}


/*
** ApplyNewObjectTwinsToFolderTwins()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  Adds new spin-off object twins to hlistNewObjectTwins as they
**                are created.
**
** N.b., new object twins may have been added to hlistNewObjectTwins even if
** FALSE is returned.  Clean-up of these new object twins in case of failure is
** the caller's responsibility.
**
** A new object twin may generate more new object twins, implied by existing
** folder twins.  E.g., consider the following scenario:
**
** 1) Folder twins (c:\, d:\, *.*) and (d:\, e:\, *.*) exist.
** 2) Files c:\foo, d:\foo, and e:\foo do not exist.
** 3) File e:\foo is created.
** 4) New object twin e:\foo is added.
** 5) d:\foo must be added as a new object twin from the e:\foo object twin
**    because of the (d:\, e:\, *.*) folder twin.
** 6) c:\foo must be added as a new object twin from the d:\foo object twin
**    because of the (c:\, d:\, *.*) folder twin.
**
** So we see that new object twin e:\foo must generate two more new object
** twins, d:\foo and c:\foo, implied by the two existing folder twins,
** (c:\, d:\, *.*) and (d:\, e:\, *.*).
*/
PUBLIC_CODE BOOL ApplyNewObjectTwinsToFolderTwins(HLIST hlistNewObjectTwins)
{
   BOOL bResult = TRUE;
   BOOL bContinue;
   HNODE hnode;

   ASSERT(IS_VALID_HANDLE(hlistNewObjectTwins, LIST));

   /*
    * Don't use WalkList() here because we want to insert new nodes in
    * hlistNewObjectTwins after the current node.
    */

   for (bContinue = GetFirstNode(hlistNewObjectTwins, &hnode);
        bContinue && bResult;
        bContinue = GetNextNode(hnode, &hnode))
   {
      POBJECTTWIN pot;
      HPATHLIST hpl;
      HPTRARRAY hpaFolderPairs;
      ARRAYINDEX aicPtrs;
      ARRAYINDEX ai;

      pot = GetNodeData(hnode);

      ASSERT(! pot->ulcSrcFolderTwins);

      TRACE_OUT((TEXT("ApplyNewObjectTwinsToFolderTwins(): Applying new object twin %s\\%s."),
                 DebugGetPathString(pot->hpath),
                 GetString(pot->ptfParent->hsName)));

      /*
       * Assume that hpl, hpaFolderPairs, and aicPtrs don't change during this
       * loop.  Calculate them outside the loop.
       */

      hpl = GetBriefcasePathList(pot->ptfParent->hbr);
      hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pot->ptfParent->hbr);

      aicPtrs = GetPtrCount(hpaFolderPairs);
      ASSERT(! (aicPtrs % 2));

      for (ai = 0; ai < aicPtrs; ai++)
      {
         PFOLDERPAIR pfp;

         pfp = GetPtr(hpaFolderPairs, ai);

         if (FolderTwinGeneratesObjectTwin(pfp, pot->hpath,
                                           GetString(pot->ptfParent->hsName)))
         {
            HPATH hpathMatchingFolder;
            HNODE hnodeUnused;

            ASSERT(pot->ulcSrcFolderTwins < ULONG_MAX);
            pot->ulcSrcFolderTwins++;

            /*
             * Append the generated object twin's subpath to the matching
             * folder twin's base path for subtree twins.
             */

            if (BuildPathForMatchingObjectTwin(pfp, pot, hpl,
                                               &hpathMatchingFolder))
            {
               /*
                * We don't want to collapse any twin families if the matching
                * object twin is found in a different twin family.  This will
                * be done by ApplyNewFolderTwinsToTwinFamilies() for spin-off
                * object twins generated by new folder twins.
                *
                * Spin-off object twins created by new object twins never
                * require collapsing twin families.  For a spin-off object twin
                * generated by a new object twin to collapse twin families,
                * there would have to have been separate twin families
                * connected by a folder twin.  But if those twin families were
                * already connected by a folder twin, they would not be
                * separate because they would already have been collapsed by
                * ApplyNewFolderTwinsToTwinFamilies() when the connecting
                * folder twin was added.
                */

               if (! FindObjectTwin(pot->ptfParent->hbr, hpathMatchingFolder,
                                    GetString(pot->ptfParent->hsName),
                                    &hnodeUnused))
               {
                  POBJECTTWIN potNew;

                  /*
                   * CreateObjectTwin() ASSERT()s that an object twin for
                   * hpathMatchingFolder is not found, so we don't need to do
                   * that here.
                   */

                  if (CreateObjectTwin(pot->ptfParent, hpathMatchingFolder,
                                       &potNew))
                  {
                     /*
                      * Add the new object twin to hlistNewObjectTwins after
                      * the new object twin currently being processed to make
                      * certain that it gets processed in the outside loop
                      * through hlistNewObjectTwins.
                      */

                     if (! InsertNodeAfter(hnode, NULL, potNew, &hnodeUnused))
                     {
                        DestroyStub(&(potNew->stub));
                        bResult = FALSE;
                        break;
                     }
                  }
               }

               DeletePath(hpathMatchingFolder);
            }
            else
            {
               bResult = FALSE;
               break;
            }
         }
      }
   }

   return(bResult);
}


/*
** BuildPathForMatchingObjectTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  Path is added to object twin's briefcase's path list.
*/
PUBLIC_CODE BOOL BuildPathForMatchingObjectTwin(PCFOLDERPAIR pcfp,
                                                PCOBJECTTWIN pcot,
                                                HPATHLIST hpl, PHPATH phpath)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));
   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
   ASSERT(IS_VALID_WRITE_PTR(phpath, HPATH));

   ASSERT(FolderTwinGeneratesObjectTwin(pcfp, pcot->hpath, GetString(pcot->ptfParent->hsName)));

   /* Is the generating folder twin a subtree twin? */

   if (IsStubFlagSet(&(pcfp->stub), STUB_FL_SUBTREE))
   {
      TCHAR rgchPathSuffix[MAX_PATH_LEN];
      LPCTSTR pcszSubPath;

      /*
       * Yes.  Append the object twin's subpath to the subtree twin's base
       * path.
       */

      pcszSubPath = FindChildPathSuffix(pcfp->hpath, pcot->hpath,
                                        rgchPathSuffix);

      bResult = AddChildPath(hpl, pcfp->pfpOther->hpath, pcszSubPath, phpath);
   }
   else
      /* No.  Just use the matching folder twin's folder. */
      bResult = CopyPath(pcfp->pfpOther->hpath, hpl, phpath);

   return(bResult);
}


/*
** EnumGeneratedObjectTwins()
**
**
**
** Arguments:
**
** Returns:       FALSE if callback aborted.  TRUE if not.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL EnumGeneratedObjectTwins(PCFOLDERPAIR pcfp,
                                     ENUMGENERATEDOBJECTTWINSPROC egotp,
                                     PVOID pvRefData)
{
   BOOL bResult = TRUE;
   HPTRARRAY hpaTwinFamilies;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   /* pvRefData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_CODE_PTR(egotp, ENUMGENERATEDOBJECTTWINPROC));

   /*
    * Walk the array of twin families, looking for twin families whose names
    * intersect the given folder twin's name specification.
    */

   hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(pcfp->pfpd->hbr);

   aicPtrs = GetPtrCount(hpaTwinFamilies);
   ai = 0;

   while (ai < aicPtrs)
   {
      PTWINFAMILY ptf;
      LPCTSTR pcszName;

      ptf = GetPtr(hpaTwinFamilies, ai);

      ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
      ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED));

      /*
       * Does the twin family's name match the folder twin's name
       * specification?
       */

      pcszName = GetString(ptf->hsName);

      if (IsFolderObjectTwinName(pcszName) ||
          NamesIntersect(pcszName, GetString(pcfp->pfpd->hsName)))
      {
         BOOL bContinue;
         HNODE hnodePrev;

         /* Yes.  Look for a matching folder. */

         /* Lock the twin family so it isn't deleted out from under us. */

         LockStub(&(ptf->stub));

         /*
          * Walk each twin family's list of object twins looking for object
          * twins in the given folder twin's subtree.
          */

         bContinue = GetFirstNode(ptf->hlistObjectTwins, &hnodePrev);

         while (bContinue)
         {
            HNODE hnodeNext;
            POBJECTTWIN pot;

            bContinue = GetNextNode(hnodePrev, &hnodeNext);

            pot = (POBJECTTWIN)GetNodeData(hnodePrev);

            ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

            if (FolderTwinIntersectsFolder(pcfp, pot->hpath))
            {
               /*
                * A given object twin should only be generated by one of the
                * folder twins in a pair of folder twins.
                */

               ASSERT(! FolderTwinGeneratesObjectTwin(pcfp->pfpOther, pot->hpath, GetString(pot->ptfParent->hsName)));

               bResult = (*egotp)(pot, pvRefData);

               if (! bResult)
                  break;
            }

            hnodePrev = hnodeNext;
         }

         /* Was the twin family unlinked? */

         if (IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED))
            /* No. */
            ai++;
         else
         {
            /* Yes. */

            aicPtrs--;
            ASSERT(aicPtrs == GetPtrCount(hpaTwinFamilies));

            TRACE_OUT((TEXT("EnumGeneratedObjectTwins(): Twin family for object %s unlinked by callback."),
                       GetString(ptf->hsName)));
         }

         UnlockStub(&(ptf->stub));

         if (! bResult)
            break;
      }
      else
         /* No.  Skip it. */
         ai++;
   }

   return(bResult);
}


/*
** EnumGeneratingFolderTwins()
**
**
**
** Arguments:
**
** Returns:       FALSE if callback aborted.  TRUE if not.
**
** Side Effects:  none
**
** N.b., if the egftp callback removes a pair of folder twins, it must remove
** the pair from the first folder twin encountered.  If it removes the pair of
** folder twins from the second folder twin encountered, a folder twin will be
** skipped.
*/
PUBLIC_CODE BOOL EnumGeneratingFolderTwins(PCOBJECTTWIN pcot,
                                           ENUMGENERATINGFOLDERTWINSPROC egftp,
                                           PVOID pvRefData,
                                           PULONG pulcGeneratingFolderTwins)
{
   BOOL bResult = TRUE;
   HPTRARRAY hpaFolderPairs;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   /* pvRefData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));
   ASSERT(IS_VALID_CODE_PTR(egftp, ENUMGENERATINGFOLDERTWINSPROC));
   ASSERT(IS_VALID_WRITE_PTR(pulcGeneratingFolderTwins, ULONG));

   *pulcGeneratingFolderTwins = 0;

   hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pcot->ptfParent->hbr);

   aicPtrs = GetPtrCount(hpaFolderPairs);
   ASSERT(! (aicPtrs % 2));

   ai = 0;

   while (ai < aicPtrs)
   {
      PFOLDERPAIR pfp;

      pfp = GetPtr(hpaFolderPairs, ai);

      if (FolderTwinGeneratesObjectTwin(pfp, pcot->hpath,
                                        GetString(pcot->ptfParent->hsName)))
      {
         ASSERT(! FolderTwinGeneratesObjectTwin(pfp->pfpOther, pcot->hpath, GetString(pcot->ptfParent->hsName)));

         ASSERT(*pulcGeneratingFolderTwins < ULONG_MAX);
         (*pulcGeneratingFolderTwins)++;

         /*
          * Lock the pair of folder twins so they don't get deleted out from
          * under us.
          */

         LockStub(&(pfp->stub));

         bResult = (*egftp)(pfp, pvRefData);

         if (IsStubFlagSet(&(pfp->stub), STUB_FL_UNLINKED))
         {
            WARNING_OUT((TEXT("EnumGeneratingFolderTwins(): Folder twin pair unlinked during callback.")));

            aicPtrs -= 2;
            ASSERT(! (aicPtrs % 2));
            ASSERT(aicPtrs == GetPtrCount(hpaFolderPairs));
         }
         else
            ai++;

         UnlockStub(&(pfp->stub));

         if (! bResult)
            break;
      }
      else
         ai++;
   }

   return(bResult);
}


/*
** FolderTwinGeneratesObjectTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** A folder twin or subtree twin is said to generate an object twin when the
** following conditions are met:
**
** 1) The folder twin or subtree twin is on the same volume as the object twin.
**
** 2) The name of the object twin (literal) intersects the objects matched by
**    the folder twin or subtree twin (literal or wildcard).
**
** 3) The folder twin's folder exactly matches the object twin's folder, or the
**    subtree twin's root folder is a path prefix of the object twin's folder.
*/
PUBLIC_CODE BOOL FolderTwinGeneratesObjectTwin(PCFOLDERPAIR pcfp,
                                               HPATH hpathFolder,
                                               LPCTSTR pcszName)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));

   return(FolderTwinIntersectsFolder(pcfp, hpathFolder) &&
          (IsFolderObjectTwinName(pcszName) ||
           NamesIntersect(pcszName, GetString(pcfp->pfpd->hsName))));
}


/*
** IsValidHFOLDERTWIN()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHFOLDERTWIN(HFOLDERTWIN hft)
{
   return(IS_VALID_STRUCT_PTR((PFOLDERPAIR)hft, CFOLDERPAIR));
}


#ifdef VSTF

/*
** IsValidPCFOLDERPAIR()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCFOLDERPAIR(PCFOLDERPAIR pcfp)
{
   BOOL bResult = FALSE;

   /* All the fields of an unlinked folder pair should be valid. */

   if (EVAL(IsValidFolderPairHalf(pcfp)))
   {
      if (IsStubFlagSet(&(pcfp->stub), STUB_FL_BEING_DELETED))
         bResult = TRUE;
      else if (EVAL(IsValidFolderPairHalf(pcfp->pfpOther)) &&
               EVAL(pcfp->pfpOther->pfpOther == pcfp) &&
               EVAL(pcfp->pfpd == pcfp->pfpOther->pfpd) &&
               EVAL(pcfp->stub.ulcLock == pcfp->pfpOther->stub.ulcLock))
      {
         BOOL bUnlinked;
         BOOL bOtherUnlinked;

         /*
          * Neither or both folder pair halves may be unlinked, but not only
          * one.
          */

         bUnlinked = IsStubFlagSet(&(pcfp->stub), STUB_FL_UNLINKED);
         bOtherUnlinked = IsStubFlagSet(&(pcfp->pfpOther->stub), STUB_FL_UNLINKED);

         if (EVAL((bUnlinked && bOtherUnlinked) ||
                  (! bUnlinked && ! bOtherUnlinked)))
            bResult = TRUE;
      }
   }

   return(bResult);
}

#endif


/*
** WriteFolderPairList()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT WriteFolderPairList(HCACHEDFILE hcf,
                                      HPTRARRAY hpaFolderPairs)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
   DWORD dwcbDBFolderTwinListHeaderOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hpaFolderPairs, PTRARRAY));

   /* Save initial file position. */

   dwcbDBFolderTwinListHeaderOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbDBFolderTwinListHeaderOffset != INVALID_SEEK_POSITION)
   {
      DBFOLDERTWINLISTHEADER dbftlh;

      /* Leave space for folder twin data header. */

      ZeroMemory(&dbftlh, sizeof(dbftlh));

      if (WriteToCachedFile(hcf, (PCVOID)&dbftlh, sizeof(dbftlh), NULL))
      {
         ARRAYINDEX aicPtrs;
         ARRAYINDEX ai;

         tr = TR_SUCCESS;

         /* Mark all folder pairs unused. */

         ClearFlagInArrayOfStubs(hpaFolderPairs, STUB_FL_USED);

         aicPtrs = GetPtrCount(hpaFolderPairs);
         ASSERT(! (aicPtrs % 2));

         /* Write all folder pairs. */

         for (ai = 0; ai < aicPtrs; ai++)
         {
            PFOLDERPAIR pfp;

            pfp = GetPtr(hpaFolderPairs, ai);

            ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

            if (IsStubFlagClear(&(pfp->stub), STUB_FL_USED))
            {
               ASSERT(IsStubFlagClear(&(pfp->pfpOther->stub), STUB_FL_USED));

               tr = WriteFolderPair(hcf, pfp);

               if (tr == TR_SUCCESS)
               {
                  SetStubFlag(&(pfp->stub), STUB_FL_USED);
                  SetStubFlag(&(pfp->pfpOther->stub), STUB_FL_USED);
               }
               else
                  break;
            }
         }

         /* Save folder twin data header. */

         if (tr == TR_SUCCESS)
         {
            ASSERT(! (aicPtrs % 2));

            dbftlh.lcFolderPairs = aicPtrs / 2;

            tr = WriteDBSegmentHeader(hcf, dwcbDBFolderTwinListHeaderOffset,
                                      &dbftlh, sizeof(dbftlh));

            if (tr == TR_SUCCESS)
               TRACE_OUT((TEXT("WriteFolderPairList(): Wrote %ld folder pairs."),
                          dbftlh.lcFolderPairs));
         }
      }
   }

   return(tr);
}


/*
** ReadFolderPairList()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT ReadFolderPairList(HCACHEDFILE hcf, HBRFCASE hbr,
                                     HHANDLETRANS hhtFolderTrans,
                                     HHANDLETRANS hhtNameTrans)
{
   TWINRESULT tr;
   DBFOLDERTWINLISTHEADER dbftlh;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtNameTrans, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &dbftlh, sizeof(dbftlh), &dwcbRead) &&
       dwcbRead == sizeof(dbftlh))
   {
      LONG l;

      tr = TR_SUCCESS;

      TRACE_OUT((TEXT("ReadFolderPairList(): Reading %ld folder pairs."),
                 dbftlh.lcFolderPairs));

      for (l = 0; l < dbftlh.lcFolderPairs && tr == TR_SUCCESS; l++)
         tr = ReadFolderPair(hcf, hbr, hhtFolderTrans, hhtNameTrans);

      ASSERT(tr != TR_SUCCESS || AreFolderPairsValid(GetBriefcaseFolderPairPtrArray(hbr)));
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


/***************************** Exported Functions ****************************/


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | AddFolderTwin | Twins two folders.

@parm HBRFCASE | hbr | A handle to the open briefcase that the new folder twins
are to be added to.

@parm PCNEWFOLDERTWIN | pcnft | A pointer to a CNEWFOLDERTWIN describing the
two folders to be twinned.

@parm PHFOLDERTWIN | phft | A pointer to an HFOLDERTWIN to be filled in with
a handle to the new folder twins.  *phft is only valid if TR_SUCCESS or
TR_DUPLICATE_TWIN is returned.

@rdesc If the folder twins were added successfully, TR_SUCCESS is returned, and
*phFolderTwin contains a handle to the new folder twins.  Otherwise, the
folder twins were not added successfully, the return value indicates the error
that occurred, and *phFolderTwin is undefined.  If one or both of the volumes
specified by the NEWFOLDERTWIN structure is not present, TR_UNAVAILABLE_VOLUME
will be returned, and the folder twin will not be added.


@comm Once the caller is finshed with the twin handle returned by
AddFolderTwin(), ReleaseTwinHandle() should be called to release the twin
handle.  N.b., DeleteTwin() does not release a twin handle returned by
AddFolderTwin().

@xref ReleaseTwinHandle DeleteTwin

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI AddFolderTwin(HBRFCASE hbr, PCNEWFOLDERTWIN pcnft,
                                           PHFOLDERTWIN phft)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(AddFolderTwin);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE) &&
          IS_VALID_STRUCT_PTR(pcnft, CNEWFOLDERTWIN) &&
          EVAL(pcnft->ulSize == sizeof(*pcnft)) &&
          IS_VALID_WRITE_PTR(phft, HFOLDERTWIN))
#endif
      {
         INEWFOLDERTWIN inft;

         InvalidatePathListInfo(GetBriefcasePathList(hbr));

         tr = MakeINewFolderTwin(hbr, pcnft, &inft);

         if (tr == TR_SUCCESS)
         {
            PFOLDERPAIR pfp;

            ASSERT(! IS_ATTR_DIR(pcnft->dwAttributes));

            tr = TwinFolders(&inft, &pfp);

            if (tr == TR_SUCCESS ||
                tr == TR_DUPLICATE_TWIN)
            {
               LockStub(&(pfp->stub));

               *phft = (HFOLDERTWIN)pfp;
            }

            ReleaseINewFolderTwin(&inft);
         }
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(AddFolderTwin, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | IsFolderTwin | Determines whether or not a folder is a
   folder twin.

@parm HBRFCASE | hbr | A handle to the open briefcase to check for the folder
twin.

@parm PCSTR | pcszFolder | A pointer to a string indicating the folder in
question.

@parm PBOOL | pbIsFolderTwin | A pointer to a BOOL to be filled in with TRUE
if the folder is a folder twin, or FALSE if not.  *pbIsFolderTwin is only
valid if TR_SUCCESS is returned.

@rdesc If the lookup was successful, TR_SUCCESS is returned.  Otherwise, the
lookup was not successful, and the return value indicates the error that
occurred.

@xref CreateFolderTwinList DestroyFolderTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI IsFolderTwin(HBRFCASE hbr, LPCTSTR pcszFolder,
                                          PBOOL pbIsFolderTwin)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(IsFolderTwin);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE) &&
          IS_VALID_STRING_PTR(pcszFolder, CSTR) &&
          IS_VALID_WRITE_PTR(pbIsFolderTwin, BOOL))
#endif
      {
         HPATH hpath;

         InvalidatePathListInfo(GetBriefcasePathList(hbr));

         tr = TranslatePATHRESULTToTWINRESULT(
               AddPath(GetBriefcasePathList(hbr), pcszFolder, &hpath));

         if (tr == TR_SUCCESS)
         {
            ARRAYINDEX aiFirst;

            /* Search for folder pair referencing given folder. */

            *pbIsFolderTwin = SearchSortedArray(
                                       GetBriefcaseFolderPairPtrArray(hbr),
                                       &FolderPairSearchCmp, hpath, &aiFirst);

            if (*pbIsFolderTwin)
               TRACE_OUT((TEXT("IsFolderTwin(): %s is a folder twin."),
                          DebugGetPathString(hpath)));
            else
               TRACE_OUT((TEXT("IsFolderTwin(): %s is not a folder twin."),
                          DebugGetPathString(hpath)));

            DeletePath(hpath);
         }
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(IsFolderTwin, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | CreateFolderTwinList | Creates a list of the folder twins of
a given folder.

@parm HBRFCASE | hbr | A handle to the open briefcase that the folder twin list
is to be created from.

@parm PCSTR | pcszFolder | A pointer to a string indicating the folder whose
folder twins are to be listed.

@parm PFOLDERTWINLIST | ppftl | A pointer to an PFOLDERTWINLIST to be
filled in with a pointer to the new list of folder twins.  *ppFolderTwinList
is only valid if TR_SUCCESS is returned.

@rdesc If the folder twin list was created successfully, TR_SUCCESS is
returned.  Otherwise, the folder twin list was not created successfully, and
the return value indicates the error that occurred.

@xref DestroyFolderTwinList IsFolderTwin

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI CreateFolderTwinList(HBRFCASE hbr,
                                                  LPCTSTR pcszFolder,
                                                  PFOLDERTWINLIST *ppftl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(CreateFolderTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE) &&
          IS_VALID_STRING_PTR(pcszFolder, CSTR) &&
          IS_VALID_WRITE_PTR(ppftl, PFOLDERTWINLIST))
#endif
      {
         HPATH hpath;

         InvalidatePathListInfo(GetBriefcasePathList(hbr));

         tr = TranslatePATHRESULTToTWINRESULT(
               AddPath(GetBriefcasePathList(hbr), pcszFolder, &hpath));

         if (tr == TR_SUCCESS)
         {
            PFOLDERTWINLIST pftlNew;

            /* Try to create a new folder twin list. */

            if (AllocateMemory(sizeof(*pftlNew), &pftlNew))
            {
               ARRAYINDEX ai;

               /* Initialize FOLDERTWINLIST structure fields. */

               pftlNew->ulcItems = 0;
               pftlNew->pcftFirst = NULL;
               pftlNew->hbr = hbr;

               /* Search for first folder pair referencing given folder. */

               if (SearchSortedArray(GetBriefcaseFolderPairPtrArray(hbr),
                                     &FolderPairSearchCmp, hpath, &ai))
               {
                  PFOLDERTWIN pftHead;
                  ARRAYINDEX aicFolderTwins;

                  tr = CreateListOfFolderTwins(hbr, ai, hpath, &pftHead, &aicFolderTwins);

                  if (tr == TR_SUCCESS)
                  {
                     /* Success!  Update parent folder twin list fields. */

                     pftlNew->pcftFirst = pftHead;
                     pftlNew->ulcItems = aicFolderTwins;
                  }
                  else
                     /* Free data structure, ignoring return value. */
                     FreeMemory(pftlNew);
               }
               else
                  tr = TR_SUCCESS;

               /* Return pointer to new FOLDERTWINLIST. */

               if (tr == TR_SUCCESS)
               {
                  *ppftl = pftlNew;

                  ASSERT(IS_VALID_STRUCT_PTR(*ppftl, CFOLDERTWINLIST));
               }
            }
            else
               tr = TR_OUT_OF_MEMORY;

            DeletePath(hpath);
         }
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(CreateFolderTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | DestroyFolderTwinList | Destroys a folder twin list created
by CreateFolderTwinList().

@parm PFOLDERTWINLIST | pftl | A pointer to the folder twin list to be
destroyed.  The FOLDERTWINLIST pointed to by pftl is not valid after
DestroyFolderTwinList() is called.

@rdesc If the folder twin list was deleted successfully, TR_SUCCESS is
returned.  Otherwise, the folder twin list was not deleted successfully, and
the return value indicates the error that occurred.

@xref CreateFolderTwinList IsFolderTwin

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI DestroyFolderTwinList(PFOLDERTWINLIST pftl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(DestroyFolderTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_STRUCT_PTR(pftl, CFOLDERTWINLIST))
#endif
      {
         DestroyListOfFolderTwins((PFOLDERTWIN)(pftl->pcftFirst));
         FreeMemory(pftl);

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(DestroyFolderTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\fcache.c ===
/*
 * fcache.c - File cache ADT module.
 */

/*

   The file cache ADT may be disabled by #defining NOFCACHE.  If NOFCACHE is
#defined, file cache ADT calls are translated into their direct Win32 file
system API equivalents.

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Constants
 ************/

/* last resort default minimum cache size */

#define DEFAULT_MIN_CACHE_SIZE      (32)


/* Types
 ********/

#ifndef NOFCACHE

/* cached file description structure */

typedef struct _icachedfile
{
   /* current position of file pointer in file */

   DWORD dwcbCurFilePosition;

   /* file handle of cached file */

   HANDLE hfile;

   /* file open mode */

   DWORD dwOpenMode;

   /* size of cache in bytes */

   DWORD dwcbCacheSize;

   /* pointer to base of cache */

   PBYTE pbyteCache;

   /* size of default cache in bytes */

   DWORD dwcbDefaultCacheSize;

   /* default cache */

   PBYTE pbyteDefaultCache;

   /* length of file (including data written to cache) */

   DWORD dwcbFileLen;

   /* offset of start of cache in file */

   DWORD dwcbFileOffsetOfCache;

   /* number of valid bytes in cache, starting at beginning of cache */

   DWORD dwcbValid;

   /* number of uncommitted bytes in cache, starting at beginning of cache */

   DWORD dwcbUncommitted;

   /* path of cached file */

   LPTSTR pszPath;
}
ICACHEDFILE;
DECLARE_STANDARD_TYPES(ICACHEDFILE);

#endif   /* NOFCACHE */


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE FCRESULT SetUpCachedFile(PCCACHEDFILE, PHCACHEDFILE);

#ifndef NOFCACHE

PRIVATE_CODE void BreakDownCachedFile(PICACHEDFILE);
PRIVATE_CODE void ResetCacheToEmpty(PICACHEDFILE);
PRIVATE_CODE DWORD ReadFromCache(PICACHEDFILE, PVOID, DWORD);
PRIVATE_CODE DWORD GetValidReadData(PICACHEDFILE, PBYTE *);
PRIVATE_CODE BOOL FillCache(PICACHEDFILE, PDWORD);
PRIVATE_CODE DWORD WriteToCache(PICACHEDFILE, PCVOID, DWORD);
PRIVATE_CODE DWORD GetAvailableWriteSpace(PICACHEDFILE, PBYTE *);
PRIVATE_CODE BOOL CommitCache(PICACHEDFILE);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCICACHEDFILE(PCICACHEDFILE);

#endif   /* VSTF */

#endif   /* NOFCACHE */

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCCACHEDFILE(PCCACHEDFILE);

#endif   /* VSTF */


/*
** SetUpCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE FCRESULT SetUpCachedFile(PCCACHEDFILE pccf, PHCACHEDFILE phcf)
{
   FCRESULT fcr;
   HANDLE hfNew;

   ASSERT(IS_VALID_STRUCT_PTR(pccf, CCACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(phcf, HCACHEDFILE));

   /* Open the file with the requested open and sharing flags. */

   hfNew = CreateFile(pccf->pcszPath, pccf->dwOpenMode, pccf->dwSharingMode,
                      pccf->psa, pccf->dwCreateMode, pccf->dwAttrsAndFlags,
                      pccf->hTemplateFile);

   if (hfNew != INVALID_HANDLE_VALUE)
   {

#ifdef NOFCACHE

      *phcf = hfNew;

      fcr = FCR_SUCCESS;

#else
      PICACHEDFILE picf;

      fcr = FCR_OUT_OF_MEMORY;

      /* Try to allocate a new cached file structure. */

      if (AllocateMemory(sizeof(*picf), &picf))
      {
         DWORD dwcbDefaultCacheSize;

         /* Allocate the default cache for the cached file. */

         if (pccf->dwcbDefaultCacheSize > 0)
            dwcbDefaultCacheSize = pccf->dwcbDefaultCacheSize;
         else
         {
            dwcbDefaultCacheSize = DEFAULT_MIN_CACHE_SIZE;

            WARNING_OUT((TEXT("SetUpCachedFile(): Using minimum cache size of %lu instead of %lu."),
                         dwcbDefaultCacheSize,
                         pccf->dwcbDefaultCacheSize));
         }

         if (AllocateMemory(dwcbDefaultCacheSize, &(picf->pbyteDefaultCache)))
         {
            if (StringCopy(pccf->pcszPath, &(picf->pszPath)))
            {
               DWORD dwcbFileLenHigh;

               picf->dwcbFileLen = GetFileSize(hfNew, &dwcbFileLenHigh);

               if (picf->dwcbFileLen != INVALID_FILE_SIZE && ! dwcbFileLenHigh)
               {
                  /* Success!  Fill in cached file structure fields. */

                  picf->hfile = hfNew;
                  picf->dwcbCurFilePosition = 0;
                  picf->dwcbCacheSize = dwcbDefaultCacheSize;
                  picf->pbyteCache = picf->pbyteDefaultCache;
                  picf->dwcbDefaultCacheSize = dwcbDefaultCacheSize;
                  picf->dwOpenMode = pccf->dwOpenMode;

                  ResetCacheToEmpty(picf);

                  *phcf = (HCACHEDFILE)picf;
                  fcr = FCR_SUCCESS;

                  ASSERT(IS_VALID_HANDLE(*phcf, CACHEDFILE));

                  TRACE_OUT((TEXT("SetUpCachedFile(): Created %lu byte default cache for file %s."),
                             picf->dwcbCacheSize,
                             picf->pszPath));
               }
               else
               {
                  fcr = FCR_OPEN_FAILED;

SETUPCACHEDFILE_BAIL1:
                  FreeMemory(picf->pbyteDefaultCache);
SETUPCACHEDFILE_BAIL2:
                  FreeMemory(picf);
SETUPCACHEDFILE_BAIL3:
                  /*
                   * Failing to close the file properly is not a failure
                   * condition here.
                   */
                  CloseHandle(hfNew);
               }
            }
            else
               goto SETUPCACHEDFILE_BAIL1;
         }
         else
            goto SETUPCACHEDFILE_BAIL2;
      }
      else
         goto SETUPCACHEDFILE_BAIL3;

#endif   /* NOFCACHE */

   }
   else
   {
      switch (GetLastError())
      {
         /* Returned when file opened by local machine. */
         case ERROR_SHARING_VIOLATION:
            fcr = FCR_FILE_LOCKED;
            break;

         default:
            fcr = FCR_OPEN_FAILED;
            break;
      }
   }

   return(fcr);
}


#ifndef NOFCACHE

/*
** BreakDownCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void BreakDownCachedFile(PICACHEDFILE picf)
{
   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));

   /* Are we using the default cache? */

   if (picf->pbyteCache != picf->pbyteDefaultCache)
      /* No.  Free the cache. */
      FreeMemory(picf->pbyteCache);

   /* Free the default cache. */

   FreeMemory(picf->pbyteDefaultCache);

   TRACE_OUT((TEXT("BreakDownCachedFile(): Destroyed cache for file %s."),
              picf->pszPath));

   FreeMemory(picf->pszPath);
   FreeMemory(picf);

   return;
}


/*
** ResetCacheToEmpty()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void ResetCacheToEmpty(PICACHEDFILE picf)
{
   /*
    * Don't fully validate *picf here since we may be called by
    * SetUpCachedFile() before *picf has been set up.
    */

   ASSERT(IS_VALID_WRITE_PTR(picf, ICACHEDFILE));

   picf->dwcbFileOffsetOfCache = picf->dwcbCurFilePosition;
   picf->dwcbValid = 0;
   picf->dwcbUncommitted = 0;

   return;
}


/*
** ReadFromCache()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE DWORD ReadFromCache(PICACHEDFILE picf, PVOID hpbyteBuffer, DWORD dwcb)
{
   DWORD dwcbRead;
   PBYTE pbyteStart;
   DWORD dwcbValid;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(hpbyteBuffer, BYTE, (UINT)dwcb));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_READ));
   ASSERT(dwcb > 0);

   /* Is there any valid data that can be read from the cache? */

   dwcbValid = GetValidReadData(picf, &pbyteStart);

   if (dwcbValid > 0)
   {
      /* Yes.  Copy it into the buffer. */

      dwcbRead = min(dwcbValid, dwcb);

      CopyMemory(hpbyteBuffer, pbyteStart, dwcbRead);

      picf->dwcbCurFilePosition += dwcbRead;
   }
   else
      dwcbRead = 0;

   return(dwcbRead);
}


/*
** GetValidReadData()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE DWORD GetValidReadData(PICACHEDFILE picf, PBYTE *ppbyteStart)
{
   DWORD dwcbValid;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(ppbyteStart, PBYTE *));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_READ));

   /* Is there any valid read data in the cache? */

   /* The current file position must be inside the valid data in the cache. */

   /* Watch out for overflow. */

   ASSERT(picf->dwcbFileOffsetOfCache <= DWORD_MAX - picf->dwcbValid);

   if (picf->dwcbCurFilePosition >= picf->dwcbFileOffsetOfCache &&
       picf->dwcbCurFilePosition < picf->dwcbFileOffsetOfCache + picf->dwcbValid)
   {
      DWORD dwcbStartBias;

      /* Yes. */

      dwcbStartBias = picf->dwcbCurFilePosition - picf->dwcbFileOffsetOfCache;

      *ppbyteStart = picf->pbyteCache + dwcbStartBias;

      /* The second clause above protects against underflow here. */

      dwcbValid = picf->dwcbValid - dwcbStartBias;
   }
   else
      /* No. */
      dwcbValid = 0;

   return(dwcbValid);
}


/*
** FillCache()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FillCache(PICACHEDFILE picf, PDWORD pdwcbNewData)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(pdwcbNewData, DWORD));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_READ));

   if (CommitCache(picf))
   {
      DWORD dwcbOffset;

      ResetCacheToEmpty(picf);

      /* Seek to start position. */

      dwcbOffset = SetFilePointer(picf->hfile, picf->dwcbCurFilePosition, NULL, FILE_BEGIN);

      if (dwcbOffset != INVALID_SEEK_POSITION)
      {
         DWORD dwcbRead;

         ASSERT(dwcbOffset == picf->dwcbCurFilePosition);

         /* Fill cache from file. */

         if (ReadFile(picf->hfile, picf->pbyteCache, picf->dwcbCacheSize, &dwcbRead, NULL))
         {
            picf->dwcbValid = dwcbRead;

            *pdwcbNewData = dwcbRead;
            bResult = TRUE;

            TRACE_OUT((TEXT("FillCache(): Read %lu bytes into cache starting at offset %lu in file %s."),
                       dwcbRead,
                       dwcbOffset,
                       picf->pszPath));
         }
      }
   }

   return(bResult);
}


/*
** WriteToCache()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE DWORD WriteToCache(PICACHEDFILE picf, PCVOID hpbyteBuffer, DWORD dwcb)
{
   DWORD dwcbAvailable;
   PBYTE pbyteStart;
   DWORD dwcbWritten;
   DWORD dwcbNewUncommitted;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_READ_BUFFER_PTR(hpbyteBuffer, BYTE, (UINT)dwcb));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_WRITE));
   ASSERT(dwcb > 0);

   /* Is there any room left to write data into the cache? */

   dwcbAvailable = GetAvailableWriteSpace(picf, &pbyteStart);

   /* Yes.  Determine how much to copy into cache. */

   dwcbWritten = min(dwcbAvailable, dwcb);

   /* Can we write anything into the cache? */

   if (dwcbWritten > 0)
   {
      /* Yes.  Write it. */

      CopyMemory(pbyteStart, hpbyteBuffer, dwcbWritten);

      /* Watch out for overflow. */

      ASSERT(picf->dwcbCurFilePosition <= DWORD_MAX - dwcbWritten);

      picf->dwcbCurFilePosition += dwcbWritten;

      /* Watch out for underflow. */

      ASSERT(picf->dwcbCurFilePosition >= picf->dwcbFileOffsetOfCache);

      dwcbNewUncommitted = picf->dwcbCurFilePosition - picf->dwcbFileOffsetOfCache;

      if (picf->dwcbUncommitted < dwcbNewUncommitted)
         picf->dwcbUncommitted = dwcbNewUncommitted;

      if (picf->dwcbValid < dwcbNewUncommitted)
      {
         DWORD dwcbNewFileLen;

         picf->dwcbValid = dwcbNewUncommitted;

         /* Watch out for overflow. */

         ASSERT(picf->dwcbFileOffsetOfCache <= DWORD_MAX - dwcbNewUncommitted);

         dwcbNewFileLen = picf->dwcbFileOffsetOfCache + dwcbNewUncommitted;

         if (picf->dwcbFileLen < dwcbNewFileLen)
            picf->dwcbFileLen = dwcbNewFileLen;
      }
   }

   return(dwcbWritten);
}


/*
** GetAvailableWriteSpace()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE DWORD GetAvailableWriteSpace(PICACHEDFILE picf, PBYTE *ppbyteStart)
{
   DWORD dwcbAvailable;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(ppbyteStart, PBYTE *));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_WRITE));

   /* Is there room to write data in the cache? */

   /*
    * The current file position must be inside or just after the end of the
    * valid data in the cache, or at the front of the cache when there is no
    * valid data in the cache.
    */

   /* Watch out for overflow. */

   ASSERT(picf->dwcbFileOffsetOfCache <= DWORD_MAX - picf->dwcbValid);

   if (picf->dwcbCurFilePosition >= picf->dwcbFileOffsetOfCache &&
       picf->dwcbCurFilePosition <= picf->dwcbFileOffsetOfCache + picf->dwcbValid)
   {
      DWORD dwcbStartBias;

      /* Yes. */

      dwcbStartBias = picf->dwcbCurFilePosition - picf->dwcbFileOffsetOfCache;

      *ppbyteStart = picf->pbyteCache + dwcbStartBias;

      /* Watch out for underflow. */

      ASSERT(picf->dwcbCacheSize >= dwcbStartBias);

      dwcbAvailable = picf->dwcbCacheSize - dwcbStartBias;
   }
   else
      /* No. */
      dwcbAvailable = 0;

   return(dwcbAvailable);
}


/*
** CommitCache()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Calling CommitCache() on a file opened without write access is a NOP.
*/
PRIVATE_CODE BOOL CommitCache(PICACHEDFILE picf)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));

   /* Any data to commit? */

   if (IS_FLAG_SET(picf->dwOpenMode, GENERIC_WRITE) &&
       picf->dwcbUncommitted > 0)
   {
      DWORD dwcbOffset;

      /* Yes.  Seek to start position of cache in file. */

      bResult = FALSE;

      dwcbOffset = SetFilePointer(picf->hfile, picf->dwcbFileOffsetOfCache, NULL, FILE_BEGIN);

      if (dwcbOffset != INVALID_SEEK_POSITION)
      {
         DWORD dwcbWritten;

         ASSERT(dwcbOffset == picf->dwcbFileOffsetOfCache);

         /* Write to file from cache. */

         if (WriteFile(picf->hfile, picf->pbyteCache, picf->dwcbUncommitted, &dwcbWritten, NULL) &&
             dwcbWritten == picf->dwcbUncommitted)
         {
            TRACE_OUT((TEXT("CommitCache(): Committed %lu uncommitted bytes starting at offset %lu in file %s."),
                       dwcbWritten,
                       dwcbOffset,
                       picf->pszPath));

            bResult = TRUE;
         }
      }
   }
   else
      bResult = TRUE;

   return(bResult);
}


#ifdef VSTF

/*
** IsValidPCICACHEDFILE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCICACHEDFILE(PCICACHEDFILE pcicf)
{
   return(IS_VALID_READ_PTR(pcicf, CICACHEDFILE) &&
          IS_VALID_HANDLE(pcicf->hfile, FILE) &&
          FLAGS_ARE_VALID(pcicf->dwOpenMode, ALL_FILE_ACCESS_FLAGS) &&
          EVAL(pcicf->dwcbCacheSize > 0) &&
          IS_VALID_WRITE_BUFFER_PTR(pcicf->pbyteCache, BYTE, (UINT)(pcicf->dwcbCacheSize)) &&
          IS_VALID_WRITE_BUFFER_PTR(pcicf->pbyteDefaultCache, BYTE, (UINT)(pcicf->dwcbDefaultCacheSize)) &&
          EVAL(pcicf->dwcbCacheSize > pcicf->dwcbDefaultCacheSize ||
               pcicf->pbyteCache == pcicf->pbyteDefaultCache) &&
          IS_VALID_STRING_PTR(pcicf->pszPath, STR) &&
          EVAL(IS_FLAG_SET(pcicf->dwOpenMode, GENERIC_WRITE) ||
               ! pcicf->dwcbUncommitted) &&
          (EVAL(pcicf->dwcbValid <= pcicf->dwcbCacheSize) &&
           EVAL(pcicf->dwcbUncommitted <= pcicf->dwcbCacheSize) &&
           EVAL(pcicf->dwcbUncommitted <= pcicf->dwcbValid) &&
           (EVAL(! pcicf->dwcbValid ||
                 pcicf->dwcbFileLen >= pcicf->dwcbFileOffsetOfCache + pcicf->dwcbValid) &&
            EVAL(! pcicf->dwcbUncommitted ||
                 pcicf->dwcbFileLen >= pcicf->dwcbFileOffsetOfCache + pcicf->dwcbUncommitted))));
}

#endif   /* VSTF */

#endif   /* NOFCACHE */


#ifdef VSTF

/*
** IsValidPCCACHEDFILE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCCACHEDFILE(PCCACHEDFILE pccf)
{
   return(IS_VALID_READ_PTR(pccf, CCACHEDFILE) &&
          IS_VALID_STRING_PTR(pccf->pcszPath, CSTR) &&
          EVAL(pccf->dwcbDefaultCacheSize > 0) &&
          FLAGS_ARE_VALID(pccf->dwOpenMode, ALL_FILE_ACCESS_FLAGS) &&
          FLAGS_ARE_VALID(pccf->dwSharingMode, ALL_FILE_SHARING_FLAGS) &&
          (! pccf->psa ||
           IS_VALID_STRUCT_PTR(pccf->psa, CSECURITY_ATTRIBUTES)) &&
          IsValidFileCreationMode(pccf->dwCreateMode) &&
          FLAGS_ARE_VALID(pccf->dwAttrsAndFlags, ALL_FILE_ATTRIBUTES_AND_FLAGS) &&
          IS_VALID_HANDLE(pccf->hTemplateFile, TEMPLATEFILE));
}

#endif   /* VSTF */


/****************************** Public Functions *****************************/


/*
** CreateCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE FCRESULT CreateCachedFile(PCCACHEDFILE pccf, PHCACHEDFILE phcf)
{
   ASSERT(IS_VALID_STRUCT_PTR(pccf, CCACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(phcf, HCACHEDFILE));

   return(SetUpCachedFile(pccf, phcf));
}


/*
** SetCachedFileCacheSize()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  Commits the cache, and discards cached data.
*/
PUBLIC_CODE FCRESULT SetCachedFileCacheSize(HCACHEDFILE hcf, DWORD dwcbNewCacheSize)
{
   FCRESULT fcr;

   /* dwcbNewCacheSize may be any value here. */

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

#ifdef NOFCACHE

   fcr = FCR_SUCCESS;

#else

   /* Use default cache size instead of 0. */

   if (! dwcbNewCacheSize)
   {
      ASSERT(((PICACHEDFILE)hcf)->dwcbDefaultCacheSize > 0);

      dwcbNewCacheSize = ((PICACHEDFILE)hcf)->dwcbDefaultCacheSize;
   }

   /* Is the cache size changing? */

   if (dwcbNewCacheSize == ((PICACHEDFILE)hcf)->dwcbCacheSize)
      /* No.  Whine about it. */
      WARNING_OUT((TEXT("SetCachedFileCacheSize(): Cache size is already %lu bytes."),
                   dwcbNewCacheSize));

   /* Commit the cache so we can change its size. */

   if (CommitCache((PICACHEDFILE)hcf))
   {
      PBYTE pbyteNewCache;

      /* Throw away cached data. */

      ResetCacheToEmpty((PICACHEDFILE)hcf);

      /* Do we need to allocate a new cache? */

      if (dwcbNewCacheSize <= ((PICACHEDFILE)hcf)->dwcbDefaultCacheSize)
      {
         /* No. */

         pbyteNewCache = ((PICACHEDFILE)hcf)->pbyteDefaultCache;

         fcr = FCR_SUCCESS;

         TRACE_OUT((TEXT("SetCachedFileCacheSize(): Using %lu bytes of %lu bytes allocated to default cache."),
                    dwcbNewCacheSize,
                    ((PICACHEDFILE)hcf)->dwcbDefaultCacheSize));
      }
      else
      {
         /* Yes. */

         if (AllocateMemory(dwcbNewCacheSize, &pbyteNewCache))
         {
            fcr = FCR_SUCCESS;

            TRACE_OUT((TEXT("SetCachedFileCacheSize(): Allocated %lu bytes for new cache."),
                       dwcbNewCacheSize));
         }
         else
            fcr = FCR_OUT_OF_MEMORY;
      }

      if (fcr == FCR_SUCCESS)
      {
         /* Do we need to free the old cache? */

         if (((PICACHEDFILE)hcf)->pbyteCache != ((PICACHEDFILE)hcf)->pbyteDefaultCache)
         {
            /* Yes. */

            ASSERT(((PICACHEDFILE)hcf)->dwcbCacheSize > ((PICACHEDFILE)hcf)->dwcbDefaultCacheSize);

            FreeMemory(((PICACHEDFILE)hcf)->pbyteCache);
         }

         /* Use new cache. */

         ((PICACHEDFILE)hcf)->pbyteCache = pbyteNewCache;
         ((PICACHEDFILE)hcf)->dwcbCacheSize = dwcbNewCacheSize;
      }
   }
   else
      fcr = FCR_WRITE_FAILED;

#endif

   return(fcr);
}


/*
** SeekInCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE DWORD SeekInCachedFile(HCACHEDFILE hcf, DWORD dwcbSeek, DWORD uOrigin)
{
   DWORD dwcbResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(uOrigin == FILE_BEGIN || uOrigin == FILE_CURRENT || uOrigin == FILE_END);

#ifdef NOFCACHE

   dwcbResult = SetFilePointer(hcf, dwcbSeek, NULL, uOrigin);

#else

   {
      BOOL bValidTarget = TRUE;
      DWORD dwcbWorkingOffset = 0;

      /* Determine seek base. */

      switch (uOrigin)
      {
         case SEEK_CUR:
            dwcbWorkingOffset = ((PICACHEDFILE)hcf)->dwcbCurFilePosition;
            break;

         case SEEK_SET:
            break;

         case SEEK_END:
            dwcbWorkingOffset = ((PICACHEDFILE)hcf)->dwcbFileLen;
            break;

         default:
            bValidTarget = FALSE;
            break;
      }

      if (bValidTarget)
      {
         /* Add bias. */

         /* Watch out for overflow. */

         ASSERT(dwcbWorkingOffset <= DWORD_MAX - dwcbSeek);

         dwcbWorkingOffset += dwcbSeek;

         ((PICACHEDFILE)hcf)->dwcbCurFilePosition = dwcbWorkingOffset;
         dwcbResult = dwcbWorkingOffset;
      }
      else
         dwcbResult = INVALID_SEEK_POSITION;
   }

#endif   /* NOFCACHE */

   return(dwcbResult);
}


/*
** SetEndOfCachedFile()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  Commits cache.
*/
PUBLIC_CODE BOOL SetEndOfCachedFile(HCACHEDFILE hcf)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   bResult = CommitCache((PICACHEDFILE)hcf);

   if (bResult)
   {
      bResult = (SetFilePointer(((PICACHEDFILE)hcf)->hfile,
                                ((PICACHEDFILE)hcf)->dwcbCurFilePosition, NULL,
                                FILE_BEGIN) ==
                 ((PICACHEDFILE)hcf)->dwcbCurFilePosition);

      if (bResult)
      {
         bResult = SetEndOfFile(((PICACHEDFILE)hcf)->hfile);

         if (bResult)
         {
            ResetCacheToEmpty((PICACHEDFILE)hcf);

            ((PICACHEDFILE)hcf)->dwcbFileLen = ((PICACHEDFILE)hcf)->dwcbCurFilePosition;

#ifdef DEBUG

            {
               DWORD dwcbFileSizeHigh;
               DWORD dwcbFileSizeLow;

               dwcbFileSizeLow = GetFileSize(((PICACHEDFILE)hcf)->hfile, &dwcbFileSizeHigh);

               ASSERT(! dwcbFileSizeHigh);
               ASSERT(((PICACHEDFILE)hcf)->dwcbFileLen == dwcbFileSizeLow);
               ASSERT(((PICACHEDFILE)hcf)->dwcbCurFilePosition == dwcbFileSizeLow);
            }

#endif

         }
      }
   }

   return(bResult);
}


/*
** GetCachedFilePointerPosition()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE DWORD GetCachedFilePointerPosition(HCACHEDFILE hcf)
{
   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   return(((PICACHEDFILE)hcf)->dwcbCurFilePosition);
}


/*
** GetCachedFileSize()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE DWORD GetCachedFileSize(HCACHEDFILE hcf)
{
   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   return(((PICACHEDFILE)hcf)->dwcbFileLen);
}


/*
** ReadFromCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ReadFromCachedFile(HCACHEDFILE hcf, PVOID hpbyteBuffer, DWORD dwcb,
                               PDWORD pdwcbRead)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(hpbyteBuffer, BYTE, (UINT)dwcb));
   ASSERT(! pdwcbRead || IS_VALID_WRITE_PTR(pdwcbRead, DWORD));

   *pdwcbRead = 0;

#ifdef NOFCACHE

   bResult = ReadFile(hcf, hpbyteBuffer, dwcb, pdwcbRead, NULL);

#else

   /*
    * Make sure that the cached file has been set up for read access before
    * allowing a read.
    */

   if (IS_FLAG_SET(((PICACHEDFILE)hcf)->dwOpenMode, GENERIC_READ))
   {
      DWORD dwcbToRead = dwcb;

      /* Read requested data. */

      bResult = TRUE;

      while (dwcbToRead > 0)
      {
         DWORD dwcbRead;

         dwcbRead = ReadFromCache((PICACHEDFILE)hcf, hpbyteBuffer, dwcbToRead);

         /* Watch out for underflow. */

         ASSERT(dwcbRead <= dwcbToRead);

         dwcbToRead -= dwcbRead;

         if (dwcbToRead > 0)
         {
            DWORD dwcbNewData;

            if (FillCache((PICACHEDFILE)hcf, &dwcbNewData))
            {
               hpbyteBuffer = (PBYTE)hpbyteBuffer + dwcbRead;

               if (! dwcbNewData)
                  break;
            }
            else
            {
               bResult = FALSE;
               break;
            }
         }
      }

      /* Watch out for underflow. */

      ASSERT(dwcb >= dwcbToRead);

      if (bResult && pdwcbRead)
         *pdwcbRead = dwcb - dwcbToRead;
   }
   else
      bResult = FALSE;

#endif   /* NOFCACHE */

   ASSERT(! pdwcbRead ||
          ((bResult && *pdwcbRead <= dwcb) ||
           (! bResult && ! *pdwcbRead)));

   return(bResult);
}


/*
** WriteToCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** N.b., callers don't currently check that *pdwcbWritten == dwcb when
** WriteToCachedFile() returns TRUE.
*/
PUBLIC_CODE BOOL WriteToCachedFile(HCACHEDFILE hcf, PCVOID hpbyteBuffer, DWORD dwcb,
                              PDWORD pdwcbWritten)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_READ_BUFFER_PTR(hpbyteBuffer, BYTE, (UINT)dwcb));

   ASSERT(dwcb > 0);

#ifdef NOFCACHE

   bResult = WriteFile(hcf, hpbyteBuffer, dwcb, pdwcbWritten, NULL);

#else

   /*
    * Make sure that the cached file has been set up for write access before
    * allowing a write.
    */

   if (IS_FLAG_SET(((PICACHEDFILE)hcf)->dwOpenMode, GENERIC_WRITE))
   {
      DWORD dwcbToWrite = dwcb;

      /* Write requested data. */

      bResult = TRUE;

      while (dwcbToWrite > 0)
      {
         DWORD dwcbWritten;

         dwcbWritten = WriteToCache((PICACHEDFILE)hcf, hpbyteBuffer, dwcbToWrite);

         /* Watch out for underflow. */

         ASSERT(dwcbWritten <= dwcbToWrite);

         dwcbToWrite -= dwcbWritten;

         if (dwcbToWrite > 0)
         {
            if (CommitCache((PICACHEDFILE)hcf))
            {
               ResetCacheToEmpty((PICACHEDFILE)hcf);

               hpbyteBuffer = (PCBYTE)hpbyteBuffer + dwcbWritten;
            }
            else
            {
               bResult = FALSE;

               break;
            }
         }
      }

      ASSERT(dwcb >= dwcbToWrite);

      if (pdwcbWritten)
      {
         if (bResult)
         {
            ASSERT(! dwcbToWrite);

            *pdwcbWritten = dwcb;
         }
         else
            *pdwcbWritten = 0;
      }
   }
   else
      bResult = FALSE;

#endif   /* NOFCACHE */

   ASSERT(! pdwcbWritten ||
          ((bResult && *pdwcbWritten == dwcb) ||
           (! bResult && ! *pdwcbWritten)));

   return(bResult);
}


/*
** CommitCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CommitCachedFile(HCACHEDFILE hcf)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

#ifdef NOFCACHE

   bResult = TRUE;

#else

   /*
    * Make sure that the cached file has been set up for write access before
    * allowing a commit.
    */

   if (IS_FLAG_SET(((PICACHEDFILE)hcf)->dwOpenMode, GENERIC_WRITE))
      bResult = CommitCache((PICACHEDFILE)hcf);
   else
      bResult = FALSE;

#endif   /* NOFCACHE */

   return(bResult);
}


/*
** GetFileHandle()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HANDLE GetFileHandle(HCACHEDFILE hcf)
{
   HANDLE hfResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

#ifdef NOFCACHE

   hfResult = hcf;

#else

   hfResult = ((PCICACHEDFILE)hcf)->hfile;

#endif   /* NOFCACHE */

   return(hfResult);
}


/*
** CloseCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CloseCachedFile(HCACHEDFILE hcf)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

#ifdef NOFCACHE

   bResult = CloseHandle(hcf);

#else

   {
      BOOL bCommit;
      BOOL bClose;

      bCommit = CommitCache((PICACHEDFILE)hcf);

      bClose = CloseHandle(((PCICACHEDFILE)hcf)->hfile);

      BreakDownCachedFile((PICACHEDFILE)hcf);

      bResult = bCommit && bClose;
   }

#endif   /* NOFCACHE */

   return(bResult);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidHCACHEDFILE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHCACHEDFILE(HCACHEDFILE hcf)
{
   BOOL bResult;

#ifdef NOFCACHE

   bResult = TRUE;

#else

   bResult = IS_VALID_STRUCT_PTR((PCICACHEDFILE)hcf, CICACHEDFILE);

#endif   /* NOFCACHE */

   return(bResult);
}

#endif   /* DEBUG || VSTF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\foldtwin.h ===
/*
 * foldtwin.h - Folder twin ADT description.
 */


/* Prototypes
 *************/

/* foldtwin.c */

extern BOOL CreateFolderPairPtrArray(PHPTRARRAY);
extern void DestroyFolderPairPtrArray(HPTRARRAY);
extern TWINRESULT MyTranslateFolder(HBRFCASE, HPATH, HPATH);
extern BOOL IsValidHFOLDERTWIN(HFOLDERTWIN);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\file.c ===
/*
 * file.c - File routines module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Constants
 ************/

/* size of file comparison buffer in bytes */

#define COMP_BUF_SIZE      (16U * 1024U)


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_SHARED)

/* lock count for file comparison buffer */

PRIVATE_DATA ULONG MulcCompBufLock = 0;

/* buffers for file comparison */

PRIVATE_DATA PBYTE MrgbyteCompBuf1 = NULL;
PRIVATE_DATA PBYTE MrgbyteCompBuf2 = NULL;

/* length of file comparison buffers in bytes */

PRIVATE_DATA UINT MucbCompBufLen = 0;

#pragma data_seg()


/****************************** Public Functions *****************************/


/*
** BeginComp()
**
** Increments file comparison buffers' lock count.
**
** Arguments:     void
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE void BeginComp(void)
{
   ASSERT((MrgbyteCompBuf1 && MrgbyteCompBuf2 && MucbCompBufLen > 0) ||
          (! MrgbyteCompBuf1 && ! MrgbyteCompBuf2 && ! MucbCompBufLen));

   ASSERT(MulcCompBufLock < ULONG_MAX);
   MulcCompBufLock++;

   return;
}


/*
** EndComp()
**
** Decrements file comparison buffers' lock count.
**
** Arguments:     void
**
** Returns:       void
**
** Side Effects:  Frees file comparison buffers if lock count goes to 0.
*/
PUBLIC_CODE void EndComp(void)
{
   ASSERT((MrgbyteCompBuf1 && MrgbyteCompBuf2 && MucbCompBufLen > 0) ||
          (! MrgbyteCompBuf1 && ! MrgbyteCompBuf2 && ! MucbCompBufLen));
   ASSERT(MulcCompBufLock > 0 || (! MrgbyteCompBuf1 && ! MrgbyteCompBuf2 && ! MucbCompBufLen));

   if (EVAL(MulcCompBufLock > 0))
      MulcCompBufLock--;

   /* Are the comparison buffers still locked? */

   if (! MulcCompBufLock && MrgbyteCompBuf1 && MrgbyteCompBuf2)
   {
      /* No.  Free them. */

      FreeMemory(MrgbyteCompBuf1);
      MrgbyteCompBuf1 = NULL;

      FreeMemory(MrgbyteCompBuf2);
      MrgbyteCompBuf2 = NULL;

      TRACE_OUT((TEXT("EndComp(): Two %u byte file comparison buffers freed."),
                 MucbCompBufLen));

      MucbCompBufLen = 0;
   }

   return;
}


/*
** CompareFilesByHandle()
**
** Determines whether or not two files are the same.
**
** Arguments:     h1 - DOS file handle to first open file
**                h2 - DOS file handle to second open file
**                pbIdentical - pointer to BOOL to be filled in with value
**                               indicating whether or not the files are
**                               identical
**
** Returns:       TWINRESULT
**
** Side Effects:  Changes the position of the file pointer of each file.
*/
PUBLIC_CODE TWINRESULT CompareFilesByHandle(HANDLE h1, HANDLE h2,
                                              PBOOL pbIdentical)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(h1, FILE));
   ASSERT(IS_VALID_HANDLE(h2, FILE));
   ASSERT(IS_VALID_WRITE_PTR(pbIdentical, BOOL));

   ASSERT((MrgbyteCompBuf1 && MrgbyteCompBuf2 && MucbCompBufLen > 0) ||
          (! MrgbyteCompBuf1 && ! MrgbyteCompBuf2 && ! MucbCompBufLen));
   ASSERT(MulcCompBufLock || (! MrgbyteCompBuf1 && ! MrgbyteCompBuf2 && ! MucbCompBufLen));

   /* Have the comparison buffers already been allocated? */

   if (MrgbyteCompBuf1)
      tr = TR_SUCCESS;
   else
   {
      /* No.  Allocate them. */

      tr = TR_OUT_OF_MEMORY;

      if (AllocateMemory(COMP_BUF_SIZE, &MrgbyteCompBuf1))
      {
         if (AllocateMemory(COMP_BUF_SIZE, &MrgbyteCompBuf2))
         {
            /* Success! */

            MucbCompBufLen = COMP_BUF_SIZE;
            tr = TR_SUCCESS;

            TRACE_OUT((TEXT("CompareFilesByHandle(): Two %u byte file comparison buffers allocated."),
                       MucbCompBufLen));
         }
         else
         {
            FreeMemory(MrgbyteCompBuf1);
            MrgbyteCompBuf1 = NULL;
         }
      }
   }

   if (tr == TR_SUCCESS)
   {
      DWORD dwcbLen1;

      BeginComp();

      /* Get file lengths to compare. */

      tr = TR_SRC_READ_FAILED;

      dwcbLen1 = SetFilePointer(h1, 0, NULL, FILE_END);

      if (dwcbLen1 != INVALID_SEEK_POSITION)
      {
         DWORD dwcbLen2;

         dwcbLen2 = SetFilePointer(h2, 0, NULL, FILE_END);

         if (dwcbLen2 != INVALID_SEEK_POSITION)
         {
            /* Are the files the same length? */

            if (dwcbLen1 == dwcbLen2)
            {
               /* Yes.  Move to the beginning of the files. */

               if (SetFilePointer(h1, 0, NULL, FILE_BEGIN) != INVALID_SEEK_POSITION)
               {
                  if (SetFilePointer(h2, 0, NULL, FILE_BEGIN) != INVALID_SEEK_POSITION)
                  {
                     tr = TR_SUCCESS;

                     do
                     {
                        DWORD dwcbRead1;

                        if (ReadFile(h1, MrgbyteCompBuf1, MucbCompBufLen, &dwcbRead1, NULL))
                        {
                           DWORD dwcbRead2;

                           if (ReadFile(h2, MrgbyteCompBuf2, MucbCompBufLen, &dwcbRead2, NULL))
                           {
                              if (dwcbRead1 == dwcbRead2)
                              {
                                 /* At EOF? */

                                 if (! dwcbRead1)
                                 {
                                    /* Yes. */

                                    *pbIdentical = TRUE;
                                    break;
                                 }
                                 else if (MyMemComp(MrgbyteCompBuf1, MrgbyteCompBuf2, dwcbRead1) != CR_EQUAL)
                                 {
                                    /* Yes. */

                                    *pbIdentical = FALSE;
                                    break;
                                 }
                              }
                              else
                                 tr = TR_SRC_READ_FAILED;
                           }
                           else
                              tr = TR_SRC_READ_FAILED;
                        }
                        else
                           tr = TR_SRC_READ_FAILED;
                     } while (tr == TR_SUCCESS);
                  }
               }
            }
            else
            {
               /* No.  Files different lengths. */

               *pbIdentical = FALSE;

               tr = TR_SUCCESS;
            }
         }
      }

      EndComp();
   }

   return(tr);
}


/*
** CompareFilesByName()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT CompareFilesByName(HPATH hpath1, HPATH hpath2,
                                          PBOOL pbIdentical)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hpath1, PATH));
   ASSERT(IS_VALID_HANDLE(hpath2, PATH));
   ASSERT(IS_VALID_WRITE_PTR(pbIdentical, BOOL));

   /* Only verify source and destination volumes once up front. */

   if (IsPathVolumeAvailable(hpath1) &&
       IsPathVolumeAvailable(hpath2))
   {
      HANDLE h1;
      TCHAR rgchFile1[MAX_PATH_LEN];

      /* Try to open files.  Assume sequential reads. */

      GetPathString(hpath1, 0, rgchFile1);

      h1 = CreateFile(rgchFile1, GENERIC_READ, FILE_SHARE_READ, NULL,
                      OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

      if (h1 != INVALID_HANDLE_VALUE)
      {
         HANDLE h2;
         TCHAR rgchFile2[MAX_PATH_LEN];

         GetPathString(hpath2, 0, rgchFile2);

         h2 = CreateFile(rgchFile2, GENERIC_READ, FILE_SHARE_READ, NULL,
                         OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

         if (h2 != INVALID_HANDLE_VALUE)
         {
            TRACE_OUT((TEXT("CompareFilesByHandle(): Comparing files %s and %s."),
                       DebugGetPathString(hpath1),
                       DebugGetPathString(hpath2)));

            tr = CompareFilesByHandle(h1, h2, pbIdentical);

#ifdef DEBUG

            if (tr == TR_SUCCESS)
            {
               if (*pbIdentical)
                  TRACE_OUT((TEXT("CompareFilesByHandle(): %s and %s are identical."),
                             DebugGetPathString(hpath1),
                             DebugGetPathString(hpath2)));
               else
                  TRACE_OUT((TEXT("CompareFilesByHandle(): %s and %s are different."),
                             DebugGetPathString(hpath1),
                             DebugGetPathString(hpath2)));
            }

#endif

            /*
             * Failing to close the file properly is not a failure condition here.
             */

            CloseHandle(h2);
         }
         else
            tr = TR_DEST_OPEN_FAILED;

          /*
           * Failing to close the file properly is not a failure condition here.
           */

         CloseHandle(h1);
      }
      else
         tr = TR_SRC_OPEN_FAILED;
   }
   else
      tr = TR_UNAVAILABLE_VOLUME;

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\findbc.c ===
/*
 * findbc.c - Briefcase enumeration module.
 */

/*



*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "findbc.h"


/* Macros
 *********/

/* macro for translating an LRESULT to a TWINRESULT */

#define LRESULTToTWINRESULT(lr, TR)    case lr: tr = TR; break


/* Constants
 ************/

/* briefcase registry keys */

#define HKEY_BRIEFCASE_ROOT         HKEY_CURRENT_USER
#ifdef DEBUG
#define HKEY_BRIEFCASE_ROOT_STRING  TEXT("HKEY_CURRENT_USER")
#endif

#define BRIEFCASE_SUBKEY            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Briefcase\\Briefcases")

/* maximum briefcase value name length, including null terminator */

#define MAX_VALUE_NAME_LEN          (8 + 1)


/* Types
 ********/

/* EnumBriefcases() callback function */

typedef LONG (*ENUMBRIEFCASESPROC)(PCLINKINFO, PCVOID, PBOOL);

/* briefcase iterator */

typedef struct _brfcaseiter
{
   HPTRARRAY hpa;

   ARRAYINDEX aiNext;
}
BRFCASEITER;
DECLARE_STANDARD_TYPES(BRFCASEITER);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE COMPARISONRESULT LinkInfoSortCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT LinkInfoSearchCmp(PCVOID, PCVOID);
PRIVATE_CODE TWINRESULT TranslateLRESULTToTWINRESULT(LONG);
PRIVATE_CODE LONG AllocateValueDataBuffer(HKEY, PVOID *, PDWORD);
PRIVATE_CODE LONG EnumBriefcases(HKEY, ENUMBRIEFCASESPROC, PCVOID, LPTSTR, PBOOL);
PRIVATE_CODE LONG GetUnusedBriefcaseValueName(HKEY, LPTSTR);
PRIVATE_CODE TWINRESULT CreateBriefcaseIterator(PBRFCASEITER *);
PRIVATE_CODE TWINRESULT GetNextBriefcaseIterator(PBRFCASEITER, PBRFCASEINFO);
PRIVATE_CODE void DestroyBriefcaseIterator(PBRFCASEITER);
PRIVATE_CODE LONG AddBriefcaseToIteratorProc(PCLINKINFO, PCVOID, PBOOL);
PRIVATE_CODE LONG CompareLinkInfoProc(PCLINKINFO, PCVOID, PBOOL);
PRIVATE_CODE TWINRESULT MyAddBriefcaseToSystem(PCLINKINFO);
PRIVATE_CODE TWINRESULT MyRemoveBriefcaseFromSystem(PCLINKINFO);
PRIVATE_CODE TWINRESULT UpdateBriefcaseLinkInfo(PCLINKINFO, PCLINKINFO);

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsValidPCBRFCASEITER(PCBRFCASEITER);

#endif

#ifdef EXPV

PRIVATE_CODE BOOL IsValidHBRFCASEITER(HBRFCASEITER);

#endif


/*
** LinkInfoSortCmp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** LinkInfo structures are sorted by:
**    1) LinkInfo referent
**    2) pointer
*/
PRIVATE_CODE COMPARISONRESULT LinkInfoSortCmp(PCVOID pcli1, PCVOID pcli2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pcli1, CLINKINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pcli2, CLINKINFO));

   cr = CompareLinkInfoReferents((PCLINKINFO)pcli1, (PCLINKINFO)pcli2);

   if (cr == CR_EQUAL)
      cr = ComparePointers(pcli1, pcli2);

   return(cr);
}


/*
** LinkInfoSearchCmp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** LinkInfo structures are searched by:
**    1) LinkInfo referent
*/
PRIVATE_CODE COMPARISONRESULT LinkInfoSearchCmp(PCVOID pcliTarget,
                                                PCVOID pcliCurrent)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcliTarget, CLINKINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pcliCurrent, CLINKINFO));

   return(CompareLinkInfoReferents(pcliTarget, pcliCurrent));
}


/*
** TranslateLRESULTToTWINRESULT()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT TranslateLRESULTToTWINRESULT(LONG lResult)
{
   TWINRESULT tr;

   switch (lResult)
   {
      LRESULTToTWINRESULT(ERROR_SUCCESS, TR_SUCCESS);

      default:
         tr = TR_OUT_OF_MEMORY;
         if (lResult != ERROR_OUTOFMEMORY)
            WARNING_OUT((TEXT("TranslateLRESULTToTWINRESULT(): Translating unlisted LRESULT %ld to TWINRESULT %s."),
                         lResult,
                         GetTWINRESULTString(tr)));
         break;
   }

   return(tr);
}


/*
** AllocateValueDataBuffer()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
LONG PRIVATE_CODE AllocateValueDataBuffer(HKEY hkey, PVOID *ppvData,
                                          PDWORD pdwcbLen)
{
   LONG lResult;

   ASSERT(IS_VALID_HANDLE(hkey, KEY));
   ASSERT(IS_VALID_WRITE_PTR(ppvData, PVOID));
   ASSERT(IS_VALID_WRITE_PTR(pdwcbLen, DWORD));

   lResult = RegQueryInfoKey(hkey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                             NULL, pdwcbLen, NULL, NULL);

   if (lResult == ERROR_SUCCESS)
   {
      if (! AllocateMemory(*pdwcbLen, ppvData))
         lResult = ERROR_OUTOFMEMORY;
   }

   ASSERT(lResult != ERROR_SUCCESS ||
          IS_VALID_WRITE_BUFFER_PTR(*ppvData, VOID, *pdwcbLen));

   return(lResult);
}


/*
** EnumBriefcases()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE LONG EnumBriefcases(HKEY hkeyBriefcases, ENUMBRIEFCASESPROC ebcp,
                                 PCVOID pcvRefData, LPTSTR pszValueNameBuf,
                                 PBOOL pbAbort)
{
   LONG lResult;
   DWORD dwcbMaxValueDataLen;
   PLINKINFO pli;

   /* pcvRefData may be any value. */

   ASSERT(IS_VALID_HANDLE(hkeyBriefcases, KEY));
   ASSERT(IS_VALID_CODE_PTR(ebcp, ENUMBRIEFCASESPROC));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszValueNameBuf, STR, MAX_VALUE_NAME_LEN));
   ASSERT(IS_VALID_WRITE_PTR(pbAbort, BOOL));

   /* Allocate a buffer to hold the largest value's data. */

   lResult = AllocateValueDataBuffer(hkeyBriefcases, &pli,
                                     &dwcbMaxValueDataLen);

   if (lResult == ERROR_SUCCESS)
   {
      DWORD dwiValue;

      /* Look through the briefcases looking for matching LinkInfo. */

      *pbAbort = FALSE;
      dwiValue = 0;

      do
      {
         DWORD dwcbValueNameLen;
         DWORD dwType;
         DWORD dwcbDataLen;

         dwcbValueNameLen = MAX_VALUE_NAME_LEN;
         dwcbDataLen = dwcbMaxValueDataLen;
         lResult = RegEnumValue(hkeyBriefcases, dwiValue, pszValueNameBuf,
                                &dwcbValueNameLen, NULL, &dwType, (PBYTE)pli,
                                &dwcbDataLen);

         switch (lResult)
         {
            case ERROR_SUCCESS:
               if (dwcbDataLen >= sizeof(pli->ucbSize) &&
                   pli->ucbSize == dwcbDataLen)
                  lResult = (*ebcp)(pli, pcvRefData, pbAbort);
               else
                  WARNING_OUT((TEXT("EnumBriefcases(): Value %s under %s\\%s is not a valid LinkInfo structure."),
                               pszValueNameBuf,
                               HKEY_BRIEFCASE_ROOT_STRING,
                               BRIEFCASE_SUBKEY));
               break;

            case ERROR_MORE_DATA:
               /*
                * Watch out for value names that are too long, and added
                * data values that are too long.
                */

               /* (+ 1) for null terminator. */

               if (dwcbValueNameLen >= MAX_VALUE_NAME_LEN)
                  WARNING_OUT((TEXT("EnumBriefcases(): Value %s under %s\\%s is too long.  %u bytes > %u bytes."),
                               pszValueNameBuf,
                               HKEY_BRIEFCASE_ROOT_STRING,
                               BRIEFCASE_SUBKEY,
                               dwcbValueNameLen + 1,
                               MAX_VALUE_NAME_LEN));
               if (dwcbDataLen > dwcbMaxValueDataLen)
                  WARNING_OUT((TEXT("EnumBriefcases(): Value %s's data under %s\\%s is too long.  %u bytes > %u bytes."),
                               pszValueNameBuf,
                               HKEY_BRIEFCASE_ROOT_STRING,
                               BRIEFCASE_SUBKEY,
                               dwcbDataLen,
                               dwcbMaxValueDataLen));

               /* Skip this value. */

               lResult = ERROR_SUCCESS;
               break;

            default:
               break;
         }
      } while (lResult == ERROR_SUCCESS &&
               ! *pbAbort &&
               dwiValue++ < DWORD_MAX);

      if (lResult == ERROR_NO_MORE_ITEMS)
         lResult = ERROR_SUCCESS;

      FreeMemory(pli);
   }

   return(lResult);
}


/*
** GetUnusedBriefcaseValueName()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE LONG GetUnusedBriefcaseValueName(HKEY hkeyBriefcases,
                                              LPTSTR pszValueNameBuf)
{
   LONG lResult;
   DWORD dwValueNumber;
   BOOL bFound;

   ASSERT(IS_VALID_HANDLE(hkeyBriefcases, KEY));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszValueNameBuf, STR, MAX_VALUE_NAME_LEN));

   dwValueNumber = 0;
   bFound = FALSE;

   do
   {
      wsprintf(pszValueNameBuf, TEXT("%lu"), dwValueNumber);
      ASSERT((DWORD)lstrlen(pszValueNameBuf) < MAX_VALUE_NAME_LEN);

      lResult = RegQueryValueEx(hkeyBriefcases, pszValueNameBuf, NULL, NULL,
                                NULL, NULL);

      switch (lResult)
      {
         case ERROR_SUCCESS:
            /* Used value name.  Continue searching. */
            TRACE_OUT((TEXT("GetUnusedBriefcaseValueName(): Found used briefcase value name %s."),
                       pszValueNameBuf));
            break;

         case ERROR_FILE_NOT_FOUND:
            /* Unused value name.  Stop searching. */
            lResult = ERROR_SUCCESS;
            bFound = TRUE;
            TRACE_OUT((TEXT("GetUnusedBriefcaseValueName(): Found unused briefcase value name %s."),
                       pszValueNameBuf));
            break;

         default:
            WARNING_OUT((TEXT("GetUnusedBriefcaseValueName(): RegQueryValueEx() failed, returning %ld."),
                         lResult));
            break;
      }
   } while (lResult == ERROR_SUCCESS &&
            ! bFound &&
            dwValueNumber++ < DWORD_MAX);

   if (dwValueNumber == DWORD_MAX)
   {
      ASSERT(lResult == ERROR_SUCCESS &&
             ! bFound);
      WARNING_OUT((TEXT("GetUnusedBriefcaseValueName(): All value names in use.")));

      lResult = ERROR_CANTWRITE;
   }

   return(lResult);
}


/*
** CreateBriefcaseIterator()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT CreateBriefcaseIterator(PBRFCASEITER *ppbciter)
{
   TWINRESULT tr;
   LONG lResult;
   HKEY hkeyBriefcases;

   ASSERT(IS_VALID_WRITE_PTR(ppbciter, PBRFCASEITER));

   lResult = RegOpenKeyEx(HKEY_BRIEFCASE_ROOT, BRIEFCASE_SUBKEY, 0,
                          (KEY_QUERY_VALUE | KEY_SET_VALUE), &hkeyBriefcases);

   if (lResult == ERROR_SUCCESS)
   {
      DWORD dwcBriefcases;

      lResult = RegQueryInfoKey(hkeyBriefcases, NULL, NULL, NULL, NULL, NULL,
                                NULL, NULL, &dwcBriefcases, NULL, NULL, NULL);

      if (lResult == ERROR_SUCCESS)
      {
         if (dwcBriefcases > 0)
         {
            tr = TR_OUT_OF_MEMORY;

            if (AllocateMemory(sizeof(**ppbciter), ppbciter))
            {
               NEWPTRARRAY npa;

               npa.aicInitialPtrs = dwcBriefcases;
               npa.aicAllocGranularity = 1;
               npa.dwFlags = NPA_FL_SORTED_ADD;

               if (CreatePtrArray(&npa, &((*ppbciter)->hpa)))
               {
                  TCHAR rgchValueName[MAX_VALUE_NAME_LEN];
                  BOOL bAbort;

                  (*ppbciter)->aiNext = 0;

                  tr = TranslateLRESULTToTWINRESULT(
                           EnumBriefcases(hkeyBriefcases,
                                          &AddBriefcaseToIteratorProc,
                                          *ppbciter, rgchValueName, &bAbort));

                  if (tr == TR_SUCCESS)
                     ASSERT(! bAbort);
                  else
                  {
                     DestroyPtrArray((*ppbciter)->hpa);
CREATEBRIEFCASEITERATOR_BAIL:
                     FreeMemory(*ppbciter);
                  }
               }
               else
                  goto CREATEBRIEFCASEITERATOR_BAIL;
            }
         }
         else
            tr = TR_NO_MORE;
      }
      else
         tr = TranslateLRESULTToTWINRESULT(lResult);
   }
   else
   {
      /* ERROR_FILE_NOT_FOUND is returned for a non-existent key. */

      if (lResult == ERROR_FILE_NOT_FOUND)
         tr = TR_NO_MORE;
      else
         /* RAIDRAID: (16279) We should map to other TWINRESULTs here. */
         tr = TR_OUT_OF_MEMORY;
   }

   ASSERT(tr != TR_SUCCESS ||
          IS_VALID_STRUCT_PTR(*ppbciter, CBRFCASEITER));

   return(tr);
}


/*
** GetNextBriefcaseIterator()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT GetNextBriefcaseIterator(PBRFCASEITER pbciter,
                                                 PBRFCASEINFO pbcinfo)
{
   TWINRESULT tr = TR_NO_MORE;
   ARRAYINDEX aicBriefcases;

   ASSERT(IS_VALID_STRUCT_PTR(pbciter, CBRFCASEITER));
   ASSERT(IS_VALID_WRITE_PTR(pbcinfo, BRFCASEINFO));
   ASSERT(pbcinfo->ulSize == sizeof(*pbcinfo));

   aicBriefcases = GetPtrCount(pbciter->hpa);

   while (pbciter->aiNext < aicBriefcases)
   {
      PCLINKINFO pcli;
      DWORD dwOutFlags;
      PLINKINFO pliUpdated;
      BOOL bRemoveBriefcase = FALSE;

      pcli = GetPtr(pbciter->hpa, pbciter->aiNext);

      if (ResolveLinkInfo(pcli, pbcinfo->rgchDatabasePath,
                          (RLI_IFL_UPDATE | RLI_IFL_LOCAL_SEARCH), NULL,
                          &dwOutFlags, &pliUpdated))
      {
         if (PathExists(pbcinfo->rgchDatabasePath))
         {
            /* Found an existing briefcase database. */

            if (IS_FLAG_SET(dwOutFlags, RLI_OFL_UPDATED))
            {
               if (UpdateBriefcaseLinkInfo(pcli, pliUpdated))
                  TRACE_OUT((TEXT("GetNextBriefcaseIterator(): Updated LinkInfo for briefcase database %s."),
                             pbcinfo->rgchDatabasePath));
               else
                  WARNING_OUT((TEXT("GetNextBriefcaseIterator(): Failed to update LinkInfo for briefcase database %s."),
                               pbcinfo->rgchDatabasePath));
            }

            tr = TR_SUCCESS;
         }
         else
            bRemoveBriefcase = TRUE;

         if (IS_FLAG_SET(dwOutFlags, RLI_OFL_UPDATED))
            DestroyLinkInfo(pliUpdated);
      }
      else
      {
         /*
          * GetLastError() here to differentiate an out of memory condition and
          * all other errors.  Remove the briefcase from the system for all
          * errors except out of memory, e.g., unavailable volume or invalid
          * parameter.
          */

         if (GetLastError() != ERROR_OUTOFMEMORY)
            bRemoveBriefcase = TRUE;
      }

      if (bRemoveBriefcase)
      {
         if (MyRemoveBriefcaseFromSystem(pcli) == TR_SUCCESS)
            TRACE_OUT((TEXT("GetNextBriefcaseIterator(): Unavailable/missing briefcase removed from system.")));
         else
            WARNING_OUT((TEXT("GetNextBriefcaseIterator(): Failed to remove unavailable/missing briefcase from system.")));
      }

      ASSERT(pbciter->aiNext < ARRAYINDEX_MAX);
      pbciter->aiNext++;

      if (tr == TR_SUCCESS)
         break;
   }

   return(tr);
}


/*
** DestroyBriefcaseIterator()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyBriefcaseIterator(PBRFCASEITER pbciter)
{
   ARRAYINDEX ai;
   ARRAYINDEX aicPtrs;

   ASSERT(IS_VALID_STRUCT_PTR(pbciter, CBRFCASEITER));

   aicPtrs = GetPtrCount(pbciter->hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      FreeMemory(GetPtr(pbciter->hpa, ai));

   DestroyPtrArray(pbciter->hpa);
   FreeMemory(pbciter);

   return;
}


/*
** AddBriefcaseToIteratorProc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE LONG AddBriefcaseToIteratorProc(PCLINKINFO pcli, PCVOID pcbciter,
                                             PBOOL pbAbort)
{
   LONG lResult;
   PLINKINFO pliCopy;

   ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pcbciter, CBRFCASEITER));
   ASSERT(IS_VALID_WRITE_PTR(pbAbort, BOOL));

   /* Add this briefcase database's LinkInfo to the iterator's list. */

   *pbAbort = TRUE;
   lResult = ERROR_OUTOFMEMORY;

   if (CopyLinkInfo(pcli, &pliCopy))
   {
      ARRAYINDEX ai;

      if (AddPtr(((PCBRFCASEITER)pcbciter)->hpa, LinkInfoSortCmp, pliCopy, &ai))
      {
         *pbAbort = FALSE;
         lResult = ERROR_SUCCESS;
      }
      else
         FreeMemory(pliCopy);
   }

   if (lResult == ERROR_SUCCESS)
      TRACE_OUT((TEXT("AddBriefcaseToIteratorProc(): Added LinkInfo for briefcase to briefcase iterator %#lx."),
                 pcbciter));
   else
      WARNING_OUT((TEXT("AddBriefcaseToIteratorProc(): Failed to add LinkInfo for briefcase to briefcase iterator %#lx."),
                   pcbciter));

   return(lResult);
}


/*
** CompareLinkInfoProc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE LONG CompareLinkInfoProc(PCLINKINFO pcli, PCVOID pcliTarget,
                                      PBOOL pbAbort)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pcliTarget, CLINKINFO));
   ASSERT(IS_VALID_WRITE_PTR(pbAbort, BOOL));

   /* Does this LinkInfo match our target LinkInfo? */

   *pbAbort = (LinkInfoSearchCmp(pcli, pcliTarget) == CR_EQUAL);

   return(ERROR_SUCCESS);
}


/*
** MyAddBriefcaseToSystem()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT MyAddBriefcaseToSystem(PCLINKINFO pcli)
{
   LONG lResult;
   HKEY hkeyBriefcases;
   DWORD dwDisposition;

   ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));

   /* Open briefcase list registry key for common access. */

   lResult = RegCreateKeyEx(HKEY_BRIEFCASE_ROOT, BRIEFCASE_SUBKEY, 0, NULL,
                            REG_OPTION_NON_VOLATILE,
                            (KEY_QUERY_VALUE | KEY_SET_VALUE), NULL,
                            &hkeyBriefcases, &dwDisposition);

   if (lResult == ERROR_SUCCESS)
   {
      TCHAR rgchValueName[MAX_VALUE_NAME_LEN];
      BOOL bFound;
      LONG lClose;

      lResult = EnumBriefcases(hkeyBriefcases, &CompareLinkInfoProc, pcli,
                               rgchValueName, &bFound);

      if (lResult == ERROR_SUCCESS)
      {
         if (bFound)
            TRACE_OUT((TEXT("AddBriefcaseToSystem(): Briefcase database already in registry list as value %s under %s\\%s."),
                       rgchValueName,
                       HKEY_BRIEFCASE_ROOT_STRING,
                       BRIEFCASE_SUBKEY));
         else
         {
            lResult = GetUnusedBriefcaseValueName(hkeyBriefcases,
                                                  rgchValueName);

            if (lResult == ERROR_SUCCESS)
            {
               lResult = RegSetValueEx(hkeyBriefcases, rgchValueName, 0,
                                       REG_BINARY, (PCBYTE)pcli,
                                       pcli->ucbSize);

               if (lResult == ERROR_SUCCESS)
                  TRACE_OUT((TEXT("AddBriefcaseToSystem(): Briefcase database added to registry list as value %s under %s\\%s."),
                             rgchValueName,
                             HKEY_BRIEFCASE_ROOT_STRING,
                             BRIEFCASE_SUBKEY));
            }
         }
      }

      lClose = RegCloseKey(hkeyBriefcases);

      if (lResult == ERROR_SUCCESS)
         lResult = lClose;
   }

   return(TranslateLRESULTToTWINRESULT(lResult));
}


/*
** MyRemoveBriefcaseFromSystem()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT MyRemoveBriefcaseFromSystem(PCLINKINFO pcli)
{
   LONG lResult;
   HKEY hkeyBriefcases;

   ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));

   /* Open briefcase list registry key for common access. */

   lResult = RegOpenKeyEx(HKEY_BRIEFCASE_ROOT, BRIEFCASE_SUBKEY, 0,
                          (KEY_QUERY_VALUE | KEY_SET_VALUE), &hkeyBriefcases);

   if (lResult == ERROR_SUCCESS)
   {
      TCHAR rgchValueName[MAX_VALUE_NAME_LEN];
      BOOL bFound;
      LONG lClose;

      lResult = EnumBriefcases(hkeyBriefcases, &CompareLinkInfoProc, pcli,
                               rgchValueName, &bFound);

      if (lResult == ERROR_SUCCESS)
      {
         if (bFound)
         {
            lResult = RegDeleteValue(hkeyBriefcases, rgchValueName);

            if (lResult == ERROR_SUCCESS)
               TRACE_OUT((TEXT("MyRemoveBriefcaseFromSystem(): Briefcase database removed from registry list as value %s under %s\\%s."),
                          rgchValueName,
                          HKEY_BRIEFCASE_ROOT_STRING,
                          BRIEFCASE_SUBKEY));
         }
         else
            WARNING_OUT((TEXT("MyRemoveBriefcaseFromSystem(): Briefcase database not in registry list under %s\\%s."),
                         HKEY_BRIEFCASE_ROOT_STRING,
                         BRIEFCASE_SUBKEY));
      }

      lClose = RegCloseKey(hkeyBriefcases);

      if (lResult == ERROR_SUCCESS)
         lResult = lClose;
   }
   else if (lResult == ERROR_FILE_NOT_FOUND)
   {
      WARNING_OUT((TEXT("MyRemoveBriefcaseFromSystem(): Briefcase key %s\\%s does not exist."),
                   HKEY_BRIEFCASE_ROOT_STRING,
                   BRIEFCASE_SUBKEY));

      lResult = ERROR_SUCCESS;
   }

   return(TranslateLRESULTToTWINRESULT(lResult));
}


/*
** UpdateBriefcaseLinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT UpdateBriefcaseLinkInfo(PCLINKINFO pcliOriginal,
                                                PCLINKINFO pcliUpdated)
{
   LONG lResult;
   HKEY hkeyBriefcases;
   DWORD dwDisposition;

   ASSERT(IS_VALID_STRUCT_PTR(pcliOriginal, CLINKINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pcliUpdated, CLINKINFO));

   /* Open briefcase list registry key for common access. */

   lResult = RegCreateKeyEx(HKEY_BRIEFCASE_ROOT, BRIEFCASE_SUBKEY, 0, NULL,
                            REG_OPTION_NON_VOLATILE,
                            (KEY_QUERY_VALUE | KEY_SET_VALUE), NULL,
                            &hkeyBriefcases, &dwDisposition);

   if (lResult == ERROR_SUCCESS)
   {
      TCHAR rgchValueName[MAX_VALUE_NAME_LEN];
      BOOL bFound;
      LONG lClose;

      lResult = EnumBriefcases(hkeyBriefcases, &CompareLinkInfoProc,
                               pcliOriginal, rgchValueName, &bFound);

      if (lResult == ERROR_SUCCESS)
      {
         if (bFound)
         {
            lResult = RegSetValueEx(hkeyBriefcases, rgchValueName, 0,
                                    REG_BINARY, (PCBYTE)pcliUpdated,
                                    pcliUpdated->ucbSize);

            if (lResult == ERROR_SUCCESS)
               TRACE_OUT((TEXT("UpdateBriefcaseLinkInfo(): Briefcase database LinkInfo updated in registry list as value %s under %s\\%s."),
                          rgchValueName,
                          HKEY_BRIEFCASE_ROOT_STRING,
                          BRIEFCASE_SUBKEY));
         }
         else
            WARNING_OUT((TEXT("UpdateBriefcaseLinkInfo(): Briefcase database LinkInfo not found in registry list under %s\\%s."),
                         HKEY_BRIEFCASE_ROOT_STRING,
                         BRIEFCASE_SUBKEY));
      }

      lClose = RegCloseKey(hkeyBriefcases);

      if (lResult == ERROR_SUCCESS)
         lResult = lClose;
   }

   return(TranslateLRESULTToTWINRESULT(lResult));
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidPCBRFCASEITER()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCBRFCASEITER(PCBRFCASEITER pcbciter)
{
   BOOL bResult = FALSE;

   if (IS_VALID_READ_PTR(pcbciter, CBRFCASEITER) &&
       IS_VALID_HANDLE(pcbciter->hpa, PTRARRAY))
   {
      ARRAYINDEX aicPtrs;
      ARRAYINDEX ai;

      aicPtrs = GetPtrCount(pcbciter->hpa);

      for (ai = 0; ai < aicPtrs; ai++)
      {
         if (! IS_VALID_STRUCT_PTR(GetPtr(pcbciter->hpa, ai), CLINKINFO))
            break;
      }

      bResult = (ai == aicPtrs);
   }

   return(bResult);
}

#endif


#ifdef EXPV

/*
** IsValidHBRFCASEITER()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidHBRFCASEITER(HBRFCASEITER hbciter)
{
   return(IS_VALID_STRUCT_PTR((PCBRFCASEITER)hbciter, CBRFCASEITER));
}

#endif


/****************************** Public Functions *****************************/


/*
** AddBriefcaseToSystem()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT AddBriefcaseToSystem(LPCTSTR pcszBriefcaseDatabase)
{
   TWINRESULT tr;
   PLINKINFO pli;

   ASSERT(IsFullPath(pcszBriefcaseDatabase));

   if (CreateLinkInfo(pcszBriefcaseDatabase, &pli))
   {
      tr = MyAddBriefcaseToSystem(pli);

      DestroyLinkInfo(pli);
   }
   else
   {
      /*
       * GetLastError() here to differentiate between TR_UNAVAILABLE_VOLUME and
       * TR_OUT_OF_MEMORY.
       */

      if (GetLastError() == ERROR_OUTOFMEMORY)
         tr = TR_OUT_OF_MEMORY;
      else
         tr = TR_UNAVAILABLE_VOLUME;
   }

   return(tr);
}


/*
** RemoveBriefcaseFromSystem()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT RemoveBriefcaseFromSystem(LPCTSTR pcszBriefcaseDatabase)
{
   TWINRESULT tr;
   PLINKINFO pli;

   ASSERT(IsFullPath(pcszBriefcaseDatabase));

   if (CreateLinkInfo(pcszBriefcaseDatabase, &pli))
   {
      tr = MyRemoveBriefcaseFromSystem(pli);

      DestroyLinkInfo(pli);
   }
   else
   {
      /*
       * GetLastError() here to differentiate between TR_UNAVAILABLE_VOLUME and
       * TR_OUT_OF_MEMORY.
       */

      if (GetLastError() == ERROR_OUTOFMEMORY)
         tr = TR_OUT_OF_MEMORY;
      else
         tr = TR_UNAVAILABLE_VOLUME;
   }

   return(tr);
}


/***************************** Exported Functions ****************************/


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | FindFirstBriefcase | Finds the first briefcase in the current
user's list of briefcases.

@parm PHBRFCASEITER | phbciter | A pointer to an HBRFCASEITER to be filled in
with a handle identifying the briefcase enumeration data associated with this
call to FindFirstBriefcase().  This handle may be passed to FindNextBriefcase()
amd FindCloseBriefcase().  This handle is only valid until FindBriefcaseClose()
is called on it.

@parm PBRFCASEINFO | pbcinfo | A pointer to a BRFCASEINFO to be filled in with
information describing the first enumerated briefcase.  The information in
*pbcinfo is only valid until FindBriefcaseClose() is called on *phbciter.

@rdesc If there is at least one existing briefcase in the user's list of
briefcases, TR_SUCCESS is returned, *phbciter is filled in with a handle
identifying the briefcase enumeration data associated with this call, and
*pbcinfo contains information describing the first briefcase in the user's list
of briefcases.  If there are no existing briefcases in the user's list of
briefcases, TR_NO_MORE is returned.  Otherwise, the return value indicates the
error that occurred.  *phbciter and *pbcinfo are only valid if TR_SUCCESS is
returned.

@comm To find the next briefcase in the user's list of briefcases, call
FindNextBriefcase() with *phbciter.  Once the caller is finished enumerating
briefcases, FindBriefcaseClose() should be called with *phbciter to free the
briefcase enumeration data.

@xref FindNextBriefcase() FindBriefcaseClose()

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI FindFirstBriefcase(PHBRFCASEITER phbciter,
                                                PBRFCASEINFO pbcinfo)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(FindFirstBriefcase);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_WRITE_PTR(phbciter, HBRFCASEITER) &&
          IS_VALID_WRITE_PTR(pbcinfo, BRFCASEINFO) &&
          EVAL(pbcinfo->ulSize == sizeof(*pbcinfo)))
#endif
      {
         PBRFCASEITER pbciter;

         tr = CreateBriefcaseIterator(&pbciter);

         if (tr == TR_SUCCESS)
         {
            tr = GetNextBriefcaseIterator(pbciter, pbcinfo);

            if (tr == TR_SUCCESS)
               *phbciter = (HBRFCASEITER)pbciter;
            else
               DestroyBriefcaseIterator(pbciter);
         }
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(FindFirstBriefcase, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | FindNextBriefcase | Finds the next briefcase in the current
user's list of briefcases.

@parm HBRFCASEITER | hbciter | A handle identifying the briefcase enumeration
data associated with a call to FindFirstBriefcase().

@parm PBRFCASEINFO | pbcinfo | A pointer to a BRFCASEINFO to be filled in with
information describing the next enumerated briefcase.  The information in
*pbcinfo is only valid until FindBriefcaseClose() is called on hbciter.

@rdesc If there is at least one more existing briefcase in the user's list of
briefcases, TR_SUCCESS is returned, and *pbcinfo contains information
describing the next briefcase in the user's list of briefcases.  If there are
no more existing briefcases in the user's list of briefcases, TR_NO_MORE is
returned.  Otherwise, the return value indicates the error that occurred.
*pbcinfo is only valid if TR_SUCCESS is returned.

@xref FindFirstBriefcase() FindBriefcaseClose()

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI FindNextBriefcase(HBRFCASEITER hbciter,
                                               PBRFCASEINFO pbcinfo)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(FindNextBriefcase);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbciter, BRFCASEITER) &&
          IS_VALID_WRITE_PTR(pbcinfo, BRFCASEINFO) &&
          EVAL(pbcinfo->ulSize == sizeof(*pbcinfo)))
#endif
      {
         tr = GetNextBriefcaseIterator((PBRFCASEITER)hbciter, pbcinfo);
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(FindNextBriefcase, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | FindBriefcaseClose | Terminates briefcase enumeration started
by FindFirstBriefcase().

@parm HBRFCASEITER | hbciter | A handle identifying the briefcase enumeration
data associated with a call to FindFirstBriefcase().  This handle is invalid
after calling FindBriefcaseClose().

@rdesc If the briefcase enumeration was terminated successfully, TR_SUCCESS is
returned.  Otherwise, the return value indicates the error that occurred.

@comm The information in any BRFCASEINFO structures returned by the call to
FindFirstBriefcase() that returned hbciter, and by any subsequent calls to
FindNextBriefcase() with hbciter, is invalid after FindBriefcaseClose() is
called on hbciter.

@xref FindFirstBriefcase() FindNextBriefcase()

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI FindBriefcaseClose(HBRFCASEITER hbciter)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(FindBriefcaseClose);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbciter, BRFCASEITER))
#endif
      {
         DestroyBriefcaseIterator((PBRFCASEITER)hbciter);

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(FindBriefcaseClose, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\hndtrans.h ===
/*
 * hndtrans.h - Handle translation description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HHANDLETRANS);
DECLARE_STANDARD_TYPES(HHANDLETRANS);

DECLARE_HANDLE(HGENERIC);
DECLARE_STANDARD_TYPES(HGENERIC);


/* Prototypes
 *************/

/* hndtrans.c */

extern BOOL CreateHandleTranslator(LONG, PHHANDLETRANS);
extern void DestroyHandleTranslator(HHANDLETRANS);
extern BOOL AddHandleToHandleTranslator(HHANDLETRANS, HGENERIC, HGENERIC);
extern void PrepareForHandleTranslation(HHANDLETRANS);
extern BOOL TranslateHandle(HHANDLETRANS, HGENERIC, PHGENERIC);

#ifdef DEBUG

extern BOOL IsValidHHANDLETRANS(HHANDLETRANS);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\guids.c ===
/*
 * guids.c - GUID definitions.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#pragma data_seg(DATA_SEG_READ_ONLY)

#pragma warning(disable:4001) /* "single line comment" warning */

#include <initguid.h>

#pragma warning(default:4001) /* "single line comment" warning */

#include <recguids.h>

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\inifile.h ===
/*
 * inifile.h - Initialization file processing module description.
 */


/* Types
 ********/

#ifdef DEBUG

/* .ini switch types */

typedef enum _iniswitchtype
{
   IST_BOOL,
   IST_DEC_INT,
   IST_UNS_DEC_INT
}
INISWITCHTYPE;
DECLARE_STANDARD_TYPES(INISWITCHTYPE);

/* boolean .ini switch */

typedef struct _booliniswitch
{
   INISWITCHTYPE istype;      /* must be IST_BOOL */

   LPCTSTR pcszKeyName;

   PDWORD pdwParentFlags;

   DWORD dwFlag;
}
BOOLINISWITCH;
DECLARE_STANDARD_TYPES(BOOLINISWITCH);

/* decimal integer .ini switch */

typedef struct _decintiniswitch
{
   INISWITCHTYPE istype;      /* must be IST_DEC_INT */

   LPCTSTR pcszKeyName;

   PINT pnValue;
}
DECINTINISWITCH;
DECLARE_STANDARD_TYPES(DECINTINISWITCH);

/* unsigned decimal integer .ini switch */

typedef struct _unsdecintiniswitch
{
   INISWITCHTYPE istype;      /* must be IST_UNS_DEC_INT */

   LPCTSTR pcszKeyName;

   PUINT puValue;
}
UNSDECINTINISWITCH;
DECLARE_STANDARD_TYPES(UNSDECINTINISWITCH);

#endif


/* Global Variables
 *******************/

#ifdef DEBUG

/* defined by client */

extern LPCTSTR GpcszIniFile;
extern LPCTSTR GpcszIniSection;

#endif


/* Prototypes
 *************/

#ifdef DEBUG

/* inifile.c */

extern BOOL SetIniSwitches(const PCVOID *, UINT);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\hndtrans.c ===
/*
 * hndtrans.c - Handle translation module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "sortsrch.h"


/* Macros
 *********/

#define ARRAY_ELEMENT(pht, ai)   ((((PHANDLETRANS)(hht))->hpHandlePairs)[(ai)])


/* Types
 ********/

/* handle translation unit */

typedef struct _handlepair
{
   HGENERIC hgenOld;
   HGENERIC hgenNew;
}
HANDLEPAIR;
DECLARE_STANDARD_TYPES(HANDLEPAIR);

/* handle translation structure */

typedef struct _handletrans
{
   /* pointer to array of handle translation units */

   HANDLEPAIR *hpHandlePairs;

   /* number of handle pairs in array */

   LONG lcTotalHandlePairs;

   /* number of used handle pairs in array */

   LONG lcUsedHandlePairs;
}
HANDLETRANS;
DECLARE_STANDARD_TYPES(HANDLETRANS);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE COMPARISONRESULT CompareHandlePairs(PCVOID, PCVOID);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCHANDLETRANS(PCHANDLETRANS);
PRIVATE_CODE BOOL IsValidPCHANDLEPAIR(PCHANDLEPAIR);

#endif


/*
** CompareHandlePairs()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE COMPARISONRESULT CompareHandlePairs(PCVOID pchp1, PCVOID pchp2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pchp1, CHANDLEPAIR));
   ASSERT(IS_VALID_STRUCT_PTR(pchp2, CHANDLEPAIR));

   if (((PHANDLEPAIR)pchp1)->hgenOld < ((PHANDLEPAIR)pchp2)->hgenOld)
      cr = CR_FIRST_SMALLER;
   else if (((PHANDLEPAIR)pchp1)->hgenOld > ((PHANDLEPAIR)pchp2)->hgenOld)
      cr = CR_FIRST_LARGER;
   else
      cr = CR_EQUAL;

   return(cr);
}


#ifdef VSTF

/*
** IsValidPCHANDLETRANS()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCHANDLETRANS(PCHANDLETRANS pcht)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pcht, CHANDLETRANS) &&
       EVAL(pcht->lcTotalHandlePairs >= 0) &&
       (EVAL(pcht->lcUsedHandlePairs >= 0) &&
        EVAL(pcht->lcUsedHandlePairs <= pcht->lcTotalHandlePairs)) &&
       IS_VALID_READ_BUFFER_PTR(pcht->hpHandlePairs, HANDLEPAIR, (UINT)(pcht->lcTotalHandlePairs)))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}


/*
** IsValidPCHANDLEPAIR()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCHANDLEPAIR(PCHANDLEPAIR pchp)
{
   return(IS_VALID_READ_PTR(pchp, CHANDLEPAIR));
}

#endif


/****************************** Public Functions *****************************/


/*
** CreateHandleTranslator()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreateHandleTranslator(LONG lcHandles, PHHANDLETRANS phht)
{
   PHANDLEPAIR hpHandlePairs;

   ASSERT(IS_VALID_WRITE_PTR(phht, HHANDLETRANS));

   *phht = NULL;

#ifdef DBLCHECK
   ASSERT((double)sizeof(HANDLEPAIR) * (double)lcHandles <= DWORD_MAX);
#endif

   if (AllocateMemory(sizeof(HANDLEPAIR) * lcHandles, &hpHandlePairs))
   {
      PHANDLETRANS phtNew;

      if (AllocateMemory(sizeof(*phtNew), &phtNew))
      {
         /* Success!  Fill in HANDLETRANS fields. */

         phtNew->hpHandlePairs = hpHandlePairs;
         phtNew->lcTotalHandlePairs = lcHandles;
         phtNew->lcUsedHandlePairs = 0;

         *phht = (HHANDLETRANS)phtNew;

         ASSERT(IS_VALID_HANDLE(*phht, HANDLETRANS));
      }
      else
         FreeMemory(hpHandlePairs);
   }

   return(*phht != NULL);
}


/*
** DestroyHandleTranslator()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyHandleTranslator(HHANDLETRANS hht)
{
   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));

   ASSERT(((PHANDLETRANS)hht)->hpHandlePairs);

   FreeMemory(((PHANDLETRANS)hht)->hpHandlePairs);

   FreeMemory((PHANDLETRANS)hht);

   return;
}


/*
** AddHandleToHandleTranslator()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL AddHandleToHandleTranslator(HHANDLETRANS hht,
                                               HGENERIC hgenOld,
                                               HGENERIC hgenNew)
{
   BOOL bRet;

   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));

   if (((PHANDLETRANS)hht)->lcUsedHandlePairs < ((PHANDLETRANS)hht)->lcTotalHandlePairs)
   {
      ARRAY_ELEMENT((PHANDLETRANS)hht, ((PHANDLETRANS)hht)->lcUsedHandlePairs).hgenOld = hgenOld;
      ARRAY_ELEMENT((PHANDLETRANS)hht, ((PHANDLETRANS)hht)->lcUsedHandlePairs).hgenNew = hgenNew;

      ((PHANDLETRANS)hht)->lcUsedHandlePairs++;

      bRet = TRUE;
   }
   else
      bRet = FALSE;

   return(bRet);
}


/*
** PrepareForHandleTranslation()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE void PrepareForHandleTranslation(HHANDLETRANS hht)
{
   HANDLEPAIR hpTemp;

   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));

   HeapSort(((PHANDLETRANS)hht)->hpHandlePairs,
            ((PHANDLETRANS)hht)->lcUsedHandlePairs,
            sizeof((((PHANDLETRANS)hht)->hpHandlePairs)[0]),
            &CompareHandlePairs,
            &hpTemp);

   return;
}


/*
** TranslateHandle()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL TranslateHandle(HHANDLETRANS hht, HGENERIC hgenOld,
                                   PHGENERIC phgenNew)
{
   BOOL bFound;
   HANDLEPAIR hpTemp;
   LONG liTarget;

   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));
   ASSERT(IS_VALID_WRITE_PTR(phgenNew, HGENERIC));

   hpTemp.hgenOld = hgenOld;

   bFound = BinarySearch(((PHANDLETRANS)hht)->hpHandlePairs,
                         ((PHANDLETRANS)hht)->lcUsedHandlePairs,
                         sizeof((((PHANDLETRANS)hht)->hpHandlePairs)[0]),
                         &CompareHandlePairs,
                         &hpTemp,
                         &liTarget);

   if (bFound)
   {
      ASSERT(liTarget < ((PHANDLETRANS)hht)->lcUsedHandlePairs);

      *phgenNew = ARRAY_ELEMENT((PHANDLETRANS)hht, liTarget).hgenNew;
   }

   return(bFound);
}


#ifdef DEBUG

/*
** IsValidHHANDLETRANS()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHHANDLETRANS(HHANDLETRANS hht)
{
   return(IS_VALID_STRUCT_PTR((PHANDLETRANS)hht, CHANDLETRANS));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\init.c ===
/*
 * init.c - DLL startup routines module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "init.h"


/****************************** Public Functions *****************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** LibMain()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL APIENTRY LibMain(HANDLE hModule, DWORD dwReason, PVOID pvReserved)
{
   BOOL bResult;

   DebugEntry(LibMain);

   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
         bResult = AttachProcess(hModule);
         break;

      case DLL_PROCESS_DETACH:
         bResult = DetachProcess(hModule);
         break;

      case DLL_THREAD_ATTACH:
         bResult = AttachThread(hModule);
         break;

      case DLL_THREAD_DETACH:
         bResult = DetachThread(hModule);
         break;

      default:
         ERROR_OUT((TEXT("LibMain() called with unrecognized dwReason %lu."),
                    dwReason));
         bResult = FALSE;
         break;
   }

   DebugExitBOOL(LibMain, bResult);

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\init.h ===
/*
 * init.h - DLL startup routines module description.
 */


/* Prototypes
 *************/

/* functions to be provided by client */

extern BOOL AttachProcess(HANDLE);
extern BOOL DetachProcess(HANDLE);
extern BOOL AttachThread(HANDLE);
extern BOOL DetachThread(HANDLE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\irecinit.c ===
/*
 * irecinit.c - CReconcileInitiator implementation.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "oleutil.h"
#include "irecinit.h"


/* Types
 ********/

/* ReconcileInitiator class */

typedef struct _creconcileinitiator
{
   /* IReconcileInitiator */

   IReconcileInitiator irecinit;

   /* IBriefcaseInitiator */

   IBriefcaseInitiator ibcinit;

   /* reference count */

   ULONG ulcRef;

   /* handle to parent briefcase */

   HBRFCASE hbr;

   /* status callback function */

   RECSTATUSPROC rsp;

   /* status callback function data */

   LPARAM lpCallbackData;

   /* IUnknown to release to abort reconciliation. */

   PIUnknown piunkForAbort;
}
CReconcileInitiator;
DECLARE_STANDARD_TYPES(CReconcileInitiator);


/* Module Prototypes
 ********************/

PRIVATE_CODE HRESULT ReconcileInitiator_QueryInterface(PCReconcileInitiator, REFIID, PVOID *);
PRIVATE_CODE ULONG ReconcileInitiator_AddRef(PCReconcileInitiator);
PRIVATE_CODE ULONG ReconcileInitiator_Release(PCReconcileInitiator);
PRIVATE_CODE HRESULT ReconcileInitiator_SetAbortCallback(PCReconcileInitiator, PIUnknown);
PRIVATE_CODE HRESULT ReconcileInitiator_SetProgressFeedback(PCReconcileInitiator, ULONG, ULONG);

PRIVATE_CODE HRESULT AbortReconciliation(PCReconcileInitiator);

PRIVATE_CODE HRESULT RI_IReconcileInitiator_QueryInterface(PIReconcileInitiator, REFIID, PVOID *);
PRIVATE_CODE ULONG RI_IReconcileInitiator_AddRef(PIReconcileInitiator);
PRIVATE_CODE ULONG RI_IReconcileInitiator_Release(PIReconcileInitiator);
PRIVATE_CODE HRESULT RI_IReconcileInitiator_SetAbortCallback(PIReconcileInitiator, PIUnknown);
PRIVATE_CODE HRESULT RI_IReconcileInitiator_SetProgressFeedback( PIReconcileInitiator, ULONG, ULONG);

PRIVATE_CODE HRESULT RI_IBriefcaseInitiator_QueryInterface(PIBriefcaseInitiator, REFIID, PVOID *);
PRIVATE_CODE ULONG RI_IBriefcaseInitiator_AddRef(PIBriefcaseInitiator);
PRIVATE_CODE ULONG RI_IBriefcaseInitiator_Release(PIBriefcaseInitiator);
PRIVATE_CODE HRESULT RI_IBriefcaseInitiator_IsMonikerInBriefcase(PIBriefcaseInitiator, PIMoniker);

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCCReconcileInitiator(PCCReconcileInitiator);
PRIVATE_CODE BOOL IsValidPCIBriefcaseInitiator(PCIBriefcaseInitiator);

#endif


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

/* IReconcileInitiator vtable */


PRIVATE_DATA IReconcileInitiatorVtbl Mcirecinitvtbl =
{
   &RI_IReconcileInitiator_QueryInterface,
   &RI_IReconcileInitiator_AddRef,
   &RI_IReconcileInitiator_Release,
   &RI_IReconcileInitiator_SetAbortCallback,
   &RI_IReconcileInitiator_SetProgressFeedback
};

/* IBriefcaseInitiator vtable */

PRIVATE_DATA IBriefcaseInitiatorVtbl Mcibcinitvtbl =
{
   &RI_IBriefcaseInitiator_QueryInterface,
   &RI_IBriefcaseInitiator_AddRef,
   &RI_IBriefcaseInitiator_Release,
   &RI_IBriefcaseInitiator_IsMonikerInBriefcase
};

#pragma data_seg()


/***************************** Private Functions *****************************/


/*
** ReconcileInitiator_QueryInterface()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT ReconcileInitiator_QueryInterface(
                                                PCReconcileInitiator precinit,
                                                REFIID riid, PVOID *ppvObject)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));
   //ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   if (IsEqualIID(riid, &IID_IUnknown) ||
       IsEqualIID(riid, &IID_IReconcileInitiator))
   {
      *ppvObject = &(precinit->irecinit);
      precinit->irecinit.lpVtbl->AddRef(&(precinit->irecinit));
      hr = S_OK;
   }
   else if (IsEqualIID(riid, &IID_IBriefcaseInitiator))
   {
      *ppvObject = &(precinit->ibcinit);
      precinit->ibcinit.lpVtbl->AddRef(&(precinit->ibcinit));
      hr = S_OK;
   }
   else
      hr = E_NOINTERFACE;

   return(hr);
}


/*
** ReconcileInitiator_AddRef()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG ReconcileInitiator_AddRef(PCReconcileInitiator precinit)
{
   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));

   ASSERT(precinit->ulcRef < ULONG_MAX);
   return(++(precinit->ulcRef));
}


/*
** ReconcileInitiator_Release()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG ReconcileInitiator_Release(PCReconcileInitiator precinit)
{
   ULONG ulcRef;

   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));

   if (EVAL(precinit->ulcRef > 0))
      precinit->ulcRef--;

   ulcRef = precinit->ulcRef;

   if (! precinit->ulcRef)
      FreeMemory(precinit);

   return(ulcRef);
}


/*
** ReconcileInitiator_SetAbortCallback()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT ReconcileInitiator_SetAbortCallback(
                                                PCReconcileInitiator precinit,
                                                PIUnknown piunkForAbort)
{
   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));
   /* piunkForAbort can be legally NULL */
   ASSERT(NULL == piunkForAbort || IS_VALID_STRUCT_PTR(piunkForAbort, CIUnknown));

   precinit->piunkForAbort = piunkForAbort;

   return(S_OK);
}


/*
** ReconcileInitiator_SetProgressFeedback()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT ReconcileInitiator_SetProgressFeedback(
                                                PCReconcileInitiator precinit,
                                                ULONG ulProgress,
                                                ULONG ulProgressMax)
{
   RECSTATUSUPDATE rsu;

   /* ulProgress may be any value. */
   /* ulProgressMax may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));

   rsu.ulScale = ulProgressMax;
   rsu.ulProgress = ulProgress;

   if (! NotifyReconciliationStatus(precinit->rsp, RS_DELTA_MERGE,
                                    (LPARAM)&rsu, precinit->lpCallbackData))
      AbortReconciliation(precinit);

   return(S_OK);
}


/*
** ReconcileInitiator_IsMonikerInBriefcase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT ReconcileInitiator_IsMonikerInBriefcase(
                                          PCReconcileInitiator precinit,
                                          PIMoniker pimk)
{
   HRESULT hr;
   PIMoniker pimkBriefcase;

   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));
   ASSERT(IS_VALID_STRUCT_PTR(pimk, CIMoniker));

   hr = GetBriefcaseRootMoniker(precinit->hbr, &pimkBriefcase);

   if (SUCCEEDED(hr))
   {
      PIMoniker pimkCommonPrefix;

      hr = pimk->lpVtbl->CommonPrefixWith(pimk, pimkBriefcase,
                                          &pimkCommonPrefix);

      if (SUCCEEDED(hr))
      {
         switch (hr)
         {
            case MK_S_US:
               WARNING_OUT(((TEXT("ReconcileInitiator_IsMonikerInBriefcase(): Called on briefcase root."))));
               /* Fall through... */
            case MK_S_HIM:
               hr = S_OK;
               break;

            default:
               ASSERT(hr == S_OK ||
                      hr == MK_S_ME);
               hr = S_FALSE;
               break;
         }

#ifdef DEBUG

         {
            PIBindCtx pibindctx;
            BOOL bGotMoniker = FALSE;
            BOOL bGotBriefcase = FALSE;
            PWSTR pwszMoniker;
            PWSTR pwszBriefcase;
            PIMalloc pimalloc;

            if (SUCCEEDED(CreateBindCtx(0, &pibindctx)))
            {
               bGotMoniker = SUCCEEDED(pimk->lpVtbl->GetDisplayName(
                                                               pimk, pibindctx,
                                                               NULL,
                                                               &pwszMoniker));

               bGotBriefcase = SUCCEEDED(pimkBriefcase->lpVtbl->GetDisplayName(
                                                            pimkBriefcase,
                                                            pibindctx, NULL,
                                                            &pwszBriefcase));

               pibindctx->lpVtbl->Release(pibindctx);
            }

            if (! bGotMoniker)
               pwszMoniker = (PWSTR)L"UNAVAILABLE DISPLAY NAME";

            if (! bGotBriefcase)
               pwszBriefcase = (PWSTR)L"UNAVAILABLE DISPLAY NAME";

            TRACE_OUT(((TEXT("ReconcileInitiator_IsMonikerInBriefcase(): Moniker %ls is %s briefcase %ls.")),
                       pwszMoniker,
                       (hr == S_OK) ? "in" : "not in",
                       pwszBriefcase));

            if (EVAL(GetIMalloc(&pimalloc)))
            {
               if (bGotMoniker)
                  pimalloc->lpVtbl->Free(pimalloc, pwszMoniker);

               if (bGotBriefcase)
                  pimalloc->lpVtbl->Free(pimalloc, pwszBriefcase);

               /* Do not release pimalloc. */
            }
         }

#endif

         /* Do not release pimkBriefcase. */
      }
   }

   return(hr);
}


/*
** AbortReconciliation()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT AbortReconciliation(PCReconcileInitiator precinit)
{
   ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));

   if (precinit->piunkForAbort)
      precinit->piunkForAbort->lpVtbl->Release(precinit->piunkForAbort);

   return(S_OK);
}


/*
** RI_IReconcileInitiator_QueryInterface()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT RI_IReconcileInitiator_QueryInterface(
                                                PIReconcileInitiator pirecinit,
                                                REFIID riid, PVOID *ppvObject)
{
   ASSERT(IS_VALID_STRUCT_PTR(pirecinit, CIReconcileInitiator));
   //ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   return(ReconcileInitiator_QueryInterface(
            ClassFromIface(CReconcileInitiator, irecinit, pirecinit),
            riid, ppvObject));
}


/*
** RI_IReconcileInitiator_AddRef()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG RI_IReconcileInitiator_AddRef(
                                                PIReconcileInitiator pirecinit)
{
   ASSERT(IS_VALID_STRUCT_PTR(pirecinit, CIReconcileInitiator));

   return(ReconcileInitiator_AddRef(
            ClassFromIface(CReconcileInitiator, irecinit, pirecinit)));
}


/*
** RI_IReconcileInitiator_Release()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG RI_IReconcileInitiator_Release(
                                                PIReconcileInitiator pirecinit)
{
   ASSERT(IS_VALID_STRUCT_PTR(pirecinit, CIReconcileInitiator));

   return(ReconcileInitiator_Release(
            ClassFromIface(CReconcileInitiator, irecinit, pirecinit)));
}


/*
** RI_IReconcileInitiator_SetAbortCallback()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT RI_IReconcileInitiator_SetAbortCallback(
                                                PIReconcileInitiator pirecinit,
                                                PIUnknown piunkForAbort)
{
   ASSERT(IS_VALID_STRUCT_PTR(pirecinit, CIReconcileInitiator));
   /* piunkForAbort can be legally NULL */
   ASSERT(NULL == piunkForAbort || IS_VALID_STRUCT_PTR(piunkForAbort, CIUnknown));

   return(ReconcileInitiator_SetAbortCallback(
            ClassFromIface(CReconcileInitiator, irecinit, pirecinit),
            piunkForAbort));
}


/*
** RI_IReconcileInitiator_SetProgressFeedback()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT RI_IReconcileInitiator_SetProgressFeedback(
                                                PIReconcileInitiator pirecinit,
                                                ULONG ulProgress,
                                                ULONG ulProgressMax)
{
   /* ulProgress may be any value. */
   /* ulProgressMax may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pirecinit, CIReconcileInitiator));

   return(ReconcileInitiator_SetProgressFeedback(
            ClassFromIface(CReconcileInitiator, irecinit, pirecinit),
            ulProgress, ulProgressMax));
}


/*
** RI_IBriefcaseInitiator_QueryInterface()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT RI_IBriefcaseInitiator_QueryInterface(
                                                PIBriefcaseInitiator pibcinit,
                                                REFIID riid, PVOID *ppvObject)
{
   ASSERT(IS_VALID_STRUCT_PTR(pibcinit, CIBriefcaseInitiator));
   //ASSERT(IsValidREFIID(riid));
   ASSERT(IS_VALID_WRITE_PTR(ppvObject, PVOID));

   return(ReconcileInitiator_QueryInterface(
            ClassFromIface(CReconcileInitiator, ibcinit, pibcinit),
            riid, ppvObject));
}


/*
** RI_IBriefcaseInitiator_AddRef()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG RI_IBriefcaseInitiator_AddRef(PIBriefcaseInitiator pibcinit)
{
   ASSERT(IS_VALID_STRUCT_PTR(pibcinit, CIBriefcaseInitiator));

   return(ReconcileInitiator_AddRef(
            ClassFromIface(CReconcileInitiator, ibcinit, pibcinit)));
}


/*
** RI_IBriefcaseInitiator_Release()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG RI_IBriefcaseInitiator_Release(
                                                PIBriefcaseInitiator pibcinit)
{
   ASSERT(IS_VALID_STRUCT_PTR(pibcinit, CIBriefcaseInitiator));

   return(ReconcileInitiator_Release(
            ClassFromIface(CReconcileInitiator, ibcinit, pibcinit)));
}


/*
** RI_IBriefcaseInitiator_IsMonikerInBriefcase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT RI_IBriefcaseInitiator_IsMonikerInBriefcase(
                                                PIBriefcaseInitiator pibcinit,
                                                PIMoniker pmk)
{
   ASSERT(IS_VALID_STRUCT_PTR(pibcinit, CIBriefcaseInitiator));
   ASSERT(IS_VALID_STRUCT_PTR(pmk, CIMoniker));

   return(ReconcileInitiator_IsMonikerInBriefcase(
            ClassFromIface(CReconcileInitiator, ibcinit, pibcinit),
            pmk));
}


#ifdef DEBUG

/*
** IsValidPCCReconcileInitiator()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCCReconcileInitiator(PCCReconcileInitiator pcrecinit)
{
   /* ulcRef may be any value. */
   /* lpCallbackData may be any value. */

   return(IS_VALID_READ_PTR(pcrecinit, CCReconcileInitiator) &&
          IS_VALID_STRUCT_PTR(&(pcrecinit->irecinit), CIReconcileInitiator) &&
          IS_VALID_STRUCT_PTR(&(pcrecinit->ibcinit), CIBriefcaseInitiator) &&
          IS_VALID_HANDLE(pcrecinit->hbr, BRFCASE) &&
          (! pcrecinit->rsp ||
           IS_VALID_CODE_PTR(pcrecinit->rsp, RECSTATUSPROC)) &&
          (! pcrecinit->piunkForAbort ||
           IS_VALID_STRUCT_PTR(pcrecinit->piunkForAbort, CIUnknown)));
}


/*
** IsValidPCIBriefcaseInitiator()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCIBriefcaseInitiator(PCIBriefcaseInitiator pcibcinit)
{
   return(IS_VALID_READ_PTR(pcibcinit, CIBriefcaseInitiator) &&
          IS_VALID_READ_PTR(pcibcinit->lpVtbl, sizeof(*(pcibcinit->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcibcinit, CIUnknown) &&
          IS_VALID_CODE_PTR(pcibcinit->lpVtbl->IsMonikerInBriefcase, IsMonikerInBriefcase));
}

#endif


/****************************** Public Functions *****************************/


/*
** IReconcileInitiator_Constructor()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT IReconcileInitiator_Constructor(
                                             HBRFCASE hbr, RECSTATUSPROC rsp,
                                             LPARAM lpCallbackData,
                                             PIReconcileInitiator *ppirecinit)
{
   HRESULT hr;
   PCReconcileInitiator precinit;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
   ASSERT(IS_VALID_WRITE_PTR(ppirecinit, PIReconcileInitiator));

   if (AllocateMemory(sizeof(*precinit), &precinit))
   {
      precinit->irecinit.lpVtbl = &Mcirecinitvtbl;
      precinit->ibcinit.lpVtbl = &Mcibcinitvtbl;
      precinit->ulcRef = 0;
      precinit->hbr = hbr;
      precinit->rsp = rsp;
      precinit->lpCallbackData = lpCallbackData;
      precinit->piunkForAbort = NULL;

      ASSERT(IS_VALID_STRUCT_PTR(precinit, CCReconcileInitiator));

      hr = precinit->irecinit.lpVtbl->QueryInterface(
               &(precinit->irecinit), &IID_IReconcileInitiator, ppirecinit);

      ASSERT(hr == S_OK);
   }
   else
      hr = E_OUTOFMEMORY;

   ASSERT(FAILED(hr) ||
          IS_VALID_STRUCT_PTR(*ppirecinit, CIReconcileInitiator));

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\inifile.c ===
/*
 * inifile.c - Initialization file processing module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Constants
 ************/

/* maximum length of .ini switch RHS */

#define MAX_INI_SWITCH_RHS_LEN      MAX_PATH_LEN


/* Module Variables
 *******************/

#ifdef DEBUG

#pragma data_seg(DATA_SEG_READ_ONLY)

/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

PRIVATE_DATA const LPCTSTR MrgcpcszTrue[] =
{
   TEXT("1"),
   TEXT("On"),
   TEXT("True"),
   TEXT("Y"),
   TEXT("Yes")
};

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

PRIVATE_DATA const LPCTSTR MrgcpcszFalse[] =
{
   TEXT("0"),
   TEXT("Off"),
   TEXT("False"),
   TEXT("N"),
   TEXT("No")
};

#pragma data_seg()

#endif


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE BOOL SetBOOLIniSwitch(PCBOOLINISWITCH);
PRIVATE_CODE BOOL SetDecimalIntIniSwitch(PCDECINTINISWITCH);
PRIVATE_CODE BOOL SetIniSwitch(PCVOID);
PRIVATE_CODE BOOL IsYesString(LPCTSTR);
PRIVATE_CODE BOOL IsNoString(LPCTSTR);
PRIVATE_CODE BOOL IsStringInList(LPCTSTR, const LPCTSTR *, UINT);
PRIVATE_CODE BOOL IsValidPCBOOLINISWITCH(PCBOOLINISWITCH);
PRIVATE_CODE BOOL IsValidPCDECINTINISWITCH(PCDECINTINISWITCH);
PRIVATE_CODE BOOL IsValidPCUNSDECINTINISWITCH(PCUNSDECINTINISWITCH);

#endif


#ifdef DEBUG

/*
** SetBOOLIniSwitch()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetBOOLIniSwitch(PCBOOLINISWITCH pcbis)
{
   DWORD dwcbKeyLen;
   TCHAR rgchRHS[MAX_INI_SWITCH_RHS_LEN];

   ASSERT(IS_VALID_STRUCT_PTR(pcbis, CBOOLINISWITCH));

   /* Set boolean .ini switch. */

   dwcbKeyLen = GetPrivateProfileString(GpcszIniSection, pcbis->pcszKeyName,
                                        TEXT(""), rgchRHS, ARRAYSIZE(rgchRHS),
                                        GpcszIniFile);

   /* Is the .ini switch set? */

   if (rgchRHS[0])
   {
      /* Yes.  Set or clear flag? */

      if (IsYesString(rgchRHS))
      {
         /* Set flag. */

         if (IS_FLAG_CLEAR(*(pcbis->pdwParentFlags), pcbis->dwFlag))
         {
            SET_FLAG(*(pcbis->pdwParentFlags), pcbis->dwFlag);

            WARNING_OUT((TEXT("SetBOOLIniSwitch(): %s set in %s![%s]."),
                         pcbis->pcszKeyName,
                         GpcszIniFile,
                         GpcszIniSection));
         }
      }
      else if (IsNoString(rgchRHS))
      {
         /* Clear flag. */

         if (IS_FLAG_SET(*(pcbis->pdwParentFlags), pcbis->dwFlag))
         {
            CLEAR_FLAG(*(pcbis->pdwParentFlags), pcbis->dwFlag);

            WARNING_OUT((TEXT("SetBOOLIniSwitch(): %s cleared in %s![%s]."),
                         pcbis->pcszKeyName,
                         GpcszIniFile,
                         GpcszIniSection));
         }
      }
      else
         /* Unknown flag. */
         WARNING_OUT((TEXT("SetBOOLIniSwitch(): Found unknown Boolean RHS %s for %s in %s![%s]."),
                      rgchRHS,
                      pcbis->pcszKeyName,
                      GpcszIniFile,
                      GpcszIniSection));
   }

   return(TRUE);
}


/*
** SetDecimalIntIniSwitch()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetDecimalIntIniSwitch(PCDECINTINISWITCH pcdiis)
{
   INT nNewValue;

   ASSERT(IS_VALID_STRUCT_PTR(pcdiis, CDECINTINISWITCH));

   /* Get decimal integer .ini switch. */

   nNewValue = GetPrivateProfileInt(GpcszIniSection, pcdiis->pcszKeyName,
                                    *(pcdiis->pnValue), GpcszIniFile);

   /* New value? */

   if (nNewValue != *(pcdiis->pnValue))
   {
      /* Yes. */

      *(pcdiis->pnValue) = nNewValue;

      WARNING_OUT((TEXT("SetDecimalIntIniSwitch(): %s set to %d in %s![%s]."),
                   pcdiis->pcszKeyName,
                   *(pcdiis->pnValue),
                   GpcszIniFile,
                   GpcszIniSection));
   }

   return(TRUE);
}


/*
** SetUnsignedDecimalIntIniSwitch()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetUnsignedDecimalIntIniSwitch(PCUNSDECINTINISWITCH pcudiis)
{
   INT nNewValue;

   ASSERT(IS_VALID_STRUCT_PTR(pcudiis, CUNSDECINTINISWITCH));

   /* Get unsigned decimal integer .ini switch as signed decimal integer. */

   ASSERT(*(pcudiis->puValue) <= INT_MAX);

   nNewValue = GetPrivateProfileInt(GpcszIniSection, pcudiis->pcszKeyName,
                                    *(pcudiis->puValue), GpcszIniFile);

   if (nNewValue >= 0)
   {
      if ((UINT)nNewValue != *(pcudiis->puValue))
      {
         /* New non-negative value. */

         *(pcudiis->puValue) = nNewValue;

         WARNING_OUT((TEXT("SetUnsignedDecimalIntIniSwitch(): %s set to %u in %s![%s]."),
                      pcudiis->pcszKeyName,
                      *(pcudiis->puValue),
                      GpcszIniFile,
                      GpcszIniSection));
      }
   }
   else
      /* Negative value. */
      WARNING_OUT((TEXT("SetUnsignedDecimalIntIniSwitch(): Unsigned value %s set to %d in %s![%s].  Ignored."),
                   pcudiis->pcszKeyName,
                   nNewValue,
                   GpcszIniFile,
                   GpcszIniSection));

   return(TRUE);
}


/*
** SetIniSwitch()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetIniSwitch(PCVOID pcvIniSwitch)
{
   BOOL bResult;

   ASSERT(IS_VALID_READ_PTR((PCINISWITCHTYPE)pcvIniSwitch, CINISWITCHTYPE));

   /* Set .ini switch based upon type. */

   switch (*(PCINISWITCHTYPE)pcvIniSwitch)
   {
      case IST_BOOL:
         bResult = SetBOOLIniSwitch(pcvIniSwitch);
         break;

      case IST_DEC_INT:
         bResult = SetDecimalIntIniSwitch(pcvIniSwitch);
         break;

      case IST_UNS_DEC_INT:
         bResult = SetUnsignedDecimalIntIniSwitch(pcvIniSwitch);
         break;

      default:
         ERROR_OUT((TEXT("SetIniSwitch(): Unrecognized .ini switch type %d."),
                    *(PCINISWITCHTYPE)pcvIniSwitch));
         bResult = FALSE;
         break;
   }

   return(bResult);
}


/*
** IsYesString()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsYesString(LPCTSTR pcsz)
{
   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(IsStringInList(pcsz, MrgcpcszTrue, ARRAY_ELEMENTS(MrgcpcszTrue)));
}


/*
** IsNoString()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsNoString(LPCTSTR pcsz)
{
   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(IsStringInList(pcsz, MrgcpcszFalse, ARRAY_ELEMENTS(MrgcpcszFalse)));
}


/*
** IsStringInList()
**
** Determines whether or not a given string matches a string in a list of
** strings.
**
** Arguments:     pcsz - pointer to string to be checked
**
** Returns:       
**
** Side Effects:  none
**
** N.b., string comparison is case-insensitive.
*/
PRIVATE_CODE BOOL IsStringInList(LPCTSTR pcsz, const LPCTSTR *pcpcszList,
                            UINT ucbStrings)
{
   UINT u;
   BOOL bFound = FALSE;

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(IS_VALID_READ_BUFFER_PTR(pcpcszList, LPCTSTR, ucbStrings * sizeof(*pcpcszList)));

   /* Search the list for the given string. */

   for (u = 0; u < ucbStrings; u++)
   {
      ASSERT(IS_VALID_STRING_PTR(pcpcszList[u], CSTR));

      if (! lstrcmpi(pcsz, pcpcszList[u]))
      {
         bFound = TRUE;
         break;
      }
   }

   return(bFound);
}


/*
** IsValidPCBOOLINIKEY()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCBOOLINISWITCH(PCBOOLINISWITCH pcbis)
{
   return(IS_VALID_READ_PTR(pcbis, CBOOLINISWITCH) &&
          EVAL(pcbis->istype == IST_BOOL) &&
          IS_VALID_STRING_PTR(pcbis->pcszKeyName, CSTR) &&
          IS_VALID_WRITE_PTR(pcbis->pdwParentFlags, DWORD) &&
          EVAL(pcbis->dwFlag));
}


/*
** IsValidPCDECINTINISWITCH()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCDECINTINISWITCH(PCDECINTINISWITCH pcdiis)
{
   return(IS_VALID_READ_PTR(pcdiis, CDECINTINISWITCH) &&
          EVAL(pcdiis->istype == IST_DEC_INT) &&
          IS_VALID_STRING_PTR(pcdiis->pcszKeyName, CSTR) &&
          IS_VALID_WRITE_PTR(pcdiis->pnValue, INT));
}


/*
** IsValidPCUNSDECINTINISWITCH()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCUNSDECINTINISWITCH(PCUNSDECINTINISWITCH pcudiis)
{
   return(IS_VALID_READ_PTR(pcudiis, CUNSDECINTINISWITCH) &&
          EVAL(pcudiis->istype == IST_UNS_DEC_INT) &&
          IS_VALID_STRING_PTR(pcudiis->pcszKeyName, CSTR) &&
          IS_VALID_WRITE_PTR(pcudiis->puValue, UINT));
}

#endif


/****************************** Public Functions *****************************/


#ifdef DEBUG

/*
** SetIniSwitches()
**
** Set flags from initialization file.
**
** Arguments:     ppcvIniSwitches - pointer to array of pointers to .ini switch
**                                  structures describing .ini switches to set
**                ucSwitches - number of .ini switch pointers in
**                             ppcvIniSwitches array
**
** Returns:       TRUE if .ini switch processing is successful.  FALSE if not.
**
** Side Effects:  none
**
** N.b, the global variables GpcszIniFile and GpcszIniSection must be filled in
** before calling SetIniSwitches().
*/
PUBLIC_CODE BOOL SetIniSwitches(const PCVOID *pcpcvIniSwitches, UINT ucSwitches)
{
   BOOL bResult = TRUE;
   UINT u;

   ASSERT(IS_VALID_READ_BUFFER_PTR(pcpcvIniSwitches, const PCVOID, ucSwitches * sizeof(*pcpcvIniSwitches)));

   /* Process .ini switches. */

   for (u = 0; u < ucSwitches; u++)
      bResult = SetIniSwitch(pcpcvIniSwitches[u]) && bResult;

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\irecinit.h ===
/*
 * irecinit.h - IReconcileInitiator implementation description.
 */


/* Prototypes
 *************/

/* irecinit.c */

extern HRESULT IReconcileInitiator_Constructor(HBRFCASE, RECSTATUSPROC, LPARAM, PIReconcileInitiator *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\list.h ===
/*
 * list.h - List ADT description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HLIST);
DECLARE_STANDARD_TYPES(HLIST);

DECLARE_HANDLE(HNODE);
DECLARE_STANDARD_TYPES(HNODE);

/*
 * sorted list node comparison callback function
 *
 * The first pointer is reference data and the second pointer is a list node
 * data element.
 */

typedef COMPARISONRESULT (*COMPARESORTEDNODESPROC)(PCVOID, PCVOID);

/*
 * unsorted list node comparison callback function
 *
 * The first pointer is reference data and the second pointer is a list node
 * data element.
 */

typedef BOOL (*COMPAREUNSORTEDNODESPROC)(PCVOID, PCVOID);

/*
 * WalkList() callback function - called as:
 *
 *    bContinue = WalkList(pvNodeData, pvRefData);
 */

typedef BOOL (*WALKLIST)(PVOID, PVOID);

/* new list flags */

typedef enum _newlistflags
{
   /* Insert nodes in sorted order. */

   NL_FL_SORTED_ADD        = 0x0001,

   /* flag combinations */

   ALL_NL_FLAGS            = NL_FL_SORTED_ADD
}
NEWLISTFLAGS;

/* new list description */

typedef struct _newlist
{
   DWORD dwFlags;
}
NEWLIST;
DECLARE_STANDARD_TYPES(NEWLIST);


/* Prototypes
 *************/

/* list.c */

extern BOOL CreateList(PCNEWLIST, PHLIST);
extern void DestroyList(HLIST);
extern BOOL AddNode(HLIST, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL InsertNodeAtFront(HLIST, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL InsertNodeBefore(HNODE, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL InsertNodeAfter(HNODE, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern void DeleteNode(HNODE);
extern void DeleteAllNodes(HLIST);
extern PVOID GetNodeData(HNODE);
extern void SetNodeData(HNODE, PCVOID);
extern ULONG GetNodeCount(HLIST);
extern BOOL IsListEmpty(HLIST);
extern BOOL GetFirstNode(HLIST, PHNODE);
extern BOOL GetNextNode(HNODE, PHNODE);
extern BOOL GetPrevNode(HNODE, PHNODE);
extern void AppendList(HLIST, HLIST);
extern BOOL SearchSortedList(HLIST, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL SearchUnsortedList(HLIST, COMPAREUNSORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL WalkList(HLIST, WALKLIST, PVOID);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidHLIST(HLIST);
extern BOOL IsValidHNODE(HNODE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\memmgr.h ===
/*
 * memmgr.h - Memory manager module description.
 */


/* Macros
 *********/

#ifdef DEBUG
#define AllocateMemory(size, ppv)   (GpcszElemHdrSize = TEXT(#size), GpcszElemHdrFile = TEXT(__FILE__), GulElemHdrLine = __LINE__, MyAllocateMemory(size, ppv))
#else
#define AllocateMemory(size, ppv)   MyAllocateMemory(size, ppv)
#endif   /* DEBUG */


/* Types
 ********/

#ifdef DEBUG

/* SpewHeapSummary() flags */

typedef enum _spewheapsummaryflags
{
   /* Spew description of each remaining used element. */

   SHS_FL_SPEW_USED_INFO            = 0x0001,

   /* flag combinations */

   ALL_SHS_FLAGS                    = SHS_FL_SPEW_USED_INFO
}
SPEWHEAPSUMMARYFLAGS;

#endif


/* Prototypes
 *************/

/* memmgr.c */

extern BOOL InitMemoryManagerModule(void);
extern void ExitMemoryManagerModule(void);

extern COMPARISONRESULT MyMemComp(PCVOID, PCVOID, DWORD);
extern BOOL MyAllocateMemory(DWORD, PVOID *);
extern void FreeMemory(PVOID);
extern BOOL ReallocateMemory(PVOID, DWORD, PVOID *);
extern DWORD GetMemorySize(PVOID);

#ifdef DEBUG

extern BOOL SetMemoryManagerModuleIniSwitches(void);
extern void SpewHeapSummary(DWORD);

#endif


/* Global Variables
 *******************/

#ifdef DEBUG

/* parameters used by debug version of AllocateMemory() */

extern LPCTSTR GpcszElemHdrSize;
extern LPCTSTR GpcszElemHdrFile;
extern ULONG GulElemHdrLine;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\memmgr.c ===
/*
 * memmgr.c - Memory manager module.
 */

/*

   The memory manager implementation in this module uses either a private
shared heap (if PRIVATE_HEAP is #defined) or the non-shared process heap (if
PRIVATE_HEAP is not #defined).  Thde debug implementation of this memory
manager keeps track of memory blocks allocated from the heap using a
doubly-linked list of heap element nodes.  Each node describes one allocated
heap element.

   Debug heap elements are allocated with extra space at the beginning and end
of the element.  Prefix and suffix sentinels surround each allocated heap
element.  New heap elements are filled with UNINITIALIZED_BYTE_VALUE.  Freed
heap elements are filled with FREED_BYTE_VALUE.  The new tails of grown heap
elements are filled with UNINITIALIZED_BYTE_VALUE.

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Constants
 ************/

#ifdef PRIVATE_HEAP

/* undocumented flag for HeapCreate() from kernel32.h */


#define HEAP_SHARED                 (0x04000000)

/*
 * Set maximum shared heap size used for CreateHeap() to 0 since we don't know
 * how big the heap may get, and we don't want to restrict its size
 * artificially.  BrianSm says this is ok.
 */

#define MAX_SHARED_HEAP_SIZE        (0)

#endif   /* PRIVATE_HEAP */

#ifdef DEBUG

/* heap element byte fill values */

#define UNINITIALIZED_BYTE_VALUE    (0xcc)
#define FREED_BYTE_VALUE            (0xdd)

#endif   /* DEBUG */


/* Macros
 *********/

/* atomic memory management function wrappers for translation */

#ifdef PRIVATE_HEAP

#define GetHeap()                   (Mhheap)
#define MEMALLOCATE(size)           HeapAlloc(GetHeap(), 0, (size))
#define MEMREALLOCATE(pv, size)     HeapReAlloc(GetHeap(), 0, (pv), (size))
#define MEMFREE(pv)                 HeapFree(GetHeap(), 0, (pv))
#define MEMSIZE(pv)                 HeapSize(GetHeap(), 0, (pv))

#else

#define MEMALLOCATE(size)           LocalAlloc(LMEM_FIXED, (size))
#define MEMREALLOCATE(pv, size)     LocalReAlloc((pv), (size), 0)
#define MEMFREE(pv)                 (! LocalFree(pv))
#define MEMSIZE(pv)                 LocalSize(pv)

#endif


/* Types
 ********/

#ifdef DEBUG

/* heap element descriptor structure */

typedef struct _heapelemdesc
{
   TCHAR rgchSize[6];       /* enough for 99,999 lines */
   TCHAR rgchFile[24];      
   ULONG ulLine;
}
HEAPELEMDESC;
DECLARE_STANDARD_TYPES(HEAPELEMDESC);

/* heap node */

typedef struct _heapnode
{
   PCVOID pcv;
   DWORD dwcbSize;
   struct _heapnode *phnPrev;
   struct _heapnode *phnNext;
   HEAPELEMDESC hed;
}
HEAPNODE;
DECLARE_STANDARD_TYPES(HEAPNODE);

/* heap */

typedef struct _heap
{
   HEAPNODE hnHead;
}
HEAP;
DECLARE_STANDARD_TYPES(HEAP);

/* heap summary filled in by AnalyzeHeap() */

typedef struct _heapsummary
{
   ULONG ulcUsedElements;
   DWORD dwcbUsedSize;
}
HEAPSUMMARY;
DECLARE_STANDARD_TYPES(HEAPSUMMARY);

/* debug flags */

typedef enum _memmgrdebugflags
{
   MEMMGR_DFL_VALIDATE_HEAP_ON_ENTRY   = 0x0001,

   MEMMGR_DFL_VALIDATE_HEAP_ON_EXIT    = 0x0002,

   ALL_MEMMGR_DFLAGS                   = (MEMMGR_DFL_VALIDATE_HEAP_ON_ENTRY |
                                          MEMMGR_DFL_VALIDATE_HEAP_ON_EXIT)
}
MEMMGRDEBUGFLAGS;

#endif   /* DEBUG */


/* Global Variables
 *******************/

#ifdef DEBUG

#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* parameters used by debug AllocateMemory() macro */

PUBLIC_DATA LPCTSTR GpcszElemHdrSize = NULL;
PUBLIC_DATA LPCTSTR GpcszElemHdrFile = NULL;
PUBLIC_DATA ULONG GulElemHdrLine = 0;

#pragma data_seg()

#endif   /* DEBUG */


/* Module Variables
 *******************/

#ifdef PRIVATE_HEAP

#pragma data_seg(DATA_SEG_SHARED)

/* handle to global shared heap */

PRIVATE_DATA HANDLE Mhheap = NULL;

#pragma data_seg()

#endif   /* PRIVATE_HEAP */

#ifdef DEBUG

#ifdef PRIVATE_HEAP
#pragma data_seg(DATA_SEG_SHARED)
#else
#pragma data_seg(DATA_SEG_PER_INSTANCE)
#endif   /* PRIVATE_HEAP */

/* heap */

PRIVATE_DATA PHEAP Mpheap = NULL;

#pragma data_seg(DATA_SEG_SHARED)

/* debug flags */

PRIVATE_DATA DWORD MdwMemoryManagerModuleFlags = 0;

#pragma data_seg(DATA_SEG_READ_ONLY)

/* heap element sentinels */

PRIVATE_DATA CONST struct
{
   BYTE rgbyte[4];
}
MchsPrefix =
{
   { TEXT('H'), TEXT('E'), TEXT('A'), TEXT('D') }
};

PRIVATE_DATA CONST struct
{
   BYTE rgbyte[4];
}
MchsSuffix =
{
   { TEXT('T'), TEXT('A'), TEXT('I'), TEXT('L') }
};

/* .ini file switch descriptions */

PRIVATE_DATA CBOOLINISWITCH cbisValidateHeapOnEntry =
{
   IST_BOOL,
   TEXT("ValidateHeapOnEntry"),
   &MdwMemoryManagerModuleFlags,
   MEMMGR_DFL_VALIDATE_HEAP_ON_ENTRY
};

PRIVATE_DATA CBOOLINISWITCH cbisValidateHeapOnExit =
{
   IST_BOOL,
   TEXT("ValidateHeapOnExit"),
   &MdwMemoryManagerModuleFlags,
   MEMMGR_DFL_VALIDATE_HEAP_ON_EXIT
};

PRIVATE_DATA const PCVOID MrgcpcvisMemoryManagerModule[] =
{
   &cbisValidateHeapOnEntry,
   &cbisValidateHeapOnExit
};

#pragma data_seg()

#endif   /* DEBUG */


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE DWORD CalculatePrivateSize(DWORD);
PRIVATE_CODE PVOID GetPrivateHeapPtr(PVOID);
PRIVATE_CODE PVOID GetPublicHeapPtr(PVOID);
PRIVATE_CODE DWORD GetHeapSize(PCVOID);
PRIVATE_CODE BOOL AddHeapElement(PCVOID, DWORD);
PRIVATE_CODE void RemoveHeapElement(PCVOID);
PRIVATE_CODE void ModifyHeapElement(PCVOID, PCVOID, DWORD);
PRIVATE_CODE BOOL FindHeapElement(PCVOID, PHEAPNODE *);
PRIVATE_CODE void FillNewMemory(PBYTE, DWORD, DWORD);
PRIVATE_CODE void FillFreedMemory(PBYTE, DWORD);
PRIVATE_CODE void FillGrownMemory(PBYTE, DWORD, DWORD, DWORD);
PRIVATE_CODE void FillShrunkenMemory(PBYTE, DWORD, DWORD, DWORD);
PRIVATE_CODE BOOL IsValidHeapPtr(PCVOID);
PRIVATE_CODE BOOL IsHeapOK(void);
PRIVATE_CODE BOOL IsValidPCHEAPNODE(PCHEAPNODE);
PRIVATE_CODE BOOL IsValidPCHEAPELEMDESC(PCHEAPELEMDESC);
PRIVATE_CODE BOOL IsValidHeapElement(PCBYTE, DWORD, DWORD);
PRIVATE_CODE void SpewHeapElementInfo(PCHEAPNODE);
PRIVATE_CODE void AnalyzeHeap(PHEAPSUMMARY, DWORD);

#endif   /* DEBUG */


#ifdef PRIVATE_HEAP

/*
** InitPrivateHeapModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL InitPrivateHeapModule(void)
{
   BOOL bResult;
   SYSTEM_INFO si;

   ASSERT(! Mhheap);

   /* Create shared heap. */

   GetSystemInfo(&si);

   #ifdef WINNT
   Mhheap = HeapCreate(0, si.dwPageSize, MAX_SHARED_HEAP_SIZE);
#else      
   Mhheap = HeapCreate(HEAP_SHARED, si.dwPageSize, MAX_SHARED_HEAP_SIZE);
#endif

   if (Mhheap)
   {

#ifdef DEBUG

      ASSERT(! Mpheap);

      Mpheap = MEMALLOCATE(sizeof(*Mpheap));
      
      if (Mpheap)
      {
         FillMemory(Mpheap, sizeof(*Mpheap), 0);
         bResult = TRUE;

         TRACE_OUT((TEXT("InitMemoryManagerModule(): Created shared heap, initial size == %lu, maximum size == %lu."),
                    si.dwPageSize,
                    MAX_SHARED_HEAP_SIZE));
      }
      else
      {
         EVAL(HeapDestroy(Mhheap));
         Mhheap = NULL;
         bResult = FALSE;

         WARNING_OUT((TEXT("InitMemoryManagerModule(): Failed to create shared heap head.")));
      }

#else    /* DEBUG */

      bResult = TRUE;

#endif   /* DEBUG */
         
   }
   else
   {
      bResult = FALSE;

      WARNING_OUT((TEXT("InitMemoryManagerModule(): Failed to create shared heap.")));
   }

   return(bResult);
}


#else    /* PRIVATE_HEAP */


/*
** InitHeapModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL InitHeapModule(void)
{
   BOOL bResult;

#ifdef DEBUG

   ASSERT(! Mpheap);

   Mpheap = MEMALLOCATE(sizeof(*Mpheap));
   
   if (Mpheap)
   {
      FillMemory(Mpheap, sizeof(*Mpheap), 0);

      TRACE_OUT((TEXT("InitMemoryManagerModule(): Created heap.")));
   }
   else
      WARNING_OUT((TEXT("InitMemoryManagerModule(): Failed to create heap head.")));
         
   bResult = (Mpheap != NULL);

#else

   bResult = TRUE;

#endif

   return(bResult);
}


#endif   /* PRIVATE_HEAP */


#ifdef DEBUG

/*
** CalculatePrivateSize()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE DWORD CalculatePrivateSize(DWORD dwcbPublicSize)
{
   ASSERT(dwcbPublicSize <= DWORD_MAX - sizeof(MchsPrefix) - sizeof(MchsSuffix));

   return(dwcbPublicSize + sizeof(MchsPrefix) + sizeof(MchsSuffix));
}


/*
** GetPrivateHeapPtr()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE PVOID GetPrivateHeapPtr(PVOID pvPublic)
{
   ASSERT((ULONG)pvPublic > sizeof(MchsPrefix));

   return((PBYTE)pvPublic - sizeof(MchsPrefix));
}


/*
** GetPublicHeapPtr()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE PVOID GetPublicHeapPtr(PVOID pvPrivate)
{
   ASSERT((PCBYTE)pvPrivate <= (PCBYTE)PTR_MAX - sizeof(MchsPrefix));

   return((PBYTE)pvPrivate + sizeof(MchsPrefix));
}


/*
** GetHeapSize()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE DWORD GetHeapSize(PCVOID pcv)
{
   PHEAPNODE phn;
   DWORD dwcbSize;

   if (EVAL(FindHeapElement(pcv, &phn)))
      dwcbSize = phn->dwcbSize;
   else
      dwcbSize = 0;

   return(dwcbSize);
}


/*
** AddHeapElement()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Assumes that the global variables GpcszElemHdrSize, GpcszElemHdrFile, and
** GulElemHdrLine are filled in.
*/
PRIVATE_CODE BOOL AddHeapElement(PCVOID pcvNew, DWORD dwcbSize)
{
   PHEAPNODE phnNew;

   /* Is the new heap element already in the list? */

   ASSERT(! FindHeapElement(pcvNew, &phnNew));

   if (Mpheap)
   {
      /* Create new heap node. */

      phnNew = MEMALLOCATE(sizeof(*phnNew));

      if (phnNew)
      {
         /* Fill in heap node fields. */

         phnNew->pcv = pcvNew;
         phnNew->dwcbSize = dwcbSize;

         /* Insert heap node at front of list. */

         phnNew->phnNext = Mpheap->hnHead.phnNext;
         phnNew->phnPrev = &(Mpheap->hnHead);
         Mpheap->hnHead.phnNext = phnNew;

         if (phnNew->phnNext)
            phnNew->phnNext->phnPrev = phnNew;

         /* Fill in heap element descriptor fields. */

         MyLStrCpyN(phnNew->hed.rgchSize, GpcszElemHdrSize, ARRAYSIZE(phnNew->hed.rgchSize));
         MyLStrCpyN(phnNew->hed.rgchFile, GpcszElemHdrFile, ARRAYSIZE(phnNew->hed.rgchFile));
         phnNew->hed.ulLine = GulElemHdrLine;

         ASSERT(IS_VALID_STRUCT_PTR(phnNew, CHEAPNODE));
      }
   }
   else
      phnNew = NULL;

   return(phnNew != NULL);
}


/*
** RemoveHeapElement()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void RemoveHeapElement(PCVOID pcvOld)
{
   PHEAPNODE phnOld;

   if (EVAL(FindHeapElement(pcvOld, &phnOld)))
   {
      /* Remove heap node from list. */

      phnOld->phnPrev->phnNext = phnOld->phnNext;

      if (phnOld->phnNext)
         phnOld->phnNext->phnPrev = phnOld->phnPrev;

      MEMFREE(phnOld);
   }

   return;
}


/*
** ModifyHeapElement()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void ModifyHeapElement(PCVOID pcvOld, PCVOID pcvNew, DWORD dwcbNewSize)
{
   PHEAPNODE phn;

   if (EVAL(FindHeapElement(pcvOld, &phn)))
   {
      phn->pcv = pcvNew;
      phn->dwcbSize = dwcbNewSize;
   }

   return;
}


/*
** FindHeapElement()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FindHeapElement(PCVOID pcvTarget, PHEAPNODE *pphn)
{
   BOOL bFound = FALSE;
   PHEAPNODE phn;

   ASSERT(IS_VALID_WRITE_PTR(pphn, PHEAPNODE));

   if (Mpheap)
   {
      for (phn = Mpheap->hnHead.phnNext;
           phn;
           phn = phn->phnNext)
      {
         /*
          * Verify each HEAPNODE structure carefully.  We may be in the middle of
          * a ModifyHeapElement() call, in which case just the target HEAPNODE may
          * be invalid, e.g., after MEMREALLOCATE() in ReallocateMemory().
          */

         ASSERT((IS_VALID_READ_PTR(phn, CHEAPNODE) && phn->pcv == pcvTarget) ||
                IS_VALID_STRUCT_PTR(phn, CHEAPNODE));

         if (phn->pcv == pcvTarget)
         {
            *pphn = phn;
            bFound = TRUE;
            break;
         }
      }
   }

   return(bFound);
}


/*
** FillNewMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void FillNewMemory(PBYTE pbyte, DWORD dwcbRequestedSize,
                           DWORD dwcbAllocatedSize)
{
   ASSERT(dwcbRequestedSize >= sizeof(MchsPrefix) + sizeof(MchsSuffix));
   ASSERT(dwcbAllocatedSize >= dwcbRequestedSize);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pbyte, BYTE, (UINT)dwcbAllocatedSize));

   /* Fill new heap element with the uninitialized byte value. */

   FillMemory(pbyte, dwcbAllocatedSize, UNINITIALIZED_BYTE_VALUE);

   /* Copy prefix and suffix heap element sentinels. */

   CopyMemory(pbyte, &MchsPrefix, sizeof(MchsPrefix));
   CopyMemory(pbyte + dwcbRequestedSize - sizeof(MchsSuffix), &MchsSuffix,
              sizeof(MchsSuffix));

   return;
}


/*
** FillFreedMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void FillFreedMemory(PBYTE pbyte, DWORD dwcbAllocatedSize)
{
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pbyte, BYTE, (UINT)dwcbAllocatedSize));

   /* Fill old heap element with the freed byte value. */

   FillMemory(pbyte, dwcbAllocatedSize, FREED_BYTE_VALUE);

   return;
}


/*
** FillGrownMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void FillGrownMemory(PBYTE pbyte, DWORD dwcbOldRequestedSize,
                             DWORD dwcbNewRequestedSize,
                             DWORD dwcbNewAllocatedSize)
{
   ASSERT(dwcbOldRequestedSize >= sizeof(MchsPrefix) + sizeof(MchsSuffix));
   ASSERT(dwcbNewRequestedSize > dwcbOldRequestedSize);
   ASSERT(dwcbNewAllocatedSize >= dwcbNewRequestedSize);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pbyte, BYTE, (UINT)dwcbNewAllocatedSize));

   ASSERT(MyMemComp(pbyte, &MchsPrefix, sizeof(MchsPrefix)) == CR_EQUAL);

   /* Fill new heap element tail with the uninitialized byte value. */

   FillMemory(pbyte + dwcbOldRequestedSize - sizeof(MchsSuffix),
              dwcbNewRequestedSize - dwcbOldRequestedSize,
              UNINITIALIZED_BYTE_VALUE);

   /* Copy suffix heap element sentinel. */

   CopyMemory(pbyte + dwcbNewRequestedSize - sizeof(MchsSuffix), &MchsSuffix,
              sizeof(MchsSuffix));

   return;
}


/*
** FillShrunkenMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void FillShrunkenMemory(PBYTE pbyte, DWORD dwcbOldRequestedSize,
                                DWORD dwcbNewRequestedSize,
                                DWORD dwcbNewAllocatedSize)
{
   ASSERT(dwcbNewRequestedSize >= sizeof(MchsPrefix) + sizeof(MchsSuffix));
   ASSERT(dwcbNewRequestedSize < dwcbOldRequestedSize);
   ASSERT(dwcbNewAllocatedSize >= dwcbNewRequestedSize);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pbyte, BYTE, (UINT)dwcbNewAllocatedSize));

   ASSERT(MyMemComp(pbyte, &MchsPrefix, sizeof(MchsPrefix)) == CR_EQUAL);

   /* Fill old heap element tail with the freed byte value. */

   FillMemory(pbyte + dwcbNewRequestedSize,
              dwcbOldRequestedSize - dwcbNewRequestedSize, FREED_BYTE_VALUE);

   /* Copy suffix heap element sentinel. */

   CopyMemory(pbyte + dwcbNewRequestedSize - sizeof(MchsSuffix), &MchsSuffix,
              sizeof(MchsSuffix));

   return;
}


/*
** IsValidHeapPtr()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidHeapPtr(PCVOID pcv)
{
   PHEAPNODE phnUnused;

   return(FindHeapElement(pcv, &phnUnused));
}


/*
** IsHeapOK()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsHeapOK(void)
{
   PHEAPNODE phn;

   if (Mpheap)
   {
      for (phn = Mpheap->hnHead.phnNext;
           phn && IS_VALID_STRUCT_PTR(phn, CHEAPNODE);
           phn = phn->phnNext)
         ;
   }
   else
      phn = (PHEAPNODE)0xFFFF;

   return(phn == NULL);
}


/*
** IsValidPCHEAPNODE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCHEAPNODE(PCHEAPNODE pchn)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pchn, CHEAPNODE) &&
       IS_VALID_READ_PTR(pchn->phnPrev, CHEAPNODE) &&
       EVAL(pchn->phnPrev->phnNext == pchn) &&
       EVAL(! pchn->phnNext ||
            (IS_VALID_READ_PTR(pchn->phnNext, CHEAPNODE) &&
             EVAL(pchn->phnNext->phnPrev == pchn))) &&
       EVAL(IsValidHeapElement(pchn->pcv, pchn->dwcbSize, MEMSIZE((PVOID)(pchn->pcv)))) &&
       IS_VALID_STRUCT_PTR(&(pchn->hed), CHEAPELEMDESC))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}


/*
** IsValidPCHEAPELEMDESC()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCHEAPELEMDESC(PCHEAPELEMDESC pched)
{
   BOOL bResult;

   /* Any value for pched->ulLine is valid. */

   if (IS_VALID_READ_PTR(pched, CHEAPELEMDESC))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}


/*
** IsValidHeapElement()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidHeapElement(PCBYTE pcbyte, DWORD dwcbRequestedSize,
                                DWORD dwcbAllocatedSize)
{
   BOOL bResult;

   if (EVAL(dwcbRequestedSize >= sizeof(MchsPrefix) + sizeof(MchsSuffix)) &&
       EVAL(dwcbAllocatedSize >= dwcbRequestedSize) &&
       IS_VALID_READ_PTR(pcbyte, dwcbAllocatedSize) &&
       EVAL(MyMemComp(pcbyte, &MchsPrefix, sizeof(MchsPrefix)) == CR_EQUAL) &&
       EVAL(MyMemComp(pcbyte + dwcbRequestedSize - sizeof(MchsSuffix), &MchsSuffix, sizeof(MchsSuffix)) == CR_EQUAL))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}


/*
** SpewHeapElementInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void SpewHeapElementInfo(PCHEAPNODE pchn)
{
   ASSERT(IS_VALID_STRUCT_PTR(pchn, CHEAPNODE));

   TRACE_OUT((TEXT("Used heap element at %#lx:\r\n")
              TEXT("     %lu bytes requested\r\n")
              TEXT("     %lu bytes allocated\r\n")
              TEXT("     originally allocated as '%s' bytes in file %s at line %lu"),
              pchn->pcv,
              pchn->dwcbSize,
              MEMSIZE((PVOID)(pchn->pcv)),
              pchn->hed.rgchSize,
              pchn->hed.rgchFile,
              pchn->hed.ulLine));

   return;
}


/*
** AnalyzeHeap()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void AnalyzeHeap(PHEAPSUMMARY phs, DWORD dwFlags)
{
   PCHEAPNODE pchn;
   ULONG ulcHeapElements = 0;
   DWORD dwcbUsed = 0;

   ASSERT(IS_VALID_WRITE_PTR(phs, HEAPSUMMARY));
   ASSERT(FLAGS_ARE_VALID(dwFlags, SHS_FL_SPEW_USED_INFO));

   ASSERT(IsHeapOK());

   TRACE_OUT((TEXT("Starting private heap analysis.")));

   if (Mpheap)
   {
      for (pchn = Mpheap->hnHead.phnNext;
           pchn;
           pchn = pchn->phnNext)
      {
         ASSERT(IS_VALID_STRUCT_PTR(pchn, CHEAPNODE));

         ASSERT(ulcHeapElements < ULONG_MAX);
         ulcHeapElements++;

         ASSERT(dwcbUsed < DWORD_MAX - pchn->dwcbSize);
         dwcbUsed += pchn->dwcbSize;

         if (IS_FLAG_SET(dwFlags, SHS_FL_SPEW_USED_INFO))
            SpewHeapElementInfo(pchn);
      }

      phs->ulcUsedElements = ulcHeapElements;
      phs->dwcbUsedSize = dwcbUsed;
   }
   else
      WARNING_OUT((TEXT("Private heap not allocated!")));

   TRACE_OUT((TEXT("Private heap analysis complete.")));

   return;
}

#endif   /* DEBUG */


/****************************** Public Functions *****************************/


/*
** InitMemoryManagerModule()
**
** When PRIVATE_HEAP is defined, this function should be called only
** once, when the DLL is being first initialized.  When PRIVATE_HEAP
** is not defined, this function should be called for every 
** DLL_PROCESS_ATTACH.
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InitMemoryManagerModule(void)
{
   BOOL bResult;

#ifdef PRIVATE_HEAP

   bResult = InitPrivateHeapModule();

#else  /* PRIVATE_HEAP */

   bResult = InitHeapModule();

#endif

   return(bResult);
}

/*
** ExitMemoryManagerModule()
**
** When PRIVATE_HEAP is defined, this function should be called only
** once, when the DLL is finally being terminated.  When PRIVATE_HEAP
** is not defined, this function should be called for every 
** DLL_PROCESS_DETACH.
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ExitMemoryManagerModule(void)
{

#ifdef DEBUG

   if (Mpheap)
   {
      MEMFREE(Mpheap);
      Mpheap = NULL;
   }
   else
      WARNING_OUT((TEXT("ExitMemoryManagerModule() called when Mpheap is NULL.")));

#endif

#ifdef PRIVATE_HEAP

   if (Mhheap)
   {
      EVAL(HeapDestroy(Mhheap));
      Mhheap = NULL;
   }
   else
      WARNING_OUT((TEXT("ExitMemoryManagerModule() called when Mhheap is NULL.")));

#endif

   return;
}


/*
** MyMemComp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT MyMemComp(PCVOID pcv1, PCVOID pcv2, DWORD dwcbSize)
{
   int nResult = 0;
   PCBYTE pcbyte1 = pcv1;
   PCBYTE pcbyte2 = pcv2;

   ASSERT(IS_VALID_READ_BUFFER_PTR(pcv1, BYTE, (UINT)dwcbSize));
   ASSERT(IS_VALID_READ_BUFFER_PTR(pcv2, BYTE, (UINT)dwcbSize));

   while (dwcbSize > 0 &&
          ! (nResult = *pcbyte1 - *pcbyte2))
   {
      pcbyte1++;
      pcbyte2++;
      dwcbSize--;
   }

   return(MapIntToComparisonResult(nResult));
}


/*
** MyAllocateMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL MyAllocateMemory(DWORD dwcbSize, PVOID *ppvNew)
{

#ifdef DEBUG

   DWORD dwcbRequestedSize = dwcbSize;

   ASSERT(dwcbSize >= 0);
   ASSERT(IS_VALID_WRITE_PTR(ppvNew, PVOID));

   dwcbSize = CalculatePrivateSize(dwcbSize);

   if (IS_FLAG_SET(MdwMemoryManagerModuleFlags, MEMMGR_DFL_VALIDATE_HEAP_ON_ENTRY))
      ASSERT(IsHeapOK());

#endif

   *ppvNew = MEMALLOCATE(dwcbSize);

#ifdef DEBUG

   if (*ppvNew)
   {
      FillNewMemory(*ppvNew, dwcbSize, MEMSIZE(*ppvNew));

      if (AddHeapElement(*ppvNew, dwcbSize))
      {
         *ppvNew = GetPublicHeapPtr(*ppvNew);

         ASSERT(IS_VALID_WRITE_BUFFER_PTR(*ppvNew, BYTE, (UINT)dwcbRequestedSize));
      }
      else
      {
         EVAL(MEMFREE(*ppvNew));
         *ppvNew = NULL;
      }
   }

   if (IS_FLAG_SET(MdwMemoryManagerModuleFlags, MEMMGR_DFL_VALIDATE_HEAP_ON_EXIT))
      ASSERT(IsHeapOK());

#endif

   return(*ppvNew != NULL);
}


/*
** FreeMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void FreeMemory(PVOID pvOld)
{

#ifdef DEBUG

   if (IS_FLAG_SET(MdwMemoryManagerModuleFlags, MEMMGR_DFL_VALIDATE_HEAP_ON_ENTRY))
      ASSERT(IsHeapOK());

   pvOld = GetPrivateHeapPtr(pvOld);

   ASSERT(IsValidHeapPtr(pvOld));

   RemoveHeapElement(pvOld);

   FillFreedMemory(pvOld, MEMSIZE(pvOld));

#endif

   EVAL(MEMFREE(pvOld));

#ifdef DEBUG

   if (IS_FLAG_SET(MdwMemoryManagerModuleFlags, MEMMGR_DFL_VALIDATE_HEAP_ON_EXIT))
      ASSERT(IsHeapOK());

#endif   /* DEBUG */

   return;
}


/*
** ReallocateMemory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ReallocateMemory(PVOID pvOld, DWORD dwcbNewSize, PVOID *ppvNew)
{

#ifdef DEBUG

   DWORD dwcbRequestedSize = dwcbNewSize;
   DWORD dwcbOldSize;

   ASSERT(IS_VALID_WRITE_PTR(ppvNew, PVOID));

   if (IS_FLAG_SET(MdwMemoryManagerModuleFlags, MEMMGR_DFL_VALIDATE_HEAP_ON_ENTRY))
      ASSERT(IsHeapOK());

   pvOld = GetPrivateHeapPtr(pvOld);

   ASSERT(IsValidHeapPtr(pvOld));

   dwcbNewSize = CalculatePrivateSize(dwcbNewSize);

   dwcbOldSize = GetHeapSize(pvOld);

   if (dwcbNewSize == dwcbOldSize)
      WARNING_OUT((TEXT("ReallocateMemory(): Size of heap element %#lx is already %lu bytes."),
                   GetPublicHeapPtr(pvOld),
                   dwcbNewSize));

#endif

   *ppvNew = MEMREALLOCATE(pvOld, dwcbNewSize);

#ifdef DEBUG

   if (*ppvNew)
   {
      /* Bigger or smaller? */

      if (dwcbNewSize > dwcbOldSize)
         /* Bigger. */
         FillGrownMemory(*ppvNew, dwcbOldSize, dwcbNewSize, MEMSIZE(*ppvNew));
      else
         /* Smaller. */
         FillShrunkenMemory(*ppvNew, dwcbOldSize, dwcbNewSize, MEMSIZE(*ppvNew));

      ModifyHeapElement(pvOld, *ppvNew, dwcbNewSize);

      *ppvNew = GetPublicHeapPtr(*ppvNew);

      ASSERT(IS_VALID_WRITE_BUFFER_PTR(*ppvNew, BYTE, (UINT)dwcbRequestedSize));
   }

   if (IS_FLAG_SET(MdwMemoryManagerModuleFlags, MEMMGR_DFL_VALIDATE_HEAP_ON_EXIT))
      ASSERT(IsHeapOK());

#endif

   return(*ppvNew != NULL);
}


/*
** GetMemorySize()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE DWORD GetMemorySize(PVOID pv)
{
   ASSERT(IsValidHeapPtr(GetPrivateHeapPtr(pv)));

   return(MEMSIZE(pv));
}


#ifdef DEBUG

/*
** SetMemoryManagerModuleIniSwitches()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SetMemoryManagerModuleIniSwitches(void)
{
   BOOL bResult;

   bResult = SetIniSwitches(MrgcpcvisMemoryManagerModule,
                            ARRAY_ELEMENTS(MrgcpcvisMemoryManagerModule));

   ASSERT(FLAGS_ARE_VALID(MdwMemoryManagerModuleFlags, ALL_MEMMGR_DFLAGS));

   return(bResult);
}


/*
** SpewHeapSummary()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void SpewHeapSummary(DWORD dwFlags)
{
   HEAPSUMMARY hs;

   ASSERT(FLAGS_ARE_VALID(dwFlags, SHS_FL_SPEW_USED_INFO));

   AnalyzeHeap(&hs, dwFlags);

   TRACE_OUT((TEXT("Heap summary: %lu bytes in %lu used elements."),
              hs.dwcbUsedSize,
              hs.ulcUsedElements));

   return;
}

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\merge.c ===
/*
 * merge.c - File merge handler module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "oleutil.h"
#include "irecinit.h"


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* lock count for reconciliation handler cache */

PRIVATE_DATA ULONG MulcRecHandlerCacheLock = 0;

/* handle to reconciliation handler cache */

PRIVATE_DATA HCLSIFACECACHE MhcicRecHandlerCache = NULL;

#pragma data_seg()


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE HRESULT CreateRecHandlerCache(void);
PRIVATE_CODE void DestroyRecHandlerCache(void);
PRIVATE_CODE HRESULT OLEMerge(PRECNODE, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND, PRECNODE *);
PRIVATE_CODE BOOL GetRecNodeByIndex(PCRECITEM, LONG, PRECNODE *);
PRIVATE_CODE HRESULT CreateMergeSourceMonikers(PRECNODE, PULONG, PIMoniker **);
PRIVATE_CODE HRESULT CreateCopyDestinationMonikers(PCRECITEM, PULONG, PIMoniker **);

#ifdef DEBUG

PRIVATE_CODE BOOL RecHandlerCacheIsOk(void);
PRIVATE_CODE BOOL VerifyRECITEMAndDestRECNODE(PCRECNODE);

#endif


/*
** CreateRecHandlerCache()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT CreateRecHandlerCache(void)
{
   HRESULT hr;

   ASSERT(RecHandlerCacheIsOk());

   /* Has the merge handler cache already been created? */

   if (MhcicRecHandlerCache)
      /* Yes. */
      hr = S_OK;
   else
   {
      /* No.  Create it. */

      if (CreateClassInterfaceCache(&MhcicRecHandlerCache))
      {
         hr = S_OK;

         TRACE_OUT((TEXT("CreateRecHandlerCache(): Merge handler cache created.")));
      }
      else
         hr = E_OUTOFMEMORY;
   }

   ASSERT(RecHandlerCacheIsOk());

   return(hr);
}


/*
** DestroyRecHandlerCache()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyRecHandlerCache(void)
{
   ASSERT(RecHandlerCacheIsOk());

   /* Has the merge handler cache already been created? */

   if (MhcicRecHandlerCache)
   {
      /* Yes.  Destroy it. */

      DestroyClassInterfaceCache(MhcicRecHandlerCache);
      MhcicRecHandlerCache = NULL;

      TRACE_OUT((TEXT("DestroyRecHandlerCache(): Merge handler cache destroyed.")));
   }

   ASSERT(RecHandlerCacheIsOk());

   return;
}


/*
** OLEMerge()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT OLEMerge(PRECNODE prnDest, RECSTATUSPROC rsp,
                              LPARAM lpCallbackData, DWORD dwInFlags,
                              HWND hwndOwner, HWND hwndProgressFeedback,
                              PRECNODE *pprnMergedResult)
{
   HRESULT hr;
   TCHAR rgchMergeDestPath[MAX_PATH_LEN];
   CLSID clsidReconcilableObject;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(prnDest, CRECNODE));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RI_FLAGS));
   ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
          IS_VALID_HANDLE(hwndProgressFeedback, WND));
   ASSERT(IS_VALID_WRITE_PTR(pprnMergedResult, PRECNODE));

   ComposePath(rgchMergeDestPath, prnDest->pcszFolder, prnDest->priParent->pcszName);
   ASSERT(lstrlen(rgchMergeDestPath) < ARRAYSIZE(rgchMergeDestPath));

   hr = GetReconcilerClassID(rgchMergeDestPath, &clsidReconcilableObject);

   if (SUCCEEDED(hr))
   {
      PIReconcilableObject piro;

      hr = GetClassInterface(MhcicRecHandlerCache, &clsidReconcilableObject,
                             &IID_IReconcilableObject, &piro);

      if (SUCCEEDED(hr))
      {
         HSTGIFACE hstgi;

         hr = GetStorageInterface((PIUnknown)piro, &hstgi);

         if (SUCCEEDED(hr))
         {
            hr = LoadFromStorage(hstgi, rgchMergeDestPath);

            if (SUCCEEDED(hr))
            {
               PIReconcileInitiator pirecinit;

               hr = IReconcileInitiator_Constructor(
                        GetTwinBriefcase((HTWIN)(prnDest->hObjectTwin)), rsp,
                        lpCallbackData, &pirecinit);

               if (SUCCEEDED(hr))
               {
                  ULONG ulcMergeSources;
                  PIMoniker *ppimkMergeSources;

                  hr = CreateMergeSourceMonikers(prnDest, &ulcMergeSources,
                                                 &ppimkMergeSources);

                  if (SUCCEEDED(hr))
                  {
                     DWORD dwOLEFlags;
                     LONG liMergedResult;

                     dwOLEFlags = (RECONCILEF_NORESIDUESOK |
                                   RECONCILEF_OMITSELFRESIDUE |
                                   RECONCILEF_YOUMAYDOTHEUPDATES);

                     if (IS_FLAG_SET(dwInFlags, RI_FL_ALLOW_UI))
                        SET_FLAG(dwOLEFlags, RECONCILEF_MAYBOTHERUSER);

                     if (IS_FLAG_SET(dwInFlags, RI_FL_FEEDBACK_WINDOW_VALID))
                        SET_FLAG(dwOLEFlags, RECONCILEF_FEEDBACKWINDOWVALID);

                     hr = piro->lpVtbl->Reconcile(piro, pirecinit, dwOLEFlags,
                                                  hwndOwner,
                                                  hwndProgressFeedback,
                                                  ulcMergeSources,
                                                  ppimkMergeSources,
                                                  &liMergedResult, NULL, NULL);

                     if (SUCCEEDED(hr))
                     {
                        if (hr == REC_S_IDIDTHEUPDATES)
                        {
                           /* Return original merge destination RECNODE. */

                           *pprnMergedResult = prnDest;

                           TRACE_OUT((TEXT("OLEMerge(): IReconcilableObject::Reconcile() returned %s.  Not saving merged result to %s\\%s."),
                                      GetHRESULTString(hr),
                                      prnDest->pcszFolder,
                                      prnDest->priParent->pcszName));
                        }
                        else
                        {
                           /*
                            * Only save the merged result if it's different
                            * than all of the replicas.
                            */

                           if (liMergedResult < 0)
                           {
                              ASSERT(liMergedResult == -1);

                              hr = SaveToStorage(hstgi);

                              if (SUCCEEDED(hr))
                              {
                                 *pprnMergedResult = prnDest;

                                 TRACE_OUT((TEXT("OLEMerge(): Merge into %s completed successfully."),
                                            rgchMergeDestPath));
                              }
                              else
                                 WARNING_OUT((TEXT("OLEMerge(): Failed to save merged result to %s."),
                                              rgchMergeDestPath));
                           }
                           else if (! liMergedResult)
                           {
                              *pprnMergedResult = prnDest;

                              TRACE_OUT((TEXT("OLEMerge(): Merged result identical to %s."),
                                         rgchMergeDestPath));
                           }
                           else
                           {
                              if (GetRecNodeByIndex(prnDest->priParent,
                                                    liMergedResult,
                                                    pprnMergedResult))
                                 TRACE_OUT((TEXT("OLEMerge(): Merged result identical to %s\\%s."),
                                            (*pprnMergedResult)->pcszFolder,
                                            (*pprnMergedResult)->priParent->pcszName));
                              else
                              {
                                 hr = E_UNEXPECTED;

                                 WARNING_OUT((TEXT("OLEMerge(): Merge handler returned bad merge result index %ld.  No such RECNODE for %s."),
                                              liMergedResult,
                                              prnDest->priParent->pcszName));
                              }
                           }
                        }
                     }
                     else
                        WARNING_OUT((TEXT("OLEMerge(): Merge to %s failed."),
                                     rgchMergeDestPath));

                     ReleaseIUnknowns(ulcMergeSources,
                                      (PIUnknown *)ppimkMergeSources);
                  }
                  else
                     WARNING_OUT((TEXT("OLEMerge(): Failed to create merge source monikers for merge destination %s."),
                                  rgchMergeDestPath));

                  EVAL(! pirecinit->lpVtbl->Release(pirecinit));
               }
               else
                  WARNING_OUT((TEXT("OLEMerge(): Failed to create ReconcileInitiator for merge destination %s."),
                               rgchMergeDestPath));
            }
            else
               WARNING_OUT((TEXT("OLEMerge(): Failed to load replica %s from storage."),
                            rgchMergeDestPath));

            ReleaseStorageInterface(hstgi);
         }
         else
            WARNING_OUT((TEXT("OLEMerge(): Failed to get storage interface for replica %s."),
                         rgchMergeDestPath));
      }
      else
         TRACE_OUT((TEXT("OLEMerge(): Failed to get IReconcilableObject for replica %s."),
                    rgchMergeDestPath));
   }
   else
      TRACE_OUT((TEXT("OLEMerge(): Failed to get reconciliation handler class ID for replica %s."),
                 rgchMergeDestPath));

   ASSERT(FAILED(hr) ||
          (IS_VALID_STRUCT_PTR(*pprnMergedResult, CRECNODE) &&
           (*pprnMergedResult)->priParent == prnDest->priParent));
           
   return(hr);
}


/*
** GetRecNodeByIndex()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** The first RECNODE in the RECITEM's list of RECNODEs is index 1, the second
** RECNODE is index 2, etc.
*/
PRIVATE_CODE BOOL GetRecNodeByIndex(PCRECITEM pcri, LONG li, PRECNODE *pprn)
{
   BOOL bFound;

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
   ASSERT(IS_VALID_WRITE_PTR(pprn, PRECNODE));

   if (EVAL(li > 0))
   {
      PRECNODE prn;

      for (prn = pcri->prnFirst; prn && --li > 0; prn = prn->prnNext)
         ;

      bFound = EVAL(prn && ! li);

      if (bFound)
         *pprn = prn;
   }
   else
      bFound = FALSE;

   ASSERT(! bFound ||
          (IS_VALID_STRUCT_PTR(*pprn, CRECNODE) &&
           (*pprn)->priParent == pcri));

   return(bFound);
}


/*
** CreateMergeSourceMonikers()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT CreateMergeSourceMonikers(PRECNODE prnDest,
                                          PULONG pulcMergeSources,
                                          PIMoniker **pppimk)
{
   HRESULT hr;
   ULONG ulcMergeSources;
   PCRECNODE pcrn;

   ASSERT(IS_VALID_STRUCT_PTR(prnDest, CRECNODE));
   ASSERT(IS_VALID_WRITE_PTR(pulcMergeSources, ULONG));
   ASSERT(IS_VALID_WRITE_PTR(pppimk, PIMoniker *));

   ulcMergeSources = 0;

   for (pcrn = prnDest->priParent->prnFirst; pcrn; pcrn = pcrn->prnNext)
   {
      if (pcrn->rnaction == RNA_MERGE_ME &&
          pcrn != prnDest)
         ulcMergeSources++;
   }

   if (AllocateMemory(ulcMergeSources * sizeof(**pppimk), (PVOID *)pppimk))
   {
      hr = S_OK;
      *pulcMergeSources = 0;

      for (pcrn = prnDest->priParent->prnFirst; pcrn; pcrn = pcrn->prnNext)
      {
         if (pcrn->rnaction == RNA_MERGE_ME &&
             pcrn != prnDest)
         {
            hr = MyCreateFileMoniker(pcrn->pcszFolder,
                                     pcrn->priParent->pcszName,
                                     &((*pppimk)[*pulcMergeSources]));

            if (SUCCEEDED(hr))
            {
               ASSERT(*pulcMergeSources < ulcMergeSources);
               (*pulcMergeSources)++;
            }
            else
               break;
         }
      }

      if (FAILED(hr))
         ReleaseIUnknowns(*pulcMergeSources, *(PIUnknown **)pppimk);
   }
   else
      hr = E_OUTOFMEMORY;

   return(hr);
}


/*
** CreateCopyDestinationMonikers()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT CreateCopyDestinationMonikers(PCRECITEM pcri,
                                              PULONG pulcCopyDestinations,
                                              PIMoniker **pppimk)
{
   HRESULT hr;
   ULONG ulcCopyDestinations;
   PCRECNODE pcrn;

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
   ASSERT(IS_VALID_WRITE_PTR(pulcCopyDestinations, ULONG));
   ASSERT(IS_VALID_WRITE_PTR(pppimk, PIMoniker *));

   ulcCopyDestinations = 0;

   for (pcrn = pcri->prnFirst; pcrn; pcrn = pcrn->prnNext)
   {
      if (pcrn->rnaction == RNA_COPY_TO_ME)
         ulcCopyDestinations++;
   }

   if (AllocateMemory(ulcCopyDestinations * sizeof(**pppimk), (PVOID *)pppimk))
   {
      hr = S_OK;
      *pulcCopyDestinations = 0;

      for (pcrn = pcri->prnFirst; pcrn; pcrn = pcrn->prnNext)
      {
         if (pcrn->rnaction == RNA_COPY_TO_ME)
         {
            ASSERT(pcrn->priParent == pcri);

            hr = MyCreateFileMoniker(pcrn->pcszFolder,
                                     pcrn->priParent->pcszName,
                                     &((*pppimk)[*pulcCopyDestinations]));

            if (SUCCEEDED(hr))
            {
               ASSERT(*pulcCopyDestinations < ulcCopyDestinations);
               (*pulcCopyDestinations)++;
            }
            else
               break;
         }
      }

      if (FAILED(hr))
         ReleaseIUnknowns(*pulcCopyDestinations, *(PIUnknown **)pppimk);
   }
   else
      hr = E_OUTOFMEMORY;

   return(hr);
}


#ifdef DEBUG

/*
** RecHandlerCacheIsOk()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL RecHandlerCacheIsOk(void)
{
   /* Are the module merge handler cache variables in a correct state? */

   return(! MhcicRecHandlerCache ||
          IS_VALID_HANDLE(MhcicRecHandlerCache, CLSIFACECACHE));
}


/*
** VerifyRECITEMAndDestRECNODE()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL VerifyRECITEMAndDestRECNODE(PCRECNODE pcrnSrc)
{
   /* Do the RECITEM and source RECNODE actions match? */

   return(pcrnSrc->priParent->riaction == RIA_MERGE &&
          pcrnSrc->rnaction == RNA_MERGE_ME);
}

#endif


/****************************** Public Functions *****************************/


/*
** BeginMerge()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void BeginMerge(void)
{
   ASSERT(RecHandlerCacheIsOk());

   ASSERT(MulcRecHandlerCacheLock < ULONG_MAX);
   MulcRecHandlerCacheLock++;

   ASSERT(RecHandlerCacheIsOk());

   return;
}


/*
** EndMerge()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void EndMerge(void)
{
   ASSERT(RecHandlerCacheIsOk());

   /* Is the merge handler cache still locked? */

   if (! --MulcRecHandlerCacheLock)
      DestroyRecHandlerCache();

   ASSERT(RecHandlerCacheIsOk());

   return;
}


/*
** MergeHandler()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT MergeHandler(PRECNODE prnDest, RECSTATUSPROC rsp,
                                 LPARAM lpCallbackData, DWORD dwInFlags,
                                 HWND hwndOwner, HWND hwndProgressFeedback,
                                 PRECNODE *pprnMergedResult)
{
   HRESULT hr;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(prnDest, CRECNODE));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RI_FLAGS));
   ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
          IS_VALID_HANDLE(hwndProgressFeedback, WND));
   ASSERT(IS_VALID_WRITE_PTR(pprnMergedResult, PRECNODE));

   ASSERT(VerifyRECITEMAndDestRECNODE(prnDest));

   BeginMerge();

   /* Make sure the merge handler cache has been created. */

   hr = CreateRecHandlerCache();

   if (SUCCEEDED(hr))
   {
      RECSTATUSUPDATE rsu;

      /* 0% complete. */

      rsu.ulScale = 1;
      rsu.ulProgress = 0;

      if (NotifyReconciliationStatus(rsp, RS_BEGIN_MERGE, (LPARAM)&rsu,
                                     lpCallbackData))
      {
         hr = OLEMerge(prnDest, rsp, lpCallbackData, dwInFlags, hwndOwner,
                       hwndProgressFeedback, pprnMergedResult);

         if (SUCCEEDED(hr))
         {
            /* 100% complete. */

            rsu.ulScale = 1;
            rsu.ulProgress = 1;

            /* Don't allow abort. */

            NotifyReconciliationStatus(rsp, RS_END_MERGE, (LPARAM)&rsu,
                                       lpCallbackData);
         }
      }
      else
         hr = E_ABORT;
   }

   EndMerge();

   ASSERT(FAILED(hr) ||
          (IS_VALID_STRUCT_PTR(*pprnMergedResult, CRECNODE) &&
           (*pprnMergedResult)->priParent == prnDest->priParent));
           
   return(hr);
}


/*
** MyCreateFileMoniker()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT MyCreateFileMoniker(LPCTSTR pcszPath, LPCTSTR pcszSubPath,
                                   PIMoniker *ppimk)
{
   HRESULT hr;
   TCHAR rgchPath[MAX_PATH_LEN];
   WCHAR rgwchUnicodePath[MAX_PATH_LEN];

   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppimk, PIMoniker));

   ComposePath(rgchPath, pcszPath, pcszSubPath);
   ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

#ifdef UNICODE

   hr = CreateFileMoniker(rgchPath, ppimk);

#else

   /* Translate ANSI string into Unicode for OLE. */

   if (MultiByteToWideChar(CP_ACP, 0, rgchPath, -1, rgwchUnicodePath,
                           ARRAY_ELEMENTS(rgwchUnicodePath)))
   {
      hr = CreateFileMoniker(rgwchUnicodePath, ppimk);
   }
   else
   {
      hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
   }

#endif

   if (FAILED(hr))
     WARNING_OUT((TEXT("MyCreateFileMoniker(): CreateFileMoniker() on %s failed, returning %s."),
                  pcszPath,
                  GetHRESULTString(hr)));
   
   return(hr);
}


/*
** ReleaseIUnknowns()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ReleaseIUnknowns(ULONG ulcIUnknowns, PIUnknown *ppiunk)
{
   ULONG uli;

   /* ulcIUnknowns may be any value. */

   ASSERT(IS_VALID_READ_BUFFER_PTR(ppiunk, PIUnknown, ulcIUnknowns * sizeof(*ppiunk)));

   for (uli = 0; uli < ulcIUnknowns; uli++)
   {
      ASSERT(IS_VALID_STRUCT_PTR(ppiunk[uli], CIUnknown));

      ppiunk[uli]->lpVtbl->Release(ppiunk[uli]);
   }

   FreeMemory(ppiunk);

   return;
}


/*
** OLECopy()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT OLECopy(PRECNODE prnSrc, PCCLSID pcclsidReconcilableObject,
                            RECSTATUSPROC rsp, LPARAM lpCallbackData,
                            DWORD dwFlags, HWND hwndOwner,
                            HWND hwndProgressFeedback)
{
   HRESULT hr;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(prnSrc, CRECNODE));
   ASSERT(IS_VALID_STRUCT_PTR(pcclsidReconcilableObject, CCLSID));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_RI_FLAGS));
   ASSERT(IS_FLAG_CLEAR(dwFlags, RI_FL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_FLAG_CLEAR(dwFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
          IS_VALID_HANDLE(hwndProgressFeedback, WND));

   BeginMerge();

   /* Make sure the merge handler cache has been created. */

   hr = CreateRecHandlerCache();

   if (SUCCEEDED(hr))
   {
      TCHAR rgchCopySrcPath[MAX_PATH_LEN];
      PIReconcilableObject piro;

      ComposePath(rgchCopySrcPath, prnSrc->pcszFolder, prnSrc->priParent->pcszName);
      ASSERT(lstrlen(rgchCopySrcPath) < ARRAYSIZE(rgchCopySrcPath));

      hr = GetClassInterface(MhcicRecHandlerCache, pcclsidReconcilableObject,
                             &IID_IReconcilableObject, &piro);

      if (SUCCEEDED(hr))
      {
         HSTGIFACE hstgi;

         hr = GetStorageInterface((PIUnknown)piro, &hstgi);

         if (SUCCEEDED(hr))
         {
            hr = LoadFromStorage(hstgi, rgchCopySrcPath);

            if (SUCCEEDED(hr))
            {
               PIReconcileInitiator pirecinit;

               hr = IReconcileInitiator_Constructor(
                        GetTwinBriefcase((HTWIN)(prnSrc->hObjectTwin)), rsp,
                        lpCallbackData, &pirecinit);

               if (SUCCEEDED(hr))
               {
                  ULONG ulcCopyDestinations;
                  PIMoniker *ppimkCopyDestinations;

                  hr = CreateCopyDestinationMonikers(prnSrc->priParent,
                                                     &ulcCopyDestinations,
                                                     &ppimkCopyDestinations);

                  if (SUCCEEDED(hr))
                  {
                     DWORD dwOLEFlags;
                     LONG liMergedResult;

                     dwOLEFlags = (RECONCILEF_YOUMAYDOTHEUPDATES |
                                   RECONCILEF_ONLYYOUWERECHANGED);

                     if (IS_FLAG_SET(dwFlags, RI_FL_ALLOW_UI))
                        SET_FLAG(dwOLEFlags, RECONCILEF_MAYBOTHERUSER);

                     if (IS_FLAG_SET(dwFlags, RI_FL_FEEDBACK_WINDOW_VALID))
                        SET_FLAG(dwOLEFlags, RECONCILEF_FEEDBACKWINDOWVALID);

                     hr = piro->lpVtbl->Reconcile(piro, pirecinit, dwOLEFlags,
                                                  hwndOwner,
                                                  hwndProgressFeedback,
                                                  ulcCopyDestinations,
                                                  ppimkCopyDestinations,
                                                  &liMergedResult, NULL, NULL);

                     if (SUCCEEDED(hr))
                     {
                        ASSERT(liMergedResult == -1);

                        if (hr == S_FALSE)
                           /* Release storage for internal copy routine. */
                           HandsOffStorage(hstgi);
                        else
                           ASSERT(hr == REC_S_IDIDTHEUPDATES);
                     }
                     else
                        WARNING_OUT((TEXT("OLECopy(): Copy from %s failed."),
                                     rgchCopySrcPath));

                     ReleaseIUnknowns(ulcCopyDestinations,
                                      (PIUnknown *)ppimkCopyDestinations);
                  }
                  else
                     WARNING_OUT((TEXT("OLECopy(): Failed to create copy destination monikers for copy source %s."),
                                  rgchCopySrcPath));

                  EVAL(! pirecinit->lpVtbl->Release(pirecinit));
               }
               else
                  WARNING_OUT((TEXT("OLECopy(): Failed to create ReconcileInitiator for copy source %s."),
                               rgchCopySrcPath));
            }
            else
               WARNING_OUT((TEXT("OLECopy(): Failed to load copy source %s from storage."),
                            rgchCopySrcPath));

            ReleaseStorageInterface(hstgi);
         }
         else
            WARNING_OUT((TEXT("OLECopy(): Failed to get storage interface for copy source %s."),
                         rgchCopySrcPath));
      }
      else
         TRACE_OUT((TEXT("OLECopy(): Failed to get reconciliation handler class ID for replica %s."),
                    rgchCopySrcPath));
   }

   EndMerge();

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\merge.h ===
/*
 * merge.h - File merge handler module description.
 */


/* Prototypes
 *************/

/* merge.c */

extern void BeginMerge(void);
extern void EndMerge(void);
extern HRESULT MergeHandler(PRECNODE, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND, PRECNODE *);
extern HRESULT MyCreateFileMoniker(LPCTSTR, LPCTSTR, PIMoniker *);
extern void ReleaseIUnknowns(ULONG, PIUnknown *);
extern HRESULT OLECopy(PRECNODE, PCCLSID, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\list.c ===
/*
 * list.c - List ADT module.
 */

/*

Motivation
----------

   Unfortunately, C7 doesn't fully support templates.  As a result, to link ADT
structures together, we could either embed linked list pointers in those
structures, or create a separate linked list ADT in which each node contains a
pointer to the associated structure.

   If we embed linked list pointers in other ADT structures, we lose the linked
list ADT barrier, and with it, the ability to easily change the linked list
implementation.  However, we no longer need to store an extra pointer to the
data associated with each linked node.

   If we create a separate linked list ADT, we are forced to store a pointer to
the structure associated with the node.  However, we retain the ability to
alter the linked list ADT in the future.

   Let's support the abstraction barrier, and create a separate linked list
ADT.

   In the object synchronization engine, the linked list ADT is used to store
lists of links, link handlers, and strings.


Architecture
------------

   The nodes in each doubly-linked list of nodes are allocated by
AllocateMemory().  A caller-supplied DWORD is stored in each list node.  NULL
is used as a sentinel pointer value for the head and tail of a list.

   A list handle is a pointer to a LIST allocated by AllocateMemory().  A list
node handle is a pointer to a list node.


         head            node            node            tail
        (LIST)          (NODE)          (NODE)          (NODE)
      Ŀ     Ŀ     Ŀ     Ŀ
      pnodeNext --> pnodeNext --> pnodeNext --> pnodeNext --0
                                                         
  0-- pnodePrev <-- pnodePrev <-- pnodePrev <-- pnodePrev
                                                         
        XXXXXX         pcv           pcv           pcv   
      Ĵ               
               
         ....  


   pnodeNext is non-NULL for all list nodes except the tail.  pnodeNext in
the head is only NULL for an empty list.  pnodePrev is non-NULL for all list
nodes.  pnodePrev in the head is always NULL.  Be careful not to use pnodePrev
from the first list node as another list node!

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Macros
 *********/

/* Add nodes to list in sorted order? */

#define ADD_NODES_IN_SORTED_ORDER(plist)  IS_FLAG_SET((plist)->dwFlags, LIST_FL_SORTED_ADD)


/* Types
 ********/

/* list node types */

typedef struct _node
{
   struct _node *pnodeNext;      /* next node in list */
   struct _node *pnodePrev;      /* previous node in list */
   PCVOID pcv;                   /* node data */
}
NODE;
DECLARE_STANDARD_TYPES(NODE);

/* list flags */

typedef enum _listflags
{
   /* Insert nodes in sorted order. */

   LIST_FL_SORTED_ADD      = 0x0001,

   /* flag combinations */

   ALL_LIST_FLAGS          = LIST_FL_SORTED_ADD
}
LISTFLAGS;

/*
 * A LIST is just a special node at the head of a list.  N.b., the _node
 * structure MUST appear first in the _list structure because a pointer to a
 * list is sometimes used as a pointer to a node.
 */

typedef struct _list
{
   NODE node;

   DWORD dwFlags;
}
LIST;
DECLARE_STANDARD_TYPES(LIST);

/* SearchForNode() return codes */

typedef enum _addnodeaction
{
   ANA_FOUND,
   ANA_INSERT_BEFORE_NODE,
   ANA_INSERT_AFTER_NODE,
   ANA_INSERT_AT_HEAD
}
ADDNODEACTION;
DECLARE_STANDARD_TYPES(ADDNODEACTION);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE ADDNODEACTION SearchForNode(HLIST, COMPARESORTEDNODESPROC, PCVOID, PHNODE);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCLIST(PCLIST);
PRIVATE_CODE BOOL IsValidPCNODE(PCNODE);

#endif

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCNEWLIST(PCNEWLIST);
PRIVATE_CODE BOOL IsValidADDNODEACTION(ADDNODEACTION);
PRIVATE_CODE HLIST GetList(HNODE);

#endif

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsListInSortedOrder(PCLIST, COMPARESORTEDNODESPROC);

#endif


/*
** SearchForNode()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ADDNODEACTION SearchForNode(HLIST hlist,
                                         COMPARESORTEDNODESPROC csnp,
                                         PCVOID pcv, PHNODE phnode)
{
   ADDNODEACTION ana;
   ULONG ulcNodes;

   /* pcv may be any value */

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_CODE_PTR(csnp, COMPARESORTEDNODESPROC));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   ASSERT(ADD_NODES_IN_SORTED_ORDER((PCLIST)hlist));
   ASSERT(IsListInSortedOrder((PCLIST)hlist, csnp));

   /* Yes.  Are there any nodes in this list? */

   ulcNodes = GetNodeCount(hlist);

   ASSERT(ulcNodes < LONG_MAX);

   if (ulcNodes > 0)
   {
      LONG lLow = 0;
      LONG lMiddle = 0;
      LONG lHigh = ulcNodes - 1;
      LONG lCurrent = 0;
      int nCmpResult = 0;

      /* Yes.  Search for target. */

      EVAL(GetFirstNode(hlist, phnode));

      while (lLow <= lHigh)
      {
         lMiddle = (lLow + lHigh) / 2;

         /* Which way should we seek in the list to get the lMiddle node? */

         if (lCurrent < lMiddle)
         {
            /* Forward from the current node. */

            while (lCurrent < lMiddle)
            {
               EVAL(GetNextNode(*phnode, phnode));
               lCurrent++;
            }
         }
         else if (lCurrent > lMiddle)
         {
            /* Backward from the current node. */

            while (lCurrent > lMiddle)
            {
               EVAL(GetPrevNode(*phnode, phnode));
               lCurrent--;
            }
         }

         nCmpResult = (*csnp)(pcv, GetNodeData(*phnode));

         if (nCmpResult < 0)
            lHigh = lMiddle - 1;
         else if (nCmpResult > 0)
            lLow = lMiddle + 1;
         else
            /* Found a match at *phnode. */
            break;
      }

      /*
       * If (nCmpResult >  0), insert after *phnode.
       *
       * If (nCmpResult <  0), insert before *phnode.
       *
       * If (nCmpResult == 0), string found at *phnode.
       */

      if (nCmpResult > 0)
         ana = ANA_INSERT_AFTER_NODE;
      else if (nCmpResult < 0)
         ana = ANA_INSERT_BEFORE_NODE;
      else
         ana = ANA_FOUND;
   }
   else
   {
      /* No.  Insert the target as the only node in the list. */

      *phnode = NULL;
      ana = ANA_INSERT_AT_HEAD;
   }

   ASSERT(EVAL(IsValidADDNODEACTION(ana)) &&
          (ana == ANA_INSERT_AT_HEAD ||
           IS_VALID_HANDLE(*phnode, NODE)));

   return(ana);
}


#ifdef VSTF

/*
** IsValidPCLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCLIST(PCLIST pcl)
{
   BOOL bResult = FALSE;

   if (IS_VALID_READ_PTR(pcl, CLIST) &&
       FLAGS_ARE_VALID(pcl->dwFlags, ALL_LIST_FLAGS) &&
       EVAL(! pcl->node.pnodePrev))
   {
      PNODE pnode;

      for (pnode = pcl->node.pnodeNext;
           pnode && IS_VALID_STRUCT_PTR(pnode, CNODE);
           pnode = pnode->pnodeNext)
         ;

      bResult = (! pnode);
   }

   return(bResult);
}


/*
** IsValidPCNODE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCNODE(PCNODE pcn)
{
   /*
    * All valid nodes must have a valid pnodePrev pointer.  The first node's
    * pnodePrev pointer points at the list head.  A node's pnodeNext pointer
    * may be a valid pointer or NULL.
    */

   return(IS_VALID_READ_PTR(pcn, CNODE) &&
          EVAL(IS_VALID_READ_PTR(pcn->pnodePrev, CNODE) &&
               pcn->pnodePrev->pnodeNext == pcn) &&
          EVAL(! pcn->pnodeNext ||
               (IS_VALID_READ_PTR(pcn->pnodeNext, CNODE) &&
                pcn->pnodeNext->pnodePrev == pcn)));
}

#endif


#ifdef DEBUG

/*
** IsValidPCNEWLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCNEWLIST(PCNEWLIST pcnl)
{
   return(IS_VALID_READ_PTR(pcnl, CNEWLIST) &&
          FLAGS_ARE_VALID(pcnl->dwFlags, ALL_NL_FLAGS));
}


/*
** IsValidADDNODEACTION()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidADDNODEACTION(ADDNODEACTION ana)
{
   BOOL bResult;

   switch (ana)
   {
      case ANA_FOUND:
      case ANA_INSERT_BEFORE_NODE:
      case ANA_INSERT_AFTER_NODE:
      case ANA_INSERT_AT_HEAD:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidADDNODEACTION(): Invalid ADDNODEACTION %d."),
                    ana));
         break;
   }

   return(bResult);
}


/*
** GetList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HLIST GetList(HNODE hnode)
{
   PCNODE pcnode;

   ASSERT(IS_VALID_HANDLE(hnode, NODE));

   ASSERT(((PCNODE)hnode)->pnodePrev);

   for (pcnode = (PCNODE)hnode; pcnode->pnodePrev; pcnode = pcnode->pnodePrev)
      ;

   return((HLIST)pcnode);
}

#endif


#if defined(DEBUG) || defined(VSTF)

/*
** IsListInSortedOrder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsListInSortedOrder(PCLIST pclist, COMPARESORTEDNODESPROC csnp)
{
   BOOL bResult = TRUE;
   PNODE pnode;

   /* Don't validate pclist here. */

   ASSERT(ADD_NODES_IN_SORTED_ORDER(pclist));
   ASSERT(IS_VALID_CODE_PTR(csnp, COMPARESORTEDNODESPROC));

   pnode = pclist->node.pnodeNext;

   while (pnode)
   {
      PNODE pnodeNext;

      pnodeNext = pnode->pnodeNext;

      if (pnodeNext)
      {
         if ( (*csnp)(pnode->pcv, pnodeNext->pcv) == CR_FIRST_LARGER)
         {
            bResult = FALSE;
            ERROR_OUT((TEXT("IsListInSortedOrder(): Node [%ld] %#lx > following node [%ld] %#lx."),
                       pnode,
                       pnode->pcv,
                       pnodeNext,
                       pnodeNext->pcv));
            break;
         }

         pnode = pnodeNext;
      }
      else
         break;
   }

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
** CreateList()
**
** Creates a new list.
**
** Arguments:     void
**
** Returns:       Handle to new list, or NULL if unsuccessful.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreateList(PCNEWLIST pcnl, PHLIST phlist)
{
   PLIST plist;

   ASSERT(IS_VALID_STRUCT_PTR(pcnl, CNEWLIST));
   ASSERT(IS_VALID_WRITE_PTR(phlist, HLIST));

   /* Try to allocate new list structure. */

   *phlist = NULL;

   if (AllocateMemory(sizeof(*plist), &plist))
   {
      /* List allocated successfully.  Initialize list fields. */

      plist->node.pnodeNext = NULL;
      plist->node.pnodePrev = NULL;
      plist->node.pcv = NULL;

      plist->dwFlags = 0;

      if (IS_FLAG_SET(pcnl->dwFlags, NL_FL_SORTED_ADD))
      {
         SET_FLAG(plist->dwFlags, LIST_FL_SORTED_ADD);
      }

      *phlist = (HLIST)plist;

      ASSERT(IS_VALID_HANDLE(*phlist, LIST));
   }

   return(*phlist != NULL);
}


/*
** DestroyList()
**
** Deletes a list.
**
** Arguments:     hlist - handle to list to be deleted
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyList(HLIST hlist)
{
   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   DeleteAllNodes(hlist);

   /* Delete list. */

   FreeMemory((PLIST)hlist);

   return;
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** AddNode()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL AddNode(HLIST hlist, COMPARESORTEDNODESPROC csnp, PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   if (ADD_NODES_IN_SORTED_ORDER((PCLIST)hlist))
   {
      ADDNODEACTION ana;

      ana = SearchForNode(hlist, csnp, pcv, phnode);

      ASSERT(ana != ANA_FOUND);

      switch (ana)
      {
         case ANA_INSERT_BEFORE_NODE:
            bResult = InsertNodeBefore(*phnode, csnp, pcv, phnode);
            break;

         case ANA_INSERT_AFTER_NODE:
            bResult = InsertNodeAfter(*phnode, csnp, pcv, phnode);
            break;

         default:
            ASSERT(ana == ANA_INSERT_AT_HEAD);
            bResult = InsertNodeAtFront(hlist, csnp, pcv, phnode);
            break;
      }
   }
   else
      bResult = InsertNodeAtFront(hlist, csnp, pcv, phnode);

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}


/*
** InsertNodeAtFront()
**
** Inserts a node at the front of a list.
**
** Arguments:     hlist - handle to list that node is to be inserted at head of
**                pcv - data to be stored in node
**
** Returns:       Handle to new node, or NULL if unsuccessful.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InsertNodeAtFront(HLIST hlist, COMPARESORTEDNODESPROC csnp, PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

#ifdef DEBUG

   /* Make sure the correct index was given for insertion. */

   if (ADD_NODES_IN_SORTED_ORDER((PCLIST)hlist))
   {
      HNODE hnodeNew;
      ADDNODEACTION anaNew;

      anaNew = SearchForNode(hlist, csnp, pcv, &hnodeNew);

      ASSERT(anaNew != ANA_FOUND);
      ASSERT(anaNew == ANA_INSERT_AT_HEAD ||
             (anaNew == ANA_INSERT_BEFORE_NODE &&
              hnodeNew == (HNODE)(((PCLIST)hlist)->node.pnodeNext)));
   }

#endif

   bResult = AllocateMemory(sizeof(*pnode), &pnode);

   if (bResult)
   {
      /* Add new node to front of list. */

      pnode->pnodePrev = (PNODE)hlist;
      pnode->pnodeNext = ((PLIST)hlist)->node.pnodeNext;
      pnode->pcv = pcv;

      ((PLIST)hlist)->node.pnodeNext = pnode;

      /* Any more nodes in list? */

      if (pnode->pnodeNext)
         pnode->pnodeNext->pnodePrev = pnode;

      *phnode = (HNODE)pnode;
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}


/*
** InsertNodeBefore()
**
** Inserts a new node in a list before a given node.
**
** Arguments:     hnode - handle to node that new node is to be inserted before
**                pcv - data to be stored in node
**
** Returns:       Handle to new node, or NULL if unsuccessful.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InsertNodeBefore(HNODE hnode, COMPARESORTEDNODESPROC csnp, PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hnode, NODE));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

#ifdef DEBUG

   {
      HLIST hlistParent;

      /* Make sure the correct index was given for insertion. */

      hlistParent = GetList(hnode);

      if (ADD_NODES_IN_SORTED_ORDER((PCLIST)hlistParent))
      {
         HNODE hnodeNew;
         ADDNODEACTION anaNew;

         anaNew = SearchForNode(hlistParent, csnp, pcv, &hnodeNew);

         ASSERT(anaNew != ANA_FOUND);
         ASSERT((anaNew == ANA_INSERT_BEFORE_NODE &&
                 hnodeNew == hnode) ||
                (anaNew == ANA_INSERT_AFTER_NODE &&
                 hnodeNew == (HNODE)(((PCNODE)hnode)->pnodePrev)) ||
                (anaNew == ANA_INSERT_AT_HEAD &&
                 hnode == (HNODE)(((PCLIST)hlistParent)->node.pnodeNext)));
      }
   }

#endif

   bResult = AllocateMemory(sizeof(*pnode), &pnode);

   if (bResult)
   {
      /* Insert new node before given node. */

      pnode->pnodePrev = ((PNODE)hnode)->pnodePrev;
      pnode->pnodeNext = (PNODE)hnode;
      pnode->pcv = pcv;

      ((PNODE)hnode)->pnodePrev->pnodeNext = pnode;

      ((PNODE)hnode)->pnodePrev = pnode;

      *phnode = (HNODE)pnode;
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}


/*
** InsertNodeAfter()
**
** Inserts a new node in a list after a given node.
**
** Arguments:     hnode - handle to node that new node is to be inserted after
**                pcv - data to be stored in node
**
** Returns:       Handle to new node, or NULL if unsuccessful.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InsertNodeAfter(HNODE hnode, COMPARESORTEDNODESPROC csnp, PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hnode, NODE));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

#ifdef DEBUG

   /* Make sure the correct index was given for insertion. */

   {
      HLIST hlistParent;

      /* Make sure the correct index was given for insertion. */

      hlistParent = GetList(hnode);

      if (ADD_NODES_IN_SORTED_ORDER((PCLIST)hlistParent))
      {
         HNODE hnodeNew;
         ADDNODEACTION anaNew;

         anaNew = SearchForNode(hlistParent, csnp, pcv, &hnodeNew);

         ASSERT(anaNew != ANA_FOUND);
         ASSERT((anaNew == ANA_INSERT_AFTER_NODE &&
                 hnodeNew == hnode) ||
                (anaNew == ANA_INSERT_BEFORE_NODE &&
                 hnodeNew == (HNODE)(((PCNODE)hnode)->pnodeNext)));
      }
   }

#endif

   bResult = AllocateMemory(sizeof(*pnode), &pnode);

   if (bResult)
   {
      /* Insert new node after given node. */

      pnode->pnodePrev = (PNODE)hnode;
      pnode->pnodeNext = ((PNODE)hnode)->pnodeNext;
      pnode->pcv = pcv;

      /* Are we inserting after the tail of the list? */

      if (((PNODE)hnode)->pnodeNext)
         /* No. */
         ((PNODE)hnode)->pnodeNext->pnodePrev = pnode;

      ((PNODE)hnode)->pnodeNext = pnode;

      *phnode = (HNODE)pnode;
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** DeleteNode()
**
** Removes a node from a list.
**
** Arguments:     hnode - handle to node to be removed
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void DeleteNode(HNODE hnode)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));

   /*
    * There is always a previous node for normal list nodes.  Even the head
    * list node is preceded by the list's leading LIST node.
    */

   ((PNODE)hnode)->pnodePrev->pnodeNext = ((PNODE)hnode)->pnodeNext;

   /* Any more nodes in list? */

   if (((PNODE)hnode)->pnodeNext)
      ((PNODE)hnode)->pnodeNext->pnodePrev = ((PNODE)hnode)->pnodePrev;

   FreeMemory((PNODE)hnode);

   return;
}


/*
** DeleteAllNodes()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DeleteAllNodes(HLIST hlist)
{
   PNODE pnodePrev;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   /* Walk list, starting with first node after head, deleting each node. */

   pnodePrev = ((PLIST)hlist)->node.pnodeNext;

   /*
    * Deleting the tail node in the loop forces us to add an extra
    * comparison to the body of the loop.  Trade speed for size here.
    */

   while (pnodePrev)
   {
      pnode = pnodePrev->pnodeNext;

      FreeMemory(pnodePrev);

      pnodePrev = pnode;

      if (pnode)
         pnode = pnode->pnodeNext;
   }

   ((PLIST)hlist)->node.pnodeNext = NULL;

   return;
}


/*
** GetNodeData()
**
** Gets the data stored in a node.
**
** Arguments:     hnode - handle to node whose data is to be returned
**
** Returns:       Pointer to node's data.
**
** Side Effects:  none
*/
PUBLIC_CODE PVOID GetNodeData(HNODE hnode)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));

   return((PVOID)(((PNODE)hnode)->pcv));
}


/*
** SetNodeData()
**
** Sets the data stored in a node.
**
** Arguments:     hnode - handle to node whose data is to be set
**                pcv - node data
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void SetNodeData(HNODE hnode, PCVOID pcv)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));

   ((PNODE)hnode)->pcv = pcv;

   return;
}


/*
** GetNodeCount()
**
** Counts the number of nodes in a list.
**
** Arguments:     hlist - handle to list whose nodes are to be counted
**
** Returns:       Number of nodes in list.
**
** Side Effects:  none
**
** N.b., this is an O(n) operation since we don't explicitly keep track of the
** number of nodes in a list.
*/
PUBLIC_CODE ULONG GetNodeCount(HLIST hlist)
{
   PNODE pnode;
   ULONG ulcNodes;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   ulcNodes = 0;

   for (pnode = ((PLIST)hlist)->node.pnodeNext;
        pnode;
        pnode = pnode->pnodeNext)
   {
      ASSERT(ulcNodes < ULONG_MAX);
      ulcNodes++;
   }

   return(ulcNodes);
}


/*
** IsListEmpty()
**
** Determines whether or not a list is empty.
**
** Arguments:     hlist - handle to list to be checked
**
** Returns:       TRUE if list is empty, or FALSE if not.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsListEmpty(HLIST hlist)
{
   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   return(((PLIST)hlist)->node.pnodeNext == NULL);
}


/*

   To walk a list:
   ---------------

   {
      BOOL bContinue;
      HNODE hnode;

      for (bContinue = GetFirstNode(hlist, &hnode);
           bContinue;
           bContinue = GetNextNode(hnode, &hnode))
         DoSomethingWithNode(hnode);
   }

   or:
   ---

   {
      HNODE hnode;

      if (GetFirstNode(hlist, &hnode))
      {
         do
         {
            DoSomethingWithNode(hnode);
         }
         while (GetNextNode(hnode, &hnode));
      }
   }

   To compare nodes by adjacent pairs:
   -----------------------------------

   {
      HNODE hnodePrev;

      if (GetFirstNode(hlist, &hnodePrev))
      {
         PFOO pfooPrev;
         HNODE hnodeNext;

         pfooPrev = GetNodeData(hnodePrev);

         while (GetNextNode(hnodePrev, &hnodeNext))
         {
            PFOO pfooNext;

            pfooNext = GetNodeData(hnodeNext);

            CompareFoos(pfooPrev, pfooNext);

            hnodePrev = hnodeNext;
            pfooPrev = pfooNext;
         }
      }
   }

   To destroy nodes in a list:
   ---------------------------

   {
      BOOL bContinue;
      HNODE hnodePrev;

      bContinue = GetFirstNode(hlist, &hnodePrev);

      while (bContinue)
      {
         HNODE hnodeNext;

         bContinue = GetNextNode(hnodePrev, &hnodeNext);

         DeleteNode(hnodePrev);

         hnodePrev = hnodeNext;
      }
   }

*/


/*
** GetFirstNode()
**
** Gets the head node in a list.
**
** Arguments:     hlist - handle to list whose head node is to be retrieved
**
** Returns:       Handle to head list node, or NULL if list is empty.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetFirstNode(HLIST hlist, PHNODE phnode)
{
   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   *phnode = (HNODE)(((PLIST)hlist)->node.pnodeNext);

   ASSERT(! *phnode || IS_VALID_HANDLE(*phnode, NODE));

   return(*phnode != NULL);
}


/*
** GetNextNode()
**
** Gets the next node in a list.
**
** Arguments:     hnode - handle to current node
**                phnode - pointer to HNODE to be filled in with handle to next
**                         node in list, *phnode is only valid if GetNextNode()
**                         returns TRUE
**
** Returns:       TRUE if there is another node in the list, or FALSE if there
**                are no more nodes in the list.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetNextNode(HNODE hnode, PHNODE phnode)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   *phnode = (HNODE)(((PNODE)hnode)->pnodeNext);

   ASSERT(! *phnode || IS_VALID_HANDLE(*phnode, NODE));

   return(*phnode != NULL);
}


/*
** GetPrevNode()
**
** Gets the previous node in a list.
**
** Arguments:     hnode - handle to current node
**
** Returns:       Handle to previous node in list, or NULL if there are no
**                previous nodes in the list.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetPrevNode(HNODE hnode, PHNODE phnode)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   /* Is this the first node in the list? */

   if (((PNODE)hnode)->pnodePrev->pnodePrev)
   {
      *phnode = (HNODE)(((PNODE)hnode)->pnodePrev);
      ASSERT(IS_VALID_HANDLE(*phnode, NODE));
   }
   else
      *phnode = NULL;

   return(*phnode != NULL);
}


/*
** AppendList()
**
** Appends one list on to another, leaving the source list empty.
**
** Arguments:     hlistDest - handle to destination list to append to
**                hlistSrc - handle to source list to truncate
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., all HNODEs from both lists remain valid.
*/
PUBLIC_CODE void AppendList(HLIST hlistDest, HLIST hlistSrc)
{
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlistDest, LIST));
   ASSERT(IS_VALID_HANDLE(hlistSrc, LIST));

   if (hlistSrc != hlistDest)
   {
      /* Find last node in destination list to append to. */

      /*
       * N.b., start with the actual LIST node here, not the first node in the
       * list, in case the list is empty.
       */

      for (pnode = &((PLIST)hlistDest)->node;
           pnode->pnodeNext;
           pnode = pnode->pnodeNext)
         ;

      /* Append the source list to the last node in the destination list. */

      pnode->pnodeNext = ((PLIST)hlistSrc)->node.pnodeNext;

      if (pnode->pnodeNext)
         pnode->pnodeNext->pnodePrev = pnode;

      ((PLIST)hlistSrc)->node.pnodeNext = NULL;
   }
   else
      WARNING_OUT((TEXT("AppendList(): Source list same as destination list (%#lx)."),
                   hlistDest));

   return;
}


/*
** SearchSortedList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SearchSortedList(HLIST hlist, COMPARESORTEDNODESPROC csnp,
                                  PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;

   /* pcv may be any value */

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_CODE_PTR(csnp, COMPARESORTEDNODESPROC));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   ASSERT(ADD_NODES_IN_SORTED_ORDER((PCLIST)hlist));

   bResult = (SearchForNode(hlist, csnp, pcv, phnode) == ANA_FOUND);

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}


/*
** SearchUnsortedList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SearchUnsortedList(HLIST hlist, COMPAREUNSORTEDNODESPROC cunp,
                                    PCVOID pcv, PHNODE phn)
{
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_CODE_PTR(cunp, COMPAREUNSORTEDNODESPROC));
   ASSERT(IS_VALID_WRITE_PTR(phn, HNODE));

   *phn = NULL;

   for (pnode = ((PLIST)hlist)->node.pnodeNext;
        pnode;
        pnode = pnode->pnodeNext)
   {
      if ((*cunp)(pcv, pnode->pcv) == CR_EQUAL)
      {
         *phn = (HNODE)pnode;
         break;
      }
   }

   return(*phn != NULL);
}


/*
** WalkList()
**
** Walks a list, calling a callback function with each list node's data and
** caller supplied data.
**
** Arguments:     hlist - handle to list to be searched
**                wlp - callback function to be called with each list node's
**                      data, called as:
**
**                         bContinue = (*wlwdp)(pv, pvRefData);
**
**                      wlp should return TRUE to continue the walk, or FALSE
**                      to halt the walk
**                pvRefData - data to pass to callback function
**
** Returns:       FALSE if callback function aborted the walk.  TRUE if the
**                walk completed.
**
** N.b., the callback function is allowed to delete the node it is passed.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL WalkList(HLIST hlist, WALKLIST wlp, PVOID pvRefData)
{
   BOOL bResult = TRUE;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_CODE_PTR(wlp, WALKLISTPROC));

   pnode = ((PLIST)hlist)->node.pnodeNext;

   while (pnode)
   {
      PNODE pnodeNext;

      pnodeNext = pnode->pnodeNext;

      if ((*wlp)((PVOID)(pnode->pcv), pvRefData))
         pnode = pnodeNext;
      else
      {
         bResult = FALSE;
         break;
      }
   }

   return(bResult);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidHLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHLIST(HLIST hlist)
{
   return(IS_VALID_STRUCT_PTR((PLIST)hlist, CLIST));
}


/*
** IsValidHNODE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHNODE(HNODE hnode)
{
   return(IS_VALID_STRUCT_PTR((PNODE)hnode, CNODE));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\olestock.h ===
/*
 * olestock.h - Stock OLE header file.
 */


/* Types
 ********/

/* IDs */

DECLARE_STANDARD_TYPES(GUID);
DECLARE_STANDARD_TYPES(CLSID);
DECLARE_STANDARD_TYPES(IID);

typedef PROC *Interface;
DECLARE_STANDARD_TYPES(Interface);

/* interfaces */

DECLARE_STANDARD_TYPES(IAdviseSink);
DECLARE_STANDARD_TYPES(IBindCtx);
DECLARE_STANDARD_TYPES(IClassFactory);
DECLARE_STANDARD_TYPES(IDataObject);
DECLARE_STANDARD_TYPES(IEnumFORMATETC);
DECLARE_STANDARD_TYPES(IEnumSTATDATA);
DECLARE_STANDARD_TYPES(IMalloc);
DECLARE_STANDARD_TYPES(IMoniker);
DECLARE_STANDARD_TYPES(IPersist);
DECLARE_STANDARD_TYPES(IPersistFile);
DECLARE_STANDARD_TYPES(IPersistStorage);
DECLARE_STANDARD_TYPES(IPersistStream);
DECLARE_STANDARD_TYPES(IStorage);
DECLARE_STANDARD_TYPES(IStream);
DECLARE_STANDARD_TYPES(IUnknown);

/* structures */

DECLARE_STANDARD_TYPES(FORMATETC);
DECLARE_STANDARD_TYPES(STGMEDIUM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\olepig.h ===
/*
 * olepig.h - Module for indirect calling of OLE32.DLL functions description.
 */


/* Prototypes
 *************/

/* olepig.c */

extern BOOL ProcessInitOLEPigModule(void);
extern void ProcessExitOLEPigModule(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\oleutil.h ===
/*
 * oleutil.h - OLE utility functions description.
 */


/* Macros
 *********/

/* interface pointer to class pointer conversion macros */

#define IfaceOffset(class, iface)            ((UINT)&(((class *)0)->iface))
#define ClassFromIface(class, iface, piface) ((class *)(((PBYTE)piface) - IfaceOffset(class, iface)))

/* macro wrappers for CompareGUIDs() */

#define CompareClassIDs(pcclsid1, pcclsid2)  CompareGUIDs(pcclsid1, pcclsid2)
#define CompareInterfaceIDs(pciid1, pciid2)  CompareGUIDs(pciid1, pciid2)


/* Types
 ********/

/* interfaces */

DECLARE_STANDARD_TYPES(INotifyReplica);
DECLARE_STANDARD_TYPES(IReconcileInitiator);
DECLARE_STANDARD_TYPES(IReconcilableObject);
DECLARE_STANDARD_TYPES(IBriefcaseInitiator);


/* Prototypes
 *************/

/* oleutil.c */

extern HRESULT GetClassFileByExtension(LPCTSTR, PCLSID);
extern HRESULT GetReconcilerClassID(LPCTSTR, PCLSID);
extern HRESULT GetCopyHandlerClassID(LPCTSTR, PCLSID);
extern HRESULT GetReplicaNotificationClassID(LPCTSTR, PCLSID);
extern COMPARISONRESULT CompareGUIDs(PCGUID, PCGUID);
extern TWINRESULT TranslateHRESULTToTWINRESULT(HRESULT);

#ifdef DEBUG

extern BOOL IsValidPCINotifyReplica(PCINotifyReplica);
extern BOOL IsValidPCIReconcileInitiator(PCIReconcileInitiator);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\olepig.c ===
/*
 * olepig.c - Module for indirect calling of OLE32.DLL functions.
 */


/*

    OLE32.DLL should be redesigned and reimplemented so that it can
be dynalinked to like a well-behaved DLL.  OLE32.DLL is currently so slow and
piggy that we are forced to delay loading it until absolutely necessary.

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include <ole2ver.h>


/* Constants
 ************/

#define OLE_PIG_MODULE              TEXT("ole32.dll")


/* Types
 ********/

/* OLE APIs */

typedef struct _olevtbl
{
   DWORD   (STDAPICALLTYPE *CoBuildVersion)(void);
   HRESULT (STDAPICALLTYPE *CoCreateInstance)(REFCLSID, PIUnknown, DWORD, REFIID, PVOID *);
   HRESULT (STDAPICALLTYPE *CoGetMalloc)(DWORD, PIMalloc *);
   HRESULT (STDAPICALLTYPE *CreateBindCtx)(DWORD, PIBindCtx *);
   HRESULT (STDAPICALLTYPE *CreateFileMoniker)(LPCOLESTR, PIMoniker *);
   HRESULT (STDAPICALLTYPE *OleInitialize)(PIMalloc);
   HRESULT (STDAPICALLTYPE *StgOpenStorage)(const OLECHAR *, PIStorage, DWORD, SNB, DWORD, PIStorage *);
}
OLEVTBL;
DECLARE_STANDARD_TYPES(OLEVTBL);


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* OLE module handle */

PRIVATE_DATA HANDLE MhmodOLE = NULL;

/* pointer to vtable of OLE functions */

PRIVATE_DATA POLEVTBL Mpolevtbl = NULL;

/* TLS slot used to store OLE thread initialization state */

PRIVATE_DATA DWORD MdwOLEInitSlot = TLS_OUT_OF_INDEXES;

#pragma data_seg()


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL IsOLELoaded(void);
PRIVATE_CODE BOOL LoadOLE(void);
PRIVATE_CODE void UnloadOLE(void);
PRIVATE_CODE BOOL InitializeOLE(void);
PRIVATE_CODE BOOL GetOLEProc(LPSTR, PROC *);
PRIVATE_CODE BOOL FillOLEVTable(void);

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCOLEVTBL(PCOLEVTBL);
PRIVATE_CODE BOOL OLELoadedStateOK(void);
PRIVATE_CODE BOOL OLENotLoadedStateOK(void);
PRIVATE_CODE BOOL OLEStateOk(void);

#endif


/*
** IsOLELoaded()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsOLELoaded(void)
{
   ASSERT(OLEStateOk());

   return(MhmodOLE != NULL);
}


/*
** LoadOLE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL LoadOLE(void)
{
   BOOL bResult;

   if (IsOLELoaded())
      bResult = TRUE;
   else
   {
      bResult = FALSE;

      MhmodOLE = LoadLibrary(OLE_PIG_MODULE);

      if (MhmodOLE)
      {
         if (FillOLEVTable())
         {
            DWORD dwBuildVersion;

            dwBuildVersion = Mpolevtbl->CoBuildVersion();

            /* Require same major version and same or newer minor version. */

            if (HIWORD(dwBuildVersion) == rmm &&
                LOWORD(dwBuildVersion) >= rup)
            {
               bResult = TRUE;

               TRACE_OUT((TEXT("LoadOLE(): %s loaded.  Oink oink!"),
                          OLE_PIG_MODULE));
            }
            else
               WARNING_OUT((TEXT("LoadOLE(): Bad %s version %u.%u.  This module was built with %s version %u.%u."),
                            OLE_PIG_MODULE,
                            (UINT)HIWORD(dwBuildVersion),
                            (UINT)LOWORD(dwBuildVersion),
                            OLE_PIG_MODULE,
                            (UINT)rmm,
                            (UINT)rup));
         }
         else
            WARNING_OUT((TEXT("LoadOLE(): FillOLEVTable() failed.")));
      }
      else
         WARNING_OUT((TEXT("LoadOLE(): LoadLibrary(%s) failed."),
                      OLE_PIG_MODULE));

      if (! bResult)
         UnloadOLE();
   }

   if (bResult)
   {
      bResult = InitializeOLE();

      if (! bResult)
         WARNING_OUT((TEXT("LoadOLE(): %s loaded, but InitializeOLE() failed."),
                      OLE_PIG_MODULE));
   }

   ASSERT(OLEStateOk());

   return(bResult);
}


/*
** UnloadOLE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void UnloadOLE(void)
{
   if (Mpolevtbl)
   {
      FreeMemory(Mpolevtbl);
      Mpolevtbl = NULL;

      TRACE_OUT((TEXT("UnloadOLE(): Freed %s vtable."),
                 OLE_PIG_MODULE));
   }

   if (MhmodOLE)
   {
      /* Don't call CoUninitialize() here.  OLE32.DLL will. */

      FreeLibrary(MhmodOLE);
      MhmodOLE = NULL;

      TRACE_OUT((TEXT("UnloadOLE(): Freed %s."),
                 OLE_PIG_MODULE));
   }

   ASSERT(OLENotLoadedStateOK());

   return;
}


/*
** InitializeOLE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL InitializeOLE(void)
{
   BOOL bResult;

   ASSERT(IsOLELoaded());
   ASSERT(MdwOLEInitSlot != TLS_OUT_OF_INDEXES);

   if (TlsGetValue(MdwOLEInitSlot))
      bResult = TRUE;
   else
   {
      HRESULT hr;

      hr = Mpolevtbl->OleInitialize(NULL);

      bResult = (SUCCEEDED(hr) ||
                 hr == CO_E_ALREADYINITIALIZED);

      if (hr == CO_E_ALREADYINITIALIZED)
         WARNING_OUT((TEXT("InitializeOLE(): OLE already initialized for thread %lx.  OleInitialize() returned %s."),
                      GetCurrentThreadId(),
                      GetHRESULTString(hr)));

      if (bResult)
      {
         EVAL(TlsSetValue(MdwOLEInitSlot, (PVOID)TRUE));

         TRACE_OUT((TEXT("InitializeOLE(): OLE initialized for thread %lx.  Using apartment threading model."),
                    GetCurrentThreadId()));
      }
      else
         WARNING_OUT((TEXT("InitializeOLE(): OleInitialize() failed for thread %lx, returning %s."),
                      GetCurrentThreadId(),
                      GetHRESULTString(hr)));
   }

   return(bResult);
}


/*
** GetOLEProc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GetOLEProc(LPSTR pcszProc, PROC *pfp)
{
   //ASSERT(IS_VALID_STRING_PTR(pcszProc, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pfp, PROC));

   ASSERT(IS_VALID_HANDLE(MhmodOLE, MODULE));

   *pfp = GetProcAddress(MhmodOLE, pcszProc);

   if (*pfp)
      TRACE_OUT((TEXT("GetOLEProc(): Got address of %s!%s."),
                 OLE_PIG_MODULE,
                 pcszProc));
   else
      WARNING_OUT((TEXT("GetOLEProc(): Failed to get address of %s!%s."),
                   OLE_PIG_MODULE,
                   pcszProc));

   ASSERT(! *pfp ||
          IS_VALID_CODE_PTR(*pfp, PROC));

   return(*pfp != NULL);
}


/*
** FillOLEVTable()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FillOLEVTable(void)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(MhmodOLE, MODULE));

   bResult = AllocateMemory(sizeof(*Mpolevtbl), &Mpolevtbl);

   if (bResult)
   {
      bResult = (GetOLEProc("CoBuildVersion",      &(PROC)(Mpolevtbl->CoBuildVersion)) &&
                 GetOLEProc("CoCreateInstance",    &(PROC)(Mpolevtbl->CoCreateInstance)) &&
                 GetOLEProc("CoGetMalloc",         &(PROC)(Mpolevtbl->CoGetMalloc)) &&
                 GetOLEProc("CreateBindCtx",       &(PROC)(Mpolevtbl->CreateBindCtx)) &&
                 GetOLEProc("CreateFileMoniker",   &(PROC)(Mpolevtbl->CreateFileMoniker)) &&
                 GetOLEProc("OleInitialize",       &(PROC)(Mpolevtbl->OleInitialize)) &&
                 GetOLEProc("StgOpenStorage",      &(PROC)(Mpolevtbl->StgOpenStorage)));


      if (bResult)
         TRACE_OUT((TEXT("FillOLEVTable(): OLE vtable filled successfully.")));
      else
      {
         FreeMemory(Mpolevtbl);
         Mpolevtbl = NULL;

         WARNING_OUT((TEXT("FillOLEVTable(): Failed to fill OLE vtable.")));
      }
   }
   else
      WARNING_OUT((TEXT("FillOLEVTable(): Out of memory.")));

   ASSERT(! bResult ||
          OLELoadedStateOK());

   return(bResult);
}


#ifdef DEBUG

/*
** IsValidPCOLEVTBL()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCOLEVTBL(PCOLEVTBL pcolevtbl)
{
   return(IS_VALID_READ_PTR(pcolevtbl, PCOLEVTBL) &&
          IS_VALID_CODE_PTR(pcolevtbl->CoBuildVersion, CoBuildVersion) &&
          IS_VALID_CODE_PTR(pcolevtbl->CoCreateInstance, CoCreateInstance) &&
          IS_VALID_CODE_PTR(pcolevtbl->CoGetMalloc, CoGetMalloc) &&
          IS_VALID_CODE_PTR(pcolevtbl->CreateBindCtx, CreateBindCtx) &&
          IS_VALID_CODE_PTR(pcolevtbl->CreateFileMoniker, CreateFileMoniker) &&
          IS_VALID_CODE_PTR(pcolevtbl->OleInitialize, OleInitialize) &&
          IS_VALID_CODE_PTR(pcolevtbl->StgOpenStorage, StgOpenStorage));
}


/*
** OLELoadedStateOK()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL OLELoadedStateOK(void)
{
   return(IS_VALID_HANDLE(MhmodOLE, MODULE) &&
          IS_VALID_STRUCT_PTR(Mpolevtbl, COLEVTBL));
}


/*
** OLENotLoadedStateOK()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL OLENotLoadedStateOK(void)
{
   return(! MhmodOLE &&
          ! Mpolevtbl);
}


/*
** OLEStateOk()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL OLEStateOk(void)
{
   return(OLELoadedStateOK() ||
          OLENotLoadedStateOK);
}

#endif


/****************************** Public Functions *****************************/


/*
** ProcessInitOLEPigModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ProcessInitOLEPigModule(void)
{
   BOOL bResult;

   ASSERT(MdwOLEInitSlot == TLS_OUT_OF_INDEXES);

   MdwOLEInitSlot = TlsAlloc();

   bResult = (MdwOLEInitSlot != TLS_OUT_OF_INDEXES);

   if (bResult)
   {
      EVAL(TlsSetValue(MdwOLEInitSlot, (PVOID)FALSE));

      TRACE_OUT((TEXT("ProcessInitOLEPigModule(): Using thread local storage slot %lu for OLE initialization state."),
                 MdwOLEInitSlot));
   }
   else
      ERROR_OUT((TEXT("ProcessInitOLEPigModule(): TlsAlloc() failed to allocate thread local storage for OLE initialization state.")));

   return(bResult);
}


/*
** ProcessExitOLEPigModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ProcessExitOLEPigModule(void)
{
   UnloadOLE();

   if (MdwOLEInitSlot != TLS_OUT_OF_INDEXES)
   {
      EVAL(TlsFree(MdwOLEInitSlot));
      MdwOLEInitSlot= TLS_OUT_OF_INDEXES;
   }

   return;
}


/*
** CoCreateInstance()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
HRESULT STDAPICALLTYPE CoCreateInstance(REFCLSID rclsid, PIUnknown piunkOuter,
                                        DWORD dwClsCtx, REFIID riid,
                                        PVOID *ppv)
{
   HRESULT hr;

   if (LoadOLE())
      hr = Mpolevtbl->CoCreateInstance(rclsid, piunkOuter, dwClsCtx, riid, ppv);
   else
      hr = E_FAIL;

   return(hr);
}


/*
** CoGetMalloc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
HRESULT STDAPICALLTYPE CoGetMalloc(DWORD dwMemContext, PIMalloc *ppimalloc)
{
   HRESULT hr;

   if (LoadOLE())
      hr = Mpolevtbl->CoGetMalloc(dwMemContext, ppimalloc);
   else
      hr = E_FAIL;

   return(hr);
}


/*
** CreateBindCtx()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
HRESULT STDAPICALLTYPE CreateBindCtx(DWORD dwReserved, PIBindCtx *ppibindctx)
{
   HRESULT hr;

   if (LoadOLE())
      hr = Mpolevtbl->CreateBindCtx(dwReserved, ppibindctx);
   else
      hr = E_FAIL;

   return(hr);
}


/*
** CreateFileMoniker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
HRESULT STDAPICALLTYPE CreateFileMoniker(LPCOLESTR pwszPath, PIMoniker *ppimk)
{
   HRESULT hr;

   if (LoadOLE())
      hr = Mpolevtbl->CreateFileMoniker(pwszPath, ppimk);
   else
      hr = E_FAIL;

   return(hr);
}


/*
** StgOpenStorage()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
HRESULT STDAPICALLTYPE StgOpenStorage(LPCOLESTR pwszName,
                                      PIStorage pistgPriority, DWORD dwMode,
                                      SNB snbExclude, DWORD dwReserved,
                                      PIStorage *ppistgOpen)
{
   HRESULT hr;

   if (LoadOLE())
      hr = Mpolevtbl->StgOpenStorage(pwszName, pistgPriority, dwMode,
                                     snbExclude, dwReserved, ppistgOpen);
   else
      hr = E_FAIL;

   return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\olevalid.h ===
/*
 * olevalid.h - OLE validation functions description.
 */


/* Prototypes
 *************/

/* olevalid.c */

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidPCGUID(PCGUID);
extern BOOL IsValidPCCLSID(PCCLSID);
extern BOOL IsValidPCIID(PCIID);
extern BOOL IsValidREFIID(REFIID);
extern BOOL IsValidREFCLSID(REFCLSID);
extern BOOL IsValidPCInterface(PCVOID);
extern BOOL IsValidPCIClassFactory(PCIClassFactory);
extern BOOL IsValidPCIDataObject(PCIDataObject);
extern BOOL IsValidPCIMalloc(PCIMalloc);
extern BOOL IsValidPCIMoniker(PCIMoniker);
extern BOOL IsValidPCIPersist(PCIPersist);
extern BOOL IsValidPCIPersistFile(PCIPersistFile);
extern BOOL IsValidPCIPersistStorage(PCIPersistStorage);
extern BOOL IsValidPCIPersistStream(PCIPersistStream);
extern BOOL IsValidPCIStorage(PCIStorage);
extern BOOL IsValidPCIStream(PCIStream);
extern BOOL IsValidPCIUnknown(PCIUnknown);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\oleutil.c ===
/*
 * oleutil.c - OLE utility functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "oleutil.h"


/* Macros
 *********/

/* macro for translating an HRESULT to a TWINRESULT */

#define HRESULTToTWINRESULT(hr, TR)    case hr: tr = TR; break


/* Constants
 ************/

/* maximum allowed registry lengths */

#define MAX_REG_KEY_LEN                MAX_PATH_LEN
#define MAX_REG_VALUE_LEN              MAX_PATH_LEN

/* subkeys and associated lengths */

#define CLSID_SUBKEY                   TEXT("CLSID")
/* CLSID subkey length in bytes, including null terminator */
#define CLSID_SUBKEY_LEN               (5 + 1)

#define IN_PROC_SERVER_SUBKEY          TEXT("InProcServer32")
/* InProcServer32 subkey length in bytes, including null terminator */
#define IN_PROC_SERVER_SUBKEY_LEN      (14 + 1)

#define LOCAL_SERVER_SUBKEY            TEXT("LocalServer32")
/* LocalServer32 subkey length in bytes, including null terminator */
#define LOCAL_SERVER_SUBKEY_LEN        (13 + 1)

#define RECONCILER_SUBKEY              TEXT("Roles\\Reconciler")
/* InProcServer32 subkey length in bytes, including null terminator */
#define RECONCILER_SUBKEY_LEN          (5 + 1 + 10 + 1)

#define NOTIFY_SUBKEY                  TEXT("Roles\\NotifyReplica")
/* InProcServer32 subkey length in bytes, including null terminator */
#define NOTIFY_SUBKEY_LEN              (5 + 1 + 13 + 1)

#define COPY_SUBKEY                    TEXT("SingleChangeHook")
/* copy subkey length in bytes, including null terminator */
#define COPY_SUBKEY_LEN                (16 + 1)

/*
 * length of GUID subkey string in bytes, including null terminator
 *
 * "{12345678-1234-1234-1234-123456789012}"
 */

#define GUID_SUBKEY_LEN                (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

/*
 * class ID key length in bytes, including null terminator
 *
 * "CLSID\{12345678-1234-1234-1234-123456789012}"
 */

#define CLSID_REG_KEY_LEN              (CLSID_SUBKEY_LEN + GUID_SUBKEY_LEN)

/*
 * InProcServer32 key length in bytes, including null terminator
 *
 * "CLSID\{12345678-1234-1234-1234-123456789012}\InProcServer32"
 */

#define IN_PROC_SERVER_REG_KEY_LEN     (CLSID_REG_KEY_LEN + IN_PROC_SERVER_SUBKEY_LEN)

/*
 * LocalServer32 key length in bytes, including null terminator
 *
 * "CLSID\{12345678-1234-1234-1234-123456789012}\LocalServer32"
 */

#define LOCAL_SERVER_REG_KEY_LEN       (CLSID_REG_KEY_LEN + LOCAL_SERVER_SUBKEY_LEN)

/*
 * reconciler key length in bytes, including null terminator
 *
 * "CLSID\{12345678-1234-1234-1234-123456789012}\Roles\Reconciler"
 */

#define RECONCILER_REG_KEY_LEN         (CLSID_REG_KEY_LEN + RECONCILER_SUBKEY_LEN)

/*
 * notify replica key length in bytes, including null terminator
 *
 * "CLSID\{12345678-1234-1234-1234-123456789012}\Roles\NotifyReplica"
 */

#define NOTIFY_REG_KEY_LEN             (CLSID_REG_KEY_LEN + NOTIFY_SUBKEY_LEN)

/*
 * copy key length in bytes, including null terminator
 *
 * "CLSID\{12345678-1234-1234-1234-123456789012}\SingleChangeHook"
 */

#define COPY_REG_KEY_LEN               (CLSID_REG_KEY_LEN + COPY_SUBKEY_LEN)


/* Macros
 *********/

/*
 * Determine whether or not an integer value is within a given inclusive range.
 */

#define IsWithin(test, first, last)    ((UINT)((test) - (first)) <= (UINT)((last) - (first)))


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE void MakeClsIDSubKey(PCGUID, LPCTSTR, LPTSTR);
PRIVATE_CODE BOOL HexStringToDWORD(LPCTSTR *, PDWORD, UINT, TCHAR);
PRIVATE_CODE BOOL StringToGUID(LPCTSTR, PGUID);
PRIVATE_CODE HRESULT GetClassID(LPCTSTR, LPCTSTR, PCLSID);


/*
** MakeClsIDSubKey()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void MakeClsIDSubKey(PCGUID pcguid, LPCTSTR pcszSubKey,
                             LPTSTR pszRegKeyBuf)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcguid, CGUID));
   ASSERT(IS_VALID_STRING_PTR(pcszSubKey, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRegKeyBuf, STR, CLSID_REG_KEY_LEN + lstrlen(pcszSubKey) + 1));

   /* (- 1) for null terminator. */

   EVAL(wsprintf(pszRegKeyBuf,
                 TEXT("CLSID\\{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\\%s"),
                 pcguid->Data1,
                 pcguid->Data2,
                 pcguid->Data3,
                 pcguid->Data4[0],
                 pcguid->Data4[1],
                 pcguid->Data4[2],
                 pcguid->Data4[3],
                 pcguid->Data4[4],
                 pcguid->Data4[5],
                 pcguid->Data4[6],
                 pcguid->Data4[7],
                 pcszSubKey)
        == CLSID_REG_KEY_LEN + lstrlen(pcszSubKey));

   return;
}


/*
** HexStringToDWORD()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL HexStringToDWORD(LPCTSTR *ppcsz, PDWORD pdwValue, UINT ucDigits,
                              TCHAR chDelimiter)
{
   BOOL bResult = TRUE;
   UINT u;

   /* chDelimiter may be any value. */

   ASSERT(IS_VALID_WRITE_PTR(ppcsz, LPCTSTR));
   ASSERT(IS_VALID_STRING_PTR(*ppcsz, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pdwValue, DWORD));
   ASSERT(ucDigits <= 8);

   *pdwValue = 0;

   for (u = 0; u < ucDigits; u++)
   {
     TCHAR ch = (*ppcsz)[u];

     if (IsWithin(ch, TEXT('0'), TEXT('9')))
        *pdwValue = (*pdwValue << 4) + ch - TEXT('0');
     else if (IsWithin((ch |= (TEXT('a') - TEXT('A'))), TEXT('a'), TEXT('f')))
        *pdwValue = (*pdwValue << 4) + ch - TEXT('a') + 10;
     else
     {
        WARNING_OUT((TEXT("HexStringToDWORD(): Found unrecognized hex digit %c."),
                     ch));

        bResult = FALSE;
        break;
     }
   }

   if (bResult)
   {
      if (chDelimiter)
      {
         bResult = ((*ppcsz)[u++] == chDelimiter);

         if (! bResult)
            WARNING_OUT((TEXT("HexStringToDWORD(): Character %c does not match required delimiter %c."),
                         (*ppcsz)[u],
                         chDelimiter));
      }

      *ppcsz += u;
   }

   ASSERT(IS_VALID_STRING_PTR(*ppcsz, CSTR));

   return(bResult);
}


/*
** StringToGUID()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL StringToGUID(LPCTSTR pcszGUID, PGUID pguid)
{
   BOOL bResult = FALSE;
   DWORD dwValue;
   LPCTSTR pcszNext = pcszGUID;

   ASSERT(IS_VALID_STRING_PTR(pcszGUID, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pguid, GUID));

   if (*pcszNext++ == TEXT('{') &&
       HexStringToDWORD(&pcszNext, &(pguid->Data1), sizeof(DWORD) * 2, TEXT('-')) &&
       HexStringToDWORD(&pcszNext, &dwValue, sizeof(WORD) * 2, TEXT('-')))
   {
      pguid->Data2 = (WORD)dwValue;

      if (HexStringToDWORD(&pcszNext, &dwValue, sizeof(WORD) * 2, TEXT('-')))
      {
         UINT u;
#pragma data_seg(DATA_SEG_READ_ONLY)
         static const TCHAR SrgcchDelimiters[] = { 0, TEXT('-'), 0, 0, 0, 0, 0, TEXT('}') };
#pragma data_seg()

         pguid->Data3 = (WORD)dwValue;

         bResult = TRUE;

         for (u = 0; u < ARRAY_ELEMENTS(pguid->Data4); u++)
         {
            if (HexStringToDWORD(&pcszNext, &dwValue, sizeof(BYTE) * 2,
                                 SrgcchDelimiters[u]))
               pguid->Data4[u] = (BYTE)dwValue;
            else
            {
               bResult = FALSE;
               break;
            }
         }

         if (bResult)
         {
            ASSERT(u == ARRAY_ELEMENTS(pguid->Data4));

            if (*pcszNext)
            {
               bResult = FALSE;

               WARNING_OUT((TEXT("StringToGUID(): Found %c instead of }."),
                            *pcszNext));
            }
         }
         else
            WARNING_OUT((TEXT("StringToGUID(): Bad GUID string %s."),
                         pcszGUID));
      }
   }

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(pguid, CGUID));

   return(bResult);
}


/*
** GetClassID()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT GetClassID(LPCTSTR pcszPath, LPCTSTR pcszSubKey, PCLSID pclsid)
{
   HRESULT hr;
   CLSID clsidFile;

   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszSubKey, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pclsid, CLSID));

   /* Verify string length constants. */

   /* (+ 1) for each null terminator. */

   ASSERT(lstrlen(CLSID_SUBKEY)           + 1 == CLSID_SUBKEY_LEN);
   ASSERT(lstrlen(IN_PROC_SERVER_SUBKEY)  + 1 == IN_PROC_SERVER_SUBKEY_LEN);
   ASSERT(lstrlen(LOCAL_SERVER_SUBKEY)    + 1 == LOCAL_SERVER_SUBKEY_LEN);
   ASSERT(lstrlen(RECONCILER_SUBKEY)      + 1 == RECONCILER_SUBKEY_LEN);
   ASSERT(lstrlen(NOTIFY_SUBKEY)          + 1 == NOTIFY_SUBKEY_LEN);
   ASSERT(lstrlen(COPY_SUBKEY)            + 1 == COPY_SUBKEY_LEN);

   ASSERT(lstrlen(       TEXT("{12345678-1234-1234-1234-123456789012}"))                        + 1 == GUID_SUBKEY_LEN);
   ASSERT(lstrlen(TEXT("CLSID\\{12345678-1234-1234-1234-123456789012}"))                        + 1 == CLSID_REG_KEY_LEN);
   ASSERT(lstrlen(TEXT("CLSID\\{12345678-1234-1234-1234-123456789012}\\InProcServer32"))        + 1 == IN_PROC_SERVER_REG_KEY_LEN);
   ASSERT(lstrlen(TEXT("CLSID\\{12345678-1234-1234-1234-123456789012}\\LocalServer32"))         + 1 == LOCAL_SERVER_REG_KEY_LEN);
   ASSERT(lstrlen(TEXT("CLSID\\{12345678-1234-1234-1234-123456789012}\\Roles\\Reconciler"))     + 1 == RECONCILER_REG_KEY_LEN);
   ASSERT(lstrlen(TEXT("CLSID\\{12345678-1234-1234-1234-123456789012}\\Roles\\NotifyReplica"))  + 1 == NOTIFY_REG_KEY_LEN);
   ASSERT(lstrlen(TEXT("CLSID\\{12345678-1234-1234-1234-123456789012}\\SingleChangeHook"))      + 1 == COPY_REG_KEY_LEN);

   hr = GetClassFileByExtension(pcszPath, &clsidFile);

   if (SUCCEEDED(hr))
   {
      TCHAR rgchRecRegKey[MAX_REG_KEY_LEN];
      TCHAR rgchRecGUID[GUID_SUBKEY_LEN];
      DWORD dwcbLen = sizeof(rgchRecGUID);

      hr = REGDB_E_CLASSNOTREG;

      MakeClsIDSubKey(&clsidFile, pcszSubKey, rgchRecRegKey);

      if (GetDefaultRegKeyValue(HKEY_CLASSES_ROOT, rgchRecRegKey, rgchRecGUID,
                                &dwcbLen) == ERROR_SUCCESS)
      {
         /* (+ 1) for null terminator. */

         ASSERT((DWORD)(lstrlen(rgchRecGUID) + 1) * sizeof(TCHAR)  == dwcbLen);
         ASSERT(dwcbLen * sizeof(TCHAR) <= sizeof(rgchRecGUID));

         if (StringToGUID(rgchRecGUID, pclsid))
         {
            hr = S_OK;

#ifdef DEBUG

            {
               TCHAR rgchInProcServerKey[IN_PROC_SERVER_REG_KEY_LEN];
               TCHAR rgchInProcServerValue[MAX_REG_VALUE_LEN];
               DWORD dwcbInProcLen = sizeof(rgchInProcServerValue);

               /* Display the path to the registered reconciler. */

               wsprintf(rgchInProcServerKey, TEXT("%s\\%s\\%s"), CLSID_SUBKEY,
                        rgchRecGUID, IN_PROC_SERVER_SUBKEY);

               if (GetDefaultRegKeyValue(HKEY_CLASSES_ROOT,
                                         rgchInProcServerKey,
                                         rgchInProcServerValue, &dwcbInProcLen)
                   == ERROR_SUCCESS)
                  TRACE_OUT((TEXT("GetClassID(): Found registered %s reconciler %s for file %s."),
                             IN_PROC_SERVER_SUBKEY,
                             rgchInProcServerValue,
                             pcszPath));
               else
               {
                  dwcbInProcLen = sizeof(rgchInProcServerValue);

                  wsprintf(rgchInProcServerKey, TEXT("%s\\%s\\%s"), CLSID_SUBKEY,
                           rgchRecGUID, LOCAL_SERVER_SUBKEY);

                  if (GetDefaultRegKeyValue(HKEY_CLASSES_ROOT,
                                            rgchInProcServerKey,
                                            rgchInProcServerValue,
                                            &dwcbInProcLen)
                      == ERROR_SUCCESS)
                     TRACE_OUT((TEXT("GetClassID(): Found registered %s reconciler %s for file %s."),
                                LOCAL_SERVER_SUBKEY,
                                rgchInProcServerValue,
                                pcszPath));
                  else
                     WARNING_OUT((TEXT("GetClassID(): Unregistered class ID %s listed as reconciler in %s for file %s."),
                                  rgchRecGUID,
                                  rgchRecRegKey,
                                  pcszPath));
               }
            }

#endif

         }
         else
            WARNING_OUT((TEXT("GetClassID(): Bad reconciler class ID %s specified for key %s."),
                         rgchRecGUID,
                         rgchRecRegKey));
      }
      else
         TRACE_OUT((TEXT("GetClassID(): No reconciler registered for file %s."),
                    pcszPath));
   }
   else
      TRACE_OUT((TEXT("GetClassID(): No class ID registered for file %s."),
                 pcszPath));

   ASSERT(FAILED(hr) ||
          IS_VALID_STRUCT_PTR(pclsid, CCLSID));

   return(hr);
}


/****************************** Public Functions *****************************/


/*
** GetClassFileByExtension()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT GetClassFileByExtension(LPCTSTR pcszFile, PCLSID pclsid)
{
   HRESULT hr = MK_E_INVALIDEXTENSION;
   LPCTSTR pcszExtension;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pclsid, CLSID));

   pcszExtension = ExtractExtension(pcszFile);

   if (*pcszExtension)
   {
      TCHAR rgchFileType[MAX_REG_VALUE_LEN];
      DWORD dwcbBufLen = sizeof(rgchFileType);

      ASSERT(*pcszExtension == PERIOD);

      if (GetDefaultRegKeyValue(HKEY_CLASSES_ROOT, pcszExtension, rgchFileType,
                                &dwcbBufLen) == ERROR_SUCCESS)
      {
         /* dwcbBufLen includes rgchFileType's null terminator. */

         if (dwcbBufLen + sizeof(CLSID_SUBKEY) <= sizeof(rgchFileType))
         {
            TCHAR rgchFileClsID[GUID_SUBKEY_LEN];
            DWORD dwcbFileClsIDBufLen = sizeof(rgchFileClsID);

            CatPath(rgchFileType, CLSID_SUBKEY);

            if (GetDefaultRegKeyValue(HKEY_CLASSES_ROOT, rgchFileType,
                                      rgchFileClsID, &dwcbFileClsIDBufLen)
                == ERROR_SUCCESS)
            {
               if (StringToGUID(rgchFileClsID, pclsid))
               {
                  hr = S_OK;

                  TRACE_OUT((TEXT("GetClassFileByExtension(): Retrieved class ID %s for file %s."),
                             rgchFileClsID,
                             pcszFile));
               }
               else
                  WARNING_OUT((TEXT("GetClassFileByExtension(): Invalid class ID \"%s\" in %s\\%s.  No class ID will be used."),
                               rgchFileClsID,
                               rgchFileType,
                               CLSID_SUBKEY));
            }
            else
               TRACE_OUT((TEXT("GetClassFileByExtension(): No %s subkey for file type key \"%s\".  No class ID will be used."),
                          CLSID_SUBKEY,
                          rgchFileType));
         }
         else
            WARNING_OUT((TEXT("GetClassFileByExtension(): File type \"%s\" for extension %s of file %s is too long.  No class ID will be used."),
                         rgchFileType,
                         pcszExtension,
                         pcszFile));
      }
      else
         TRACE_OUT((TEXT("GetClassFileByExtension(): No file type for extension %s of file %s.  No class ID will be used."),
                    pcszExtension,
                    pcszFile));
   }
   else
      TRACE_OUT((TEXT("GetClassFileByExtension(): File %s has no extension.  No class ID will be used."),
                 pcszFile));

   ASSERT(FAILED(hr) ||
          IS_VALID_STRUCT_PTR(pclsid, CCLSID));

   return(hr);
}


/*
** GetReconcilerClassID()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT GetReconcilerClassID(LPCTSTR pcszPath, PCLSID pclsid)
{
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pclsid, CLSID));

   return(GetClassID(pcszPath, RECONCILER_SUBKEY, pclsid));
}


/*
** GetCopyHandlerClassID()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT GetCopyHandlerClassID(LPCTSTR pcszPath, PCLSID pclsid)
{
   HRESULT hr;

   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pclsid, CLSID));

   hr = GetReconcilerClassID(pcszPath, pclsid);

   if (SUCCEEDED(hr))
   {
      TCHAR rgchCopyRegKey[COPY_REG_KEY_LEN];

      MakeClsIDSubKey(pclsid, COPY_SUBKEY, rgchCopyRegKey);

      if (RegKeyExists(HKEY_CLASSES_ROOT, rgchCopyRegKey))
         hr = S_OK;
      else
         hr = REGDB_E_CLASSNOTREG;
   }

   return(hr);
}


/*
** GetReplicaNotificationClassID()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT GetReplicaNotificationClassID(LPCTSTR pcszPath, PCLSID pclsid)
{
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pclsid, CLSID));

   return(GetClassID(pcszPath, NOTIFY_SUBKEY, pclsid));
}


/*
** CompareGUIDs()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT CompareGUIDs(PCGUID pcguid1, PCGUID pcguid2)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcguid1, CGUID));
   ASSERT(IS_VALID_STRUCT_PTR(pcguid2, CGUID));

   return(MyMemComp(pcguid1, pcguid2, sizeof(*pcguid1)));
}


/*
** TranslateHRESULTToTWINRESULT()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT TranslateHRESULTToTWINRESULT(HRESULT hr)
{
   TWINRESULT tr;

   switch (hr)
   {
      HRESULTToTWINRESULT(S_OK, TR_SUCCESS);

      HRESULTToTWINRESULT(REC_S_NOTCOMPLETE, TR_MERGE_INCOMPLETE);
      HRESULTToTWINRESULT(REC_S_NOTCOMPLETEBUTPROPAGATE, TR_MERGE_INCOMPLETE);

      HRESULTToTWINRESULT(E_ABORT, TR_ABORT);
      HRESULTToTWINRESULT(E_OUTOFMEMORY, TR_OUT_OF_MEMORY);
      HRESULTToTWINRESULT(E_FAIL, TR_RH_LOAD_FAILED);

      HRESULTToTWINRESULT(REC_E_ABORTED, TR_ABORT);
      HRESULTToTWINRESULT(REC_E_TOODIFFERENT, TR_TOO_DIFFERENT);

      default:
         if (SUCCEEDED(hr))
         {
            tr = TR_SUCCESS;

            WARNING_OUT((TEXT("TranslateHRESULTToTWINRESULT(): Translating unlisted success HRESULT %s into TWINRESULT %s."),
                         GetHRESULTString(hr),
                         GetTWINRESULTString(tr)));
         }
         else
         {
            tr = TR_RH_LOAD_FAILED;

            WARNING_OUT((TEXT("TranslateHRESULTToTWINRESULT(): Translating unlisted failure HRESULT %s into TWINRESULT %s."),
                         GetHRESULTString(hr),
                         GetTWINRESULTString(tr)));
         }
         break;
   }

   return(tr);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidPCINotifyReplica()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCINotifyReplica(PCINotifyReplica pcinr)
{
   return(IS_VALID_READ_PTR(pcinr, CINotifyReplica) &&
          IS_VALID_READ_PTR(pcinr->lpVtbl, sizeof(*(pcinr->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcinr, CIUnknown) &&
          IS_VALID_CODE_PTR(pcinr->lpVtbl->YouAreAReplica, YouAreAReplica));
}


/*
** IsValidPCIReconcileInitiator()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIReconcileInitiator(PCIReconcileInitiator pciri)
{
   return(IS_VALID_READ_PTR(pciri, CIReconcileInitiator) &&
          IS_VALID_READ_PTR(pciri->lpVtbl, sizeof(*(pciri->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pciri, CIUnknown) &&
          IS_VALID_CODE_PTR(pciri->lpVtbl->SetAbortCallback, SetAbortCallback) &&
          IS_VALID_CODE_PTR(pciri->lpVtbl->SetProgressFeedback, SetProgressFeedback));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\olevalid.c ===
/*
 * olevalid.c - OLE validation functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop



/****************************** Public Functions *****************************/


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidPCGUID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCGUID(PCGUID pcguid)
{
   /* All values are valid GUIDs. */

   return(IS_VALID_READ_PTR(pcguid, CGUID));
}


/*
** IsValidPCCLSID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCCLSID(PCCLSID pcclsid)
{
   return(IS_VALID_STRUCT_PTR(pcclsid, CGUID));
}


/*
** IsValidPCIID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIID(PCIID pciid)
{
   return(IS_VALID_STRUCT_PTR(pciid, CGUID));
}


/*
** IsValidREFIID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidREFIID(REFIID riid)
{
   return(IS_VALID_STRUCT_PTR(riid, CIID));
}


/*
** IsValidREFCLSID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidREFCLSID(REFCLSID rclsid)
{
   return(IS_VALID_STRUCT_PTR(rclsid, CCLSID));
}


/*
** IsValidPCInterface()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCInterface(PCVOID pcvi)
{
   return(IS_VALID_READ_PTR((PROC *)pcvi, PROC) &&
          IS_VALID_CODE_PTR(*((PROC *)pcvi), Method));
}


/*
** IsValidPCIClassFactory()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIClassFactory(PCIClassFactory pcicf)
{
   return(IS_VALID_READ_PTR(pcicf, CIClassFactory) &&
          IS_VALID_READ_PTR(pcicf->lpVtbl, sizeof(*(pcicf->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcicf, CIUnknown) &&
          IS_VALID_CODE_PTR(pcicf->lpVtbl->CreateInstance, CreateInstance) &&
          IS_VALID_CODE_PTR(pcicf->lpVtbl->LockServer, LockServer));
}


/*
** IsValidPCIDataObject()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIDataObject(PCIDataObject pcido)
{
   return(IS_VALID_READ_PTR(pcido, CIDataObject) &&
          IS_VALID_READ_PTR(pcido->lpVtbl, sizeof(*(pcido->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcido, CIUnknown) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->GetData, GetData) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->GetDataHere, GetDataHere) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->QueryGetData, QueryGetData) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->GetCanonicalFormatEtc, GetCanonicalFormatEtc) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->SetData, SetData) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->EnumFormatEtc, EnumFormatEtc) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->DAdvise, DAdvise) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->DUnadvise, DUnadvise) &&
          IS_VALID_CODE_PTR(pcido->lpVtbl->EnumDAdvise, EnumDAdvise));
}


/*
** IsValidPCIMalloc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIMalloc(PCIMalloc pcimalloc)
{
   return(IS_VALID_READ_PTR(pcimalloc, CIMalloc) &&
          IS_VALID_READ_PTR(pcimalloc->lpVtbl, sizeof(*(pcimalloc->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcimalloc, CIUnknown) &&
          IS_VALID_CODE_PTR(pcimalloc->lpVtbl->Alloc, Alloc) &&
          IS_VALID_CODE_PTR(pcimalloc->lpVtbl->Realloc, Realloc) &&
          IS_VALID_CODE_PTR(pcimalloc->lpVtbl->Free, Free) &&
          IS_VALID_CODE_PTR(pcimalloc->lpVtbl->GetSize, GetSize) &&
          IS_VALID_CODE_PTR(pcimalloc->lpVtbl->DidAlloc, DidAlloc) &&
          IS_VALID_CODE_PTR(pcimalloc->lpVtbl->HeapMinimize, HeapMinimize));
}


/*
** IsValidPCIMoniker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIMoniker(PCIMoniker pcimk)
{
   return(IS_VALID_READ_PTR(pcimk, CIMoniker) &&
          IS_VALID_READ_PTR(pcimk->lpVtbl, sizeof(*(pcimk->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIPersistStream)pcimk, CIPersistStream) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->BindToObject, BindToObject) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->BindToStorage, BindToStorage) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->Reduce, Reduce) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->ComposeWith, ComposeWith) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->Enum, Enum) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->IsEqual, IsEqual) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->Hash, Hash) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->IsRunning, IsRunning) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->GetTimeOfLastChange, GetTimeOfLastChange) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->Inverse, Inverse) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->CommonPrefixWith, CommonPrefixWith) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->RelativePathTo, RelativePathTo) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->GetDisplayName, GetDisplayName) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->ParseDisplayName, ParseDisplayName) &&
          IS_VALID_CODE_PTR(pcimk->lpVtbl->IsSystemMoniker, IsSystemMoniker));
}


/*
** IsValidPCIPersist()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIPersist(PCIPersist pcip)
{
   return(IS_VALID_READ_PTR(pcip, CIUnknown) &&
          IS_VALID_READ_PTR(pcip->lpVtbl, sizeof(*(pcip->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcip, CIUnknown) &&
          IS_VALID_CODE_PTR(pcip->lpVtbl->GetClassID, GetClassID));
}


/*
** IsValidPCIPersistFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIPersistFile(PCIPersistFile pcipfile)
{
   return(IS_VALID_READ_PTR(pcipfile, CIPersistFile) &&
          IS_VALID_READ_PTR(pcipfile->lpVtbl, sizeof(*(pcipfile->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIPersist)pcipfile, CIPersist) &&
          IS_VALID_CODE_PTR(pcipfile->lpVtbl->IsDirty, IsDirty) &&
          IS_VALID_CODE_PTR(pcipfile->lpVtbl->Load, Load) &&
          IS_VALID_CODE_PTR(pcipfile->lpVtbl->Save, Save) &&
          IS_VALID_CODE_PTR(pcipfile->lpVtbl->SaveCompleted, SaveCompleted) &&
          IS_VALID_CODE_PTR(pcipfile->lpVtbl->GetCurFile, GetCurFile));
}


/*
** IsValidPCIPersistStorage()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIPersistStorage(PCIPersistStorage pcipstg)
{
   return(IS_VALID_READ_PTR(pcipstg, CIPersistStorage) &&
          IS_VALID_READ_PTR(pcipstg->lpVtbl, sizeof(*(pcipstg->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIPersist)pcipstg, CIPersist) &&
          IS_VALID_CODE_PTR(pcipstg->lpVtbl->IsDirty, IsDirty) &&
          IS_VALID_CODE_PTR(pcipstg->lpVtbl->InitNew, InitNew) &&
          IS_VALID_CODE_PTR(pcipstg->lpVtbl->Load, Load) &&
          IS_VALID_CODE_PTR(pcipstg->lpVtbl->Save, Save) &&
          IS_VALID_CODE_PTR(pcipstg->lpVtbl->SaveCompleted, SaveCompleted) &&
          IS_VALID_CODE_PTR(pcipstg->lpVtbl->HandsOffStorage, HandsOffStorage));
}


/*
** IsValidPCIPersistStream()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIPersistStream(PCIPersistStream pcipstr)
{
   return(IS_VALID_READ_PTR(pcipstr, CIPersistStream) &&
          IS_VALID_READ_PTR(pcipstr->lpVtbl, sizeof(*(pcipstr->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIPersist)pcipstr, CIPersist) &&
          IS_VALID_CODE_PTR(pcipstr->lpVtbl->IsDirty, IsDirty) &&
          IS_VALID_CODE_PTR(pcipstr->lpVtbl->Load, Load) &&
          IS_VALID_CODE_PTR(pcipstr->lpVtbl->Save, Save) &&
          IS_VALID_CODE_PTR(pcipstr->lpVtbl->GetSizeMax, GetSizeMax));
}


/*
** IsValidPCIStorage()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIStorage(PCIStorage pcistg)
{
   return(IS_VALID_READ_PTR(pcistg, CIStorage) &&
          IS_VALID_READ_PTR(pcistg->lpVtbl, sizeof(*(pcistg->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcistg, CIUnknown) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->CreateStream, CreateStream) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->OpenStream, OpenStream) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->CreateStorage, CreateStorage) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->OpenStorage, OpenStorage) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->CopyTo, CopyTo) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->MoveElementTo, MoveElementTo) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->Commit, Commit) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->Revert, Revert) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->EnumElements, EnumElements) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->DestroyElement, DestroyElement) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->RenameElement, RenameElement) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->SetElementTimes, SetElementTimes) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->SetClass, SetClass) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->SetStateBits, SetStateBits) &&
          IS_VALID_CODE_PTR(pcistg->lpVtbl->Stat, Stat));
}


/*
** IsValidPCIStream()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIStream(PCIStream pcistr)
{
   return(IS_VALID_READ_PTR(pcistr, CIStorage) &&
          IS_VALID_READ_PTR(pcistr->lpVtbl, sizeof(*(pcistr->lpVtbl))) &&
          IS_VALID_STRUCT_PTR((PCIUnknown)pcistr, CIUnknown) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Read, Read) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Write, Write) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Seek, Seek) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->SetSize, SetSize) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->CopyTo, CopyTo) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Commit, Commit) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Revert, Revert) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->LockRegion, LockRegion) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->UnlockRegion, UnlockRegion) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Stat, Stat) &&
          IS_VALID_CODE_PTR(pcistr->lpVtbl->Clone, Clone));
}


/*
** IsValidPCIUnknown()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCIUnknown(PCIUnknown pciunk)
{
   return(IS_VALID_READ_PTR(pciunk, CIUnknown) &&
          IS_VALID_READ_PTR(pciunk->lpVtbl, sizeof(*(pciunk->lpVtbl))) &&
          IS_VALID_CODE_PTR(pciunk->lpVtbl->QueryInterface, QueryInterface) &&
          IS_VALID_CODE_PTR(pciunk->lpVtbl->AddRef, AddRef) &&
          IS_VALID_CODE_PTR(pciunk->lpVtbl->Release, Release));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\pch.c ===
/*
 * pch.c - Precompiled header file source.
 */

#include "project.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\path.c ===
/*
 * path.c - Path ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "volume.h"


/* Constants
 ************/

/* PATHLIST PTRARRAY allocation parameters */

#define NUM_START_PATHS          (32)
#define NUM_PATHS_TO_ADD         (32)

/* PATHLIST string table allocation parameters */

#define NUM_PATH_HASH_BUCKETS    (67)


/* Types
 ********/

/* path list */

typedef struct _pathlist
{
   /* array of pointers to PATHs */

   HPTRARRAY hpa;

   /* list of volumes */

   HVOLUMELIST hvl;

   /* table of path suffix strings */

   HSTRINGTABLE hst;
}
PATHLIST;
DECLARE_STANDARD_TYPES(PATHLIST);

/* path structure */

typedef struct _path
{
   /* reference count */

   ULONG ulcLock;

   /* handle to parent volume */

   HVOLUME hvol;

   /* handle to path suffix string */

   HSTRING hsPathSuffix;

   /* pointer to PATH's parent PATHLIST */

   PPATHLIST pplParent;
}
PATH;
DECLARE_STANDARD_TYPES(PATH);

/* PATH search structure used by PathSearchCmp() */

typedef struct _pathsearchinfo
{
   HVOLUME hvol;

   LPCTSTR pcszPathSuffix;
}
PATHSEARCHINFO;
DECLARE_STANDARD_TYPES(PATHSEARCHINFO);

/* database path list header */

typedef struct _dbpathlistheader
{
   /* number of paths in list */

   LONG lcPaths;
}
DBPATHLISTHEADER;
DECLARE_STANDARD_TYPES(DBPATHLISTHEADER);

/* database path structure */

typedef struct _dbpath
{
   /* old handle to path */

   HPATH hpath;

   /* old handle to parent volume */

   HVOLUME hvol;

   /* old handle to path suffix string */

   HSTRING hsPathSuffix;
}
DBPATH;
DECLARE_STANDARD_TYPES(DBPATH);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE COMPARISONRESULT PathSortCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT PathSearchCmp(PCVOID, PCVOID);
PRIVATE_CODE BOOL UnifyPath(PPATHLIST, HVOLUME, LPCTSTR, PPATH *);
PRIVATE_CODE BOOL CreatePath(PPATHLIST, HVOLUME, LPCTSTR, PPATH *);
PRIVATE_CODE void DestroyPath(PPATH);
PRIVATE_CODE void UnlinkPath(PCPATH);
PRIVATE_CODE void LockPath(PPATH);
PRIVATE_CODE BOOL UnlockPath(PPATH);
PRIVATE_CODE PATHRESULT TranslateVOLUMERESULTToPATHRESULT(VOLUMERESULT);
PRIVATE_CODE TWINRESULT WritePath(HCACHEDFILE, PPATH);
PRIVATE_CODE TWINRESULT ReadPath(HCACHEDFILE, PPATHLIST, HHANDLETRANS, HHANDLETRANS, HHANDLETRANS);

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsValidPCPATHLIST(PCPATHLIST);
PRIVATE_CODE BOOL IsValidPCPATH(PCPATH);

#endif

#if defined(DEBUG)

PRIVATE_CODE BOOL IsValidPCPATHSEARCHINFO(PCPATHSEARCHINFO);

#endif


/*
** PathSortCmp()
**
** Pointer comparison function used to sort the module array of paths.
**
** Arguments:     pcpath1 - pointer to first path
**                pcpath2 - pointer to second path
**
** Returns:
**
** Side Effects:  none
**
** The internal paths are sorted by:
**    1) volume
**    2) path suffix
**    3) pointer value
*/
PRIVATE_CODE COMPARISONRESULT PathSortCmp(PCVOID pcpath1, PCVOID pcpath2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pcpath1, CPATH));
   ASSERT(IS_VALID_STRUCT_PTR(pcpath2, CPATH));

   cr = CompareVolumes(((PCPATH)pcpath1)->hvol,
                       ((PCPATH)pcpath2)->hvol);

   if (cr == CR_EQUAL)
   {
      cr = ComparePathStringsByHandle(((PCPATH)pcpath1)->hsPathSuffix,
                                      ((PCPATH)pcpath2)->hsPathSuffix);

      if (cr == CR_EQUAL)
         cr = ComparePointers(pcpath1, pcpath2);
   }

   return(cr);
}


/*
** PathSearchCmp()
**
** Pointer comparison function used to search for a path.
**
** Arguments:     pcpathsi - pointer to PATHSEARCHINFO describing path to
**                           search for
**                pcpath - pointer to path to examine
**
** Returns:
**
** Side Effects:  none
**
** The internal paths are searched by:
**    1) volume
**    2) path suffix string
*/
PRIVATE_CODE COMPARISONRESULT PathSearchCmp(PCVOID pcpathsi, PCVOID pcpath)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pcpathsi, CPATHSEARCHINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pcpath, CPATH));

   cr = CompareVolumes(((PCPATHSEARCHINFO)pcpathsi)->hvol,
                       ((PCPATH)pcpath)->hvol);

   if (cr == CR_EQUAL)
      cr = ComparePathStrings(((PCPATHSEARCHINFO)pcpathsi)->pcszPathSuffix,
                              GetString(((PCPATH)pcpath)->hsPathSuffix));

   return(cr);
}


/*
** UnifyPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL UnifyPath(PPATHLIST ppl, HVOLUME hvol, LPCTSTR pcszPathSuffix,
                            PPATH *pppath)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(ppl, CPATHLIST));
   ASSERT(IS_VALID_HANDLE(hvol, VOLUME));
   ASSERT(IsValidPathSuffix(pcszPathSuffix));
   ASSERT(IS_VALID_WRITE_PTR(pppath, PPATH));

   /* Allocate space for PATH structure. */

   if (AllocateMemory(sizeof(**pppath), pppath))
   {
      if (CopyVolume(hvol, ppl->hvl, &((*pppath)->hvol)))
      {
         if (AddString(pcszPathSuffix, ppl->hst, GetHashBucketIndex, &((*pppath)->hsPathSuffix)))
         {
            ARRAYINDEX aiUnused;

            /* Initialize remaining PATH fields. */

            (*pppath)->ulcLock = 0;
            (*pppath)->pplParent = ppl;

            /* Add new PATH to array. */

            if (AddPtr(ppl->hpa, PathSortCmp, *pppath, &aiUnused))
               bResult = TRUE;
            else
            {
               DeleteString((*pppath)->hsPathSuffix);
UNIFYPATH_BAIL1:
               DeleteVolume((*pppath)->hvol);
UNIFYPATH_BAIL2:
               FreeMemory(*pppath);
            }
         }
         else
            goto UNIFYPATH_BAIL1;
      }
      else
         goto UNIFYPATH_BAIL2;
   }

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*pppath, CPATH));

   return(bResult);
}


/*
** CreatePath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreatePath(PPATHLIST ppl, HVOLUME hvol, LPCTSTR pcszPathSuffix,
                             PPATH *pppath)
{
   BOOL bResult;
   ARRAYINDEX aiFound;
   PATHSEARCHINFO pathsi;

   ASSERT(IS_VALID_STRUCT_PTR(ppl, CPATHLIST));
   ASSERT(IS_VALID_HANDLE(hvol, VOLUME));
   ASSERT(IsValidPathSuffix(pcszPathSuffix));
   ASSERT(IS_VALID_WRITE_PTR(pppath, CPATH));

   /* Does a path for the given volume and path suffix already exist? */

   pathsi.hvol = hvol;
   pathsi.pcszPathSuffix = pcszPathSuffix;

   bResult = SearchSortedArray(ppl->hpa, &PathSearchCmp, &pathsi, &aiFound);

   if (bResult)
      /* Yes.  Return it. */
      *pppath = GetPtr(ppl->hpa, aiFound);
   else
      bResult = UnifyPath(ppl, hvol, pcszPathSuffix, pppath);

   if (bResult)
      LockPath(*pppath);

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*pppath, CPATH));

   return(bResult);
}


/*
** DestroyPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyPath(PPATH ppath)
{
   ASSERT(IS_VALID_STRUCT_PTR(ppath, CPATH));

   DeleteVolume(ppath->hvol);
   DeleteString(ppath->hsPathSuffix);
   FreeMemory(ppath);

   return;
}


/*
** UnlinkPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void UnlinkPath(PCPATH pcpath)
{
   HPTRARRAY hpa;
   ARRAYINDEX aiFound;

   ASSERT(IS_VALID_STRUCT_PTR(pcpath, CPATH));

   hpa = pcpath->pplParent->hpa;

   if (EVAL(SearchSortedArray(hpa, &PathSortCmp, pcpath, &aiFound)))
   {
      ASSERT(GetPtr(hpa, aiFound) == pcpath);

      DeletePtr(hpa, aiFound);
   }

   return;
}


/*
** LockPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void LockPath(PPATH ppath)
{
   ASSERT(IS_VALID_STRUCT_PTR(ppath, CPATH));

   ASSERT(ppath->ulcLock < ULONG_MAX);
   ppath->ulcLock++;

   return;
}


/*
** UnlockPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL UnlockPath(PPATH ppath)
{
   ASSERT(IS_VALID_STRUCT_PTR(ppath, CPATH));

   if (EVAL(ppath->ulcLock > 0))
      ppath->ulcLock--;

   return(ppath->ulcLock > 0);
}


/*
** TranslateVOLUMERESULTToPATHRESULT()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE PATHRESULT TranslateVOLUMERESULTToPATHRESULT(VOLUMERESULT vr)
{
   PATHRESULT pr;

   switch (vr)
   {
      case VR_SUCCESS:
         pr = PR_SUCCESS;
         break;

      case VR_UNAVAILABLE_VOLUME:
         pr = PR_UNAVAILABLE_VOLUME;
         break;

      case VR_OUT_OF_MEMORY:
         pr = PR_OUT_OF_MEMORY;
         break;

      default:
         ASSERT(vr == VR_INVALID_PATH);
         pr = PR_INVALID_PATH;
         break;
   }

   return(pr);
}


/*
** WritePath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT WritePath(HCACHEDFILE hcf, PPATH ppath)
{
   TWINRESULT tr;
   DBPATH dbpath;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(ppath, CPATH));

   /* Write database path. */

   dbpath.hpath = (HPATH)ppath;
   dbpath.hvol = ppath->hvol;
   dbpath.hsPathSuffix = ppath->hsPathSuffix;

   if (WriteToCachedFile(hcf, (PCVOID)&dbpath, sizeof(dbpath), NULL))
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


/*
** ReadPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT ReadPath(HCACHEDFILE hcf, PPATHLIST ppl,
                                 HHANDLETRANS hhtVolumes,
                                 HHANDLETRANS hhtStrings,
                                 HHANDLETRANS hhtPaths)
{
   TWINRESULT tr;
   DBPATH dbpath;
   DWORD dwcbRead;
   HVOLUME hvol;
   HSTRING hsPathSuffix;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(ppl, CPATHLIST));
   ASSERT(IS_VALID_HANDLE(hhtVolumes, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtStrings, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtPaths, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &dbpath, sizeof(dbpath), &dwcbRead) &&
       dwcbRead == sizeof(dbpath) &&
       TranslateHandle(hhtVolumes, (HGENERIC)(dbpath.hvol), (PHGENERIC)&hvol) &&
       TranslateHandle(hhtStrings, (HGENERIC)(dbpath.hsPathSuffix), (PHGENERIC)&hsPathSuffix))
   {
      PPATH ppath;

      if (CreatePath(ppl, hvol, GetString(hsPathSuffix), &ppath))
      {
         /*
          * To leave read paths with 0 initial lock count, we must undo
          * the LockPath() performed by CreatePath().
          */

         UnlockPath(ppath);

         if (AddHandleToHandleTranslator(hhtPaths,
                                         (HGENERIC)(dbpath.hpath),
                                         (HGENERIC)ppath))
            tr = TR_SUCCESS;
         else
         {
            UnlinkPath(ppath);
            DestroyPath(ppath);

            tr = TR_OUT_OF_MEMORY;
         }
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidPCPATHLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCPATHLIST(PCPATHLIST pcpl)
{
   return(IS_VALID_READ_PTR(pcpl, CPATHLIST) &&
          IS_VALID_HANDLE(pcpl->hpa, PTRARRAY) &&
          IS_VALID_HANDLE(pcpl->hvl, VOLUMELIST) &&
          IS_VALID_HANDLE(pcpl->hst, STRINGTABLE));
}


/*
** IsValidPCPATH()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCPATH(PCPATH pcpath)
{
   return(IS_VALID_READ_PTR(pcpath, CPATH) &&
          IS_VALID_HANDLE(pcpath->hvol, VOLUME) &&
          IS_VALID_HANDLE(pcpath->hsPathSuffix, STRING) &&
          IsValidPathSuffix(GetString(pcpath->hsPathSuffix)) &&
          IS_VALID_READ_PTR(pcpath->pplParent, CPATHLIST));
}

#endif


#if defined(DEBUG)

/*
** IsValidPCPATHSEARCHINFO()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCPATHSEARCHINFO(PCPATHSEARCHINFO pcpathsi)
{
   return(IS_VALID_READ_PTR(pcpathsi, CPATHSEARCHINFO) &&
          IS_VALID_HANDLE(pcpathsi->hvol, VOLUME) &&
          IsValidPathSuffix(pcpathsi->pcszPathSuffix));
}

#endif


/****************************** Public Functions *****************************/


/*
** CreatePathList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreatePathList(DWORD dwFlags, HWND hwndOwner, PHPATHLIST phpl)
{
   BOOL bResult = FALSE;
   PPATHLIST ppl;

   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_RLI_IFLAGS));
   ASSERT(IS_FLAG_CLEAR(dwFlags, RLI_IFL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_VALID_WRITE_PTR(phpl, HPATHLIST));

   if (AllocateMemory(sizeof(*ppl), &ppl))
   {
      NEWPTRARRAY npa;

      /* Create pointer array of paths. */

      npa.aicInitialPtrs = NUM_START_PATHS;
      npa.aicAllocGranularity = NUM_PATHS_TO_ADD;
      npa.dwFlags = NPA_FL_SORTED_ADD;

      if (CreatePtrArray(&npa, &(ppl->hpa)))
      {
         if (CreateVolumeList(dwFlags, hwndOwner, &(ppl->hvl)))
         {
            NEWSTRINGTABLE nszt;

            /* Create string table for path suffix strings. */

            nszt.hbc = NUM_PATH_HASH_BUCKETS;

            if (CreateStringTable(&nszt, &(ppl->hst)))
            {
               *phpl = (HPATHLIST)ppl;
               bResult = TRUE;
            }
            else
            {
               DestroyVolumeList(ppl->hvl);
CREATEPATHLIST_BAIL1:
               DestroyPtrArray(ppl->hpa);
CREATEPATHLIST_BAIL2:
               FreeMemory(ppl);
            }
         }
         else
            goto CREATEPATHLIST_BAIL1;
      }
      else
         goto CREATEPATHLIST_BAIL2;
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phpl, PATHLIST));

   return(bResult);
}


/*
** DestroyPathList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyPathList(HPATHLIST hpl)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));

   /* First free all paths in array. */

   aicPtrs = GetPtrCount(((PCPATHLIST)hpl)->hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      DestroyPath(GetPtr(((PCPATHLIST)hpl)->hpa, ai));

   /* Now wipe out the array. */

   DestroyPtrArray(((PCPATHLIST)hpl)->hpa);

   ASSERT(! GetVolumeCount(((PCPATHLIST)hpl)->hvl));
   DestroyVolumeList(((PCPATHLIST)hpl)->hvl);

   ASSERT(! GetStringCount(((PCPATHLIST)hpl)->hst));
   DestroyStringTable(((PCPATHLIST)hpl)->hst);

   FreeMemory((PPATHLIST)hpl);

   return;
}


/*
** InvalidatePathListInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void InvalidatePathListInfo(HPATHLIST hpl)
{
   InvalidateVolumeListInfo(((PCPATHLIST)hpl)->hvl);

   return;
}


/*
** ClearPathListInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ClearPathListInfo(HPATHLIST hpl)
{
   ClearVolumeListInfo(((PCPATHLIST)hpl)->hvl);

   return;
}


/*
** AddPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/

PUBLIC_CODE PATHRESULT AddPath(HPATHLIST hpl, LPCTSTR pcszPath, PHPATH phpath)
{
   PATHRESULT pr;
   HVOLUME hvol;
   TCHAR rgchPathSuffix[MAX_PATH_LEN];
   LPCTSTR     pszPath;

#ifdef UNICODE
   WCHAR szUnicode[MAX_PATH];
#endif

   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(phpath, HPATH));

   // On NT, we want to convert a unicode string to an ANSI shortened path for
   // the sake of interop

   #if defined(UNICODE) 
   {
        CHAR szAnsi[MAX_PATH];
        szUnicode[0] = L'\0';
 
        WideCharToMultiByte(CP_ACP, 0, pcszPath, -1, szAnsi, ARRAYSIZE(szAnsi), NULL, NULL);
        MultiByteToWideChar(CP_ACP, 0, szAnsi,   -1, szUnicode, ARRAYSIZE(szUnicode));
        if (lstrcmp(szUnicode, pcszPath))
        {
            // Cannot convert losslessly from Unicode -> Ansi, so get the short path

            lstrcpy(szUnicode, pcszPath);
            SheShortenPath(szUnicode, TRUE);
            pszPath = szUnicode;
        }
        else
        {
            // It will convert OK, so just use the original

            pszPath = pcszPath;
        }
   }
   #else
        pszPath = pcszPath;
   #endif

   pr = TranslateVOLUMERESULTToPATHRESULT(
            AddVolume(((PCPATHLIST)hpl)->hvl, pszPath, &hvol, rgchPathSuffix));

   if (pr == PR_SUCCESS)
   {
      PPATH ppath;

      if (CreatePath((PPATHLIST)hpl, hvol, rgchPathSuffix, &ppath))
         *phpath = (HPATH)ppath;
      else
         pr = PR_OUT_OF_MEMORY;

      DeleteVolume(hvol);
   }

   ASSERT(pr != PR_SUCCESS ||
          IS_VALID_HANDLE(*phpath, PATH));

   return(pr);
}


/*
** AddChildPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL AddChildPath(HPATHLIST hpl, HPATH hpathParent,
                              LPCTSTR pcszSubPath, PHPATH phpathChild)
{
   BOOL bResult;
   TCHAR rgchChildPathSuffix[MAX_PATH_LEN];
   LPCTSTR pcszPathSuffix;
   LPTSTR pszPathSuffixEnd;
   PPATH ppathChild;

   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
   ASSERT(IS_VALID_HANDLE(hpathParent, PATH));
   ASSERT(IS_VALID_STRING_PTR(pcszSubPath, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(phpathChild, HPATH));

   ComposePath(rgchChildPathSuffix, 
               GetString(((PCPATH)hpathParent)->hsPathSuffix), 
               pcszSubPath);

   pcszPathSuffix = rgchChildPathSuffix;

   if (IS_SLASH(*pcszPathSuffix))
      pcszPathSuffix++;

   pszPathSuffixEnd = CharPrev(pcszPathSuffix,
                               pcszPathSuffix + lstrlen(pcszPathSuffix));

   if (IS_SLASH(*pszPathSuffixEnd))
      *pszPathSuffixEnd = TEXT('\0');

   ASSERT(IsValidPathSuffix(pcszPathSuffix));

   bResult = CreatePath((PPATHLIST)hpl, ((PCPATH)hpathParent)->hvol,
                        pcszPathSuffix, &ppathChild);

   if (bResult)
      *phpathChild = (HPATH)ppathChild;

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phpathChild, PATH));

   return(bResult);
}


/*
** DeletePath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DeletePath(HPATH hpath)
{
   ASSERT(IS_VALID_HANDLE(hpath, PATH));

   if (! UnlockPath((PPATH)hpath))
   {
      UnlinkPath((PPATH)hpath);
      DestroyPath((PPATH)hpath);
   }

   return;
}


/*
** CopyPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CopyPath(HPATH hpathSrc, HPATHLIST hplDest, PHPATH phpathCopy)
{
   BOOL bResult;
   PPATH ppath;

   ASSERT(IS_VALID_HANDLE(hpathSrc, PATH));
   ASSERT(IS_VALID_HANDLE(hplDest, PATHLIST));
   ASSERT(IS_VALID_WRITE_PTR(phpathCopy, HPATH));

   /* Is the destination path list the source path's path list? */

   if (((PCPATH)hpathSrc)->pplParent == (PCPATHLIST)hplDest)
   {
      /* Yes.  Use the source path. */

      LockPath((PPATH)hpathSrc);
      ppath = (PPATH)hpathSrc;
      bResult = TRUE;
   }
   else
      bResult = CreatePath((PPATHLIST)hplDest, ((PCPATH)hpathSrc)->hvol,
                           GetString(((PCPATH)hpathSrc)->hsPathSuffix),
                           &ppath);

   if (bResult)
      *phpathCopy = (HPATH)ppath;

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phpathCopy, PATH));

   return(bResult);
}


/*
** GetPathString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void GetPathString(HPATH hpath, LPTSTR pszPathBuf)
{
   ASSERT(IS_VALID_HANDLE(hpath, PATH));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPathBuf, STR, MAX_PATH_LEN));

   GetPathRootString(hpath, pszPathBuf);
   CatPath(pszPathBuf, GetString(((PPATH)hpath)->hsPathSuffix));

   ASSERT(IsCanonicalPath(pszPathBuf));

   return;
}


/*
** GetPathRootString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void GetPathRootString(HPATH hpath, LPTSTR pszPathRootBuf)
{
   ASSERT(IS_VALID_HANDLE(hpath, PATH));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPathRootBuf, STR, MAX_PATH_LEN));

   GetVolumeRootPath(((PPATH)hpath)->hvol, pszPathRootBuf);

   ASSERT(IsCanonicalPath(pszPathRootBuf));

   return;
}


/*
** GetPathSuffixString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void GetPathSuffixString(HPATH hpath, LPTSTR pszPathSuffixBuf)
{
   ASSERT(IS_VALID_HANDLE(hpath, PATH));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPathSuffixBuf, STR, MAX_PATH_LEN));

   ASSERT(lstrlen(GetString(((PPATH)hpath)->hsPathSuffix)) < MAX_PATH_LEN);
   MyLStrCpyN(pszPathSuffixBuf, GetString(((PPATH)hpath)->hsPathSuffix), MAX_PATH_LEN);

   ASSERT(IsValidPathSuffix(pszPathSuffixBuf));

   return;
}


/*
** AllocatePathString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL AllocatePathString(HPATH hpath, LPTSTR *ppszPath)
{
   TCHAR rgchPath[MAX_PATH_LEN];

   ASSERT(IS_VALID_HANDLE(hpath, PATH));
   ASSERT(IS_VALID_WRITE_PTR(ppszPath, LPTSTR));

   GetPathString(hpath, rgchPath);

   return(StringCopy(rgchPath, ppszPath));
}


#ifdef DEBUG

/*
** DebugGetPathString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** N.b., DebugGetPathString() must be non-intrusive.
*/
PUBLIC_CODE LPCTSTR DebugGetPathString(HPATH hpath)
{
#pragma data_seg(DATA_SEG_SHARED)
   /* Allow 4 debug paths. */
   static TCHAR SrgrgchPaths[][MAX_PATH_LEN] = { TEXT(""), TEXT(""), TEXT(""), TEXT("") };
   static UINT SuiPath = 0;
#pragma data_seg()
   LPTSTR pszPath;

   ASSERT(IS_VALID_HANDLE(hpath, PATH));

   pszPath = SrgrgchPaths[SuiPath];

   DebugGetVolumeRootPath(((PPATH)hpath)->hvol, pszPath);
   CatPath(pszPath, GetString(((PPATH)hpath)->hsPathSuffix));

   SuiPath++;
   SuiPath %= ARRAY_ELEMENTS(SrgrgchPaths);

   return(pszPath);
}


/*
** GetPathCount()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE ULONG GetPathCount(HPATHLIST hpl)
{
   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));

   return(GetPtrCount(((PCPATHLIST)hpl)->hpa));
}

#endif


/*
** IsPathVolumeAvailable()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsPathVolumeAvailable(HPATH hpath)
{
   ASSERT(IS_VALID_HANDLE(hpath, PATH));

   return(IsVolumeAvailable(((PCPATH)hpath)->hvol));
}


/*
** GetPathVolumeID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HVOLUMEID GetPathVolumeID(HPATH hpath)
{
   ASSERT(IS_VALID_HANDLE(hpath, PATH));

   return((HVOLUMEID)hpath);
}


/*
** MyIsPathOnVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** MyIsPathOnVolume() will fail for a new root path alias for a volume.  E.g.,
** if the same net resource is connected to both X: and Y:, MyIsPathOnVolume()
** will only return TRUE for the drive root path that the net resource was
** connected to through the given HVOLUME.
*/
PUBLIC_CODE BOOL MyIsPathOnVolume(LPCTSTR pcszPath, HPATH hpath)
{
   BOOL bResult;
   TCHAR rgchVolumeRootPath[MAX_PATH_LEN];

   ASSERT(IsFullPath(pcszPath));
   ASSERT(IS_VALID_HANDLE(hpath, PATH));

   if (IsVolumeAvailable(((PPATH)hpath)->hvol))
   {
      GetVolumeRootPath(((PPATH)hpath)->hvol, rgchVolumeRootPath);

      bResult = (MyLStrCmpNI(pcszPath, rgchVolumeRootPath,
                             lstrlen(rgchVolumeRootPath))
                 == CR_EQUAL);
   }
   else
   {
      TRACE_OUT((TEXT("MyIsPathOnVolume(): Failing on unavailable volume %s."),
                 DebugGetVolumeRootPath(((PPATH)hpath)->hvol, rgchVolumeRootPath)));

      bResult = FALSE;
   }

   return(bResult);
}


/*
** ComparePaths()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** PATHs are compared by:
**    1) volume
**    2) path suffix
*/
PUBLIC_CODE COMPARISONRESULT ComparePaths(HPATH hpath1, HPATH hpath2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_HANDLE(hpath1, PATH));
   ASSERT(IS_VALID_HANDLE(hpath2, PATH));

   /* This comparison works across path lists. */

   cr = ComparePathVolumes(hpath1, hpath2);

   if (cr == CR_EQUAL)
      cr = ComparePathStringsByHandle(((PCPATH)hpath1)->hsPathSuffix,
                                      ((PCPATH)hpath2)->hsPathSuffix);

   return(cr);
}


/*
** ComparePathVolumes()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT ComparePathVolumes(HPATH hpath1, HPATH hpath2)
{
   ASSERT(IS_VALID_HANDLE(hpath1, PATH));
   ASSERT(IS_VALID_HANDLE(hpath2, PATH));

   return(CompareVolumes(((PCPATH)hpath1)->hvol, ((PCPATH)hpath2)->hvol));
}


/*
** IsPathPrefix()
**
** Determines whether or not one path is a prefix of another.
**
** Arguments:     hpathChild - whole path (longer or same length)
**                hpathParent - prefix path to test (shorter or same length)
**
** Returns:       TRUE if the second path is a prefix of the first path.  FALSE
**                if not.
**
** Side Effects:  none
**
** Read 'IsPathPrefix(A, B)' as 'Is A in B's subtree?'.
*/
PUBLIC_CODE BOOL IsPathPrefix(HPATH hpathChild, HPATH hpathParent)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hpathParent, PATH));
   ASSERT(IS_VALID_HANDLE(hpathChild, PATH));

   if (ComparePathVolumes(hpathParent, hpathChild) == CR_EQUAL)
   {
      TCHAR rgchParentSuffix[MAX_PATH_LEN];
      TCHAR rgchChildSuffix[MAX_PATH_LEN];
      int nParentSuffixLen;
      int nChildSuffixLen;

      /* Ignore path roots when comparing path strings. */

      GetPathSuffixString(hpathParent, rgchParentSuffix);
      GetPathSuffixString(hpathChild, rgchChildSuffix);

      /* Only root paths should have no path suffix off the root. */

      nParentSuffixLen = lstrlen(rgchParentSuffix);
      nChildSuffixLen = lstrlen(rgchChildSuffix);

      /*
       * The parent path is a path prefix of the child path iff:
       *    1) The parent's path suffix string is shorter than or the same
       *       length as the child's path suffix string.
       *    2) The two path suffix strings match through the length of the
       *       parent's path suffix string.
       *    3) The prefix of the child's path suffix string is followed
       *       immediately by a null terminator or a path separator.
       */

      bResult = (nChildSuffixLen >= nParentSuffixLen &&
                 MyLStrCmpNI(rgchParentSuffix, rgchChildSuffix,
                             nParentSuffixLen) == CR_EQUAL &&
                 (nChildSuffixLen == nParentSuffixLen ||          /* same paths */
                  ! nParentSuffixLen ||                           /* root parent */
                  IS_SLASH(rgchChildSuffix[nParentSuffixLen])));  /* non-root parent */
   }
   else
      bResult = FALSE;

   return(bResult);
}


/*
** SubtreesIntersect()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** N.b., two subtrees cannot both intersect a third subtree unless they
** intersect each other.
*/
PUBLIC_CODE BOOL SubtreesIntersect(HPATH hpath1, HPATH hpath2)
{
   ASSERT(IS_VALID_HANDLE(hpath1, PATH));
   ASSERT(IS_VALID_HANDLE(hpath2, PATH));

   return(IsPathPrefix(hpath1, hpath2) ||
          IsPathPrefix(hpath2, hpath1));
}


/*
** FindEndOfRootSpec()
**
** Finds the end of the root specification in a path string.
**
** Arguments:     pcszPath - path to examine for root specification
**                hpath - handle to PATH that path string was generated from
**
** Returns:       pointer to first character after end of root specification
**
** Side Effects:  none
**
** Examples:
**
**    input path                    output string
**    ----------                    -------------
**    c:\                           <empty string>
**    c:\foo                        foo
**    c:\foo\bar                    foo\bar
**    \\pyrex\user\                 <empty string>
**    \\pyrex\user\foo              foo
**    \\pyrex\user\foo\bar          foo\bar
*/
PUBLIC_CODE LPTSTR FindEndOfRootSpec(LPCTSTR pcszFullPath, HPATH hpath)
{
   LPCTSTR pcsz;
   UINT ucchPathLen;
   UINT ucchSuffixLen;

   ASSERT(IsCanonicalPath(pcszFullPath));
   ASSERT(IS_VALID_HANDLE(hpath, PATH));

   ucchPathLen = lstrlen(pcszFullPath);
   ucchSuffixLen = lstrlen(GetString(((PCPATH)hpath)->hsPathSuffix));

   pcsz = pcszFullPath + ucchPathLen;

   if (ucchPathLen > ucchSuffixLen)
      pcsz -= ucchSuffixLen;
   else
      /* Assume path is root path. */
      ERROR_OUT((TEXT("FindEndOfRootSpec(): Path suffix %s is longer than full path %s."),
                 GetString(((PCPATH)hpath)->hsPathSuffix),
                 pcszFullPath));

   ASSERT(IsValidPathSuffix(pcsz));

   return((LPTSTR)pcsz);
}


/*
** FindPathSuffix()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LPTSTR FindChildPathSuffix(HPATH hpathParent, HPATH hpathChild,
                                     LPTSTR pszChildSuffixBuf)
{
   LPCTSTR pcszChildSuffix;
   TCHAR rgchParentSuffix[MAX_PATH_LEN];

   ASSERT(IS_VALID_HANDLE(hpathParent, PATH));
   ASSERT(IS_VALID_HANDLE(hpathChild, PATH));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszChildSuffixBuf, STR, MAX_PATH_LEN));

   ASSERT(IsPathPrefix(hpathChild, hpathParent));

   GetPathSuffixString(hpathParent, rgchParentSuffix);
   GetPathSuffixString(hpathChild, pszChildSuffixBuf);

   ASSERT(lstrlen(rgchParentSuffix) <= lstrlen(pszChildSuffixBuf));
   pcszChildSuffix = pszChildSuffixBuf + lstrlen(rgchParentSuffix);

   if (IS_SLASH(*pcszChildSuffix))
      pcszChildSuffix++;

   ASSERT(IsValidPathSuffix(pcszChildSuffix));

   return((LPTSTR)pcszChildSuffix);
}


/*
** ComparePointers()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT ComparePointers(PCVOID pcv1, PCVOID pcv2)
{
   COMPARISONRESULT cr;

   /* pcv1 and pcv2 may be any value. */

   if (pcv1 < pcv2)
      cr = CR_FIRST_SMALLER;
   else if (pcv1 > pcv2)
      cr = CR_FIRST_LARGER;
   else
      cr = CR_EQUAL;

   return(cr);
}


/*
** TWINRESULTFromLastError()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT TWINRESULTFromLastError(TWINRESULT tr)
{
   switch (GetLastError())
   {
      case ERROR_OUTOFMEMORY:
         tr = TR_OUT_OF_MEMORY;
         break;

      default:
         break;
   }

   return(tr);
}


/*
** WritePathList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT WritePathList(HCACHEDFILE hcf, HPATHLIST hpl)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));

   tr = WriteVolumeList(hcf, ((PCPATHLIST)hpl)->hvl);

   if (tr == TR_SUCCESS)
   {
      tr = WriteStringTable(hcf, ((PCPATHLIST)hpl)->hst);

      if (tr == TR_SUCCESS)
      {
         DWORD dwcbDBPathListHeaderOffset;

         tr = TR_BRIEFCASE_WRITE_FAILED;

         /* Save initial file position. */

         dwcbDBPathListHeaderOffset = GetCachedFilePointerPosition(hcf);

         if (dwcbDBPathListHeaderOffset != INVALID_SEEK_POSITION)
         {
            DBPATHLISTHEADER dbplh;

            /* Leave space for path list header. */

            ZeroMemory(&dbplh, sizeof(dbplh));

            if (WriteToCachedFile(hcf, (PCVOID)&dbplh, sizeof(dbplh), NULL))
            {
               ARRAYINDEX aicPtrs;
               ARRAYINDEX ai;
               LONG lcPaths = 0;

               tr = TR_SUCCESS;

               aicPtrs = GetPtrCount(((PCPATHLIST)hpl)->hpa);

               /* Write all paths. */

               for (ai = 0; ai < aicPtrs; ai++)
               {
                  PPATH ppath;

                  ppath = GetPtr(((PCPATHLIST)hpl)->hpa, ai);

                  /*
                   * As a sanity check, don't save any path with a lock count
                   * of 0.  A 0 lock count implies that the path has not been
                   * referenced since it was restored from the database, or
                   * something is broken.
                   */

                  if (ppath->ulcLock > 0)
                  {
                     tr = WritePath(hcf, ppath);

                     if (tr == TR_SUCCESS)
                     {
                        ASSERT(lcPaths < LONG_MAX);
                        lcPaths++;
                     }
                     else
                        break;
                  }
                  else
                     ERROR_OUT((TEXT("WritePathList(): PATH for path %s has 0 lock count and will not be written."),
                                DebugGetPathString((HPATH)ppath)));
               }

               /* Save path list header. */

               if (tr == TR_SUCCESS)
               {
                  dbplh.lcPaths = lcPaths;

                  tr = WriteDBSegmentHeader(hcf, dwcbDBPathListHeaderOffset, &dbplh,
                                            sizeof(dbplh));

                  TRACE_OUT((TEXT("WritePathList(): Wrote %ld paths."),
                             dbplh.lcPaths));
               }
            }
         }
      }
   }

   return(tr);
}


/*
** ReadPathList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT ReadPathList(HCACHEDFILE hcf, HPATHLIST hpl,
                                    PHHANDLETRANS phht)
{
   TWINRESULT tr;
   HHANDLETRANS hhtVolumes;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
   ASSERT(IS_VALID_WRITE_PTR(phht, HHANDLETRANS));

   tr = ReadVolumeList(hcf, ((PCPATHLIST)hpl)->hvl, &hhtVolumes);

   if (tr == TR_SUCCESS)
   {
      HHANDLETRANS hhtStrings;

      tr = ReadStringTable(hcf, ((PCPATHLIST)hpl)->hst, &hhtStrings);

      if (tr == TR_SUCCESS)
      {
         DBPATHLISTHEADER dbplh;
         DWORD dwcbRead;

         tr = TR_CORRUPT_BRIEFCASE;

         if (ReadFromCachedFile(hcf, &dbplh, sizeof(dbplh), &dwcbRead) &&
             dwcbRead == sizeof(dbplh))
         {
            HHANDLETRANS hht;

            if (CreateHandleTranslator(dbplh.lcPaths, &hht))
            {
               LONG l;

               tr = TR_SUCCESS;

               TRACE_OUT((TEXT("ReadPathList(): Reading %ld paths."),
                          dbplh.lcPaths));

               for (l = 0; l < dbplh.lcPaths; l++)
               {
                  tr = ReadPath(hcf, (PPATHLIST)hpl, hhtVolumes, hhtStrings,
                                hht);

                  if (tr != TR_SUCCESS)
                     break;
               }

               if (tr == TR_SUCCESS)
               {
                  PrepareForHandleTranslation(hht);
                  *phht = hht;

                  ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
                  ASSERT(IS_VALID_HANDLE(*phht, HANDLETRANS));
               }
               else
                  DestroyHandleTranslator(hht);
            }
            else
               tr = TR_OUT_OF_MEMORY;
         }

         DestroyHandleTranslator(hhtStrings);
      }

      DestroyHandleTranslator(hhtVolumes);
   }

   return(tr);
}


/*
** IsValidHPATH()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHPATH(HPATH hp)
{
   return(IS_VALID_STRUCT_PTR((PCPATH)hp, CPATH));
}


/*
** IsValidHVOLUMEID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHVOLUMEID(HVOLUMEID hvid)
{
   return(IS_VALID_HANDLE((HPATH)hvid, PATH));
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidHPATHLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHPATHLIST(HPATHLIST hpl)
{
   return(IS_VALID_STRUCT_PTR((PCPATHLIST)hpl, CPATHLIST));
}

#endif


/***************************** Exported Functions ****************************/


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | IsPathOnVolume | Determines whether or not a given path is on
a given volume.

@parm PCSTR | pcszPath | A pointer to a string indicating the path to be
checked.

@parm HVOLUMEID | hvid | A handle to a volume ID.

@parm PBOOL | pbOnVolume | A pointer to a BOOL to be filled in with TRUE if the
given path is on the given volume, or FALSE if not.  *pbOnVolume is only valid
if TR_SUCCESS is returned.

@rdesc If the volume check was successful, TR_SUCCESS is returned.  Otherwise,
the volume check was not successful, and the return value indicates the error
that occurred.

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI IsPathOnVolume(LPCTSTR pcszPath, HVOLUMEID hvid,
                                            PBOOL pbOnVolume)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(IsPathOnVolume);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_STRING_PTR(pcszPath, CSTR) &&
          IS_VALID_HANDLE(hvid, VOLUMEID) &&
          IS_VALID_WRITE_PTR(pbOnVolume, BOOL))
#endif
      {
         TCHAR rgchFullPath[MAX_PATH_LEN];
         LPTSTR pszFileName;
         DWORD dwPathLen;

         dwPathLen = GetFullPathName(pcszPath, ARRAYSIZE(rgchFullPath),
                                     rgchFullPath, &pszFileName);

         if (dwPathLen > 0 && dwPathLen < ARRAYSIZE(rgchFullPath))
         {
            *pbOnVolume = MyIsPathOnVolume(rgchFullPath, (HPATH)hvid);

            tr = TR_SUCCESS;
         }
         else
         {
            ASSERT(! dwPathLen);

            tr = TR_INVALID_PARAMETER;
         }
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(IsPathOnVolume, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | GetVolumeDescription | Retrieves some descriptive information
for a volume, if that information is available.

@parm HVOLUMEID | hvid | A handle to a volume ID.

@parm PVOLUMEDESC | pvoldesc | A pointer to a VOLUMEDESC to be filled in with
information describing the volume.  The ulSize field of the VOLUMEDESC
structure should be filled in with sizeof(VOLUMEDESC) before calling
GetVolumeDescription().

@rdesc If the volume was described successfully, TR_SUCCESS is returned.
Otherwise, the volume was not described successfully, and the return value
indicates the error that occurred.

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI GetVolumeDescription(HVOLUMEID hvid,
                                                  PVOLUMEDESC pvoldesc)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(GetVolumeDescription);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hvid, VOLUMEID) &&
          IS_VALID_WRITE_PTR(pvoldesc, VOLUMEDESC) &&
          EVAL(pvoldesc->ulSize == sizeof(*pvoldesc)))
#endif
      {
         DescribeVolume(((PCPATH)hvid)->hvol, pvoldesc);

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(GetVolumeDescription, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\path.h ===
/*
 * path.h - Path ADT module description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HPATHLIST);
DECLARE_STANDARD_TYPES(HPATHLIST);

DECLARE_HANDLE(HPATH);
DECLARE_STANDARD_TYPES(HPATH);

/* path results returned by AddPath() */

typedef enum _pathresult
{
   PR_SUCCESS,

   PR_UNAVAILABLE_VOLUME,

   PR_OUT_OF_MEMORY,

   PR_INVALID_PATH
}
PATHRESULT;
DECLARE_STANDARD_TYPES(PATHRESULT);


/* Prototypes
 *************/

/* path.c */

extern BOOL CreatePathList(DWORD, HWND, PHPATHLIST);
extern void DestroyPathList(HPATHLIST);
extern void InvalidatePathListInfo(HPATHLIST);
extern void ClearPathListInfo(HPATHLIST);
extern PATHRESULT AddPath(HPATHLIST, LPCTSTR, PHPATH);
extern BOOL AddChildPath(HPATHLIST, HPATH, LPCTSTR, PHPATH);
extern void DeletePath(HPATH);
extern BOOL CopyPath(HPATH, HPATHLIST, PHPATH);
extern void GetPathString(HPATH, LPTSTR);
extern void GetPathRootString(HPATH, LPTSTR);
extern void GetPathSuffixString(HPATH, LPTSTR);
extern BOOL AllocatePathString(HPATH, LPTSTR *);

#ifdef DEBUG

extern LPCTSTR DebugGetPathString(HPATH);
extern ULONG GetPathCount(HPATHLIST);

#endif

extern BOOL IsPathVolumeAvailable(HPATH);
extern HVOLUMEID GetPathVolumeID(HPATH);
extern BOOL MyIsPathOnVolume(LPCTSTR, HPATH);
extern COMPARISONRESULT ComparePaths(HPATH, HPATH);
extern COMPARISONRESULT ComparePathVolumes(HPATH, HPATH);
extern BOOL IsPathPrefix(HPATH, HPATH);
extern BOOL SubtreesIntersect(HPATH, HPATH);
extern LPTSTR FindEndOfRootSpec(LPCTSTR, HPATH);
extern COMPARISONRESULT ComparePointers(PCVOID, PCVOID);
extern LPTSTR FindChildPathSuffix(HPATH, HPATH, LPTSTR);
extern TWINRESULT TWINRESULTFromLastError(TWINRESULT);
extern BOOL IsValidHPATH(HPATH);
extern BOOL IsValidHVOLUMEID(HVOLUMEID);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidHPATHLIST(HPATHLIST);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\ptrarray.h ===
/*
 * ptrarray.h - Pointer array ADT description.
 */


/* Constants
 ************/

/*
 * ARRAYINDEX_MAX is set such that (ARRAYINDEX_MAX + 1) does not overflow an
 * ARRAYINDEX.  This guarantee allows GetPtrCount() to return a count of
 * pointers as an ARRAYINDEX.
 */

#define ARRAYINDEX_MAX           (LONG_MAX - 1)


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HPTRARRAY);
DECLARE_STANDARD_TYPES(HPTRARRAY);

/* array index */

typedef LONG ARRAYINDEX;
DECLARE_STANDARD_TYPES(ARRAYINDEX);

/*
 * pointer comparison callback function
 *
 * In sorting functions, both pointers are pointer array elements.  In
 * searching functions, the first pointer is reference data and the second
 * pointer is a pointer array element.
 */

typedef COMPARISONRESULT (*COMPARESORTEDPTRSPROC)(PCVOID, PCVOID);

/*
 * pointer comparison callback function
 *
 * In searching functions, the first pointer is reference data and the second
 * pointer is a pointer array element.
 */

typedef BOOL (*COMPAREUNSORTEDPTRSPROC)(PCVOID, PCVOID);

/* new pointer array flags */

typedef enum _newptrarrayflags
{
   /* Insert elements in sorted order. */

   NPA_FL_SORTED_ADD       = 0x0001,

   /* flag combinations */

   ALL_NPA_FLAGS           = NPA_FL_SORTED_ADD
}
NEWPTRARRAYFLAGS;

/* new pointer array description */

typedef struct _newptrarray
{
   DWORD dwFlags;

   ARRAYINDEX aicInitialPtrs;

   ARRAYINDEX aicAllocGranularity;
}
NEWPTRARRAY;
DECLARE_STANDARD_TYPES(NEWPTRARRAY);


/* Prototypes
 *************/

/* ptrarray.c */

extern BOOL CreatePtrArray(PCNEWPTRARRAY, PHPTRARRAY);
extern void DestroyPtrArray(HPTRARRAY);
extern BOOL InsertPtr(HPTRARRAY, COMPARESORTEDPTRSPROC, ARRAYINDEX, PCVOID);
extern BOOL AddPtr(HPTRARRAY, COMPARESORTEDPTRSPROC, PCVOID, PARRAYINDEX);
extern void DeletePtr(HPTRARRAY, ARRAYINDEX);
extern void DeleteAllPtrs(HPTRARRAY);
extern ARRAYINDEX GetPtrCount(HPTRARRAY);
extern PVOID GetPtr(HPTRARRAY, ARRAYINDEX);
extern void SortPtrArray(HPTRARRAY, COMPARESORTEDPTRSPROC);
extern BOOL SearchSortedArray(HPTRARRAY, COMPARESORTEDPTRSPROC, PCVOID, PARRAYINDEX);
extern BOOL LinearSearchArray(HPTRARRAY, COMPAREUNSORTEDPTRSPROC, PCVOID, PARRAYINDEX);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidHPTRARRAY(HPTRARRAY);

#endif

#ifdef VSTF

extern BOOL IsValidHGLOBAL(HGLOBAL);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\project.h ===
/*
 * project.h - Project header file for object synchronization engine.
 */


/* System Headers
 *****************/

#define BUILDDLL              /* for windows.h */
#define STRICT                /* for windows.h (robustedness) */
#define _OLE32_               /* for objbase.h - HACKHACK: Remove DECLSPEC_IMPORT from WINOLEAPI. */
#define INC_OLE2              /* for windows.h */
#define CONST_VTABLE          /* for objbase.h */

/*
 * RAIDRAID: (16282) Get rid of warnings about unused Int64 inline
 * functions in winnt.h for all modules.  Emasculate other warnings only for
 * windows.h.
 */

#pragma warning(disable:4514) /* "unreferenced inline function" warning */

#pragma warning(disable:4001) /* "single line comment" warning */
#pragma warning(disable:4115) /* "named type definition in parentheses" warning */
#pragma warning(disable:4201) /* "nameless struct/union" warning */
#pragma warning(disable:4209) /* "benign typedef redefinition" warning */
#pragma warning(disable:4214) /* "bit field types other than int" warning */
#pragma warning(disable:4218) /* "must specify at least a storage class or type" warning */

#include <windows.h>
#pragma warning(disable:4001) /* "single line comment" warning - windows.h enabled it */
#include <shlobj.h>           /* for ShellChangeNotify(), etc. */
#include <shlapip.h>
#include <shlwapi.h>

#pragma warning(default:4218) /* "must specify at least a storage class or type" warning */
#pragma warning(default:4214) /* "bit field types other than int" warning */
#pragma warning(default:4209) /* "benign typedef redefinition" warning */
#pragma warning(default:4201) /* "nameless struct/union" warning */
#pragma warning(default:4115) /* "named type definition in parentheses" warning */
#pragma warning(default:4001) /* "single line comment" warning */

#include <limits.h>
#include <string.h>

#include <linkinfo.h>
#include <reconcil.h>

#define _SYNCENG_             /* for synceng.h */
#include <synceng.h>


/* Project Headers
 ******************/

/* The order of the following include files is significant. */

#include "stock.h"
#include "olestock.h"

#ifdef DEBUG

#include "inifile.h"
#include "resstr.h"

#endif

#include "debug.h"
#include "valid.h"
#include "olevalid.h"
#include "memmgr.h"
#include "ptrarray.h"
#include "list.h"
#include "hndtrans.h"
#include "string2.h"
#include "comc.h"
#include "util.h"
#include "path.h"
#include "fcache.h"
#include "brfcase.h"
#include "storage.h"
#include "clsiface.h"
#include "twin.h"
#include "foldtwin.h"
#include "expandft.h"
#include "twinlist.h"
#include "reclist.h"
#include "copy.h"
#include "merge.h"
#include "recon.h"
#include "db.h"
#include "serial.h"

/* RAIDRAID: (16283) Remove the OLE pig module hack if possible. */

#include "olepig.h"


/* Constants
 ************/

/*
 * constants to be used with #pragma data_seg()
 *
 * These section names must be given the associated attributes in the project's
 * module definition file.
 */

#define DATA_SEG_READ_ONLY       ".text"
#define DATA_SEG_PER_INSTANCE    ".instanc"
#define DATA_SEG_SHARED          ".data"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\ptrarray.c ===
/*
 * ptrarray.c - Pointer array ADT module.
 */

/*

   Pointer array structures are allocated by AllocateMemory().  Handles to
pointer arrays are pointers to ARRAYs.  Each ARRAY contains a pointer to an
rray of pointers in the pointer array.  Each array of pointers is allocated by
GlobalAlloc() to allow it to grow to greater than 64 Kb in size.  Pointer
arrays are 0-based.  Array elements are accessed using pointers.  If this
proves to be too slow, we'll go to pointers with a 64 Kb limit on total array
size.

   Pointer arrays are created with pointer comparison functions for sorting and
searching.  The sorting comparison function is used to insert new pointers into
the pointer array in sorted order.  The searching comparison function is used
to search the sorted pointer array for a pointer.  The sorting comparison
function is passed the pointer to be added to the pointer array and a pointer
from the pointer array for comparison.  The searching comparison function is
passed a pointer to the information being searched for and a pointer from the
pointer array for comparison.

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Macros
 *********/

/* extract array element */

#define ARRAY_ELEMENT(ppa, ai)            (((ppa)->ppcvArray)[(ai)])

/* Add pointers to array in sorted order? */

#define ADD_PTRS_IN_SORTED_ORDER(ppa)     IS_FLAG_SET((ppa)->dwFlags, PA_FL_SORTED_ADD)


/* Types
 ********/

/* pointer array flags */

typedef enum _ptrarrayflags
{
   /* Insert elements in sorted order. */

   PA_FL_SORTED_ADD        = 0x0001,

   /* flag combinations */

   ALL_PA_FLAGS            = PA_FL_SORTED_ADD
}
PTRARRAYFLAGS;

/* pointer array structure */

/*
 * Free elements in the ppcvArray[] array lie between indexes (aicPtrsUsed)
 * and (aiLast), inclusive.
 */

typedef struct _ptrarray
{
   /* elements to grow array by after it fills up */

   ARRAYINDEX aicPtrsToGrowBy;

   /* array flags */

   DWORD dwFlags;

   /* pointer to base of array */

   PCVOID *ppcvArray;

   /* index of last element allocated in array */

   ARRAYINDEX aicPtrsAllocated;

   /*
    * (We keep a count of the number of elements used instead of the index of
    * the last element used so that this value is 0 for an empty array, and not
    * some non-zero sentinel value.)
    */

   /* number of elements used in array */

   ARRAYINDEX aicPtrsUsed;
}
PTRARRAY;
DECLARE_STANDARD_TYPES(PTRARRAY);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL AddAFreePtrToEnd(PPTRARRAY);
PRIVATE_CODE void PtrHeapSwap(PPTRARRAY, ARRAYINDEX, ARRAYINDEX);
PRIVATE_CODE void PtrHeapSift(PPTRARRAY, ARRAYINDEX, ARRAYINDEX, COMPARESORTEDPTRSPROC);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCNEWPTRARRAY(PCNEWPTRARRAY);
PRIVATE_CODE BOOL IsValidPCPTRARRAY(PCPTRARRAY);

#endif

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsPtrArrayInSortedOrder(PCPTRARRAY, COMPARESORTEDPTRSPROC);

#endif


/*
** AddAFreePtrToEnd()
**
** Adds a free element to the end of an array.
**
** Arguments:     pa - pointer to array
**
** Returns:       TRUE if successful, or FALSE if not.
**
** Side Effects:  May grow the array.
*/
PRIVATE_CODE BOOL AddAFreePtrToEnd(PPTRARRAY pa)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pa, CPTRARRAY));

   /* Are there any free elements in the array? */

   if (pa->aicPtrsUsed < pa->aicPtrsAllocated)
      /* Yes.  Return the next free pointer. */
      bResult = TRUE;
   else
   {
      ARRAYINDEX aicNewPtrs = pa->aicPtrsAllocated + pa->aicPtrsToGrowBy;
      PCVOID *ppcvArray;

      bResult = FALSE;

      /* Try to grow the array. */

      /* Blow off unlikely overflow conditions as ASSERT()s. */

      ASSERT(pa->aicPtrsAllocated <= ARRAYINDEX_MAX + 1);
      ASSERT(ARRAYINDEX_MAX + 1 - pa->aicPtrsToGrowBy >= pa->aicPtrsAllocated);
#ifdef DBLCHECK
      ASSERT((double)aicNewPtrs * (double)(sizeof(PVOID)) <= (double)DWORD_MAX);
#endif

      /* Try to grow the array. */

      if (ReallocateMemory((PVOID)(pa->ppcvArray), aicNewPtrs * sizeof(*ppcvArray), (PVOID *)(&ppcvArray)))
      {
         /*
          * Array reallocated successfully.  Set up PTRARRAY fields, and return
          * the first free index.
          */

         pa->ppcvArray = ppcvArray;
         pa->aicPtrsAllocated = aicNewPtrs;

         bResult = TRUE;
      }
   }

   return(bResult);
}


/*
** PtrHeapSwap()
**
** Swaps two elements in an array.
**
** Arguments:     pa - pointer to array
**                aiFirst - index of first element
**                aiSecond - index of second element
**
** Returns:       void
**
** Side Effects:  none
*/
PRIVATE_CODE void PtrHeapSwap(PPTRARRAY pa, ARRAYINDEX ai1, ARRAYINDEX ai2)
{
   PCVOID pcvTemp;

   ASSERT(IS_VALID_STRUCT_PTR(pa, CPTRARRAY));
   ASSERT(ai1 >= 0);
   ASSERT(ai1 < pa->aicPtrsUsed);
   ASSERT(ai2 >= 0);
   ASSERT(ai2 < pa->aicPtrsUsed);

   pcvTemp = ARRAY_ELEMENT(pa, ai1);
   ARRAY_ELEMENT(pa, ai1) = ARRAY_ELEMENT(pa, ai2);
   ARRAY_ELEMENT(pa, ai2) = pcvTemp;

   return;
}


/*
** PtrHeapSift()
**
** Sifts an element down in an array until the partially ordered tree property
** is retored.
**
** Arguments:     pa - pointer to array
**                aiFirst - index of element to sift down
**                aiLast - index of last element in subtree
**                cspp - element comparison callback function to be called to
**                      compare elements
**
** Returns:       void
**
** Side Effects:  none
*/
PRIVATE_CODE void PtrHeapSift(PPTRARRAY pa, ARRAYINDEX aiFirst, ARRAYINDEX aiLast,
                         COMPARESORTEDPTRSPROC cspp)
{
   ARRAYINDEX ai;
   PCVOID pcvTemp;

   ASSERT(IS_VALID_STRUCT_PTR(pa, CPTRARRAY));
   ASSERT(IS_VALID_CODE_PTR(cspp, COMPARESORTEDPTRSPROC));

   ASSERT(aiFirst >= 0);
   ASSERT(aiFirst < pa->aicPtrsUsed);
   ASSERT(aiLast >= 0);
   ASSERT(aiLast < pa->aicPtrsUsed);

   ai = aiFirst * 2;

   pcvTemp = ARRAY_ELEMENT(pa, aiFirst);

   while (ai <= aiLast)
   {
      if (ai < aiLast &&
          (*cspp)(ARRAY_ELEMENT(pa, ai), ARRAY_ELEMENT(pa, ai + 1)) == CR_FIRST_SMALLER)
         ai++;

      if ((*cspp)(pcvTemp, ARRAY_ELEMENT(pa, ai)) != CR_FIRST_SMALLER)
         break;

      ARRAY_ELEMENT(pa, aiFirst) = ARRAY_ELEMENT(pa, ai);

      aiFirst = ai;

      ai *= 2;
   }

   ARRAY_ELEMENT(pa, aiFirst) = pcvTemp;

   return;
}


#ifdef VSTF

/*
** IsValidPCNEWPTRARRAY()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCNEWPTRARRAY(PCNEWPTRARRAY pcnpa)
{
   BOOL bResult;

   /*
    * Given the current value of ARRAYINDEX_MAX (ULONG_MAX - 1), we don't
    * really need a check like:
    *
    *    (pcna->aicInitialPtrs - 1 <= ARRAYINDEX_MAX)
    *
    * since the maximum value of the aicInitialPtrs field (ULONG_MAX) still
    * yields a valid top index:
    *
    *    (ULONG_MAX) - 1 == (ULONG_MAX - 1)
    *
    *    ARRAYINDEX_MAX == (ULONG_MAX - 1)
    *
    * But we'll leave the clause here anyway in case things change.
    */

   if (IS_VALID_READ_PTR(pcnpa, CNEWPTRARRAY) &&
       EVAL(pcnpa->aicInitialPtrs >= 0) &&
       EVAL(pcnpa->aicInitialPtrs < ARRAYINDEX_MAX) &&
       EVAL(pcnpa->aicAllocGranularity > 0) &&
       FLAGS_ARE_VALID(pcnpa->dwFlags, ALL_NPA_FLAGS))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}


/*
** IsValidPCPTRARRAY()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCPTRARRAY(PCPTRARRAY pcpa)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pcpa, CPTRARRAY) &&
       EVAL(pcpa->aicPtrsToGrowBy > 0) &&
       FLAGS_ARE_VALID(pcpa->dwFlags, ALL_PA_FLAGS) &&
       EVAL(pcpa->aicPtrsAllocated >= 0) &&
       IS_VALID_READ_BUFFER_PTR(pcpa->ppcvArray, PCVOID, (pcpa->aicPtrsAllocated) * sizeof(*(pcpa->ppcvArray))) &&
       (EVAL(pcpa->aicPtrsUsed >= 0) &&
        EVAL(pcpa->aicPtrsUsed <= pcpa->aicPtrsAllocated)))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}

#endif


#if defined(DEBUG) || defined(VSTF)

/*
** IsPtrArrayInSortedOrder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsPtrArrayInSortedOrder(PCPTRARRAY pcpa,
                                          COMPARESORTEDPTRSPROC cspp)
{
   BOOL bResult = TRUE;

   /* Don't validate pcpa here. */

   ASSERT(IS_VALID_CODE_PTR(cspp, COMPARESORTEDPTRSPROC));

   if (pcpa->aicPtrsUsed > 1)
   {
      ARRAYINDEX ai;

      for (ai = 0; ai < pcpa->aicPtrsUsed - 1; ai++)
      {
         if ((*cspp)(ARRAY_ELEMENT(pcpa, ai), ARRAY_ELEMENT(pcpa, ai + 1))
             == CR_FIRST_LARGER)
         {
            bResult = FALSE;
            ERROR_OUT((TEXT("IsPtrArrayInSortedOrder(): Element [%ld] %#lx > following element [%ld] %#lx."),
                       ai,
                       ARRAY_ELEMENT(pcpa, ai),
                       ai + 1,
                       ARRAY_ELEMENT(pcpa, ai + 1)));
            break;
         }
      }
   }

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
** CreatePtrArray()
**
** Creates a pointer array.
**
** Arguments:     pcna - pointer to NEWPTRARRAY describing the array to be
**                        created
**
** Returns:       Handle to the new array if successful, or NULL if
**                unsuccessful.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreatePtrArray(PCNEWPTRARRAY pcna, PHPTRARRAY phpa)
{
   PCVOID *ppcvArray;

   ASSERT(IS_VALID_STRUCT_PTR(pcna, CNEWPTRARRAY));
   ASSERT(IS_VALID_WRITE_PTR(phpa, HPTRARRAY));

   /* Try to allocate the initial array. */

   *phpa = NULL;

   if (AllocateMemory(pcna->aicInitialPtrs * sizeof(*ppcvArray), (PVOID *)(&ppcvArray)))
   {
      PPTRARRAY pa;

      /* Try to allocate PTRARRAY structure. */

      if (AllocateMemory(sizeof(*pa), &pa))
      {
         /* Initialize PTRARRAY fields. */

         pa->aicPtrsToGrowBy = pcna->aicAllocGranularity;
         pa->ppcvArray = ppcvArray;
         pa->aicPtrsAllocated = pcna->aicInitialPtrs;
         pa->aicPtrsUsed = 0;

         /* Set flags. */

         if (IS_FLAG_SET(pcna->dwFlags, NPA_FL_SORTED_ADD))
            pa->dwFlags = PA_FL_SORTED_ADD;
         else
            pa->dwFlags = 0;

         *phpa = (HPTRARRAY)pa;

         ASSERT(IS_VALID_HANDLE(*phpa, PTRARRAY));
      }
      else
         /* Unlock and free array (ignoring return values). */
         FreeMemory((PVOID)(ppcvArray));
   }

   return(*phpa != NULL);
}


/*
** DestroyPtrArray()
**
** Destroys an array.
**
** Arguments:     hpa - handle to array to be destroyed
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyPtrArray(HPTRARRAY hpa)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   /* Free the array. */

   ASSERT(((PCPTRARRAY)hpa)->ppcvArray);

   FreeMemory((PVOID)(((PCPTRARRAY)hpa)->ppcvArray));

   /* Free PTRARRAY structure. */

   FreeMemory((PPTRARRAY)hpa);

   return;
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** InsertPtr()
**
** Adds an element to an array at a given index.
**
** Arguments:     hpa - handle to array that element is to be added to
**                aiInsert - index where new element is to be inserted
**                pcvNew - pointer to element to add to array
**
** Returns:       TRUE if the element was inserted successfully, or FALSE if
**                not.
**
** Side Effects:  The array may be grown.
**
** N.b., for an array marked PA_FL_SORTED_ADD, this index should only be
** retrieved using SearchSortedArray(), or the sorted order will be destroyed.
*/
PUBLIC_CODE BOOL InsertPtr(HPTRARRAY hpa, COMPARESORTEDPTRSPROC cspp, ARRAYINDEX aiInsert, PCVOID pcvNew)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(aiInsert >= 0);
   ASSERT(aiInsert <= ((PCPTRARRAY)hpa)->aicPtrsUsed);

#ifdef DEBUG

   /* Make sure the correct index was given for insertion. */

   if (ADD_PTRS_IN_SORTED_ORDER((PCPTRARRAY)hpa))
   {
      ARRAYINDEX aiNew;

      EVAL(! SearchSortedArray(hpa, cspp, pcvNew, &aiNew));

      ASSERT(aiInsert == aiNew);
   }

#endif

   /* Get a free element in the array. */

   bResult = AddAFreePtrToEnd((PPTRARRAY)hpa);

   if (bResult)
   {
      ASSERT(((PCPTRARRAY)hpa)->aicPtrsUsed < ARRAYINDEX_MAX);

      /* Open a slot for the new element. */

      MoveMemory((PVOID)& ARRAY_ELEMENT((PPTRARRAY)hpa, aiInsert + 1),
                 & ARRAY_ELEMENT((PPTRARRAY)hpa, aiInsert),
                 (((PCPTRARRAY)hpa)->aicPtrsUsed - aiInsert) * sizeof(ARRAY_ELEMENT((PCPTRARRAY)hpa, 0)));

      /* Put the new element in the open slot. */

      ARRAY_ELEMENT((PPTRARRAY)hpa, aiInsert) = pcvNew;

      ((PPTRARRAY)hpa)->aicPtrsUsed++;
   }

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** AddPtr()
**
** Adds an element to an array, in sorted order if so specified at
** CreatePtrArray() time.
**
** Arguments:     hpa - handle to array that element is to be added to
**                pcvNew - pointer to element to be added to array
**                pai - pointer to ARRAYINDEX to be filled in with index of
**                      new element, may be NULL
**
** Returns:       TWINRESULT
**
** Side Effects:  The array may be grown.
*/
PUBLIC_CODE BOOL AddPtr(HPTRARRAY hpa, COMPARESORTEDPTRSPROC cspp, PCVOID pcvNew, PARRAYINDEX pai)
{
   BOOL bResult;
   ARRAYINDEX aiNew;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(! pai || IS_VALID_WRITE_PTR(pai, ARRAYINDEX));

   /* Find out where the new element should go. */

   if (ADD_PTRS_IN_SORTED_ORDER((PCPTRARRAY)hpa))
      EVAL(! SearchSortedArray(hpa, cspp, pcvNew, &aiNew));
   else
      aiNew = ((PCPTRARRAY)hpa)->aicPtrsUsed;

   bResult = InsertPtr(hpa, cspp, aiNew, pcvNew);

   if (bResult && pai)
      *pai = aiNew;

   return(bResult);
}


/*
** DeletePtr()
**
** Removes an element from an element array.
**
** Arguments:     ha - handle to array
**                aiDelete - index of element to be deleted
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE void DeletePtr(HPTRARRAY hpa, ARRAYINDEX aiDelete)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(aiDelete >= 0);
   ASSERT(aiDelete < ((PCPTRARRAY)hpa)->aicPtrsUsed);

   /*
    * Compact the element array by moving down all elements past the one being
    * deleted.
    */

   MoveMemory((PVOID)& ARRAY_ELEMENT((PPTRARRAY)hpa, aiDelete),
              & ARRAY_ELEMENT((PPTRARRAY)hpa, aiDelete + 1),
              (((PCPTRARRAY)hpa)->aicPtrsUsed - aiDelete - 1) * sizeof(ARRAY_ELEMENT((PCPTRARRAY)hpa, 0)));

   /* One less element used. */

   ((PPTRARRAY)hpa)->aicPtrsUsed--;

   return;
}


/*
** DeleteAllPtrs()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DeleteAllPtrs(HPTRARRAY hpa)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   ((PPTRARRAY)hpa)->aicPtrsUsed = 0;

   return;
}


/*
** GetPtrCount()
**
** Retrieves the number of elements in an element array.
**
** Arguments:     hpa - handle to array
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE ARRAYINDEX GetPtrCount(HPTRARRAY hpa)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   return(((PCPTRARRAY)hpa)->aicPtrsUsed);
}


/*
** GetPtr()
**
** Retrieves an element from an array.
**
** Arguments:     hpa - handle to array
**                ai - index of element to be retrieved
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE PVOID GetPtr(HPTRARRAY hpa, ARRAYINDEX ai)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(ai >= 0);
   ASSERT(ai < ((PCPTRARRAY)hpa)->aicPtrsUsed);

   return((PVOID)ARRAY_ELEMENT((PCPTRARRAY)hpa, ai));
}


/*
** SortPtrArray()
**
** Sorts an array.
**
** Arguments:     hpa - handle to element list to be sorted
**                cspp - pointer comparison callback function
**
** Returns:       void
**
** Side Effects:  none
**
** Uses heap sort.
*/
PUBLIC_CODE void SortPtrArray(HPTRARRAY hpa, COMPARESORTEDPTRSPROC cspp)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   /* Are there any elements to sort (2 or more)? */

   if (((PCPTRARRAY)hpa)->aicPtrsUsed > 1)
   {
      ARRAYINDEX ai;
      ARRAYINDEX aiLastUsed = ((PCPTRARRAY)hpa)->aicPtrsUsed - 1;

      /* Yes.  Create partially ordered tree. */

      for (ai = aiLastUsed / 2; ai >= 0; ai--)
         PtrHeapSift((PPTRARRAY)hpa, ai, aiLastUsed, cspp);

      for (ai = aiLastUsed; ai >= 1; ai--)
      {
         /* Remove minimum from front of heap. */

         PtrHeapSwap((PPTRARRAY)hpa, 0, ai);

         /* Reestablish partially ordered tree. */

         PtrHeapSift((PPTRARRAY)hpa, 0, ai - 1, cspp);
      }
   }

   ASSERT(IsPtrArrayInSortedOrder((PCPTRARRAY)hpa, cspp));

   return;
}


/*
** SearchSortedArray()
**
** Searches an array for a target element using binary search.  If several
** adjacent elements match the target element, the index of the first matching
** element is returned.
**
** Arguments:     hpa - handle to array to be searched
**                cspp - element comparison callback function to be called to
**                      compare the target element with an element from the
**                      array, the callback function is called as:
**
**                         (*cspp)(pcvTarget, pcvPtrFromList)
**
**                pcvTarget - pointer to target element to search for
**                pbFound - pointer to BOOL to be filled in with TRUE if the
**                          target element is found, or FALSE if not
**                paiTarget - pointer to ARRAYINDEX to be filled in with the
**                            index of the first element matching the target
**                            element if found, otherwise filled in with the
**                            index where the target element should be
**                            inserted
**
** Returns:       TRUE if target element is found.  FALSE if not.
**
** Side Effects:  none
**
** We use a private version of SearchSortedArray() instead of the CRT bsearch()
** function since we want it to return the insertion index of the target
** element if the target element is not found.
*/
PUBLIC_CODE BOOL SearchSortedArray(HPTRARRAY hpa, COMPARESORTEDPTRSPROC cspp,
                                   PCVOID pcvTarget, PARRAYINDEX paiTarget)
{
   BOOL bFound;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(IS_VALID_CODE_PTR(cspp, COMPARESORTEDPTRSPROC));
   ASSERT(IS_VALID_WRITE_PTR(paiTarget, ARRAYINDEX));

   ASSERT(ADD_PTRS_IN_SORTED_ORDER((PCPTRARRAY)hpa));
#if 0
   ASSERT(IsPtrArrayInSortedOrder((PCPTRARRAY)hpa, ((PCPTRARRAY)hpa)->cspp));
#endif

   bFound = FALSE;

   /* Are there any elements to search through? */

   if (((PCPTRARRAY)hpa)->aicPtrsUsed > 0)
   {
      ARRAYINDEX aiLow = 0;
      ARRAYINDEX aiMiddle = 0;
      ARRAYINDEX aiHigh = ((PCPTRARRAY)hpa)->aicPtrsUsed - 1;
      COMPARISONRESULT cr = CR_EQUAL;

      /* Yes.  Search for the target element. */

      /*
       * At the end of the penultimate iteration of this loop:
       *
       * aiLow == aiMiddle == aiHigh.
       */

      ASSERT(aiHigh <= ARRAYINDEX_MAX);

      while (aiLow <= aiHigh)
      {
         aiMiddle = (aiLow + aiHigh) / 2;

         cr = (*cspp)(pcvTarget, ARRAY_ELEMENT((PCPTRARRAY)hpa, aiMiddle));

         if (cr == CR_FIRST_SMALLER)
            aiHigh = aiMiddle - 1;
         else if (cr == CR_FIRST_LARGER)
            aiLow = aiMiddle + 1;
         else
         {
            /*
             * Found a match at index aiMiddle.  Search back for first match.
             */

            bFound = TRUE;

            while (aiMiddle > 0)
            {
               if ((*cspp)(pcvTarget, ARRAY_ELEMENT((PCPTRARRAY)hpa, aiMiddle - 1)) != CR_EQUAL)
                  break;
               else
                  aiMiddle--;
            }

            break;
         }
      }

      /*
       * Return the index of the target if found, or the index where the target
       * should be inserted if not found.
       */

      /*
       * If (cr == CR_FIRST_LARGER), the insertion index is aiLow.
       *
       * If (cr == CR_FIRST_SMALLER), the insertion index is aiMiddle.
       *
       * If (cr == CR_EQUAL), the insertion index is aiMiddle.
       */

      if (cr == CR_FIRST_LARGER)
         *paiTarget = aiLow;
      else
         *paiTarget = aiMiddle;
   }
   else
      /*
       * No.  The target element cannot be found in an empty array.  It should
       * be inserted as the first element.
       */
      *paiTarget = 0;

   ASSERT(*paiTarget <= ((PCPTRARRAY)hpa)->aicPtrsUsed);

   return(bFound);
}


/*
** LinearSearchArray()
**
** Searches an array for a target element using binary search.  If several
** adjacent elements match the target element, the index of the first matching
** element is returned.
**
** Arguments:     hpa - handle to array to be searched
**                cupp - element comparison callback function to be called to
**                       compare the target element with an element from the
**                       array, the callback function is called as:
**
**                         (*cupp)(pvTarget, pvPtrFromList)
**
**                      the callback function should return a value based upon
**                      the result of the element comparison as follows:
**
**                         FALSE, pvTarget == pvPtrFromList
**                         TRUE,  pvTarget != pvPtrFromList
**
**                pvTarget - far element to target element to search for
**                paiTarget - far element to ARRAYINDEX to be filled in with
**                            the index of the first matching element if
**                            found, otherwise filled in with index where
**                            element should be inserted
**
** Returns:       TRUE if target element is found.  FALSE if not.
**
** Side Effects:  none
**
** We use a private version of LinearSearchForPtr() instead of the CRT _lfind()
** function since we want it to return the insertion index of the target
** element if the target element is not found.
**
** If the target element is not found the insertion index returned is the first
** element after the last used element in the array.
*/
PUBLIC_CODE BOOL LinearSearchArray(HPTRARRAY hpa, COMPAREUNSORTEDPTRSPROC cupp,
                                   PCVOID pcvTarget, PARRAYINDEX paiTarget)
{
   BOOL bFound;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY) &&
          (! cupp || IS_VALID_CODE_PTR(cupp, COMPPTRSPROC)) &&
          IS_VALID_WRITE_PTR(paiTarget, ARRAYINDEX));

   bFound = FALSE;

   for (ai = 0; ai < ((PCPTRARRAY)hpa)->aicPtrsUsed; ai++)
   {
      if (! (*cupp)(pcvTarget, ARRAY_ELEMENT((PCPTRARRAY)hpa, ai)))
      {
         bFound = TRUE;
         break;
      }
   }

   if (bFound)
      *paiTarget = ai;

   return(bFound);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidHPTRARRAY()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHPTRARRAY(HPTRARRAY hpa)
{
   return(IS_VALID_STRUCT_PTR((PCPTRARRAY)hpa, CPTRARRAY));
}

#endif


#ifdef VSTF

/*
** IsValidHGLOBAL()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHGLOBAL(HGLOBAL hg)
{
   return(EVAL(hg != NULL));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\reclist.c ===
/*
 * reclist.c - Reconciliation list ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "oleutil.h"


/* Constants
 ************/

/* RECITEMACTION weights for folders returned by WeighFolderAction(). */

/* (RECITEMACTION weights for files are the RECITEMACTION values.) */

#define RIA_WT_COPY        (-2)
#define RIA_WT_NOTHING     (-1)
#define RIA_WT_DELETE      (+5)


/* Types
 ********/

/* used to count the number of RECNODEs of each RECNODESTATE in a RECITEM */

typedef struct _recnodestatecounter
{
   ULONG ulcUnavailable;
   ULONG ulcDoesNotExist;
   ULONG ulcDeleted;
   ULONG ulcNotReconciled;
   ULONG ulcUpToDate;
   ULONG ulcChanged;
   ULONG ulcNeverReconciled;
}
RECNODESTATECOUNTER;
DECLARE_STANDARD_TYPES(RECNODESTATECOUNTER);

/* DoesTwinFamilyNeedRec() callback structure */

typedef struct _twinfamilyrecinfo
{
   TWINRESULT tr;

   BOOL bNeedsRec;
}
TWINFAMILYRECINFO;
DECLARE_STANDARD_TYPES(TWINFAMILYRECINFO);


/***************************** Private Functions *****************************/


/* Module Prototypes
 ********************/

PRIVATE_CODE RECNODESTATE DetermineRecNodeState(PCRECNODE);
PRIVATE_CODE void AddRecNodeState(RECNODESTATE, PRECNODESTATECOUNTER);
PRIVATE_CODE void CountRecNodeStates(PCRECITEM, PRECNODESTATECOUNTER, PULONG);
PRIVATE_CODE void DetermineRecActions(PRECITEM);
PRIVATE_CODE void BreakMergeIfNecessary(PRECITEM);
PRIVATE_CODE TWINRESULT AddRecItemsToRecList(HTWINLIST, CREATERECLISTPROC, LPARAM, PRECLIST);
PRIVATE_CODE void LinkUpRecList(PRECLIST, HPTRARRAY);
PRIVATE_CODE int WeighFileAction(RECITEMACTION);
PRIVATE_CODE int WeighFolderAction(RECITEMACTION);
PRIVATE_CODE COMPARISONRESULT RecItemSortCmp(PCVOID, PCVOID);
PRIVATE_CODE void DestroyArrayOfRecItems(HPTRARRAY);
PRIVATE_CODE BOOL MarkTwinFamilyUsed(POBJECTTWIN, PVOID);
PRIVATE_CODE ULONG MarkIntersectingTwinFamiliesUsed(HTWIN);
PRIVATE_CODE void DestroyRecItem(PRECITEM);
PRIVATE_CODE void DestroyRecNode(PRECNODE);
PRIVATE_CODE void DestroyListOfRecItems(PRECITEM);
PRIVATE_CODE void DestroyListOfRecNodes(PRECNODE);
PRIVATE_CODE void MyDestroyRecList(PRECLIST);
PRIVATE_CODE BOOL DeleteDeletedObjectTwins(PCRECITEM, PBOOL);
PRIVATE_CODE BOOL FindAGeneratedObjectTwinProc(POBJECTTWIN, PVOID);
PRIVATE_CODE BOOL FolderTwinShouldBeImplicitlyDeleted(PFOLDERPAIR);
PRIVATE_CODE BOOL DeleteDeletedFolderTwins(HPTRARRAY);
PRIVATE_CODE TWINRESULT CreateRecItem(PTWINFAMILY, PRECITEM *);
PRIVATE_CODE TWINRESULT AddObjectTwinRecNode(PRECITEM, POBJECTTWIN);
PRIVATE_CODE BOOL DoesTwinFamilyNeedRec(POBJECTTWIN, PVOID);
PRIVATE_CODE TWINRESULT GetFolderPairStatus(PFOLDERPAIR, CREATERECLISTPROC, LPARAM, PFOLDERTWINSTATUS);

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidCreateRecListProcMsg(UINT);
PRIVATE_CODE BOOL IsValidFOLDERTWINSTATUS(FOLDERTWINSTATUS);
PRIVATE_CODE BOOL IsValidPCRECNODESTATECOUNTER(PCRECNODESTATECOUNTER);

#endif

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsValidRECNODESTATE(RECNODESTATE);
PRIVATE_CODE BOOL IsValidRECNODEACTION(RECNODEACTION);
PRIVATE_CODE BOOL IsValidRECITEMACTION(RECITEMACTION);
PRIVATE_CODE BOOL IsValidPCRECLIST(PCRECLIST);

#endif


/*
** DetermineRecNodeState()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE RECNODESTATE DetermineRecNodeState(PCRECNODE pcrn)
{
   RECNODESTATE rnstate;

   ASSERT(IS_VALID_WRITE_PTR(pcrn, RECNODE));

   if (pcrn->fsCurrent.fscond != FS_COND_UNAVAILABLE)
   {
      if (IsReconciledFileStamp(&(pcrn->fsLast)))
      {
         if (pcrn->fsCurrent.fscond == FS_COND_EXISTS)
         {
            BOOL bReconciledLastTime;

            bReconciledLastTime = (IsStubFlagClear(&(((PCOBJECTTWIN)(pcrn->hObjectTwin))->stub),
                                                   STUB_FL_NOT_RECONCILED));

            if (MyCompareFileStamps(&(pcrn->fsLast), &(pcrn->fsCurrent))
                == CR_EQUAL)
            {
               if (bReconciledLastTime)
                  rnstate = RNS_UP_TO_DATE;
               else
                  rnstate = RNS_NOT_RECONCILED;
            }
            else
            {
               if (bReconciledLastTime)
                  rnstate = RNS_CHANGED;
               else
                  /* Divergent version. */
                  rnstate = RNS_NEVER_RECONCILED;
            }
         }
         else
         {
            ASSERT(pcrn->fsCurrent.fscond == FS_COND_DOES_NOT_EXIST);

            rnstate = RNS_DELETED;
         }
      }
      else
      {
         if (pcrn->fsCurrent.fscond == FS_COND_EXISTS)
            rnstate = RNS_NEVER_RECONCILED;
         else
         {
            ASSERT(pcrn->fsCurrent.fscond == FS_COND_DOES_NOT_EXIST);
            rnstate = RNS_DOES_NOT_EXIST;
         }
      }
   }
   else
   {
      /* Deleted wins over unavailable. */

      if (pcrn->fsLast.fscond == FS_COND_DOES_NOT_EXIST)
         rnstate = RNS_DELETED;
      else
         rnstate = RNS_UNAVAILABLE;
   }

   /* Collapse folder RECNODE states. */

   if (IsFolderObjectTwinName(pcrn->priParent->pcszName))
   {
      switch (rnstate)
      {
         case RNS_NEVER_RECONCILED:
         case RNS_NOT_RECONCILED:
         case RNS_CHANGED:
            rnstate = RNS_UP_TO_DATE;
            break;
      }
   }

   ASSERT(IsValidRECNODESTATE(rnstate));

   return(rnstate);
}


/*
** AddRecNodeState()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void AddRecNodeState(RECNODESTATE rnstate,
                                  PRECNODESTATECOUNTER prnscntr)
{
   ASSERT(IsValidRECNODESTATE(rnstate));
   ASSERT(IS_VALID_STRUCT_PTR(prnscntr, CRECNODESTATECOUNTER));

   switch (rnstate)
   {
      case RNS_UNAVAILABLE:
         ASSERT(prnscntr->ulcUnavailable < ULONG_MAX);
         prnscntr->ulcUnavailable++;
         break;

      case RNS_DOES_NOT_EXIST:
         ASSERT(prnscntr->ulcDoesNotExist < ULONG_MAX);
         prnscntr->ulcDoesNotExist++;
         break;

      case RNS_DELETED:
         ASSERT(prnscntr->ulcDeleted < ULONG_MAX);
         prnscntr->ulcDeleted++;
         break;

      case RNS_NOT_RECONCILED:
         ASSERT(prnscntr->ulcNotReconciled < ULONG_MAX);
         prnscntr->ulcNotReconciled++;
         break;

      case RNS_UP_TO_DATE:
         ASSERT(prnscntr->ulcUpToDate < ULONG_MAX);
         prnscntr->ulcUpToDate++;
         break;

      case RNS_CHANGED:
         ASSERT(prnscntr->ulcChanged < ULONG_MAX);
         prnscntr->ulcChanged++;
         break;

      default:
         ASSERT(rnstate == RNS_NEVER_RECONCILED);
         ASSERT(prnscntr->ulcNeverReconciled < ULONG_MAX);
         prnscntr->ulcNeverReconciled++;
         break;
   }

   return;
}


/*
** CountRecNodeStates()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void CountRecNodeStates(PCRECITEM pcri,
                                     PRECNODESTATECOUNTER prnscntr,
                                     PULONG pulcToDelete)
{
   PCRECNODE pcrn;

   ASSERT(IS_VALID_READ_PTR(pcri, CRECITEM));
   ASSERT(IS_VALID_STRUCT_PTR(prnscntr, CRECNODESTATECOUNTER));
   ASSERT(IS_VALID_WRITE_PTR(pulcToDelete, ULONG));

   ZeroMemory(prnscntr, sizeof(*prnscntr));
   *pulcToDelete = 0;

   for (pcrn = pcri->prnFirst; pcrn; pcrn = pcrn->prnNext)
   {
      AddRecNodeState(pcrn->rnstate, prnscntr);

      if (pcrn->rnstate == RNS_UP_TO_DATE &&
          IsStubFlagClear(&(((PCOBJECTTWIN)(pcrn->hObjectTwin))->stub),
                          STUB_FL_KEEP))
      {
         ASSERT(*pulcToDelete < ULONG_MAX);
         (*pulcToDelete)++;
      }
   }

   ASSERT(IS_VALID_STRUCT_PTR(prnscntr, CRECNODESTATECOUNTER));
   ASSERT(prnscntr->ulcUnavailable +
          prnscntr->ulcDoesNotExist +
          prnscntr->ulcDeleted +
          prnscntr->ulcNotReconciled +
          prnscntr->ulcUpToDate +
          prnscntr->ulcChanged +
          prnscntr->ulcNeverReconciled == pcri->ulcNodes);
   ASSERT(*pulcToDelete <= prnscntr->ulcUpToDate);

   return;
}


/*
** DetermineRecActions()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE void DetermineRecActions(PRECITEM pri)
{
   RECNODESTATECOUNTER rnscntr;
   ULONG ulcToDelete;
   RECITEMACTION riaSummary = RIA_NOTHING;
   RECNODEACTION rnaDoesNotExist = RNA_NOTHING;
   RECNODEACTION rnaNotReconciled = RNA_NOTHING;
   RECNODEACTION rnaUpToDateSrc = RNA_NOTHING;
   RECNODEACTION rnaUpToDate = RNA_NOTHING;
   RECNODEACTION rnaChanged = RNA_NOTHING;
   RECNODEACTION rnaNeverReconciled = RNA_NOTHING;
   BOOL bNeedUpToDateCopySrc = FALSE;
   BOOL bNeedNotReconciledCopySrc = FALSE;
   PRECNODE prn;

   ASSERT(IS_VALID_WRITE_PTR(pri, RECITEM));

   ZeroMemory(&rnscntr, sizeof(rnscntr));
   CountRecNodeStates(pri, &rnscntr, &ulcToDelete);

   if (rnscntr.ulcNeverReconciled > 0)
   {
      if (rnscntr.ulcChanged > 0)
      {
         riaSummary = RIA_MERGE;

         rnaNeverReconciled = RNA_MERGE_ME;
         rnaChanged = RNA_MERGE_ME;

         rnaUpToDate = RNA_COPY_TO_ME;
         rnaNotReconciled = RNA_COPY_TO_ME;
         rnaDoesNotExist = RNA_COPY_TO_ME;
      }
      else if (rnscntr.ulcUpToDate > 0)
      {
         riaSummary = RIA_MERGE;

         rnaNeverReconciled = RNA_MERGE_ME;
         rnaUpToDate = RNA_MERGE_ME;

         rnaNotReconciled = RNA_COPY_TO_ME;
         rnaDoesNotExist = RNA_COPY_TO_ME;
      }
      else if (rnscntr.ulcNotReconciled > 0)
      {
         riaSummary = RIA_MERGE;

         rnaNeverReconciled = RNA_MERGE_ME;
         rnaNotReconciled = RNA_MERGE_ME;

         rnaDoesNotExist = RNA_COPY_TO_ME;
      }
      else if (rnscntr.ulcNeverReconciled >= 2)
      {
         riaSummary = RIA_MERGE;

         rnaNeverReconciled = RNA_MERGE_ME;

         rnaDoesNotExist = RNA_COPY_TO_ME;
      }
      else if (rnscntr.ulcDoesNotExist > 0)
      {
         ASSERT(rnscntr.ulcNeverReconciled == 1);

         riaSummary = RIA_COPY;

         rnaNeverReconciled = RNA_COPY_FROM_ME;

         rnaDoesNotExist = RNA_COPY_TO_ME;
      }
   }
   else if (rnscntr.ulcChanged >= 2)
   {
      riaSummary = RIA_MERGE;

      rnaChanged = RNA_MERGE_ME;

      rnaUpToDate = RNA_COPY_TO_ME;
      rnaNotReconciled = RNA_COPY_TO_ME;
      rnaDoesNotExist = RNA_COPY_TO_ME;
   }
   else if (rnscntr.ulcChanged == 1)
   {
      if (rnscntr.ulcUpToDate > 0 ||
          rnscntr.ulcNotReconciled > 0 ||
          rnscntr.ulcDoesNotExist > 0)
      {
         riaSummary = RIA_COPY;

         rnaChanged = RNA_COPY_FROM_ME;

         rnaUpToDate = RNA_COPY_TO_ME;
         rnaNotReconciled = RNA_COPY_TO_ME;
         rnaDoesNotExist = RNA_COPY_TO_ME;
      }
   }
   else if (IsTwinFamilyDeletionPending((PCTWINFAMILY)(pri->hTwinFamily)))
   {
      if (ulcToDelete > 0)
      {
         riaSummary = RIA_DELETE;

         rnaNotReconciled = RNA_DELETE_ME;
         rnaUpToDate = RNA_DELETE_ME;
      }
   }
   else if (rnscntr.ulcUpToDate > 0)
   {
      if (rnscntr.ulcNotReconciled > 0 ||
          rnscntr.ulcDoesNotExist > 0)
      {
         riaSummary = RIA_COPY;

         bNeedUpToDateCopySrc = TRUE;

         rnaNotReconciled = RNA_COPY_TO_ME;
         rnaDoesNotExist = RNA_COPY_TO_ME;
      }
   }
   else if (rnscntr.ulcNotReconciled > 0)
   {
      if (rnscntr.ulcDoesNotExist > 0)
      {
         riaSummary = RIA_COPY;

         bNeedNotReconciledCopySrc = TRUE;

         rnaDoesNotExist = RNA_COPY_TO_ME;
      }
   }

   /* Apply determined actions. */

   ASSERT(! (bNeedUpToDateCopySrc && bNeedNotReconciledCopySrc));

   for (prn = pri->prnFirst; prn; prn = prn->prnNext)
   {
      switch (prn->rnstate)
      {
         case RNS_NEVER_RECONCILED:
            prn->rnaction = rnaNeverReconciled;
            break;

         case RNS_DOES_NOT_EXIST:
            prn->rnaction = rnaDoesNotExist;
            break;

         case RNS_NOT_RECONCILED:
            if (bNeedNotReconciledCopySrc)
            {
               prn->rnaction = RNA_COPY_FROM_ME;
               bNeedNotReconciledCopySrc = FALSE;
            }
            else
               prn->rnaction = rnaNotReconciled;
            break;

         case RNS_UP_TO_DATE:
            if (bNeedUpToDateCopySrc)
            {
               prn->rnaction = RNA_COPY_FROM_ME;
               bNeedUpToDateCopySrc = FALSE;
            }
            else
               prn->rnaction = rnaUpToDate;
            break;

         case RNS_CHANGED:
            prn->rnaction = rnaChanged;
            break;

         default:
            ASSERT(prn->rnstate == RNS_UNAVAILABLE ||
                   prn->rnstate == RNS_DELETED);
            prn->rnaction = RNA_NOTHING;
            break;
      }

      if (prn->rnaction == RNA_DELETE_ME)
      {
         if (IsStubFlagClear(&(((PCOBJECTTWIN)(prn->hObjectTwin))->stub),
             STUB_FL_KEEP))
            SET_FLAG(prn->dwFlags, RN_FL_DELETION_SUGGESTED);
         else
            prn->rnaction = RNA_NOTHING;
      }
   }

   pri->riaction = riaSummary;

   /* Break a merge if no reconciliation handler is registered. */

   if (pri->riaction == RIA_MERGE)
      BreakMergeIfNecessary(pri);

   ASSERT(IS_VALID_STRUCT_PTR(pri, CRECITEM));

   return;
}


/*
** BreakMergeIfNecessary()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void BreakMergeIfNecessary(PRECITEM pri)
{
   PRECNODE prnMergeDest;
   TCHAR rgchPath[MAX_PATH_LEN];
   CLSID clsidReconciler;

   ASSERT(IS_VALID_STRUCT_PTR(pri, CRECITEM));

   ASSERT(pri->riaction == RIA_MERGE);

   /* Is a class reconciler registered for this RECITEM? */

   ChooseMergeDestination(pri, &prnMergeDest);
   ASSERT(prnMergeDest->priParent == pri);

   ComposePath(rgchPath, prnMergeDest->pcszFolder, prnMergeDest->priParent->pcszName);
   ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

   if (FAILED(GetReconcilerClassID(rgchPath, &clsidReconciler)))
   {
      pri->riaction = RIA_BROKEN_MERGE;

      TRACE_OUT((TEXT("MassageMergeCase(): Breaking merge RECITEM for %s.  No registered reconciliation handler."),
                 pri->pcszName));
   }

   return;
}


/*
** AddRecItemsToRecList()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT AddRecItemsToRecList(HTWINLIST htl,
                                             CREATERECLISTPROC crlp,
                                             LPARAM lpCallbackData,
                                             PRECLIST prl)
{
   TWINRESULT tr = TR_SUCCESS;
   HBRFCASE hbr;
   HPTRARRAY hpaTwinFamilies;
   ARRAYINDEX aicTwins;
   ARRAYINDEX ai;
   ULONG ulcMarkedTwinFamilies = 0;
   NEWPTRARRAY npa;
   HPTRARRAY hpaRecItems;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_HANDLE(htl, TWINLIST));
   ASSERT(! crlp ||
          IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));
   ASSERT(IS_VALID_STRUCT_PTR(prl, CRECLIST));

   /*
    * "Used" twin families are twin families that are to be added to the
    * reconciliation list as RECITEMs.
    */

   /* Mark all twin families unused. */

   hbr = GetTwinListBriefcase(htl);

   hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(hbr);

   ClearFlagInArrayOfStubs(hpaTwinFamilies, STUB_FL_USED);

   /* Mark twin families that intersect twins in twin list as used. */

   aicTwins = GetTwinListCount(htl);

   for (ai = 0; ai < aicTwins; ai++)
   {
      ULONG ulcNewlyMarked;

      ulcNewlyMarked = MarkIntersectingTwinFamiliesUsed(GetTwinFromTwinList(htl, ai));

      ASSERT(ulcMarkedTwinFamilies <= ULONG_MAX - ulcNewlyMarked);
      ulcMarkedTwinFamilies += ulcNewlyMarked;
   }

   /* Create a PTRARRAY to keep track of the RECITEMs created. */

   npa.aicInitialPtrs = ulcMarkedTwinFamilies;
   npa.aicAllocGranularity = 1;
   npa.dwFlags = 0;

   if (CreatePtrArray(&npa, &hpaRecItems))
   {
      ARRAYINDEX aicPtrs;

      /* Add the marked twin families to the RECLIST as RECITEMS. */

      aicPtrs = GetPtrCount(hpaTwinFamilies);

      ai = 0;

      while (ai < aicPtrs && ulcMarkedTwinFamilies > 0)
      {
         PTWINFAMILY ptf;

         ptf = GetPtr(hpaTwinFamilies, ai);

         ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

         if (IsStubFlagSet(&(ptf->stub), STUB_FL_USED))
         {
            PRECITEM priNew;

            ulcMarkedTwinFamilies--;

            tr = CreateRecItem(ptf, &priNew);

            if (tr == TR_SUCCESS)
            {
               ARRAYINDEX ai;

               if (AddPtr(hpaRecItems, NULL, priNew, &ai))
               {
                  if (! NotifyCreateRecListStatus(crlp, CRLS_DELTA_CREATE_REC_LIST,
                                                  0, lpCallbackData))
                     tr = TR_ABORT;
               }
               else
                  tr = TR_OUT_OF_MEMORY;
            }

            if (tr != TR_SUCCESS)
               break;
         }

         ai++;
      }

      if (tr == TR_SUCCESS)
      {
         ASSERT(! ulcMarkedTwinFamilies);
         LinkUpRecList(prl, hpaRecItems);
      }
      else
         DestroyArrayOfRecItems(hpaRecItems);

      DestroyPtrArray(hpaRecItems);
   }
   else
      tr = TR_OUT_OF_MEMORY;

   return(tr);
}


/*
** WeighFileAction()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE int WeighFileAction(RECITEMACTION riaction)
{
   ASSERT(IsValidRECITEMACTION(riaction));

   return(riaction);
}


/*
** WeighFolderAction()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE int WeighFolderAction(RECITEMACTION riaction)
{
   int nWeight;

   ASSERT(IsValidRECITEMACTION(riaction));

   switch (riaction)
   {
      case RIA_COPY:
         nWeight = RIA_WT_COPY;
         break;

      case RIA_NOTHING:
         nWeight = RIA_WT_NOTHING;
         break;

      default:
         ASSERT(riaction == RIA_DELETE);
         nWeight = RIA_WT_DELETE;
         break;
   }

   return(nWeight);
}


/*
** RecItemSortCmp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** RECITEMs are sorted in the following order:
**    1) create folder
**    2) do nothing to folder
**    3) do nothing to file
**    4) delete file
**    5) copy file
**    6) merge file
**    7) broken merge file
**    8) delete folder
** and then by:
**    1) name
*/
PRIVATE_CODE COMPARISONRESULT RecItemSortCmp(PCVOID pcriFirst,
                                             PCVOID pcriSecond)
{
   COMPARISONRESULT cr;
   BOOL bFirstFile;
   BOOL bSecondFile;
   int nFirstWeight;
   int nSecondWeight;

   ASSERT(IS_VALID_STRUCT_PTR(pcriFirst, CRECITEM));
   ASSERT(IS_VALID_STRUCT_PTR(pcriSecond, CRECITEM));

   bFirstFile = (*(((PCRECITEM)pcriFirst)->pcszName) != TEXT('\0'));
   bSecondFile = (*(((PCRECITEM)pcriSecond)->pcszName) != TEXT('\0'));

   if (bFirstFile)
      nFirstWeight = WeighFileAction(((PCRECITEM)pcriFirst)->riaction);
   else
      nFirstWeight = WeighFolderAction(((PCRECITEM)pcriFirst)->riaction);

   if (bSecondFile)
      nSecondWeight = WeighFileAction(((PCRECITEM)pcriSecond)->riaction);
   else
      nSecondWeight = WeighFolderAction(((PCRECITEM)pcriSecond)->riaction);

   cr = CompareInts(nFirstWeight, nSecondWeight);

   if (cr == CR_EQUAL)
      cr = CompareNameStrings(((PCRECITEM)pcriFirst)->pcszName,
                              ((PCRECITEM)pcriSecond)->pcszName);

   return(cr);
}


/*
** LinkUpRecList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void LinkUpRecList(PRECLIST prl, HPTRARRAY hpaRecItems)
{
   ARRAYINDEX ai;
   ARRAYINDEX aicPtrs;

   ASSERT(IS_VALID_STRUCT_PTR(prl, CRECLIST));
   ASSERT(IS_VALID_HANDLE(hpaRecItems, PTRARRAY));

   SortPtrArray(hpaRecItems, &RecItemSortCmp);

   aicPtrs = GetPtrCount(hpaRecItems);

   for (ai = aicPtrs; ai > 0; ai--)
   {
      PRECITEM pri;

      pri = GetPtr(hpaRecItems, ai - 1);

      pri->priNext = prl->priFirst;
      prl->priFirst = pri;
   }

   prl->ulcItems = aicPtrs;

   ASSERT(IS_VALID_STRUCT_PTR(prl, CRECLIST));

   return;
}


/*
** DestroyArrayOfRecItems()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyArrayOfRecItems(HPTRARRAY hpaRecItems)
{
   ARRAYINDEX ai;
   ARRAYINDEX aicPtrs;

   ASSERT(IS_VALID_HANDLE(hpaRecItems, PTRARRAY));

   aicPtrs = GetPtrCount(hpaRecItems);

   for (ai = 0; ai < aicPtrs; ai++)
      DestroyRecItem(GetPtr(hpaRecItems, ai));

   return;
}


/*
** MarkTwinFamilyUsed()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/

#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL MarkTwinFamilyUsed(POBJECTTWIN pot, PVOID pulcNewlyMarked)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(IS_VALID_WRITE_PTR(pulcNewlyMarked, ULONG));

   if (IsStubFlagClear(&(pot->ptfParent->stub), STUB_FL_USED))
   {
      /* Mark the twin family used. */

      SetStubFlag(&(pot->ptfParent->stub), STUB_FL_USED);

      ASSERT(*(PULONG)pulcNewlyMarked < ULONG_MAX);
      (*(PULONG)pulcNewlyMarked)++;
   }

   return(TRUE);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** MarkIntersectingTwinFamiliesUsed()
**
** Marks the twin families that intersect a twin as used.
**
** Arguments:     htwin - handle to intersecting twin
**
** Returns:       Number of twin families newly marked used.
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG MarkIntersectingTwinFamiliesUsed(HTWIN htwin)
{
   ULONG ulcNewlyMarked = 0;

   ASSERT(IS_VALID_HANDLE(htwin, TWIN));

   /* Skip deleted twins. */

   if (IsStubFlagClear((PCSTUB)htwin, STUB_FL_UNLINKED))
   {
      /* Determine intersecting twin families based upon type of twin. */

      switch (((PSTUB)htwin)->st)
      {
         case ST_OBJECTTWIN:
            if (IsStubFlagClear(&(((POBJECTTWIN)htwin)->ptfParent->stub),
                                STUB_FL_USED))
            {
               /* Mark the twin family of the object twin as used. */

               SetStubFlag(&(((POBJECTTWIN)htwin)->ptfParent->stub),
                           STUB_FL_USED);

               ulcNewlyMarked++;
            }
            break;

         case ST_TWINFAMILY:
            if (IsStubFlagClear(&(((PTWINFAMILY)htwin)->stub), STUB_FL_USED))
            {
               /* Mark the twin family used. */

               SetStubFlag(&(((PTWINFAMILY)htwin)->stub), STUB_FL_USED);

               ulcNewlyMarked++;
            }
            break;

         default:
            /*
             * Mark the twin families of the generated object twins from one of
             * the folder twins as used.  (Only one of the two lists of object
             * twins needs to be added since the other list should contain
             * object twins in exactly the same twin families as the first.)
             */
            ASSERT(((PSTUB)htwin)->st == ST_FOLDERPAIR);
            EVAL(EnumGeneratedObjectTwins((PCFOLDERPAIR)htwin,
                                          &MarkTwinFamilyUsed,
                                          &ulcNewlyMarked));
            break;
      }
   }

   return(ulcNewlyMarked);
}


/*
** DestroyRecItem()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyRecItem(PRECITEM pri)
{
   ASSERT(IS_VALID_STRUCT_PTR(pri, CRECITEM));

   /* Destroy the RECITEM's list of RECNODES. */

   DestroyListOfRecNodes(pri->prnFirst);

   /* Now unlock the twin family stub associated with the RECITEM. */

   UnlockStub(&(((PTWINFAMILY)(pri->hTwinFamily))->stub));

   FreeMemory(pri);

   return;
}


/*
** DestroyRecNode()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyRecNode(PRECNODE prn)
{
   ASSERT(IS_VALID_STRUCT_PTR(prn, CRECNODE));

   /* Unlock the object twin stub associated with the RECNODE. */

   UnlockStub(&(((POBJECTTWIN)(prn->hObjectTwin))->stub));

   FreeMemory((LPTSTR)(prn->pcszFolder));
   FreeMemory(prn);

   return;
}


/*
** DestroyListOfRecItems()
**
** Destroys a list of reconciliation items.
**
** Arguments:     priHead - pointer to first reconciliation item in list
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyListOfRecItems(PRECITEM priHead)
{
   while (priHead)
   {
      PRECITEM priPrev;

      ASSERT(IS_VALID_STRUCT_PTR(priHead, CRECITEM));

      priPrev = priHead;
      priHead = priHead->priNext;

      DestroyRecItem(priPrev);
   }

   return;
}


/*
** DestroyListOfRecNodes()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyListOfRecNodes(PRECNODE prnHead)
{
   while (prnHead)
   {
      PRECNODE prnPrev;

      ASSERT(IS_VALID_STRUCT_PTR(prnHead, CRECNODE));

      prnPrev = prnHead;
      prnHead = prnHead->prnNext;

      DestroyRecNode(prnPrev);
   }

   return;
}


/*
** MyDestroyRecList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void MyDestroyRecList(PRECLIST prl)
{
   ASSERT(IS_VALID_STRUCT_PTR(prl, CRECLIST));

   DestroyListOfRecItems(prl->priFirst);
   FreeMemory(prl);

   return;
}


/*
** DeleteDeletedObjectTwins()
**
** Performs garbage collection of obsolete object twins.
**
** Arguments:
**
** Returns:
**
** Side Effects:  May implicitly delete twin family.  Marks generating folder
**                twins used.
**
** Deletes the following:
**    1) Any reconciled object twin last known non-existent whose twin family
**       is not in the deletion pending state.  This may cause the parent twin
**       family to be implicitly deleted as a result.
**    2) Any twin family all of whose object twins are last known non-existent.
*/
PRIVATE_CODE BOOL DeleteDeletedObjectTwins(PCRECITEM pcri,
                                           PBOOL pbAnyFolderTwinsMarked)
{
   BOOL bAnyDeleted = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
   ASSERT(IS_VALID_WRITE_PTR(pbAnyFolderTwinsMarked, BOOL));

   *pbAnyFolderTwinsMarked = FALSE;

   if (! IsTwinFamilyDeletionPending((PCTWINFAMILY)(pcri->hTwinFamily)))
   {
      ULONG ulcNonExistent = 0;
      PRECNODE prn;
      PTWINFAMILY ptf;

      for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
      {
         if (LastKnownNonExistent(&(prn->fsLast), &(prn->fsCurrent)))
         {
            ASSERT(ulcNonExistent < ULONG_MAX);
            ulcNonExistent++;

            if (IsReconciledFileStamp(&(prn->fsLast)))
            {
               POBJECTTWIN pot;

               pot = (POBJECTTWIN)(prn->hObjectTwin);

               if (! pot->ulcSrcFolderTwins)
               {
                  DestroyStub(&(pot->stub));

                  TRACE_OUT((TEXT("DeleteDeletedObjectTwins(): Implicitly removed object twin for deleted file %s\\%s."),
                             prn->pcszFolder,
                             prn->priParent->pcszName));
               }
               else
               {
                  ULONG ulcFolderTwins;

                  ClearStubFlag(&(pot->stub), STUB_FL_FROM_OBJECT_TWIN);

                  EVAL(EnumGeneratingFolderTwins(
                           pot,
                           (ENUMGENERATINGFOLDERTWINSPROC)&SetStubFlagWrapper,
                           (PVOID)STUB_FL_USED, &ulcFolderTwins));

                  *pbAnyFolderTwinsMarked = (ulcFolderTwins > 0);
               }

               bAnyDeleted = TRUE;
            }
         }
      }

      ptf = (PTWINFAMILY)(pcri->hTwinFamily);

      if (ulcNonExistent == pcri->ulcNodes &&
          IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED))
      {
         ClearTwinFamilySrcFolderTwinCount(ptf);

         EVAL(DestroyStub(&(ptf->stub)) == TR_SUCCESS);

         TRACE_OUT((TEXT("DeleteDeletedObjectTwins(): Implicitly removed twin family for %s since all members are last known non-existent."),
                    pcri->pcszName));
      }
   }

   return(bAnyDeleted);
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** FindAGeneratedObjectTwinProc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** An obsolete generated object twin is an object twin that is last known
** non-existent, and whose twin family is not in the deletion pending state.
*/
PRIVATE_CODE BOOL FindAGeneratedObjectTwinProc(POBJECTTWIN pot, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pvUnused);

   return(pot->fsLastRec.fscond == FS_COND_DOES_NOT_EXIST &&
          ! IsTwinFamilyDeletionPending(pot->ptfParent));
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** FolderTwinShouldBeImplicitlyDeleted()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** A folder twin should be implicitly deleted when it meets all the following
** conditions:
**    1) The folder root is last known non-existent.
**    2) One or more of its generated object twins has just been implicitly
**       deleted.
**    3) It no longer generates any non-obsolete object twins.
*/
PRIVATE_CODE BOOL FolderTwinShouldBeImplicitlyDeleted(PFOLDERPAIR pfp)
{
   BOOL bDelete;

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   if (IsStubFlagSet(&(pfp->stub), STUB_FL_DELETION_PENDING) &&
       IsStubFlagSet(&(pfp->stub), STUB_FL_USED) &&
       EnumGeneratedObjectTwins(pfp, &FindAGeneratedObjectTwinProc, NULL))
   {
      TRACE_OUT((TEXT("FolderTwinShouldBeImplicitlyDeleted(): Folder twin %s should be implicitly deleted."),
                 DebugGetPathString(pfp->hpath)));

      bDelete = TRUE;
   }
   else
      bDelete = FALSE;

   return(bDelete);
}


/*
** DeleteDeletedFolderTwins()
**
** Performs garbage collection of obsolete folder twins.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL DeleteDeletedFolderTwins(HPTRARRAY hpaFolderPairs)
{
   BOOL bAnyDeleted = FALSE;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpaFolderPairs, PTRARRAY));

   aicPtrs = GetPtrCount(hpaFolderPairs);
   ASSERT(! (aicPtrs % 2));

   ai = 0;

   while (ai < aicPtrs)
   {
      PFOLDERPAIR pfp;

      pfp = GetPtr(hpaFolderPairs, ai);

      if (FolderTwinShouldBeImplicitlyDeleted(pfp) ||
          FolderTwinShouldBeImplicitlyDeleted(pfp->pfpOther))
      {
         TRACE_OUT((TEXT("DeleteDeletedFolderTwins(): Implicitly deleting %s twin pair %s and %s, files %s."),
                    IsStubFlagSet(&(pfp->stub), STUB_FL_SUBTREE) ? TEXT("subtree") : TEXT("folder"),
                    DebugGetPathString(pfp->hpath),
                    DebugGetPathString(pfp->pfpOther->hpath),
                    GetString(pfp->pfpd->hsName)));

         DestroyStub(&(pfp->stub));

         aicPtrs -= 2;
         ASSERT(! (aicPtrs % 2));
         ASSERT(aicPtrs == GetPtrCount(hpaFolderPairs));

         bAnyDeleted = TRUE;
      }
      else
      {
         /* Don't check this pair of folder twins again. */

         ClearStubFlag(&(pfp->stub), STUB_FL_USED);
         ClearStubFlag(&(pfp->pfpOther->stub), STUB_FL_USED);

         ai++;
      }
   }

   return(bAnyDeleted);
}


/*
** CreateRecItem()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT CreateRecItem(PTWINFAMILY ptf, PRECITEM *ppri)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
   ASSERT(IS_VALID_WRITE_PTR(ppri, PRECITEM));

   /* Create a new RECITEM for the twin family. */

   if (AllocateMemory(sizeof(**ppri), ppri))
   {
      LPCTSTR pcszName;
      BOOL bContinue;
      HNODE hnode;

      /* Get twin family's object name. */

      tr = TR_SUCCESS;

      pcszName = GetString(ptf->hsName);

      /* Fill in the fields required for adding new RECNODEs. */

      /* N.b., SYNCUI depends on dwUser to be initialized to 0. */

      (*ppri)->pcszName = pcszName;
      (*ppri)->ulcNodes = 0;
      (*ppri)->prnFirst = NULL;
      (*ppri)->hTwinFamily = (HTWINFAMILY)ptf;
      (*ppri)->dwUser = 0;

      TRACE_OUT((TEXT("CreateRecItem(): Creating a RECITEM for %s."),
                 pcszName));

      /* Add object twins to the RECITEM one at a time as RECNODEs. */

      for (bContinue = GetFirstNode(ptf->hlistObjectTwins, &hnode);
           bContinue;
           bContinue = GetNextNode(hnode, &hnode))
      {
         POBJECTTWIN pot;

         pot = (POBJECTTWIN)GetNodeData(hnode);

         tr = AddObjectTwinRecNode(*ppri, pot);

         if (tr != TR_SUCCESS)
         {
            DestroyRecItem(*ppri);
            break;
         }
      }

      if (tr == TR_SUCCESS)
      {
         DetermineDeletionPendingState(*ppri);

         DetermineRecActions(*ppri);

         LockStub(&(ptf->stub));

#ifdef DEBUG

         {
            LPCTSTR pcszAction;

            switch ((*ppri)->riaction)
            {
               case RIA_COPY:
                  pcszAction = TEXT("Copy");
                  break;

               case RIA_MERGE:
                  pcszAction = TEXT("Merge");
                  break;

               case RIA_BROKEN_MERGE:
                  pcszAction = TEXT("Broken merge for");
                  break;

               case RIA_DELETE:
                  pcszAction = TEXT("Delete");
                  break;

               default:
                  ASSERT((*ppri)->riaction == RIA_NOTHING);
                  pcszAction = TEXT("Do nothing to");
                  break;
            }

            TRACE_OUT((TEXT("CreateRecItem(): %s %s."),
                       pcszAction,
                       (*ppri)->pcszName));
         }

#endif

      }
   }
   else
      tr = TR_OUT_OF_MEMORY;

   ASSERT(tr != TR_SUCCESS ||
          IS_VALID_READ_PTR(*ppri, CRECITEM));

   return(tr);
}


/*
** AddObjectTwinRecNode()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT AddObjectTwinRecNode(PRECITEM pri, POBJECTTWIN pot)
{
   TWINRESULT tr = TR_OUT_OF_MEMORY;
   PRECNODE prnNew;

   ASSERT(IS_VALID_READ_PTR(pri, CRECITEM));
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

   ASSERT(pri->ulcNodes < ULONG_MAX);

   /* Try to allocate a new reconciliation node. */

   if (AllocateMemory(sizeof(*prnNew), &prnNew))
   {
      LPTSTR pszFolder;

      if (AllocatePathString(pot->hpath, &pszFolder))
      {
         /* Fill in RECNODE fields. */

         /* N.b., we don't touch the dwUser field. */

         /*
          * The rnaction field may be changed later during the call to
          * DetermineRecActions().
          */

         prnNew->hvid = (HVOLUMEID)(pot->hpath);
         prnNew->pcszFolder = pszFolder;
         prnNew->hObjectTwin = (HOBJECTTWIN)pot;
         prnNew->priParent = pri;
         prnNew->fsLast = pot->fsLastRec;
         prnNew->rnaction = RNA_NOTHING;
         prnNew->dwFlags = 0;

         /* Set flags. */

         if (IsStubFlagSet(&(pot->stub), STUB_FL_FROM_OBJECT_TWIN))
            SET_FLAG(prnNew->dwFlags, RN_FL_FROM_OBJECT_TWIN);

         if (pot->ulcSrcFolderTwins > 0)
            SET_FLAG(prnNew->dwFlags, RN_FL_FROM_FOLDER_TWIN);

         /* Determine RECNODE file stamp. */

         if (IsStubFlagSet(&(pot->stub), STUB_FL_FILE_STAMP_VALID))
         {
            prnNew->fsCurrent = pot->fsCurrent;

            TRACE_OUT((TEXT("AddObjectTwinRecNode(): Used cached file stamp for object twin %s\\%s."),
                       prnNew->pcszFolder,
                       prnNew->priParent->pcszName));
         }
         else
         {
            MyGetFileStampByHPATH(pot->hpath, prnNew->priParent->pcszName,
                                  &(prnNew->fsCurrent));

            TRACE_OUT((TEXT("AddObjectTwinRecNode(): Determined uncached file stamp for object twin %s\\%s."),
                       prnNew->pcszFolder,
                       prnNew->priParent->pcszName));
         }

         prnNew->rnstate = DetermineRecNodeState(prnNew);

         /* Tie the new RECNODE in to the parent RECITEM's list of RECNODEs. */

         prnNew->prnNext = pri->prnFirst;
         pri->prnFirst = prnNew;

         ASSERT(pri->ulcNodes < ULONG_MAX);
         pri->ulcNodes++;

         LockStub(&(pot->stub));

         tr = TR_SUCCESS;

         ASSERT(IS_VALID_STRUCT_PTR(prnNew, CRECNODE));

         TRACE_OUT((TEXT("AddObjectTwinRecNode(): Adding a RECNODE for object %s\\%s.  RECNODE state is %s."),
                    pszFolder,
                    pri->pcszName,
                    GetRECNODESTATEString(prnNew->rnstate)));
      }
      else
         FreeMemory(prnNew);
   }

   return(tr);
}


/*
** DoesTwinFamilyNeedRec()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL DoesTwinFamilyNeedRec(POBJECTTWIN pot, PVOID ptfri)
{
   BOOL bContinue = FALSE;
   TWINRESULT tr;
   PRECITEM priTemp;

   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(IS_VALID_WRITE_PTR((PTWINFAMILYRECINFO)ptfri, TWINFAMILYRECINFO));

   /*
    * Create a temporary RECITEM for this object twin's twin family to
    * determine whether or not the twin family requires reconciliation.
    */

   tr = CreateRecItem(pot->ptfParent, &priTemp);

   if (tr == TR_SUCCESS)
   {
      if (priTemp->riaction == RIA_NOTHING)
      {
         ((PTWINFAMILYRECINFO)ptfri)->bNeedsRec = FALSE;

         bContinue = TRUE;

         TRACE_OUT((TEXT("DoesTwinFamilyNeedRec(): Twin family for object %s is up-to-date."),
                    priTemp->pcszName));
      }
      else
      {
         ((PTWINFAMILYRECINFO)ptfri)->bNeedsRec = TRUE;

         TRACE_OUT((TEXT("DoesTwinFamilyNeedRec(): Twin family for object %s needs to be reconciled."),
                    priTemp->pcszName));
      }

      DestroyRecItem(priTemp);
   }

   ((PTWINFAMILYRECINFO)ptfri)->tr = tr;

   return(bContinue);
}


/*
** GetFolderPairStatus()
**
** Determines the status of a folder pair.
**
** Arguments:     pfp - pointer to folder pair whose status is to be
**                      determined
**                pfts - pointer to FOLDERTWINSTATUS to be filled in with
**                       reconciliation action that should be taken on the
**                       folder pair, *pfts is filled in with one of the
**                       following values:
**
**                         FTS_DO_NOTHING - no reconciliation required
**                         FTS_DO_SOMETHING - reconciliation required
**                         FTS_UNAVAILABLE - one or both of the folders is
**                                           unavailable
**
** Returns:       TWINRESULT
**
** Side Effects:  Expands intersecting folder twins to object twins.  This may
**                be S-L-O-W.
*/
PRIVATE_CODE TWINRESULT GetFolderPairStatus(PFOLDERPAIR pfp,
                                            CREATERECLISTPROC crlp,
                                            LPARAM lpCallbackData,
                                            PFOLDERTWINSTATUS pfts)
{
   TWINRESULT tr;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
   ASSERT(! crlp ||
          IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));
   ASSERT(IS_VALID_WRITE_PTR(pfts, UINT));

   if (IsPathVolumeAvailable(pfp->hpath))
   {
      tr = ExpandIntersectingFolderTwins(pfp, crlp, lpCallbackData);

      if (tr == TR_SUCCESS)
      {
         TWINFAMILYRECINFO tfri;

         /*
          * Walk the list of generated object twins for one half of this folder
          * pair.  Prepare a RECITEM for each object twin's twin family.
          * Continue until one of the RECITEMs requires reconciliation, or we
          * run out of object twins.
          *
          * Both of the lists of object twins in this folder pair should hit
          * exactly the same twin families.
          */

         /* Set defaults in case there are no generated object twins. */

         tfri.tr = TR_SUCCESS;
         tfri.bNeedsRec = FALSE;

         /*
          * EnumGeneratedObjectTwins() returns TRUE if enumeration finished
          * without being stopped by the callback function.
          */

         if (EnumGeneratedObjectTwins(pfp, &DoesTwinFamilyNeedRec, &tfri))
            ASSERT(tfri.tr == TR_SUCCESS && ! tfri.bNeedsRec);
         else
            ASSERT((tfri.tr != TR_SUCCESS) ||
                   (tfri.tr == TR_SUCCESS && tfri.bNeedsRec));

         tr = tfri.tr;

         if (tr == TR_SUCCESS)
         {
            if (tfri.bNeedsRec)
               *pfts = FTS_DO_SOMETHING;
            else
               *pfts = FTS_DO_NOTHING;
         }
      }
   }
   else
   {
      *pfts = FTS_UNAVAILABLE;
      tr = TR_SUCCESS;
   }

   ASSERT(tr != TR_SUCCESS ||
          IsValidFOLDERTWINSTATUS(*pfts));

   return(tr);
}


#ifdef DEBUG

/*
** IsValidCreateRecListProcMsg()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidCreateRecListProcMsg(UINT uMsg)
{
   BOOL bResult;

   switch (uMsg)
   {
      case CRLS_BEGIN_CREATE_REC_LIST:
      case CRLS_DELTA_CREATE_REC_LIST:
      case CRLS_END_CREATE_REC_LIST:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidCreateRecListProcMsg(): Invalid CreateRecListProc() message %u."),
                    uMsg));
         break;
   }

   return(bResult);
}


/*
** IsValidFOLDERTWINSTATUS()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidFOLDERTWINSTATUS(FOLDERTWINSTATUS fts)
{
   BOOL bResult;

   switch (fts)
   {
      case FTS_DO_NOTHING:
      case FTS_DO_SOMETHING:
      case FTS_UNAVAILABLE:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidFOLDERTWINSTATUS(): Invalid FOLDERTWINSTATUS %d."),
                    fts));
         break;
   }

   return(bResult);
}


/*
** IsValidPCRECNODESTATECOUNTER()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCRECNODESTATECOUNTER(PCRECNODESTATECOUNTER pcrnscntr)
{
   /* The fields may be any values. */

   return(IS_VALID_READ_PTR(pcrnscntr, CRECNODESTATECOUNTER));
}

#endif


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidRECNODESTATE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidRECNODESTATE(RECNODESTATE rnstate)
{
   BOOL bResult;

   switch (rnstate)
   {
      case RNS_NEVER_RECONCILED:
      case RNS_UNAVAILABLE:
      case RNS_DOES_NOT_EXIST:
      case RNS_DELETED:
      case RNS_NOT_RECONCILED:
      case RNS_UP_TO_DATE:
      case RNS_CHANGED:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidRECNODESTATE(): Invalid RECNODESTATE %d."),
                    rnstate));
         break;
   }

   return(bResult);
}


/*
** IsValidRECNODEACTION()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidRECNODEACTION(RECNODEACTION rnaction)
{
   BOOL bResult;

   switch (rnaction)
   {
      case RNA_NOTHING:
      case RNA_COPY_FROM_ME:
      case RNA_COPY_TO_ME:
      case RNA_MERGE_ME:
      case RNA_DELETE_ME:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidRECNODEACTION(): Invalid RECNODEACTION %d."),
                    rnaction));
         break;
   }

   return(bResult);
}


/*
** IsValidRECITEMACTION()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidRECITEMACTION(RECITEMACTION riaction)
{
   BOOL bResult;

   switch (riaction)
   {
      case RIA_NOTHING:
      case RIA_DELETE:
      case RIA_COPY:
      case RIA_MERGE:
      case RIA_BROKEN_MERGE:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidRECITEMACTION(): Invalid RECITEMACTION %d."),
                    riaction));
         break;
   }

   return(bResult);
}


/*
** IsValidPCRECLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCRECLIST(PCRECLIST pcrl)
{
   BOOL bResult = FALSE;

   if (IS_VALID_READ_PTR(pcrl, CRECLIST) &&
       IS_VALID_HANDLE(pcrl->hbr, BRFCASE))
   {
      PRECITEM pri;
      ULONG ulcRecItems = 0;

      for (pri = pcrl->priFirst;
           pri && IS_VALID_STRUCT_PTR(pri, CRECITEM);
           pri = pri->priNext)
      {
         ASSERT(ulcRecItems < ULONG_MAX);
         ulcRecItems++;
      }

      if (! pri && EVAL(ulcRecItems == pcrl->ulcItems))
         bResult = TRUE;
   }

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
** IsReconciledFileStamp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsReconciledFileStamp(PCFILESTAMP pcfs)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcfs, CFILESTAMP));

   return(pcfs->fscond != FS_COND_UNAVAILABLE);
}


/*
** LastKnownNonExistent()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL LastKnownNonExistent(PCFILESTAMP pcfsLast,
                                      PCFILESTAMP pcfsCurrent)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcfsLast, CFILESTAMP));
   ASSERT(IS_VALID_STRUCT_PTR(pcfsCurrent, CFILESTAMP));

   return(pcfsCurrent->fscond == FS_COND_DOES_NOT_EXIST ||
          (pcfsCurrent->fscond == FS_COND_UNAVAILABLE &&
           pcfsLast->fscond == FS_COND_DOES_NOT_EXIST));
}


/*
** DetermineDeletionPendingState()
**
**
**
** Arguments:
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void DetermineDeletionPendingState(PCRECITEM pcri)
{
   PCRECNODE pcrn;
   ULONG ulcDeleted = 0;
   ULONG ulcToDelete = 0;
   ULONG ulcChanged = 0;
   ULONG ulcJustDeleted = 0;
   ULONG ulcNeverReconciledTotal = 0;

   /*
    * Don't fully validate *pcri here since we may be called from
    * CreateRecItem() with an incomplete RECITEM.
    */

   ASSERT(IS_VALID_READ_PTR(pcri, CRECITEM));

   /* Count RECNODE states. */

   for (pcrn = pcri->prnFirst; pcrn; pcrn= pcrn->prnNext)
   {
      if (LastKnownNonExistent(&(pcrn->fsLast), &(pcrn->fsCurrent)))
      {
         ASSERT(ulcDeleted < ULONG_MAX);
         ulcDeleted++;

         TRACE_OUT((TEXT("DetermineDeletionPendingState(): %s\\%s last known non-existent."),
                    pcrn->pcszFolder,
                    pcri->pcszName));
      }
      else if (IsStubFlagClear(&(((PCOBJECTTWIN)(pcrn->hObjectTwin))->stub),
                               STUB_FL_KEEP))
      {
         ASSERT(ulcToDelete < ULONG_MAX);
         ulcToDelete++;

         TRACE_OUT((TEXT("DetermineDeletionPendingState(): %s\\%s not explicitly kept."),
                    pcrn->pcszFolder,
                    pcri->pcszName));
      }

      if (IsReconciledFileStamp(&(pcrn->fsLast)))
      {
         if (pcrn->fsCurrent.fscond == FS_COND_EXISTS &&
             MyCompareFileStamps(&(pcrn->fsLast), &(pcrn->fsCurrent)) != CR_EQUAL)
         {
            ASSERT(ulcChanged < ULONG_MAX);
            ulcChanged++;

            TRACE_OUT((TEXT("DetermineDeletionPendingState(): %s\\%s changed."),
                       pcrn->pcszFolder,
                       pcri->pcszName));
         }

         if (pcrn->fsLast.fscond == FS_COND_EXISTS &&
             pcrn->fsCurrent.fscond == FS_COND_DOES_NOT_EXIST)
         {
            ASSERT(ulcJustDeleted < ULONG_MAX);
            ulcJustDeleted++;

            TRACE_OUT((TEXT("DetermineDeletionPendingState(): %s\\%s just deleted."),
                       pcrn->pcszFolder,
                       pcri->pcszName));
         }
      }
      else
      {
         ASSERT(ulcNeverReconciledTotal < ULONG_MAX);
         ulcNeverReconciledTotal++;

         TRACE_OUT((TEXT("DetermineDeletionPendingState(): %s\\%s never reconciled."),
                    pcrn->pcszFolder,
                    pcri->pcszName));
      }
   }

   /*
    * Take twin family out of the deletion pending state if any object twin
    * has changed, or if no object twins are awaiting deletion (i.e., all
    * object twins are deleted or kept).
    *
    * Take twin family in to the deletion pending state if any object twin has
    * just been deleted.
    */

   if (ulcNeverReconciledTotal > 0 ||
       ulcChanged > 0 ||
       ! ulcDeleted ||
       ! ulcToDelete)
   {
      UnmarkTwinFamilyDeletionPending((PTWINFAMILY)(pcri->hTwinFamily));

      if (ulcJustDeleted > 0)
         TRACE_OUT((TEXT("DetermineDeletionPendingState(): One or more object twins of %s deleted, but deletion not pending (%lu never reconciled, %lu changed, %lu deleted, %lu to delete, %lu just deleted)."),
                    pcri->pcszName,
                    ulcNeverReconciledTotal,
                    ulcChanged,
                    ulcDeleted,
                    ulcToDelete,
                    ulcJustDeleted));
   }
   else if (ulcJustDeleted > 0)
      MarkTwinFamilyDeletionPending((PTWINFAMILY)(pcri->hTwinFamily));

   return;
}


/*
** DeleteTwinsFromRecItem()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  May implicitly delete object twins, twin families, and pairs
**                of folder twins.
*/
PUBLIC_CODE BOOL DeleteTwinsFromRecItem(PCRECITEM pcri)
{
   BOOL bObjectTwinsDeleted;
   BOOL bCheckFolderTwins;
   BOOL bFolderTwinsDeleted;
   HPTRARRAY hpaFolderPairs;

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

   /*
    * DetermineDeletionPendingState() has already been performed by
    * MyReconcileItem() for the twin family of this RECITEM.
    */

   hpaFolderPairs = GetBriefcaseFolderPairPtrArray(((PCTWINFAMILY)(pcri->hTwinFamily))->hbr);

   ClearFlagInArrayOfStubs(hpaFolderPairs, STUB_FL_USED);

   bObjectTwinsDeleted = DeleteDeletedObjectTwins(pcri, &bCheckFolderTwins);

   if (bObjectTwinsDeleted)
      TRACE_OUT((TEXT("DeleteTwinsFromRecItem(): One or more object twins implicitly deleted from twin family for %s."),
                 pcri->pcszName));

   if (bCheckFolderTwins)
   {
      TRACE_OUT((TEXT("DeleteTwinsFromRecItem(): Checking for folder twins to implicitly delete.")));

      bFolderTwinsDeleted = DeleteDeletedFolderTwins(hpaFolderPairs);

      if (bFolderTwinsDeleted)
         TRACE_OUT((TEXT("DeleteTwinsFromRecItem(): One or more pairs of folder twins implicitly deleted.")));
   }
   else
      bFolderTwinsDeleted = FALSE;

   return(bObjectTwinsDeleted || bFolderTwinsDeleted);
}


/*
** DeleteTwinsFromRecList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  May implicitly delete object twins, twin families, and pairs
**                of folder twins.
*/
PUBLIC_CODE BOOL DeleteTwinsFromRecList(PCRECLIST pcrl)
{
   PCRECITEM pcri;
   BOOL bObjectTwinsDeleted = FALSE;
   BOOL bCheckFolderTwins = FALSE;
   BOOL bFolderTwinsDeleted;
   HPTRARRAY hpaFolderPairs;

   ASSERT(IS_VALID_STRUCT_PTR(pcrl, CRECLIST));

   /*
    * DetermineDeletionPendingState() has already been performed by
    * CreateRecItem() for the twin family of each RECITEM in the RECLIST.
    */

   hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pcrl->hbr);

   ClearFlagInArrayOfStubs(hpaFolderPairs, STUB_FL_USED);

   for (pcri = pcrl->priFirst; pcri; pcri = pcri->priNext)
   {
      BOOL bLocalCheckFolderTwins;

      if (DeleteDeletedObjectTwins(pcri, &bLocalCheckFolderTwins))
      {
         TRACE_OUT((TEXT("DeleteTwinsFromRecList(): One or more object twins implicitly deleted from twin family for %s."),
                    pcri->pcszName));

         bObjectTwinsDeleted = TRUE;
      }

      if (bLocalCheckFolderTwins)
         bCheckFolderTwins = TRUE;
   }

   if (bCheckFolderTwins)
   {
      TRACE_OUT((TEXT("DeleteTwinsFromRecList(): Checking for folder twins to implicitly delete.")));

      bFolderTwinsDeleted = DeleteDeletedFolderTwins(hpaFolderPairs);

      if (bFolderTwinsDeleted)
         TRACE_OUT((TEXT("DeleteTwinsFromRecItem(): One or more pairs of folder twins implicitly deleted.")));
   }
   else
      bFolderTwinsDeleted = FALSE;

   return(bObjectTwinsDeleted || bFolderTwinsDeleted);
}


/*
** FindCopySource()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT FindCopySource(PCRECITEM pcri, PRECNODE *pprnCopySrc)
{
   TWINRESULT tr = TR_INVALID_PARAMETER;
   PRECNODE prn;

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
   ASSERT(IS_VALID_WRITE_PTR(pprnCopySrc, PRECNODE));

   ASSERT(pcri->riaction == RIA_COPY);

   for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
   {
      if (prn->rnaction == RNA_COPY_FROM_ME)
      {
         *pprnCopySrc = prn;
         tr = TR_SUCCESS;
         break;
      }
   }

   ASSERT(tr != TR_SUCCESS ||
          (*pprnCopySrc)->rnaction == RNA_COPY_FROM_ME);

   return(tr);
}


/*
** ChooseMergeDestination()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ChooseMergeDestination(PCRECITEM pcri,
                                        PRECNODE *pprnMergeDest)
{
   PRECNODE prn;

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
   ASSERT(IS_VALID_WRITE_PTR(pprnMergeDest, PRECNODE));

   ASSERT(pcri->riaction == RIA_MERGE);

   for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
   {
      if (prn->rnaction == RNA_MERGE_ME)
      {
         *pprnMergeDest = prn;
         break;
      }
   }

   ASSERT(IS_VALID_STRUCT_PTR(*pprnMergeDest, CRECNODE));
   ASSERT((*pprnMergeDest)->rnaction == RNA_MERGE_ME);

   return;
}


/*
** ClearFlagInArrayOfStubs()
**
** Clears flags in all the stubs pointed to by an array of pointers to stubs.
**
** Arguments:     hpa - handle to array of pointers to stubs
**                dwClearFlags - flags to be cleared
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void ClearFlagInArrayOfStubs(HPTRARRAY hpa, DWORD dwClearFlags)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(FLAGS_ARE_VALID(dwClearFlags, ALL_STUB_FLAGS));

   aicPtrs = GetPtrCount(hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      ClearStubFlag(GetPtr(hpa, ai), dwClearFlags);

   return;
}


/*
** NotifyCreateRecListStatus()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL NotifyCreateRecListStatus(CREATERECLISTPROC crlp, UINT uMsg,
                                           LPARAM lp, LPARAM lpCallbackData)
{
   BOOL bContinue;

   /* lpCallbackData may be any value. */

   ASSERT(! crlp ||
          IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));
   ASSERT(IsValidCreateRecListProcMsg(uMsg));
   ASSERT(! lp);

   if (crlp)
   {
      TRACE_OUT((TEXT("NotifyReconciliationStatus(): Calling CREATERECLISTPROC with message %s, LPARAM %#lx, callback data %#lx."),
                 GetCREATERECLISTPROCMSGString(uMsg),
                 lp,
                 lpCallbackData));

      bContinue = (*crlp)(uMsg, lp, lpCallbackData);
   }
   else
   {
      TRACE_OUT((TEXT("NotifyReconciliationStatus(): Not calling NULL CREATERECLISTPROC with message %s, LPARAM %#lx, callback data %#lx."),
                 GetCREATERECLISTPROCMSGString(uMsg),
                 lp,
                 lpCallbackData));

      bContinue = TRUE;
   }

   if (! bContinue)
      WARNING_OUT((TEXT("NotifyCreateRecListStatus(): Client callback aborted RecList creation.")));

   return(bContinue);
}


/*
** CompareInts()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT CompareInts(int nFirst, int nSecond)
{
   COMPARISONRESULT cr;

   /* nFirst and nSecond may be any value. */

   if (nFirst < nSecond)
      cr = CR_FIRST_SMALLER;
   else if (nFirst > nSecond)
      cr = CR_FIRST_LARGER;
   else
      cr = CR_EQUAL;

   return(cr);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidFILESTAMPCONDITION()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidFILESTAMPCONDITION(FILESTAMPCONDITION fsc)
{
   BOOL bResult;

   switch (fsc)
   {
      case FS_COND_EXISTS:
      case FS_COND_DOES_NOT_EXIST:
      case FS_COND_UNAVAILABLE:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidFILESTAMPCONDITION(): Unknown FILESTAMPCONDITION %d."),
                    fsc));
         break;
   }

   return(bResult);
}


/*
** IsValidPCFILESTAMP()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCFILESTAMP(PCFILESTAMP pcfs)
{
   /* dwcbLowLength may be any value. */

   return(IS_VALID_READ_PTR(pcfs, CFILESTAMP) &&
          EVAL(IsValidFILESTAMPCONDITION(pcfs->fscond)) &&
          IS_VALID_STRUCT_PTR(&(pcfs->ftMod), CFILETIME) &&
          IS_VALID_STRUCT_PTR(&(pcfs->ftModLocal), CFILETIME) &&
          ! pcfs->dwcbHighLength);
}


/*
** IsFolderObjectTwinFileStamp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsFolderObjectTwinFileStamp(PCFILESTAMP pcfs)
{
   return(EVAL(! pcfs->ftMod.dwLowDateTime) &&
          EVAL(! pcfs->ftMod.dwHighDateTime) &&
          EVAL(! pcfs->dwcbLowLength) &&
          EVAL(! pcfs->dwcbHighLength));
}


/*
** IsValidPCRECNODE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCRECNODE(PCRECNODE pcrn)
{
   return(IS_VALID_READ_PTR(pcrn, CRECNODE) &&
          IS_VALID_HANDLE(pcrn->hvid, VOLUMEID) &&
          IS_VALID_STRING_PTR(pcrn->pcszFolder, CSTR) &&
          IS_VALID_HANDLE(pcrn->hObjectTwin, OBJECTTWIN) &&
          IS_VALID_STRUCT_PTR(&(pcrn->fsLast), CFILESTAMP) &&
          IS_VALID_STRUCT_PTR(&(pcrn->fsCurrent), CFILESTAMP) &&
          FLAGS_ARE_VALID(pcrn->dwFlags, ALL_RECNODE_FLAGS) &&
          EVAL(IsValidRECNODESTATE(pcrn->rnstate)) &&
          EVAL(IsValidRECNODEACTION(pcrn->rnaction)) &&
          EVAL(*(pcrn->priParent->pcszName) ||
               (IsFolderObjectTwinFileStamp(&(pcrn->fsLast)) &&
                IsFolderObjectTwinFileStamp(&(pcrn->fsCurrent)))) &&
          EVAL(IsReconciledFileStamp(&(pcrn->fsCurrent)) ||
               MyCompareFileStamps(&(pcrn->fsLast), &(((PCOBJECTTWIN)(pcrn->hObjectTwin))->fsLastRec)) == CR_EQUAL));
}


/*
** IsValidPCRECITEM()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCRECITEM(PCRECITEM pcri)
{
   BOOL bResult = FALSE;

   /* Does the twin family associated with this RECITEM still exist? */

   if (IS_VALID_READ_PTR(pcri, CRECITEM) &&
       IS_VALID_STRING_PTR(pcri->pcszName, CSTR) &&
       IS_VALID_HANDLE(pcri->hTwinFamily, TWINFAMILY))
   {
      if (IsStubFlagSet(&(((PTWINFAMILY)(pcri->hTwinFamily))->stub),
                        STUB_FL_UNLINKED))
         bResult = TRUE;
      else
      {
         ULONG ulcRecNodes = 0;
         PRECNODE prn;

         /*
          * Yes.  Verify the parent pointers, node count, and flags in this
          * RECITEM.
          */

         /* All unavailable RECNODEs should contain action RNA_NOTHING. */

         for (prn = pcri->prnFirst;
              prn && IS_VALID_STRUCT_PTR(prn, CRECNODE);
              prn = prn->prnNext)
         {
            /* Does the object twin associated with this RECNODE still exist? */

            if (IsStubFlagClear(&(((PTWINFAMILY)(pcri->hTwinFamily))->stub),
                                STUB_FL_UNLINKED))
            {
               /* Yes.  Verify its parent RECITEM pointer. */

               if (prn->priParent != pcri)
               {
                  ERROR_OUT((TEXT("IsValidPCRECITEM(): Bad parent pointer found in RECNODE - parent pointer (%#lx), actual parent (%#lx)."),
                             prn->priParent,
                             pcri));

                  break;
               }
            }

            ASSERT(ulcRecNodes < ULONG_MAX);
            ulcRecNodes++;
         }

         if (! prn)
         {
            /* Check RECNODE count. */

            if (ulcRecNodes == pcri->ulcNodes)
            {
               if (ulcRecNodes >= 2)
               {
                  /* Now verify the RECITEM's actions. */

                  switch (pcri->riaction)
                  {
                     case RIA_NOTHING:

                        /* All RECNODEs should contain action RNA_NOTHING. */

                        for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
                        {
                           if (prn->rnaction != RNA_NOTHING)
                           {
                              ERROR_OUT((TEXT("IsValidPCRECITEM(): Nop RECITEM with non-nop RECNODE action %d."),
                                         prn->rnaction));
                              break;
                           }
                        }

                        if (! prn)
                           bResult = TRUE;

                        break;

                     case RIA_COPY:
                     {
                        PRECNODE prnSrc = NULL;
                        ULONG ulcCopyDests = 0;

                        /*
                         * There should only be one available RECNODE
                         * containing action RNA_COPY_FROM_ME.
                         *
                         * The other available RECNODEs should contain action
                         * RNA_COPY_TO_ME or RNA_NOTHING.
                         */

                        for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
                        {
                           if (RECNODE_IS_AVAILABLE(prn))
                           {
                              switch (prn->rnaction)
                              {
                                 case RNA_COPY_TO_ME:
                                    ASSERT(ulcCopyDests < ULONG_MAX);
                                    ulcCopyDests++;
                                    break;

                                 case RNA_NOTHING:
                                    break;

                                 case RNA_COPY_FROM_ME:
                                    if (! prnSrc)
                                       prnSrc = prn;
                                    else
                                       ERROR_OUT((TEXT("IsValidPCRECITEM(): Copy RECITEM with multiple source file RECNODEs.")));
                                    break;

                                 case RNA_MERGE_ME:
                                    ERROR_OUT((TEXT("IsValidPCRECITEM(): Copy RECITEM with merge RECNODE.")));
                                    break;

                                 default:
                                    ERROR_OUT((TEXT("IsValidPCRECITEM(): Copy RECITEM with unknown RECNODE action %d."),
                                               prn->rnaction));
                                    break;
                              }
                           }
                        }

                        if (! prn)
                        {
                           /* Did we find a copy source? */

                           if (prnSrc)
                           {
                              /* Yes. */

                              /* Did we find one or more copy destinations? */

                              if (ulcCopyDests > 0)
                                 /* Yes. */
                                 bResult = TRUE;
                              else
                                 /* No. */
                                 ERROR_OUT((TEXT("IsValidPCRECITEM(): Copy RECITEM with no copy destination RECNODEs.")));
                           }
                           else
                              /* No. */
                              ERROR_OUT((TEXT("IsValidPCRECITEM(): Copy RECITEM with no copy source RECNODE.")));
                        }

                        break;
                     }

                     case RIA_MERGE:
                     case RIA_BROKEN_MERGE:
                     {
                        PRECNODE prn;
                        ULONG ulcMergeBuddies = 0;
#ifdef DEBUG
                        LPCTSTR pcszAction = (pcri->riaction == RIA_MERGE) ?
                                           TEXT("merge") :
                                           TEXT("broken merge");
#endif

                        /*
                         * There should be multiple available RECNODEs
                         * containing action RNA_MERGE_ME.
                         *
                         * The other available RECNODEs should contain action
                         * RNA_COPY_TO_ME.
                         */

                        for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
                        {
                           if (RECNODE_IS_AVAILABLE(prn))
                           {
                              switch (prn->rnaction)
                              {
                                 case RNA_COPY_TO_ME:
                                    break;

                                 case RNA_NOTHING:
                                    ERROR_OUT((TEXT("IsValidPCRECITEM(): %s RECITEM with RNA_NOTHING RECNODE."),
                                               pcszAction));
                                    break;

                                 case RNA_COPY_FROM_ME:
                                    ERROR_OUT((TEXT("IsValidPCRECITEM(): %s RECITEM with RNA_COPY_FROM_ME RECNODE."),
                                               pcszAction));
                                    break;

                                 case RNA_MERGE_ME:
                                    ASSERT(ulcMergeBuddies < ULONG_MAX);
                                    ulcMergeBuddies++;
                                    break;

                                 default:
                                    ERROR_OUT((TEXT("IsValidPCRECITEM(): %s RECITEM with unknown RECNODE action %d."),
                                               pcszAction,
                                               prn->rnaction));
                                    break;
                              }
                           }
                        }

                        if (! prn)
                        {
                           /* Are there multiple merge source RECNODEs? */

                           if (ulcMergeBuddies > 1)
                              bResult = TRUE;
                           else
                              ERROR_OUT((TEXT("IsValidPCRECITEM(): %s RECITEM with too few (%lu) merge source RECNODEs."),
                                         pcszAction,
                                         ulcMergeBuddies));
                        }

                        break;
                     }

                     case RIA_DELETE:
                     {
                        BOOL bDelete = FALSE;

                        /*
                         * There should be at least one available RECNODE
                         * marked RNA_DELETE_ME.  All other RECNODEs should be
                         * marked RNA_NOTHING.
                         */

                        for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
                        {
                           if (RECNODE_IS_AVAILABLE(prn) &&
                               prn->rnaction == RNA_DELETE_ME)
                              bDelete = TRUE;
                           else if (prn->rnaction != RNA_NOTHING)
                              ERROR_OUT((TEXT("IsValidPCRECITEM(): Delete RECITEM with RECNODE marked %s."),
                                         GetRECNODEACTIONString(prn->rnaction)));
                        }

                        if (bDelete)
                           bResult = TRUE;
                        else
                           ERROR_OUT((TEXT("IsValidPCRECITEM(): Delete RECITEM with no RECNODEs marked RNA_DELETE_ME.")));

                        break;
                     }

                     default:
                        ERROR_OUT((TEXT("IsValidPCRECITEM(): Unrecognized RECITEMACTION %d."),
                                   pcri->riaction));
                        break;
                  }
               }
               else
                  ERROR_OUT((TEXT("IsValidPCRECITEM(): RECITEM only has %lu RECNODEs."),
                             ulcRecNodes));
            }
            else
               ERROR_OUT((TEXT("IsValidPCRECITEM(): RECITEM has bad RECNODE count.  (%lu actual RECNODEs for RECITEM claiming %lu RECNODEs.)"),
                          ulcRecNodes,
                          pcri->ulcNodes));
         }
      }
   }

   return(bResult);
}

#endif


/***************************** Exported Functions ****************************/

/* RAIDRAID: (16203) AutoDoc CREATERECLISTPROC messages below. */

/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | CreateRecList | Creates a reconciliation list for all twins
or for marked twins.

@parm HTWINLIST | htl | A handle to the twin list that the reconciliation list
is to be created from.  All twins in the twin list generate RECITEMs in the
reconciliation list.

@parm CREATERECLISTPROC | crlp | A procedure instance address of a callback
function to be called with status information during the creation of the
RECLIST.  crlp may be NULL to indicate that no RECLIST creation status callback
function is to be called.

@parm LPARAM | lpCallbackData | Callback data to be supplied to the RECLIST
creation status callback function.  If crlp is NULL, lpCallbackData is ignored.

@parm PRECLIST * | pprl | A pointer to a RECLIST to be filled in with a
pointer to the new reconciliation list.  *pprl is only valid if TR_SUCCESS is
returned.

@rdesc If the reconciliation list was created successfully, TR_SUCCESS is
returned.  Otherwise, the reconciliation list was not created successfully, and
the return value indicates the error that occurred.

@xref DestroyRecList MarkTwin

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI CreateRecList(HTWINLIST htl,
                                           CREATERECLISTPROC crlp,
                                           LPARAM lpCallbackData,
                                           PRECLIST *pprl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(CreateRecList);

#ifdef EXPV
      /* Verify parameters. */

      /* lpCallbackData may be any value. */

      if (IS_VALID_HANDLE(htl, TWINLIST) &&
          (! crlp ||
           IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC)) &&
          IS_VALID_WRITE_PTR(pprl, PRECLIST))
#endif
      {
         if (NotifyCreateRecListStatus(crlp, CRLS_BEGIN_CREATE_REC_LIST, 0,
                                       lpCallbackData))
         {
            HBRFCASE hbr;

            /* Expand the required folder twins to object twins. */

            hbr = GetTwinListBriefcase(htl);

            InvalidatePathListInfo(GetBriefcasePathList(hbr));

            tr = ExpandFolderTwinsIntersectingTwinList(htl, crlp,
                                                       lpCallbackData);

            if (tr == TR_SUCCESS)
            {
               PRECLIST prlNew;

               /* Try to create a new reconciliation list. */

               if (AllocateMemory(sizeof(*prlNew), &prlNew))
               {
                  /* Initialize RECLIST structure fields. */

                  prlNew->ulcItems = 0;
                  prlNew->priFirst = NULL;
                  prlNew->hbr = hbr;

                  tr = AddRecItemsToRecList(htl, crlp, lpCallbackData, prlNew);

                  if (tr == TR_SUCCESS)
                  {
                     if (DeleteTwinsFromRecList(prlNew))
                     {
                        TRACE_OUT((TEXT("CreateRecList(): Twins implicitly deleted.  Recalculating RECLIST.")));

                        DestroyListOfRecItems(prlNew->priFirst);

                        prlNew->ulcItems = 0;
                        prlNew->priFirst = NULL;
                        ASSERT(prlNew->hbr == hbr);

                        tr = AddRecItemsToRecList(htl, crlp, lpCallbackData,
                                                  prlNew);
                     }
                  }

                  if (tr == TR_SUCCESS)
                  {
                     *pprl = prlNew;

                     /* Don't allow abort. */

                     NotifyCreateRecListStatus(crlp, CRLS_END_CREATE_REC_LIST,
                                               0, lpCallbackData);

                     ASSERT(IS_VALID_STRUCT_PTR(*pprl, CRECLIST));
                  }
                  else
                     /*
                      * Destroy RECLIST and any RECITEMs that have been created
                      * so far.
                      */
                     MyDestroyRecList(prlNew);
               }
            }
         }
         else
            tr = TR_ABORT;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(CreateRecList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | DestroyRecList | Destroys a reconciliation list created by
CreateRecList().

@parm PRECLIST | prl | A pointer to the reconciliation list to be destroyed.
The RECLIST pointed by pRecList is not valid after DestroyRecList() is called.

@rdesc If the specified reconciliation list was freed successfully, TR_SUCCESS
is returned.  Otherwise, the specified reconciliation list was not freed
successfully, and the return value indicates the error that occurred.

@xref CreateRecList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI DestroyRecList(PRECLIST prl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(DestroyRecList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_STRUCT_PTR(prl, CRECLIST))
#endif
      {
         MyDestroyRecList(prl);

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(DestroyRecList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | GetFolderTwinStatus | Determines the reconciliation status of
a folder twin.

@parm HFOLDERTWIN | hFolderTwin | A handle to the folder twin whose
reconciliation status is to be determined.

@parm CREATERECLISTPROC | crlp | A procedure instance address of a callback
function to be called with status information during the creation of the
RECLIST.  crlp may be NULL to indicate that no RECLIST creation status callback
function is to be called.

@parm LPARAM | lpCallbackData | Callback data to be supplied to the RECLIST
creation status callback function.  If crlp is NULL, lpCallbackData is ignored.

@parm PFOLDERTWINSTATUS | pfts | A pointer to a UINT to be filled in with the
reconciliation status of the folder twin.  *pfts is only valid if TR_SUCCESS is
returned.  *pfts may be one of the following values:

@flag FTS_DO_NOTHING | This folder twin is up-to-date.  No reconciliation
action needs to be taken on it.  N.b., the folder may still contain object
twins that were not generated by the folder twin that are out-of-date.

@flag FTS_DO_SOMETHING | This folder twin is out-of-date.  Some reconciliation
action needs to be taken on it.

@flag FTS_UNAVAILABLE | This folder twin is unavailable for reconciliation.

@rdesc If the reconcilation status of the folder twin was determined
successfully, *pfts is filled in with the status of the folder twin, and
TR_SUCCESS is returned.  Otherwise, the reconciliation status of the folder
twin was not determined successfully, *pfts is undefined, and the return
value indicates the error that occurred.

@comm If GetFolderTwinStatus() is called with a valid handle to a folder twin
that has been deleted, TR_DELETED_TWIN will be returned.  N.b., in general,
calling GetFolderTwinStatus() for a folder twin will not be any slower than
calling CreateRecList() for that folder twin, and may be significantly faster
if the folder twin requires reconciliation.

@xref AddFolderTwin CreateFolderTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI GetFolderTwinStatus(HFOLDERTWIN hFolderTwin,
                                                 CREATERECLISTPROC crlp,
                                                 LPARAM lpCallbackData,
                                                 PFOLDERTWINSTATUS pfts)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(GetFolderTwinStatus);

#ifdef EXPV
      /* Verify parameters. */

      /* lpCallbackData may be any value. */

      if (IS_VALID_HANDLE(hFolderTwin, FOLDERTWIN) &&
          EVAL(! crlp ||
               IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC)) &&
          IS_VALID_WRITE_PTR(pfts, FOLDERTWINSTATUS))
#endif
      {
         /* Has this folder twin already been deleted? */

         if (IsStubFlagClear(&(((PFOLDERPAIR)hFolderTwin)->stub),
                             STUB_FL_UNLINKED))
         {
            if (NotifyCreateRecListStatus(crlp, CRLS_BEGIN_CREATE_REC_LIST, 0,
                                          lpCallbackData))
            {
               /* No. Determine its status. */

               InvalidatePathListInfo(
                  GetBriefcasePathList(((PCFOLDERPAIR)hFolderTwin)->pfpd->hbr));

               tr = GetFolderPairStatus((PFOLDERPAIR)hFolderTwin, crlp,
                                        lpCallbackData, pfts);

               if (tr == TR_SUCCESS)
               {
                  /* Don't allow abort. */

                  NotifyCreateRecListStatus(crlp, CRLS_END_CREATE_REC_LIST, 0,
                                            lpCallbackData);

                  if (IsStubFlagSet(&(((PFOLDERPAIR)hFolderTwin)->stub),
                                    STUB_FL_UNLINKED))
                  {
                     WARNING_OUT((TEXT("GetFolderTwinStatus(): Folder twin deleted during status determination.")));

                     tr = TR_DELETED_TWIN;
                  }

#ifdef DEBUG

                  {
                     LPCTSTR pcszStatus;

                     switch (*pfts)
                     {
                        case FTS_DO_NOTHING:
                           pcszStatus = TEXT("FTS_DO_NOTHING");
                           break;

                        case FTS_DO_SOMETHING:
                           pcszStatus = TEXT("FTS_DO_SOMETHING");
                           break;

                        default:
                           ASSERT(*pfts == FTS_UNAVAILABLE);
                           pcszStatus = TEXT("FTS_UNAVAILABLE");
                           break;
                     }

                     TRACE_OUT((TEXT("GetFolderTwinStatus(): Status of folder %s is %s."),
                                DebugGetPathString(((PFOLDERPAIR)hFolderTwin)->hpath),
                                pcszStatus));
                  }

#endif

               }
            }
            else
               tr = TR_ABORT;
         }
         else
         {
            /* Yes.  Bail. */

            WARNING_OUT((TEXT("GetFolderTwinStatus(): Called on deleted folder twin.")));

            tr = TR_DELETED_TWIN;
         }
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      ASSERT(tr != TR_SUCCESS ||
             IsValidFOLDERTWINSTATUS(*pfts));

      DebugExitTWINRESULT(GetFolderTwinStatus, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\reclist.h ===
/*
 * reclist.h - Reconciliation list ADT description.
 */


/* Macros
 *********/

#define RECNODE_EXISTS(prn)           ((prn)->fsCurrent.fscond == FS_COND_EXISTS)
#define RECNODE_DOES_NOT_EXIST(prn)   ((prn)->fsCurrent.fscond == FS_COND_DOES_NOT_EXIST)
#define RECNODE_IS_AVAILABLE(prn)     (RECNODE_EXISTS(prn) || RECNODE_DOES_NOT_EXIST(prn))
#define RECNODE_WAS_RECONCILED(prn)   (RECNODE_EXISTS(prn) && prn->rnaction != RNA_NOTHING)


/* Prototypes
 *************/

/* reclist.c */

extern BOOL IsReconciledFileStamp(PCFILESTAMP);
extern BOOL LastKnownNonExistent(PCFILESTAMP, PCFILESTAMP);
extern void DetermineDeletionPendingState(PCRECITEM);
extern BOOL DeleteTwinsFromRecItem(PCRECITEM);
extern BOOL DeleteTwinsFromRecList(PCRECLIST);
extern TWINRESULT FindCopySource(PCRECITEM, PRECNODE *);
extern void ChooseMergeDestination(PCRECITEM, PRECNODE *);
extern void ClearFlagInArrayOfStubs(HPTRARRAY, DWORD);
extern BOOL NotifyCreateRecListStatus(CREATERECLISTPROC, UINT, LPARAM, LPARAM);
extern COMPARISONRESULT CompareInts(int, int);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidFILESTAMPCONDITION(FILESTAMPCONDITION);
extern BOOL IsValidPCFILESTAMP(PCFILESTAMP);
extern BOOL IsFolderObjectTwinFileStamp(PCFILESTAMP);
extern BOOL IsValidPCRECNODE(PCRECNODE);
extern BOOL IsValidPCRECITEM(PCRECITEM);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\recon.h ===
/*
 * recon.h - Reconciliation routines description.
 */


/* Prototypes
 *************/

/* recon.c */

extern void CopyFileStampFromFindData(PCWIN32_FIND_DATA, PFILESTAMP);
extern void MyGetFileStamp(LPCTSTR, PFILESTAMP);
extern void MyGetFileStampByHPATH(HPATH, LPCTSTR, PFILESTAMP);
extern COMPARISONRESULT MyCompareFileStamps(PCFILESTAMP, PCFILESTAMP);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\recon.c ===
/*
 * recon.c - Reconciliation routines.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "oleutil.h"


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE void GenerateShellEvents(PCRECITEM);
PRIVATE_CODE TWINRESULT MyReconcileItem(PCRECITEM, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
PRIVATE_CODE void UpdateObjectTwinStates(PCRECITEM);
PRIVATE_CODE TWINRESULT CopyFolder(PCRECITEM, RECSTATUSPROC, LPARAM);
PRIVATE_CODE TWINRESULT DeleteFolder(PCRECITEM, RECSTATUSPROC, LPARAM);
PRIVATE_CODE TWINRESULT DealWithCopy(PCRECITEM, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
PRIVATE_CODE TWINRESULT DealWithMerge(PCRECITEM, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
PRIVATE_CODE TWINRESULT DealWithDelete(PCRECITEM, RECSTATUSPROC, LPARAM);
PRIVATE_CODE ULONG CountRECNODEs(PCRECITEM, RECNODEACTION);
PRIVATE_CODE TWINRESULT UpdateRecNodeFileStamps(PCRECITEM);
PRIVATE_CODE BOOL DeletedTwinsInRecItem(PCRECITEM);


/*
** GenerateShellEvents()
**
** Notifies the Shell about reconciliation events for a RECITEM.
**
** Arguments:     pcri - reconciled RECITEM to notify Shell about
**
** Returns:       void
**
** Side Effects:  None
*/
PRIVATE_CODE void GenerateShellEvents(PCRECITEM pcri)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

   /* Any reconciliation events to report? */

   if (pcri->riaction == RIA_NOTHING ||
       pcri->riaction == RIA_COPY ||
       pcri->riaction == RIA_MERGE ||
       pcri->riaction == RIA_DELETE)
   {
      PRECNODE prn;

      /*
       * Yes.  Send an appropriate notification to the Shell about the file
       * operations assumed carried out during reconciliation.  The file system
       * is poor, and does not support notifications for some of the
       * interesting reconciliation operations.  We also generate a specious
       * update notification for the source file in a copy operation to cause
       * the Briefcase ui to recalculate the status string for that file, even
       * though the file itself has not changed.
       */

      for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
      {
         BOOL bNotify;
         NOTIFYSHELLEVENT nse;
         LPCTSTR pcszPath;
         TCHAR rgchPath[MAX_PATH_LEN];

         /* How shall I notify you?  Let me enumerate the ways. */

         bNotify = TRUE;

         if (IsFolderObjectTwinName(pcri->pcszName))
         {
            nse = NSE_UPDATE_FOLDER;

            pcszPath = prn->pcszFolder;

            switch (prn->rnaction)
            {
               /*
                * Notifications about folders that were copied or deleted
                * during reconciliation were sent during reconciliation.  Don't
                * send redundant notifications.
                */
               case RNA_COPY_TO_ME:
               case RNA_DELETE_ME:
                  bNotify = FALSE;
                  break;

               default:
                  ASSERT(prn->rnaction == RNA_NOTHING ||
                         prn->rnaction == RNA_COPY_FROM_ME);
                  break;
            }
         }
         else
         {
            nse = NSE_UPDATE_ITEM;

            ComposePath(rgchPath, prn->pcszFolder, pcri->pcszName);
            pcszPath = rgchPath;

            switch (prn->rnaction)
            {
               case RNA_COPY_TO_ME:
                  if (prn->rnstate == RNS_DOES_NOT_EXIST ||
                      prn->rnstate == RNS_DELETED)
                     nse = NSE_CREATE_ITEM;
                  break;

               case RNA_DELETE_ME:
                  nse = NSE_DELETE_ITEM;
                  break;

               default:
                  ASSERT(prn->rnaction == RNA_NOTHING ||
                         prn->rnaction == RNA_COPY_FROM_ME ||
                         prn->rnaction == RNA_MERGE_ME);
                  break;
            }
         }

         if (bNotify)
            NotifyShell(pcszPath, nse);
      }
   }
}


/*
** MyReconcileItem()
**
** Reconciles a reconciliation item.
**
** Arguments:     pcri - pointer to reconciliation item to be reconciled
**
** Side Effects:
*/
PRIVATE_CODE TWINRESULT MyReconcileItem(PCRECITEM pcri, RECSTATUSPROC rsp,
                                        LPARAM lpCallbackData, DWORD dwFlags,
                                        HWND hwndOwner,
                                        HWND hwndProgressFeedback)
{
   TWINRESULT tr;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_RI_FLAGS));
   ASSERT(IS_FLAG_CLEAR(dwFlags, RI_FL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_FLAG_CLEAR(dwFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
          IS_VALID_HANDLE(hwndProgressFeedback, WND));

#ifdef DEBUG

   {
      LPCTSTR pcszGerund;

      switch (pcri->riaction)
      {
         case RIA_NOTHING:
            pcszGerund = TEXT("Taking no action on");
            break;

         case RIA_COPY:
            pcszGerund = TEXT("Copying");
            break;

         case RIA_MERGE:
            pcszGerund = TEXT("Merging");
            break;

         case RIA_BROKEN_MERGE:
            pcszGerund = TEXT("Broken merge for");
            break;

         case RIA_DELETE:
            pcszGerund = TEXT("Deleting");
            break;

         default:
            pcszGerund = TEXT("Unknown action specifed for");
            break;
      }

      TRACE_OUT((TEXT("MyReconcileItem(): %s %s."),
                 pcszGerund,
                 *(pcri->pcszName) ? pcri->pcszName : TEXT("folder")));
   }

#endif

   switch (pcri->riaction)
   {
      case RIA_NOTHING:
         tr = TR_SUCCESS;
         break;

      case RIA_COPY:
         if (*(pcri->pcszName))
            tr = DealWithCopy(pcri, rsp, lpCallbackData, dwFlags, hwndOwner,
                              hwndProgressFeedback);
         else
            tr = CopyFolder(pcri, rsp, lpCallbackData);

         if (tr == TR_SUCCESS)
            tr = UpdateRecNodeFileStamps(pcri);
         break;

      case RIA_MERGE:
         tr = DealWithMerge(pcri, rsp, lpCallbackData, dwFlags, hwndOwner,
                            hwndProgressFeedback);

         if (tr == TR_SUCCESS || tr == TR_MERGE_INCOMPLETE)
            tr = UpdateRecNodeFileStamps(pcri);
         break;

      case RIA_DELETE:
         if (*(pcri->pcszName))
            tr = DealWithDelete(pcri, rsp, lpCallbackData);
         else
         {
            tr = DeleteFolder(pcri, rsp, lpCallbackData);

            if (tr == TR_DEST_WRITE_FAILED)
               tr = TR_SUCCESS;
         }

         if (tr == TR_SUCCESS)
            tr = UpdateRecNodeFileStamps(pcri);
         break;

      default:
         ASSERT(pcri->riaction == RIA_BROKEN_MERGE);
         tr = TR_NO_MERGE_HANDLER;
         break;
   }

   /*
    * Only update briefcase time stamps if the entire reconciliation operation
    * on this RECITEM is successful.  However, the RECNODE time stamps in the
    * given RECITEM have been updated as they were changed.
    */

   if (tr == TR_SUCCESS)
   {
      UpdateObjectTwinStates(pcri);

      DetermineDeletionPendingState(pcri);

      DeleteTwinsFromRecItem(pcri);
   }
   else if (tr == TR_MERGE_INCOMPLETE)
      tr = TR_SUCCESS;

   if (tr == TR_SUCCESS)
      GenerateShellEvents(pcri);

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

   return(tr);
}


/*
** UpdateObjectTwinStates()
**
** Updates the last reconciliation time stamp of the twin family and the object
** twins associated with a RECITEM that has just been successfully reconciled.
**
** Arguments:     pri - pointer to reconciliation item that has just been
**                      reconciled
**
** Returns:       TWINRESULT
**
** Side Effects:  Implicitly deletes twin family if the last known state of
**                every component object twins is non-existence.
**
** N.b., this function assumes that the actions specified in the RECNODEs of
** the RECITEM were carried out successfully.
**
** This function assumes that all available RECNODES were reconciled.
**
** This function assumes that the time stamp fields of the RECNODEs associated
** with objects that were modified during reconciliation were filled in
** immediately after each of those RECNODEs was reconciled.  I.e., that all
** time stamp fields in reconciled RECNODEs are up-to-date with respect to any
** modifications that may have been made to them during reconciliation.
*/
PRIVATE_CODE void UpdateObjectTwinStates(PCRECITEM pcri)
{
   PRECNODE prn;
   BOOL bNewVersion = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

   /*
    * There is a new version if any changed or never reconciled RECNODEs were
    * reconciled as RNA_NOTHING, RNA_COPY_FROM_ME, or RNA_MERGE_ME.
    */

   for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
   {
      if ((prn->rnstate == RNS_NEVER_RECONCILED ||
           prn->rnstate == RNS_CHANGED) &&
          (prn->rnaction == RNA_NOTHING ||
           prn->rnaction == RNA_COPY_FROM_ME ||
           prn->rnaction == RNA_MERGE_ME))
         bNewVersion = TRUE;
   }

   /*
    * Save file stamps of available files.  Mark unavailable object twins not
    * reconciled if any new versions exist in the reconciled set of files.
    */

   for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
   {
      POBJECTTWIN pot;

      pot = (POBJECTTWIN)(prn->hObjectTwin);

      if (prn->fsCurrent.fscond != FS_COND_UNAVAILABLE)
      {
         ClearStubFlag(&(pot->stub), STUB_FL_NOT_RECONCILED);
         pot->fsLastRec = prn->fsCurrent;

         /*
          * Remember not to delete object twins as requested.  Treat any folder
          * that could not be deleted as implicitly kept as well.
          */

         if (IS_FLAG_SET(prn->dwFlags, RN_FL_DELETION_SUGGESTED) &&
             IsTwinFamilyDeletionPending((PCTWINFAMILY)(pcri->hTwinFamily)) &&
             (pcri->riaction == RIA_NOTHING ||
              pcri->riaction == RIA_DELETE) &&
             (prn->rnaction != RNA_DELETE_ME ||
              IsFolderObjectTwinName(pcri->pcszName)))
         {
            SetStubFlag(&(pot->stub), STUB_FL_KEEP);

            TRACE_OUT((TEXT("UpdateObjectTwinStates(): Object twin %s\\%s will be kept and not deleted."),
                       prn->pcszFolder,
                       prn->priParent->pcszName));
         }
      }
      else if (bNewVersion &&
               IsReconciledFileStamp(&(prn->fsLast)))
      {
         SetStubFlag(&(pot->stub), STUB_FL_NOT_RECONCILED);

         WARNING_OUT((TEXT("UpdateObjectTwinStates(): Marked %s\\%s not reconciled."),
                      prn->pcszFolder,
                      pcri->pcszName));
      }
   }

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

   return;
}


/*
** CopyFolder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT CopyFolder(PCRECITEM pcri, RECSTATUSPROC rsp,
                                   LPARAM lpCallbackData)
{
   TWINRESULT tr;
   RECSTATUSUPDATE rsu;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));

   ASSERT(IsFolderObjectTwinName(pcri->pcszName));

   rsu.ulScale = CountRECNODEs(pcri, RNA_COPY_TO_ME);
   ASSERT(rsu.ulScale > 0);
   rsu.ulProgress = 0;

   if (NotifyReconciliationStatus(rsp, RS_BEGIN_COPY, (LPARAM)&rsu,
                                  lpCallbackData))
   {
      PRECNODE prn;

      tr = TR_SUCCESS;

      for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
      {
         if (prn->rnaction == RNA_COPY_TO_ME)
            tr = CreateFolders(prn->pcszFolder, (HPATH)(prn->hvid));
      }

      if (tr == TR_SUCCESS)
      {
         /* 100% complete. */

         rsu.ulProgress = rsu.ulScale;

         /* Don't allow abort. */

         NotifyReconciliationStatus(rsp, RS_END_COPY, (LPARAM)&rsu,
                                    lpCallbackData);
      }
   }
   else
      tr = TR_ABORT;

   return(tr);
}


/*
** DeleteFolder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT DeleteFolder(PCRECITEM pcri, RECSTATUSPROC rsp,
                                     LPARAM lpCallbackData)
{
   TWINRESULT tr;
   RECSTATUSUPDATE rsu;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));

   ASSERT(IsFolderObjectTwinName(pcri->pcszName));

   rsu.ulScale = CountRECNODEs(pcri, RNA_DELETE_ME);
   ASSERT(rsu.ulScale > 0);
   rsu.ulProgress = 0;

   if (NotifyReconciliationStatus(rsp, RS_BEGIN_DELETE, (LPARAM)&rsu,
                                  lpCallbackData))
   {
      PRECNODE prn;

      tr = TR_SUCCESS;

      for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
      {
         if (prn->rnaction == RNA_DELETE_ME)
            tr = DestroySubtree(prn->pcszFolder, (HPATH)(prn->hvid));
      }

      if (tr == TR_SUCCESS)
      {
         /* 100% complete. */

         rsu.ulProgress = rsu.ulScale;

         /* Don't allow abort. */

         NotifyReconciliationStatus(rsp, RS_END_DELETE, (LPARAM)&rsu,
                                    lpCallbackData);
      }
   }
   else
      tr = TR_ABORT;

   return(tr);
}


/*
** DealWithCopy()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT DealWithCopy(PCRECITEM pcri, RECSTATUSPROC rsp,
                                     LPARAM lpCallbackData, DWORD dwInFlags,
                                     HWND hwndOwner, HWND hwndProgressFeedback)
{
   TWINRESULT tr;
   PRECNODE prnCopySrc;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RI_FLAGS));
   ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
          IS_VALID_HANDLE(hwndProgressFeedback, WND));

   tr = FindCopySource(pcri, &prnCopySrc);

   if (EVAL(tr == TR_SUCCESS))
      tr = CopyHandler(prnCopySrc, rsp, lpCallbackData, dwInFlags, hwndOwner,
                       hwndProgressFeedback);

   return(tr);
}


/*
** DealWithMerge()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT DealWithMerge(PCRECITEM pcri, RECSTATUSPROC rsp,
                                      LPARAM lpCallbackData, DWORD dwInFlags,
                                      HWND hwndOwner,
                                      HWND hwndProgressFeedback)
{
   TWINRESULT tr;
   HRESULT hr;
   PRECNODE prnMergeDest;
   PRECNODE prnMergedResult;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RI_FLAGS));
   ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_FLAG_CLEAR(dwInFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
          IS_VALID_HANDLE(hwndProgressFeedback, WND));

   ChooseMergeDestination(pcri, &prnMergeDest);

   hr = MergeHandler(prnMergeDest, rsp, lpCallbackData, dwInFlags, hwndOwner,
                     hwndProgressFeedback, &prnMergedResult);

   if (hr == S_OK ||
       hr == REC_S_NOTCOMPLETEBUTPROPAGATE)
   {
      tr = CopyHandler(prnMergedResult, rsp, lpCallbackData, dwInFlags,
                       hwndOwner, hwndProgressFeedback);

      if (tr == TR_SUCCESS)
         TRACE_OUT((TEXT("DealWithMerge(): Propagated merged result %s\\%s successfully."),
                    prnMergedResult->pcszFolder,
                    pcri->pcszName));
      else
         WARNING_OUT((TEXT("DealWithMerge(): Propagating merged result %s\\%s failed."),
                      prnMergedResult->pcszFolder,
                      pcri->pcszName));
   }
   else
      tr = TR_SUCCESS;

   return((tr == TR_SUCCESS) ? TranslateHRESULTToTWINRESULT(hr)
                             : tr);
}


/*
** DealWithDelete()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT DealWithDelete(PCRECITEM pcri, RECSTATUSPROC rsp,
                                       LPARAM lpCallbackData)
{
   TWINRESULT tr;
   RECSTATUSUPDATE rsu;

   /* lpCallbackData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
   ASSERT(! rsp ||
          IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));

   rsu.ulScale = CountRECNODEs(pcri, RNA_DELETE_ME);
   ASSERT(rsu.ulScale > 0);
   rsu.ulProgress = 0;

   if (NotifyReconciliationStatus(rsp, RS_BEGIN_DELETE, (LPARAM)&rsu,
                                  lpCallbackData))
   {
      PRECNODE prn;

      tr = TR_SUCCESS;

      for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
      {
         if (prn->rnaction == RNA_DELETE_ME)
         {
            TCHAR rgchPath[MAX_PATH_LEN];

            ComposePath(rgchPath, prn->pcszFolder, prn->priParent->pcszName);
            ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

            if (MyIsPathOnVolume(rgchPath, (HPATH)(prn->hvid)))
            {
               if (DeleteFile(rgchPath))
                  WARNING_OUT((TEXT("DealWithDelete(): Deleted file %s."),
                               rgchPath));
               else
               {
                  tr = TR_DEST_OPEN_FAILED;

                  WARNING_OUT((TEXT("DealWithDelete(): Failed to delete file %s."),
                               rgchPath));
               }
            }
            else
               tr = TR_UNAVAILABLE_VOLUME;
         }
      }

      if (tr == TR_SUCCESS)
      {
         /* 100% complete. */

         rsu.ulProgress = rsu.ulScale;

         /* Don't allow abort. */

         NotifyReconciliationStatus(rsp, RS_END_DELETE, (LPARAM)&rsu,
                                    lpCallbackData);
      }
   }
   else
      tr = TR_ABORT;

   return(tr);
}


/*
** CountRECNODEs()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE ULONG CountRECNODEs(PCRECITEM pcri, RECNODEACTION rnaction)
{
   ULONG ulc = 0;
   PRECNODE prn;

   for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
   {
      if (prn->rnaction == rnaction)
      {
         ASSERT(ulc < ULONG_MAX);
         ulc++;
      }
   }

   return(ulc);
}


/*
** UpdateRecNodeFileStamps()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT UpdateRecNodeFileStamps(PCRECITEM pcri)
{
   TWINRESULT tr;
   PRECNODE prn;

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

   tr = TR_SUCCESS;

   for (prn = pcri->prnFirst; prn; prn = prn->prnNext)
   {
      ASSERT(IS_VALID_HANDLE(prn->hObjectTwin, OBJECTTWIN));

      /* Was the RECNODE supposed to be reconciled? */


      if (prn->rnaction != RNA_NOTHING)
      {
         ASSERT(prn->fsCurrent.fscond != FS_COND_UNAVAILABLE);

         /* Leave prn->fsLast as pot->fsLastRec here. */

         MyGetFileStampByHPATH(((PCOBJECTTWIN)(prn->hObjectTwin))->hpath,
               GetString(((PCOBJECTTWIN)(prn->hObjectTwin))->ptfParent->hsName),
               &(prn->fsCurrent));
      }
   }

   return(tr);
}


/*
** DeletedTwinsInRecItem()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL DeletedTwinsInRecItem(PCRECITEM pcri)
{
   BOOL bResult = TRUE;

   ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));

   /* Has the associated twin family been deleted? */

   if (IsStubFlagClear(&(((PTWINFAMILY)(pcri->hTwinFamily))->stub), STUB_FL_UNLINKED))
   {
      PRECNODE prn;

      /* No.  Have any of the associated object twins been deleted? */

      for (prn = pcri->prnFirst;
           prn && IsStubFlagClear(&(((PCOBJECTTWIN)(prn->hObjectTwin))->stub), STUB_FL_UNLINKED);
           prn = prn->prnNext)
         ;

      if (! prn)
         bResult = FALSE;
   }

   return(bResult);
}


/****************************** Public Functions *****************************/


/*
** CopyFileStampFromFindData()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void CopyFileStampFromFindData(PCWIN32_FIND_DATA pcwfdSrc,
                                           PFILESTAMP pfsDest)
{
   ASSERT(IS_VALID_READ_PTR(pcwfdSrc, CWIN32_FIND_DATA));
   ASSERT(IS_VALID_WRITE_PTR(pfsDest, FILESTAMP));

   pfsDest->dwcbHighLength = pcwfdSrc->nFileSizeHigh;
   pfsDest->dwcbLowLength = pcwfdSrc->nFileSizeLow;

   /* Convert to local time and save that too */

   if ( !FileTimeToLocalFileTime(&pcwfdSrc->ftLastWriteTime, &pfsDest->ftModLocal) )
   {
      /* Just copy the time if FileTimeToLocalFileTime failed */

      pfsDest->ftModLocal = pcwfdSrc->ftLastWriteTime;
   }
   pfsDest->ftMod = pcwfdSrc->ftLastWriteTime;
   pfsDest->fscond = FS_COND_EXISTS;

   ASSERT(IS_VALID_STRUCT_PTR(pfsDest, CFILESTAMP));

   return;
}


/*
** MyGetFileStamp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void MyGetFileStamp(LPCTSTR pcszFile, PFILESTAMP pfs)
{
   WIN32_FIND_DATA wfd;
   HANDLE hff;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pfs, FILESTAMP));

   ZeroMemory(pfs, sizeof(*pfs));

   hff = FindFirstFile(pcszFile, &wfd);

   if (hff != INVALID_HANDLE_VALUE)
   {
      if (! IS_ATTR_DIR(wfd.dwFileAttributes))
         CopyFileStampFromFindData(&wfd, pfs);
      else
         pfs->fscond = FS_COND_EXISTS;

      EVAL(FindClose(hff));
   }
   else
      pfs->fscond = FS_COND_DOES_NOT_EXIST;

   ASSERT(IS_VALID_STRUCT_PTR(pfs, CFILESTAMP));

   return;
}


/*
** MyGetFileStampByHPATH()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:
*/
PUBLIC_CODE void MyGetFileStampByHPATH(HPATH hpath, LPCTSTR pcszSubPath,
                                       PFILESTAMP pfs)
{
   ASSERT(IS_VALID_HANDLE(hpath, PATH));
   ASSERT(! pcszSubPath ||
          IS_VALID_STRING_PTR(pcszSubPath, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pfs, FILESTAMP));

   if (IsPathVolumeAvailable(hpath))
   {
      TCHAR rgchPath[MAX_PATH_LEN];

      /* The root of the file's path is accessible. */

      GetPathString(hpath, rgchPath);
      if (pcszSubPath)
         CatPath(rgchPath, pcszSubPath);
      ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

      MyGetFileStamp(rgchPath, pfs);
   }
   else
   {
      ZeroMemory(pfs, sizeof(*pfs));
      pfs->fscond = FS_COND_UNAVAILABLE;
   }

   ASSERT(IS_VALID_STRUCT_PTR(pfs, CFILESTAMP));

   return;
}


/*
** MyCompareFileStamps()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Any FS_COND_UNAVAILABLE == any FS_COND_UNAVAILABLE.
** Any FS_COND_UNAVAILABLE < any FS_COND_DOES_NOT_EXIST.
** Any FS_COND_DOES_NOT_EXIST == any FS_COND_DOES_NOT_EXIST.
** Any FS_COND_DOES_NOT_EXIST < any FS_COND_EXISTS.
** Two FS_COND_EXISTS are compared by date and time.
**
** Hack Warning: This function depends upon the constant values of
** FS_COND_UNAVAILABLE, FS_COND_DOES_NOT_EXIST, and FS_COND_EXISTS being in
** increasing order, i.e.,
**
** FS_COND_UNAVAILABLE < FS_COND_DOES_NOT_EXIST < FS_COND_EXISTS
*/
PUBLIC_CODE int MyCompareFileStamps(PCFILESTAMP pcfs1, PCFILESTAMP pcfs2)
{
   int nResult;

   ASSERT(IS_VALID_STRUCT_PTR(pcfs1, CFILESTAMP));
   ASSERT(IS_VALID_STRUCT_PTR(pcfs2, CFILESTAMP));

   nResult = (int)(pcfs1->fscond - pcfs2->fscond);

   if (! nResult && pcfs1->fscond == FS_COND_EXISTS)
   {
      /* File times are stored as UTC times.  However, files on FAT
      ** file systems only store the local time.  This means the UTC
      ** is derived from the local time, and fudged depending on the
      ** current timezone info.  This means that the UTC time will
      ** differ between timezone changes.
      **
      ** For remote files, the time's derivation depends on the server.
      ** NTFS servers provide the absolute UTC time, regardless of timezone.
      ** These are the best.  Likewise, NWServer keeps track of the 
      ** timezone and puts the UTC time on the wire like NTFS.  FAT
      ** systems convert the local time to UTC time based on the server's
      ** timezone, and places the UTC time on the wire.  Netware 3.31
      ** and some SMB servers put the local time on the wire and have
      ** the client convert to UTC time, so it uses the client's timezone.
      **
      ** One way to cover most of the holes that occur due to timezone
      ** changes is store both the UTC time and the local time.  If either
      ** are the same, then the file has not changed.
      */

      BOOL bModEqual = (pcfs1->ftMod.dwHighDateTime == pcfs2->ftMod.dwHighDateTime);
      BOOL bModLocalEqual = (pcfs1->ftModLocal.dwHighDateTime == pcfs2->ftModLocal.dwHighDateTime);

      if (bModEqual || bModLocalEqual)
      {
         if (bModEqual && pcfs1->ftMod.dwLowDateTime == pcfs2->ftMod.dwLowDateTime ||
            bModLocalEqual && pcfs1->ftModLocal.dwLowDateTime == pcfs2->ftModLocal.dwLowDateTime)
         {
            if (pcfs1->dwcbHighLength == pcfs2->dwcbHighLength)
            {
               if (pcfs1->dwcbLowLength == pcfs2->dwcbLowLength)
                  nResult = CR_EQUAL;
               else if (pcfs1->dwcbLowLength < pcfs2->dwcbLowLength)
                  nResult = CR_FIRST_SMALLER;
               else
                  nResult = CR_FIRST_LARGER;
            }
            else if (pcfs1->dwcbHighLength < pcfs2->dwcbHighLength)
               nResult = CR_FIRST_SMALLER;
            else
               nResult = CR_FIRST_LARGER;
         }
         else if (pcfs1->ftMod.dwLowDateTime < pcfs2->ftMod.dwLowDateTime)
            nResult = CR_FIRST_SMALLER;
         else
            nResult = CR_FIRST_LARGER;
      }
      else if (pcfs1->ftMod.dwHighDateTime < pcfs2->ftMod.dwHighDateTime)
         nResult = CR_FIRST_SMALLER;
      else
         nResult = CR_FIRST_LARGER;
   }

   return(MapIntToComparisonResult(nResult));
}


/***************************** Exported Functions ****************************/

/* RAIDRAID: (16205) AutoDoc RECSTATUSPROC messages below. */

/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | ReconcileItem | Reconciles a reconciliation item created by
CreateRecList().

@parm PCRECITEM | pcri | A pointer to a reconciliation item to be reconciled.

@parm RECSTATUSPROC | rsp | A procedure instance address of a callback function
to be called with status information during the reconciliation of the given
RECITEM.  rsp may be NULL to indicate that no reconciliation status callback
function is to be called.  (See the reconciliation handler SPI documentation
for details.)

@parm LPARAM | lpCallbackData | Callback data to be supplied to the
reconciliation status callback function.  If rsp is NULL, lpCallbackData is
ignored.

@parm DWORD | dwFlags | A bit mask of flags.  This parameter may be any
combination of the following values:
   RI_FL_ALLOW_UI - Allow interaction with the user during reconciliation.
   RI_FL_FEEDBACK_WINDOW_VALID - hwndProgressFeedback is valid, and may be used
   to communicate reconciliation progress information to the user during
   reconciliation.

@parm HWND | hwndOwner | A handle to the parent window to be used when
requesting user interaction.  This parameter is ignored if the RI_FL_ALLOW_UI
flag is clear.

@parm HWND | hwndProgressFeedback | A handle to the window to be used to
provide progress information to the user during reconciliation.  This parameter
is ignored if the RI_FL_FEEDBACK_WINDOW_VALID flag is clear.

@rdesc If the reconciliation item was reconciled successfully, TR_SUCCESS is
returned.  Otherwise, the reconciliation item was not reconciled successfully,
and the return value indicates the error that occurred.

@comm All the fields in the given RECITEM and its child structures are left
unchanged by ReconcileItem(), except for the fsCurrent fields of RECNODEs
associated with objects that are overwritten during reconciliation.  The
fsCurrent field of each RECNODE associated with an object that is overwritten
during reconciliation (i.e., RECNODEs with rnaction set to RNA_COPY_TO_ME or
RNA_MERGE_ME) is updated to reflect the current time stamp of the object after
it is overwritten.  If ReconcileItem() returns TR_SUCCESS, all the available
RECNODEs (i.e., all RECNODEs whose uState field is not RNS_UNAVAILABLE) in the
RECITEM may be assumed to be up-to-date.  If ReconcileItem() does not return
TR_SUCCESS, no assumption may be made about the states of the RECNODEs in the
RECITEM.  If ReconcileItem() is called on a RECITEM that references a twin
family that has been deleted or one or more object twins that have been
deleted, TR_DELETED_TWIN is returned.  In this case, no assumption may be made
about what reconciliation actions have been carried out on the RECITEM.  If
TR_DELETED_TWIN is returned, the client may attempt to create a RECLIST for the
twin family associated with the RECITEM in order to retry the reconciliation
operation.  (The client would call MarkTwin(), followed by CreateRecList().) If
TR_DELETED_TWIN is returned by MarkTwin(), the entire twin family has been
deleted.  If TR_SUCCESS is returned by MarkTwin(), the client should be able to
call CreateRecList() to create a RECLIST containing a more up-to-date RECITEM
for the twin family.

@xref CreateRecList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI ReconcileItem(PCRECITEM pcri, RECSTATUSPROC rsp,
                                           LPARAM lpCallbackData,
                                           DWORD dwFlags, HWND hwndOwner,
                                           HWND hwndProgressFeedback)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(ReconcileItem);

#ifdef EXPV
      /* Verify parameters. */

      /* lpCallbackData may be any value. */

      if (IS_VALID_STRUCT_PTR(pcri, CRECITEM) &&
          (! rsp ||
           IS_VALID_CODE_PTR(rsp, RECSTATUSPROC)) &&
          FLAGS_ARE_VALID(dwFlags, ALL_RI_FLAGS) &&
          (IS_FLAG_CLEAR(dwFlags, RI_FL_ALLOW_UI) ||
           IS_VALID_HANDLE(hwndOwner, WND)) &&
          (IS_FLAG_CLEAR(dwFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
           IS_VALID_HANDLE(hwndProgressFeedback, WND)))
#endif
      {
         /* Check for any deleted twins referenced by this RECITEM. */

         if (! DeletedTwinsInRecItem(pcri))
         {
            InvalidatePathListInfo(GetBriefcasePathList(((PCTWINFAMILY)(pcri->hTwinFamily))->hbr));

            tr = MyReconcileItem(pcri, rsp, lpCallbackData, dwFlags,
                                 hwndOwner, hwndProgressFeedback);

            ASSERT(IS_VALID_STRUCT_PTR(pcri, CRECITEM));
         }
         else
            tr = TR_DELETED_TWIN;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(ReconcileItem, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | BeginReconciliation | Indicates to the synchronization engine
that the caller is about to make multiple calls to ReconcileItem().

@parm HBRFCASE | hbr | A handle to the open briefcase about to be reconciled.

@rdesc If reconciliation for the given briefcase was initialized successfully,
TR_SUCCESS is returned.  Otherwise, reconciliation for the given briefcase was
not initialized successfully, and the return value indicates the error that
occurred.

@comm Synchronization engine clients need not call BeginReconciliation() before
calling ReconcileItem().  BeginReconciliation() is simply provided to allow
synchronization engine clients to give the synchronization engine a hint that
multiple calls to ReconcileItem() are about to occur.  Each call to
EndReconciliation() should be followed by a call to EndReconciliation().

@xref EndReconciliation ReconcileItem

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI BeginReconciliation(HBRFCASE hbr)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(BeginReconciliation);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE))
#endif
      {
         BeginCopy();
         BeginMerge();

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(BeginReconciliation, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | EndReconciliation | Indicates to the synchronization engine
that the client has finished making multiple calls to ReconcileItem(),
preceded by a call to BeginReconciliation().

@parm HBRFCASE | hbr | A handle to the open briefcase whose reconciliation has
been completed.

@rdesc If reconciliation for the given briefcase was terminaterd successfully,
TR_SUCCESS is returned.  Otherwise, reconciliation for the given briefcase was
not terminated successfully, and the return value indicates the error that
occurred.

@comm EndReconciliation() should only be called after a call to
BeginReconciliation().  Each call to BeginReconciliation() should be followed
by a matching call to EndReconciliation().

@xref BeginReconciliation ReconcileItem

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI EndReconciliation(HBRFCASE hbr)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(EndReconciliation);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE))
#endif
      {
         EndMerge();
         EndCopy();

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(EndReconciliation, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | GetFileStamp | Retrieves the file stamp for an open file.

@parm PCSTR | pcszFile | A pointer to a string indicating the file whose file
stamp is to be retrieved.

@parm PFILESTAMP | pcr | A pointer to a FILESTAMP to be filled in with the
file stamp of the given open file.

@rdesc If the comparison was successful, TR_SUCCESS is returned.  Otherwise,
the comparison was not successful, and the return value indicates the error
that occurred.

@xref CompareFileStamps

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI GetFileStamp(LPCTSTR pcszFile, PFILESTAMP pfs)
{
   TWINRESULT tr;

   /* No need for exclusive access here. */

   DebugEntry(GetFileStamp);

#ifdef EXPV
   /* Verify parameters. */

   if (IS_VALID_STRING_PTR(pcszFile, CSTR) &&
       IS_VALID_WRITE_PTR(pfs, FILESTAMP))
#endif
   {
      MyGetFileStamp(pcszFile, pfs);

      tr = TR_SUCCESS;
   }
#ifdef EXPV
   else
      tr = TR_INVALID_PARAMETER;
#endif

   DebugExitTWINRESULT(GetFileStamp, tr);

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api COMPARISONRESULT | CompareFileStamps | Compares two file stamps.

@parm PCFILESTAMP | pcfs1 | A pointer to the first FILESTAMP to be compared.

@parm PCFILESTAMP | pcfs2 | A pointer to the second FILESTAMP to be compared.

@parm PCOMPARISONRESULT | pcr | A pointer to a COMPARISONRESULT to be filled in
with the result of the file stamp comparison.  *pcr is only valid if TR_SUCCESS
is returned.

@rdesc If the file stamp was retrieved successfully, TR_SUCCESS is returned.
Otherwise, the file stamp was not retrieved successfully, and the return value
indicates the error that occurred.

@comm File stamps are compared by fields as follows:
1) condition
   Any FS_COND_UNAVAILABLE equals any FS_COND_UNAVAILABLE.
   Any FS_COND_UNAVAILABLE is less than any FS_COND_DOES_NOT_EXIST.
   Any FS_COND_DOES_NOT_EXIST equals any FS_COND_DOES_NOT_EXIST.
   Any FS_COND_DOES_NOT_EXIST is less than any FS_COND_EXISTS.
   Two FS_COND_EXISTS are compared by date and time.
2) date and time of last modification
3) length

@xref GetFileStamp

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI CompareFileStamps(PCFILESTAMP pcfs1,
                                               PCFILESTAMP pcfs2,
                                               PCOMPARISONRESULT pcr)
{
   TWINRESULT tr;

   /* No need for exclusive access here. */

   DebugEntry(CompareFileStamps);

#ifdef EXPV
   /* Verify parameters. */

   if (IS_VALID_STRUCT_PTR(pcfs1, CFILESTAMP) &&
       IS_VALID_STRUCT_PTR(pcfs2, CFILESTAMP) &&
       IS_VALID_WRITE_PTR(pcr, COMPARISONRESULT))
#endif
   {
      *pcr = MyCompareFileStamps(pcfs1, pcfs2);
      tr = TR_SUCCESS;
   }
#ifdef EXPV
   else
      tr = TR_INVALID_PARAMETER;
#endif

   DebugExitTWINRESULT(CompareFileStamps, tr);

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\resstr.c ===
/*
 * resstr.c - Return code to string translation routines.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#ifdef DEBUG

#pragma data_seg(DATA_SEG_READ_ONLY)

#include "debugstr.h"

#pragma data_seg()

#endif


/* Macros
 *********/

/*
 * macro for simplifying result to string translation, assumes result string
 * pointer pcsz
 */

#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


/****************************** Public Functions *****************************/


#ifdef DEBUG

/*
** GetINTString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR GetINTString(int n)
{
#pragma data_seg(DATA_SEG_SHARED)
   static TCHAR SrgchINT[] = TEXT("-2147483646");
#pragma data_seg()

   wsprintf(SrgchINT, TEXT("%d"), n);

   ASSERT(IS_VALID_STRING_PTR(SrgchINT, CSTR));

   return(SrgchINT);
}


/*
** GetULONGString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR GetULONGString(ULONG ul)
{
#pragma data_seg(DATA_SEG_SHARED)
   static TCHAR SrgchULONG[] = TEXT("4294967295");
#pragma data_seg()

   wsprintf(SrgchULONG, TEXT("%lx"), ul);

   ASSERT(IS_VALID_STRING_PTR(SrgchULONG, CSTR));

   return(SrgchULONG);
}


/*
** GetBOOLString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR GetBOOLString(BOOL bResult)
{
   LPCTSTR pcsz;

   if (bResult)
      pcsz = TEXT("TRUE");
   else
      pcsz = TEXT("FALSE");

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(pcsz);
}


/*
** GetCOMPARISONRESULTString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR GetCOMPARISONRESULTString(COMPARISONRESULT cr)
{
   LPCTSTR pcsz;

   switch (cr)
   {
      STRING_CASE(CR_FIRST_SMALLER);
      STRING_CASE(CR_FIRST_LARGER);
      STRING_CASE(CR_EQUAL);

      default:
         ERROR_OUT((TEXT("GetCOMPARISONRESULTString() called on unknown COMPARISONRESULT %d."),
                    cr));
         pcsz = TEXT("UNKNOWN COMPARISONRESULT");
         break;
   }

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(pcsz);
}


#ifdef INC_OLE2

/*
** GetHRESULTString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR GetHRESULTString(HRESULT hr)
{
   LPCTSTR pcsz;
#pragma data_seg(DATA_SEG_SHARED)
   static TCHAR SrgchHRESULT[] = TEXT("0x12345678");
#pragma data_seg()

   switch (hr)
   {
      STRING_CASE(S_OK);
      STRING_CASE(S_FALSE);

      STRING_CASE(E_UNEXPECTED);
      STRING_CASE(E_NOTIMPL);
      STRING_CASE(E_OUTOFMEMORY);
      STRING_CASE(E_INVALIDARG);
      STRING_CASE(E_NOINTERFACE);
      STRING_CASE(E_POINTER);
      STRING_CASE(E_HANDLE);
      STRING_CASE(E_ABORT);
      STRING_CASE(E_FAIL);
      STRING_CASE(E_ACCESSDENIED);

      STRING_CASE(CLASS_E_NOAGGREGATION);

      STRING_CASE(CO_E_NOTINITIALIZED);
      STRING_CASE(CO_E_ALREADYINITIALIZED);
      STRING_CASE(CO_E_INIT_ONLY_SINGLE_THREADED);

#ifdef __RECONCIL_H__

      STRING_CASE(REC_S_IDIDTHEUPDATES);
      STRING_CASE(REC_S_NOTCOMPLETE);
      STRING_CASE(REC_S_NOTCOMPLETEBUTPROPAGATE);

      STRING_CASE(REC_E_ABORTED);
      STRING_CASE(REC_E_NOCALLBACK);
      STRING_CASE(REC_E_NORESIDUES);
      STRING_CASE(REC_E_TOODIFFERENT);
      STRING_CASE(REC_E_INEEDTODOTHEUPDATES);

#endif   /* __RECONCIL_H__ */

      default:
         wsprintf(SrgchHRESULT, TEXT("%#lx"), hr);
         pcsz = SrgchHRESULT;
         break;
   }

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(pcsz);
}

#endif   /* INC_OLE2 */


#ifdef __SYNCENG_H__

/*
** GetTWINRESULTString()
**
** Returns a pointer to the string name of a TWINRESULT return code.
**
** Arguments:     tr - return code to be translated
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR GetTWINRESULTString(TWINRESULT tr)
{
   LPCTSTR pcsz;

   ASSERT(tr >= 0);

   if (tr < ARRAY_ELEMENTS(rgcpcszTwinResult))
      pcsz = rgcpcszTwinResult[tr];
   else
   {
      ERROR_OUT((TEXT("GetTWINRESULTString() called on unrecognized TWINRESULT %ld."),
                 tr));
      pcsz = TEXT("UNKNOWN TWINRESULT");
   }

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(pcsz);
}


/*
** GetCREATERECLISTPROCMSGString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR GetCREATERECLISTPROCMSGString(UINT uCreateRecListMsg)
{
   LPCTSTR pcsz;

   ASSERT(uCreateRecListMsg >= 0);

   if (uCreateRecListMsg < ARRAY_ELEMENTS(rgcpcszCreateRecListMsg))
      pcsz = rgcpcszCreateRecListMsg[uCreateRecListMsg];
   else
   {
      ERROR_OUT((TEXT("GetCREATERECLISTPROCMSGString() called on unrecognized RECSTATUSPROC message %u."),
                 uCreateRecListMsg));
      pcsz = TEXT("UNKNOWN RECSTATUSPROC MESSAGE");
   }

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(pcsz);
}


/*
** GetRECSTATUSPROCMSGString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR GetRECSTATUSPROCMSGString(UINT uRecStatusMsg)
{
   LPCTSTR pcsz;

   ASSERT(uRecStatusMsg >= 0);

   if (uRecStatusMsg < ARRAY_ELEMENTS(rgcpcszRecStatusMsg))
      pcsz = rgcpcszRecStatusMsg[uRecStatusMsg];
   else
   {
      ERROR_OUT((TEXT("GetRECSTATUSPROCMSGString() called on unrecognized RECSTATUSPROC message %u."),
                 uRecStatusMsg));
      pcsz = TEXT("UNKNOWN RECSTATUSPROC MESSAGE");
   }

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(pcsz);
}


/*
** GetRECNODESTATEString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR GetRECNODESTATEString(RECNODESTATE rnstate)
{
   LPCTSTR pcsz;

   switch (rnstate)
   {
      STRING_CASE(RNS_NEVER_RECONCILED);
      STRING_CASE(RNS_UNAVAILABLE);
      STRING_CASE(RNS_DOES_NOT_EXIST);
      STRING_CASE(RNS_DELETED);
      STRING_CASE(RNS_NOT_RECONCILED);
      STRING_CASE(RNS_UP_TO_DATE);
      STRING_CASE(RNS_CHANGED);

      default:
         ERROR_OUT((TEXT("GetRECNODESTATEString() called on unknown RECNODESTATE %d."),
                    rnstate));
         pcsz = TEXT("UNKNOWN RECNODESTATE");
         break;
   }

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(pcsz);
}


/*
** GetRECNODEACTIONString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR GetRECNODEACTIONString(RECNODEACTION rnaction)
{
   LPCTSTR pcsz;

   switch (rnaction)
   {
      STRING_CASE(RNA_NOTHING);
      STRING_CASE(RNA_COPY_FROM_ME);
      STRING_CASE(RNA_COPY_TO_ME);
      STRING_CASE(RNA_MERGE_ME);
      STRING_CASE(RNA_DELETE_ME);

      default:
         ERROR_OUT((TEXT("GetRECNODEACTIONString() called on unknown RECNODEACTION %d."),
                    rnaction));
         pcsz = TEXT("UNKNOWN RECNODEACTION");
         break;
   }

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

   return(pcsz);
}

#endif   /* __SYNCENG_H__ */

#endif   /* DEBUG */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\serial.c ===
/*
 * serial.c - Access serialization routines module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "init.h"


/* Types
 ********/

/* process information */

typedef struct _processinfo
{
   HANDLE hModule;
}
PROCESSINFO;
DECLARE_STANDARD_TYPES(PROCESSINFO);

#ifdef DEBUG

/* debug flags */

typedef enum _serialdebugflags
{
   SERIAL_DFL_BREAK_ON_PROCESS_ATTACH  = 0x0001,

   SERIAL_DFL_BREAK_ON_THREAD_ATTACH   = 0x0002,

   ALL_SERIAL_DFLAGS                   = (SERIAL_DFL_BREAK_ON_PROCESS_ATTACH |
                                          SERIAL_DFL_BREAK_ON_THREAD_ATTACH)
}
SERIALDEBUGFLAGS;

#endif   /* DEBUG */


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_SHARED)

/*
 * RAIDRAID: (16273) The use of Mnrcs in a shared data section is broken under
 * NT.  To run under NT, this code should be changed to use a shared mutex
 * referenced by hMutex in Mpi.
 */

/* critical section used for access serialization */

PRIVATE_DATA NONREENTRANTCRITICALSECTION Mnrcs =
{
   { 0 },

#ifdef DEBUG
   INVALID_THREAD_ID,
#endif   /* DEBUG */

   FALSE
};

/* number of attached processes */

PRIVATE_DATA ULONG MulcProcesses = 0;

#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* information about current process */

/*
 * Initialize Mpi so it is actually put in the .instanc section instead of the
 * .bss section.
 */

PRIVATE_DATA PROCESSINFO Mpi =
{
   NULL
};

#pragma data_seg()

#ifdef DEBUG

#pragma data_seg(DATA_SEG_SHARED)

/* debug flags */

PRIVATE_DATA DWORD MdwSerialModuleFlags = 0;

#pragma data_seg(DATA_SEG_READ_ONLY)

/* .ini file switch descriptions */

PRIVATE_DATA CBOOLINISWITCH cbisBreakOnProcessAttach =
{
   IST_BOOL,
  TEXT( "BreakOnProcessAttach"),
   &MdwSerialModuleFlags,
   SERIAL_DFL_BREAK_ON_PROCESS_ATTACH
};

PRIVATE_DATA CBOOLINISWITCH cbisBreakOnThreadAttach =
{
   IST_BOOL,
   TEXT("BreakOnThreadAttach"),
   &MdwSerialModuleFlags,
   SERIAL_DFL_BREAK_ON_THREAD_ATTACH
};

PRIVATE_DATA const PCVOID MrgcpcvisSerialModule[] =
{
   &cbisBreakOnProcessAttach,
   &cbisBreakOnThreadAttach
};

#pragma data_seg()

#endif   /* DEBUG */


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCSERIALCONTROL(PCSERIALCONTROL);
PRIVATE_CODE BOOL IsValidPCPROCESSINFO(PCPROCESSINFO);
PRIVATE_CODE BOOL IsValidPCCRITICAL_SECTION(PCCRITICAL_SECTION);
PRIVATE_CODE BOOL IsValidThreadId(DWORD);
PRIVATE_CODE BOOL IsValidPCNONREENTRANTCRITICALSECTION(PCNONREENTRANTCRITICALSECTION);

#endif


#ifdef DEBUG

/*
** IsValidPCSERIALCONTROL()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCSERIALCONTROL(PCSERIALCONTROL pcserctrl)
{
   return(IS_VALID_READ_PTR(pcserctrl, CSERIALCONTROL) &&
          (! pcserctrl->AttachProcess ||
           IS_VALID_CODE_PTR(pcserctrl->AttachProcess, AttachProcess)) &&
          (! pcserctrl->DetachProcess ||
           IS_VALID_CODE_PTR(pcserctrl->DetachProcess, DetachProcess)) &&
          (! pcserctrl->AttachThread ||
           IS_VALID_CODE_PTR(pcserctrl->AttachThread, AttachThread)) &&
          (! pcserctrl->DetachThread||
           IS_VALID_CODE_PTR(pcserctrl->DetachThread, DetachThread)));
}


/*
** IsValidPCPROCESSINFO()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCPROCESSINFO(PCPROCESSINFO pcpi)
{
   return(IS_VALID_READ_PTR(pcpi, CPROCESSINFO) &&
          IS_VALID_HANDLE(pcpi->hModule, MODULE));
}


/*
** IsValidPCCRITICAL_SECTION()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCCRITICAL_SECTION(PCCRITICAL_SECTION pccritsec)
{
   return(IS_VALID_READ_PTR(pccritsec, CCRITICAL_SECTION));
}


/*
** IsValidThreadId()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidThreadId(DWORD dwThreadId)
{
   return(dwThreadId != INVALID_THREAD_ID);
}


/*
** IsValidPCNONREENTRANTCRITICALSECTION()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCNONREENTRANTCRITICALSECTION(
                                          PCNONREENTRANTCRITICALSECTION pcnrcs)
{
   /* bEntered may be any value. */

   return(IS_VALID_READ_PTR(pcnrcs, CNONREENTRANTCRITICALSECTION) &&
          IS_VALID_STRUCT_PTR(&(pcnrcs->critsec), CCRITICAL_SECTION) &&
          EVAL(pcnrcs->dwOwnerThread == INVALID_THREAD_ID ||
               IsValidThreadId(pcnrcs->dwOwnerThread)));
}

#endif


/****************************** Public Functions *****************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

#ifdef DEBUG

/*
** SetSerialModuleIniSwitches()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SetSerialModuleIniSwitches(void)
{
   BOOL bResult;

   bResult = SetIniSwitches(MrgcpcvisSerialModule,
                            ARRAY_ELEMENTS(MrgcpcvisSerialModule));

   ASSERT(FLAGS_ARE_VALID(MdwSerialModuleFlags, ALL_SERIAL_DFLAGS));

   return(bResult);
}

#endif


/*
** AttachProcess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL AttachProcess(HMODULE hmod)
{
   BOOL bResult;

   ReinitializeNonReentrantCriticalSection(&Mnrcs);

   bResult = EnterNonReentrantCriticalSection(&Mnrcs);

   if (bResult)
   {

#ifdef DEBUG

      ASSERT(SetAllIniSwitches());

      TRACE_OUT((TEXT("AttachProcess(): Called for module %#lx."),
                 hmod));

      if (IS_FLAG_SET(MdwSerialModuleFlags, SERIAL_DFL_BREAK_ON_PROCESS_ATTACH))
      {
         WARNING_OUT((TEXT("AttachProcess(): Breaking on process attach, as requested.")));
         DebugBreak();
      }

#endif   /* DEBUG */

      Mpi.hModule = hmod;

      ASSERT(MulcProcesses < ULONG_MAX);

      if (! MulcProcesses++)
      {
         TRACE_OUT((TEXT("AttachProcess(): First process attached.  Calling InitializeDLL().")));

         bResult = InitializeDLL();
      }
      else
      {

#ifdef PRIVATE_HEAP

         bResult = TRUE;

#else
         /* 
          * Initialize the per-instance memory manager heap for 
          * subsequent processes.
          */

         bResult = InitMemoryManagerModule();

#endif

      }

      if (bResult)
      {
         ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

         if (g_cserctrl.AttachProcess)
            bResult = g_cserctrl.AttachProcess(hmod);
      }

      TRACE_OUT((TEXT("AttachProcess(): There are now %lu processes attached."),
                 MulcProcesses));

      LeaveNonReentrantCriticalSection(&Mnrcs);
   }

   return(bResult);
}


/*
** DetachProcess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL DetachProcess(HMODULE hmod)
{
   BOOL bResult;

   bResult = EnterNonReentrantCriticalSection(&Mnrcs);

   if (bResult)
   {
      ASSERT(hmod == Mpi.hModule);

      ASSERT(MulcProcesses > 0);

      TRACE_OUT((TEXT("DetachProcess(): Called for module %#lx."),
                 hmod));

      ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

      if (g_cserctrl.DetachProcess)
         bResult = g_cserctrl.DetachProcess(hmod);

      if (--MulcProcesses)
      {
         bResult = TRUE;

#ifndef PRIVATE_HEAP

         /* 
          * Terminate the per-instance memory manager heap.
          */

         ExitMemoryManagerModule();

#endif
      }
      else
      {
         TRACE_OUT((TEXT("DetachProcess(): Last process detached.  Calling TerminateDLL().")));

         bResult = TerminateDLL();
      }

      TRACE_OUT((TEXT("DetachProcess(): There are now %lu processes attached."),
                 MulcProcesses));

      LeaveNonReentrantCriticalSection(&Mnrcs);
   }

   /*
    * Do not call DeleteCriticalSection(&(Mnrcs->critsec)) here, since doing so
    * at the right time would require unprotected access to shared data
    * MulcProcesses and Mnrcs->critsec.  Assume Kernel32 will clean up
    * Mnrcs->critsec for us at termination.
    */

   return(bResult);
}


/*
** AttachThread()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL AttachThread(HMODULE hmod)
{
   BOOL bResult;

   bResult = EnterNonReentrantCriticalSection(&Mnrcs);

   if (bResult)
   {

#ifdef DEBUG

      ASSERT(SetAllIniSwitches());

      TRACE_OUT((TEXT("AttachThread() called for module %#lx, thread ID %#lx."),
                 hmod,
                 GetCurrentThreadId()));

      if (IS_FLAG_SET(MdwSerialModuleFlags, SERIAL_DFL_BREAK_ON_THREAD_ATTACH))
      {
         WARNING_OUT((TEXT("AttachThread(): Breaking on thread attach, as requested.")));
         DebugBreak();
      }

#endif

      ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

      if (g_cserctrl.AttachThread)
         bResult = g_cserctrl.AttachThread(hmod);
      else
         bResult = TRUE;

      LeaveNonReentrantCriticalSection(&Mnrcs);
   }

   return(bResult);
}


/*
** DetachThread()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL DetachThread(HMODULE hmod)
{
   BOOL bResult;

   bResult = EnterNonReentrantCriticalSection(&Mnrcs);

   if (bResult)
   {
      TRACE_OUT((TEXT("DetachThread() called for module %#lx, thread ID %#lx."),
                 hmod,
                 GetCurrentThreadId()));

      ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

      if (g_cserctrl.DetachThread)
         bResult = g_cserctrl.DetachThread(hmod);
      else
         bResult = TRUE;

      LeaveNonReentrantCriticalSection(&Mnrcs);
   }

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** ReinitializeNonReentrantCriticalSection()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ReinitializeNonReentrantCriticalSection(
                                          PNONREENTRANTCRITICALSECTION pnrcs)
{
   ASSERT(IS_VALID_STRUCT_PTR(pnrcs, CNONREENTRANTCRITICALSECTION));

   InitializeCriticalSection(&(pnrcs->critsec));

   return;
}


/*
** EnterNonReentrantCriticalSection()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL EnterNonReentrantCriticalSection(
                                          PNONREENTRANTCRITICALSECTION pnrcs)
{
   BOOL bEntered;

#ifdef DEBUG

   BOOL bBlocked;

   ASSERT(IS_VALID_STRUCT_PTR(pnrcs, CNONREENTRANTCRITICALSECTION));

   /* Is the critical section already owned by another thread? */

   /* Use pnrcs->bEntered and pnrcs->dwOwnerThread unprotected here. */

   bBlocked = (pnrcs->bEntered &&
               GetCurrentThreadId() != pnrcs->dwOwnerThread);

   if (bBlocked)
      WARNING_OUT((TEXT("EnterNonReentrantCriticalSection(): Blocking thread %lx.  Critical section is already owned by thread %#lx."),
                   GetCurrentThreadId(),
                   pnrcs->dwOwnerThread));

#endif

   EnterCriticalSection(&(pnrcs->critsec));

   bEntered = (! pnrcs->bEntered);

   if (bEntered)
   {
      pnrcs->bEntered = TRUE;

#ifdef DEBUG

      pnrcs->dwOwnerThread = GetCurrentThreadId();

      if (bBlocked)
         WARNING_OUT((TEXT("EnterNonReentrantCriticalSection(): Unblocking thread %lx.  Critical section is now owned by this thread."),
                      pnrcs->dwOwnerThread));
#endif

   }
   else
   {
      LeaveCriticalSection(&(pnrcs->critsec));

      ERROR_OUT((TEXT("EnterNonReentrantCriticalSection(): Thread %#lx attempted to reenter non-reentrant code."),
                 GetCurrentThreadId()));
   }

   return(bEntered);
}


/*
** LeaveNonReentrantCriticalSection()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void LeaveNonReentrantCriticalSection(
                                          PNONREENTRANTCRITICALSECTION pnrcs)
{
   ASSERT(IS_VALID_STRUCT_PTR(pnrcs, CNONREENTRANTCRITICALSECTION));

   if (EVAL(pnrcs->bEntered))
   {
      pnrcs->bEntered = FALSE;
#ifdef DEBUG
      pnrcs->dwOwnerThread = INVALID_THREAD_ID;
#endif

      LeaveCriticalSection(&(pnrcs->critsec));
   }

   return;
}


#ifdef DEBUG

/*
** NonReentrantCriticalSectionIsOwned()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL NonReentrantCriticalSectionIsOwned(
                                          PCNONREENTRANTCRITICALSECTION pcnrcs)
{
   return(pcnrcs->bEntered);
}

#endif


/*
** BeginExclusiveAccess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL BeginExclusiveAccess(void)
{
   return(EnterNonReentrantCriticalSection(&Mnrcs));
}


/*
** EndExclusiveAccess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void EndExclusiveAccess(void)
{
   LeaveNonReentrantCriticalSection(&Mnrcs);

   return;
}


#ifdef DEBUG

/*
** AccessIsExclusive()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL AccessIsExclusive(void)
{
   return(NonReentrantCriticalSectionIsOwned(&Mnrcs));
}

#endif   /* DEBUG */


/*
** GetThisModulesHandle()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HMODULE GetThisModulesHandle(void)
{
   ASSERT(IS_VALID_STRUCT_PTR((PCPROCESSINFO)&Mpi, CPROCESSINFO));

   return(Mpi.hModule);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\resstr.h ===
/*
 * resstr.h - Common return code to string translation routines description.
 */


/* Prototypes
 *************/

/* resstr.c */

#ifdef DEBUG

extern LPCTSTR GetINTString(int);
extern LPCTSTR GetULONGString(ULONG);
extern LPCTSTR GetBOOLString(BOOL);
extern LPCTSTR GetCOMPARISONRESULTString(COMPARISONRESULT);

#ifdef INC_OLE2

extern LPCTSTR GetHRESULTString(HRESULT);

#endif   /* INC_OLE2 */

#ifdef __SYNCENG_H__

extern LPCTSTR GetTWINRESULTString(TWINRESULT);
extern LPCTSTR GetCREATERECLISTPROCMSGString(UINT);
extern LPCTSTR GetRECSTATUSPROCMSGString(UINT);
extern LPCTSTR GetRECNODESTATEString(RECNODESTATE);
extern LPCTSTR GetRECNODEACTIONString(RECNODEACTION);

#endif   /* __SYNCENG_H__ */

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\sortsrch.h ===
/*
 * sortsrch.c - Generic array sorting and searching description.
 */


/* Types
 ********/

/* array element comparison callback function */

typedef COMPARISONRESULT (*COMPARESORTEDELEMSPROC)(PCVOID, PCVOID);


/* Prototypes
 *************/

/* sortsrch.c */

extern void HeapSort(PVOID, LONG, size_t, COMPARESORTEDELEMSPROC, PVOID);
extern BOOL BinarySearch(PVOID, LONG, size_t, COMPARESORTEDELEMSPROC, PCVOID, PLONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\serial.h ===
/*
 * serial.h - Access serialization routines description.
 */


/* Types
 ********/

typedef struct _serialcontrol
{
   BOOL (*AttachProcess)(HMODULE);
   BOOL (*DetachProcess)(HMODULE);
   BOOL (*AttachThread)(HMODULE);
   BOOL (*DetachThread)(HMODULE);
}
SERIALCONTROL;
DECLARE_STANDARD_TYPES(SERIALCONTROL);

typedef struct _nonreentrantcriticalsection
{
   CRITICAL_SECTION critsec;

#ifdef DEBUG
   DWORD dwOwnerThread;
#endif   /* DEBUG */

   BOOL bEntered;
}
NONREENTRANTCRITICALSECTION;
DECLARE_STANDARD_TYPES(NONREENTRANTCRITICALSECTION);


/* Prototypes
 *************/

/* serial.c */

#ifdef DEBUG

extern BOOL SetSerialModuleIniSwitches(void);

#endif   /* DEBUG */

extern void ReinitializeNonReentrantCriticalSection(PNONREENTRANTCRITICALSECTION);
extern BOOL EnterNonReentrantCriticalSection(PNONREENTRANTCRITICALSECTION);
extern void LeaveNonReentrantCriticalSection(PNONREENTRANTCRITICALSECTION);

#ifdef DEBUG

extern BOOL NonReentrantCriticalSectionIsOwned(PCNONREENTRANTCRITICALSECTION);

#endif

extern BOOL BeginExclusiveAccess(void);
extern void EndExclusiveAccess(void);

#ifdef DEBUG

extern BOOL AccessIsExclusive(void);

#endif   /* DEBUG */

extern HMODULE GetThisModulesHandle(void);

/* functions to be provided by client */

extern BOOL InitializeDLL(void);
extern BOOL TerminateDLL(void);

#ifdef DEBUG

extern BOOL SetAllIniSwitches(void);

#endif


/* Global Variables
 *******************/

/* serialization control structure */

extern CSERIALCONTROL g_cserctrl;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\storage.h ===
/*
 * storage.h - Storage ADT description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HSTGIFACE);
DECLARE_STANDARD_TYPES(HSTGIFACE);


/* Prototypes
 *************/

/* storage.c */

extern BOOL ProcessInitStorageModule(void);
extern void ProcessExitStorageModule(void);
extern HRESULT GetStorageInterface(PIUnknown, PHSTGIFACE);
extern void ReleaseStorageInterface(HSTGIFACE);
extern HRESULT LoadFromStorage(HSTGIFACE, LPCTSTR);
extern HRESULT SaveToStorage(HSTGIFACE);
extern void HandsOffStorage(HSTGIFACE);
extern BOOL GetIMalloc(PIMalloc *);

#ifdef DEBUG

extern BOOL IsValidHSTGIFACE(HSTGIFACE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\storage.c ===
/*
 * storage.c - Storage ADT module.
 */

/*

   The HSTGIFACE ADT is provided to insulate the caller from the details of
which storage interface is used for serialization, and how it is called.
Storage interfaces are tried in the following order:

1) IPersistFile
2) IPersistStorage

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Constants
 ************/

/* flags specified when opening a storage */

#define STORAGE_OPEN_MODE_FLAGS        (STGM_TRANSACTED |\
                                        STGM_READWRITE |\
                                        STGM_SHARE_EXCLUSIVE)


/* Macros
 *********/

/* access STGIFACE fields */

#define STGI_TYPE(pstgi)               ((pstgi)->stgit)
#define STGI_IPERSISTFILE(pstgi)       ((pstgi)->stgi.pipfile)
#define STGI_ISTORAGE(pstgi)           ((pstgi)->stgi.stg.pistg)
#define STGI_IPERSISTSTORAGE(pstgi)    ((pstgi)->stgi.stg.pipstg)


/* Types
 ********/

/* storage interface types */

typedef enum _storageinterfacetype
{
   STGIT_IPERSISTFILE,

   STGIT_IPERSISTSTORAGE
}
STGIFACETYPE;

/* storage interface structure */

typedef struct _storageinterface
{
   STGIFACETYPE stgit;

   union
   {
      PIPersistFile pipfile;

      struct
      {
         PIStorage pistg;

         PIPersistStorage pipstg;
      } stg;
   } stgi;
}
STGIFACE;
DECLARE_STANDARD_TYPES(STGIFACE);


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* memory manager interface */

PRIVATE_DATA PIMalloc Mpimalloc = NULL;

#pragma data_seg()


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCSTGIFACE(PCSTGIFACE);

#endif


#ifdef DEBUG

/*
** IsValidPCSTGIFACE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCSTGIFACE(PCSTGIFACE pcstgi)
{
   BOOL bResult = FALSE;

   if (IS_VALID_READ_PTR(pcstgi, CSTGIFACE))
   {
      switch (STGI_TYPE(pcstgi))
      {
         case STGIT_IPERSISTSTORAGE:
            bResult = ((! STGI_ISTORAGE(pcstgi) ||
                        IS_VALID_STRUCT_PTR(STGI_ISTORAGE(pcstgi), CIStorage)) &&
                       IS_VALID_STRUCT_PTR(STGI_IPERSISTSTORAGE(pcstgi), CIPersistStorage));
            break;

         default:
            ASSERT(STGI_TYPE(pcstgi) == STGIT_IPERSISTFILE);
            bResult = IS_VALID_STRUCT_PTR(STGI_IPERSISTFILE(pcstgi), CIPersistFile);
            break;
      }
   }

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
** ProcessInitStorageModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ProcessInitStorageModule(void)
{
   return(TRUE);
}


/*
** ProcessExitStorageModule()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ProcessExitStorageModule(void)
{
   ASSERT(! Mpimalloc ||
          IS_VALID_STRUCT_PTR(Mpimalloc, CIMalloc));

   if (Mpimalloc)
   {
      Mpimalloc->lpVtbl->Release(Mpimalloc);
      Mpimalloc = NULL;

      TRACE_OUT((TEXT("ProcessExitStorageModule(): Released IMalloc.")));
   }

   return;
}


/*
** GetStorageInterface()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT GetStorageInterface(PIUnknown piunk, PHSTGIFACE phstgi)
{
   HRESULT hr;
   PSTGIFACE pstgi;

   ASSERT(IS_VALID_STRUCT_PTR(piunk, CIUnknown));
   ASSERT(IS_VALID_WRITE_PTR(phstgi, HSTGIFACE));

   if (AllocateMemory(sizeof(*pstgi), &pstgi))
   {
      PVOID pvInterface;

      /* Ask for a storage interface. */

      hr = piunk->lpVtbl->QueryInterface(piunk, &IID_IPersistFile,
                                         &pvInterface);

      if (SUCCEEDED(hr))
      {
         /* Use IPersistFile. */

         STGI_TYPE(pstgi) = STGIT_IPERSISTFILE;
         STGI_IPERSISTFILE(pstgi) = pvInterface;
      }
      else
      {
         hr = piunk->lpVtbl->QueryInterface(piunk, &IID_IPersistStorage,
                                            &pvInterface);

         if (SUCCEEDED(hr))
         {
            /* Use IPersistStorage. */

            STGI_TYPE(pstgi) = STGIT_IPERSISTSTORAGE;
            STGI_ISTORAGE(pstgi) = NULL;
            STGI_IPERSISTSTORAGE(pstgi) = pvInterface;
         }
         else
            FreeMemory(pstgi);
      }

      if (SUCCEEDED(hr))
         *phstgi = (HSTGIFACE)pstgi;
   }
   else
      hr = E_OUTOFMEMORY;

   ASSERT(FAILED(hr) ||
          IS_VALID_HANDLE(*phstgi, STGIFACE));

   return(hr);
}


/*
** ReleaseStorageInterface()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ReleaseStorageInterface(HSTGIFACE hstgi)
{
   PCSTGIFACE pcstgi;

   ASSERT(IS_VALID_HANDLE(hstgi, STGIFACE));

   pcstgi = (PCSTGIFACE)hstgi;

   switch (STGI_TYPE(pcstgi))
   {
      case STGIT_IPERSISTSTORAGE:
         STGI_IPERSISTSTORAGE(pcstgi)->lpVtbl->Release(STGI_IPERSISTSTORAGE(pcstgi));
         if (STGI_ISTORAGE(pcstgi))
            STGI_ISTORAGE(pcstgi)->lpVtbl->Release(STGI_ISTORAGE(pcstgi));
         break;

      default:
         ASSERT(STGI_TYPE(pcstgi) == STGIT_IPERSISTFILE);
         STGI_IPERSISTFILE(pcstgi)->lpVtbl->Release(STGI_IPERSISTFILE(pcstgi));
         break;
   }

   FreeMemory(hstgi);

   return;
}


/*
** LoadFromStorage()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT LoadFromStorage(HSTGIFACE hstgi, LPCTSTR pcszPath)
{
   HRESULT hr = S_OK;
   WCHAR rgwchUnicodePath[MAX_PATH_LEN];

   ASSERT(IS_VALID_HANDLE(hstgi, STGIFACE));
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));

#ifdef UNICODE
   
   // REVIEW useless strcpy

   lstrcpy(rgwchUnicodePath, pcszPath);
   
#else

   /* Translate ANSI string into Unicode for OLE. */

   if (MultiByteToWideChar(CP_ACP, 0, pcszPath, -1, rgwchUnicodePath,
                           ARRAY_ELEMENTS(rgwchUnicodePath)))
   {
       hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
   }

#endif

   if (S_OK == hr)
   {
      PSTGIFACE pstgi;

      pstgi = (PSTGIFACE)hstgi;

      switch (STGI_TYPE(pstgi))
      {
         case STGIT_IPERSISTSTORAGE:
         {
            PIStorage pistg;

            hr = StgOpenStorage(rgwchUnicodePath, NULL,
                                STORAGE_OPEN_MODE_FLAGS, NULL, 0, &pistg);

            if (SUCCEEDED(hr))
            {
               hr = STGI_IPERSISTSTORAGE(pstgi)->lpVtbl->Load(STGI_IPERSISTSTORAGE(pstgi),
                                                              pistg);

               if (SUCCEEDED(hr))
                  STGI_ISTORAGE(pstgi) = pistg;
               else
                  pistg->lpVtbl->Release(pistg);
            }
            else
               WARNING_OUT((TEXT("LoadFromStorage(): StgOpenStorage() on %s failed, returning %s."),
                            pcszPath,
                            GetHRESULTString(hr)));

            break;
         }

         default:
            ASSERT(STGI_TYPE(pstgi) == STGIT_IPERSISTFILE);
            hr = STGI_IPERSISTFILE(pstgi)->lpVtbl->Load(STGI_IPERSISTFILE(pstgi),
                                                        rgwchUnicodePath,
                                                        STORAGE_OPEN_MODE_FLAGS);
            break;
      }
   }
   
   return(hr);
}


/*
** SaveToStorage()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HRESULT SaveToStorage(HSTGIFACE hstgi)
{
   HRESULT hr;
   PCSTGIFACE pcstgi;

   ASSERT(IS_VALID_HANDLE(hstgi, STGIFACE));

   pcstgi = (PCSTGIFACE)hstgi;

   switch (STGI_TYPE(pcstgi))
   {
      case STGIT_IPERSISTSTORAGE:
         hr = STGI_IPERSISTSTORAGE(pcstgi)->lpVtbl->IsDirty(STGI_IPERSISTSTORAGE(pcstgi));
         if (hr == S_OK)
         {
            hr = STGI_IPERSISTSTORAGE(pcstgi)->lpVtbl->Save(STGI_IPERSISTSTORAGE(pcstgi),
                                                            STGI_ISTORAGE(pcstgi),
                                                            TRUE);

            if (SUCCEEDED(hr))
            {
               HRESULT hrNext;

               HandsOffStorage((HSTGIFACE)pcstgi);

               hr = STGI_ISTORAGE(pcstgi)->lpVtbl->Commit(STGI_ISTORAGE(pcstgi),
                                                          STGC_DEFAULT);

               hrNext = STGI_IPERSISTSTORAGE(pcstgi)->lpVtbl->SaveCompleted(STGI_IPERSISTSTORAGE(pcstgi),
                                                                            NULL);

               if (SUCCEEDED(hr))
                  hr = hrNext;
            }
         }
         break;

      default:
         ASSERT(STGI_TYPE(pcstgi) == STGIT_IPERSISTFILE);
         hr = STGI_IPERSISTFILE(pcstgi)->lpVtbl->IsDirty(STGI_IPERSISTFILE(pcstgi));
         if (hr == S_OK)
         {
            LPOLESTR posPath;

            hr = STGI_IPERSISTFILE(pcstgi)->lpVtbl->GetCurFile(STGI_IPERSISTFILE(pcstgi),
                                                               &posPath);

            if (hr == S_OK)
            {
               PIMalloc pimalloc;

               hr = STGI_IPERSISTFILE(pcstgi)->lpVtbl->Save(STGI_IPERSISTFILE(pcstgi),
                                                            posPath, FALSE);

               if (SUCCEEDED(hr))
                  hr = STGI_IPERSISTFILE(pcstgi)->lpVtbl->SaveCompleted(STGI_IPERSISTFILE(pcstgi),
                                                                        posPath);

               if (EVAL(GetIMalloc(&pimalloc)))
                  pimalloc->lpVtbl->Free(pimalloc, posPath);
                  /* Do not release pimalloc. */
            }
         }
         break;
   }

   return(hr);
}


/*
** HandsOffStorage()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void HandsOffStorage(HSTGIFACE hstgi)
{
   PCSTGIFACE pcstgi;

   ASSERT(IS_VALID_HANDLE(hstgi, STGIFACE));

   pcstgi = (PCSTGIFACE)hstgi;

   switch (STGI_TYPE(pcstgi))
   {
      case STGIT_IPERSISTSTORAGE:
         EVAL(STGI_IPERSISTSTORAGE(pcstgi)->lpVtbl->HandsOffStorage(STGI_IPERSISTSTORAGE(pcstgi))
              == S_OK);
         break;

      default:
         ASSERT(STGI_TYPE(pcstgi) == STGIT_IPERSISTFILE);
         break;
   }

   return;
}


/*
** GetIMalloc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetIMalloc(PIMalloc *ppimalloc)
{
   BOOL bResult;

   ASSERT(IS_VALID_WRITE_PTR(ppimalloc, PIMalloc));

   ASSERT(! Mpimalloc ||
          IS_VALID_STRUCT_PTR(Mpimalloc, CIMalloc));

   if (! Mpimalloc)
   {
      HRESULT hr;

      hr = CoGetMalloc(MEMCTX_TASK, &Mpimalloc);

      if (SUCCEEDED(hr))
         ASSERT(IS_VALID_STRUCT_PTR(Mpimalloc, CIMalloc));
      else
      {
         ASSERT(! Mpimalloc);

         WARNING_OUT((TEXT("GetIMalloc(): CoGetMalloc() failed, returning %s."),
                      GetHRESULTString(hr)));
      }
   }

   if (Mpimalloc)
   {
      *ppimalloc = Mpimalloc;
      bResult = TRUE;
   }
   else
      bResult = FALSE;

   return(bResult);
}


#ifdef DEBUG

/*
** IsValidHSTGIFACE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHSTGIFACE(HSTGIFACE hstgi)
{
   return(IS_VALID_STRUCT_PTR((PCSTGIFACE)hstgi, CSTGIFACE));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\sortsrch.c ===
/*
 * sortsrch.c - Generic array sorting and searching module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "sortsrch.h"


/* Macros
 *********/

#define ARRAY_ELEMENT(hpa, ai, es)     (((PBYTE)hpa)[(ai) * (es)])


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE void HeapSwap(PVOID, LONG, LONG, size_t, PVOID);
PRIVATE_CODE void HeapSift(PVOID, LONG, LONG, size_t, COMPARESORTEDELEMSPROC, PVOID);


/*
** HeapSwap()
**
** Swaps two elements of an array.
**
** Arguments:     pvArray - pointer to array
**                li1 - index of first element
**                li2 - index of second element
**                stElemSize - length of element in bytes
**                pvTemp - pointer to temporary buffer of at least stElemSize
**                          bytes used for swapping
**
** Returns:       void
**
** Side Effects:  none
*/
PRIVATE_CODE void HeapSwap(PVOID pvArray, LONG li1, LONG li2,
                           size_t stElemSize, PVOID pvTemp)
{
   ASSERT(li1 >= 0);
   ASSERT(li2 >= 0);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvArray, VOID, (max(li1, li2) + 1) * stElemSize));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvTemp, VOID, stElemSize));

   CopyMemory(pvTemp, & ARRAY_ELEMENT(pvArray, li1, stElemSize), stElemSize);
   CopyMemory(& ARRAY_ELEMENT(pvArray, li1, stElemSize), & ARRAY_ELEMENT(pvArray, li2, stElemSize), stElemSize);
   CopyMemory(& ARRAY_ELEMENT(pvArray, li2, stElemSize), pvTemp, stElemSize);

   return;
}


/*
** HeapSift()
**
** Sifts an element down in an array until the partially ordered tree property
** is restored.
**
** Arguments:     hppTable - pointer to array
**                liFirst - index of first element to sift down
**                liLast - index of last element in subtree
**                cep - pointer comparison callback function to be called to
**                      compare elements
**
** Returns:       void
**
** Side Effects:  none
*/
PRIVATE_CODE void HeapSift(PVOID pvArray, LONG liFirst, LONG liLast,
                           size_t stElemSize, COMPARESORTEDELEMSPROC cep, PVOID pvTemp)
{
   LONG li;

   ASSERT(liFirst >= 0);
   ASSERT(liLast >= 0);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvArray, VOID, (max(liFirst, liLast) + 1) * stElemSize));
   ASSERT(IS_VALID_CODE_PTR(cep, COMPARESORTEDELEMSPROC));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvTemp, VOID, stElemSize));

   li = liFirst * 2;

   CopyMemory(pvTemp, & ARRAY_ELEMENT(pvArray, liFirst, stElemSize), stElemSize);

   while (li <= liLast)
   {
      if (li < liLast &&
          (*cep)(& ARRAY_ELEMENT(pvArray, li, stElemSize), & ARRAY_ELEMENT(pvArray, li + 1, stElemSize)) == CR_FIRST_SMALLER)
         li++;

      if ((*cep)(pvTemp, & ARRAY_ELEMENT(pvArray, li, stElemSize)) != CR_FIRST_SMALLER)
         break;

      CopyMemory(& ARRAY_ELEMENT(pvArray, liFirst, stElemSize), & ARRAY_ELEMENT(pvArray, li, stElemSize), stElemSize);

      liFirst = li;

      li *= 2;
   }

   CopyMemory(& ARRAY_ELEMENT(pvArray, liFirst, stElemSize), pvTemp, stElemSize);

   return;
}


#ifdef DEBUG

/*
** InSortedOrder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL InSortedOrder(PVOID pvArray, LONG lcElements,
                                size_t stElemSize, COMPARESORTEDELEMSPROC cep)
{
   BOOL bResult = TRUE;

   ASSERT(lcElements >= 0);
   ASSERT(IS_VALID_READ_BUFFER_PTR(pvArray, VOID, lcElements * stElemSize));
   ASSERT(IS_VALID_CODE_PTR(cep, COMPARESORTEDELEMSPROC));

   if (lcElements > 1)
   {
      LONG li;

      for (li = 0; li < lcElements - 1; li++)
      {
         if ((*cep)(& ARRAY_ELEMENT(pvArray, li, stElemSize),
                    & ARRAY_ELEMENT(pvArray, li + 1, stElemSize))
             == CR_FIRST_LARGER)
         {
            bResult = FALSE;
            ERROR_OUT((TEXT("InSortedOrder(): Element [%ld] %#lx > following element [%ld] %#lx."),
                       li,
                       & ARRAY_ELEMENT(pvArray, li, stElemSize),
                       li + 1,
                       & ARRAY_ELEMENT(pvArray, li + 1, stElemSize)));
            break;
         }
      }
   }

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
** HeapSort()
**
** Sorts an array.  Thanks to Rob's Dad for the cool heap sort algorithm.
**
** Arguments:     pvArray - pointer to base of array
**                lcElements - number of elements in array
**                stElemSize - length of element in bytes
**                cep - element comparison callback function
**                pvTemp - pointer to temporary buffer of at least stElemSize
**                          bytes used for swapping
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void HeapSort(PVOID pvArray, LONG lcElements, size_t stElemSize,
                          COMPARESORTEDELEMSPROC cep, PVOID pvTemp)
{
#ifdef DBLCHECK
   ASSERT((double)lcElements * (double)stElemSize <= (double)LONG_MAX);
#endif

   ASSERT(lcElements >= 0);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvArray, VOID, lcElements * stElemSize));
   ASSERT(IS_VALID_CODE_PTR(cep, COMPARESORTEDELEMSPROC));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvTemp, VOID, stElemSize));

   /* Are there any elements to sort (2 or more)? */

   if (lcElements > 1)
   {
      LONG li;
      LONG liLastUsed = lcElements - 1;

      /* Yes.  Create partially ordered tree. */

      for (li = liLastUsed / 2; li >= 0; li--)
         HeapSift(pvArray, li, liLastUsed, stElemSize, cep, pvTemp);

      for (li = liLastUsed; li >= 1; li--)
      {
         /* Remove minimum from front of heap. */

         HeapSwap(pvArray, 0, li, stElemSize, pvTemp);

         /* Reestablish partially ordered tree. */

         HeapSift(pvArray, 0, li - 1, stElemSize, cep, pvTemp);
      }
   }

   ASSERT(InSortedOrder(pvArray, lcElements, stElemSize, cep));

   return;
}


/*
** BinarySearch()
**
** Searches an array for a given element.
**
** Arguments:     pvArray - pointer to base of array
**                lcElements - number of elements in array
**                stElemSize - length of element in bytes
**                cep - element comparison callback function
**                pvTarget - pointer to target element to search for
**                pliTarget - pointer to LONG to be filled in with index of
**                             target element if found
**
** Returns:       TRUE if target element found, or FALSE if not.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL BinarySearch(PVOID pvArray, LONG lcElements,
                              size_t stElemSize, COMPARESORTEDELEMSPROC cep,
                              PCVOID pcvTarget, PLONG pliTarget)
{
   BOOL bFound = FALSE;

#ifdef DBLCHECK
   ASSERT((double)lcElements * (double)stElemSize <= (double)ULONG_MAX);
#endif

   ASSERT(lcElements >= 0);
   ASSERT(IS_VALID_READ_BUFFER_PTR(pvArray, VOID, lcElements * stElemSize));
   ASSERT(IS_VALID_CODE_PTR(cep, COMPARESORTEDELEMSPROC));
   ASSERT(IS_VALID_READ_BUFFER_PTR(pcvTarget, VOID, stElemSize));
   ASSERT(IS_VALID_WRITE_PTR(pliTarget, LONG));

   /* Are there any elements to search through? */

   if (lcElements > 0)
   {
      LONG liLow = 0;
      LONG liMiddle = 0;
      LONG liHigh = lcElements - 1;
      COMPARISONRESULT cr = CR_EQUAL;

      /* Yes.  Search for the target element. */

      /*
       * At the end of the penultimate iteration of this loop:
       *
       * liLow == liMiddle == liHigh.
       */

      while (liLow <= liHigh)
      {
         liMiddle = (liLow + liHigh) / 2;

         cr = (*cep)(pcvTarget, & ARRAY_ELEMENT(pvArray, liMiddle, stElemSize));

         if (cr == CR_FIRST_SMALLER)
            liHigh = liMiddle - 1;
         else if (cr == CR_FIRST_LARGER)
            liLow = liMiddle + 1;
         else
         {
            *pliTarget = liMiddle;
            bFound = TRUE;
            break;
         }
      }
   }

   return(bFound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\stock.h ===
/*
 * stock.h - Stock header file.
 */


/* Constants
 ************/

#define FOREVER                  for (;;)

#define INVALID_SEEK_POSITION    (0xffffffff)

#define EMPTY_STRING             TEXT("")
#define SLASH_SLASH              TEXT("\\\\")

#define EQUAL                    TEXT('=')
#define SPACE                    TEXT(' ')
#define TAB                      TEXT('\t')
#define COLON                    TEXT(':')
#define COMMA                    TEXT(',')
#define PERIOD                   TEXT('.')
#define SLASH                    TEXT('\\')
#define BACKSLASH                TEXT('/')
#define ASTERISK                 TEXT('*')
#define QMARK                    TEXT('?')

/* linkage */

/* #pragma data_seg() doesn't work for variables defined extern. */
#define PUBLIC_CODE
#define PUBLIC_DATA
/* Make private functions and data public for profiling and debugging. */
#define PRIVATE_CODE             PUBLIC_CODE
#define PRIVATE_DATA             PUBLIC_DATA
#define INLINE                   __inline

/* limits */

#define WORD_MAX                 USHRT_MAX
#define DWORD_MAX                ULONG_MAX
#define SIZE_T_MAX               DWORD_MAX
#define PTR_MAX                  ((PCVOID)DWORD_MAX)

/* file system constants */

#define MAX_PATH_LEN             MAX_PATH
#define MAX_NAME_LEN             MAX_PATH
#define MAX_FOLDER_DEPTH         (MAX_PATH / 2)
#define DRIVE_ROOT_PATH_LEN      (4)

/* size macros */

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#define SIZEOF(a)       sizeof(a)

/* invalid thread ID */

#define INVALID_THREAD_ID        (0xffffffff)

/* file-related flag combinations */

#define ALL_FILE_ACCESS_FLAGS          (GENERIC_READ |\
                                        GENERIC_WRITE)

#define ALL_FILE_SHARING_FLAGS         (FILE_SHARE_READ |\
                                        FILE_SHARE_WRITE)

#ifdef WINNT
#define ALL_FILE_ATTRIBUTES            (FILE_ATTRIBUTE_READONLY |\
                                            FILE_ATTRIBUTE_HIDDEN |\
                                            FILE_ATTRIBUTE_SYSTEM |\
                                            FILE_ATTRIBUTE_DIRECTORY |\
                                            FILE_ATTRIBUTE_ARCHIVE |\
                                            FILE_ATTRIBUTE_NORMAL |\
                                            FILE_ATTRIBUTE_TEMPORARY)
#else
#define ALL_FILE_ATTRIBUTES            (FILE_ATTRIBUTE_READONLY |\
                                            FILE_ATTRIBUTE_HIDDEN |\
                                        FILE_ATTRIBUTE_ARCHIVE |\
                                        FILE_ATTRIBUTE_NORMAL |\
                                        FILE_ATTRIBUTE_TEMPORARY |\
                                        FILE_ATTRIBUTE_ATOMIC_WRITE |\
                                        FILE_ATTRIBUTE_XACTION_WRITE)
#endif

#define ALL_FILE_FLAGS                 (FILE_FLAG_WRITE_THROUGH |\
                                        FILE_FLAG_OVERLAPPED |\
                                        FILE_FLAG_NO_BUFFERING |\
                                        FILE_FLAG_RANDOM_ACCESS |\
                                        FILE_FLAG_SEQUENTIAL_SCAN |\
                                        FILE_FLAG_DELETE_ON_CLOSE |\
                                        FILE_FLAG_BACKUP_SEMANTICS |\
                                        FILE_FLAG_POSIX_SEMANTICS)

#define ALL_FILE_ATTRIBUTES_AND_FLAGS  (ALL_FILE_ATTRIBUTES |\
                                        ALL_FILE_FLAGS)


/* Macros
 *********/

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

/* character manipulation */

#define IS_SLASH(ch)                      ((ch) == SLASH || (ch) == BACKSLASH)

/* bit flag manipulation */

#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define CLEAR_FLAG(dwAllFlags, dwFlag)    ((dwAllFlags) &= (~dwFlag))

#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))
#define IS_FLAG_CLEAR(dwAllFlags, dwFlag) (! (IS_FLAG_SET(dwAllFlags, dwFlag)))

/* array element count */

#define ARRAY_ELEMENTS(rg)                (sizeof(rg) / sizeof((rg)[0]))

/* file attribute manipulation */

#define IS_ATTR_DIR(attr)                 (IS_FLAG_SET((attr), FILE_ATTRIBUTE_DIRECTORY))
#define IS_ATTR_VOLUME(attr)              (IS_FLAG_SET((attr), FILE_ATTRIBUTE_VOLUME))


/* Types
 ********/

typedef const void *PCVOID;
typedef const INT CINT;
typedef const INT *PCINT;
typedef const UINT CUINT;
typedef const UINT *PCUINT;
typedef const BYTE CBYTE;
typedef const BYTE *PCBYTE;
typedef const WORD CWORD;
typedef const WORD *PCWORD;
typedef const DWORD CDWORD;
typedef const DWORD *PCDWORD;
typedef const CRITICAL_SECTION CCRITICAL_SECTION;
typedef const CRITICAL_SECTION *PCCRITICAL_SECTION;
typedef const FILETIME CFILETIME;
typedef const FILETIME *PCFILETIME;
typedef const SECURITY_ATTRIBUTES CSECURITY_ATTRIBUTES;
typedef const SECURITY_ATTRIBUTES *PCSECURITY_ATTRIBUTES;
typedef const WIN32_FIND_DATA CWIN32_FIND_DATA;
typedef const WIN32_FIND_DATA *PCWIN32_FIND_DATA;

DECLARE_STANDARD_TYPES(HICON);
DECLARE_STANDARD_TYPES(NMHDR);

#ifndef _COMPARISONRESULT_DEFINED_

/* comparison result */

typedef enum _comparisonresult
{
   CR_FIRST_SMALLER = -1,
   CR_EQUAL = 0,
   CR_FIRST_LARGER = +1
}
COMPARISONRESULT;
DECLARE_STANDARD_TYPES(COMPARISONRESULT);

#define _COMPARISONRESULT_DEFINED_

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\string2.h ===
/*
 * string.h - String table ADT description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HSTRING);
DECLARE_STANDARD_TYPES(HSTRING);
DECLARE_HANDLE(HSTRINGTABLE);
DECLARE_STANDARD_TYPES(HSTRINGTABLE);

/* count of hash buckets in a string table */

typedef UINT HASHBUCKETCOUNT;
DECLARE_STANDARD_TYPES(HASHBUCKETCOUNT);

/* string table hash function */

typedef HASHBUCKETCOUNT (*STRINGTABLEHASHFUNC)(LPCTSTR, HASHBUCKETCOUNT);

/* new string table */

typedef struct _newstringtable
{
   HASHBUCKETCOUNT hbc;
}
NEWSTRINGTABLE;
DECLARE_STANDARD_TYPES(NEWSTRINGTABLE);


/* Prototypes
 *************/

/* string.c */

extern BOOL CreateStringTable(PCNEWSTRINGTABLE, PHSTRINGTABLE);
extern void DestroyStringTable(HSTRINGTABLE);
extern BOOL AddString(LPCTSTR pcsz, HSTRINGTABLE hst, STRINGTABLEHASHFUNC pfnHashFunc, PHSTRING phs);
extern void DeleteString(HSTRING);
extern void LockString(HSTRING);
extern COMPARISONRESULT CompareStringsI(HSTRING, HSTRING);
extern LPCTSTR GetString(HSTRING);

#if defined(DEBUG) || defined (VSTF)

extern BOOL IsValidHSTRING(HSTRING);
extern BOOL IsValidHSTRINGTABLE(HSTRINGTABLE);

#endif

#ifdef DEBUG

extern ULONG GetStringCount(HSTRINGTABLE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\stub.c ===
/*
 * stub.c - Stub ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"


/* Macros
 *********/

/* get a pointer to the stub type descriptor for a STUB */

#define GetStubTypeDescriptor(pcs)     (&(Mrgcstd[pcs->st]))


/* Types
 ********/

/* stub functions */

typedef TWINRESULT (*UNLINKSTUBPROC)(PSTUB);
typedef void (*DESTROYSTUBPROC)(PSTUB);
typedef void (*LOCKSTUBPROC)(PSTUB);
typedef void (*UNLOCKSTUBPROC)(PSTUB);

/* stub type descriptor */

typedef struct _stubtypedescriptor
{
   UNLINKSTUBPROC UnlinkStub;

   DESTROYSTUBPROC DestroyStub;

   LOCKSTUBPROC LockStub;

   UNLOCKSTUBPROC UnlockStub;
}
STUBTYPEDESCRIPTOR;
DECLARE_STANDARD_TYPES(STUBTYPEDESCRIPTOR);


/* Module Prototypes
 ********************/

PRIVATE_CODE void LockSingleStub(PSTUB);
PRIVATE_CODE void UnlockSingleStub(PSTUB);

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsValidStubType(STUBTYPE);

#endif

#ifdef DEBUG

PRIVATE_CODE LPCTSTR GetStubName(PCSTUB);

#endif


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

/* stub type descriptors */

/* Cast off compiler complaints about pointer argument mismatch. */

PRIVATE_DATA CONST STUBTYPEDESCRIPTOR Mrgcstd[] =
{
   /* object twin STUB descriptor */

   {
      (UNLINKSTUBPROC)UnlinkObjectTwin,
      (DESTROYSTUBPROC)DestroyObjectTwin,
      LockSingleStub,
      UnlockSingleStub
   },

   /* twin family STUB descriptor */

   {
      (UNLINKSTUBPROC)UnlinkTwinFamily,
      (DESTROYSTUBPROC)DestroyTwinFamily,
      LockSingleStub,
      UnlockSingleStub
   },

   /* folder pair STUB descriptor */

   {
      (UNLINKSTUBPROC)UnlinkFolderPair,
      (DESTROYSTUBPROC)DestroyFolderPair,
      (LOCKSTUBPROC)LockFolderPair,
      (UNLOCKSTUBPROC)UnlockFolderPair
   }
};

#pragma data_seg()


/***************************** Private Functions *****************************/


/*
** LockSingleStub()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void LockSingleStub(PSTUB ps)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   ASSERT(IsStubFlagClear(ps, STUB_FL_UNLINKED));

   ASSERT(ps->ulcLock < ULONG_MAX);
   ps->ulcLock++;

   return;
}


/*
** UnlockSingleStub()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void UnlockSingleStub(PSTUB ps)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   if (EVAL(ps->ulcLock > 0))
   {
      ps->ulcLock--;

      if (! ps->ulcLock &&
          IsStubFlagSet(ps, STUB_FL_UNLINKED))
         DestroyStub(ps);
   }

   return;
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidStubType()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidStubType(STUBTYPE st)
{
   BOOL bResult;

   switch (st)
   {
      case ST_OBJECTTWIN:
      case ST_TWINFAMILY:
      case ST_FOLDERPAIR:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidStubType(): Invalid STUB type %d."),
                    st));
   }

   return(bResult);
}

#endif


#ifdef DEBUG

/*
** GetStubName()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE LPCTSTR GetStubName(PCSTUB pcs)
{
   LPCTSTR pcszStubName;

   ASSERT(IS_VALID_STRUCT_PTR(pcs, CSTUB));

   switch (pcs->st)
   {
      case ST_OBJECTTWIN:
         pcszStubName = TEXT("object twin");
         break;

      case ST_TWINFAMILY:
         pcszStubName = TEXT("twin family");
         break;

      case ST_FOLDERPAIR:
         pcszStubName = TEXT("folder twin");
         break;

      default:
         ERROR_OUT((TEXT("GetStubName() called on unrecognized stub type %d."),
                    pcs->st));
         pcszStubName = TEXT("UNKNOWN");
         break;
   }

   ASSERT(IS_VALID_STRING_PTR(pcszStubName, CSTR));

   return(pcszStubName);
}

#endif


/****************************** Public Functions *****************************/


/*
** InitStub()
**
** Initializes a stub.
**
** Arguments:     ps - pointer to stub to be initialized
**                st - type of stub
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void InitStub(PSTUB ps, STUBTYPE st)
{
   ASSERT(IS_VALID_WRITE_PTR(ps, STUB));
   ASSERT(IsValidStubType(st));

   ps->st = st;
   ps->ulcLock = 0;
   ps->dwFlags = 0;

   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   return;
}


/*
** DestroyStub()
**
** Destroys a stub.
**
** Arguments:     ps - pointer to stub to be destroyed
**
** Returns:       TWINRESULT
**
** Side Effects:  Depends upon stub type.
*/
PUBLIC_CODE TWINRESULT DestroyStub(PSTUB ps)
{
   TWINRESULT tr;
   PCSTUBTYPEDESCRIPTOR pcstd;

   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

#ifdef DEBUG

   if (IsStubFlagSet(ps, STUB_FL_UNLINKED) &&
       ps->ulcLock > 0)
      WARNING_OUT((TEXT("DestroyStub() called on unlinked locked %s stub %#lx."),
                   GetStubName(ps),
                   ps));

#endif

   pcstd = GetStubTypeDescriptor(ps);

   /* Is the stub already unlinked? */

   if (IsStubFlagSet(ps, STUB_FL_UNLINKED))
      /* Yes. */
      tr = TR_SUCCESS;
   else
      /* No.  Unlink it. */
      tr = (*(pcstd->UnlinkStub))(ps);

   /* Is the stub still locked? */

   if (tr == TR_SUCCESS && ! ps->ulcLock)
      /* No.  Wipe it out. */
      (*(pcstd->DestroyStub))(ps);

   return(tr);
}


/*
** LockStub()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void LockStub(PSTUB ps)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   (*(GetStubTypeDescriptor(ps)->LockStub))(ps);

   return;
}


/*
** UnlockStub()
**
** Unlocks a stub.  Carries out any pending deletion on the stub.
**
** Arguments:     ps - pointer to stub to be unlocked
**
** Returns:       void
**
** Side Effects:  If the stub is unlinked and the lock count decreases to 0
**                after unlocking, the stub is deleted.
*/
PUBLIC_CODE void UnlockStub(PSTUB ps)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   (*(GetStubTypeDescriptor(ps)->UnlockStub))(ps);

   return;
}


/*
** GetStubFlags()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE DWORD GetStubFlags(PCSTUB pcs)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcs, CSTUB));

   return(pcs->dwFlags);
}


/*
** SetStubFlag()
**
** Sets given flag in a stub.  Other flags in stub are not affected.
**
** Arguments:     ps - pointer to stub whose flags are to be set
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void SetStubFlag(PSTUB ps, DWORD dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_STUB_FLAGS));

   SET_FLAG(ps->dwFlags, dwFlags);

   return;
}


/*
** ClearStubFlag()
**
** Clears given flag in a stub.  Other flags in stub are not affected.
**
** Arguments:     ps - pointer to stub whose flags are to be set
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void ClearStubFlag(PSTUB ps, DWORD dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_STUB_FLAGS));

   CLEAR_FLAG(ps->dwFlags, dwFlags);

   return;
}


/*
** IsStubFlagSet()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsStubFlagSet(PCSTUB pcs, DWORD dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcs, CSTUB));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_STUB_FLAGS));

   return(IS_FLAG_SET(pcs->dwFlags, dwFlags));
}


/*
** IsStubFlagClear()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsStubFlagClear(PCSTUB pcs, DWORD dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcs, CSTUB));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_STUB_FLAGS));

   return(IS_FLAG_CLEAR(pcs->dwFlags, dwFlags));
}


#ifdef VSTF

/*
** IsValidPCSTUB()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCSTUB(PCSTUB pcs)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pcs, CSTUB) &&
       IsValidStubType(pcs->st) &&
       FLAGS_ARE_VALID(pcs->dwFlags, ALL_STUB_FLAGS))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\string.c ===
/*
 * string.c - String table ADT module.
 */

/*

   The string table ADT implemented in this module is set up as a hash table
with HASH_TABLE_SIZE buckets.  A hash function is calculated for each string to
determine its bucket.  Multiple strings in a single bucket are stored in a
linked list.  The string hash table allows us to keep only one copy of a string
that is used multiple times.  Strings are allocated in the heap by
AllocateMemory().

   Every string has a list node structure associated with it.  A string is
accessed through its associated list node.  Each hash bucket is a list of
string nodes.  A handle to a string table is a pointer to the base of the
string table's array of hash buckets.  String tables are allocated in the heap
by AllocateMemory().  Each element in an array of hash buckets is a handle to a
list of strings in the hash bucket.  A handle to a string is a handle to a node
in the string's hash bucket's list.

   Hash table ADTs are predicated on the idea that hash buckets will typically
be shallow, so the search of a hash bucket will not take horrendously long.
The data objects in hash buckets should be stored in sorted order to reduce
search time.  If hash buckets get too deep, increase the hash table size.
Ideally, the hash table should be implemented as a container class that hashes
arbitrary data objects given an initial hash table size, the size of the
objects to be hashed, a hash function, and a data object comparison function.

   Currently the hash table ADT is restricted to strings, the strings in each
hash bucket are stored in sorted order, and hash buckets are binary searched.

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Types
 ********/

/* string table */

typedef struct _stringtable
{
   /* number of hash buckets in string table */

   HASHBUCKETCOUNT hbc;

   /* pointer to array of hash buckets (HLISTs) */

   PHLIST phlistHashBuckets;
}
STRINGTABLE;
DECLARE_STANDARD_TYPES(STRINGTABLE);

/* string heap structure */

typedef struct _string
{
   /* lock count of string */

   ULONG ulcLock;

   /* actual string */

   TCHAR string[1];
}
STRING;
DECLARE_STANDARD_TYPES(STRING);

/* string table database structure header */

typedef struct _stringtabledbheader
{
   /*
    * length of longest string in string table, not including null terminator
    */

   DWORD dwcbMaxStringLen;

   /* number of strings in string table */

   LONG lcStrings;
}
STRINGTABLEDBHEADER;
DECLARE_STANDARD_TYPES(STRINGTABLEDBHEADER);

/* database string header */

typedef struct _dbstringheader
{
   /* old handle to this string */

   HSTRING hsOld;
}
DBSTRINGHEADER;
DECLARE_STANDARD_TYPES(DBSTRINGHEADER);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE COMPARISONRESULT StringSearchCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT StringSortCmp(PCVOID, PCVOID);
PRIVATE_CODE BOOL UnlockString(PSTRING);
PRIVATE_CODE BOOL FreeStringWalker(PVOID, PVOID);
PRIVATE_CODE void FreeHashBucket(HLIST);
PRIVATE_CODE TWINRESULT WriteHashBucket(HCACHEDFILE, HLIST, PLONG, PDWORD);
PRIVATE_CODE TWINRESULT WriteString(HCACHEDFILE, HNODE, PSTRING, PDWORD);
PRIVATE_CODE TWINRESULT ReadString(HCACHEDFILE, HSTRINGTABLE, HHANDLETRANS, LPTSTR, DWORD);
PRIVATE_CODE TWINRESULT SlowReadString(HCACHEDFILE, LPTSTR, DWORD);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCNEWSTRINGTABLE(PCNEWSTRINGTABLE);
PRIVATE_CODE BOOL IsValidPCSTRING(PCSTRING);
PRIVATE_CODE BOOL IsValidPCSTRINGTABLE(PCSTRINGTABLE);

#endif


/*
** StringSearchCmp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE COMPARISONRESULT StringSearchCmp(PCVOID pcszPath, PCVOID pcstring)
{
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_STRUCT_PTR(pcstring, CSTRING));

   return(MapIntToComparisonResult(lstrcmp((LPCTSTR)pcszPath,
                                           (LPCTSTR)&(((PCSTRING)pcstring)->string))));
}


/*
** StringSortCmp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE COMPARISONRESULT StringSortCmp(PCVOID pcstring1, PCVOID pcstring2)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcstring1, CSTRING));
   ASSERT(IS_VALID_STRUCT_PTR(pcstring2, CSTRING));

   return(MapIntToComparisonResult(lstrcmp((LPCTSTR)&(((PCSTRING)pcstring1)->string),
                                           (LPCTSTR)&(((PCSTRING)pcstring2)->string))));
}


/*
** UnlockString()
**
** Decrements a string's lock count.
**
** Arguments:
**
** Returns:       void
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL UnlockString(PSTRING pstring)
{
   ASSERT(IS_VALID_STRUCT_PTR(pstring, CSTRING));

   /* Is the lock count going to underflow? */

   if (EVAL(pstring->ulcLock > 0))
      pstring->ulcLock--;

   return(pstring->ulcLock > 0);
}


/*
** FreeStringWalker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/

#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL FreeStringWalker(PVOID pstring, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pstring, CSTRING));
   ASSERT(! pvUnused);

   FreeMemory(pstring);

   return(TRUE);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** FreeHashBucket()
**
** Frees the strings in a hash bucket, and the hash bucket's string list.
**
** Arguments:     hlistHashBucket - handle to hash bucket's list of strings
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., this function ignores the lock counts of the strings in the hash
** bucket.  All strings in the hash bucket are freed.
*/
PRIVATE_CODE void FreeHashBucket(HLIST hlistHashBucket)
{
   ASSERT(! hlistHashBucket || IS_VALID_HANDLE(hlistHashBucket, LIST));

   /* Are there any strings in this hash bucket to delete? */

   if (hlistHashBucket)
   {
      /* Yes.  Delete all strings in list. */

      EVAL(WalkList(hlistHashBucket, &FreeStringWalker, NULL));

      /* Delete hash bucket string list. */

      DestroyList(hlistHashBucket);
   }

   return;
}


/*
** MyGetStringLen()
**
** Retrieves the length of a string in a string table.
**
** Arguments:     pcstring - pointer to string whose length is to be
**                            determined
**
** Returns:       Length of string in bytes, not including null terminator.
**
** Side Effects:  none
*/
PRIVATE_CODE int MyGetStringLen(PCSTRING pcstring)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcstring, CSTRING));

   return(lstrlen(pcstring->string) * sizeof(TCHAR));
}


/*
** WriteHashBucket()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT WriteHashBucket(HCACHEDFILE hcf,
                                           HLIST hlistHashBucket,
                                           PLONG plcStrings,
                                           PDWORD pdwcbMaxStringLen)
{
   TWINRESULT tr = TR_SUCCESS;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(! hlistHashBucket || IS_VALID_HANDLE(hlistHashBucket, LIST));
   ASSERT(IS_VALID_WRITE_PTR(plcStrings, LONG));
   ASSERT(IS_VALID_WRITE_PTR(pdwcbMaxStringLen, DWORD));

   /* Any strings in this hash bucket? */

   *plcStrings = 0;
   *pdwcbMaxStringLen = 0;

   if (hlistHashBucket)
   {
      BOOL bContinue;
      HNODE hnode;

      /* Yes.  Walk hash bucket, saving each string. */

      for (bContinue = GetFirstNode(hlistHashBucket, &hnode);
           bContinue;
           bContinue = GetNextNode(hnode, &hnode))
      {
         PSTRING pstring;

         pstring = (PSTRING)GetNodeData(hnode);

         ASSERT(IS_VALID_STRUCT_PTR(pstring, CSTRING));

         /*
          * As a sanity check, don't save any string with a lock count of 0.  A
          * 0 lock count implies that the string has not been referenced since
          * it was restored from the database, or something is broken.
          */

         if (pstring->ulcLock > 0)
         {
            DWORD dwcbStringLen;

            tr = WriteString(hcf, hnode, pstring, &dwcbStringLen);

            if (tr == TR_SUCCESS)
            {
               if (dwcbStringLen > *pdwcbMaxStringLen)
                  *pdwcbMaxStringLen = dwcbStringLen;

               ASSERT(*plcStrings < LONG_MAX);
               (*plcStrings)++;
            }
            else
               break;
         }
         else
            ERROR_OUT((TEXT("WriteHashBucket(): String \"%s\" has 0 lock count and will not be saved."),
                       pstring->string));
      }
   }

   return(tr);
}


/*
** WriteString()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT WriteString(HCACHEDFILE hcf, HNODE hnodeOld,
                                    PSTRING pstring, PDWORD pdwcbStringLen)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
   DBSTRINGHEADER dbsh;

   /* (+ 1) for null terminator. */

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hnodeOld, NODE));
   ASSERT(IS_VALID_STRUCT_PTR(pstring, CSTRING));
   ASSERT(IS_VALID_READ_BUFFER_PTR(pstring, STRING, sizeof(STRING) + MyGetStringLen(pstring) + sizeof(TCHAR) - sizeof(pstring->string)));
   ASSERT(IS_VALID_WRITE_PTR(pdwcbStringLen, DWORD));

   /* Create string header. */

   dbsh.hsOld = (HSTRING)hnodeOld;

   /* Save string header and string. */

   if (WriteToCachedFile(hcf, (PCVOID)&dbsh, sizeof(dbsh), NULL))
   {
      LPSTR pszAnsi;

      /* (+ 1) for null terminator. */

      *pdwcbStringLen = MyGetStringLen(pstring) + SIZEOF(TCHAR);

      // If its unicode, convert the string to ansi before writing it out

      #ifdef UNICODE
      {
          pszAnsi = LocalAlloc(LPTR, *pdwcbStringLen);
          if (NULL == pszAnsi)
          {
            return tr;
          }
          WideCharToMultiByte(CP_ACP, 0, pstring->string, -1, pszAnsi, *pdwcbStringLen, NULL, NULL);

          // We should always have a string at this point that can be converted losslessly

          #if (defined(DEBUG) || defined(DBG)) && defined(UNICODE)
          {
                WCHAR szUnicode[MAX_PATH*2];
                MultiByteToWideChar(CP_ACP, 0, pszAnsi, -1, szUnicode, ARRAYSIZE(szUnicode));
                ASSERT(0 == lstrcmp(szUnicode, pstring->string));
          }
          #endif

          if (WriteToCachedFile(hcf, (PCVOID) pszAnsi, lstrlenA(pszAnsi) + 1, NULL))
            tr = TR_SUCCESS;

          LocalFree(pszAnsi);
     }
     #else
      
          if (WriteToCachedFile(hcf, (PCVOID)&(pstring->string), (UINT)*pdwcbStringLen, NULL))
             tr = TR_SUCCESS;
 
     #endif

   }

   return(tr);
}


/*
** ReadString()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT ReadString(HCACHEDFILE hcf, HSTRINGTABLE hst,
                                      HHANDLETRANS hht, LPTSTR pszStringBuf,
                                      DWORD dwcbStringBufLen)
{
   TWINRESULT tr;
   DBSTRINGHEADER dbsh;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));
   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszStringBuf, STR, (UINT)dwcbStringBufLen));

   if (ReadFromCachedFile(hcf, &dbsh, sizeof(dbsh), &dwcbRead) &&
       dwcbRead == sizeof(dbsh))
   {
      tr = SlowReadString(hcf, pszStringBuf, dwcbStringBufLen);

      if (tr == TR_SUCCESS)
      {
         HSTRING hsNew;

         if (AddString(pszStringBuf, hst, GetHashBucketIndex, &hsNew))
         {
            /*
             * We must undo the LockString() performed by AddString() to
             * maintain the correct string lock count.  N.b., the lock count of
             * a string may be > 0 even after unlocking since the client may
             * already have added the string to the given string table.
             */

            UnlockString((PSTRING)GetNodeData((HNODE)hsNew));

            if (! AddHandleToHandleTranslator(hht, (HGENERIC)(dbsh.hsOld), (HGENERIC)hsNew))
            {
               DeleteNode((HNODE)hsNew);

               tr = TR_CORRUPT_BRIEFCASE;
            }
         }
         else
            tr = TR_OUT_OF_MEMORY;
      }
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


/*
** SlowReadString()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT SlowReadString(HCACHEDFILE hcf, LPTSTR pszStringBuf,
                                          DWORD dwcbStringBufLen)
{
   TWINRESULT tr = TR_CORRUPT_BRIEFCASE;
   LPTSTR pszStringBufEnd;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszStringBuf, STR, (UINT)dwcbStringBufLen));

   pszStringBufEnd = pszStringBuf + dwcbStringBufLen;

   // The database strings are always written ANSI, so if we are running unicode,
   // we need to convert as we go

   #ifdef UNICODE
   {
        LPSTR pszAnsiEnd;
        LPSTR pszAnsiStart;
        LPSTR pszAnsi = LocalAlloc(LPTR, dwcbStringBufLen);
        pszAnsiStart  = pszAnsi;
        pszAnsiEnd    = pszAnsi + dwcbStringBufLen;
            
        if (NULL == pszAnsi)
        {
            return tr;
        }

        while (pszAnsi < pszAnsiEnd &&
              ReadFromCachedFile(hcf, pszAnsi, sizeof(*pszAnsi), &dwcbRead) &&
              dwcbRead == sizeof(*pszAnsi))
        {
            if (*pszAnsi)
                pszAnsi++;
            else
            {
                tr = TR_SUCCESS;
                break;
            }
        }

       if (tr == TR_SUCCESS)
       {
            MultiByteToWideChar(CP_ACP, 0, pszAnsiStart, -1, pszStringBuf, dwcbStringBufLen / sizeof(TCHAR));
       }

       LocalFree(pszAnsiStart);
    }
    #else

       while (pszStringBuf < pszStringBufEnd &&
              ReadFromCachedFile(hcf, pszStringBuf, sizeof(*pszStringBuf), &dwcbRead) &&
              dwcbRead == sizeof(*pszStringBuf))
       {
          if (*pszStringBuf)
             pszStringBuf++;
          else
          {
             tr = TR_SUCCESS;
             break;
          }
       }

    #endif

   return(tr);
}


#ifdef VSTF

/*
** IsValidPCNEWSTRINGTABLE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCNEWSTRINGTABLE(PCNEWSTRINGTABLE pcnst)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pcnst, CNEWSTRINGTABLE) &&
       EVAL(pcnst->hbc > 0))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}


/*
** IsValidPCSTRING()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCSTRING(PCSTRING pcs)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pcs, CSTRING) &&
       IS_VALID_STRING_PTR(pcs->string, CSTR))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}


/*
** IsValidStringWalker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/

#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL IsValidStringWalker(PVOID pstring, PVOID pvUnused)
{
   ASSERT(! pvUnused);

   return(IS_VALID_STRUCT_PTR(pstring, CSTRING));
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** IsValidPCSTRINGTABLE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCSTRINGTABLE(PCSTRINGTABLE pcst)
{
   BOOL bResult = FALSE;

   if (IS_VALID_READ_PTR(pcst, CSTRINGTABLE) &&
       EVAL(pcst->hbc > 0) &&
       IS_VALID_READ_BUFFER_PTR(pcst->phlistHashBuckets, HLIST, pcst->hbc * sizeof((pcst->phlistHashBuckets)[0])))
   {
      HASHBUCKETCOUNT hbc;

      for (hbc = 0; hbc < pcst->hbc; hbc++)
      {
         HLIST hlistHashBucket;

         hlistHashBucket = (pcst->phlistHashBuckets)[hbc];

         if (hlistHashBucket)
         {
            if (! IS_VALID_HANDLE(hlistHashBucket, LIST) ||
                ! WalkList(hlistHashBucket, &IsValidStringWalker, NULL))
               break;
         }
      }

      if (hbc == pcst->hbc)
         bResult = TRUE;
   }

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/

/*
** CreateStringTable()
**
** Creates a new string table.
**
** Arguments:     pcnszt - pointer to NEWSTRINGTABLE descibing string table to
**                          be created
**
** Returns:       Handle to new string table if successful, or NULL if
**                unsuccessful.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreateStringTable(PCNEWSTRINGTABLE pcnszt,
                                     PHSTRINGTABLE phst)
{
   PSTRINGTABLE pst;

   ASSERT(IS_VALID_STRUCT_PTR(pcnszt, CNEWSTRINGTABLE));
   ASSERT(IS_VALID_WRITE_PTR(phst, HSTRINGTABLE));

   /* Try to allocate new string table structure. */

   *phst = NULL;

   if (AllocateMemory(sizeof(*pst), &pst))
   {
      PHLIST phlistHashBuckets;

      /* Try to allocate hash bucket array. */

#ifdef DBLCHECK
      ASSERT((double)(pcnszt->hbc) * (double)(sizeof(*phlistHashBuckets)) <= (double)SIZE_T_MAX);
#endif

      if (AllocateMemory(pcnszt->hbc * sizeof(*phlistHashBuckets), (PVOID *)(&phlistHashBuckets)))
      {
         HASHBUCKETCOUNT bc;

         /* Successs!  Initialize STRINGTABLE fields. */

         pst->phlistHashBuckets = phlistHashBuckets;
         pst->hbc = pcnszt->hbc;

         /* Initialize all hash buckets to NULL. */

         for (bc = 0; bc < pcnszt->hbc; bc++)
            phlistHashBuckets[bc] = NULL;

         *phst = (HSTRINGTABLE)pst;

         ASSERT(IS_VALID_HANDLE(*phst, STRINGTABLE));
      }
      else
         /* Free string table structure. */
         FreeMemory(pst);
   }

   return(*phst != NULL);
}


/*
** DestroyStringTable()
**
** Destroys a string table.
**
** Arguments:     hst - handle to string table to be destroyed
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyStringTable(HSTRINGTABLE hst)
{
   HASHBUCKETCOUNT bc;

   ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));

   /* Traverse array of hash bucket heads, freeing hash bucket strings. */

   for (bc = 0; bc < ((PSTRINGTABLE)hst)->hbc; bc++)
      FreeHashBucket(((PSTRINGTABLE)hst)->phlistHashBuckets[bc]);

   /* Free array of hash buckets. */

   FreeMemory(((PSTRINGTABLE)hst)->phlistHashBuckets);

   /* Free string table structure. */

   FreeMemory((PSTRINGTABLE)hst);

   return;
}


/*
** AddString()
**
** Adds a string to a string table.
**
** Arguments:     pcsz - pointer to string to be added
**                hst - handle to string table that string is to be added to
**
** Returns:       Handle to new string if successful, or NULL if unsuccessful.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL AddString(LPCTSTR pcsz, HSTRINGTABLE hst, 
                           STRINGTABLEHASHFUNC pfnHashFunc, PHSTRING phs)
{
   BOOL bResult;
   HASHBUCKETCOUNT hbcNew;
   BOOL bFound;
   HNODE hnode;
   PHLIST phlistHashBucket;

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));
   ASSERT(IS_VALID_CODE_PTR(pfnHashFunc, STRINGTABLEHASHFUNC));
   ASSERT(IS_VALID_WRITE_PTR(phs, HSTRING));

   /* Find appropriate hash bucket. */

   hbcNew = pfnHashFunc(pcsz, ((PSTRINGTABLE)hst)->hbc);

   ASSERT(hbcNew < ((PSTRINGTABLE)hst)->hbc);

   phlistHashBucket = &(((PSTRINGTABLE)hst)->phlistHashBuckets[hbcNew]);

   if (*phlistHashBucket)
   {
      /* Search the hash bucket for the string. */

      bFound = SearchSortedList(*phlistHashBucket, &StringSearchCmp, pcsz,
                                &hnode);
      bResult = TRUE;
   }
   else
   {
      NEWLIST nl;

      /* Create a string list for this hash bucket. */

      bFound = FALSE;

      nl.dwFlags = NL_FL_SORTED_ADD;

      bResult = CreateList(&nl, phlistHashBucket);
   }

   /* Do we have a hash bucket for the string? */

   if (bResult)
   {
      /* Yes.  Is the string already in the hash bucket? */

      if (bFound)
      {
         /* Yes. */

         LockString((HSTRING)hnode);
         *phs = (HSTRING)hnode;
      }
      else
      {
         /* No.  Create it. */

         PSTRING pstringNew;

         /* (+ 1) for null terminator. */

         bResult = AllocateMemory(sizeof(*pstringNew) - sizeof(pstringNew->string)
                                  + (lstrlen(pcsz) + 1) * sizeof(TCHAR), &pstringNew);

         if (bResult)
         {
            HNODE hnodeNew;

            /* Set up STRING fields. */

            pstringNew->ulcLock = 1;
            lstrcpy(pstringNew->string, pcsz);

            /* What's up with this string, Doc? */

            bResult = AddNode(*phlistHashBucket, StringSortCmp, pstringNew, &hnodeNew);

            /* Was the new string added to the hash bucket successfully? */

            if (bResult)
               /* Yes. */
               *phs = (HSTRING)hnodeNew;
            else
               /* No. */
               FreeMemory(pstringNew);
         }
      }
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phs, STRING));

   return(bResult);
}


/*
** DeleteString()
**
** Decrements a string's lock count.  If the lock count goes to 0, the string
** is deleted from its string table.
**
** Arguments:     hs - handle to the string to be deleted
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void DeleteString(HSTRING hs)
{
   PSTRING pstring;

   ASSERT(IS_VALID_HANDLE(hs, STRING));

   pstring = (PSTRING)GetNodeData((HNODE)hs);

   /* Delete string completely? */

   if (! UnlockString(pstring))
   {
      /* Yes.  Remove the string node from the hash bucket's list. */

      DeleteNode((HNODE)hs);

      FreeMemory(pstring);
   }

   return;
}


/*
** LockString()
**
** Increments a string's lock count.
**
** Arguments:     hs - handle to string whose lock count is to be incremented
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void LockString(HSTRING hs)
{
   PSTRING pstring;

   ASSERT(IS_VALID_HANDLE(hs, STRING));

   /* Increment lock count. */

   pstring = (PSTRING)GetNodeData((HNODE)hs);

   ASSERT(pstring->ulcLock < ULONG_MAX);
   pstring->ulcLock++;

   return;
}


/*
** CompareStrings()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT CompareStringsI(HSTRING hs1, HSTRING hs2)
{
   ASSERT(IS_VALID_HANDLE(hs1, STRING));
   ASSERT(IS_VALID_HANDLE(hs2, STRING));

   /* This comparison works across string tables. */

   return(MapIntToComparisonResult(lstrcmpi(((PCSTRING)GetNodeData((HNODE)hs1))->string,
                                            ((PCSTRING)GetNodeData((HNODE)hs2))->string)));
}


/*
** GetString()
**
** Retrieves a pointer to a string in a string table.
**
** Arguments:     hs - handle to the string to be retrieved
**
** Returns:       Pointer to string.
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR GetString(HSTRING hs)
{
   PSTRING pstring;

   ASSERT(IS_VALID_HANDLE(hs, STRING));

   pstring = (PSTRING)GetNodeData((HNODE)hs);

   return((LPCTSTR)&(pstring->string));
}


/*
** WriteStringTable()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT WriteStringTable(HCACHEDFILE hcf, HSTRINGTABLE hst)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
   DWORD dwcbStringTableDBHeaderOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));

   /* Save initial file poisition. */

   dwcbStringTableDBHeaderOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbStringTableDBHeaderOffset != INVALID_SEEK_POSITION)
   {
      STRINGTABLEDBHEADER stdbh;

      /* Leave space for the string table header. */

      ZeroMemory(&stdbh, sizeof(stdbh));

      if (WriteToCachedFile(hcf, (PCVOID)&stdbh, sizeof(stdbh), NULL))
      {
         HASHBUCKETCOUNT hbc;

         /* Save strings in each hash bucket. */

         stdbh.dwcbMaxStringLen = 0;
         stdbh.lcStrings = 0;

         tr = TR_SUCCESS;

         for (hbc = 0; hbc < ((PSTRINGTABLE)hst)->hbc; hbc++)
         {
            LONG lcStringsInHashBucket;
            DWORD dwcbStringLen;

            tr = WriteHashBucket(hcf,
                              (((PSTRINGTABLE)hst)->phlistHashBuckets)[hbc],
                              &lcStringsInHashBucket, &dwcbStringLen);

            if (tr == TR_SUCCESS)
            {
               /* Watch out for overflow. */

               ASSERT(stdbh.lcStrings <= LONG_MAX - lcStringsInHashBucket);

               stdbh.lcStrings += lcStringsInHashBucket;

               if (dwcbStringLen > stdbh.dwcbMaxStringLen)
                  stdbh.dwcbMaxStringLen = dwcbStringLen;
            }
            else
               break;
         }

         if (tr == TR_SUCCESS)
         {
            /* Save string table header. */

            // The on-disk dwCBMaxString len always refers to ANSI chars,
            // whereas in memory it is for the TCHAR type, we adjust it
            // around the save

            stdbh.dwcbMaxStringLen /= sizeof(TCHAR);

            tr = WriteDBSegmentHeader(hcf, dwcbStringTableDBHeaderOffset,
                                      &stdbh, sizeof(stdbh));
            
            stdbh.dwcbMaxStringLen *= sizeof(TCHAR);

            TRACE_OUT((TEXT("WriteStringTable(): Wrote %ld strings."),
                       stdbh.lcStrings));
         }
      }
   }

   return(tr);
}


/*
** ReadStringTable()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT ReadStringTable(HCACHEDFILE hcf, HSTRINGTABLE hst,
                                         PHHANDLETRANS phhtTrans)
{
   TWINRESULT tr;
   STRINGTABLEDBHEADER stdbh;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));
   ASSERT(IS_VALID_WRITE_PTR(phhtTrans, HHANDLETRANS));

   if (ReadFromCachedFile(hcf, &stdbh, sizeof(stdbh), &dwcbRead) &&
       dwcbRead == sizeof(stdbh))
   {
      LPTSTR pszStringBuf;

      // The string header will have the ANSI cb max, whereas inmemory
      // we need the cb max based on the current character size

      stdbh.dwcbMaxStringLen *= sizeof(TCHAR);

      if (AllocateMemory(stdbh.dwcbMaxStringLen, &pszStringBuf))
      {
         HHANDLETRANS hht;

         if (CreateHandleTranslator(stdbh.lcStrings, &hht))
         {
            LONG lcStrings;

            tr = TR_SUCCESS;

            TRACE_OUT((TEXT("ReadStringTable(): Reading %ld strings, maximum length %lu."),
                       stdbh.lcStrings,
                       stdbh.dwcbMaxStringLen));

            for (lcStrings = 0;
                 lcStrings < stdbh.lcStrings && tr == TR_SUCCESS;
                 lcStrings++)
               tr = ReadString(hcf, hst, hht, pszStringBuf, stdbh.dwcbMaxStringLen);

            if (tr == TR_SUCCESS)
            {
               PrepareForHandleTranslation(hht);
               *phhtTrans = hht;

               ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));
               ASSERT(IS_VALID_HANDLE(*phhtTrans, HANDLETRANS));
            }
            else
               DestroyHandleTranslator(hht);
         }
         else
            tr = TR_OUT_OF_MEMORY;

         FreeMemory(pszStringBuf);
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


#if defined(DEBUG) || defined (VSTF)

/*
** IsValidHSTRING()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHSTRING(HSTRING hs)
{
   BOOL bResult;

   if (IS_VALID_HANDLE((HNODE)hs, NODE))
      bResult = IS_VALID_STRUCT_PTR((PSTRING)GetNodeData((HNODE)hs), CSTRING);
   else
      bResult = FALSE;

   return(bResult);
}


/*
** IsValidHSTRINGTABLE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHSTRINGTABLE(HSTRINGTABLE hst)
{
   return(IS_VALID_STRUCT_PTR((PSTRINGTABLE)hst, CSTRINGTABLE));
}

#endif


#ifdef DEBUG

/*
** GetStringCount()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE ULONG GetStringCount(HSTRINGTABLE hst)
{
   ULONG ulcStrings = 0;
   HASHBUCKETCOUNT hbc;

   ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));

   for (hbc = 0; hbc < ((PCSTRINGTABLE)hst)->hbc; hbc++)
   {
      HLIST hlistHashBucket;

      hlistHashBucket = (((PCSTRINGTABLE)hst)->phlistHashBuckets)[hbc];

      if (hlistHashBucket)
      {
         ASSERT(ulcStrings <= ULONG_MAX - GetNodeCount(hlistHashBucket));
         ulcStrings += GetNodeCount(hlistHashBucket);
      }
   }

   return(ulcStrings);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\stub.h ===
/*
 * stub.h - Stub ADT description.
 */


/* Types
 ********/

/* stub types */

typedef enum _stubtype
{
   ST_OBJECTTWIN,

   ST_TWINFAMILY,

   ST_FOLDERPAIR
}
STUBTYPE;
DECLARE_STANDARD_TYPES(STUBTYPE);

/* stub flags */

typedef enum _stubflags
{
   /* This stub was marked for deletion while it was locked. */

   STUB_FL_UNLINKED           = 0x0001,

   /* This stub has already been used for some operation. */

   STUB_FL_USED               = 0x0002,

   /*
    * The file stamp of this object twin stub is valid.  (Only used for object
    * twins to cache file stamp from folder twin expansion for RECNODE
    * creation.)
    */

   STUB_FL_FILE_STAMP_VALID   = 0x0004,

   /*
    * This twin family stub or folder twin stub is in the process of being
    * deleted.  (Only used for twin families and folder twins.)
    */

   STUB_FL_BEING_DELETED      = 0x0008,

   /*
    * This folder twin stub is in the process of being translated.  (Only used
    * for folder twins.)
    */

   STUB_FL_BEING_TRANSLATED   = 0x0010,

   /*
    * This object twin stub was explicitly added a an object twin through
    * AddObjectTwin().  (Only used for object twins.)
    */

   STUB_FL_FROM_OBJECT_TWIN   = 0x0100,

   /*
    * This object twin stub was not reconciled the last time its twin family
    * was reconciled, and some members of the twin family were known to have
    * changed.  (Only used for object twins.)
    */

   STUB_FL_NOT_RECONCILED     = 0x0200,

   /*
    * The subtree of the root folder of this folder twin stub is to be included
    * in reconciliation.  (Only used for folder twins.)
    */

   STUB_FL_SUBTREE            = 0x0400,

   /*
    * The object twins in this twin family are pending deletion because an
    * object twin was deleted, and no object twins have changed since that
    * object twins was deleted.  This folder twin is pending deletion because
    * its folder root is last known deleted.  (Only used for twin families and
    * folder twins.)
    */

   STUB_FL_DELETION_PENDING   = 0x0800,

   /*
    * The client indicated that this object twin should not be deleted.  (Only
    * used for object twins.)
    */

   STUB_FL_KEEP               = 0x1000,

   /* stub flag combinations */

   ALL_STUB_FLAGS             = (STUB_FL_UNLINKED |
                                 STUB_FL_USED |
                                 STUB_FL_FILE_STAMP_VALID |
                                 STUB_FL_BEING_DELETED |
                                 STUB_FL_BEING_TRANSLATED |
                                 STUB_FL_FROM_OBJECT_TWIN |
                                 STUB_FL_NOT_RECONCILED |
                                 STUB_FL_SUBTREE |
                                 STUB_FL_DELETION_PENDING |
                                 STUB_FL_KEEP),

   ALL_OBJECT_TWIN_FLAGS      = (STUB_FL_UNLINKED |
                                 STUB_FL_USED |
                                 STUB_FL_FILE_STAMP_VALID |
                                 STUB_FL_NOT_RECONCILED |
                                 STUB_FL_FROM_OBJECT_TWIN |
                                 STUB_FL_KEEP),

   ALL_TWIN_FAMILY_FLAGS      = (STUB_FL_UNLINKED |
                                 STUB_FL_USED |
                                 STUB_FL_BEING_DELETED |
                                 STUB_FL_DELETION_PENDING),

   ALL_FOLDER_TWIN_FLAGS      = (STUB_FL_UNLINKED |
                                 STUB_FL_USED |
                                 STUB_FL_BEING_DELETED |
                                 STUB_FL_BEING_TRANSLATED |
                                 STUB_FL_SUBTREE |
                                 STUB_FL_DELETION_PENDING),

   /* bit mask used to save stub flags in briefcase database */

   DB_STUB_FLAGS_MASK         = 0xff00
}
STUBFLAGS;

/*
 * common stub - These fields must appear at the start of TWINFAMILY,
 * OBJECTTWIN, and FOLDERPAIR in the same order.
 */

typedef struct _stub
{
   /* structure tag */

   STUBTYPE st;

   /* lock count */

   ULONG ulcLock;

   /* flags */

   DWORD dwFlags;
}
STUB;
DECLARE_STANDARD_TYPES(STUB);

/* object twin family */

typedef struct _twinfamily
{
   /* common stub */

   STUB stub;

   /* handle to name string */

   HSTRING hsName;

   /* handle to list of object twins */

   HLIST hlistObjectTwins;

   /* handle to parent briefcase */

   HBRFCASE hbr;
}
TWINFAMILY;
DECLARE_STANDARD_TYPES(TWINFAMILY);

/* object twin */

typedef struct _objecttwin
{
   /* common stub */

   STUB stub;

   /* handle to folder path */

   HPATH hpath;

   /* file stamp at last reconciliation time */

   FILESTAMP fsLastRec;

   /* pointer to parent twin family */

   PTWINFAMILY ptfParent;

   /* source folder twins count */

   ULONG ulcSrcFolderTwins;

   /*
    * current file stamp, only valid if STUB_FL_FILE_STAMP_VALID is set in
    * stub's flags
    */

   FILESTAMP fsCurrent;
}
OBJECTTWIN;
DECLARE_STANDARD_TYPES(OBJECTTWIN);

/* folder pair data */

typedef struct _folderpairdata
{
   /* handle to name of included objects - may contain wildcards */

   HSTRING hsName;

   /* attributes to match */

   DWORD dwAttributes;

   /* handle to parent briefcase */

   HBRFCASE hbr;
}
FOLDERPAIRDATA;
DECLARE_STANDARD_TYPES(FOLDERPAIRDATA);

/* folder pair */

typedef struct _folderpair
{
   /* common stub */

   STUB stub;

   /* handle to folder path */

   HPATH hpath;

   /* pointer to folder pair data */

   PFOLDERPAIRDATA pfpd;

   /* pointer to other half of folder pair */

   struct _folderpair *pfpOther;
}
FOLDERPAIR;
DECLARE_STANDARD_TYPES(FOLDERPAIR);

/*
 * EnumGeneratedObjectTwins() callback function
 *
 * Called as:
 *
 * bContinue = EnumGeneratedObjectTwinsProc(pot, pvRefData);
 */

typedef BOOL (*ENUMGENERATEDOBJECTTWINSPROC)(POBJECTTWIN, PVOID);

/*
 * EnumGeneratingFolderTwins() callback function
 *
 * Called as:
 *
 * bContinue = EnumGeneratingFolderTwinsProc(pfp, pvRefData);
 */

typedef BOOL (*ENUMGENERATINGFOLDERTWINSPROC)(PFOLDERPAIR, PVOID);


/* Prototypes
 *************/

/* stub.c */

extern void InitStub(PSTUB, STUBTYPE);
extern TWINRESULT DestroyStub(PSTUB);
extern void LockStub(PSTUB);
extern void UnlockStub(PSTUB);
extern DWORD GetStubFlags(PCSTUB);
extern void SetStubFlag(PSTUB, DWORD);
extern void ClearStubFlag(PSTUB, DWORD);
extern BOOL IsStubFlagSet(PCSTUB, DWORD);
extern BOOL IsStubFlagClear(PCSTUB, DWORD);

#ifdef VSTF

extern BOOL IsValidPCSTUB(PCSTUB);

#endif

/* twin.c */

extern BOOL FindObjectTwin(HBRFCASE, HPATH, LPCTSTR, PHNODE);
extern TWINRESULT TwinObjects(HBRFCASE, HCLSIFACECACHE, HPATH, HPATH, LPCTSTR, POBJECTTWIN *, POBJECTTWIN *);
extern BOOL CreateObjectTwin(PTWINFAMILY, HPATH, POBJECTTWIN *);
extern TWINRESULT UnlinkObjectTwin(POBJECTTWIN);
extern void DestroyObjectTwin(POBJECTTWIN);
extern TWINRESULT UnlinkTwinFamily(PTWINFAMILY);
extern void MarkTwinFamilyNeverReconciled(PTWINFAMILY);
extern void MarkObjectTwinNeverReconciled(PVOID);
extern void DestroyTwinFamily(PTWINFAMILY);
extern void MarkTwinFamilyDeletionPending(PTWINFAMILY);
extern void UnmarkTwinFamilyDeletionPending(PTWINFAMILY);
extern BOOL IsTwinFamilyDeletionPending(PCTWINFAMILY);
extern void ClearTwinFamilySrcFolderTwinCount(PTWINFAMILY);
extern BOOL EnumObjectTwins(HBRFCASE, ENUMGENERATEDOBJECTTWINSPROC, PVOID);
extern BOOL ApplyNewFolderTwinsToTwinFamilies(PCFOLDERPAIR);
extern TWINRESULT TransplantObjectTwin(POBJECTTWIN, HPATH, HPATH);
extern BOOL IsFolderObjectTwinName(LPCTSTR);


#ifdef VSTF

extern BOOL IsValidPCTWINFAMILY(PCTWINFAMILY);
extern BOOL IsValidPCOBJECTTWIN(PCOBJECTTWIN);

#endif

/* foldtwin.c */

extern void LockFolderPair(PFOLDERPAIR);
extern void UnlockFolderPair(PFOLDERPAIR);
extern TWINRESULT UnlinkFolderPair(PFOLDERPAIR);
extern void DestroyFolderPair(PFOLDERPAIR);
extern BOOL ApplyNewObjectTwinsToFolderTwins(HLIST);
extern BOOL BuildPathForMatchingObjectTwin(PCFOLDERPAIR, PCOBJECTTWIN, HPATHLIST, PHPATH);
extern BOOL EnumGeneratedObjectTwins(PCFOLDERPAIR, ENUMGENERATEDOBJECTTWINSPROC, PVOID);
extern BOOL EnumGeneratingFolderTwins(PCOBJECTTWIN, ENUMGENERATINGFOLDERTWINSPROC, PVOID, PULONG);
extern BOOL FolderTwinGeneratesObjectTwin(PCFOLDERPAIR, HPATH, LPCTSTR);

#ifdef VSTF

extern BOOL IsValidPCFOLDERPAIR(PCFOLDERPAIR);

#endif

extern void RemoveObjectTwinFromAllFolderPairs(POBJECTTWIN);

/* expandft.c */

extern BOOL ClearStubFlagWrapper(PSTUB, PVOID);
extern BOOL SetStubFlagWrapper(PSTUB, PVOID);
extern TWINRESULT ExpandIntersectingFolderTwins(PFOLDERPAIR, CREATERECLISTPROC, LPARAM);
extern TWINRESULT TryToGenerateObjectTwin(HBRFCASE, HPATH, LPCTSTR, PBOOL, POBJECTTWIN *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\twin.h ===
/*
 * twin.h - Twin ADT description.
 */


/* Types
 ********/

/*
 * EnumTwins() callback function - called as:
 *
 *    bContinue = EnumTwinsProc(htwin, pData);
 */

typedef BOOL (*ENUMTWINSPROC)(HTWIN, LPARAM);


/* Prototypes
 *************/

/* twin.c */

extern COMPARISONRESULT CompareNameStrings(LPCTSTR, LPCTSTR);
extern COMPARISONRESULT CompareNameStringsByHandle(HSTRING, HSTRING);
extern TWINRESULT TranslatePATHRESULTToTWINRESULT(PATHRESULT);
extern BOOL CreateTwinFamilyPtrArray(PHPTRARRAY);
extern void DestroyTwinFamilyPtrArray(HPTRARRAY);
extern HBRFCASE GetTwinBriefcase(HTWIN);
extern BOOL FindObjectTwinInList(HLIST, HPATH, PHNODE);
extern BOOL EnumTwins(HBRFCASE, ENUMTWINSPROC, LPARAM, PHTWIN);
extern BOOL IsValidHTWIN(HTWIN);
extern BOOL IsValidHTWINFAMILY(HTWINFAMILY);
extern BOOL IsValidHOBJECTTWIN(HOBJECTTWIN);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\twinlist.h ===
/*
 * twinlist.h - Twin list ADT description.
 */


/* Prototypes
 *************/

/* twinlist.c */

extern HBRFCASE GetTwinListBriefcase(HTWINLIST);
extern ARRAYINDEX GetTwinListCount(HTWINLIST);
extern HTWIN GetTwinFromTwinList(HTWINLIST, ARRAYINDEX);
extern BOOL IsValidHTWINLIST(HTWINLIST);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\subcycle.h ===
/*
 * subcycle.h - Subtree cycle detection routines description.
 */


/* Prototypes
 *************/

/* subcycle.c */

extern void BeginTranslateFolder(PFOLDERPAIR);
extern void EndTranslateFolder(PFOLDERPAIR);
extern TWINRESULT CheckForSubtreeCycles(HPTRARRAY, HPATH, HPATH, HSTRING);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\twinlist.c ===
/*
 * twinlist.c - Twin list ADT module.
 */

/*



*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"


/* Constants
 ************/

/* twin list pointer array allocation parameters */

#define NUM_START_TWIN_HANDLES      (1)
#define NUM_TWIN_HANDLES_TO_ADD     (16)


/* Types
 ********/

/* twin list */

typedef struct _twinlist
{
   /* handle to array of HTWINs in list */

   /* A NULL hpa implies that all twins in the briefcase are in the list. */

   HPTRARRAY hpa;

   /* handle to briefcase that twin list is associated with */

   HBRFCASE hbr;
}
TWINLIST;
DECLARE_STANDARD_TYPES(TWINLIST);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE COMPARISONRESULT TwinListSortCmp(PCVOID, PCVOID);
PRIVATE_CODE TWINRESULT MyAddTwinToTwinList(PCTWINLIST, HTWIN);
PRIVATE_CODE TWINRESULT MyRemoveTwinFromTwinList(PCTWINLIST, HTWIN);
PRIVATE_CODE void MyRemoveAllTwinsFromTwinList(PCTWINLIST);
PRIVATE_CODE BOOL AddTwinToTwinListProc(HTWIN, LPARAM);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCTWINLIST(PCTWINLIST);

#endif


/*
** TwinListSortCmp()
**
** Handle comparison function used to sort twin lists.
**
** Arguments:     htwin1 - first twin handle
**                htwin2 - second twin handle
**
** Returns:
**
** Side Effects:  none
**
** Twin handles are sorted by:
**    1) handle value
*/
PRIVATE_CODE COMPARISONRESULT TwinListSortCmp(PCVOID htwin1, PCVOID htwin2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_HANDLE((HTWIN)htwin1, TWIN));
   ASSERT(IS_VALID_HANDLE((HTWIN)htwin2, TWIN));

   if (htwin1 < htwin2)
      cr = CR_FIRST_SMALLER;
   else if (htwin1 > htwin2)
      cr = CR_FIRST_LARGER;
   else
      cr = CR_EQUAL;

   return(cr);
}


/*
** MyAddTwinToTwinList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT MyAddTwinToTwinList(PCTWINLIST pctl, HTWIN htwin)
{
   TWINRESULT tr;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_STRUCT_PTR(pctl, CTWINLIST));
   ASSERT(IS_VALID_HANDLE(htwin, TWIN));

   if (! SearchSortedArray(pctl->hpa, &TwinListSortCmp, htwin, &ai))
   {
      if (InsertPtr(pctl->hpa, TwinListSortCmp, ai, htwin))
      {
         LockStub((PSTUB)htwin);

         tr = TR_SUCCESS;
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
   {
      ASSERT(GetPtr(pctl->hpa, ai) == htwin);
      ASSERT(GetTwinBriefcase(htwin) == pctl->hbr);

      WARNING_OUT((TEXT("MyAddTwinToTwinList(): Twin %#lx has already been added to twin list %#lx."),
                   htwin,
                   pctl));

      tr = TR_DUPLICATE_TWIN;
   }

   return(tr);
}


/*
** MyRemoveTwinFromTwinList()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT MyRemoveTwinFromTwinList(PCTWINLIST pctl,
                                                    HTWIN htwin)
{
   TWINRESULT tr;
   ARRAYINDEX ai;

   if (SearchSortedArray(pctl->hpa, &TwinListSortCmp, htwin, &ai))
   {
      ASSERT(GetPtr(pctl->hpa, ai) == htwin);
      ASSERT(GetTwinBriefcase(htwin) == pctl->hbr);

      DeletePtr(pctl->hpa, ai);

      UnlockStub((PSTUB)htwin);

      tr = TR_SUCCESS;
   }
   else
   {
      WARNING_OUT((TEXT("MyRemoveTwinFromTwinList(): Twin %#lx is not in twin list %#lx."),
                   htwin,
                   pctl));

      tr = TR_INVALID_PARAMETER;
   }

   return(tr);
}


/*
** MyRemoveAllTwinsFromTwinList()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void MyRemoveAllTwinsFromTwinList(PCTWINLIST pctl)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   /* Unlock all twins in array. */

   aicPtrs = GetPtrCount(pctl->hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      UnlockStub(GetPtr(pctl->hpa, ai));

   /* Now wipe out the array. */

   DeleteAllPtrs(pctl->hpa);

   return;
}


/*
** AddTwinToTwinListProc()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL AddTwinToTwinListProc(HTWIN htwin, LPARAM htl)
{
   BOOL bResult;
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(htwin, TWIN));
   ASSERT(IS_VALID_HANDLE((HTWINLIST)htl, TWINLIST));

   tr = MyAddTwinToTwinList((PCTWINLIST)htl, htwin);

   switch (tr)
   {
      case TR_SUCCESS:
      case TR_DUPLICATE_TWIN:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         break;
   }

   return(bResult);
}


#ifdef VSTF

/*
** IsValidPCTWINLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCTWINLIST(PCTWINLIST pctl)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pctl, CTWINLIST) &&
       (! pctl->hpa || IS_VALID_HANDLE(pctl->hpa, PTRARRAY)) &&
       IS_VALID_HANDLE(pctl->hbr, BRFCASE))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
** GetTwinListBriefcase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HBRFCASE GetTwinListBriefcase(HTWINLIST htl)
{
   ASSERT(IS_VALID_HANDLE(htl, TWINLIST));

   return(((PCTWINLIST)htl)->hbr);
}


/*
** GetTwinListCount()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE ARRAYINDEX GetTwinListCount(HTWINLIST htl)
{
   ASSERT(IS_VALID_HANDLE(htl, TWINLIST));

   return(GetPtrCount(((PCTWINLIST)htl)->hpa));
}


/*
** GetTwinFromTwinList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HTWIN GetTwinFromTwinList(HTWINLIST htl, ARRAYINDEX ai)
{
   HTWIN htwin;

   ASSERT(IS_VALID_HANDLE(htl, TWINLIST));

   ASSERT(ai < GetPtrCount(((PCTWINLIST)htl)->hpa));

   htwin = GetPtr(((PCTWINLIST)htl)->hpa, ai);

   ASSERT(IS_VALID_HANDLE(htwin, TWIN));

   return(htwin);
}


/*
** IsValidHTWINLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHTWINLIST(HTWINLIST htl)
{
   return(IS_VALID_STRUCT_PTR((PCTWINLIST)htl, CTWINLIST));
}


/***************************** Exported Functions ****************************/


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | CreateTwinList | Creates a new empty twin list.

@parm HBRFCASE | hbr | A handle to the open briefcase that the twin list is to
be associated with.

@parm PHTWINLIST | phtl | A pointer to an HTWINLIST to be filled in with a
handle to the new twin list.  *phtl is only valid if TR_SUCCESS is returned.

@rdesc If the twin list was created successfully, TR_SUCCESS is returned, and
*phtl contains a handle to the new twin list.  Otherwise, the twin list was
not created successfully, the return value indicates the error that occurred,
and *phtl is undefined.

@xref DeleteTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI CreateTwinList(HBRFCASE hbr, PHTWINLIST phtl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(CreateTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE) &&
          IS_VALID_WRITE_PTR(phtl, HTWINLIST))
#endif
      {
         PTWINLIST ptl;

         tr = TR_OUT_OF_MEMORY;

         if (AllocateMemory(sizeof(*ptl), &ptl))
         {
            NEWPTRARRAY npa;

            /* Try to create a twin list pointer array. */

            npa.aicInitialPtrs = NUM_START_TWIN_HANDLES;
            npa.aicAllocGranularity = NUM_TWIN_HANDLES_TO_ADD;
            npa.dwFlags = NPA_FL_SORTED_ADD;

            if (CreatePtrArray(&npa, &(ptl->hpa)))
            {
               ptl->hbr = hbr;

               *phtl = (HTWINLIST)ptl;
               tr = TR_SUCCESS;

               ASSERT(IS_VALID_HANDLE(*phtl, TWINLIST));
            }
            else
               FreeMemory(ptl);
         }
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(CreateTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | DestroyTwinList | Destroys a twin list.

@parm HTWINLIST | htl | A handle to the twin list to be destroyed.

@rdesc If the twin list was destroyed successfully, TR_SUCCESS is returned.
Otherwise, the twin list was not destroyed successfully, and the return value
indicates the error that occurred.

@xref CreateTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI DestroyTwinList(HTWINLIST htl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(DestroyTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(htl, TWINLIST))
#endif
      {
         /* Unlock all twins. */

         MyRemoveAllTwinsFromTwinList((PCTWINLIST)htl);

         DestroyPtrArray(((PCTWINLIST)htl)->hpa);

         FreeMemory((PTWINLIST)htl);

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(DestroyTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | AddTwinToTwinList | Adds a twin to a twin list.

@parm HTWINLIST | htl | A handle to the twin list that the twin is to be added
to.

@parm HTWIN | htwin | A handle to the twin to be added to the twin list.

@rdesc If the twin was added to the twin list successfully, TR_SUCCESS is
returned.  Otherwise, the twin was not added to the twin list successfully, and
the return value indicates the error that occurred.

@comm If the twin associated with htwin is part of an open briefcase other than
the open briefcase associated with htl, TR_INVALID_PARAMETER is returned.  If
htwin has already been added to the twin list, TR_DUPLICATE_TWIN is returned.
If htwin refers to a deleted twin, TR_DELETED_TWIN is returned.

@xref RemoveTwinFromTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI AddTwinToTwinList(HTWINLIST htl, HTWIN htwin)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(AddTwinToTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(htl, TWINLIST) &&
          IS_VALID_HANDLE(htwin, TWIN))
#endif
      {
         if (IsStubFlagClear((PCSTUB)htwin, STUB_FL_UNLINKED))
         {
            if (GetTwinBriefcase(htwin) == ((PCTWINLIST)htl)->hbr)
               tr = MyAddTwinToTwinList((PCTWINLIST)htl, htwin);
            else
               tr = TR_INVALID_PARAMETER;
         }
         else
            tr = TR_DELETED_TWIN;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(AddTwinToTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | AddAllTwinsToTwinList | Adds all the twins in an open
briefcase to a twin list.

@parm HTWINLIST | htl | A handle to the twin list that the twins are to be
added to.

@rdesc If the twins were added to the twin list successfully, TR_SUCCESS is
returned.  Otherwise, the twins were not added to the twin list successfully,
and the return value indicates the error that occurred.

@xref RemoveAllTwinsFromTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI AddAllTwinsToTwinList(HTWINLIST htl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(AddAllTwinsToTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(htl, TWINLIST))
#endif
      {
         HTWIN htwinUnused;

         if (! EnumTwins(((PCTWINLIST)htl)->hbr, &AddTwinToTwinListProc, (LPARAM)htl, &htwinUnused))
            tr = TR_SUCCESS;
         else
            tr = TR_OUT_OF_MEMORY;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(AddAllTwinsToTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | RemoveTwinFromTwinList | Removes a twin from a twin list.

@parm HTWINLIST | htl | A handle to the twin list that the twin is to be
removed from.

@parm HTWIN | htwin | A handle to the twin to be removed from the twin list.

@rdesc If the twin was removed from the twin list successfully, TR_SUCCESS is
returned.  Otherwise, the twin was not removed from the twin list successfully,
and the return value indicates the error that occurred.

@comm If the twin associated with htwin is not in the twin list,
TR_INVALID_PARAMETER is returned.

@xref AddTwinToTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI RemoveTwinFromTwinList(HTWINLIST htl, HTWIN htwin)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(RemoveTwinFromTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(htl, TWINLIST) &&
          IS_VALID_HANDLE(htwin, TWIN))
#endif
      {
         tr = MyRemoveTwinFromTwinList((PCTWINLIST)htl, htwin);
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(RemoveTwinFromTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | RemoveAllTwinsFromTwinList | Removes all the twins from a
twin list.

@parm HTWINLIST | htl | A handle to the twin list to be emptied.

@rdesc If the twins were removed from the twin list successfully, TR_SUCCESS is
returned.  Otherwise, the twins were not removed from the twin list
successfully, and the return value indicates the error that occurred.

@xref AddAllTwinsToTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI RemoveAllTwinsFromTwinList(HTWINLIST htl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(RemoveAllTwinsFromTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(htl, TWINLIST))
#endif
      {
         MyRemoveAllTwinsFromTwinList((PCTWINLIST)htl);

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(RemoveAllTwinsFromTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\subcycle.c ===
/*
 * subcycle.c - Subtree cycle detection routines module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "subcycle.h"


/* Constants
 ************/

/* pointer array allocation constants */

#define NUM_CYCLE_PTRS_TO_ADD          (16)


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE TWINRESULT CheckHalfForSubtreeCycle(HPTRARRAY, HPATH, HPATH, LPCTSTR);


/*
** CheckHalfForSubtreeCycle()
**
** Checks to see if half of a proposed new folder subtree twin would create one
** or more cycles of folder subtree twins.
**
** Arguments:     hpaFolderPairs - handle to PTRARRAY containing pointers to
**                                 folder pairs
**                hpathStartFolder - root folder of initial half of proposed
**                                   new folder pair
**                hpathEndFolder - root folder of other half of proposed new
**                                 folder pair
**                pcszName - name specification of matching objects to be
**                           included in proposed new folder subtree pair
**
** Returns:       TWINRESULT
**
** Side Effects:  none
**
** N.b., this function should be called twice for each proposed new folder
** subtree pair.
*/
PRIVATE_CODE TWINRESULT CheckHalfForSubtreeCycle(HPTRARRAY hpaFolderPairs,
                                                 HPATH hpathStartFolder,
                                                 HPATH hpathEndFolder,
                                                 LPCTSTR pcszName)
{
   TWINRESULT tr;
   ARRAYINDEX aicFolderPairs;
   NEWPTRARRAY npa;
   HPTRARRAY hpaFolders;

   ASSERT(IS_VALID_HANDLE(hpaFolderPairs, PTRARRAY));
   ASSERT(IS_VALID_HANDLE(hpathStartFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hpathEndFolder, PATH));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));

   aicFolderPairs = GetPtrCount(hpaFolderPairs);

   /*
    * Try to create an unsorted pointer array to be used in checking for
    * cycles.
    */

   npa.aicInitialPtrs = aicFolderPairs;
   npa.aicAllocGranularity = NUM_CYCLE_PTRS_TO_ADD;
   npa.dwFlags = 0;

   if (CreatePtrArray(&npa, &hpaFolders))
   {
      ARRAYINDEX aicFolders;
      ARRAYINDEX aiCurFolder;
      HPATH hpathCurFolderRoot;

      /* Search all folder pairs connected to the first new folder twin. */

      /*
       * Mark all folder twins unused.  A "used" folder twin is one that has
       * already been visited while searching for subtree cycles.  I.e., a
       * used folder subtree pair half intersected the first folder of the
       * proposed new folder twin, and its other half was added to the list for
       * later comparison.
       */

      ClearFlagInArrayOfStubs(hpaFolderPairs, STUB_FL_USED);

      /*
       * Loop to process entire graph of folder subtree twins connected to the
       * first new folder twin.  Folder twins are only added to the hpaFolders
       * array if they don't already intersect the second of the two proposed
       * new folder subtree twins.
       */

      tr = TR_SUCCESS;
      aicFolders = 0;
      aiCurFolder = 0;

      /* Begin with start folder. */

      hpathCurFolderRoot = hpathStartFolder;

      FOREVER
      {
         ARRAYINDEX aiCheckFolderRoot;

         /*
          * Loop to find all subtree folder pairs that intersect
          * hpaFolders[aiCurFolder]'s subtree.
          */

         for (aiCheckFolderRoot = 0;
              aiCheckFolderRoot < aicFolderPairs;
              aiCheckFolderRoot++)
         {
            PFOLDERPAIR pfpCheck;

            /* Get this subtree folder pair's root folder. */

            pfpCheck = GetPtr(hpaFolderPairs, aiCheckFolderRoot);

            ASSERT(IS_VALID_STRUCT_PTR(pfpCheck, CFOLDERPAIR));

            /* Have we already visited this folder pair? */

            if (IsStubFlagSet(&(pfpCheck->stub), STUB_FL_SUBTREE) &&
                IsStubFlagClear(&(pfpCheck->stub), STUB_FL_BEING_TRANSLATED) &&
                IsStubFlagClear(&(pfpCheck->stub), STUB_FL_USED) &&
                IsStubFlagClear(&(pfpCheck->pfpOther->stub), STUB_FL_USED))
            {
               /*
                * No.  Does this subtree folder pair intersect the current
                * folder pair node's subtree, and the objects named in the
                * proposed new folder subtree twin?
                */

               ASSERT(IsStubFlagSet(&(pfpCheck->pfpOther->stub), STUB_FL_SUBTREE));
               ASSERT(IsStubFlagClear(&(pfpCheck->pfpOther->stub), STUB_FL_BEING_TRANSLATED));

               if (SubtreesIntersect(hpathCurFolderRoot, pfpCheck->hpath) &&
                   NamesIntersect(GetString(pfpCheck->pfpd->hsName), pcszName))
               {
                  HPATH hpathOtherCheckFolderRoot;

                  /* Yes.  Get the other side of the folder subtree pair. */

                  hpathOtherCheckFolderRoot = pfpCheck->pfpOther->hpath;

                  /*
                   * Does this pair connect back to the other side of the
                   * proposed new folder pair?
                   */

                  if (SubtreesIntersect(hpathOtherCheckFolderRoot,
                                        hpathEndFolder))
                  {
                     /*
                      * Yes.  Are the roots different parts of the common
                      * subtree?
                      */

                     if (ComparePaths(hpathEndFolder,
                                      hpathOtherCheckFolderRoot)
                         != CR_EQUAL)
                     {
                        /* Yes.  Found a cycle.  Bail out. */

                        WARNING_OUT((TEXT("CheckHalfForSubtreeCycle(): Subtree cycle found connecting folders %s and %s."),
                                     DebugGetPathString(hpathStartFolder),
                                     DebugGetPathString(hpathEndFolder)));

                        tr = TR_SUBTREE_CYCLE_FOUND;
                        break;
                     }

                     /*
                      * We don't need to include this root in the search if it
                      * is the same as the other side of the proposed new
                      * folder pair since it will be covered during the other
                      * call to CheckHalfForSubtreeCycle().
                      */
                  }
                  else
                  {
                     /* Add this subtree as another node to be examined. */

                     if (! InsertPtr(hpaFolders, NULL, aicFolders++,
                                     (PCVOID)(pfpCheck->pfpOther)))
                        tr = TR_OUT_OF_MEMORY;
                  }

                  /* Mark this folder twin as already visited. */

                  if (tr == TR_SUCCESS)
                     SetStubFlag(&(pfpCheck->stub), STUB_FL_USED);
                  else
                     break;
               }
            }
         }

         /* Any folder subtree twins left to investigate? */

         if (aiCurFolder < aicFolders)
         {
            PFOLDERPAIR pfpCur;

            /* Yes. */

            pfpCur = GetPtr(hpaFolders, aiCurFolder++);

            hpathCurFolderRoot = pfpCur->hpath;
         }
         else
            /* No. */
            break;
      }

      DestroyPtrArray(hpaFolders);
   }
   else
      tr = TR_OUT_OF_MEMORY;

   return(tr);
}


/****************************** Public Functions *****************************/


/*
** BeginTranslateFolder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void BeginTranslateFolder(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_BEING_TRANSLATED));
   ASSERT(IsStubFlagClear(&(pfp->pfpOther->stub), STUB_FL_BEING_TRANSLATED));

   SetStubFlag(&(pfp->stub), STUB_FL_BEING_TRANSLATED);
   SetStubFlag(&(pfp->pfpOther->stub), STUB_FL_BEING_TRANSLATED);

   return;
}


/*
** EndTranslateFolder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void EndTranslateFolder(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   ASSERT(IsStubFlagSet(&(pfp->stub), STUB_FL_BEING_TRANSLATED));
   ASSERT(IsStubFlagSet(&(pfp->pfpOther->stub), STUB_FL_BEING_TRANSLATED));

   ClearStubFlag(&(pfp->stub), STUB_FL_BEING_TRANSLATED);
   ClearStubFlag(&(pfp->pfpOther->stub), STUB_FL_BEING_TRANSLATED);

   return;
}


/*
** CheckForSubtreeCycles()
**
** Checks to see if a proposed new folder subtree twin would create one or more
** cycles of folder subtree twins.
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
**
** N.b., TR_SUBTREE_CYCLE_FOUND is returned if the folder subtree roots of the
** proposed new folder subtree twin are the same.
*/
PUBLIC_CODE TWINRESULT CheckForSubtreeCycles(HPTRARRAY hpaFolderPairs,
                                             HPATH hpathFirstFolder,
                                             HPATH hpathSecondFolder,
                                             HSTRING hsName)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hpaFolderPairs, PTRARRAY));
   ASSERT(IS_VALID_HANDLE(hpathFirstFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hpathSecondFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hsName, STRING));

   /* Are the folder twins cyclical on their own? */

   if (SubtreesIntersect(hpathFirstFolder, hpathSecondFolder))
   {
      /* Yes. */

      tr = TR_SUBTREE_CYCLE_FOUND;

      WARNING_OUT((TEXT("CheckForSubtreeCycles(): Subtree cycle found connecting folders %s and %s."),
                   DebugGetPathString(hpathFirstFolder),
                   DebugGetPathString(hpathSecondFolder)));
   }
   else
   {
      LPCTSTR pcszName;

      /* No.  Check for any indirect subtree cycle.  */

      pcszName = GetString(hsName);

      tr = CheckHalfForSubtreeCycle(hpaFolderPairs, hpathFirstFolder,
                                    hpathSecondFolder, pcszName);

      if (tr == TR_SUCCESS)
         tr = CheckHalfForSubtreeCycle(hpaFolderPairs, hpathSecondFolder,
                                       hpathFirstFolder, pcszName);
   }

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\twin.c ===
/*
 * twin.c - Twin ADT module.
 */

/*



*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "oleutil.h"


/* Constants
 ************/

/* twin family pointer array allocation constants */

#define NUM_START_TWIN_FAMILY_PTRS        (16)
#define NUM_TWIN_FAMILY_PTRS_TO_ADD       (16)


/* Types
 ********/

/* twin families database structure header */

typedef struct _twinfamiliesdbheader
{
   /* number of twin families */

   LONG lcTwinFamilies;
}
TWINFAMILIESDBHEADER;
DECLARE_STANDARD_TYPES(TWINFAMILIESDBHEADER);

/* individual twin family database structure header */

typedef struct _twinfamilydbheader
{
   /* stub flags */

   DWORD dwStubFlags;

   /* old string handle of name */

   HSTRING hsName;

   /* number of object twins in family */

   LONG lcObjectTwins;
}
TWINFAMILYDBHEADER;
DECLARE_STANDARD_TYPES(TWINFAMILYDBHEADER);

/* object twin database structure */

typedef struct _dbobjecttwin
{
   /* stub flags */

   DWORD dwStubFlags;

   /* old handle to folder string */

   HPATH hpath;

   /* time stamp at last reconciliation */

   FILESTAMP fsLastRec;
}
DBOBJECTTWIN;
DECLARE_STANDARD_TYPES(DBOBJECTTWIN);

/* GenerateSpinOffObjectTwin() callback structure */

typedef struct _spinoffobjecttwininfo
{
   PCFOLDERPAIR pcfp;

   HLIST hlistNewObjectTwins;
}
SPINOFFOBJECTTWININFO;
DECLARE_STANDARD_TYPES(SPINOFFOBJECTTWININFO);

typedef void (CALLBACK *COPYOBJECTTWINPROC)(POBJECTTWIN, PCDBOBJECTTWIN);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE TWINRESULT TwinJustTheseTwoObjects(HBRFCASE, HPATH, HPATH, LPCTSTR, POBJECTTWIN *, POBJECTTWIN *, HLIST);
PRIVATE_CODE BOOL CreateTwinFamily(HBRFCASE, LPCTSTR, PTWINFAMILY *);
PRIVATE_CODE void CollapseTwinFamilies(PTWINFAMILY, PTWINFAMILY);
PRIVATE_CODE BOOL GenerateSpinOffObjectTwin(PVOID, PVOID);
PRIVATE_CODE BOOL BuildBradyBunch(PVOID, PVOID);
PRIVATE_CODE BOOL CreateObjectTwinAndAddToList(PTWINFAMILY, HPATH, HLIST, POBJECTTWIN *, PHNODE);
PRIVATE_CODE BOOL CreateListOfGeneratedObjectTwins(PCFOLDERPAIR, PHLIST);
PRIVATE_CODE void NotifyNewObjectTwins(HLIST, HCLSIFACECACHE);
PRIVATE_CODE HRESULT NotifyOneNewObjectTwin(PINotifyReplica, PCOBJECTTWIN, LPCTSTR);
PRIVATE_CODE HRESULT CreateOtherReplicaMonikers(PCOBJECTTWIN, PULONG, PIMoniker **);
PRIVATE_CODE COMPARISONRESULT TwinFamilySortCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT TwinFamilySearchCmp(PCVOID, PCVOID);
PRIVATE_CODE BOOL ObjectTwinSearchCmp(PCVOID, PCVOID);
PRIVATE_CODE TWINRESULT WriteTwinFamily(HCACHEDFILE, PCTWINFAMILY);
PRIVATE_CODE TWINRESULT WriteObjectTwin(HCACHEDFILE, PCOBJECTTWIN);
PRIVATE_CODE TWINRESULT ReadTwinFamily(HCACHEDFILE, HBRFCASE, PCDBVERSION, HHANDLETRANS, HHANDLETRANS);
PRIVATE_CODE TWINRESULT ReadObjectTwin(HCACHEDFILE, PCDBVERSION, PTWINFAMILY, HHANDLETRANS);
PRIVATE_CODE void CopyTwinFamilyInfo(PTWINFAMILY, PCTWINFAMILYDBHEADER);
PRIVATE_CODE void CopyObjectTwinInfo(POBJECTTWIN, PCDBOBJECTTWIN);
PRIVATE_CODE void CopyM8ObjectTwinInfo(POBJECTTWIN, PCDBOBJECTTWIN);
PRIVATE_CODE BOOL DestroyObjectTwinStubWalker(PVOID, PVOID);
PRIVATE_CODE BOOL MarkObjectTwinNeverReconciledWalker(PVOID, PVOID);
PRIVATE_CODE BOOL LookForSrcFolderTwinsWalker(PVOID, PVOID);
PRIVATE_CODE BOOL IncrementSrcFolderTwinsWalker(PVOID, PVOID);
PRIVATE_CODE BOOL ClearSrcFolderTwinsWalker(PVOID, PVOID);
PRIVATE_CODE BOOL SetTwinFamilyWalker(PVOID, PVOID);
PRIVATE_CODE BOOL InsertNodeAtFrontWalker(POBJECTTWIN, PVOID);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidObjectTwinWalker(PVOID, PVOID);
PRIVATE_CODE BOOL IsValidPCNEWOBJECTTWIN(PCNEWOBJECTTWIN);
PRIVATE_CODE BOOL IsValidPCSPINOFFOBJECTTWININFO(PCSPINOFFOBJECTTWININFO);

#endif

#ifdef DEBUG

PRIVATE_CODE BOOL AreTwinFamiliesValid(HPTRARRAY);

#endif


/*
** TwinJustTheseTwoObjects()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT TwinJustTheseTwoObjects(HBRFCASE hbr, HPATH hpathFolder1,
                                           HPATH hpathFolder2, LPCTSTR pcszName,
                                           POBJECTTWIN *ppot1,
                                           POBJECTTWIN *ppot2,
                                           HLIST hlistNewObjectTwins)
{
   TWINRESULT tr = TR_OUT_OF_MEMORY;
   HNODE hnodeSearch;
   BOOL bFound1;
   BOOL bFound2;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hpathFolder1, PATH));
   ASSERT(IS_VALID_HANDLE(hpathFolder2, PATH));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppot1, POBJECTTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppot2, POBJECTTWIN));
   ASSERT(IS_VALID_HANDLE(hlistNewObjectTwins, LIST));

   /* Determine twin families of existing object twins. */

   bFound1 = FindObjectTwin(hbr, hpathFolder1, pcszName, &hnodeSearch);

   if (bFound1)
      *ppot1 = (POBJECTTWIN)GetNodeData(hnodeSearch);

   bFound2 = FindObjectTwin(hbr, hpathFolder2, pcszName, &hnodeSearch);

   if (bFound2)
      *ppot2 = (POBJECTTWIN)GetNodeData(hnodeSearch);

   /* Take action based upon existence of two object twins. */

   if (! bFound1 && ! bFound2)
   {
      PTWINFAMILY ptfNew;

      /* Neither object is already present.  Create a new twin family. */

      if (CreateTwinFamily(hbr, pcszName, &ptfNew))
      {
         HNODE hnodeNew1;

         if (CreateObjectTwinAndAddToList(ptfNew, hpathFolder1,
                                          hlistNewObjectTwins, ppot1,
                                          &hnodeNew1))
         {
            HNODE hnodeNew2;

            if (CreateObjectTwinAndAddToList(ptfNew, hpathFolder2,
                                             hlistNewObjectTwins, ppot2,
                                             &hnodeNew2))
            {
               TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Created a twin family for object %s in folders %s and %s."),
                          pcszName,
                          DebugGetPathString(hpathFolder1),
                          DebugGetPathString(hpathFolder2)));

               ASSERT(IsStubFlagClear(&(ptfNew->stub), STUB_FL_DELETION_PENDING));

               tr = TR_SUCCESS;
            }
            else
            {
               DeleteNode(hnodeNew1);
               DestroyStub(&((*ppot1)->stub));
TWINJUSTTHESETWOOBJECTS_BAIL:
               DestroyStub(&(ptfNew->stub));
            }
         }
         else
            goto TWINJUSTTHESETWOOBJECTS_BAIL;
      }
   }
   else if (bFound1 && bFound2)
   {
      /*
       * Both objects are already present.  Are they members of the same twin
       * family?
       */

      if ((*ppot1)->ptfParent == (*ppot2)->ptfParent)
      {
         /* Yes, same twin family.  Complain that these twins already exist. */

         TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Object %s is already twinned in folders %s and %s."),
                    pcszName,
                    DebugGetPathString(hpathFolder1),
                    DebugGetPathString(hpathFolder2)));

         tr = TR_DUPLICATE_TWIN;
      }
      else
      {
         /*
          * No, different twin families.  Collapse the two families.
          *
          * "That's the way they became the Brady bunch..."
          *
          * *ppot1 and *ppot2 remain valid across this call.
          */

         TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Collapsing separate twin families for object %s in folders %s and %s."),
                    pcszName,
                    DebugGetPathString(hpathFolder1),
                    DebugGetPathString(hpathFolder2)));

         CollapseTwinFamilies((*ppot1)->ptfParent, (*ppot2)->ptfParent);

         tr = TR_SUCCESS;
      }
   }
   else
   {
      PTWINFAMILY ptfParent;
      HNODE hnodeUnused;

      /*
       * Only one of the two objects is present.  Add the new object twin
       * to the existing object twin's family.
       */

      if (bFound1)
      {
         /* First object is already a twin. */

         ptfParent = (*ppot1)->ptfParent;

         if (CreateObjectTwinAndAddToList(ptfParent, hpathFolder2,
                                          hlistNewObjectTwins, ppot2,
                                          &hnodeUnused))
         {
            TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Adding twin of object %s\\%s to existing twin family including %s\\%s."),
                       DebugGetPathString(hpathFolder2),
                       pcszName,
                       DebugGetPathString(hpathFolder1),
                       pcszName));

            tr = TR_SUCCESS;
         }
      }
      else
      {
         /* Second object is already a twin. */

         ptfParent = (*ppot2)->ptfParent;

         if (CreateObjectTwinAndAddToList(ptfParent, hpathFolder1,
                                          hlistNewObjectTwins, ppot1,
                                          &hnodeUnused))
         {
            TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Adding twin of object %s\\%s to existing twin family including %s\\%s."),
                       DebugGetPathString(hpathFolder1),
                       pcszName,
                       DebugGetPathString(hpathFolder2),
                       pcszName));

            tr = TR_SUCCESS;
         }
      }
   }

   ASSERT((tr != TR_SUCCESS && tr != TR_DUPLICATE_TWIN) ||
          IS_VALID_STRUCT_PTR(*ppot1, COBJECTTWIN) && IS_VALID_STRUCT_PTR(*ppot2, COBJECTTWIN));

   return(tr);
}


/*
** CreateTwinFamily()
**
** Creates a new empty twin family, and adds it to a briefcase.
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreateTwinFamily(HBRFCASE hbr, LPCTSTR pcszName, PTWINFAMILY *pptf)
{
   BOOL bResult = FALSE;
   PTWINFAMILY ptfNew;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pptf, PTWINFAMILY));

   /* Try to create a new TWINFAMILY structure. */

   if (AllocateMemory(sizeof(*ptfNew), &ptfNew))
   {
      NEWLIST nl;
      HLIST hlistObjectTwins;

      /* Create a list of object twins for the new twin family. */

      nl.dwFlags = 0;

      if (CreateList(&nl, &hlistObjectTwins))
      {
         HSTRING hsName;

         /* Add the object name to the name string table. */

         if (AddString(pcszName, GetBriefcaseNameStringTable(hbr), 
            GetHashBucketIndex, &hsName))
         {
            ARRAYINDEX aiUnused;

            /* Fill in TWINFAMILY fields. */

            InitStub(&(ptfNew->stub), ST_TWINFAMILY);

            ptfNew->hsName = hsName;
            ptfNew->hlistObjectTwins = hlistObjectTwins;
            ptfNew->hbr = hbr;

            MarkTwinFamilyNeverReconciled(ptfNew);

            /* Add the twin family to the briefcase's list of twin families. */

            if (AddPtr(GetBriefcaseTwinFamilyPtrArray(hbr), TwinFamilySortCmp, ptfNew, &aiUnused))
            {
               *pptf = ptfNew;
               bResult = TRUE;

               ASSERT(IS_VALID_STRUCT_PTR(*pptf, CTWINFAMILY));
            }
            else
            {
               DeleteString(hsName);
CREATETWINFAMILY_BAIL1:
               DestroyList(hlistObjectTwins);
CREATETWINFAMILY_BAIL2:
               FreeMemory(ptfNew);
            }
         }
         else
            goto CREATETWINFAMILY_BAIL1;
      }
      else
         goto CREATETWINFAMILY_BAIL2;
   }

   return(bResult);
}


/*
** CollapseTwinFamilies()
**
** Collapses two twin families into one.  N.b., this function should only be
** called on two twin families with the same object name!
**
** Arguments:     ptf1 - pointer to destination twin family
**                ptf2 - pointer to source twin family
**
** Returns:       void
**
** Side Effects:  Twin family *ptf2 is destroyed.
*/
PRIVATE_CODE void CollapseTwinFamilies(PTWINFAMILY ptf1, PTWINFAMILY ptf2)
{
   ASSERT(IS_VALID_STRUCT_PTR(ptf1, CTWINFAMILY));
   ASSERT(IS_VALID_STRUCT_PTR(ptf2, CTWINFAMILY));

   ASSERT(CompareNameStringsByHandle(ptf1->hsName, ptf2->hsName) == CR_EQUAL);

   /* Use the first twin family as the collapsed twin family. */

   /*
    * Change the parent twin family of the object twins in the second twin
    * family to the first twin family.
    */

   EVAL(WalkList(ptf2->hlistObjectTwins, &SetTwinFamilyWalker, ptf1));

   /* Append object list from second twin family on to first. */

   AppendList(ptf1->hlistObjectTwins, ptf2->hlistObjectTwins);

   MarkTwinFamilyNeverReconciled(ptf1);

   /* Wipe out the old twin family. */

   DestroyStub(&(ptf2->stub));

   ASSERT(IS_VALID_STRUCT_PTR(ptf1, CTWINFAMILY));

   return;
}


/*
** GenerateSpinOffObjectTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GenerateSpinOffObjectTwin(PVOID pot, PVOID pcsooti)
{
   BOOL bResult;
   HPATH hpathMatchingFolder;
   HNODE hnodeUnused;

   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(IS_VALID_STRUCT_PTR(pcsooti, CSPINOFFOBJECTTWININFO));

   /*
    * Append the generated object twin's subpath to the matching folder twin's
    * base path for subtree twins.
    */

   if (BuildPathForMatchingObjectTwin(
                     ((PCSPINOFFOBJECTTWININFO)pcsooti)->pcfp, pot,
                     GetBriefcasePathList(((POBJECTTWIN)pot)->ptfParent->hbr),
                     &hpathMatchingFolder))
   {
      /*
       * Does this generated object twin's twin family already contain an
       * object twin generated by the other half of the pair of folder twins?
       */

      if (! SearchUnsortedList(((POBJECTTWIN)pot)->ptfParent->hlistObjectTwins,
                               &ObjectTwinSearchCmp, hpathMatchingFolder,
                               &hnodeUnused))
      {
         /*
          * No.  Does the other object twin already exist in a different twin
          * family?
          */

         if (FindObjectTwin(((POBJECTTWIN)pot)->ptfParent->hbr,
                            hpathMatchingFolder,
                            GetString(((POBJECTTWIN)pot)->ptfParent->hsName),
                            &hnodeUnused))
         {
            /* Yes. */

            ASSERT(((PCOBJECTTWIN)GetNodeData(hnodeUnused))->ptfParent != ((POBJECTTWIN)pot)->ptfParent);

            bResult = TRUE;
         }
         else
         {
            POBJECTTWIN potNew;

            /*
             * No.  Create a new object twin, and add it to the bookkeeping
             * list of new object twins.
             */

            bResult = CreateObjectTwinAndAddToList(
                     ((POBJECTTWIN)pot)->ptfParent, hpathMatchingFolder,
                     ((PCSPINOFFOBJECTTWININFO)pcsooti)->hlistNewObjectTwins,
                     &potNew, &hnodeUnused);

#ifdef DEBUG

            if (bResult)
            {
               TRACE_OUT((TEXT("GenerateSpinOffObjectTwin(): Generated spin-off object twin for object %s\\%s."),
                          DebugGetPathString(potNew->hpath),
                          GetString(potNew->ptfParent->hsName)));
            }

#endif

         }
      }
      else
         bResult = TRUE;

      DeletePath(hpathMatchingFolder);
   }
   else
      bResult = FALSE;

   return(bResult);
}


/*
** BuildBradyBunch()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL BuildBradyBunch(PVOID pot, PVOID pcfp)
{
   BOOL bResult;
   HPATH hpathMatchingFolder;
   HNODE hnodeOther;

   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));

   /*
    * Append the generated object twin's subpath to the matching folder twin's
    * base path for subtree twins.
    */

   bResult = BuildPathForMatchingObjectTwin(
                     pcfp, pot,
                     GetBriefcasePathList(((POBJECTTWIN)pot)->ptfParent->hbr),
                     &hpathMatchingFolder);

   if (bResult)
   {
      /*
       * Does this generated object twin's twin family already contain an object
       * twin generated by the other half of the pair of folder twins?
       */

      if (! SearchUnsortedList(((POBJECTTWIN)pot)->ptfParent->hlistObjectTwins,
                               &ObjectTwinSearchCmp, hpathMatchingFolder,
                               &hnodeOther))
      {
         /*
          * The other object twin should already exist in a different twin family.
          */

         if (EVAL(FindObjectTwin(((POBJECTTWIN)pot)->ptfParent->hbr,
                                 hpathMatchingFolder,
                                 GetString(((POBJECTTWIN)pot)->ptfParent->hsName),
                                 &hnodeOther)))
         {
            PCOBJECTTWIN pcotOther;

            pcotOther = (PCOBJECTTWIN)GetNodeData(hnodeOther);

            if (EVAL(pcotOther->ptfParent != ((POBJECTTWIN)pot)->ptfParent))
            {
               /* It does.  Crush them. */

               CollapseTwinFamilies(((POBJECTTWIN)pot)->ptfParent,
                                    pcotOther->ptfParent);

               TRACE_OUT((TEXT("BuildBradyBunch(): Collapsed separate twin families for object %s\\%s and %s\\%s."),
                          DebugGetPathString(((POBJECTTWIN)pot)->hpath),
                          GetString(((POBJECTTWIN)pot)->ptfParent->hsName),
                          DebugGetPathString(pcotOther->hpath),
                          GetString(pcotOther->ptfParent->hsName)));
            }
         }
      }

      DeletePath(hpathMatchingFolder);
   }

   return(bResult);
}


/*
** CreateObjectTwinAndAddToList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreateObjectTwinAndAddToList(PTWINFAMILY ptf, HPATH hpathFolder,
                                          HLIST hlistObjectTwins,
                                          POBJECTTWIN *ppot, PHNODE phnode)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hlistObjectTwins, LIST));
   ASSERT(IS_VALID_WRITE_PTR(ppot, POBJECTTWIN));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   if (CreateObjectTwin(ptf, hpathFolder, ppot))
   {
      if (InsertNodeAtFront(hlistObjectTwins, NULL, *ppot, phnode))
         bResult = TRUE;
      else
         DestroyStub(&((*ppot)->stub));
   }

   return(bResult);
}


/*
** CreateListOfGeneratedObjectTwins()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreateListOfGeneratedObjectTwins(PCFOLDERPAIR pcfp,
                                             PHLIST phlistGeneratedObjectTwins)
{
   NEWLIST nl;
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_WRITE_PTR(phlistGeneratedObjectTwins, HLIST));

   nl.dwFlags = 0;

   if (CreateList(&nl, phlistGeneratedObjectTwins))
   {
      if (EnumGeneratedObjectTwins(pcfp, &InsertNodeAtFrontWalker, *phlistGeneratedObjectTwins))
         bResult = TRUE;
      else
         DestroyList(*phlistGeneratedObjectTwins);
   }

   return(bResult);
}


/*
** NotifyNewObjectTwins()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void NotifyNewObjectTwins(HLIST hlistNewObjectTwins,
                                       HCLSIFACECACHE hcic)
{
   BOOL bContinue;
   HNODE hnode;

   ASSERT(IS_VALID_HANDLE(hlistNewObjectTwins, LIST));
   ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));

   for (bContinue = GetFirstNode(hlistNewObjectTwins, &hnode);
        bContinue;
        bContinue = GetNextNode(hnode, &hnode))
   {
      PCOBJECTTWIN pcot;
      TCHAR rgchPath[MAX_PATH_LEN];
      CLSID clsidReplicaNotification;

      pcot = (PCOBJECTTWIN)GetNodeData(hnode);

      GetPathString(pcot->hpath, rgchPath);
      CatPath(rgchPath, GetString(pcot->ptfParent->hsName));
      ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

      if (SUCCEEDED(GetReplicaNotificationClassID(rgchPath,
                                                  &clsidReplicaNotification)))
      {
         PINotifyReplica pinr;

         if (SUCCEEDED(GetClassInterface(hcic, &clsidReplicaNotification,
                                         &IID_INotifyReplica, &pinr)))
            /* Ignore return value. */
            NotifyOneNewObjectTwin(pinr, pcot, rgchPath);
         else
            TRACE_OUT((TEXT("NotifyNewObjectTwins(): Failed to get INotifyReplica for replica %s."),
                       rgchPath));
      }
      else
         TRACE_OUT((TEXT("NotifyNewObjectTwins(): Failed to get replica notification class ID for replica %s."),
                    rgchPath));
   }

   return;
}


/*
** NotifyOneNewObjectTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT NotifyOneNewObjectTwin(PINotifyReplica pinr, PCOBJECTTWIN pcot,
                                       LPCTSTR pcszPath)
{
   HRESULT hr;
   HSTGIFACE hstgi;

   ASSERT(IS_VALID_STRUCT_PTR(pinr, CINotifyReplica));
   ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));

   hr = GetStorageInterface((PIUnknown)pinr, &hstgi);

   if (SUCCEEDED(hr))
   {
      hr = LoadFromStorage(hstgi, pcszPath);

      if (SUCCEEDED(hr))
      {
         ULONG ulcOtherReplicas;
         PIMoniker *ppimkOtherReplicas;

         /*
          * RAIDRAID: (16270) (Performance) We may create a file moniker for
          * the same object twin multiple times here.
          */

         hr = CreateOtherReplicaMonikers(pcot, &ulcOtherReplicas,
                                         &ppimkOtherReplicas);

         if (SUCCEEDED(hr))
         {
            hr = pinr->lpVtbl->YouAreAReplica(pinr, ulcOtherReplicas,
                                              ppimkOtherReplicas);

            if (SUCCEEDED(hr))
            {
               hr = SaveToStorage(hstgi);

               if (SUCCEEDED(hr))
                  TRACE_OUT((TEXT("NotifyOneNewObjectTwin(): Replica %s successfully notified."),
                             pcszPath));
               else
                  WARNING_OUT((TEXT("NotifyOneNewObjectTwin(): Failed to save replica %s to storage."),
                               pcszPath));
            }
            else
               WARNING_OUT((TEXT("NotifyOneNewObjectTwin(): Failed to notify replica %s."),
                            pcszPath));

            ReleaseIUnknowns(ulcOtherReplicas,
                             (PIUnknown *)ppimkOtherReplicas);
         }
         else
            WARNING_OUT((TEXT("NotifyOneNewObjectTwin(): Failed to create monikers for other replicas of replica %s."),
                         pcszPath));
      }
      else
         WARNING_OUT((TEXT("NotifyOneNewObjectTwin(): Failed to load replica %s from storage."),
                      pcszPath));

      ReleaseStorageInterface(hstgi);
   }
   else
      WARNING_OUT((TEXT("NotifyOneNewObjectTwin(): Failed to get storage interface for replica %s."),
                   pcszPath));

   return(hr);
}


/*
** CreateOtherReplicaMonikers()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE HRESULT CreateOtherReplicaMonikers(PCOBJECTTWIN pcotMaster,
                                           PULONG pulcOtherReplicas,
                                           PIMoniker **pppimk)
{
   HRESULT hr;
   HLIST hlist;
   ULONG ulcOtherReplicas;

   ASSERT(IS_VALID_STRUCT_PTR(pcotMaster, COBJECTTWIN));
   ASSERT(IS_VALID_WRITE_PTR(pulcOtherReplicas, ULONG));
   ASSERT(IS_VALID_WRITE_PTR(pppimk, PIMoniker *));

   hlist = pcotMaster->ptfParent->hlistObjectTwins;

   ulcOtherReplicas = GetNodeCount(hlist);
   ASSERT(ulcOtherReplicas > 0);
   ulcOtherReplicas--;

   if (AllocateMemory(ulcOtherReplicas * sizeof(**pppimk), (PVOID *)pppimk))
   {
      BOOL bContinue;
      HNODE hnode;

      hr = S_OK;
      *pulcOtherReplicas = 0;

      for (bContinue = GetFirstNode(hlist, &hnode);
           bContinue;
           bContinue = GetNextNode(hnode, &hnode))
      {
         PCOBJECTTWIN pcot;

         pcot = (PCOBJECTTWIN)GetNodeData(hnode);

         if (pcot != pcotMaster)
         {
            TCHAR rgchPath[MAX_PATH_LEN];

            GetPathString(pcot->hpath, rgchPath);

            hr = MyCreateFileMoniker(rgchPath,
                                     GetString(pcot->ptfParent->hsName),
                                     &((*pppimk)[*pulcOtherReplicas]));

            if (SUCCEEDED(hr))
            {
               ASSERT(*pulcOtherReplicas < ulcOtherReplicas);
               (*pulcOtherReplicas)++;
            }
            else
               break;
         }
      }

      if (FAILED(hr))
         ReleaseIUnknowns(*pulcOtherReplicas, *(PIUnknown **)pppimk);
   }
   else
      hr = E_OUTOFMEMORY;

   return(hr);
}


/*
** TwinFamilySortCmp()
**
** Pointer comparison function used to sort the global array of twin families.
**
** Arguments:     pctf1 - pointer to TWINFAMILY describing first twin family
**                pctf2 - pointer to TWINFAMILY describing second twin family
**
** Returns:
**
** Side Effects:  none
**
** Twin families are sorted by:
**    1) name string
**    2) pointer value
*/
PRIVATE_CODE COMPARISONRESULT TwinFamilySortCmp(PCVOID pctf1, PCVOID pctf2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pctf1, CTWINFAMILY));
   ASSERT(IS_VALID_STRUCT_PTR(pctf2, CTWINFAMILY));

   cr = CompareNameStringsByHandle(((PCTWINFAMILY)pctf1)->hsName, ((PCTWINFAMILY)pctf2)->hsName);

   if (cr == CR_EQUAL)
      /* Same name strings.  Now sort by pointer value. */
      cr = ComparePointers(pctf1, pctf2);

   return(cr);
}


/*
** TwinFamilySearchCmp()
**
** Pointer comparison function used to search the global array of twin families
** for the first twin family for a given name.
**
** Arguments:     pcszName - name string to search for
**                pctf - pointer to TWINFAMILY to examine
**
** Returns:
**
** Side Effects:  none
**
** Twin families are searched by:
**    1) name string
*/
PRIVATE_CODE COMPARISONRESULT TwinFamilySearchCmp(PCVOID pcszName, PCVOID pctf)
{
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY));

   return(CompareNameStrings(pcszName, GetString(((PCTWINFAMILY)pctf)->hsName)));
}


/*
** ObjectTwinSearchCmp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL ObjectTwinSearchCmp(PCVOID hpath, PCVOID pcot)
{
   ASSERT(IS_VALID_HANDLE((HPATH)hpath, PATH));
   ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));

   return(ComparePaths((HPATH)hpath, ((PCOBJECTTWIN)pcot)->hpath));
}


/*
** WriteTwinFamily()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT WriteTwinFamily(HCACHEDFILE hcf, PCTWINFAMILY pctf)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
   DWORD dwcbTwinFamilyDBHeaderOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY));

   /* Save initial file poisition. */

   dwcbTwinFamilyDBHeaderOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbTwinFamilyDBHeaderOffset != INVALID_SEEK_POSITION)
   {
      TWINFAMILYDBHEADER tfdbh;

      /* Leave space for the twin family's header. */

      ZeroMemory(&tfdbh, sizeof(tfdbh));

      if (WriteToCachedFile(hcf, (PCVOID)&tfdbh, sizeof(tfdbh), NULL))
      {
         BOOL bContinue;
         HNODE hnode;
         LONG lcObjectTwins = 0;

         /* Save twin family's object twins. */

         ASSERT(GetNodeCount(pctf->hlistObjectTwins) >= 2);

         tr = TR_SUCCESS;

         for (bContinue = GetFirstNode(pctf->hlistObjectTwins, &hnode);
              bContinue;
              bContinue = GetNextNode(hnode, &hnode))
         {
            POBJECTTWIN pot;

            pot = (POBJECTTWIN)GetNodeData(hnode);

            tr = WriteObjectTwin(hcf, pot);

            if (tr == TR_SUCCESS)
            {
               ASSERT(lcObjectTwins < LONG_MAX);
               lcObjectTwins++;
            }
            else
               break;
         }

         /* Save twin family's database header. */

         if (tr == TR_SUCCESS)
         {
            ASSERT(lcObjectTwins >= 2);

            tfdbh.dwStubFlags = (pctf->stub.dwFlags & DB_STUB_FLAGS_MASK);
            tfdbh.hsName = pctf->hsName;
            tfdbh.lcObjectTwins = lcObjectTwins;

            tr = WriteDBSegmentHeader(hcf, dwcbTwinFamilyDBHeaderOffset, &tfdbh, sizeof(tfdbh));
         }
      }
   }

   return(tr);
}


/*
** WriteObjectTwin()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT WriteObjectTwin(HCACHEDFILE hcf, PCOBJECTTWIN pcot)
{
   TWINRESULT tr;
   DBOBJECTTWIN dbot;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));

   /* Set up object twin database structure. */

   dbot.dwStubFlags = (pcot->stub.dwFlags & DB_STUB_FLAGS_MASK);
   dbot.hpath = pcot->hpath;
   dbot.hpath = pcot->hpath;
   dbot.fsLastRec = pcot->fsLastRec;

   /* Save object twin database structure. */

   if (WriteToCachedFile(hcf, (PCVOID)&dbot, sizeof(dbot), NULL))
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


/*
** ReadTwinFamily()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT ReadTwinFamily(HCACHEDFILE hcf, HBRFCASE hbr,
                                  PCDBVERSION pcdbver,
                                  HHANDLETRANS hhtFolderTrans,
                                  HHANDLETRANS hhtNameTrans)
{
   TWINRESULT tr = TR_CORRUPT_BRIEFCASE;
   TWINFAMILYDBHEADER tfdbh;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_READ_PTR(pcdbver, DBVERSION));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtNameTrans, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &tfdbh, sizeof(tfdbh), &dwcbRead) &&
       dwcbRead == sizeof(tfdbh))
   {
      if (tfdbh.lcObjectTwins >= 2)
      {
         HSTRING hsName;

         if (TranslateHandle(hhtNameTrans, (HGENERIC)(tfdbh.hsName), (PHGENERIC)&hsName))
         {
            PTWINFAMILY ptfParent;

            if (CreateTwinFamily(hbr, GetString(hsName), &ptfParent))
            {
               LONG l;

               CopyTwinFamilyInfo(ptfParent, &tfdbh);

               tr = TR_SUCCESS;

               for (l = tfdbh.lcObjectTwins;
                    l > 0 && tr == TR_SUCCESS;
                    l--)
                  tr = ReadObjectTwin(hcf, pcdbver, ptfParent, hhtFolderTrans);

               if (tr != TR_SUCCESS)
                  DestroyStub(&(ptfParent->stub));
            }
            else
               tr = TR_OUT_OF_MEMORY;
         }
      }
   }

   return(tr);
}


/*
** ReadObjectTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT ReadObjectTwin(HCACHEDFILE hcf, 
                                  PCDBVERSION pcdbver,
                                  PTWINFAMILY ptfParent,
                                  HHANDLETRANS hhtFolderTrans)
{
   TWINRESULT tr;
   DBOBJECTTWIN dbot;
   DWORD dwcbRead;
   HPATH hpath;
   DWORD dwcbSize;
   COPYOBJECTTWINPROC pfnCopy;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_READ_PTR(pcdbver, DBVERSION));
   ASSERT(IS_VALID_STRUCT_PTR(ptfParent, CTWINFAMILY));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));

   if (HEADER_M8_MINOR_VER == pcdbver->dwMinorVer)
   {
      /* The M8 database does not have the ftModLocal in the FILESTAMP
      ** structure.
      */

      dwcbSize = sizeof(dbot) - sizeof(FILETIME);
      pfnCopy = CopyM8ObjectTwinInfo;
   }
   else
   {
      ASSERT(HEADER_MINOR_VER == pcdbver->dwMinorVer);
      dwcbSize = sizeof(dbot);
      pfnCopy = CopyObjectTwinInfo;
   }

   if ((ReadFromCachedFile(hcf, &dbot, dwcbSize, &dwcbRead) &&
        dwcbRead == dwcbSize) &&
       TranslateHandle(hhtFolderTrans, (HGENERIC)(dbot.hpath), (PHGENERIC)&hpath))
   {
      POBJECTTWIN pot;

      /* Create the new object twin and add it to the twin family. */

      if (CreateObjectTwin(ptfParent, hpath, &pot))
      {
          pfnCopy(pot, &dbot);

          tr = TR_SUCCESS;
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


/*
** CopyTwinFamilyInfo()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE void CopyTwinFamilyInfo(PTWINFAMILY ptf,
                                PCTWINFAMILYDBHEADER pctfdbh)
{
   ASSERT(IS_VALID_WRITE_PTR(ptf, TWINFAMILY));
   ASSERT(IS_VALID_READ_PTR(pctfdbh, CTWINFAMILYDBHEADER));

   ptf->stub.dwFlags = pctfdbh->dwStubFlags;

   return;
}


/*
** CopyObjectTwinInfo()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE void CopyObjectTwinInfo(POBJECTTWIN pot, PCDBOBJECTTWIN pcdbot)
{
   ASSERT(IS_VALID_WRITE_PTR(pot, OBJECTTWIN));
   ASSERT(IS_VALID_READ_PTR(pcdbot, CDBOBJECTTWIN));

   pot->stub.dwFlags = pcdbot->dwStubFlags;
   pot->fsLastRec = pcdbot->fsLastRec;

   return;
}


/*
** CopyM8ObjectTwinInfo()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE void CopyM8ObjectTwinInfo(POBJECTTWIN pot, PCDBOBJECTTWIN pcdbot)
{
   ASSERT(IS_VALID_WRITE_PTR(pot, OBJECTTWIN));
   ASSERT(IS_VALID_READ_PTR(pcdbot, CDBOBJECTTWIN));

   pot->stub.dwFlags = pcdbot->dwStubFlags;
   pot->fsLastRec = pcdbot->fsLastRec;

   /* The pot->fsLastRec.ftModLocal field is invalid, so fill it in */

   if ( !FileTimeToLocalFileTime(&pot->fsLastRec.ftMod, &pot->fsLastRec.ftModLocal) )
   {
      /* Just copy the time if FileTimeToLocalFileTime failed */

      pot->fsLastRec.ftModLocal = pot->fsLastRec.ftMod;
   }

   return;
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** DestroyObjectTwinStubWalker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL DestroyObjectTwinStubWalker(PVOID pot, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pvUnused);

   /*
    * Set ulcSrcFolderTwins to 0 so UnlinkObjectTwin() succeeds.
    * DestroyStub() will unlink and destroy any new twin family created.
    */

   ((POBJECTTWIN)pot)->ulcSrcFolderTwins = 0;
   DestroyStub(&(((POBJECTTWIN)pot)->stub));

   return(TRUE);
}


/*
** MarkObjectTwinNeverReconciledWalker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL MarkObjectTwinNeverReconciledWalker(PVOID pot, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pvUnused);

   MarkObjectTwinNeverReconciled(pot);

   return(TRUE);
}


/*
** LookForSrcFolderTwinsWalker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL LookForSrcFolderTwinsWalker(PVOID pot, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pvUnused);

   return(! ((POBJECTTWIN)pot)->ulcSrcFolderTwins);
}


/*
** IncrementSrcFolderTwinsWalker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IncrementSrcFolderTwinsWalker(PVOID pot, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pvUnused);

   ASSERT(((POBJECTTWIN)pot)->ulcSrcFolderTwins < ULONG_MAX);
   ((POBJECTTWIN)pot)->ulcSrcFolderTwins++;

   return(TRUE);
}


/*
** ClearSrcFolderTwinsWalker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL ClearSrcFolderTwinsWalker(PVOID pot, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pvUnused);

   ((POBJECTTWIN)pot)->ulcSrcFolderTwins = 0;

   return(TRUE);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** SetTwinFamilyWalker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SetTwinFamilyWalker(PVOID pot, PVOID ptfParent)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(IS_VALID_STRUCT_PTR(ptfParent, CTWINFAMILY));

   ((POBJECTTWIN)pot)->ptfParent = ptfParent;

   return(TRUE);
}


/*
** InsertNodeAtFrontWalker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL InsertNodeAtFrontWalker(POBJECTTWIN pot, PVOID hlist)
{
   HNODE hnodeUnused;

   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   return(InsertNodeAtFront(hlist, NULL, pot, &hnodeUnused));
}


#ifdef VSTF

/*
** IsValidObjectTwinWalker()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidObjectTwinWalker(PVOID pcot, PVOID pctfParent)
{
   return(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN) &&
          EVAL(((PCOBJECTTWIN)pcot)->ptfParent == pctfParent) &&
          EVAL(IsStubFlagClear(&(((PCOBJECTTWIN)pcot)->stub), STUB_FL_KEEP) ||
               IsStubFlagSet(&(((PCTWINFAMILY)pctfParent)->stub),
                             STUB_FL_DELETION_PENDING)));
}


/*
** IsValidPCNEWOBJECTTWIN()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCNEWOBJECTTWIN(PCNEWOBJECTTWIN pcnot)
{
   return(IS_VALID_READ_PTR(pcnot, CNEWOBJECTTWIN) &&
          EVAL(pcnot->ulSize == sizeof(*pcnot)) &&
          IS_VALID_STRING_PTR(pcnot->pcszFolder1, CSTR) &&
          IS_VALID_STRING_PTR(pcnot->pcszFolder2, CSTR) &&
          IS_VALID_STRING_PTR(pcnot->pcszName, CSTR));
}


/*
** IsValidPCSPINOFFOBJECTTWININFO()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCSPINOFFOBJECTTWININFO(PCSPINOFFOBJECTTWININFO pcsooti)
{
   return(IS_VALID_READ_PTR(pcsooti, CSPINOFFOBJECTTWININFO) &&
          IS_VALID_STRUCT_PTR(pcsooti->pcfp, CFOLDERPAIR) &&
          IS_VALID_HANDLE(pcsooti->hlistNewObjectTwins, LIST));
}

#endif


#ifdef DEBUG

/*
** AreTwinFamiliesValid()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL AreTwinFamiliesValid(HPTRARRAY hpaTwinFamilies)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpaTwinFamilies, PTRARRAY));

   aicPtrs = GetPtrCount(hpaTwinFamilies);

   for (ai = 0; ai < aicPtrs; ai++)
   {
      PCTWINFAMILY pctf;

      pctf = GetPtr(hpaTwinFamilies, ai);

      if (! IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY) ||
          ! EVAL(GetNodeCount(pctf->hlistObjectTwins) >= 2))
         break;
   }

   return(ai == aicPtrs);
}

#endif


/****************************** Public Functions *****************************/


/*
** CompareNameStrings()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT CompareNameStrings(LPCTSTR pcszFirst, LPCTSTR pcszSecond)
{
   ASSERT(IS_VALID_STRING_PTR(pcszFirst, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszSecond, CSTR));

   return(MapIntToComparisonResult(lstrcmpi(pcszFirst, pcszSecond)));
}


/*
** CompareNameStringsByHandle()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT CompareNameStringsByHandle(HSTRING hsFirst,
                                                        HSTRING hsSecond)
{
   ASSERT(IS_VALID_HANDLE(hsFirst, STRING));
   ASSERT(IS_VALID_HANDLE(hsSecond, STRING));

   return(CompareStringsI(hsFirst, hsSecond));
}


/*
** TranslatePATHRESULTToTWINRESULT()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT TranslatePATHRESULTToTWINRESULT(PATHRESULT pr)
{
   TWINRESULT tr;

   switch (pr)
   {
      case PR_SUCCESS:
         tr = TR_SUCCESS;
         break;

      case PR_UNAVAILABLE_VOLUME:
         tr = TR_UNAVAILABLE_VOLUME;
         break;

      case PR_OUT_OF_MEMORY:
         tr = TR_OUT_OF_MEMORY;
         break;

      default:
         ASSERT(pr == PR_INVALID_PATH);
         tr = TR_INVALID_PARAMETER;
         break;
   }

   return(tr);
}


/*
** CreateTwinFamilyPtrArray()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreateTwinFamilyPtrArray(PHPTRARRAY phpa)
{
   NEWPTRARRAY npa;

   ASSERT(IS_VALID_WRITE_PTR(phpa, HPTRARRAY));

   /* Try to create a twin family pointer array. */

   npa.aicInitialPtrs = NUM_START_TWIN_FAMILY_PTRS;
   npa.aicAllocGranularity = NUM_TWIN_FAMILY_PTRS_TO_ADD;
   npa.dwFlags = NPA_FL_SORTED_ADD;

   return(CreatePtrArray(&npa, phpa));
}


/*
** DestroyTwinFamilyPtrArray()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyTwinFamilyPtrArray(HPTRARRAY hpa)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   /* First free all twin families in pointer array. */

   aicPtrs = GetPtrCount(hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      DestroyTwinFamily(GetPtr(hpa, ai));

   /* Now wipe out the pointer array. */

   DestroyPtrArray(hpa);

   return;
}


/*
** GetTwinBriefcase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HBRFCASE GetTwinBriefcase(HTWIN htwin)
{
   HBRFCASE hbr;

   ASSERT(IS_VALID_HANDLE(htwin, TWIN));

   switch (((PSTUB)htwin)->st)
   {
      case ST_OBJECTTWIN:
         hbr = ((PCOBJECTTWIN)htwin)->ptfParent->hbr;
         break;

      case ST_TWINFAMILY:
         hbr = ((PCTWINFAMILY)htwin)->hbr;
         break;

      case ST_FOLDERPAIR:
         hbr = ((PCFOLDERPAIR)htwin)->pfpd->hbr;
         break;

      default:
         ERROR_OUT((TEXT("GetTwinBriefcase() called on unrecognized stub type %d."),
                    ((PSTUB)htwin)->st));
         hbr = NULL;
         break;
   }

   return(hbr);
}


/*
** FindObjectTwinInList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL FindObjectTwinInList(HLIST hlist, HPATH hpath, PHNODE phnode)
{
   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_HANDLE(hpath, PATH));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   return(SearchUnsortedList(hlist, &ObjectTwinSearchCmp, hpath, phnode));
}


/*
** EnumTwins()
**
** Enumerates folder twins and twin families in a briefcase.
**
** Arguments:
**
** Returns:       TRUE if halted.  FALSE if not.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL EnumTwins(HBRFCASE hbr, ENUMTWINSPROC etp, LPARAM lpData,
                           PHTWIN phtwinStop)
{
   HPTRARRAY hpa;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_CODE_PTR(etp, ENUMTWINSPROC));
   ASSERT(IS_VALID_WRITE_PTR(phtwinStop, HTWIN));

   /* Enumerate folder pairs. */

   *phtwinStop = NULL;

   hpa = GetBriefcaseFolderPairPtrArray(hbr);

   aicPtrs = GetPtrCount(hpa);

   for (ai = 0; ai < aicPtrs; ai++)
   {
      PCFOLDERPAIR pcfp;

      pcfp = GetPtr(hpa, ai);

      ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));

      if (! (*etp)((HTWIN)pcfp, lpData))
      {
         *phtwinStop = (HTWIN)pcfp;
         break;
      }
   }

   if (! *phtwinStop)
   {
      /* Enumerate twin families. */

      hpa = GetBriefcaseTwinFamilyPtrArray(hbr);

      aicPtrs = GetPtrCount(hpa);

      for (ai = 0; ai < aicPtrs; ai++)
      {
         PCTWINFAMILY pctf;

         pctf = GetPtr(hpa, ai);

         ASSERT(IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY));

         if (! (*etp)((HTWIN)pctf, lpData))
         {
            *phtwinStop = (HTWIN)pctf;
            break;
         }
      }
   }

   return(*phtwinStop != NULL);
}


/*
** FindObjectTwin()
**
** Looks for a twin family containing a specified object twin.
**
** Arguments:     hpathFolder - folder containing object
**                pcszName - name of object
**
** Returns:       Handle to list node containing pointer to object twin if
**                found, or NULL if not found.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL FindObjectTwin(HBRFCASE hbr, HPATH hpathFolder,
                                LPCTSTR pcszName, PHNODE phnode)
{
   BOOL bFound = FALSE;
   HPTRARRAY hpaTwinFamilies;
   ARRAYINDEX aiFirst;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   /* Search for a matching twin family. */

   *phnode = NULL;

   hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(hbr);

   if (SearchSortedArray(hpaTwinFamilies, &TwinFamilySearchCmp, pcszName,
                         &aiFirst))
   {
      ARRAYINDEX aicPtrs;
      ARRAYINDEX ai;
      PTWINFAMILY ptf;

      /*
       * aiFirst holds the index of the first twin family with a common object
       * name matching pcszName.
       */

      /*
       * Now search each of these twin families for a folder matching
       * pcszFolder.
       */

      aicPtrs = GetPtrCount(hpaTwinFamilies);

      ASSERT(aicPtrs > 0);
      ASSERT(aiFirst >= 0);
      ASSERT(aiFirst < aicPtrs);

      for (ai = aiFirst; ai < aicPtrs; ai++)
      {
         ptf = GetPtr(hpaTwinFamilies, ai);

         ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

         /* Is this a twin family of objects of the given name? */

         if (CompareNameStrings(GetString(ptf->hsName), pcszName) == CR_EQUAL)
         {
            bFound = SearchUnsortedList(ptf->hlistObjectTwins,
                                        &ObjectTwinSearchCmp, hpathFolder,
                                        phnode);

            if (bFound)
               break;
         }
         else
            /* No.  Stop searching. */
            break;
      }
   }

   return(bFound);
}


/*
** TwinObjects()
**
** Twins two objects.
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
**
** N.b., *ppot1 and *ppot2 are valid if TR_SUCCESS or TR_DUPLICATE_TWIN is
** returned.
*/
PUBLIC_CODE TWINRESULT TwinObjects(HBRFCASE hbr, HCLSIFACECACHE hcic,
                                   HPATH hpathFolder1, HPATH hpathFolder2,
                                   LPCTSTR pcszName, POBJECTTWIN *ppot1,
                                   POBJECTTWIN *ppot2)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));
   ASSERT(IS_VALID_HANDLE(hpathFolder1, PATH));
   ASSERT(IS_VALID_HANDLE(hpathFolder2, PATH));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppot1, POBJECTTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppot2, POBJECTTWIN));

   /* Fail twinning a file to itself. */

   if (ComparePaths(hpathFolder1, hpathFolder2) != CR_EQUAL)
   {
      NEWLIST nl;
      HLIST hlistNewObjectTwins;

      nl.dwFlags = 0;

      if (CreateList(&nl, &hlistNewObjectTwins))
      {
         /* Twin 'em. */

         tr = TwinJustTheseTwoObjects(hbr, hpathFolder1, hpathFolder2,
                                      pcszName, ppot1, ppot2,
                                      hlistNewObjectTwins);

         /*
          * Add any new object twins to the lists of generated object twins for
          * all intersecting folder twins.  Create new spin-off object twins
          * from the other folder twin connected to each intersecting folder
          * twin.  Spin-off object twins are added to the twin family as they
          * are created.
          */

         if (tr == TR_SUCCESS)
         {
            if (ApplyNewObjectTwinsToFolderTwins(hlistNewObjectTwins))
            {
               /*
                * Notify new object twins that they are object twins.  Don't
                * notify folder object twins.
                */

               if (*pcszName)
                  NotifyNewObjectTwins(hlistNewObjectTwins, hcic);
            }
            else
               tr = TR_OUT_OF_MEMORY;
         }

         if (tr != TR_SUCCESS)
            /*
             * We must maintain a consistent internal state by deleting any new
             * twin family and object twins on failure, independent of source
             * folder twin count.
             */
            EVAL(WalkList(hlistNewObjectTwins, &DestroyObjectTwinStubWalker,
                          NULL));

         DestroyList(hlistNewObjectTwins);
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TR_SAME_FOLDER;

   ASSERT((tr != TR_SUCCESS && tr != TR_DUPLICATE_TWIN) ||
          IS_VALID_STRUCT_PTR(*ppot1, COBJECTTWIN) && IS_VALID_STRUCT_PTR(*ppot2, COBJECTTWIN));

   return(tr);
}


/*
** CreateObjectTwin()
**
** Creates a new object twin, and adds it to a twin family.
**
** Arguments:     ptf - pointer to parent twin family
**                hpathFolder - folder of new object twin
**
** Returns:       Pointer to new object twin if successful, or NULL if
**                unsuccessful.
**
** Side Effects:  none
**
** N.b., this function does not first check to see if the object twin already
** exists in the family.
*/
PUBLIC_CODE BOOL CreateObjectTwin(PTWINFAMILY ptf, HPATH hpathFolder,
                             POBJECTTWIN *ppot)
{
   BOOL bResult = FALSE;
   POBJECTTWIN potNew;

   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_WRITE_PTR(ppot, POBJECTTWIN));

#ifdef DEBUG

   {
      HNODE hnodeUnused;

      /* Is this object twin already in a twin family? */

      if (FindObjectTwin(ptf->hbr, hpathFolder, GetString(ptf->hsName), &hnodeUnused))
         ERROR_OUT((TEXT("CreateObjectTwin(): An object twin for %s\\%s already exists."),
                    DebugGetPathString(hpathFolder),
                    GetString(ptf->hsName)));
   }

#endif

   /* Create a new OBJECTTWIN structure. */

   if (AllocateMemory(sizeof(*potNew), &potNew))
   {
      if (CopyPath(hpathFolder, GetBriefcasePathList(ptf->hbr), &(potNew->hpath)))
      {
         HNODE hnodeUnused;

         /* Fill in new OBJECTTWIN fields. */

         InitStub(&(potNew->stub), ST_OBJECTTWIN);

         potNew->ptfParent = ptf;
         potNew->ulcSrcFolderTwins = 0;

         MarkObjectTwinNeverReconciled(potNew);

         /* Add the object twin to the twin family's list of object twins. */

         if (InsertNodeAtFront(ptf->hlistObjectTwins, NULL, potNew, &hnodeUnused))
         {
            *ppot = potNew;
            bResult = TRUE;

            ASSERT(IS_VALID_STRUCT_PTR(*ppot, COBJECTTWIN));
         }
         else
         {
            DeletePath(potNew->hpath);
CREATEOBJECTTWIN_BAIL:
            FreeMemory(potNew);
         }
      }
      else
         goto CREATEOBJECTTWIN_BAIL;
   }

   return(bResult);
}


/*
** UnlinkObjectTwin()
**
** Unlinks an object twin.
**
** Arguments:     pot - pointer to object twin to unlink
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT UnlinkObjectTwin(POBJECTTWIN pot)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

   ASSERT(IsStubFlagClear(&(pot->stub), STUB_FL_UNLINKED));

   TRACE_OUT((TEXT("UnlinkObjectTwin(): Unlinking object twin for folder %s."),
              DebugGetPathString(pot->hpath)));

   /* Is the object twin's twin family being deleted? */

   if (IsStubFlagSet(&(pot->ptfParent->stub), STUB_FL_BEING_DELETED))
      /* Yes.  No need to unlink the object twin. */
      tr = TR_SUCCESS;
   else
   {
      /* Are there any folder twin sources left for this object twin? */

      if (! pot->ulcSrcFolderTwins)
      {
         HNODE hnode;

         /*
          * Search the object twin's parent's list of object twins for the
          * object twin to be unlinked.
          */

         if (EVAL(FindObjectTwinInList(pot->ptfParent->hlistObjectTwins, pot->hpath, &hnode)) &&
             EVAL(GetNodeData(hnode) == pot))
         {
            ULONG ulcRemainingObjectTwins;

            /* Unlink the object twin. */

            DeleteNode(hnode);

            SetStubFlag(&(pot->stub), STUB_FL_UNLINKED);

            /*
             * If we have just unlinked the second last object twin in a twin
             * family, destroy the twin family.
             */

            ulcRemainingObjectTwins = GetNodeCount(pot->ptfParent->hlistObjectTwins);

            if (ulcRemainingObjectTwins < 2)
            {

#ifdef DEBUG

               TCHAR rgchName[MAX_NAME_LEN];

               lstrcpy(rgchName, GetString(pot->ptfParent->hsName));

#endif

               /* It's the end of the family line. */

               tr = DestroyStub(&(pot->ptfParent->stub));

#ifdef DEBUG

               if (tr == TR_SUCCESS)
                  TRACE_OUT((TEXT("UnlinkObjectTwin(): Implicitly destroyed twin family for object %s."),
                             rgchName));

#endif

               if (ulcRemainingObjectTwins == 1 &&
                   tr == TR_HAS_FOLDER_TWIN_SRC)
                  tr = TR_SUCCESS;
            }
            else
               tr = TR_SUCCESS;
         }
         else
            tr = TR_INVALID_PARAMETER;

         ASSERT(tr == TR_SUCCESS);
      }
      else
         tr = TR_HAS_FOLDER_TWIN_SRC;
   }

   return(tr);
}


/*
** DestroyObjectTwin()
**
** Destroys an object twin.
**
** Arguments:     pot - pointer to object twin to destroy
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyObjectTwin(POBJECTTWIN pot)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

   TRACE_OUT((TEXT("DestroyObjectTwin(): Destroying object twin for folder %s."),
              DebugGetPathString(pot->hpath)));

   DeletePath(pot->hpath);
   FreeMemory(pot);

   return;
}


/*
** UnlinkTwinFamily()
**
** Unlinks a twin family.
**
** Arguments:     ptf - pointer to twin family to unlink
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT UnlinkTwinFamily(PTWINFAMILY ptf)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

   ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED));
   ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_BEING_DELETED));

   /*
    * A twin family containing object twins generated by folder twins may not
    * be deleted, since those object twins may not be directly deleted.
    */

   if (WalkList(ptf->hlistObjectTwins, &LookForSrcFolderTwinsWalker, NULL))
   {
      HPTRARRAY hpaTwinFamilies;
      ARRAYINDEX aiUnlink;

      TRACE_OUT((TEXT("UnlinkTwinFamily(): Unlinking twin family for object %s."),
                 GetString(ptf->hsName)));

      /* Search for the twin family to be unlinked. */

      hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(ptf->hbr);

      if (EVAL(SearchSortedArray(hpaTwinFamilies, &TwinFamilySortCmp, ptf,
                                 &aiUnlink)))
      {
         /* Unlink the twin family. */

         ASSERT(GetPtr(hpaTwinFamilies, aiUnlink) == ptf);

         DeletePtr(hpaTwinFamilies, aiUnlink);

         SetStubFlag(&(ptf->stub), STUB_FL_UNLINKED);
      }

      tr = TR_SUCCESS;
   }
   else
      tr = TR_HAS_FOLDER_TWIN_SRC;

   return(tr);
}


/*
** DestroyTwinFamily()
**
** Destroys a twin family.
**
** Arguments:     ptf - pointer to twin family to destroy
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyTwinFamily(PTWINFAMILY ptf)
{
   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

   ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_BEING_DELETED));

   TRACE_OUT((TEXT("DestroyTwinFamily(): Destroying twin family for object %s."),
              GetString(ptf->hsName)));

   SetStubFlag(&(ptf->stub), STUB_FL_BEING_DELETED);

   /*
    * Destroy the object twins in the family one by one.  Be careful not to use
    * an object twin after it has been destroyed.
    */

   EVAL(WalkList(ptf->hlistObjectTwins, &DestroyObjectTwinStubWalker, NULL));

   /* Destroy TWINFAMILY fields. */

   DestroyList(ptf->hlistObjectTwins);
   DeleteString(ptf->hsName);
   FreeMemory(ptf);

   return;
}


/*
** MarkTwinFamilyNeverReconciled()
**
** Marks a twin family as never reconciled.
**
** Arguments:     ptf - pointer to twin family to be marked never reconciled
**
** Returns:       void
**
** Side Effects:  Clears the twin family's last reconciliation time stamp.
**                Marks all the object twins in the family never reconciled.
*/
PUBLIC_CODE void MarkTwinFamilyNeverReconciled(PTWINFAMILY ptf)
{
   /*
    * If we're being called from CreateTwinFamily(), the fields we're about to
    * set may currently be invalid.  Don't fully verify the TWINFAMILY
    * structure.
    */

   ASSERT(IS_VALID_WRITE_PTR(ptf, TWINFAMILY));

   /* Mark all object twins in twin family as never reconciled. */

   EVAL(WalkList(ptf->hlistObjectTwins, MarkObjectTwinNeverReconciledWalker, NULL));

   return;
}


/*
** MarkObjectTwinNeverReconciled()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE void MarkObjectTwinNeverReconciled(PVOID pot)
{
   /*
    * If we're being called from CreateObjectTwin(), the fields we're about to
    * set may currently be invalid.  Don't fully verify the OBJECTTWIN
    * structure.
    */

   ASSERT(IS_VALID_WRITE_PTR((PCOBJECTTWIN)pot, COBJECTTWIN));

   ASSERT(IsStubFlagClear(&(((PCOBJECTTWIN)pot)->stub), STUB_FL_NOT_RECONCILED));

   ZeroMemory(&(((POBJECTTWIN)pot)->fsLastRec),
              sizeof(((POBJECTTWIN)pot)->fsLastRec));

   ((POBJECTTWIN)pot)->fsLastRec.fscond = FS_COND_UNAVAILABLE;

   return;
}


/*
** MarkTwinFamilyDeletionPending()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void MarkTwinFamilyDeletionPending(PTWINFAMILY ptf)
{
   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

   if (IsStubFlagClear(&(ptf->stub), STUB_FL_DELETION_PENDING))
      TRACE_OUT((TEXT("MarkTwinFamilyDeletionPending(): Deletion now pending for twin family for %s."),
                 GetString(ptf->hsName)));

   SetStubFlag(&(ptf->stub), STUB_FL_DELETION_PENDING);

   return;
}


/*
** UnmarkTwinFamilyDeletionPending()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void UnmarkTwinFamilyDeletionPending(PTWINFAMILY ptf)
{
   BOOL bContinue;
   HNODE hnode;

   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

   if (IsStubFlagSet(&(ptf->stub), STUB_FL_DELETION_PENDING))
   {
      for (bContinue = GetFirstNode(ptf->hlistObjectTwins, &hnode);
           bContinue;
           bContinue = GetNextNode(hnode, &hnode))
      {
         POBJECTTWIN pot;

         pot = GetNodeData(hnode);

         ClearStubFlag(&(pot->stub), STUB_FL_KEEP);
      }

      ClearStubFlag(&(ptf->stub), STUB_FL_DELETION_PENDING);

      TRACE_OUT((TEXT("UnmarkTwinFamilyDeletionPending(): Deletion no longer pending for twin family for %s."),
                 GetString(ptf->hsName)));
   }

   return;
}


/*
** IsTwinFamilyDeletionPending()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsTwinFamilyDeletionPending(PCTWINFAMILY pctf)
{
   ASSERT(IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY));

   return(IsStubFlagSet(&(pctf->stub), STUB_FL_DELETION_PENDING));
}


/*
** ClearTwinFamilySrcFolderTwinCount()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ClearTwinFamilySrcFolderTwinCount(PTWINFAMILY ptf)
{
   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

   EVAL(WalkList(ptf->hlistObjectTwins, &ClearSrcFolderTwinsWalker, NULL));

   return;
}


/*
** EnumObjectTwins()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL EnumObjectTwins(HBRFCASE hbr,
                                 ENUMGENERATEDOBJECTTWINSPROC egotp,
                                 PVOID pvRefData)
{
   BOOL bResult = TRUE;
   HPTRARRAY hpaTwinFamilies;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   /* pvRefData may be any value. */

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_CODE_PTR(egotp, ENUMGENERATEDOBJECTTWINPROC));

   /* Walk the array of twin families. */

   hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(hbr);

   aicPtrs = GetPtrCount(hpaTwinFamilies);
   ai = 0;

   while (ai < aicPtrs)
   {
      PTWINFAMILY ptf;
      BOOL bContinue;
      HNODE hnodePrev;

      ptf = GetPtr(hpaTwinFamilies, ai);

      ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
      ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED));

      /* Lock the twin family so it isn't deleted out from under us. */

      LockStub(&(ptf->stub));

      /*
       * Walk each twin family's list of object twins, calling the callback
       * function with each object twin.
       */

      bContinue = GetFirstNode(ptf->hlistObjectTwins, &hnodePrev);

      while (bContinue)
      {
         HNODE hnodeNext;
         POBJECTTWIN pot;

         bContinue = GetNextNode(hnodePrev, &hnodeNext);

         pot = (POBJECTTWIN)GetNodeData(hnodePrev);

         ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

         bResult = (*egotp)(pot, pvRefData);

         if (! bResult)
            break;

         hnodePrev = hnodeNext;
      }

      /* Was the twin family unlinked? */

      if (IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED))
         /* No. */
         ai++;
      else
      {
         /* Yes. */
         aicPtrs--;
         ASSERT(aicPtrs == GetPtrCount(hpaTwinFamilies));
         TRACE_OUT((TEXT("EnumObjectTwins(): Twin family for object %s unlinked by callback."),
                    GetString(ptf->hsName)));
      }

      UnlockStub(&(ptf->stub));

      if (! bResult)
         break;
   }

   return(bResult);
}


/*
** ApplyNewFolderTwinsToTwinFamilies()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** If FALSE is returned, the array of twin families is in the same state it was
** in before ApplyNewFolderTwinsToTwinFamilies() was called.  No clean-up is
** required by the caller in case of failure.
**
** This function collapses a pair of separate twin families when an object twin
** in one twin family intersects one of the folder twins in the pair of new
** folder twins and an object twin in the other twin family intersects the
** other folder twin in the pair of new folder twins.
**
** This function generates a spinoff object twin when an existing object twin
** intersects one of the folder twins in the pair of new folder twins, and no
** corresponding object twin for the other folder twin in the pair of new
** folder twins exists in the briefcase.  The spinoff object twin is added to
** the generating object twin's twin family.  A spinoff object twins cannot
** cause any existing pairs of twin families to be collapsed because the
** spinoff object twin did not previously exist in a twin family.
**
** A new folder twin may collapse pairs of existing twin families.  E.g.,
** consider the following scenario:
**
** 1) Twin families (c:\, d:\, foo), (e:\, f:\, foo), (c:\, d:\, bar), and
**    (e:\, f:\, bar) exist.
** 2) New folder twin (d:\, e:\, *.*) is added.
** 3) Twin families (c:\, d:\, foo) and (e:\, f:\, foo) must be collpased into
**    a single twin family because of the (d:\, e:\, *.*) folder twin.
** 4) Twin families (c:\, d:\, bar) and (e:\, f:\, bar) must be collpased into
**    a single twin family because of the (d:\, e:\, *.*) folder twin.
**
** So we see that new folder twin (d:\, e:\, *.*) must collapse two pairs of
** existing twin families a single twin family each.  Twin family
** (c:\, d:\, foo) plus twin family (e:\, f:\, foo) becomes twin family
** (c:\, d:\, e:\, f:\, foo).  Twin family (c:\, d:\, bar) plus twin family
** (e:\, f:\, bar) becomes twin family (c:\, d:\, e:\, f:\, bar).
*/
PUBLIC_CODE BOOL ApplyNewFolderTwinsToTwinFamilies(PCFOLDERPAIR pcfp)
{
   BOOL bResult = FALSE;
   HLIST hlistGeneratedObjectTwins;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));

   /*
    * Create lists to contain existing object twins generated by both folder
    * twins.
    */

   if (CreateListOfGeneratedObjectTwins(pcfp, &hlistGeneratedObjectTwins))
   {
      HLIST hlistOtherGeneratedObjectTwins;

      if (CreateListOfGeneratedObjectTwins(pcfp->pfpOther,
                                           &hlistOtherGeneratedObjectTwins))
      {
         NEWLIST nl;
         HLIST hlistNewObjectTwins;

         /* Create list to contain spin-off object twins. */

         nl.dwFlags = 0;

         if (CreateList(&nl, &hlistNewObjectTwins))
         {
            SPINOFFOBJECTTWININFO sooti;

            /*
             * Generate list of new object twins generated by new folder twins
             * to seed ApplyNewObjectTwinToFolderTwins().
             */

            sooti.pcfp = pcfp;
            sooti.hlistNewObjectTwins = hlistNewObjectTwins;

            if (WalkList(hlistGeneratedObjectTwins, &GenerateSpinOffObjectTwin,
                         &sooti))
            {
               sooti.pcfp = pcfp->pfpOther;
               ASSERT(sooti.hlistNewObjectTwins == hlistNewObjectTwins);

               if (WalkList(hlistOtherGeneratedObjectTwins,
                            &GenerateSpinOffObjectTwin, &sooti))
               {
                  /*
                   * ApplyNewObjectTwinsToFolderTwins() sets ulcSrcFolderTwins
                   * for all object twins in hlistNewObjectTwins.
                   */

                  if (ApplyNewObjectTwinsToFolderTwins(hlistNewObjectTwins))
                  {
                     /*
                      * Collapse separate twin families joined by new folder
                      * twin.
                      */

                     EVAL(WalkList(hlistGeneratedObjectTwins, &BuildBradyBunch,
                                   (PVOID)pcfp));

                     /*
                      * We don't need to call BuildBradyBunch() for
                      * pcfp->pfpOther and hlistOtherGeneratedObjectTwins since
                      * one twin family from each collapsed pair of twin
                      * families must come from each list of generated object
                      * twins.
                      */

                     /*
                      * Increment source folder twin count for all pre-existing
                      * object twins generated by the new folder twins.
                      */

                     EVAL(WalkList(hlistGeneratedObjectTwins,
                                   &IncrementSrcFolderTwinsWalker, NULL));
                     EVAL(WalkList(hlistOtherGeneratedObjectTwins,
                                   &IncrementSrcFolderTwinsWalker, NULL));

                     bResult = TRUE;
                  }
               }
            }

            /* Wipe out any new object twins on failure. */

            if (! bResult)
               EVAL(WalkList(hlistNewObjectTwins, &DestroyObjectTwinStubWalker,
                             NULL));

            DestroyList(hlistNewObjectTwins);
         }

         DestroyList(hlistOtherGeneratedObjectTwins);
      }

      DestroyList(hlistGeneratedObjectTwins);
   }

   return(bResult);
}


/*
** TransplantObjectTwin()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT TransplantObjectTwin(POBJECTTWIN pot,
                                            HPATH hpathOldFolder,
                                            HPATH hpathNewFolder)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(IS_VALID_HANDLE(hpathOldFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hpathNewFolder, PATH));

   /* Is this object twin rooted in the renamed folder's subtree? */

   if (IsPathPrefix(pot->hpath, hpathOldFolder))
   {
      TCHAR rgchPathSuffix[MAX_PATH_LEN];
      LPCTSTR pcszSubPath;
      HPATH hpathNew;

      /* Yes.  Change the object twin's root. */

      pcszSubPath = FindChildPathSuffix(hpathOldFolder, pot->hpath,
                                        rgchPathSuffix);

      if (AddChildPath(GetBriefcasePathList(pot->ptfParent->hbr),
                       hpathNewFolder, pcszSubPath, &hpathNew))
      {
         TRACE_OUT((TEXT("TransplantObjectTwin(): Transplanted object twin %s\\%s to %s\\%s."),
                    DebugGetPathString(pot->hpath),
                    GetString(pot->ptfParent->hsName),
                    DebugGetPathString(hpathNew),
                    GetString(pot->ptfParent->hsName)));

         DeletePath(pot->hpath);
         pot->hpath = hpathNew;

         tr = TR_SUCCESS;
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TR_SUCCESS;

   return(tr);
}


/*
** IsFolderObjectTwinName()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsFolderObjectTwinName(LPCTSTR pcszName)
{
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));

   return(! *pcszName);
}


/*
** IsValidHTWIN()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHTWIN(HTWIN htwin)
{
   BOOL bValid = FALSE;

   if (IS_VALID_STRUCT_PTR((PCSTUB)htwin, CSTUB))
   {
      switch (((PSTUB)htwin)->st)
      {
         case ST_OBJECTTWIN:
            bValid = IS_VALID_HANDLE((HOBJECTTWIN)htwin, OBJECTTWIN);
            break;

         case ST_TWINFAMILY:
            bValid = IS_VALID_HANDLE((HTWINFAMILY)htwin, TWINFAMILY);
            break;

         case ST_FOLDERPAIR:
            bValid = IS_VALID_HANDLE((HFOLDERTWIN)htwin, FOLDERTWIN);
            break;

         default:
            ERROR_OUT((TEXT("IsValidHTWIN() called on unrecognized stub type %d."),
                       ((PSTUB)htwin)->st));
            break;
      }
   }
   else
      ERROR_OUT((TEXT("IsValidHTWIN() called on bad twin handle %#lx."),
                 htwin));

   return(bValid);
}


/*
** IsValidHTWINFAMILY()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHTWINFAMILY(HTWINFAMILY htf)
{
   return(IS_VALID_STRUCT_PTR((PTWINFAMILY)htf, CTWINFAMILY));
}


/*
** IsValidHOBJECTTWIN()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHOBJECTTWIN(HOBJECTTWIN hot)
{
   return(IS_VALID_STRUCT_PTR((POBJECTTWIN)hot, COBJECTTWIN));
}


#ifdef VSTF

/*
** IsValidPCTWINFAMILY()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCTWINFAMILY(PCTWINFAMILY pctf)
{
   BOOL bResult;

   /* All the fields of an unlinked twin family should be valid. */

   /* Don't validate hbr. */

   /*
    * In some cases there may be fewer than two object twins in a twin family,
    * e.g., when two twin families are being collapsed, when a twin family is
    * being deleted, and when a twin family is being read in from a database.
    */

   if (IS_VALID_READ_PTR(pctf, CTWINFAMILY) &&
       IS_VALID_STRUCT_PTR(&(pctf->stub), CSTUB) &&
       FLAGS_ARE_VALID(GetStubFlags(&(pctf->stub)), ALL_TWIN_FAMILY_FLAGS) &&
       IS_VALID_HANDLE(pctf->hsName, STRING) &&
       IS_VALID_HANDLE(pctf->hlistObjectTwins, LIST))
      bResult = WalkList(pctf->hlistObjectTwins, &IsValidObjectTwinWalker, (PVOID)pctf);
   else
      bResult = FALSE;

   return(bResult);
}


/*
** IsValidPCOBJECTTWIN()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCOBJECTTWIN(PCOBJECTTWIN pcot)
{
   /*
    * All the fields of an unlinked object twin should be valid, except
    * possibly ptfParent and fsCurrent.
    */

   /*
    *   Winner of the 1995 "I think the compiler generates better code
    *                       if its takes up less space on the screen" award.
    *
    *   Running up in the  "Make the debugger execute 2K of code as an
    *                       atomic operation while debugger" category.
    *
    */

   return(IS_VALID_READ_PTR(pcot, COBJECTTWIN) &&
          IS_VALID_STRUCT_PTR(&(pcot->stub), CSTUB) &&
          FLAGS_ARE_VALID(GetStubFlags(&(pcot->stub)), ALL_OBJECT_TWIN_FLAGS) &&
          IS_VALID_HANDLE(pcot->hpath, PATH) &&
          (IsStubFlagSet(&(pcot->stub), STUB_FL_UNLINKED) ||
           IS_VALID_READ_PTR(pcot->ptfParent, CTWINFAMILY)) &&
          IS_VALID_STRUCT_PTR(&(pcot->fsLastRec), CFILESTAMP) &&
          (IsStubFlagClear(&(pcot->stub), STUB_FL_FILE_STAMP_VALID) ||
           (IS_VALID_STRUCT_PTR(&(pcot->fsCurrent), CFILESTAMP))) &&
          EVAL(! (! IsReconciledFileStamp(&(pcot->fsLastRec)) &&
                  IsStubFlagSet(&(pcot->stub), STUB_FL_NOT_RECONCILED))));
}

#endif


/*
** WriteTwinFamilies()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT WriteTwinFamilies(HCACHEDFILE hcf, HPTRARRAY hpaTwinFamilies)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
   DWORD dwcbTwinFamiliesDBHeaderOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hpaTwinFamilies, PTRARRAY));

   /* Save initial file poisition. */

   dwcbTwinFamiliesDBHeaderOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbTwinFamiliesDBHeaderOffset != INVALID_SEEK_POSITION)
   {
      TWINFAMILIESDBHEADER tfdbh;

      /* Leave space for the twin families' header. */

      ZeroMemory(&tfdbh, sizeof(tfdbh));

      if (WriteToCachedFile(hcf, (PCVOID)&tfdbh, sizeof(tfdbh), NULL))
      {
         ARRAYINDEX aicPtrs;
         ARRAYINDEX ai;

         tr = TR_SUCCESS;

         aicPtrs = GetPtrCount(hpaTwinFamilies);

         for (ai = 0;
              ai < aicPtrs && tr == TR_SUCCESS;
              ai++)
            tr = WriteTwinFamily(hcf, GetPtr(hpaTwinFamilies, ai));

         if (tr == TR_SUCCESS)
         {
            /* Save twin families' header. */

            tfdbh.lcTwinFamilies = aicPtrs;

            tr = WriteDBSegmentHeader(hcf, dwcbTwinFamiliesDBHeaderOffset,
                                      &tfdbh, sizeof(tfdbh));

            if (tr == TR_SUCCESS)
               TRACE_OUT((TEXT("WriteTwinFamilies(): Wrote %ld twin families."),
                          tfdbh.lcTwinFamilies));
         }
      }
   }

   return(tr);
}


/*
** ReadTwinFamilies()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT ReadTwinFamilies(HCACHEDFILE hcf, HBRFCASE hbr,
                                   PCDBVERSION pcdbver,
                                   HHANDLETRANS hhtFolderTrans,
                                   HHANDLETRANS hhtNameTrans)
{
   TWINRESULT tr;
   TWINFAMILIESDBHEADER tfdbh;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_READ_PTR(pcdbver, DBVERSION));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtNameTrans, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &tfdbh, sizeof(tfdbh), &dwcbRead) &&
       dwcbRead == sizeof(tfdbh))
   {
      LONG l;

      tr = TR_SUCCESS;

      TRACE_OUT((TEXT("ReadTwinFamilies(): Reading %ld twin families."),
                 tfdbh.lcTwinFamilies));

      for (l = 0;
           l < tfdbh.lcTwinFamilies && tr == TR_SUCCESS;
           l++)
         tr = ReadTwinFamily(hcf, hbr, pcdbver, hhtFolderTrans, hhtNameTrans);

      ASSERT(AreTwinFamiliesValid(GetBriefcaseTwinFamilyPtrArray(hbr)));
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


/***************************** Exported Functions ****************************/


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | AddObjectTwin | Twins two objects.

@parm HBRFCASE | hbr | A handle to the open briefcase that the new object twins
are to be added to.

@parm PCNEWOBJECTTWIN | pcnot | A pointer to a CNEWOBJECTTWIN describing the
objects to be twinned.

@parm PHTWINFAMILY | phtf | A pointer to an HTWINFAMILY to be filled in with
a handle to the twin family to which the object twins were added.  This handle
may refer to a new or existing twin family.  *phtf is only valid if TR_SUCCESS
is returned.

@rdesc If the objects were twinned successfully, TR_SUCCESS is returned, and
*phTwinFamily contains a handle to the associated twin family.  Otherwise, the
objects were not twinned successfully, the return value indicates the error
that occurred, and *phtf is undefined.  If one or both of the volumes
specified by the NEWOBJECTTWIN structure is not present, TR_UNAVAILABLE_VOLUME
will be returned, and the object twin will not be added.

@comm Once the caller is finshed with the twin handle returned by
AddObjectTwin(), ReleaseTwinHandle() should be called to release the twin
handle.  DeleteTwin() does not release a twin handle returned by
AddObjectTwin().

@xref ReleaseTwinHandle DeleteTwin

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI AddObjectTwin(HBRFCASE hbr, PCNEWOBJECTTWIN pcnot,
                                           PHTWINFAMILY phtf)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(AddObjectTwin);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE) &&
          IS_VALID_STRUCT_PTR(pcnot, CNEWOBJECTTWIN) &&
          EVAL(pcnot->ulSize == sizeof(*pcnot)) &&
          IS_VALID_WRITE_PTR(phtf, HTWINFAMILY))
#endif
      {
         HCLSIFACECACHE hcic;

         if (CreateClassInterfaceCache(&hcic))
         {
            HPATHLIST hplBriefcase;
            HPATH hpathFolder1;

            InvalidatePathListInfo(GetBriefcasePathList(hbr));

            hplBriefcase = GetBriefcasePathList(hbr);

            tr = TranslatePATHRESULTToTWINRESULT(AddPath(hplBriefcase,
                                                         pcnot->pcszFolder1,
                                                         &hpathFolder1));

            if (tr == TR_SUCCESS)
            {
               HPATH hpathFolder2;

               tr = TranslatePATHRESULTToTWINRESULT(AddPath(hplBriefcase,
                                                            pcnot->pcszFolder2,
                                                            &hpathFolder2));

               if (tr == TR_SUCCESS)
               {
                  POBJECTTWIN pot1;
                  POBJECTTWIN pot2;

                  tr = TwinObjects(hbr, hcic, hpathFolder1, hpathFolder2,
                                   pcnot->pcszName, &pot1, &pot2);

                  /*
                   * These twins are not really duplicates unless they were already
                   * connected as object twins.
                   */

                  if (tr == TR_DUPLICATE_TWIN &&
                      (IsStubFlagClear(&(pot1->stub), STUB_FL_FROM_OBJECT_TWIN) ||
                       IsStubFlagClear(&(pot2->stub), STUB_FL_FROM_OBJECT_TWIN)))
                     tr = TR_SUCCESS;

                  if (tr == TR_SUCCESS)
                  {
                     /* Success! */

                     ASSERT(pot1->ptfParent == pot2->ptfParent);
                     ASSERT(IS_VALID_HANDLE((HTWINFAMILY)(pot1->ptfParent), TWINFAMILY));

                     LockStub(&(pot1->ptfParent->stub));

                     SetStubFlag(&(pot1->stub), STUB_FL_FROM_OBJECT_TWIN);
                     SetStubFlag(&(pot2->stub), STUB_FL_FROM_OBJECT_TWIN);

                     *phtf = (HTWINFAMILY)(pot1->ptfParent);
                  }

                  DeletePath(hpathFolder2);
               }

               DeletePath(hpathFolder1);
            }

            DestroyClassInterfaceCache(hcic);
         }
         else
            tr = TR_OUT_OF_MEMORY;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(AddObjectTwin, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | ReleaseTwinHandle | Releases a twin handle returned by
AddObjectTwin(), AddFolderTwin(), or GetObjectTwinHandle().

@parm HTWIN | hTwin | The twin handle that is to be released.

@rdesc If the twin handle was released successfully, TR_SUCCESS is returned.
Otherwise, the twin handle was not released successfully, and the return value
indicates the error that occurred.  hTwin is no longer a valid twin handle
after ReleaseTwinHandle() is called.

@comm If the lock count of the twin drops to 0 and deletion is pending against
the twin, the twin is deleted.  If ReleaseTwinHandle() is called with a valid
handle to a twin that has been deleted, TR_SUCCESS will be returned.
DeleteTwin() does not release a twin handle returned by AddObjectTwin(),
AddFolderTwin(), or GetObjectTwinHandle().  ReleaseTwinHandle() should be
called to release a twin handle returned by AddObjectTwin(), AddFolderTwin(),
or GetObjectTwinHandle().  DeleteTwin() should be called before
ReleaseTwinHandle() if the twin is to be deleted.

@xref AddObjectTwin AddFolderTwin DeleteTwin

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI ReleaseTwinHandle(HTWIN hTwin)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(ReleaseTwinHandle);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hTwin, TWIN))
#endif
      {
         UnlockStub((PSTUB)hTwin);

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(ReleaseTwinHandle, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | DeleteTwin | Deletes a twin from the synchronization
database.  A twin is added to the synchronization database by AddObjectTwin()
or AddFolderTwin().

@parm HTWIN | htwin | A handle to the twin being deleted.

@rdesc If the twin was deleted successfully, TR_SUCCESS is returned.
Otherwise, the twin was not deleted successfully, and the return value
indicates the error that occurred.

@comm If DeleteTwin() is called with a valid handle to a twin that has been
deleted, TR_SUCCESS will be returned.  DeleteTwin() does not release a twin
handle returned by AddObjectTwin(), AddFolderTwin(), or GetObjectTwinHandle().
ReleaseTwinHandle() should be called to release a twin handle returned by
AddObjectTwin(), AddFolderTwin(), or GetObjectTwinHandle().  DeleteTwin()
should be called before ReleaseTwinHandle() if the twin is to be deleted.
DeleteTwin() will always succeed on a valid HFOLDERTWIN.  DeleteTwin() will
fail on a valid HOBJECTTWIN for any object twin that has source folder twins,
returning TR_HAS_FOLDER_TWIN_SRC.  DeleteTwin() will also fail on a valid
HTWINFAMILY for any twin family that contains two or more object twins with
source folder twins, returning TR_HAS_FOLDER_TWIN_SRC.  A twin family cannot
contain only one object twin with source folder twins.  Twin families can only
contain 0, 2, or more object twins with source folder twins.

@xref AddObjectTwin AddFolderTwin ReleaseTwinHandle IsOrphanObjectTwin
CountSourceFolderTwins

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI DeleteTwin(HTWIN hTwin)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(DeleteTwin);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hTwin, TWIN))
#endif
      {
         tr = DestroyStub((PSTUB)hTwin);
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(DeleteTwin, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | GetObjectTwinHandle | Determines whether or not an object is
a twin.  If the object is a twin, a twin handle for the twinned object is
returned.

@parm HBRFCASE | hbr | A handle to the open briefcase to be checked for the
object twin.

@parm PCSTR | pcszFolder | A pointer to a string indicating the object's
folder.

@parm PCSTR | pcszName | A pointer to a string indicating the object's name.

@parm PHOBJECTTWIN | phot | A pointer to an HOBJECTTWIN to be filled in with
a handle to the object twin or NULL.  If the object is a twin, *phObjectTwin
is filled in with a handle to the object twin.  If the object is not a twin,
*phObjectTwin is filled in with NULL.  *phObjectTwin is only valid if
TR_SUCCESS is returned.

@rdesc If the lookup was successful, TR_SUCCESS is returned.  Otherwise, the
lookup was not successful, and the return value indicates the error that
occurred.

@comm Once the caller is finshed with the twin handle returned by
GetObjectTwinHandle(), ReleaseTwinHandle() should be called to release the twin
handle.  N.b., DeleteTwin() does not release a twin handle returned by
GetObjectTwinHandle().

@xref AddObjectTwin ReleaseTwinHandle DeleteTwin

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI GetObjectTwinHandle(HBRFCASE hbr,
                                                 LPCTSTR pcszFolder,
                                                 LPCTSTR pcszName,
                                                 PHOBJECTTWIN phot)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(GetObjectTwinHandle);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE) &&
          IS_VALID_STRING_PTR(pcszFolder, CSTR) &&
          IS_VALID_STRING_PTR(pcszName, CSTR) &&
          IS_VALID_WRITE_PTR(phot, HOBJECTTWIN))
#endif
      {
         HPATH hpath;

         InvalidatePathListInfo(GetBriefcasePathList(hbr));

         tr = TranslatePATHRESULTToTWINRESULT(
               AddPath(GetBriefcasePathList(hbr), pcszFolder, &hpath));

         if (tr == TR_SUCCESS)
         {
            BOOL bFound;
            HNODE hnode;
            POBJECTTWIN pot;

            /* Is this object already an object twin? */

            bFound = FindObjectTwin(hbr, hpath, pcszName, &hnode);

            if (bFound)
               /* Yes. */
               pot = (POBJECTTWIN)GetNodeData(hnode);
            else
               /*
                * No.  Expand folder twins, and check for a generating folder
                * twin.
                */
               tr = TryToGenerateObjectTwin(hbr, hpath, pcszName, &bFound,
                                            &pot);

            if (tr == TR_SUCCESS)
            {
               if (bFound)
               {
                  LockStub(&(pot->stub));

                  TRACE_OUT((TEXT("GetObjectTwinHandle(): %s\\%s is an object twin."),
                             DebugGetPathString(hpath),
                             pcszName));

                  *phot = (HOBJECTTWIN)pot;

                  ASSERT(IS_VALID_HANDLE(*phot, OBJECTTWIN));
               }
               else
               {
                  TRACE_OUT((TEXT("GetObjectTwinHandle(): %s\\%s is not an object twin."),
                             DebugGetPathString(hpath),
                             pcszName));

                  *phot = NULL;
               }
            }

            DeletePath(hpath);
         }
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(GetObjectTwinHandle, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | IsOrphanObjectTwin | Determines whether or not an object twin
was added to the synchronization database through a call to AddObjectTwin().

@parm HOBJECTTWIN | hot | A handle to the object twin whose orphan status is to
be determined.

@parm PBOOL | pbIsOrphanObjectTwin | A pointer to a BOOL to be filled in with
TRUE if the object twin was added through AddObjectTwin().
*pbIsOrphanObjectTwin is only valid if TR_SUCCESS is returned.

@rdesc If the lookup was successful, TR_SUCCESS is returned.  Otherwise, the
lookup was not successful, and the return value indicates the error that
occurred.

@comm If IsOrphanObjectTwin() is called with a valid handle to an object twin
that has been deleted, TR_DELETED_TWIN will be returned.

@xref AddObjectTwin

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI IsOrphanObjectTwin(HOBJECTTWIN hot,
                                                PBOOL pbIsOrphanObjectTwin)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(IsOrphanObjectTwin);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hot, OBJECTTWIN) &&
          IS_VALID_WRITE_PTR(pbIsOrphanObjectTwin, BOOL))
#endif
      {
         /* Has this object twin been deleted? */

         if (IsStubFlagClear(&(((POBJECTTWIN)(hot))->stub), STUB_FL_UNLINKED))
         {
            /* No. */

            if (IsStubFlagSet(&(((POBJECTTWIN)hot)->stub), STUB_FL_FROM_OBJECT_TWIN))
            {
               *pbIsOrphanObjectTwin = TRUE;

               TRACE_OUT((TEXT("IsOrphanObjectTwin(): Object twin %s\\%s is an orphan object twin."),
                          DebugGetPathString(((POBJECTTWIN)hot)->hpath),
                          GetString(((POBJECTTWIN)hot)->ptfParent->hsName)));
            }
            else
            {
               *pbIsOrphanObjectTwin = FALSE;

               TRACE_OUT((TEXT("IsOrphanObjectTwin(): Object twin %s\\%s is not an orphan object twin."),
                          DebugGetPathString(((POBJECTTWIN)hot)->hpath),
                          GetString(((POBJECTTWIN)hot)->ptfParent->hsName)));
            }

            ASSERT(*pbIsOrphanObjectTwin ||
                   ((POBJECTTWIN)hot)->ulcSrcFolderTwins);

            tr = TR_SUCCESS;
         }
         else
            /* Yes. */
            tr = TR_DELETED_TWIN;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(IsOrphanObjectTwin, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | CountSourceFolderTwins | Determines the number of folder
twins that generate an object twin.

@parm HOBJECTTWIN | hot | A handle to the object twin whose folder twin sources
are to be counted.

@parm PULONG | pulcSrcFolderTwins | A pointer to a ULONG to be filled in with
the number of folder twins that generate the object twin.  *pulcSrcFolderTwins
is only valid if TR_SUCCESS is returned.

@rdesc If the lookup was successful, TR_SUCCESS is returned.  Otherwise, the
lookup was not successful, and the return value indicates the error that
occurred.

@comm If CountSourceFolderTwins() is called with a valid handle to a folder
twin that has been deleted, TR_DELETED_TWIN will be returned.

@xref AddFolderTwin

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI CountSourceFolderTwins(HOBJECTTWIN hot,
                                                    PULONG pulcSrcFolderTwins)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(CountSourceFolderTwins);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hot, OBJECTTWIN) &&
          IS_VALID_WRITE_PTR(pulcSrcFolderTwins, ULONG))
#endif
      {
         /* Has this object twin been deleted? */

         if (IsStubFlagClear(&(((POBJECTTWIN)(hot))->stub), STUB_FL_UNLINKED))
         {
            /* No. */

            *pulcSrcFolderTwins = ((POBJECTTWIN)hot)->ulcSrcFolderTwins;

            ASSERT(*pulcSrcFolderTwins > 0 ||
                   IsStubFlagSet(&(((POBJECTTWIN)hot)->stub), STUB_FL_FROM_OBJECT_TWIN));

            TRACE_OUT((TEXT("CountSourceFolderTwins(): Object twin %s\\%s has %lu source folder twins."),
                       DebugGetPathString(((POBJECTTWIN)hot)->hpath),
                       GetString(((POBJECTTWIN)hot)->ptfParent->hsName),
                       *pulcSrcFolderTwins));

            tr = TR_SUCCESS;
         }
         else
            /* Yes. */
            tr = TR_DELETED_TWIN;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(CountSourceFolderTwins, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api BOOL | AnyTwins | Determines whether or not any twins currently exist in a
briefcase.

@parm HBRFCASE | hbr | A handle to the open briefcase to be checked for twins.

@parm PBOOL | pbAnyTwins | A pointer to a BOOL to be filled in with TRUE if
the given briefcase contains any twins or FALSE if not.  *pbAnyTwins is only
valid if TR_SUCCESS is returned.

@rdesc If the lookup was successful, TR_SUCCESS is returned.  Otherwise, the
lookup was not successful, and the return value indicates the error that
occurred.

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI AnyTwins(HBRFCASE hbr, PBOOL pbAnyTwins)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(AnyTwins);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE) &&
          IS_VALID_WRITE_PTR(pbAnyTwins, BOOL))
#endif
      {
         if (GetPtrCount(GetBriefcaseTwinFamilyPtrArray(hbr)) ||
             GetPtrCount(GetBriefcaseFolderPairPtrArray(hbr)))
         {
            *pbAnyTwins = TRUE;

            TRACE_OUT((TEXT("AnyTwins(): There are twins in briefcase %#lx."),
                       hbr));
         }
         else
         {
            *pbAnyTwins = FALSE;

            TRACE_OUT((TEXT("AnyTwins(): There are not any twins in briefcase %#lx."),
                       hbr));
         }

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(AnyTwins, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\util.c ===
/*
 * util.c - Miscellaneous utility functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#ifdef WINNT
#include <uastrfnc.h>  // for ualstrcpyn (used on unaligned UNICODE strings)
#endif

/****************************** Public Functions *****************************/


/*
** NotifyShell()
**
** Notifies the Shell of an event.
**
** Arguments:     pcszPath - path string related to event
**                nse - event
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void NotifyShell(LPCTSTR pcszPath, NOTIFYSHELLEVENT nse)
{

#pragma data_seg(DATA_SEG_READ_ONLY)

   /*
    * N.b., these events must match the enumerated NOTIFYSHELLEVENT values in
    * util.h.
    */
   static const LONG SrgclShellEvents[] =
   {
      SHCNE_CREATE,
      SHCNE_DELETE,
      SHCNE_MKDIR,
      SHCNE_RMDIR,
      SHCNE_UPDATEITEM,
      SHCNE_UPDATEDIR
   };

#ifdef DEBUG

   static const LPCTSTR SrgpcszShellEvents[] =
   {
      TEXT("create item"),
      TEXT("delete item"),
      TEXT("create folder"),
      TEXT("delete folder"),
      TEXT("update item"),
      TEXT("update folder")
   };

#endif

#pragma data_seg()

   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(nse < ARRAY_ELEMENTS(SrgclShellEvents));
   ASSERT(nse < ARRAY_ELEMENTS(SrgpcszShellEvents));

   TRACE_OUT((TEXT("NotifyShell(): Sending %s notification for %s."),
              SrgpcszShellEvents[nse],
              pcszPath));

   SHChangeNotify(SrgclShellEvents[nse], SHCNF_PATH, pcszPath, NULL);
}


/*
** ComparePathStringsByHandle()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT ComparePathStringsByHandle(HSTRING hsFirst,
                                                        HSTRING hsSecond)
{
   ASSERT(IS_VALID_HANDLE(hsFirst, STRING));
   ASSERT(IS_VALID_HANDLE(hsSecond, STRING));

   return(CompareStringsI(hsFirst, hsSecond));
}


/*
** MyLStrCmpNI()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT MyLStrCmpNI(LPCTSTR pcsz1, LPCTSTR pcsz2, int ncbLen)
{
   int n = 0;

   ASSERT(IS_VALID_STRING_PTR(pcsz1, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcsz2, CSTR));
   ASSERT(ncbLen >= 0);

   while (ncbLen > 0 &&
          ! (n = (DWORD) CharLower((LPTSTR)(ULONG)*pcsz1)
               - (DWORD) CharLower((LPTSTR)(ULONG)*pcsz2)) &&
          *pcsz1)
   {
      pcsz1++;
      pcsz2++;
      ncbLen--;
   }

   return(MapIntToComparisonResult(n));
}


/*

/*
** ComposePath()
**
** Composes a path string given a folder and a filename.
**
** Arguments:     pszBuffer - path string that is created
**                pcszFolder - path string of the folder
**                pcszName - path to append
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., truncates path to MAX_PATH_LEN bytes in length.
*/
PUBLIC_CODE void ComposePath(LPTSTR pszBuffer, LPCTSTR pcszFolder, LPCTSTR pcszName)
{
   ASSERT(IS_VALID_STRING_PTR(pszBuffer, STR));
   ASSERT(IS_VALID_STRING_PTR(pcszFolder, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszBuffer, STR, MAX_PATH_LEN));

#ifdef WINNT
   ualstrcpyn(pszBuffer, pcszFolder, MAX_PATH_LEN);
#else      
   MyLStrCpyN(pszBuffer, pcszFolder, MAX_PATH_LEN);
#endif

   CatPath(pszBuffer, pcszName);

   ASSERT(IS_VALID_STRING_PTR(pszBuffer, STR));

   return;
}


/*
** ExtractFileName()
**
** Extracts the file name from a path name.
**
** Arguments:     pcszPathName - path string from which to extract file name
**
** Returns:       Pointer to file name in path string.
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR ExtractFileName(LPCTSTR pcszPathName)
{
   LPCTSTR pcszLastComponent;
   LPCTSTR pcsz;

   ASSERT(IS_VALID_STRING_PTR(pcszPathName, CSTR));

   for (pcszLastComponent = pcsz = pcszPathName;
        *pcsz;
        pcsz = CharNext(pcsz))
   {
      if (IS_SLASH(*pcsz) || *pcsz == COLON)
         pcszLastComponent = CharNext(pcsz);
   }

   ASSERT(IS_VALID_STRING_PTR(pcszLastComponent, CSTR));

   return(pcszLastComponent);
}


/*
** ExtractExtension()
**
** Extracts the extension from a file.
**
** Arguments:     pcszName - name whose extension is to be extracted
**
** Returns:       If the name contains an extension, a pointer to the period at
**                the beginning of the extension is returned.  If the name has
**                no extension, a pointer to the name's null terminator is
**                returned.
**
** Side Effects:  none
*/
PUBLIC_CODE LPCTSTR ExtractExtension(LPCTSTR pcszName)
{
   LPCTSTR pcszLastPeriod;

   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));

   /* Make sure we have an isolated file name. */

   pcszName = ExtractFileName(pcszName);

   pcszLastPeriod = NULL;

   while (*pcszName)
   {
      if (*pcszName == PERIOD)
         pcszLastPeriod = pcszName;

      pcszName = CharNext(pcszName);
   }

   if (! pcszLastPeriod)
   {
      /* Point at null terminator. */

      pcszLastPeriod = pcszName;
      ASSERT(! *pcszLastPeriod);
   }
   else
      /* Point at period at beginning of extension. */
      ASSERT(*pcszLastPeriod == PERIOD);

   ASSERT(IS_VALID_STRING_PTR(pcszLastPeriod, CSTR));

   return(pcszLastPeriod);
}


/*
** GetHashBucketIndex()
**
** Calculates the hash bucket index for a string.
**
** Arguments:     pcsz - pointer to string whose hash bucket index is to be
**                        calculated
**                hbc - number of hash buckets in string table
**
** Returns:       Hash bucket index for string.
**
** Side Effects:  none
**
** The hashing function used is the sum of the byte values in the string modulo
** the number of buckets in the hash table.
*/
PUBLIC_CODE HASHBUCKETCOUNT GetHashBucketIndex(LPCTSTR pcsz,
                                               HASHBUCKETCOUNT hbc)
{
   ULONG ulSum;

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(hbc > 0);

   /* Don't worry about overflow here. */

   for (ulSum = 0; *pcsz; pcsz++)
      ulSum += *pcsz;

   return((HASHBUCKETCOUNT)(ulSum % hbc));
}


/*
** RegKeyExists()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL RegKeyExists(HKEY hkeyParent, LPCTSTR pcszSubKey)
{
   BOOL bResult;
   HKEY hkeySubKey;

   ASSERT(IS_VALID_HANDLE(hkeyParent, KEY));
   ASSERT(IS_VALID_STRING_PTR(pcszSubKey, CSTR));

   bResult = (RegOpenKeyEx(hkeyParent, pcszSubKey, 0, KEY_QUERY_VALUE,
                           &hkeySubKey)
              == ERROR_SUCCESS);

   if (bResult)
      EVAL(RegCloseKey(hkeySubKey) == ERROR_SUCCESS);

   return(bResult);
}


/*
** CopyLinkInfo()
**
** Copies LinkInfo into local memory.
**
** Arguments:     pcliSrc - source LinkInfo
**                ppliDest - pointer to PLINKINFO to be filled in with pointer
**                           to local copy
**
** Returns:       TRUE if successful.  FALSE if not.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CopyLinkInfo(PCLINKINFO pcliSrc, PLINKINFO *ppliDest)
{
   BOOL bResult;
   DWORD dwcbSize;

   ASSERT(IS_VALID_STRUCT_PTR(pcliSrc, CLINKINFO));
   ASSERT(IS_VALID_WRITE_PTR(ppliDest, PLINKINFO));

   dwcbSize = *(PDWORD)pcliSrc;

   bResult = AllocateMemory(dwcbSize, ppliDest);

   if (bResult)
      CopyMemory(*ppliDest, pcliSrc, dwcbSize);

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*ppliDest, CLINKINFO));

   return(bResult);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidPCLINKINFO()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCLINKINFO(PCLINKINFO pcli)
{
   BOOL bResult;

   if (IS_VALID_READ_BUFFER_PTR(pcli, CDWORD, sizeof(DWORD)) &&
       IS_VALID_READ_BUFFER_PTR(pcli, CLINKINFO, (UINT)*(PDWORD)pcli))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\valid.h ===
/*
 * valid.h - Validation functions description.
 */


/* Prototypes
 *************/

/* valid.c */

extern BOOL IsValidHANDLE(HANDLE);
extern BOOL IsValidHFILE(HANDLE);
extern BOOL IsValidHWND(HWND);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidPCSECURITY_ATTRIBUTES(PCSECURITY_ATTRIBUTES);
extern BOOL IsValidFileCreationMode(DWORD);
extern BOOL IsValidHTEMPLATEFILE(HANDLE);
extern BOOL IsValidPCFILETIME(PCFILETIME);

#endif

#ifdef DEBUG

extern BOOL IsValidHINSTANCE(HINSTANCE);
extern BOOL IsValidHICON(HICON);
extern BOOL IsValidHKEY(HKEY);
extern BOOL IsValidHMODULE(HMODULE);
extern BOOL IsValidShowWindowCmd(int);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\valid.c ===
/*
 * valid.c - Validation functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/****************************** Public Functions *****************************/


/*
** IsValidHANDLE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHANDLE(HANDLE hnd)
{
   return(EVAL(hnd != INVALID_HANDLE_VALUE));
}


/*
** IsValidHFILE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHFILE(HANDLE hf)
{
   return(IsValidHANDLE(hf));
}


/*
** IsValidHWND()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHWND(HWND hwnd)
{
   /* Ask User if this is a valid window. */

   return(IsWindow(hwnd));
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidPCSECURITY_ATTRIBUTES()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCSECURITY_ATTRIBUTES(PCSECURITY_ATTRIBUTES pcsa)
{
   return(IS_VALID_READ_PTR(pcsa, CSECURITY_ATTRIBUTES));
}


/*
** IsValidFileCreationMode()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidFileCreationMode(DWORD dwMode)
{
   BOOL bResult;

   switch (dwMode)
   {
      case CREATE_NEW:
      case CREATE_ALWAYS:
      case OPEN_EXISTING:
      case OPEN_ALWAYS:
      case TRUNCATE_EXISTING:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidFileCreationMode(): Invalid file creation mode %#lx."),
                    dwMode));
         break;
   }

   return(bResult);
}


/*
** IsValidHTEMPLATEFILE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHTEMPLATEFILE(HANDLE htf)
{
   return(IsValidHANDLE(htf));
}


/*
** IsValidPCFILETIME()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCFILETIME(PCFILETIME pcft)
{
   return(IS_VALID_READ_PTR(pcft, CFILETIME));
}

#endif


#ifdef DEBUG

/*
** IsValidHINSTANCE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHINSTANCE(HINSTANCE hinst)
{
   return(EVAL(hinst));
}


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** IsValidHICON()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHICON(HICON hicon)

{
   /* Any value is a valid HICON. */

   return(TRUE);
}


/*
** IsValidHKEY()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHKEY(HKEY hkey)
{
   /* Any value is a valid HKEY. */

   return(TRUE);
}


/*
** IsValidHMODULE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHMODULE(HMODULE hmod)

{
   /* Any non-NULL value is a valid HMODULE. */

   return(hmod != NULL);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** IsValidShowWindowCmd()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidShowWindowCmd(int nShow)
{
   BOOL bResult;

   switch (nShow)
   {
      case SW_HIDE:
      case SW_SHOWNORMAL:
      case SW_SHOWMINIMIZED:
      case SW_SHOWMAXIMIZED:
      case SW_SHOWNOACTIVATE:
      case SW_SHOW:
      case SW_MINIMIZE:
      case SW_SHOWMINNOACTIVE:
      case SW_SHOWNA:
      case SW_RESTORE:
      case SW_SHOWDEFAULT:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidShowWindowCmd(): Invalid file creation mode %d."),
                    nShow));
         break;
   }

   return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\volume.c ===
/*
 * volume.c - Volume ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "volume.h"


/* Constants
 ************/

/* VOLUMELIST PTRARRAY allocation parameters */

#define NUM_START_VOLUMES        (16)
#define NUM_VOLUMES_TO_ADD       (16)

/* VOLUMELIST string table allocation parameters */

#define NUM_VOLUME_HASH_BUCKETS  (31)


/* Types
 ********/

/* volume list */

typedef struct _volumelist
{
   /* array of pointers to VOLUMEs */

   HPTRARRAY hpa;

   /* table of volume root path strings */

   HSTRINGTABLE hst;

   /* flags from RESOLVELINKINFOINFLAGS */

   DWORD dwFlags;

   /*
    * handle to parent window, only valid if RLI_IFL_ALLOW_UI is set in dwFlags
    * field
    */

   HWND hwndOwner;
}
VOLUMELIST;
DECLARE_STANDARD_TYPES(VOLUMELIST);

/* VOLUME flags */

typedef enum _volumeflags
{
   /* The volume root path string indicated by hsRootPath is valid. */

   VOLUME_FL_ROOT_PATH_VALID  = 0x0001,

   /*
    * The net resource should be disconnected by calling DisconnectLinkInfo()
    * when finished.
    */

   VOLUME_FL_DISCONNECT       = 0x0002,

   /* Any cached volume information should be verified before use. */

   VOLUME_FL_VERIFY_VOLUME    = 0x0004,

   /* flag combinations */

   ALL_VOLUME_FLAGS           = (VOLUME_FL_ROOT_PATH_VALID |
                                 VOLUME_FL_DISCONNECT |
                                 VOLUME_FL_VERIFY_VOLUME)
}
VOLUMEFLAGS;

/* VOLUME states */

typedef enum _volumestate
{
   VS_UNKNOWN,

   VS_AVAILABLE,

   VS_UNAVAILABLE
}
VOLUMESTATE;
DECLARE_STANDARD_TYPES(VOLUMESTATE);

/* volume structure */

typedef struct _volume
{
   /* reference count */

   ULONG ulcLock;

   /* bit mask of flags from VOLUMEFLAGS */

   DWORD dwFlags;

   /* volume state */

   VOLUMESTATE vs;

   /* pointer to LinkInfo structure indentifying volume */

   PLINKINFO pli;

   /*
    * handle to volume root path string, only valid if
    * VOLUME_FL_ROOT_PATH_VALID is set in dwFlags field
    */

   HSTRING hsRootPath;

   /* pointer to parent volume list */

   PVOLUMELIST pvlParent;
}
VOLUME;
DECLARE_STANDARD_TYPES(VOLUME);

/* database volume list header */

typedef struct _dbvolumelistheader
{
   /* number of volumes in list */

   LONG lcVolumes;

   /* length of longest LinkInfo structure in volume list in bytes */

   UINT ucbMaxLinkInfoLen;
}
DBVOLUMELISTHEADER;
DECLARE_STANDARD_TYPES(DBVOLUMELISTHEADER);

/* database volume structure */

typedef struct _dbvolume
{
   /* old handle to volume */

   HVOLUME hvol;

   /* old LinkInfo structure follows */

   /* first DWORD of LinkInfo structure is total size in bytes */
}
DBVOLUME;
DECLARE_STANDARD_TYPES(DBVOLUME);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE COMPARISONRESULT VolumeSortCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT VolumeSearchCmp(PCVOID, PCVOID);
PRIVATE_CODE BOOL SearchForVolumeByRootPathCmp(PCVOID, PCVOID);
PRIVATE_CODE BOOL UnifyVolume(PVOLUMELIST, PLINKINFO, PVOLUME *);
PRIVATE_CODE BOOL CreateVolume(PVOLUMELIST, PLINKINFO, PVOLUME *);
PRIVATE_CODE void UnlinkVolume(PCVOLUME);
PRIVATE_CODE BOOL DisconnectVolume(PVOLUME);
PRIVATE_CODE void DestroyVolume(PVOLUME);
PRIVATE_CODE void LockVolume(PVOLUME);
PRIVATE_CODE BOOL UnlockVolume(PVOLUME);
PRIVATE_CODE void InvalidateVolumeInfo(PVOLUME);
PRIVATE_CODE void ClearVolumeInfo(PVOLUME);
PRIVATE_CODE void GetUnavailableVolumeRootPath(PCLINKINFO, LPTSTR);
PRIVATE_CODE BOOL VerifyAvailableVolume(PVOLUME);
PRIVATE_CODE void ExpensiveResolveVolumeRootPath(PVOLUME, LPTSTR);
PRIVATE_CODE void ResolveVolumeRootPath(PVOLUME, LPTSTR);
PRIVATE_CODE VOLUMERESULT VOLUMERESULTFromLastError(VOLUMERESULT);
PRIVATE_CODE TWINRESULT WriteVolume(HCACHEDFILE, PVOLUME);
PRIVATE_CODE TWINRESULT ReadVolume(HCACHEDFILE, PVOLUMELIST, PLINKINFO, UINT, HHANDLETRANS);

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsValidPCVOLUMELIST(PCVOLUMELIST);
PRIVATE_CODE BOOL IsValidVOLUMESTATE(VOLUMESTATE);
PRIVATE_CODE BOOL IsValidPCVOLUME(PCVOLUME);

#endif

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCVOLUMEDESC(PCVOLUMEDESC);

#endif


/*
** VolumeSortCmp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Volumes are sorted by:
**    1) LinkInfo volume
**    2) pointer
*/
PRIVATE_CODE COMPARISONRESULT VolumeSortCmp(PCVOID pcvol1, PCVOID pcvol2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pcvol1, CVOLUME));
   ASSERT(IS_VALID_STRUCT_PTR(pcvol2, CVOLUME));

   cr = CompareLinkInfoVolumes(((PCVOLUME)pcvol1)->pli,
                               ((PCVOLUME)pcvol2)->pli);

   if (cr == CR_EQUAL)
      cr = ComparePointers(pcvol1, pcvol1);

   return(cr);
}


/*
** VolumeSearchCmp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Volumes are searched by:
**    1) LinkInfo volume
*/
PRIVATE_CODE COMPARISONRESULT VolumeSearchCmp(PCVOID pcli, PCVOID pcvol)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pcvol, CVOLUME));

   return(CompareLinkInfoVolumes(pcli, ((PCVOLUME)pcvol)->pli));
}


/*
** SearchForVolumeByRootPathCmp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Volumes are searched by:
**    1) available volume root path
*/
PRIVATE_CODE BOOL SearchForVolumeByRootPathCmp(PCVOID pcszFullPath,
                                               PCVOID pcvol)
{
   BOOL bDifferent;

   ASSERT(IsFullPath(pcszFullPath));
   ASSERT(IS_VALID_STRUCT_PTR(pcvol, CVOLUME));

   if (((PCVOLUME)pcvol)->vs == VS_AVAILABLE &&
       IS_FLAG_SET(((PCVOLUME)pcvol)->dwFlags, VOLUME_FL_ROOT_PATH_VALID))
   {
      LPCTSTR pcszVolumeRootPath;

      pcszVolumeRootPath = GetString(((PCVOLUME)pcvol)->hsRootPath);

      bDifferent = MyLStrCmpNI(pcszFullPath, pcszVolumeRootPath,
                               lstrlen(pcszVolumeRootPath));
   }
   else
      bDifferent = TRUE;

   return(bDifferent);
}


/*
** UnifyVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL UnifyVolume(PVOLUMELIST pvl, PLINKINFO pliRoot,
                              PVOLUME *ppvol)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(pvl, CVOLUMELIST));
   ASSERT(IS_VALID_STRUCT_PTR(pliRoot, CLINKINFO));
   ASSERT(IS_VALID_WRITE_PTR(ppvol, PVOLUME));

   if (AllocateMemory(sizeof(**ppvol), ppvol))
   {
      if (CopyLinkInfo(pliRoot, &((*ppvol)->pli)))
      {
         ARRAYINDEX aiUnused;

         (*ppvol)->ulcLock = 0;
         (*ppvol)->dwFlags = 0;
         (*ppvol)->vs = VS_UNKNOWN;
         (*ppvol)->hsRootPath = NULL;
         (*ppvol)->pvlParent = pvl;

         if (AddPtr(pvl->hpa, VolumeSortCmp, *ppvol, &aiUnused))
            bResult = TRUE;
         else
         {
            FreeMemory((*ppvol)->pli);
UNIFYVOLUME_BAIL:
            FreeMemory(*ppvol);
         }
      }
      else
         goto UNIFYVOLUME_BAIL;
   }

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*ppvol, CVOLUME));

   return(bResult);
}


/*
** CreateVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreateVolume(PVOLUMELIST pvl, PLINKINFO pliRoot,
                               PVOLUME *ppvol)
{
   BOOL bResult;
   PVOLUME pvol;
   ARRAYINDEX aiFound;

   ASSERT(IS_VALID_STRUCT_PTR(pvl, CVOLUMELIST));
   ASSERT(IS_VALID_STRUCT_PTR(pliRoot, CLINKINFO));
   ASSERT(IS_VALID_WRITE_PTR(ppvol, PVOLUME));

   /* Does a volume for the given root path already exist? */

   if (SearchSortedArray(pvl->hpa, &VolumeSearchCmp, pliRoot, &aiFound))
   {
      pvol = GetPtr(pvl->hpa, aiFound);
      bResult = TRUE;
   }
   else
      bResult = UnifyVolume(pvl, pliRoot, &pvol);

   if (bResult)
   {
      LockVolume(pvol);
      *ppvol = pvol;
   }

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*ppvol, CVOLUME));

   return(bResult);
}


/*
** UnlinkVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void UnlinkVolume(PCVOLUME pcvol)
{
   HPTRARRAY hpa;
   ARRAYINDEX aiFound;

   ASSERT(IS_VALID_STRUCT_PTR(pcvol, CVOLUME));

   hpa = pcvol->pvlParent->hpa;

   if (EVAL(SearchSortedArray(hpa, &VolumeSortCmp, pcvol, &aiFound)))
   {
      ASSERT(GetPtr(hpa, aiFound) == pcvol);

      DeletePtr(hpa, aiFound);
   }

   return;
}


/*
** DisconnectVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL DisconnectVolume(PVOLUME pvol)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   if (IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_DISCONNECT))
   {
      bResult = DisconnectLinkInfo(pvol->pli);

      CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_DISCONNECT);
   }
   else
      bResult = TRUE;

   return(bResult);
}


/*
** DestroyVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyVolume(PVOLUME pvol)
{
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   ClearVolumeInfo(pvol);

   FreeMemory(pvol->pli);
   FreeMemory(pvol);

   return;
}


/*
** LockVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void LockVolume(PVOLUME pvol)
{
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   ASSERT(pvol->ulcLock < ULONG_MAX);
   pvol->ulcLock++;

   return;
}


/*
** UnlockVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL UnlockVolume(PVOLUME pvol)
{
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   if (EVAL(pvol->ulcLock > 0))
      pvol->ulcLock--;

   return(pvol->ulcLock > 0);
}


/*
** InvalidateVolumeInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void InvalidateVolumeInfo(PVOLUME pvol)
{
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   SET_FLAG(pvol->dwFlags, VOLUME_FL_VERIFY_VOLUME);

   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   return;
}


/*
** ClearVolumeInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void ClearVolumeInfo(PVOLUME pvol)
{
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   DisconnectVolume(pvol);

   if (IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID))
   {
      DeleteString(pvol->hsRootPath);

      CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID);
   }

   CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_VERIFY_VOLUME);

   pvol->vs = VS_UNKNOWN;

   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   return;
}


/*
** GetUnavailableVolumeRootPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void GetUnavailableVolumeRootPath(PCLINKINFO pcli,
                                               LPTSTR pszRootPathBuf)
{
   LPCSTR pcszLinkInfoData;

   ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRootPathBuf, STR, MAX_PATH_LEN));

   /*
    * Try unavailable volume root paths in the following order:
    *    1) last redirected device
    *    2) net resource name
    *    3) local path           ...and take the _last_ good one!
    */

   if (GetLinkInfoData(pcli, LIDT_REDIRECTED_DEVICE, &pcszLinkInfoData) ||
       GetLinkInfoData(pcli, LIDT_NET_RESOURCE, &pcszLinkInfoData) ||
       GetLinkInfoData(pcli, LIDT_LOCAL_BASE_PATH, &pcszLinkInfoData))
   {
      //ASSERT(IS_VALID_STRING_PTR(pcszLinkInfoData, CSTR));
      ASSERT(lstrlenA(pcszLinkInfoData) < MAX_PATH_LEN);


#ifdef UNICODE
      {
        TCHAR szTmp[MAX_PATH] = TEXT("");
        MultiByteToWideChar(CP_ACP, 0, pcszLinkInfoData, -1, szTmp, MAX_PATH);
        ComposePath(pszRootPathBuf, szTmp, TEXT("\\"));
      }
#else

      ComposePath(pszRootPathBuf, pcszLinkInfoData, TEXT("\\"));

#endif

   }
   else
   {
      pszRootPathBuf[0] = TEXT('\0');

      ERROR_OUT((TEXT("GetUnavailableVolumeRootPath(): Net resource name and local base path unavailable.  Using empty string as unavailable root path.")));
   }

   ASSERT(IsRootPath(pszRootPathBuf) &&
          EVAL(lstrlen(pszRootPathBuf) < MAX_PATH_LEN));

   return;
}


/*
** VerifyAvailableVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL VerifyAvailableVolume(PVOLUME pvol)
{
   BOOL bResult = FALSE;
   PLINKINFO pli;

   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   ASSERT(pvol->vs == VS_AVAILABLE);
   ASSERT(IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID));

   WARNING_OUT((TEXT("VerifyAvailableVolume(): Calling CreateLinkInfo() to verify volume on %s."),
                GetString(pvol->hsRootPath)));

   if (CreateLinkInfo(GetString(pvol->hsRootPath), &pli))
   {
      bResult = (CompareLinkInfoReferents(pvol->pli, pli) == CR_EQUAL);

      DestroyLinkInfo(pli);

      if (bResult)
         TRACE_OUT((TEXT("VerifyAvailableVolume(): Volume %s has not changed."),
                    GetString(pvol->hsRootPath)));
      else
         WARNING_OUT((TEXT("VerifyAvailableVolume(): Volume %s has changed."),
                      GetString(pvol->hsRootPath)));
   }
   else
      WARNING_OUT((TEXT("VerifyAvailableVolume(): CreateLinkInfo() failed for %s."),
                   GetString(pvol->hsRootPath)));

   return(bResult);
}


/*
** ExpensiveResolveVolumeRootPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void ExpensiveResolveVolumeRootPath(PVOLUME pvol,
                                                 LPTSTR pszVolumeRootPathBuf)
{
   BOOL bResult;
   DWORD dwOutFlags;
   PLINKINFO pliUpdated;
   HSTRING hsRootPath;

   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszVolumeRootPathBuf, STR, MAX_PATH_LEN));

   if (pvol->vs == VS_UNKNOWN ||
       pvol->vs == VS_AVAILABLE)
   {
      /*
       * Only request a connection if connections are still permitted in this
       * volume list.
       */

      WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Calling ResolveLinkInfo() to determine volume availability and root path.")));

      bResult = ResolveLinkInfo(pvol->pli, pszVolumeRootPathBuf,
                                pvol->pvlParent->dwFlags,
                                pvol->pvlParent->hwndOwner, &dwOutFlags,
                                &pliUpdated);

      if (bResult)
      {
         pvol->vs = VS_AVAILABLE;

         if (IS_FLAG_SET(dwOutFlags, RLI_OFL_UPDATED))
         {
            PLINKINFO pliUpdatedCopy;

            ASSERT(IS_FLAG_SET(pvol->pvlParent->dwFlags, RLI_IFL_UPDATE));

            if (CopyLinkInfo(pliUpdated, &pliUpdatedCopy))
            {
               FreeMemory(pvol->pli);
               pvol->pli = pliUpdatedCopy;
            }

            DestroyLinkInfo(pliUpdated);

            WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Updating LinkInfo for volume %s."),
                         pszVolumeRootPathBuf));
         }

         if (IS_FLAG_SET(dwOutFlags, RLI_OFL_DISCONNECT))
         {
            SET_FLAG(pvol->dwFlags, VOLUME_FL_DISCONNECT);

            WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Volume %s must be disconnected when finished."),
                         pszVolumeRootPathBuf));
         }

         TRACE_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Volume %s is available."),
                    pszVolumeRootPathBuf));
      }
      else
         ASSERT(GetLastError() != ERROR_INVALID_PARAMETER);
   }
   else
   {
      ASSERT(pvol->vs == VS_UNAVAILABLE);
      bResult = FALSE;
   }

   if (! bResult)
   {
      pvol->vs = VS_UNAVAILABLE;

      if (GetLastError() == ERROR_CANCELLED)
      {
         ASSERT(IS_FLAG_SET(pvol->pvlParent->dwFlags, RLI_IFL_CONNECT));

         CLEAR_FLAG(pvol->pvlParent->dwFlags, RLI_IFL_CONNECT);

         WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Connection attempt cancelled.  No subsequent connections will be attempted.")));
      }

      GetUnavailableVolumeRootPath(pvol->pli, pszVolumeRootPathBuf);

      WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Using %s as unavailable volume root path."),
                   pszVolumeRootPathBuf));
   }

   /* Add volume root path string to volume list's string table. */

   if (IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID))
   {
      CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID);
      DeleteString(pvol->hsRootPath);
   }

   if (AddString(pszVolumeRootPathBuf, pvol->pvlParent->hst, GetHashBucketIndex, &hsRootPath))
   {
      SET_FLAG(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID);
      pvol->hsRootPath = hsRootPath;
   }
   else
      WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Unable to save %s as volume root path."),
                   pszVolumeRootPathBuf));

   return;
}


/*
** ResolveVolumeRootPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void ResolveVolumeRootPath(PVOLUME pvol,
                                        LPTSTR pszVolumeRootPathBuf)
{
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszVolumeRootPathBuf, STR, MAX_PATH_LEN));

   /* Do we have a cached volume root path to use? */

   if (IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID) &&
       (IS_FLAG_CLEAR(pvol->dwFlags, VOLUME_FL_VERIFY_VOLUME) ||
        (pvol->vs == VS_AVAILABLE &&
         VerifyAvailableVolume(pvol))))
   {
      /* Yes. */

      MyLStrCpyN(pszVolumeRootPathBuf, GetString(pvol->hsRootPath), MAX_PATH_LEN);
      ASSERT(lstrlen(pszVolumeRootPathBuf) < MAX_PATH_LEN);

      ASSERT(pvol->vs != VS_UNKNOWN);
   }
   else
      /* No.  Welcome in I/O City. */
      ExpensiveResolveVolumeRootPath(pvol, pszVolumeRootPathBuf);

   CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_VERIFY_VOLUME);

   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   return;
}


/*
** VOLUMERESULTFromLastError()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE VOLUMERESULT VOLUMERESULTFromLastError(VOLUMERESULT vr)
{
   switch (GetLastError())
   {
      case ERROR_OUTOFMEMORY:
         vr = VR_OUT_OF_MEMORY;
         break;

      case ERROR_BAD_PATHNAME:
         vr = VR_INVALID_PATH;
         break;

      default:
         break;
   }

   return(vr);
}


/*
** WriteVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT WriteVolume(HCACHEDFILE hcf, PVOLUME pvol)
{
   TWINRESULT tr;
   DBVOLUME dbvol;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   /* Write database volume followed by LinkInfo structure. */

   dbvol.hvol = (HVOLUME)pvol;

   if (WriteToCachedFile(hcf, (PCVOID)&dbvol, sizeof(dbvol), NULL) &&
       WriteToCachedFile(hcf, pvol->pli, *(PDWORD)(pvol->pli), NULL))
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


/*
** ReadVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT ReadVolume(HCACHEDFILE hcf, PVOLUMELIST pvl,
                                   PLINKINFO pliBuf, UINT ucbLinkInfoBufLen,
                                   HHANDLETRANS hhtVolumes)
{
   TWINRESULT tr = TR_CORRUPT_BRIEFCASE;
   DBVOLUME dbvol;
   DWORD dwcbRead;
   UINT ucbLinkInfoLen;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pvl, CVOLUMELIST));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pliBuf, LINKINFO, ucbLinkInfoBufLen));
   ASSERT(IS_VALID_HANDLE(hhtVolumes, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &dbvol, sizeof(dbvol), &dwcbRead) &&
       dwcbRead == sizeof(dbvol) &&
       ReadFromCachedFile(hcf, &ucbLinkInfoLen, sizeof(ucbLinkInfoLen), &dwcbRead) &&
       dwcbRead == sizeof(ucbLinkInfoLen) &&
       ucbLinkInfoLen <= ucbLinkInfoBufLen)
   {
      /* Read the remainder of the LinkInfo structure into memory. */

      DWORD dwcbRemainder;

      pliBuf->ucbSize = ucbLinkInfoLen;
      dwcbRemainder = ucbLinkInfoLen - sizeof(ucbLinkInfoLen);

      if (ReadFromCachedFile(hcf, (PBYTE)pliBuf + sizeof(ucbLinkInfoLen),
                             dwcbRemainder, &dwcbRead) &&
          dwcbRead == dwcbRemainder &&
          IsValidLinkInfo(pliBuf))
      {
         PVOLUME pvol;

         if (CreateVolume(pvl, pliBuf, &pvol))
         {
            /*
             * To leave read volumes with 0 initial lock count, we must undo
             * the LockVolume() performed by CreateVolume().
             */

            UnlockVolume(pvol);

            if (AddHandleToHandleTranslator(hhtVolumes,
                                            (HGENERIC)(dbvol.hvol),
                                            (HGENERIC)pvol))
               tr = TR_SUCCESS;
            else
            {
               UnlinkVolume(pvol);
               DestroyVolume(pvol);

               tr = TR_OUT_OF_MEMORY;
            }
         }
         else
            tr = TR_OUT_OF_MEMORY;
      }
   }

   return(tr);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidPCVOLUMELIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCVOLUMELIST(PCVOLUMELIST pcvl)
{
   return(IS_VALID_READ_PTR(pcvl, CVOLUMELIST) &&
          IS_VALID_HANDLE(pcvl->hpa, PTRARRAY) &&
          IS_VALID_HANDLE(pcvl->hst, STRINGTABLE) &&
          FLAGS_ARE_VALID(pcvl->dwFlags, ALL_RLI_IFLAGS) &&
          (IS_FLAG_CLEAR(pcvl->dwFlags, RLI_IFL_ALLOW_UI) ||
           IS_VALID_HANDLE(pcvl->hwndOwner, WND)));
}


/*
** IsValidVOLUMESTATE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidVOLUMESTATE(VOLUMESTATE vs)
{
   BOOL bResult;

   switch (vs)
   {
      case VS_UNKNOWN:
      case VS_AVAILABLE:
      case VS_UNAVAILABLE:
         bResult = TRUE;
         break;

      default:
         ERROR_OUT((TEXT("IsValidVOLUMESTATE(): Invalid VOLUMESTATE %d."),
                    vs));
         bResult = FALSE;
         break;
   }

   return(bResult);
}


/*
** IsValidPCVOLUME()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCVOLUME(PCVOLUME pcvol)
{
   return(IS_VALID_READ_PTR(pcvol, CVOLUME) &&
          FLAGS_ARE_VALID(pcvol->dwFlags, ALL_VOLUME_FLAGS) &&
          EVAL(IsValidVOLUMESTATE(pcvol->vs)) &&
          IS_VALID_STRUCT_PTR(pcvol->pli, CLINKINFO) &&
          (IS_FLAG_CLEAR(pcvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID) ||
           IS_VALID_HANDLE(pcvol->hsRootPath, STRING)) &&
          IS_VALID_STRUCT_PTR(pcvol->pvlParent, CVOLUMELIST));
}

#endif


#ifdef DEBUG

/*
** IsValidPCVOLUMEDESC()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCVOLUMEDESC(PCVOLUMEDESC pcvoldesc)
{
   /*
    * A set dwSerialNumber may be any value.  An unset dwSerialNumber must be
    * 0.  A set strings may be any valid string.  An unset string must be the
    * empty string.
    */

   return(IS_VALID_READ_PTR(pcvoldesc, CVOLUMEDESC) &&
          EVAL(pcvoldesc->ulSize == sizeof(*pcvoldesc)) &&
          FLAGS_ARE_VALID(pcvoldesc->dwFlags, ALL_VD_FLAGS) &&
          (IS_FLAG_SET(pcvoldesc->dwFlags, VD_FL_SERIAL_NUMBER_VALID) ||
           ! pcvoldesc->dwSerialNumber) &&
          ((IS_FLAG_CLEAR(pcvoldesc->dwFlags, VD_FL_VOLUME_LABEL_VALID) &&
            ! pcvoldesc->rgchVolumeLabel[0]) ||
           (IS_FLAG_SET(pcvoldesc->dwFlags, VD_FL_VOLUME_LABEL_VALID) &&
            IS_VALID_STRING_PTR(pcvoldesc->rgchVolumeLabel, CSTR) &&
            EVAL(lstrlen(pcvoldesc->rgchVolumeLabel) < ARRAYSIZE(pcvoldesc->rgchVolumeLabel)))) &&
          ((IS_FLAG_CLEAR(pcvoldesc->dwFlags, VD_FL_NET_RESOURCE_VALID) &&
            ! pcvoldesc->rgchNetResource[0]) ||
           (IS_FLAG_SET(pcvoldesc->dwFlags, VD_FL_NET_RESOURCE_VALID) &&
            IS_VALID_STRING_PTR(pcvoldesc->rgchNetResource, CSTR) &&
            EVAL(lstrlen(pcvoldesc->rgchNetResource) < ARRAYSIZE(pcvoldesc->rgchNetResource)))));
}

#endif


/****************************** Public Functions *****************************/


/*
** CreateVolumeList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreateVolumeList(DWORD dwFlags, HWND hwndOwner,
                                  PHVOLUMELIST phvl)
{
   BOOL bResult = FALSE;
   PVOLUMELIST pvl;

   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_RLI_IFLAGS));
   ASSERT(IS_FLAG_CLEAR(dwFlags, RLI_IFL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_VALID_WRITE_PTR(phvl, HVOLUMELIST));

   if (AllocateMemory(sizeof(*pvl), &pvl))
   {
      NEWSTRINGTABLE nszt;

      /* Create string table for volume root path strngs. */

      nszt.hbc = NUM_VOLUME_HASH_BUCKETS;

      if (CreateStringTable(&nszt, &(pvl->hst)))
      {
         NEWPTRARRAY npa;

         /* Create pointer array of volumes. */

         npa.aicInitialPtrs = NUM_START_VOLUMES;
         npa.aicAllocGranularity = NUM_VOLUMES_TO_ADD;
         npa.dwFlags = NPA_FL_SORTED_ADD;

         if (CreatePtrArray(&npa, &(pvl->hpa)))
         {
            pvl->dwFlags = dwFlags;
            pvl->hwndOwner = hwndOwner;

            *phvl = (HVOLUMELIST)pvl;
            bResult = TRUE;
         }
         else
         {
            DestroyStringTable(pvl->hst);
CREATEVOLUMELIST_BAIL:
            FreeMemory(pvl);
         }
      }
      else
         goto CREATEVOLUMELIST_BAIL;
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phvl, VOLUMELIST));

   return(bResult);
}


/*
** DestroyVolumeList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyVolumeList(HVOLUMELIST hvl)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

   /* First free all volumes in array. */

   aicPtrs = GetPtrCount(((PCVOLUMELIST)hvl)->hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      DestroyVolume(GetPtr(((PCVOLUMELIST)hvl)->hpa, ai));

   /* Now wipe out the array. */

   DestroyPtrArray(((PCVOLUMELIST)hvl)->hpa);

   ASSERT(! GetStringCount(((PCVOLUMELIST)hvl)->hst));
   DestroyStringTable(((PCVOLUMELIST)hvl)->hst);

   FreeMemory((PVOLUMELIST)hvl);

   return;
}


/*
** InvalidateVolumeListInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void InvalidateVolumeListInfo(HVOLUMELIST hvl)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

   aicPtrs = GetPtrCount(((PCVOLUMELIST)hvl)->hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      InvalidateVolumeInfo(GetPtr(((PCVOLUMELIST)hvl)->hpa, ai));

   WARNING_OUT((TEXT("InvalidateVolumeListInfo(): Volume cache invalidated.")));

   return;
}


/*
** ClearVolumeListInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ClearVolumeListInfo(HVOLUMELIST hvl)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

   aicPtrs = GetPtrCount(((PCVOLUMELIST)hvl)->hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      ClearVolumeInfo(GetPtr(((PCVOLUMELIST)hvl)->hpa, ai));

   WARNING_OUT((TEXT("ClearVolumeListInfo(): Volume cache cleared.")));

   return;
}


/*
** AddVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE VOLUMERESULT AddVolume(HVOLUMELIST hvl, LPCTSTR pcszPath,
                                   PHVOLUME phvol, LPTSTR pszPathSuffixBuf)
{
   VOLUMERESULT vr;
   TCHAR rgchPath[MAX_PATH_LEN];
   LPTSTR pszFileName;
   DWORD dwPathLen;

   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(phvol, HVOLUME));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPathSuffixBuf, STR, MAX_PATH_LEN));

   dwPathLen = GetFullPathName(pcszPath, ARRAYSIZE(rgchPath), rgchPath,
                               &pszFileName);

   if (dwPathLen > 0 && dwPathLen < ARRAYSIZE(rgchPath))
   {
      ARRAYINDEX aiFound;

      /* Does a volume for this root path already exist? */

      if (LinearSearchArray(((PVOLUMELIST)hvl)->hpa,
                            &SearchForVolumeByRootPathCmp, rgchPath,
                            &aiFound))
      {
         PVOLUME pvol;
         LPCTSTR pcszVolumeRootPath;

         /* Yes. */

         pvol = GetPtr(((PVOLUMELIST)hvl)->hpa, aiFound);

         LockVolume(pvol);

         ASSERT(pvol->vs == VS_AVAILABLE &&
                IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID));

         pcszVolumeRootPath = GetString(pvol->hsRootPath);

         ASSERT(lstrlen(pcszVolumeRootPath) <= lstrlen(rgchPath));

         lstrcpy(pszPathSuffixBuf, rgchPath + lstrlen(pcszVolumeRootPath));

         *phvol = (HVOLUME)pvol;
         vr = VR_SUCCESS;
      }
      else
      {
         DWORD dwOutFlags;
         TCHAR rgchNetResource[MAX_PATH_LEN];
         LPTSTR pszRootPathSuffix;

         /* No.  Create a new volume. */

         if (GetCanonicalPathInfo(pcszPath, rgchPath, &dwOutFlags,
                                  rgchNetResource, &pszRootPathSuffix))
         {
            PLINKINFO pli;

            lstrcpy(pszPathSuffixBuf, pszRootPathSuffix);
            *pszRootPathSuffix = TEXT('\0');

            WARNING_OUT((TEXT("AddVolume(): Creating LinkInfo for root path %s."),
                         rgchPath));

            if (CreateLinkInfo(rgchPath, &pli))
            {
               PVOLUME pvol;

               if (CreateVolume((PVOLUMELIST)hvl, pli, &pvol))
               {
                  TCHAR rgchUnusedVolumeRootPath[MAX_PATH_LEN];

                  ResolveVolumeRootPath(pvol, rgchUnusedVolumeRootPath);

                  *phvol = (HVOLUME)pvol;
                  vr = VR_SUCCESS;
               }
               else
                  vr = VR_OUT_OF_MEMORY;

               DestroyLinkInfo(pli);
            }
            else
               /*
                * Differentiate between VR_UNAVAILABLE_VOLUME and
                * VR_OUT_OF_MEMORY.
                */
               vr = VOLUMERESULTFromLastError(VR_UNAVAILABLE_VOLUME);
         }
         else
            vr = VOLUMERESULTFromLastError(VR_INVALID_PATH);
      }
   }
   else
   {
      ASSERT(! dwPathLen);

      vr = VOLUMERESULTFromLastError(VR_INVALID_PATH);
   }

   ASSERT(vr != VR_SUCCESS ||
          (IS_VALID_HANDLE(*phvol, VOLUME) &&
           EVAL(IsValidPathSuffix(pszPathSuffixBuf))));

   return(vr);
}


/*
** DeleteVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DeleteVolume(HVOLUME hvol)
{
   ASSERT(IS_VALID_HANDLE(hvol, VOLUME));

   if (! UnlockVolume((PVOLUME)hvol))
   {
      UnlinkVolume((PVOLUME)hvol);
      DestroyVolume((PVOLUME)hvol);
   }

   return;
}


/*
** CompareVolumes()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT CompareVolumes(HVOLUME hvolFirst,
                                            HVOLUME hvolSecond)
{
   ASSERT(IS_VALID_HANDLE(hvolFirst, VOLUME));
   ASSERT(IS_VALID_HANDLE(hvolSecond, VOLUME));

   /* This comparison works across volume lists. */

   return(CompareLinkInfoVolumes(((PCVOLUME)hvolFirst)->pli,
                                 ((PCVOLUME)hvolSecond)->pli));
}


/*
** CopyVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CopyVolume(HVOLUME hvolSrc, HVOLUMELIST hvlDest,
                            PHVOLUME phvolCopy)
{
   BOOL bResult;
   PVOLUME pvol;

   ASSERT(IS_VALID_HANDLE(hvolSrc, VOLUME));
   ASSERT(IS_VALID_HANDLE(hvlDest, VOLUMELIST));
   ASSERT(IS_VALID_WRITE_PTR(phvolCopy, HVOLUME));

   /* Is the destination volume list the source volume's volume list? */

   if (((PCVOLUME)hvolSrc)->pvlParent == (PCVOLUMELIST)hvlDest)
   {
      /* Yes.  Use the source volume. */

      LockVolume((PVOLUME)hvolSrc);
      pvol = (PVOLUME)hvolSrc;
      bResult = TRUE;
   }
   else
      bResult = CreateVolume((PVOLUMELIST)hvlDest, ((PCVOLUME)hvolSrc)->pli,
                             &pvol);

   if (bResult)
      *phvolCopy = (HVOLUME)pvol;

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phvolCopy, VOLUME));

   return(bResult);
}


/*
** IsVolumeAvailable()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsVolumeAvailable(HVOLUME hvol)
{
   TCHAR rgchUnusedVolumeRootPath[MAX_PATH_LEN];

   ASSERT(IS_VALID_HANDLE(hvol, VOLUME));

   ResolveVolumeRootPath((PVOLUME)hvol, rgchUnusedVolumeRootPath);

   ASSERT(IsValidVOLUMESTATE(((PCVOLUME)hvol)->vs) &&
          ((PCVOLUME)hvol)->vs != VS_UNKNOWN);

   return(((PCVOLUME)hvol)->vs == VS_AVAILABLE);
}


/*
** GetVolumeRootPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void GetVolumeRootPath(HVOLUME hvol, LPTSTR pszRootPathBuf)
{
   ASSERT(IS_VALID_HANDLE(hvol, VOLUME));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRootPathBuf, STR, MAX_PATH_LEN));

   ResolveVolumeRootPath((PVOLUME)hvol, pszRootPathBuf);

   ASSERT(IsRootPath(pszRootPathBuf));

   return;
}


#ifdef DEBUG

/*
** DebugGetVolumeRootPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** N.b., DebugGetVolumeRootPath() must be non-intrusive.
*/
PUBLIC_CODE LPTSTR DebugGetVolumeRootPath(HVOLUME hvol, LPTSTR pszRootPathBuf)
{
   ASSERT(IS_VALID_HANDLE(hvol, VOLUME));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRootPathBuf, STR, MAX_PATH_LEN));

   if (IS_FLAG_SET(((PVOLUME)hvol)->dwFlags, VOLUME_FL_ROOT_PATH_VALID))
      MyLStrCpyN(pszRootPathBuf, GetString(((PVOLUME)hvol)->hsRootPath), MAX_PATH_LEN);
   else
      GetUnavailableVolumeRootPath(((PVOLUME)hvol)->pli, pszRootPathBuf);

   ASSERT(IsRootPath(pszRootPathBuf));

   return(pszRootPathBuf);
}


/*
** GetVolumeCount()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE ULONG GetVolumeCount(HVOLUMELIST hvl)
{
   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

   return(GetPtrCount(((PCVOLUMELIST)hvl)->hpa));
}

#endif


/*
** DescribeVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DescribeVolume(HVOLUME hvol, PVOLUMEDESC pvoldesc)
{
   PCVOID pcv;

   ASSERT(IS_VALID_HANDLE(hvol, VOLUME));
   ASSERT(IS_VALID_WRITE_PTR(pvoldesc, VOLUMEDESC));

   ASSERT(pvoldesc->ulSize == sizeof(*pvoldesc));

   pvoldesc->dwFlags = 0;

   if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_VOLUME_SERIAL_NUMBER, &pcv))
   {
      pvoldesc->dwSerialNumber = *(PCDWORD)pcv;
      SET_FLAG(pvoldesc->dwFlags, VD_FL_SERIAL_NUMBER_VALID);
   }
   else
      pvoldesc->dwSerialNumber = 0;

   if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_VOLUME_LABELW, &pcv) && pcv)
   {
      lstrcpy(pvoldesc->rgchVolumeLabel, pcv);
      SET_FLAG(pvoldesc->dwFlags, VD_FL_VOLUME_LABEL_VALID);
   }
   else if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_VOLUME_LABEL, &pcv) && pcv)
   {
      MultiByteToWideChar(CP_ACP, 0, pcv, -1, pvoldesc->rgchVolumeLabel, MAX_PATH);
      SET_FLAG(pvoldesc->dwFlags, VD_FL_VOLUME_LABEL_VALID);
   }
   else
   {
      pvoldesc->rgchVolumeLabel[0] = TEXT('\0');
   }

   if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_NET_RESOURCEW, &pcv) && pcv)
   {
        lstrcpy(pvoldesc->rgchNetResource, pcv);
        SET_FLAG(pvoldesc->dwFlags, VD_FL_NET_RESOURCE_VALID);
   }
   else if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_NET_RESOURCE, &pcv) && pcv)
   {
        MultiByteToWideChar(CP_ACP, 0, pcv, -1, pvoldesc->rgchNetResource, MAX_PATH);
        SET_FLAG(pvoldesc->dwFlags, VD_FL_NET_RESOURCE_VALID);
   }
   else
      pvoldesc->rgchNetResource[0] = TEXT('\0');

   ASSERT(IS_VALID_STRUCT_PTR(pvoldesc, CVOLUMEDESC));

   return;
}


/*
** WriteVolumeList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT WriteVolumeList(HCACHEDFILE hcf, HVOLUMELIST hvl)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
   DWORD dwcbDBVolumeListHeaderOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

   /* Save initial file position. */

   dwcbDBVolumeListHeaderOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbDBVolumeListHeaderOffset != INVALID_SEEK_POSITION)
   {
      DBVOLUMELISTHEADER dbvlh;

      /* Leave space for volume list header. */

      ZeroMemory(&dbvlh, sizeof(dbvlh));

      if (WriteToCachedFile(hcf, (PCVOID)&dbvlh, sizeof(dbvlh), NULL))
      {
         ARRAYINDEX aicPtrs;
         ARRAYINDEX ai;
         UINT ucbMaxLinkInfoLen = 0;
         LONG lcVolumes = 0;

         tr = TR_SUCCESS;

         aicPtrs = GetPtrCount(((PCVOLUMELIST)hvl)->hpa);

         /* Write all volumes. */

         for (ai = 0; ai < aicPtrs; ai++)
         {
            PVOLUME pvol;

            pvol = GetPtr(((PCVOLUMELIST)hvl)->hpa, ai);

            /*
             * As a sanity check, don't save any volume with a lock count of 0.
             * A 0 lock count implies that the volume has not been referenced
             * since it was restored from the database, or something is broken.
             */

            if (pvol->ulcLock > 0)
            {
               tr = WriteVolume(hcf, pvol);

               if (tr == TR_SUCCESS)
               {
                  ASSERT(lcVolumes < LONG_MAX);
                  lcVolumes++;

                  if (pvol->pli->ucbSize > ucbMaxLinkInfoLen)
                     ucbMaxLinkInfoLen = pvol->pli->ucbSize;
               }
               else
                  break;
            }
            else
               ERROR_OUT((TEXT("WriteVolumeList(): VOLUME has 0 lock count and will not be written.")));
         }

         /* Save volume list header. */

         if (tr == TR_SUCCESS)
         {
            dbvlh.lcVolumes = lcVolumes;
            dbvlh.ucbMaxLinkInfoLen = ucbMaxLinkInfoLen;

            tr = WriteDBSegmentHeader(hcf, dwcbDBVolumeListHeaderOffset,
                                      &dbvlh, sizeof(dbvlh));

            TRACE_OUT((TEXT("WriteVolumeList(): Wrote %ld volumes; maximum LinkInfo length %u bytes."),
                       dbvlh.lcVolumes,
                       dbvlh.ucbMaxLinkInfoLen));
         }
      }
   }

   return(tr);
}


/*
** ReadVolumeList()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT ReadVolumeList(HCACHEDFILE hcf, HVOLUMELIST hvl,
                                      PHHANDLETRANS phht)
{
   TWINRESULT tr;
   DBVOLUMELISTHEADER dbvlh;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));
   ASSERT(IS_VALID_WRITE_PTR(phht, HHANDLETRANS));

   if (ReadFromCachedFile(hcf, &dbvlh, sizeof(dbvlh), &dwcbRead) &&
       dwcbRead == sizeof(dbvlh))
   {
      HHANDLETRANS hht;

      tr = TR_OUT_OF_MEMORY;

      if (CreateHandleTranslator(dbvlh.lcVolumes, &hht))
      {
         PLINKINFO pliBuf;

         if (AllocateMemory(dbvlh.ucbMaxLinkInfoLen, &pliBuf))
         {
            LONG l;

            tr = TR_SUCCESS;

            TRACE_OUT((TEXT("ReadPathList(): Reading %ld volumes; maximum LinkInfo length %u bytes."),
                       dbvlh.lcVolumes,
                       dbvlh.ucbMaxLinkInfoLen));

            for (l = 0; l < dbvlh.lcVolumes; l++)
            {
               tr = ReadVolume(hcf, (PVOLUMELIST)hvl, pliBuf,
                               dbvlh.ucbMaxLinkInfoLen, hht);

               if (tr != TR_SUCCESS)
                  break;
            }

            if (tr == TR_SUCCESS)
            {
               PrepareForHandleTranslation(hht);
               *phht = hht;

               ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));
               ASSERT(IS_VALID_HANDLE(*phht, HANDLETRANS));
            }
            else
               DestroyHandleTranslator(hht);

            FreeMemory(pliBuf);
         }
      }
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   ASSERT(tr != TR_SUCCESS ||
          (IS_VALID_HANDLE(hvl, VOLUMELIST) &&
           IS_VALID_HANDLE(*phht, HANDLETRANS)));

   return(tr);
}


/*
** IsValidHVOLUME()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHVOLUME(HVOLUME hvol)
{
   return(IS_VALID_STRUCT_PTR((PCVOLUME)hvol, CVOLUME));
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidHVOLUMELIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHVOLUMELIST(HVOLUMELIST hvl)
{
   return(IS_VALID_STRUCT_PTR((PCVOLUMELIST)hvl, CVOLUMELIST));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\volume.h ===
/*
 * volume.h - Volume ADT module description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HVOLUMELIST);
DECLARE_STANDARD_TYPES(HVOLUMELIST);

DECLARE_HANDLE(HVOLUME);
DECLARE_STANDARD_TYPES(HVOLUME);

/* volume results returned by AddVolume() */

typedef enum _volumeresult
{
   VR_SUCCESS,

   VR_UNAVAILABLE_VOLUME,

   VR_OUT_OF_MEMORY,

   VR_INVALID_PATH
}
VOLUMERESULT;
DECLARE_STANDARD_TYPES(VOLUMERESULT);


/* Prototypes
 *************/

/* volume.c */

extern BOOL CreateVolumeList(DWORD, HWND, PHVOLUMELIST);
extern void DestroyVolumeList(HVOLUMELIST);
extern void InvalidateVolumeListInfo(HVOLUMELIST);
PUBLIC_CODE void ClearVolumeListInfo(HVOLUMELIST);
extern VOLUMERESULT AddVolume(HVOLUMELIST, LPCTSTR, PHVOLUME, LPTSTR);
extern void DeleteVolume(HVOLUME);
extern COMPARISONRESULT CompareVolumes(HVOLUME, HVOLUME);
extern BOOL CopyVolume(HVOLUME, HVOLUMELIST, PHVOLUME);
extern BOOL IsVolumeAvailable(HVOLUME);
extern void GetVolumeRootPath(HVOLUME, LPTSTR);

#ifdef DEBUG

extern LPTSTR DebugGetVolumeRootPath(HVOLUME, LPTSTR);
extern ULONG GetVolumeCount(HVOLUMELIST);

#endif

extern void DescribeVolume(HVOLUME, PVOLUMEDESC);
extern TWINRESULT WriteVolumeList(HCACHEDFILE, HVOLUMELIST);
extern TWINRESULT ReadVolumeList(HCACHEDFILE, HVOLUMELIST, PHHANDLETRANS);
extern BOOL IsValidHVOLUME(HVOLUME);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidHVOLUMELIST(HVOLUMELIST);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\core\util.h ===
/*
 * util.h - Miscellaneous utility functions module description.
 */


/* Constants
 ************/

/* maximum length of buffer required by SeparatePath() */

#define MAX_SEPARATED_PATH_LEN            (MAX_PATH_LEN + 1)

/* events for NotifyShell */

typedef enum _notifyshellevent
{
   NSE_CREATE_ITEM,
   NSE_DELETE_ITEM,
   NSE_CREATE_FOLDER,
   NSE_DELETE_FOLDER,
   NSE_UPDATE_ITEM,
   NSE_UPDATE_FOLDER
}
NOTIFYSHELLEVENT;
DECLARE_STANDARD_TYPES(NOTIFYSHELLEVENT);


/* Prototypes
 *************/

/* util.c */

extern void NotifyShell(LPCTSTR, NOTIFYSHELLEVENT);
extern COMPARISONRESULT ComparePathStringsByHandle(HSTRING, HSTRING);
extern COMPARISONRESULT MyLStrCmpNI(LPCTSTR, LPCTSTR, int);
extern void ComposePath(LPTSTR, LPCTSTR, LPCTSTR);
extern LPCTSTR ExtractFileName(LPCTSTR);
extern LPCTSTR ExtractExtension(LPCTSTR);
extern HASHBUCKETCOUNT GetHashBucketIndex(LPCTSTR, HASHBUCKETCOUNT);
extern COMPARISONRESULT MyCompareStrings(LPCTSTR, LPCTSTR, BOOL);
extern BOOL RegKeyExists(HKEY, LPCTSTR);
extern BOOL CopyLinkInfo(PCLINKINFO, PLINKINFO *);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidPCLINKINFO(PCLINKINFO);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\init.c ===
/*
 * init.c - DLL startup routines module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "init.h"


/****************************** Public Functions *****************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** LibMain()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL APIENTRY LibMain(HANDLE hModule, DWORD dwReason, PVOID pvReserved)
{
   BOOL bResult;

   DebugEntry(LibMain);

   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
         bResult = AttachProcess(hModule);
         break;

      case DLL_PROCESS_DETACH:
         bResult = DetachProcess(hModule);
         break;

      case DLL_THREAD_ATTACH:
         bResult = AttachThread(hModule);
         break;

      case DLL_THREAD_DETACH:
         bResult = DetachThread(hModule);
         break;

      default:
         ERROR_OUT((TEXT("LibMain() called with unrecognized dwReason %lu."),
                    dwReason));
         bResult = FALSE;
         break;
   }

   DebugExitBOOL(LibMain, bResult);

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\canon.h ===
/*
 * canon.h - Canonical path manipulation module description.
 */


/* Constants
 ************/

#define MAX_NETRESOURCE_LEN      (2 * MAX_PATH_LEN)


/* Types
 ********/

/* NETRESOURCE buffer */

typedef union _netresourcebuf
{
   NETRESOURCE nr;

   BYTE rgbyte[MAX_NETRESOURCE_LEN];
}
NETRESOURCEBUF;
DECLARE_STANDARD_TYPES(NETRESOURCEBUF);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\canon.c ===
/*
 * canon.c - Canonical path manipulation module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL GetCNRInfoForDevice(LPTSTR, LPTSTR, PDWORD, PDWORD);
PRIVATE_CODE BOOL GetDrivePathInfo(LPTSTR, PDWORD, LPTSTR, LPTSTR *);
PRIVATE_CODE BOOL GetRemotePathInfo(LPTSTR, PDWORD, LPTSTR, LPTSTR *);
PRIVATE_CODE void CanonicalizeTrailingSlash(LPTSTR);

#ifdef DEBUG

PRIVATE_CODE BOOL CheckFullPathInfo(LPCTSTR, PDWORD, LPCTSTR, LPCTSTR *);

#endif


/*
** GetCNRInfoForDevice()
**
**
**
** Arguments:
**
** Returns:       BOOL
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GetCNRInfoForDevice(LPTSTR pszDeviceName, LPTSTR pszNameBuf,
                                      PDWORD pdwcbLen, PDWORD pdwOutFlags)
{
   DWORD dwNetResult;
   BOOL bResult;
   /* "X:" + null terminator */
   TCHAR rgchDrive[2 + 1];

   ASSERT(IS_VALID_STRING_PTR(pszDeviceName, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pdwcbLen, DWORD));
   ASSERT(*pdwcbLen > 0);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszNameBuf, TCHAR, (UINT)(*pdwcbLen)));
   ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));

   /* WNetGetConnection requires the device name to have no trailing
   ** backslash.
   */
   MyLStrCpyN(rgchDrive, pszDeviceName, ARRAYSIZE(rgchDrive));
   dwNetResult = WNetGetConnection(rgchDrive, pszNameBuf, pdwcbLen);

   switch (dwNetResult)
   {
      case NO_ERROR:
         *pdwOutFlags = GCPI_OFL_REMOTE;
         bResult = TRUE;
         TRACE_OUT((TEXT("GetCNRInfoForDevice(): %s is redirected to net resource \"%s\"."),
                    pszDeviceName,
                    pszNameBuf));
         break;

      case ERROR_NOT_CONNECTED:
         *pdwOutFlags = 0;
         bResult = TRUE;
         TRACE_OUT((TEXT("GetCNRInfoForDevice(): %s is not redirected."),
                    pszDeviceName));
         break;

      default:
         WARNING_OUT((TEXT("GetCNRInfoForDevice(): WNetGetConnection() on %s returned %lu."),
                      pszDeviceName,
                      dwNetResult));
         bResult = FALSE;
         break;
   }

   ASSERT(! bResult ||
          FLAGS_ARE_VALID(*pdwOutFlags, ALL_GCPI_OFLAGS) &&
          (IS_FLAG_CLEAR(*pdwOutFlags, GCPI_OFL_REMOTE) ||
           IsValidCNRName(pszNameBuf)));

   return(bResult);
}


/*
** GetDrivePathInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GetDrivePathInfo(LPTSTR pszDrivePath, PDWORD pdwOutFlags,
                                   LPTSTR pszNetResourceNameBuf,
                                   LPTSTR *ppszRootPathSuffix)
{
   BOOL bResult;
   /* "X:\" + null terminator. */
   TCHAR rgchDriveRootPath[3 + 1];

   ASSERT(IsDrivePath(pszDrivePath));
   ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszNetResourceNameBuf, STR, MAX_PATH_LEN));
   ASSERT(IS_VALID_WRITE_PTR(ppszRootPathSuffix, LPTSTR));

   ASSERT(lstrlen(pszDrivePath) >= 3);

   *pdwOutFlags = 0;

   MyLStrCpyN(rgchDriveRootPath, pszDrivePath, ARRAYSIZE(rgchDriveRootPath));

   ASSERT(IsDriveRootPath(rgchDriveRootPath));

   /* Do we need to get the CNR name for this drive path? */

   if (GetDriveType(rgchDriveRootPath) != DRIVE_REMOTE)
      /* No. */
      bResult = TRUE;
   else
   {
      DWORD dwcbBufLen = MAX_PATH_LEN;

      /* Yes. */

      bResult = GetCNRInfoForDevice(rgchDriveRootPath, pszNetResourceNameBuf,
                                    &dwcbBufLen, pdwOutFlags);
   }

   *ppszRootPathSuffix = pszDrivePath + 3;

   ASSERT(! bResult ||
          CheckFullPathInfo(pszDrivePath, pdwOutFlags, pszNetResourceNameBuf,
                            ppszRootPathSuffix));

   return(bResult);
}


/*
** GetRemotePathInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GetRemotePathInfo(LPTSTR pszRemotePath, PDWORD pdwOutFlags,
                                    LPTSTR pszNetResourceNameBuf,
                                    LPTSTR *ppszRootPathSuffix)
{
   BOOL bResult;

   ASSERT(IsFullPath(pszRemotePath));
   ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszNetResourceNameBuf, STR, MAX_PATH_LEN));
   ASSERT(IS_VALID_WRITE_PTR(ppszRootPathSuffix, LPTSTR));

   /* Is this a "\\server\share" name? */

   bResult = IsUNCPath(pszRemotePath);

   if (bResult)
   {
      LPTSTR psz;

      *pdwOutFlags = 0;

      /*
       * Yes.  Skip two leading slashes and look for end of \\server\share
       * specification.
       */

      /* Assume (as above) that a slash cannot be a DBCS lead byte. */

      for (psz = pszRemotePath + 2; ! IS_SLASH(*psz); psz = CharNext(psz))
         ASSERT(*psz);

      ASSERT(IS_SLASH(*psz));

      /*
       * Found first slash after double slash.  Find end of string or next
       * slash as end of root specification.
       */

      for (psz = CharNext(psz); *psz; psz = CharNext(psz))
      {
         if (IS_SLASH(*psz))
            break;
      }

      ASSERT(psz >= pszRemotePath);

      /* Add trailing slash for UNC root path. */

      if (! *psz)
      {
         *psz = SLASH;
         *(psz + 1) = TEXT('\0');
      }

      *ppszRootPathSuffix = (LPTSTR)psz + 1;

      ASSERT(! IS_SLASH(**ppszRootPathSuffix));

      /* (+ 1) for null terminator. */

      MyLStrCpyN(pszNetResourceNameBuf, pszRemotePath, psz - pszRemotePath + 1);

      CharUpper(pszNetResourceNameBuf);

      SET_FLAG(*pdwOutFlags, GCPI_OFL_REMOTE);
      bResult = TRUE;
   }
   else
      /* Not a UNC path. */
      SetLastError(ERROR_BAD_PATHNAME);

   ASSERT(! bResult ||
          CheckFullPathInfo(pszRemotePath, pdwOutFlags, pszNetResourceNameBuf,
                            ppszRootPathSuffix));

   return(bResult);
}


/*
** CanonicalizeTrailingSlash()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void CanonicalizeTrailingSlash(LPTSTR pszRootPathSuffix)
{
   LPTSTR pszLast;

   ASSERT(IS_VALID_STRING_PTR(pszRootPathSuffix, STR));

   ASSERT(! IS_SLASH(*pszRootPathSuffix));

   /* No path suffix should end in a slash. */

   pszLast = CharPrev(pszRootPathSuffix,
                      pszRootPathSuffix + lstrlen(pszRootPathSuffix));

   if (IS_SLASH(*pszLast))
      *pszLast = TEXT('\0');

   ASSERT(IsValidPathSuffix(pszRootPathSuffix));

   return;
}


#ifdef DEBUG

/*
** CheckFullPathInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CheckFullPathInfo(LPCTSTR pcszFullPath,
                                    PDWORD pdwOutFlags,
                                    LPCTSTR pcszNetResourceName,
                                    LPCTSTR *ppcszRootPathSuffix)
{
   return(EVAL(IsFullPath(pcszFullPath)) &&
          FLAGS_ARE_VALID(*pdwOutFlags, ALL_GCPI_OFLAGS) &&
          (IS_FLAG_CLEAR(*pdwOutFlags, GCPI_OFL_REMOTE) ||
           (EVAL(IsValidCNRName(pcszNetResourceName)) &&
            EVAL(lstrlen(pcszNetResourceName) < MAX_PATH_LEN))) &&
          (IS_FLAG_SET(*pdwOutFlags, GCPI_OFL_REMOTE) ||
           EVAL(IsLocalDrivePath(pcszFullPath))) &&
          IS_VALID_STRING_PTR(*ppcszRootPathSuffix, CSTR) &&
          EVAL(IsStringContained(pcszFullPath, *ppcszRootPathSuffix)));
}

#endif


/***************************** Exported Functions ****************************/


/******************************************************************************

@doc LINKINFOAPI

@func BOOL | GetCanonicalPathInfo | Retrieves information about the canonical
form of a path.

@parm PCSTR | pcszPath | A pointer to the path string whose canonical form
information is to be retrieved.

@parm PSTR | pszCanonicalBuf | A pointer to a buffer to be filled in with the
full canonical form of the path.  This buffer must be at least MAX_PATH_LEN
bytes long.

@parm PDWORD | pdwOutFlags | A pointer to a DWORD bit mask of flags to be
filled in with flags from the <t GETCANONICALPATHINFOOUTFLAGS> enumeration.

@parm PSTR | pszNetResourceNameBuf | A pointer to a buffer to be filled in with
the name of the net resource parent of the path.  This buffer must be at least
MAX_PATH_LEN bytes long.  This buffer is only filled in if GCPI_OFL_REMOTE is
set in *pdwOutFlags.

@parm PSTR * | ppszRootPathSuffix | A pointer to a PSTR to be filled in with a
pointer to the file system root path suffix, not including the leading slash,
of the canonical path in pszCanonicalBuf's buffer.

@rdesc If the function completed successfully, TRUE is returned.  Otherwise,
FALSE is returned.  The reason for failure may be determined by calling
GetLastError().

******************************************************************************/

LINKINFOAPI BOOL WINAPI GetCanonicalPathInfo(LPCTSTR pcszPath,
                                             LPTSTR pszCanonicalBuf,
                                             PDWORD pdwOutFlags,
                                             LPTSTR pszNetResourceNameBuf,
                                             LPTSTR *ppszRootPathSuffix)
{
   BOOL bResult;
   LPTSTR pszFileName;
   DWORD dwPathLen;

   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszCanonicalBuf, STR, MAX_PATH_LEN));
   ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));
   ASSERT(IS_VALID_WRITE_PTR(ppszRootPathSuffix, LPTSTR));

   dwPathLen = GetFullPathName(pcszPath, MAX_PATH_LEN, pszCanonicalBuf,
                               &pszFileName);

   if (dwPathLen > 0 && dwPathLen < MAX_PATH_LEN)
   {
      /*
       * Assume that GetFullPathName() changed all back slashes ('/') to
       * forward slashes ('\\').
       */

      ASSERT(! MyStrChr(pszCanonicalBuf, TEXT('/'), NULL));

      if (IsDrivePath(pszCanonicalBuf))
         bResult = GetDrivePathInfo(pszCanonicalBuf, pdwOutFlags,
                                    pszNetResourceNameBuf,
                                    ppszRootPathSuffix);
      else
         bResult = GetRemotePathInfo(pszCanonicalBuf, pdwOutFlags,
                                     pszNetResourceNameBuf,
                                     ppszRootPathSuffix);

      if (bResult)
         CanonicalizeTrailingSlash(*ppszRootPathSuffix);
   }
   else
   {
      ASSERT(! dwPathLen);

      WARNING_OUT((TEXT("GetFullPathName() failed on path %s, returning %lu."),
                   pcszPath,
                   dwPathLen));

      bResult = FALSE;
   }

   ASSERT(! bResult ||
          (CheckFullPathInfo(pszCanonicalBuf, pdwOutFlags,
                             pszNetResourceNameBuf, ppszRootPathSuffix) &&
           IsValidPathSuffix(*ppszRootPathSuffix)));

   return(bResult);
}

#ifdef UNICODE
LINKINFOAPI BOOL WINAPI GetCanonicalPathInfoA(LPCSTR pcszPath,
                                             LPSTR pszCanonicalBuf,
                                             PDWORD pdwOutFlags,
                                             LPSTR pszNetResourceNameBuf,
                                             LPSTR *ppszRootPathSuffix)
{
    LPWSTR  pcszWidePath;
    UINT    cchPath;
    WCHAR   szWideCanonicalBuf[MAX_PATH];
    WCHAR   szWideNetResourceNameBuf[MAX_PATH];
    LPWSTR  pszWideRootPathSuffix;
    UINT    chOffset;
    BOOL    fCanonical;

    cchPath = lstrlenA(pcszPath) + 1;

    pcszWidePath = (LPWSTR)_alloca(cchPath*SIZEOF(WCHAR));

    if ( MultiByteToWideChar( CP_ACP, 0,
                              pcszPath, cchPath,
                              pcszWidePath, cchPath) == 0)
    {
        return FALSE;
    }
    fCanonical = GetCanonicalPathInfo( pcszWidePath,
                                       szWideCanonicalBuf,
                                       pdwOutFlags,
                                       szWideNetResourceNameBuf,
                                       &pszWideRootPathSuffix );
    if ( fCanonical )
    {
        if ( WideCharToMultiByte( CP_ACP, 0,
                                  szWideCanonicalBuf, -1,
                                  pszCanonicalBuf, MAX_PATH,
                                  NULL, NULL ) == 0)
        {
            return FALSE;
        }
        if ( *pdwOutFlags & GCPI_OFL_REMOTE )
        {
            if ( WideCharToMultiByte( CP_ACP, 0,
                                      szWideNetResourceNameBuf, -1,
                                      pszNetResourceNameBuf, MAX_PATH,
                                      NULL, NULL ) == 0)
            {
                return FALSE;
            }
        }
        chOffset = pszWideRootPathSuffix - szWideCanonicalBuf;
        *ppszRootPathSuffix = pszCanonicalBuf;
        while ( chOffset-- )
        {
            *ppszRootPathSuffix = CharNextA(*ppszRootPathSuffix);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\cnrlink.h ===
/*
 * cnrlink.h - CNRLink ADT module description.
 */


/* Types
 ********/

typedef struct _cnrlink
{
   int nUnused;
}
CNRLINK;
DECLARE_STANDARD_TYPES(CNRLINK);

typedef enum _cnrflags
{
   CNR_FL_LOCAL      = 0x0001,

   ALL_CNR_FLAGS     = CNR_FL_LOCAL
}
CNRFLAGS;


/* Prototypes
 *************/

/* cnrlink.c */

extern BOOL CreateLocalCNRLink(LPCTSTR, PCNRLINK *, PUINT, LPTSTR, LPCTSTR *);
extern BOOL CreateRemoteCNRLink(LPCTSTR, LPCTSTR, PCNRLINK *, PUINT);
extern void DestroyCNRLink(PCNRLINK);
extern COMPARISONRESULT CompareCNRLinks(PCCNRLINK, PCCNRLINK);
extern BOOL IsLocalCNRLink(PCCNRLINK, PBOOL);
extern BOOL GetLocalPathFromCNRLink(PCCNRLINK, LPTSTR, PDWORD);
extern void GetRemotePathFromCNRLink(PCCNRLINK, LPTSTR);
extern BOOL ConnectToCNR(PCCNRLINK, DWORD, HWND, LPTSTR, PDWORD);
extern BOOL DisconnectFromCNR(PCCNRLINK);
extern BOOL IsCNRAvailable(PCCNRLINK);
extern UINT GetCNRLinkLen(PCCNRLINK);
extern BOOL GetCNRNetType(PCCNRLINK, PCDWORD *);
extern BOOL GetCNRName(PCCNRLINK, LPCSTR *);
extern BOOL GetLastRedirectedDevice(PCCNRLINK, LPCSTR *);
#ifdef UNICODE
extern BOOL GetCNRNameW(PCCNRLINK, LPCWSTR *);
extern BOOL GetLastRedirectedDeviceW(PCCNRLINK, LPCWSTR *);
#endif

#if defined(DEBUG) || defined (VSTF)

extern BOOL IsValidPCCNRLINK(PCCNRLINK);

#endif

#ifdef DEBUG

extern void DumpCNRLink(PCCNRLINK);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\dllinit.c ===
/*
 * dllinit.c - Initialization and termination routines.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "..\core\init.h"
#include "server.h"
#include "cnrlink.h"


/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL MyAttachProcess(HMODULE);
PRIVATE_CODE BOOL MyDetachProcess(HMODULE);


/* Global Variables
 *******************/

#pragma data_seg(DATA_SEG_READ_ONLY)

/* serialization control structure */

PUBLIC_DATA CSERIALCONTROL g_cserctrl =
{
   MyAttachProcess,
   MyDetachProcess,
   NULL,
   NULL
};

#pragma data_seg()

#ifdef DEBUG

#pragma data_seg(DATA_SEG_READ_ONLY)

/* .ini file name and section used by inifile.c!SetIniSwitches() */

PUBLIC_DATA LPCTSTR GpcszIniFile = TEXT("rover.ini");
PUBLIC_DATA LPCTSTR GpcszIniSection = TEXT("LinkInfoDebugOptions");

/* module name used by debug.c!SpewOut() */

PUBLIC_DATA LPCTSTR GpcszSpewModule = TEXT("LinkInfo");

#pragma data_seg()

#endif


/***************************** Private Functions *****************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** MyAttachProcess()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL MyAttachProcess(HMODULE hmod)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   DebugEntry(MyAttachProcess);

   bResult = ProcessInitServerModule();

   DebugExitBOOL(MyAttachProcess, bResult);

   return(bResult);
}


/*
** MyDetachProcess()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL MyDetachProcess(HMODULE hmod)
{
   BOOL bResult = TRUE;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   DebugEntry(MyDetachProcess);

   ProcessExitServerModule();

   DebugExitBOOL(MyDetachProcess, bResult);

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/****************************** Public Functions *****************************/


#ifdef DEBUG

/*
** SetAllIniSwitches()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SetAllIniSwitches(void)
{
   BOOL bResult;

   bResult = SetDebugModuleIniSwitches();
   bResult |= SetSerialModuleIniSwitches();
   bResult |= SetMemoryManagerModuleIniSwitches();

   return(bResult);
}

#endif


/*
** InitializeDLL()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InitializeDLL(void)
{
   BOOL bResult;

   DebugEntry(InitializeDLL);

   bResult = InitMemoryManagerModule();

#ifdef DEBUG

   SpewHeapSummary(0);

#endif

   DebugExitBOOL(InitializeDLL, bResult);

   return(bResult);
}


/*
** TerminateDLL()
**
** 
**
** Arguments:
**
** Returns:       TRUE
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL TerminateDLL(void)
{
   BOOL bResult;

   DebugEntry(TerminateDLL);

   ExitMemoryManagerModule();

   bResult = TRUE;

   DebugExitBOOL(TerminateDLL, bResult);

   return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\cnrlink.c ===
/*
 * cnrlink.c - CNRLink ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "cnrlink.h"
#include "server.h"


/* Constants
 ************/

/* WNetUseConnection() flag combinations */

#define ALL_CONNECT_IN_FLAGS     (CONNECT_UPDATE_PROFILE |\
                                  CONNECT_UPDATE_RECENT |\
                                  CONNECT_TEMPORARY |\
                                  CONNECT_INTERACTIVE |\
                                  CONNECT_PROMPT |\
                                  CONNECT_REDIRECT)

#define ALL_CONNECT_OUT_FLAGS    (CONNECT_REFCOUNT |\
                                  CONNECT_LOCALDRIVE)


/* Macros
 *********/

/* macros for accessing ICNRLINK data */

#define ICNRL_Remote_Name_PtrA(picnrl) \
   ((LPSTR)(((PBYTE)(picnrl)) + (picnrl)->ucbNetNameOffset))

#define ICNRL_Device_PtrA(picnrl) \
   ((LPSTR)(((PBYTE)(picnrl)) + (picnrl)->ucbDeviceOffset))

#define ICNRL_Remote_Name_PtrW(picnrl) \
   ((LPWSTR)(((PBYTE)(picnrl)) + (picnrl)->ucbNetNameOffsetW))

#define ICNRL_Device_PtrW(picnrl) \
   ((LPWSTR)(((PBYTE)(picnrl)) + (picnrl)->ucbDeviceOffsetW))

#define IS_ICNRL_ANSI(picnrl) \
   ((PBYTE)(picnrl) + ((PICNRLINKW)(picnrl))->ucbNetNameOffset) == (PBYTE)&(((PICNRLINKW)(picnrl))->ucbNetNameOffsetW)

#ifdef UNICODE
#define ICNRL_Remote_Name_Ptr(picnrl)   ICNRL_Remote_Name_PtrW(picnrl)
#define ICNRL_Device_Ptr(picnrl)        ICNRL_Device_PtrW(picnrl)
#else
#define ICNRL_Remote_Name_Ptr(picnrl)   ICNRL_Remote_Name_PtrA(picnrl)
#define ICNRL_Device_Ptr(picnrl)        ICNRL_Device_PtrA(picnrl)
#endif

/* Types
 ********/

/*
   @doc INTERNAL

   @enum ICNRLINKFLAGS | Internal CNRLink structure flags.
*/

typedef enum _icnrlinkflags
{
   /*
      @emem ICNRL_FL_VALID_DEVICE | If set, last redirected drive is valid.  If
      clear, last redirected drive is not valid.
   */

   ICNRL_FL_VALID_DEVICE = 0x0001,

   /*
      @emem ICNRL_FL_VALID_NET_TYPE | If set, net type is valid.  If clear, net
      type is not valid.
   */

   ICNRL_FL_VALID_NET_TYPE = 0x0002,

   /* @emem ALL_ICNRL_FLAGS | All internal CNRLink structure flags. */

   ALL_ICNRL_FLAGS = (ICNRL_FL_VALID_DEVICE |
                      ICNRL_FL_VALID_NET_TYPE)
}
ICNRLINKFLAGS;

/*
   @doc INTERNAL

   @struct ICNRLINK | Internal definition of relocatable connectable network
   resource (CNR) link structure.  An <t ILINKINFO> structure may contain an
   ICNRLINK structure.  An ICNRLINK structure consists of a header described as
   below, followed by variable-length data.
*/

typedef struct _icnrlinkA
{
   /*
      @field UINT | ucbSize | Length of ICNRLINK structure in bytes, including
      ucbSize field.
   */

   UINT ucbSize;

   /*
      @field DWORD | dwFlags | A bit mask of flags from the <t ICNRLINKFLAGS>
      enumeration.
   */

   DWORD dwFlags;

   /*
      @field UINT | ucbNetNameOffset | Offset in bytes of CNR name string from
      base of structure.  The CNR name string may be passed to
      WNetUseConnection() to add a connection to the CNR.<nl>
      Example CNRLink name string: "\\\\fredbird\\work".
   */

   UINT ucbNetNameOffset;

   /*
      @field UINT | ucbDeviceOffset | Offset in bytes of last redirected local
      device string from base of structure.  This field is only valid if
      ICNRL_FL_VALID_DEVICE is set in dwFlags.  The last redirected local
      device string may be passed to WNetUseConnection() to add a redirected
      device connection to the CNR.<nl>
      Example last redirected local device string: "D:".
   */

   UINT ucbDeviceOffset;

   /*
      @field DWORD | dwNetType | The network type as returned in a
      NETINFOSTRUCT.  This field is only valid if ICNRL_FL_VALID_NET_TYPE is
      set in dwFlags.  The net type is used to retrieve the host net resource's
      host NP's name to use in calling WNetUseConnection().<nl>
      Example net type: WNNC_NET_NETWARE.
   */

   DWORD dwNetType;
}
ICNRLINKA;
DECLARE_STANDARD_TYPES(ICNRLINKA);

#ifdef UNICODE
typedef struct _icnrlinkW
{
   /*
      @field UINT | ucbSize | Length of ICNRLINK structure in bytes, including
      ucbSize field.
   */

   UINT ucbSize;

   /*
      @field DWORD | dwFlags | A bit mask of flags from the <t ICNRLINKFLAGS>
      enumeration.
   */

   DWORD dwFlags;

   /*
      @field UINT | ucbNetNameOffset | Offset in bytes of CNR name string from
      base of structure.  The CNR name string may be passed to
      WNetUseConnection() to add a connection to the CNR.<nl>
      Example CNRLink name string: "\\\\fredbird\\work".
   */

   UINT ucbNetNameOffset;

   /*
      @field UINT | ucbDeviceOffset | Offset in bytes of last redirected local
      device string from base of structure.  This field is only valid if
      ICNRL_FL_VALID_DEVICE is set in dwFlags.  The last redirected local
      device string may be passed to WNetUseConnection() to add a redirected
      device connection to the CNR.<nl>
      Example last redirected local device string: "D:".
   */

   UINT ucbDeviceOffset;

   /*
      @field DWORD | dwNetType | The network type as returned in a
      NETINFOSTRUCT.  This field is only valid if ICNRL_FL_VALID_NET_TYPE is
      set in dwFlags.  The net type is used to retrieve the host net resource's
      host NP's name to use in calling WNetUseConnection().<nl>
      Example net type: WNNC_NET_NETWARE.
   */

   DWORD dwNetType;

   /*
      These members are for storing the unicode version of the strings
   */
   UINT ucbNetNameOffsetW;
   UINT ucbDeviceOffsetW;
}
ICNRLINKW;
DECLARE_STANDARD_TYPES(ICNRLINKW);
#endif

#ifdef UNICODE
#define ICNRLINK    ICNRLINKW
#define PICNRLINK   PICNRLINKW
#define CICNRLINK   CICNRLINKW
#define PCICNRLINK  PCICNRLINKW
#else
#define ICNRLINK    ICNRLINKA
#define PICNRLINK   PICNRLINKA
#define CICNRLINK   CICNRLINKA
#define PCICNRLINK  PCICNRLINKA
#endif

/* Exported from MPR.DLL, but not in winnetwk.h
*/
#ifdef UNICODE
DWORD APIENTRY WNetGetResourceInformationW (LPNETRESOURCE lpNetResource, LPVOID lpBuffer, LPDWORD cbBuffer, LPTSTR * lplpSystem);
#define WNetGetResourceInformation WNetGetResourceInformationW
#else
DWORD APIENTRY WNetGetResourceInformationA (LPNETRESOURCE lpNetResource, LPVOID lpBuffer, LPDWORD cbBuffer, LPTSTR * lplpSystem);
#define WNetGetResourceInformation WNetGetResourceInformationA
#endif


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL GetNetPathFromLocalPath(LPCTSTR, LPTSTR, LPCTSTR *, PBOOL, PDWORD);
PRIVATE_CODE BOOL UnifyICNRLinkInfo(LPCTSTR, DWORD, LPCTSTR, DWORD, PICNRLINK *, PUINT);
PRIVATE_CODE BOOL GetNetType(LPCTSTR, PDWORD);
PRIVATE_CODE BOOL GetNetProviderName(PCICNRLINK, LPTSTR);
PRIVATE_CODE COMPARISONRESULT CompareNetNames(LPCTSTR, LPCTSTR);
PRIVATE_CODE BOOL SearchForRedirectedConnection(PCICNRLINK, LPTSTR);

#if defined(DEBUG) || defined (VSTF)

PRIVATE_CODE BOOL IsValidDevice(LPCTSTR);
PRIVATE_CODE BOOL IsValidNetType(DWORD);
PRIVATE_CODE BOOL IsValidPCICNRLINK(PCICNRLINK);

#endif

#if defined(DEBUG)

PRIVATE_CODE BOOL IsValidNetProviderName(LPCTSTR);

#endif

#if 0 //#ifndef 

DWORD APIENTRY
WNetGetNetworkInformationW(
    LPCWSTR          lpProvider,
    LPNETINFOSTRUCT   lpNetInfoStruct
    )
{
#if 0
    if (wcsicmp(lpProvider, L"Microsoft Windows Network") == 0)
    {
        lpNetInfoStruct->wNetType = (WORD)WNNC_NET_LANMAN;
        return ERROR_SUCCESS;
    }
    else if (wcsicmp(lpProvider, L"Novell Network") == 0)
    {
        lpNetInfoStruct->wNetType = (WORD)WNNC_NET_NETWARE;
        return ERROR_SUCCESS;
    }
    else
#endif
    {
        return ERROR_NOT_SUPPORTED;
    }
}
#endif

/*
** GetNetPathFromLocalPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GetNetPathFromLocalPath(LPCTSTR pcszLocalPath,
                                          LPTSTR pszNetNameBuf,
                                          LPCTSTR *ppcszCommonPathSuffix,
                                          PBOOL pbIsShared, PDWORD pdwNetType)
{
   BOOL bResult = TRUE;
   PCSERVERVTABLE pcsvt;

   ASSERT(IsDrivePath(pcszLocalPath));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszNetNameBuf, STR, MAX_PATH_LEN));
   ASSERT(IS_VALID_WRITE_PTR(ppcszCommonPathSuffix, LPCTSTR));
   ASSERT(IS_VALID_WRITE_PTR(pbIsShared, BOOL));
   ASSERT(IS_VALID_WRITE_PTR(pdwNetType, DWORD));

   *pbIsShared = FALSE;

   if (GetServerVTable(&pcsvt))
   {
      TCHAR rgchSharedPath[MAX_PATH_LEN];

      ASSERT(lstrlen(pcszLocalPath) < ARRAYSIZE(rgchSharedPath));
      lstrcpy(rgchSharedPath, pcszLocalPath);

      FOREVER
      {
         if ((pcsvt->GetNetResourceFromLocalPath)(rgchSharedPath,
                                                  pszNetNameBuf, MAX_PATH_LEN,
                                                  pdwNetType))
         {
            ASSERT(lstrlen(pszNetNameBuf) < MAX_PATH_LEN);

            /* Determine common path suffix. */

            *ppcszCommonPathSuffix = pcszLocalPath + lstrlen(rgchSharedPath);

            /* Skip any leading slash. */

            if (IS_SLASH(**ppcszCommonPathSuffix))
               *ppcszCommonPathSuffix = CharNext(*ppcszCommonPathSuffix);

            ASSERT(! IS_SLASH(**ppcszCommonPathSuffix));

            *pbIsShared = TRUE;

            break;
         }
         else
         {
            if (! DeleteLastDrivePathElement(rgchSharedPath))
               break;
         }
      }
   }

   ASSERT(! bResult ||
          ! *pbIsShared ||
          (EVAL(IsUNCPath(pszNetNameBuf)) &&
           IS_VALID_STRING_PTR(*ppcszCommonPathSuffix, CSTR) &&
           EVAL(*ppcszCommonPathSuffix >= pcszLocalPath) &&
           EVAL(IsStringContained(pcszLocalPath, *ppcszCommonPathSuffix)) &&
           EVAL(IsValidNetType(*pdwNetType))));

   return(bResult);
}


/*
** UnifyICNRLinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL UnifyICNRLinkInfo(LPCTSTR pcszNetName, DWORD dwFlags,
                                    LPCTSTR pcszDevice, DWORD dwNetType,
                                    PICNRLINK *ppicnrl, PUINT pucbICNRLinkLen)
{
   BOOL bResult;
   UINT ucbDataOffset;
#ifdef UNICODE
   BOOL bUnicode;
   UINT cchChars;
   CHAR szAnsiNetName[MAX_PATH];
   CHAR szAnsiDevice[MAX_PATH];
   UINT cbAnsiNetName;
   UINT cbWideNetName;
   UINT cbAnsiDevice;
   UINT cbWideDevice;
   UINT cbChars;
#endif

   ASSERT(IsUNCPath(pcszNetName));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_ICNRL_FLAGS));
   ASSERT(IS_FLAG_CLEAR(dwFlags, ICNRL_FL_VALID_DEVICE) ||
          IsValidDevice(pcszDevice));
   ASSERT(IS_FLAG_CLEAR(dwFlags, ICNRL_FL_VALID_NET_TYPE) ||
          IsValidNetType(dwNetType));
   ASSERT(IS_VALID_WRITE_PTR(ppicnrl, PCNRLINK));
   ASSERT(IS_VALID_WRITE_PTR(pucbICNRLinkLen, UINT));

#ifdef UNICODE
   bUnicode = FALSE;

   cbAnsiNetName = WideCharToMultiByte(CP_ACP, 0,
                                       pcszNetName, -1,
                                       szAnsiNetName, MAX_PATH,
                                       0, 0);
   if ( cbAnsiNetName == 0 )
   {
      bUnicode = FALSE;
   }
   else
   {
      WCHAR szWideNetName[MAX_PATH];

      cbChars = MultiByteToWideChar(CP_ACP, 0,
                                    szAnsiNetName, -1,
                                    szWideNetName, MAX_PATH);
      if ( cbChars == 0 || lstrcmp(pcszNetName,szWideNetName) != 0 )
      {
         bUnicode = TRUE;
      }
   }

   if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_DEVICE))
   {
      cbAnsiDevice = WideCharToMultiByte(CP_ACP, 0,
                                         pcszDevice, -1,
                                         szAnsiDevice, MAX_PATH,
                                         0, 0);
      if ( cbAnsiDevice == 0 )
      {
         bUnicode = FALSE;
      }
      else
      {
         WCHAR szWideDevice[MAX_PATH];

         cchChars = MultiByteToWideChar(CP_ACP, 0,
                                        szAnsiDevice, -1,
                                        szWideDevice, MAX_PATH);
         if ( cchChars == 0 || lstrcmp(pcszDevice,szWideDevice) != 0 )
         {
            bUnicode = TRUE;
         }
      }
   }
   else
   {
      cbAnsiDevice = 0;
   }

   if ( bUnicode )
   {
      ucbDataOffset = SIZEOF(ICNRLINKW);

      /* (+ 1) for null terminator. */
      cbWideNetName = (lstrlen(pcszNetName) + 1) * sizeof(TCHAR);

      if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_DEVICE))
         cbWideDevice = (lstrlen(pcszDevice) + 1) * sizeof(TCHAR);
      else
         cbWideDevice = 0;

   }
   else
   {
      ucbDataOffset = SIZEOF(ICNRLINKA);

      cbWideNetName = 0;
      cbWideDevice  = 0;
   }

   *pucbICNRLinkLen = ucbDataOffset +
                      cbAnsiNetName +
                      cbAnsiDevice;
   if ( bUnicode )
   {
       *pucbICNRLinkLen = ALIGN_WORD_CNT(*pucbICNRLinkLen) +
                          cbWideNetName +
                          cbWideDevice;
   }

#else

   /* Assume we won't overflow *pucbICNRLinkLen here. */

   /* (+ 1) for null terminator. */

   *pucbICNRLinkLen = SIZEOF(**ppicnrl) +
                      (lstrlen(pcszNetName) + 1) * SIZEOF(TCHAR);

   if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_DEVICE))
      /* (+ 1) for null terminator. */
      *pucbICNRLinkLen += (lstrlen(pcszDevice) + 1) * SIZEOF(TCHAR);

   ucbDataOffset = SIZEOF(ICNRLINKA);
#endif

   bResult = AllocateMemory(*pucbICNRLinkLen, ppicnrl);

   if (bResult)
   {
      (*ppicnrl)->ucbSize = *pucbICNRLinkLen;
      (*ppicnrl)->dwFlags = dwFlags;

      if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_NET_TYPE))
         (*ppicnrl)->dwNetType = dwNetType;
      else
         (*ppicnrl)->dwNetType = 0;

      /* Append remote name. */

      (*ppicnrl)->ucbNetNameOffset = ucbDataOffset;

#ifdef UNICODE
      lstrcpyA(ICNRL_Remote_Name_PtrA(*ppicnrl), szAnsiNetName);
      ucbDataOffset += cbAnsiNetName;

      if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_DEVICE))
      {
         /* Append device name. */

         (*ppicnrl)->ucbDeviceOffset = ucbDataOffset;
         lstrcpyA(ICNRL_Device_PtrA(*ppicnrl), szAnsiDevice);

         ucbDataOffset += cbAnsiDevice;
      }
      else
      {
         (*ppicnrl)->ucbDeviceOffset = 0;
      }

      if ( bUnicode )
      {
         ucbDataOffset = ALIGN_WORD_CNT(ucbDataOffset);

         (*ppicnrl)->ucbNetNameOffsetW = ucbDataOffset;

         lstrcpy(ICNRL_Remote_Name_PtrW(*ppicnrl), pcszNetName);
         ucbDataOffset += cbWideNetName;

         if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_DEVICE))
         {
            /* Append device name. */

            (*ppicnrl)->ucbDeviceOffsetW = ucbDataOffset;
            lstrcpy(ICNRL_Device_Ptr(*ppicnrl), pcszDevice);

            /* (+ 1) for null terminator. */
            ucbDataOffset += cbWideDevice;
         }
         else
         {
            (*ppicnrl)->ucbDeviceOffsetW = 0;
         }

      }
#else
      lstrcpy(ICNRL_Remote_Name_Ptr(*ppicnrl), pcszNetName);
      /* (+ 1) for null terminator. */
      ucbDataOffset += lstrlen(pcszNetName) + 1;

      if (IS_FLAG_SET(dwFlags, ICNRL_FL_VALID_DEVICE))
      {
         /* Append device name. */

         (*ppicnrl)->ucbDeviceOffset = ucbDataOffset;
         lstrcpy(ICNRL_Device_Ptr(*ppicnrl), pcszDevice);
#ifdef DEBUG
         /* (+ 1) for null terminator. */
         ucbDataOffset += (lstrlen(pcszDevice) + 1) * SIZEOF(TCHAR);
#endif
      }
      else
         (*ppicnrl)->ucbDeviceOffset = 0;
#endif

      /* Do all the calculated lengths match? */

      ASSERT(ucbDataOffset == (*ppicnrl)->ucbSize);
      ASSERT(ucbDataOffset == *pucbICNRLinkLen);
   }

   ASSERT(! bResult ||
          (IS_VALID_STRUCT_PTR(*ppicnrl, CICNRLINK) &&
           EVAL(*pucbICNRLinkLen == GetCNRLinkLen((PCCNRLINK)*ppicnrl))));

   return(bResult);
}


/*
** GetNetType()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GetNetType(LPCTSTR pcszCNRName, PDWORD pdwNetType)
{
   BOOL bResult = FALSE;
   NETRESOURCE nrIn;
   NETRESOURCEBUF nrbufOut;
   DWORD dwcbBufLen = SIZEOF(nrbufOut);
   LPTSTR pszFileSysPath;
   DWORD dwNetResult;
#ifdef DEBUG
   DWORD dwcmsTicks;
#endif

   ASSERT(IsValidCNRName(pcszCNRName));
   ASSERT(IS_VALID_WRITE_PTR(pdwNetType, DWORD));

   /* RAIDRAID: (15691) We only support disk resource connections here. */

   ZeroMemory(&nrIn, SIZEOF(nrIn));
   nrIn.lpRemoteName = (LPTSTR)pcszCNRName;
   nrIn.dwType = RESOURCETYPE_DISK;

#ifdef DEBUG
   dwcmsTicks = GetTickCount();
#endif

   dwNetResult = WNetGetResourceInformation(&nrIn, &(nrbufOut.rgbyte),
                                            &dwcbBufLen, &pszFileSysPath);

#ifdef DEBUG

   dwcmsTicks = GetTickCount() - dwcmsTicks;

   TRACE_OUT((TEXT("GetRemotePathInfo(): WNetGetResourceInformation() on net resource %s took %lu.%03lu seconds."),
              pcszCNRName,
              (dwcmsTicks / 1000),
              (dwcmsTicks % 1000)));

#endif

   if (dwNetResult == ERROR_SUCCESS)
   {
      if (nrbufOut.nr.lpProvider)
      {
         NETINFOSTRUCT nis;

         ASSERT(IS_VALID_STRING_PTR(nrbufOut.nr.lpProvider, STR));

         nis.cbStructure = SIZEOF(nis);

         dwNetResult = WNetGetNetworkInformation(nrbufOut.nr.lpProvider, &nis);

         if (dwNetResult == ERROR_SUCCESS)
         {
            *pdwNetType = ((nis.wNetType) << 16);
            bResult = TRUE;

            TRACE_OUT((TEXT("GetNetType(): Net type for CNR %s is %#08lx."),
                       pcszCNRName,
                       *pdwNetType));
         }
         else
            WARNING_OUT((TEXT("GetNetType(): WNetGetNetworkInformation() failed for %s NP, returning %lu."),
                         nrbufOut.nr.lpProvider,
                         dwNetResult));
      }
      else
         WARNING_OUT((TEXT("GetNetType(): WNetGetResourceInformation() was unable to determine the NP for CNR %s."),
                      pcszCNRName));
   }
   else
      WARNING_OUT((TEXT("GetNetType(): WNetGetResourceInformation() failed for CNR %s, returning %lu."),
                   pcszCNRName,
                   dwNetResult));

   ASSERT(! bResult ||
          IsValidNetType(*pdwNetType));

   return(bResult);
}


/*
** GetNetProviderName()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GetNetProviderName(PCICNRLINK pcicnrl, LPTSTR pszNPNameBuf)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(pcicnrl, CICNRLINK));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszNPNameBuf, STR, MAX_PATH_LEN));

   if (IS_FLAG_SET(pcicnrl->dwFlags, ICNRL_FL_VALID_NET_TYPE))
   {
      DWORD dwcbNPNameBufLen;
      DWORD dwNetResult;

      dwcbNPNameBufLen = MAX_PATH_LEN;

      dwNetResult = WNetGetProviderName(pcicnrl->dwNetType, pszNPNameBuf,
                                        &dwcbNPNameBufLen);

      if (dwNetResult == ERROR_SUCCESS)
      {
         bResult = TRUE;

         TRACE_OUT((TEXT("GetNetProviderName(): NP for CNR %s is %s."),
                    ICNRL_Remote_Name_Ptr(pcicnrl),
                    pszNPNameBuf));
      }
      else
         WARNING_OUT((TEXT("GetNetProviderName(): WNetGetProviderName() failed for CNR %s's net type %#08lx, returning %lu."),
                      TEXT("<Remote Name>"), // ICNRL_Remote_Name_Ptr(pcicnrl),
                      pcicnrl->dwNetType,
                      dwNetResult));
   }
   else
      WARNING_OUT((TEXT("GetNetProviderName(): Net type for CNR %s is not known.  Unable to determine NP name."),
                   TEXT("<Remote Name>"))); // ICNRL_Remote_Name_Ptr(pcicnrl)));

   ASSERT(! bResult ||
          IsValidNetProviderName(pszNPNameBuf));

   return(bResult);
}


/*
** CompareNetNames()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE COMPARISONRESULT CompareNetNames(LPCTSTR pcszFirstNetName,
                                              LPCTSTR pcszSecondNetName)
{
   ASSERT(IS_VALID_STRING_PTR(pcszFirstNetName, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszSecondNetName, CSTR));

   return(MapIntToComparisonResult(lstrcmp(pcszFirstNetName,
                                           pcszSecondNetName)));
}


/*
** SearchForRedirectedConnection()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL SearchForRedirectedConnection(PCICNRLINK pcicnrl,
                                                LPTSTR pszRootPathBuf)
{
   BOOL bResult = FALSE;
   HANDLE henum;
   DWORD dwNetResult;

   ASSERT(IS_VALID_STRUCT_PTR(pcicnrl, CICNRLINK));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRootPathBuf, STR, MAX_PATH_LEN));

#ifdef DEBUG
#ifdef UNICODE
   {
       LPWSTR pszWideNetName;
       WCHAR szWideNetName[MAX_PATH];

       if (IS_ICNRL_ANSI(pcicnrl))
       {
           pszWideNetName = szWideNetName;

           MultiByteToWideChar(CP_ACP, 0,
                               ICNRL_Remote_Name_PtrA(pcicnrl), -1,
                               szWideNetName, MAX_PATH);
       } else {
           pszWideNetName = ICNRL_Remote_Name_PtrW(pcicnrl);
       }

       WARNING_OUT((TEXT("SearchForRedirectedConnection(): Enumerating local connections searching for redirected connection to CNR \"%s\"."),
                pszWideNetName));
    }
#else
    WARNING_OUT((TEXT("SearchForRedirectedConnection(): Enumerating local connections searching for redirected connection to CNR \"%s\"."),
                ICNRL_Remote_Name_Ptr(pcicnrl)));
#endif
#endif

   /* RAIDRAID: (15691) We only support container resources here. */

   dwNetResult = WNetOpenEnum(RESOURCE_CONNECTED, RESOURCETYPE_DISK,
                              RESOURCEUSAGE_CONTAINER | RESOURCEUSAGE_ATTACHED,
                              NULL, &henum);

   if (dwNetResult == WN_SUCCESS)
   {
      DWORD dwc = 1;
      NETRESOURCEBUF nrbuf;
      DWORD dwcbBufLen = SIZEOF(nrbuf);

      while ((dwNetResult = WNetEnumResource(henum, &dwc, &(nrbuf.rgbyte),
                                             &dwcbBufLen))
             == WN_SUCCESS)
      {
         /* Is this a redirected connection? */

         if (nrbuf.nr.lpRemoteName != NULL)
         {
            if (nrbuf.nr.lpLocalName != NULL)
            {
               /* Yes.  Is it a redirected connection to the desired CNR? */

#ifdef UNICODE
               WCHAR szWideNetName[MAX_PATH];
               LPWSTR pszWideNetName;

               if (IS_ICNRL_ANSI(pcicnrl))
               {
                  pszWideNetName = szWideNetName;
                  MultiByteToWideChar(CP_ACP, 0,
                                      ICNRL_Remote_Name_PtrA(pcicnrl), -1,
                                      szWideNetName, MAX_PATH);
               }
               else
               {
                  pszWideNetName = ICNRL_Remote_Name_Ptr(pcicnrl);
               }
               if (CompareNetNames(pszWideNetName,
                                   nrbuf.nr.lpRemoteName)
                   == CR_EQUAL)
#else
               if (CompareNetNames(ICNRL_Remote_Name_Ptr(pcicnrl),
                                   nrbuf.nr.lpRemoteName)
                   == CR_EQUAL)
#endif
               {
                  /* Yes. */

                  ASSERT(lstrlen(nrbuf.nr.lpLocalName) < MAX_PATH_LEN);

                  lstrcpy(pszRootPathBuf, nrbuf.nr.lpLocalName);
                  bResult = TRUE;

                  TRACE_OUT((TEXT("SearchForRedirectedConnection(): Found CNR \"%s\" connected to %s."),
                             nrbuf.nr.lpRemoteName,
                             pszRootPathBuf));

                  break;
               }
               else
                  /* No. */
                  TRACE_OUT((TEXT("SearchForRedirectedConnection(): Skipping unmatched enumerated connection to CNR \"%s\" on %s."),
                             nrbuf.nr.lpRemoteName,
                             nrbuf.nr.lpLocalName));
            }
            else
               /* No. */
               TRACE_OUT((TEXT("SearchForRedirectedConnection(): Skipping enumerated deviceless connection to CNR \"%s\"."),
                          nrbuf.nr.lpRemoteName));
         }
         else
            WARNING_OUT((TEXT("SearchForRedirectedConnection(): Skipping enumerated connection with no CNR name.")));
      }

      if (! bResult && dwNetResult != WN_NO_MORE_ENTRIES)
         WARNING_OUT((TEXT("SearchForRedirectedConnection(): WNetEnumResource() failed, returning %lu."),
                      dwNetResult));

      dwNetResult = WNetCloseEnum(henum);

      if (dwNetResult != WN_SUCCESS)
         WARNING_OUT((TEXT("SearchForRedirectedConnection(): WNetCloseEnum() failed, returning %lu."),
                      dwNetResult));
   }
   else
      WARNING_OUT((TEXT("SearchForRedirectedConnection(): WNetOpenEnum() failed, returning %lu."),
                   dwNetResult));

   return(bResult);
}


#if defined(DEBUG) || defined (VSTF)

/*
** IsValidDevice()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidDevice(LPCTSTR pcszDevice)
{
   /* Any valid string < MAX_PATH_LEN bytes long is a valid device name. */

   return(IS_VALID_STRING_PTR(pcszDevice, CSTR) &&
          EVAL(lstrlen(pcszDevice) < MAX_PATH_LEN));
}


/*
** IsValidNetType()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidNetType(DWORD dwNetType)
{
   BOOL bResult;

   switch (dwNetType & 0xffff0000)
   {
      case WNNC_NET_MSNET:
      case WNNC_NET_VINES:
      case WNNC_NET_10NET:
      case WNNC_NET_LOCUS:
      case WNNC_NET_SUN_PC_NFS:
      case WNNC_NET_LANSTEP:
      case WNNC_NET_9TILES:
      case WNNC_NET_LANTASTIC:
      case WNNC_NET_AS400:
      case WNNC_NET_FTP_NFS:
      case WNNC_NET_PATHWORKS:
      case WNNC_NET_LIFENET:
      case WNNC_NET_POWERLAN:
      case WNNC_NET_BWNFS:
      case WNNC_NET_COGENT:
      case WNNC_NET_FARALLON:
      case WNNC_NET_APPLETALK:
         WARNING_OUT((TEXT("IsValidNetType(): Unexpected net type %#08lx is neither NetWare nor LANMan."),
                      dwNetType));
         /* Fall through... */

      case WNNC_NET_LANMAN:
      case WNNC_NET_NETWARE:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidNetType(): Invalid net type %#08lx."),
                    dwNetType));
         break;
   }

   if (dwNetType & 0x0000ffff)
      WARNING_OUT((TEXT("IsValidNetType(): Low word of net type %#08lx is non-zero."),
                   dwNetType));

   return(bResult);
}


/*
** IsValidPCICNRLINK()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCICNRLINK(PCICNRLINK pcicnrl)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pcicnrl, CICNRLINK) &&
       IS_VALID_READ_BUFFER_PTR(pcicnrl, CICNRLINK, pcicnrl->ucbSize) &&
       FLAGS_ARE_VALID(pcicnrl->dwFlags, ALL_ICNRL_FLAGS) &&
       EVAL(IsValidCNRName(ICNRL_Remote_Name_Ptr(pcicnrl))) &&
       EVAL(IsContained(pcicnrl, pcicnrl->ucbSize,
                        ICNRL_Remote_Name_PtrA(pcicnrl),
                        lstrlenA(ICNRL_Remote_Name_PtrA(pcicnrl)))) &&
       (IS_FLAG_CLEAR(pcicnrl->dwFlags, ICNRL_FL_VALID_NET_TYPE) ||
        EVAL(IsValidNetType(pcicnrl->dwNetType))))
   {
      if (IS_FLAG_CLEAR(pcicnrl->dwFlags, ICNRL_FL_VALID_DEVICE))
      {
         ASSERT(! pcicnrl->ucbDeviceOffset);
         bResult = TRUE;
      }
      else
         bResult = (EVAL(IsValidDevice(ICNRL_Device_Ptr(pcicnrl))) &&
                    EVAL(IsContained(pcicnrl, pcicnrl->ucbSize,
                                     ICNRL_Device_PtrA(pcicnrl),
                                     lstrlenA(ICNRL_Device_PtrA(pcicnrl)))));
   }
   else
      bResult = FALSE;

   return(bResult);
}

#endif


#if defined(DEBUG)

/*
** IsValidNetProviderName()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidNetProviderName(LPCTSTR pcszNetProvider)
{
   /* Any string < MAX_PATH_LEN characters long is a valid NP name. */

   return(IS_VALID_STRING_PTR(pcszNetProvider, CSTR) &&
          lstrlen(pcszNetProvider) < MAX_PATH_LEN);
}

#endif


/****************************** Public Functions *****************************/


/*
** CreateLocalCNRLink()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** If TRUE is returned:
**    1) *ppcnrl is only valid if *pucbCNRLinkLen > 0.
**    2) pszLocalBasePathBuf is valid.
**    3) *ppcszCommonPathSuffix is valid.
**
** If *pucbCNRLinkLen == 0, pszLocalBasePathBuf is a copy of pcszLocalPath, and
** *ppcszCommonPathSuffix points at the null terminator of pcszLocalPath.
**
** If *pucbCNRLinkLen > 0, pszLocalBasePathBuf is the closest shared local base
** path, and *ppcszCommonPathSuffix points at that path's suffix in
** pcszLocalPath.
*/
PUBLIC_CODE BOOL CreateLocalCNRLink(LPCTSTR pcszLocalPath, PCNRLINK *ppcnrl,
                                    PUINT pucbCNRLinkLen,
                                    LPTSTR pszLocalBasePathBuf,
                                    LPCTSTR *ppcszCommonPathSuffix)
{
   BOOL bResult;
   TCHAR rgchNetName[MAX_PATH_LEN];
   BOOL bShared;
   DWORD dwNetType;

   ASSERT(IsDrivePath(pcszLocalPath));
   ASSERT(IS_VALID_WRITE_PTR(ppcnrl, PCNRLINK));
   ASSERT(IS_VALID_WRITE_PTR(pucbCNRLinkLen, UINT));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszLocalBasePathBuf, STR, MAX_PATH_LEN));
   ASSERT(IS_VALID_WRITE_PTR(ppcszCommonPathSuffix, LPCTSTR));

   bResult = GetNetPathFromLocalPath(pcszLocalPath, rgchNetName,
                                     ppcszCommonPathSuffix, &bShared,
                                     &dwNetType);

   if (bResult)
   {
      if (bShared)
      {
         bResult = UnifyICNRLinkInfo(rgchNetName, ICNRL_FL_VALID_NET_TYPE,
                                     NULL, dwNetType, (PICNRLINK *)ppcnrl,
                                     pucbCNRLinkLen);

         if (bResult)
         {
            UINT ucbLocalBasePathLen;

            /* Copy local base path into output buffer. */

            ASSERT(*ppcszCommonPathSuffix >= pcszLocalPath);
            ucbLocalBasePathLen = *ppcszCommonPathSuffix - pcszLocalPath;

            CopyMemory(pszLocalBasePathBuf, pcszLocalPath, ucbLocalBasePathLen * sizeof(TCHAR));
            pszLocalBasePathBuf[ucbLocalBasePathLen] = TEXT('\0');
         }
      }
      else
      {
         /* Not shared.  No CNRLink. */

         *pucbCNRLinkLen = 0;

         /* Copy entire local path into output buffer. */

         lstrcpy(pszLocalBasePathBuf, pcszLocalPath);

         /* Common path suffix is the empty string. */

         *ppcszCommonPathSuffix = pcszLocalPath + lstrlen(pcszLocalPath);
      }
   }

   ASSERT(! bResult ||
          (EVAL(IsDrivePath(pszLocalBasePathBuf)) &&
           IS_VALID_STRING_PTR(*ppcszCommonPathSuffix, CSTR) &&
           EVAL(IsStringContained(pcszLocalPath, *ppcszCommonPathSuffix)) &&
           (! *pucbCNRLinkLen ||
            (IS_VALID_STRUCT_PTR((PCICNRLINK)*ppcnrl, CICNRLINK) &&
             EVAL(*pucbCNRLinkLen == GetCNRLinkLen(*ppcnrl))))));

   return(bResult);
}


/*
** CreateRemoteCNRLink()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreateRemoteCNRLink(LPCTSTR pcszRemotePath, LPCTSTR pcszCNRName,
                                     PCNRLINK *ppcnrl, PUINT pucbCNRLinkLen)
{
   BOOL bResult;
   /* "D:" + null terminator. */
   TCHAR rgchDrive[3];
   DWORD dwNetType;

   ASSERT(IsCanonicalPath(pcszRemotePath));
   ASSERT(IsValidCNRName(pcszCNRName));
   ASSERT(IS_VALID_WRITE_PTR(ppcnrl, PCNRLINK));
   ASSERT(IS_VALID_WRITE_PTR(pucbCNRLinkLen, UINT));

   /* Determine net provider. */

   bResult = GetNetType(pcszCNRName, &dwNetType);

   if (bResult)
   {
      DWORD dwFlags = ICNRL_FL_VALID_NET_TYPE;

      /* Determine last redirected drive, if any. */

      if (IsDrivePath(pcszRemotePath))
      {
         MyLStrCpyN(rgchDrive, pcszRemotePath, ARRAYSIZE(rgchDrive));
         SET_FLAG(dwFlags, ICNRL_FL_VALID_DEVICE);
      }
      else
         rgchDrive[0] = TEXT('\0');

      bResult = UnifyICNRLinkInfo(pcszCNRName, dwFlags, rgchDrive, dwNetType,
                                  (PICNRLINK *)ppcnrl, pucbCNRLinkLen);
   }

   ASSERT(! bResult ||
          (IS_VALID_STRUCT_PTR((PCICNRLINK)*ppcnrl, CICNRLINK) &&
           EVAL(*pucbCNRLinkLen == GetCNRLinkLen(*ppcnrl))));

   return(bResult);
}


/*
** DestroyCNRLink()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyCNRLink(PCNRLINK pcnrl)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcnrl, CCNRLINK));

   FreeMemory(pcnrl);

   return;
}


/*
** CompareCNRLinks()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** CNR link data is compared in the following order:
**
**    1) net name
**
** N.b., net types are ignored when comparing CNRLinks.
*/
PUBLIC_CODE COMPARISONRESULT CompareCNRLinks(PCCNRLINK pccnrlFirst,
                                             PCCNRLINK pccnrlSecond)
{
#ifdef UNICODE
   WCHAR szWideNetNameFirst[MAX_PATH];
   LPWSTR pszWideNetNameFirst;
   WCHAR szWideNetNameSecond[MAX_PATH];
   LPWSTR pszWideNetNameSecond;
#endif

   ASSERT(IS_VALID_STRUCT_PTR(pccnrlFirst, CCNRLINK));
   ASSERT(IS_VALID_STRUCT_PTR(pccnrlSecond, CCNRLINK));

#ifdef UNICODE
   if (IS_ICNRL_ANSI(pccnrlFirst))
   {
      pszWideNetNameFirst = szWideNetNameFirst;
      MultiByteToWideChar(CP_ACP, 0,
                          ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrlFirst), -1,
                          szWideNetNameFirst, MAX_PATH);

   }
   else
   {
      pszWideNetNameFirst = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrlFirst);
   }

   if (IS_ICNRL_ANSI(pccnrlSecond))
   {
      pszWideNetNameSecond = szWideNetNameSecond;
      MultiByteToWideChar(CP_ACP, 0,
                          ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrlSecond), -1,
                          szWideNetNameSecond, MAX_PATH);

   }
   else
   {
      pszWideNetNameSecond = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrlSecond);
   }

   return(CompareNetNames(pszWideNetNameFirst,pszWideNetNameSecond));
#else
   return(CompareNetNames(ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrlFirst),
                          ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrlSecond)));
#endif
}


/*
** GetLocalPathFromCNRLink()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetLocalPathFromCNRLink(PCCNRLINK pccnrl,
                                         LPTSTR pszLocalPathBuf,
                                         PDWORD pdwOutFlags)
{
   BOOL bResult;
   PCSERVERVTABLE pcsvt;

   ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszLocalPathBuf, STR, MAX_PATH_LEN));
   ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));

   *pdwOutFlags = 0;

   bResult = GetServerVTable(&pcsvt);

   if (bResult)
   {
      DWORD dwNetType;
      BOOL bIsLocal;

      /*
       * Get local path for share.  N.b., the share name must be in upper case
       * here for MSSHRUI.DLL.
       */

      dwNetType = (IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags,
                               ICNRL_FL_VALID_NET_TYPE) ?
                   ((PCICNRLINK)pccnrl)->dwNetType :
                   0);

#ifdef UNICODE
      {
         WCHAR szWideNetName[MAX_PATH];
         LPWSTR pszWideNetName = szWideNetName;

         if (IS_ICNRL_ANSI(pccnrl))
         {
            MultiByteToWideChar(CP_ACP, 0,
                                ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl), -1,
                                szWideNetName, MAX_PATH);

         }
         else
         {
            pszWideNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
         }
         bResult = (pcsvt->GetLocalPathFromNetResource)(
                        pszWideNetName, dwNetType,
                        pszLocalPathBuf, MAX_PATH_LEN, &bIsLocal);
      }
#else
      bResult = (pcsvt->GetLocalPathFromNetResource)(
                     ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl), dwNetType,
                     pszLocalPathBuf, MAX_PATH_LEN, &bIsLocal);
#endif

      if (bIsLocal)
         SET_FLAG(*pdwOutFlags, CNR_FL_LOCAL);
   }

   ASSERT(FLAGS_ARE_VALID(*pdwOutFlags, ALL_CNR_FLAGS) &&
          (! bResult ||
           (EVAL(IS_FLAG_SET(*pdwOutFlags, CNR_FL_LOCAL)) &&
            EVAL(IsLocalDrivePath(pszLocalPathBuf)))));

   return(bResult);
}


/*
** GetRemotePathFromCNRLink()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void GetRemotePathFromCNRLink(PCCNRLINK pccnrl,
                                          LPTSTR pszRemotePathBuf)
{
   ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRemotePathBuf, STR, MAX_PATH_LEN));

   /* It's ok that this is broken for non-UNC CNR names. */

   /* (- 1) for trailing slash. */

   ASSERT(lstrlenA(ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl)) < MAX_PATH_LEN - 1);

#ifdef UNICODE
   {
      WCHAR szWideNetName[MAX_PATH];
      LPWSTR pszWideNetName;

      if (IS_ICNRL_ANSI(pccnrl))
      {
         pszWideNetName = szWideNetName;
         MultiByteToWideChar(CP_ACP, 0,
                             ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl), -1,
                             szWideNetName, MAX_PATH);

      }
      else
      {
         pszWideNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
      }
      lstrcpy(pszRemotePathBuf, pszWideNetName);
   }
#else
   lstrcpy(pszRemotePathBuf, ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl));
#endif
   CatPath(pszRemotePathBuf, TEXT("\\"));

   return;
}


/*
** ConnectToCNR()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ConnectToCNR(PCCNRLINK pccnrl, DWORD dwInFlags,
                              HWND hwndOwner, LPTSTR pszRootPathBuf,
                              PDWORD pdwOutFlags)
{
   BOOL bResult = FALSE;
   BOOL bValidDevice;
   BOOL bRedirect;
   BOOL bTryLastDevice = FALSE;
   DWORD dwcbRootPathBufLen;
   LPTSTR pszNetName;
   LPTSTR pszDevice;
#ifdef UNICODE
   WCHAR szWideNetName[MAX_PATH];
   WCHAR szWideDevice[MAX_PATH];
#endif

   ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_CONNECT_IN_FLAGS));
   ASSERT(IS_FLAG_CLEAR(dwInFlags, CONNECT_INTERACTIVE) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRootPathBuf, STR, MAX_PATH_LEN));
   ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));

   *pdwOutFlags = 0;

#ifdef UNICODE
   if (IS_ICNRL_ANSI(pccnrl))
   {
      pszNetName = szWideNetName;
      MultiByteToWideChar(CP_ACP, 0,
                          ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl), -1,
                          szWideNetName, MAX_PATH);

   }
   else
   {
      pszNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
   }
#else
   pszNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
#endif

   /* Do we have an old redirected device to try? */

   bValidDevice = IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags,
                              ICNRL_FL_VALID_DEVICE);

#ifdef UNICODE
   if ( bValidDevice )
   {
      if (IS_ICNRL_ANSI(pccnrl))
      {
         pszDevice = szWideDevice;
         MultiByteToWideChar(CP_ACP, 0,
                             ICNRL_Device_PtrA((PCICNRLINK)pccnrl), -1,
                             szWideDevice, MAX_PATH);

      }
      else
      {
         pszDevice = ICNRL_Device_Ptr((PCICNRLINK)pccnrl);
      }
   }
#else
   pszDevice = ICNRL_Device_Ptr((PCICNRLINK)pccnrl);
#endif

   bRedirect = (bValidDevice || IS_FLAG_SET(dwInFlags, CONNECT_REDIRECT));

   if (bRedirect)
   {
      if (bValidDevice)
      {
         DWORD dwNetResult;
         /* "X:" + null terminator */
         TCHAR rgchDrive[2 + 1];

         /* Yes.  Is it already connected to the desired CNR? */

         TRACE_OUT((TEXT("ConnectToCNR(): Calling WNetGetConnection() to check %s for CNR \"%s\"."),
                    pszDevice, pszNetName));

         dwcbRootPathBufLen = MAX_PATH_LEN;

         /* WNetGetConnection requires the device name to have no trailing
         ** backslash.
         */
         MyLStrCpyN(rgchDrive, pszDevice, ARRAYSIZE(rgchDrive));
         dwNetResult = WNetGetConnection(rgchDrive, pszRootPathBuf, &dwcbRootPathBufLen);

         if (dwNetResult == WN_SUCCESS)
         {
            if (CompareNetNames(pszNetName, pszRootPathBuf)
                == CR_EQUAL)
            {
               TRACE_OUT((TEXT("ConnectToCNR(): Found matching CNR \"%s\" on %s."),
                          pszRootPathBuf,
                          pszDevice));

               ASSERT(lstrlenA(ICNRL_Device_PtrA((PCICNRLINK)pccnrl)) < MAX_PATH_LEN);
               lstrcpy(pszRootPathBuf, pszDevice);

               bResult = TRUE;
            }
            else
               TRACE_OUT((TEXT("ConnectToCNR(): Found unmatched CNR \"%s\" on %s."),
                          pszRootPathBuf,
                          pszDevice));
         }
         else
         {
            TRACE_OUT((TEXT("ConnectToCNR(): WNetGetConnection() failed on %s."),
                       pszDevice));

            /*
             * Only attempt a connection to the last redirected device if that
             * device is not already in use.
             */

            bTryLastDevice = (GetDriveType(pszDevice)
                              == DRIVE_NO_ROOT_DIR);
         }
      }

      if (! bResult)
         /* See if the desired CNR is connected to any local device. */
         bResult = SearchForRedirectedConnection((PCICNRLINK)pccnrl,
                                                 pszRootPathBuf);
         /*
          * Assume that no reference count is maintained for redirected device
          * connections, so we do not have to add a found redirected device
          * connection again.
          */
   }

   if (! bResult)
   {
      NETRESOURCE nr;
      TCHAR rgchNPName[MAX_PATH_LEN];

      /* RAIDRAID: (15691) We only support disk resource connections here. */

      ZeroMemory(&nr, SIZEOF(nr));
      nr.lpRemoteName = pszNetName;
      nr.dwType = RESOURCETYPE_DISK;
      if (GetNetProviderName((PCICNRLINK)pccnrl, rgchNPName))
         nr.lpProvider = rgchNPName;

      /* Shall we try the old device? */

      if (bTryLastDevice)
      {
         /* Yes. */

         ASSERT(bValidDevice);

         nr.lpLocalName = pszDevice;

         WARNING_OUT((TEXT("ConnectToCNR(): Calling WNetUseConnection() to attempt to connect %s to CNR \"%s\"."),
                      nr.lpLocalName,
                      nr.lpRemoteName));
      }
      else
      {
         /* No.  Shall we attempt to force a redirected connection? */

         if (bValidDevice)
         {
            /*
             * Yes.  N.b., the caller may already have set CONNECT_REDIRECT in
             * dwInFlags here.
             */

            SET_FLAG(dwInFlags, CONNECT_REDIRECT);

            WARNING_OUT((TEXT("ConnectToCNR(): Calling WNetUseConnection() to establish auto-picked redirected connection to CNR \"%s\"."),
                         nr.lpRemoteName));
         }
         else
            /* No. */
            WARNING_OUT((TEXT("ConnectToCNR(): Calling WNetUseConnection() to establish connection to CNR \"%s\"."),
                         TEXT("<nr.lpRemoteName>"))); // nr.lpRemoteName));

         ASSERT(! nr.lpLocalName);
      }

      dwcbRootPathBufLen = MAX_PATH_LEN;

      bResult = (WNetUseConnection(hwndOwner, &nr, NULL, NULL, dwInFlags,
                                   pszRootPathBuf, &dwcbRootPathBufLen,
                                   pdwOutFlags)
                 == NO_ERROR);
   }

   if (bResult)
      CatPath(pszRootPathBuf, TEXT("\\"));

   ASSERT(! bResult ||
          (IS_VALID_STRING_PTR(pszRootPathBuf, STR) &&
           FLAGS_ARE_VALID(*pdwOutFlags, ALL_CONNECT_OUT_FLAGS)));

   return(bResult);
}


/*
** DisconnectFromCNR()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL DisconnectFromCNR(PCCNRLINK pccnrl)
{
   DWORD dwNetResult;
   LPTSTR pszNetName;
#ifdef UNICODE
   WCHAR szWideNetName[MAX_PATH];
#endif

   ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

#ifdef UNICODE
   if (IS_ICNRL_ANSI(pccnrl))
   {
      pszNetName = szWideNetName;
      MultiByteToWideChar(CP_ACP, 0,
                          ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl), -1,
                          szWideNetName, MAX_PATH);

   }
   else
   {
      pszNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
   }
#else
   pszNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
#endif

   dwNetResult = WNetCancelConnection2(pszNetName,
                                       CONNECT_REFCOUNT, FALSE);

   if (dwNetResult == NO_ERROR)
      WARNING_OUT((TEXT("DisconnectFromCNR(): Reduced connection reference count on CNR \"%s\"."),
                   pszNetName));
   else
      WARNING_OUT((TEXT("DisconnectFromCNR(): Failed to reduce connection reference count on CNR \"%s\".  WNetCancelConnection2() returned %lu."),
                   pszNetName));

   return(dwNetResult == NO_ERROR);
}


/*
** IsCNRAvailable()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsCNRAvailable(PCCNRLINK pccnrl)
{
   TCHAR rgchCNRRoot[MAX_PATH_LEN];
   LPTSTR pszNetName;
#ifdef UNICODE
   WCHAR szWideNetName[MAX_PATH];
#endif

   ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

#ifdef UNICODE
   if (IS_ICNRL_ANSI(pccnrl))
   {
      pszNetName = szWideNetName;
      MultiByteToWideChar(CP_ACP, 0,
                          ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl), -1,
                          szWideNetName, MAX_PATH);

   }
   else
   {
      pszNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
   }
#else
   pszNetName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
#endif

   ASSERT(lstrlen(pszNetName) < ARRAYSIZE(rgchCNRRoot) - 1);
   lstrcpy(rgchCNRRoot, pszNetName);
   CatPath(rgchCNRRoot, TEXT("\\"));

   return(PathExists(rgchCNRRoot));
}


/*
** GetCNRLinkLen()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE UINT GetCNRLinkLen(PCCNRLINK pccnrl)
{
   ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

   return(((PCICNRLINK)pccnrl)->ucbSize);
}


/*
** GetCNRNetType()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetCNRNetType(PCCNRLINK pccnrl, PCDWORD *ppcdwNetType)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

   bResult = IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags,
                         ICNRL_FL_VALID_NET_TYPE);

   if (bResult)
      *ppcdwNetType = &(((PCICNRLINK)pccnrl)->dwNetType);

   ASSERT(! bResult ||
          IsValidNetType(**ppcdwNetType));

   return(bResult);
}


/*
** GetCNRName()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetCNRName(PCCNRLINK pccnrl, LPCSTR *ppcszCNRName)
{
   ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

   *ppcszCNRName = ICNRL_Remote_Name_PtrA((PCICNRLINK)pccnrl);

   ASSERT(IS_VALID_STRING_PTRA(*ppcszCNRName, CSTR));

   return(TRUE);
}

#ifdef UNICODE
/*
** GetCNRNameW()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetCNRNameW(PCCNRLINK pccnrl, LPCWSTR *ppcszCNRName)
{
   ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

   if (IS_ICNRL_ANSI(pccnrl))
      *ppcszCNRName = NULL;
   else
   {
      *ppcszCNRName = ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl);
      ASSERT(IS_VALID_STRING_PTR(*ppcszCNRName, CSTR));
   }

   return(TRUE);
}
#endif

/*
** GetLastRedirectedDevice()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetLastRedirectedDevice(PCCNRLINK pccnrl, LPCSTR *ppcszDevice)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

   bResult = IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags, ICNRL_FL_VALID_DEVICE);

   if (bResult)
      *ppcszDevice = ICNRL_Device_PtrA((PCICNRLINK)pccnrl);

   ASSERT(! bResult ||
          IS_VALID_STRING_PTRA(*ppcszDevice, CSTR));

   return(bResult);
}

#ifdef UNICODE
/*
** GetLastRedirectedDeviceW()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetLastRedirectedDeviceW(PCCNRLINK pccnrl, LPCWSTR *ppcszDevice)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

   bResult = IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags, ICNRL_FL_VALID_DEVICE);

   if (bResult)
      if (IS_ICNRL_ANSI(pccnrl))
         *ppcszDevice = NULL;
      else
      {
         *ppcszDevice = ICNRL_Device_Ptr((PCICNRLINK)pccnrl);
         ASSERT(! bResult ||
               IS_VALID_STRING_PTR(*ppcszDevice, CSTR));
      }

   return(bResult);
}
#endif

#if defined(DEBUG) || defined (VSTF)

/*
** IsValidPCCNRLINK()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCCNRLINK(PCCNRLINK pccnrl)
{
   return(IS_VALID_STRUCT_PTR((PCICNRLINK)pccnrl, CICNRLINK));
}

#endif


#ifdef DEBUG

/*
** DumpCNRLink()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DumpCNRLink(PCCNRLINK pccnrl)
{
   ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

   PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] ucbSize %#x"),
                    INDENT_STRING,
                    INDENT_STRING,
                    ((PCICNRLINK)pccnrl)->ucbSize));
   PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] dwFLags = %#08lx"),
                    INDENT_STRING,
                    INDENT_STRING,
                    ((PCICNRLINK)pccnrl)->dwFlags));
   PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] CNR name \"%s\""),
                    INDENT_STRING,
                    INDENT_STRING,
                    ICNRL_Remote_Name_Ptr((PCICNRLINK)pccnrl)));
   if (IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags, ICNRL_FL_VALID_NET_TYPE))
      PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] net type %#08lx"),
                       INDENT_STRING,
                       INDENT_STRING,
                       ((PCICNRLINK)pccnrl)->dwNetType));
   else
      PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] net type unknown"),
                       INDENT_STRING,
                       INDENT_STRING));
   if (IS_FLAG_SET(((PCICNRLINK)pccnrl)->dwFlags, ICNRL_FL_VALID_DEVICE))
      PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] last redirected local device \"%s\""),
                       INDENT_STRING,
                       INDENT_STRING,
                       ICNRL_Device_Ptr((PCICNRLINK)pccnrl)));
   else
      PLAIN_TRACE_OUT((TEXT("%s%s[CNR link] no last redirected local device"),
                       INDENT_STRING,
                       INDENT_STRING));

   return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\nothunk.c ===
#include "project.h"

VOID WINAPI NoThunkReinitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
) {
    InitializeCriticalSection( lpCriticalSection );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\linkinfo.c ===
/*
 * linkinfo.c - LinkInfo ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "volumeid.h"
#include "cnrlink.h"


/* Macros
 *********/

/* macros for accessing ILINKINFO data */

#define ILI_Volume_ID_Ptr(pili) \
   ((PVOLUMEID)(((PBYTE)(pili)) + (pili)->ucbVolumeIDOffset))

#define ILI_Local_Base_Path_PtrA(pili) \
   ((LPSTR)(((PBYTE)(pili)) + (pili)->ucbLocalBasePathOffset))

#define ILI_CNR_Link_Ptr(pili) \
   ((PCNRLINK)(((PBYTE)(pili)) + (pili)->ucbCNRLinkOffset))

#define ILI_Common_Path_Suffix_PtrA(pili) \
   ((LPSTR)(((PBYTE)(pili)) + (pili)->ucbCommonPathSuffixOffset))

#define ILI_Local_Base_Path_PtrW(pili) \
   ((LPWSTR)(((PBYTE)(pili)) + (pili)->ucbLocalBasePathOffsetW))

#define ILI_Common_Path_Suffix_PtrW(pili) \
   ((LPWSTR)(((PBYTE)(pili)) + (pili)->ucbCommonPathSuffixOffsetW))

#ifdef UNICODE
#define ILI_Local_Base_Path_Ptr(pili)       ILI_Local_Base_Path_PtrW(pili)
#define ILI_Common_Path_Suffix_Ptr(pili)    ILI_Common_Path_Suffix_PtrW(pili)
#else
#define ILI_Local_Base_Path_Ptr(pili)       ILI_Local_Base_Path_PtrA(pili)
#define ILI_Common_Path_Suffix_Ptr(pili)    ILI_Common_Path_Suffix_PtrA(pili)
#endif

/* Types
 ********/

/******************************************************************************

@doc LINKINFOAPI

@struct LINKINFO | External definition of LinkInfo structure.

@field UINT | ucbSize | The size of the LINKINFO structure in bytes, including
the ucbSize field.  An ILINKINFO structure consists of a header described as
below, followed by variable-length data that is opaque to the caller.

******************************************************************************/

/*
   @doc INTERNAL

   @enum ILINKINFOFLAGS | Internal LinkInfo structure flags.
*/

typedef enum _ilinkinfoflags
{
   /*
      @emem ILI_FL_LOCAL_INFO_VALID | If set, volume ID and local path are
      valid.  If clear, volume ID and local path are not valid.
   */

   ILI_FL_LOCAL_INFO_VALID    =  0x0001,

   /*
      @emem ILI_FL_REMOTE_INFO_VALID | If set, CNRLink and path suffix are
      valid.  If clear, CNRLink and path suffix not valid.
   */

   ILI_FL_REMOTE_INFO_VALID   =  0x0002,

   /* @emem ALL_ILINKINFO_FLAGS | All internal LinkInfo structure flags. */

   ALL_ILINKINFO_FLAGS        = (ILI_FL_LOCAL_INFO_VALID |\
                                 ILI_FL_REMOTE_INFO_VALID)
}
ILINKINFOFLAGS;

/*
   @doc INTERNAL

   @struct ILINKINFO | Internal definition of relocatable, extensible, internal
   LinkInfo structure.  An ILINKINFO structure may contain an <t IVOLUMEID>
   structure and an <t ICNRLINK> structure.  An ILINKINFO structure consists of
   a header described as below, followed by variable-length data.
*/

typedef struct _ilinkinfoA
{
   /* @field LINKINFO | li | External <t LINKINFO> sub-structure. */

   LINKINFO li;

   /*
      @field UINT | ucbHeaderSize | Size of the ILINKINFO header structure in
      bytes.
   */

   UINT ucbHeaderSize;

   /*
      @field DWORD | dwFlags | A bit mask of flags from the <t ILINKINFOFLAGS>
      enumeration.
   */

   DWORD dwFlags;

   /*
      @field UINT | ucbVolumeIDOffset | Offset in bytes of <t IVOLUMEID>
      sub-structure from base of structure.
   */

   UINT ucbVolumeIDOffset;

   /*
      @field UINT | ucbLocalBasePathOffset | Offset in bytes of local base path
      string from base of structure.  The local base path is a valid file
      system path.  The local base path string + the common path suffix string
      form the local path string, which is a valid file system path.  The local
      base path string refers to the same resource as the CNRLink's CNR name
      string.<nl>

      Example local base path string: "c:\\work".<nl>
      E.g., if local path "c:\\work" is shared as "\\\\fredbird\\work", an
      ILinkInfo structure would break local path
      "c:\\work\\footwear\\sneakers.doc" up into local base path "c:\\work",
      CNRLink CNR name "\\\\fredbird\\work", and common path suffix
      "footwear\\sneakers.doc".
   */

   UINT ucbLocalBasePathOffset;

   /*
      @field UINT | ucbCNRLinkOffset | Offset in bytes of <t CNRLINK>
      sub-structure from base of structure.  The file system name of the
      CNRLink's CNR name + the common path suffix string form the remote path
      string, which is a valid file system path.  The CNRLink's CNR name string
      refers to the same resource as the local base path string.
   */

   UINT ucbCNRLinkOffset;

   /*
      @field UINT | ucbCommonPathSuffixOffset | Offset in bytes of common path
      suffix string from base of structure.<nl> Example common path suffix
      string: "footwear\\sneakers.doc".
   */

   UINT ucbCommonPathSuffixOffset;
}
ILINKINFOA;
DECLARE_STANDARD_TYPES(ILINKINFOA);

#ifdef UNICODE
typedef struct _ilinkinfoW
{
   /* @field LINKINFO | li | External <t LINKINFO> sub-structure. */

   LINKINFO li;

   /*
      @field UINT | ucbHeaderSize | Size of the ILINKINFO header structure in
      bytes.
   */

   UINT ucbHeaderSize;

   /*
      @field DWORD | dwFlags | A bit mask of flags from the <t ILINKINFOFLAGS>
      enumeration.
   */

   DWORD dwFlags;

   /*
      @field UINT | ucbVolumeIDOffset | Offset in bytes of <t IVOLUMEID>
      sub-structure from base of structure.
   */

   UINT ucbVolumeIDOffset;

   /*
      @field UINT | ucbLocalBasePathOffset | Offset in bytes of local base path
      string from base of structure.  The local base path is a valid file
      system path.  The local base path string + the common path suffix string
      form the local path string, which is a valid file system path.  The local
      base path string refers to the same resource as the CNRLink's CNR name
      string.<nl>

      Example local base path string: "c:\\work".<nl>
      E.g., if local path "c:\\work" is shared as "\\\\fredbird\\work", an
      ILinkInfo structure would break local path
      "c:\\work\\footwear\\sneakers.doc" up into local base path "c:\\work",
      CNRLink CNR name "\\\\fredbird\\work", and common path suffix
      "footwear\\sneakers.doc".
   */

   UINT ucbLocalBasePathOffset;

   /*
      @field UINT | ucbCNRLinkOffset | Offset in bytes of <t CNRLINK>
      sub-structure from base of structure.  The file system name of the
      CNRLink's CNR name + the common path suffix string form the remote path
      string, which is a valid file system path.  The CNRLink's CNR name string
      refers to the same resource as the local base path string.
   */

   UINT ucbCNRLinkOffset;

   /*
      @field UINT | ucbCommonPathSuffixOffset | Offset in bytes of common path
      suffix string from base of structure.<nl> Example common path suffix
      string: "footwear\\sneakers.doc".
   */

   UINT ucbCommonPathSuffixOffset;

   /*
     These fields duplicate the above ones except that they are for the unicode
     versions of the strings.
   */
   UINT ucbLocalBasePathOffsetW;
   UINT ucbCommonPathSuffixOffsetW;

}
ILINKINFOW;
DECLARE_STANDARD_TYPES(ILINKINFOW);

#endif

#ifdef UNICODE
#define ILINKINFO   ILINKINFOW
#define PILINKINFO  PILINKINFOW
#define CILINKINFO  CILINKINFOW
#define PCILINKINFO PCILINKINFOW
#else
#define ILINKINFO   ILINKINFOA
#define PILINKINFO  PILINKINFOA
#define CILINKINFO  CILINKINFOA
#define PCILINKINFO PCILINKINFOA
#endif


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL CreateILinkInfo(LPCTSTR, PILINKINFO *);
PRIVATE_CODE BOOL CreateLocalILinkInfo(LPCTSTR, PILINKINFO *);
PRIVATE_CODE BOOL CreateRemoteILinkInfo(LPCTSTR, LPCTSTR, LPCTSTR, PILINKINFO *);
PRIVATE_CODE BOOL UnifyILinkInfo(PCVOLUMEID, UINT, LPCTSTR, PCCNRLINK, UINT, LPCTSTR, PILINKINFO *);
PRIVATE_CODE void DestroyILinkInfo(PILINKINFO);
PRIVATE_CODE BOOL UpdateILinkInfo(PCILINKINFO, LPCTSTR, PDWORD, PILINKINFO *);
PRIVATE_CODE BOOL UseNewILinkInfo(PCILINKINFO, PCILINKINFO);
PRIVATE_CODE BOOL ResolveLocalILinkInfo(PCILINKINFO, LPTSTR, DWORD);
PRIVATE_CODE BOOL ResolveRemoteILinkInfo(PCILINKINFO, LPTSTR, DWORD, HWND, PDWORD);
PRIVATE_CODE BOOL ResolveILinkInfo(PCILINKINFO, LPTSTR, DWORD, HWND, PDWORD);
PRIVATE_CODE BOOL ResolveLocalPathFromServer(PCILINKINFO, LPTSTR, PDWORD);
PRIVATE_CODE void GetLocalPathFromILinkInfo(PCILINKINFO, LPTSTR);
PRIVATE_CODE void GetRemotePathFromILinkInfo(PCILINKINFO, LPTSTR);
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoReferents(PCILINKINFO, PCILINKINFO);
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoLocalData(PCILINKINFO, PCILINKINFO);
PRIVATE_CODE COMPARISONRESULT CompareLocalPaths(PCILINKINFO, PCILINKINFO);
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoRemoteData(PCILINKINFO, PCILINKINFO);
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoVolumes(PCILINKINFO, PCILINKINFO);
PRIVATE_CODE BOOL CheckCombinedPathLen(LPCTSTR, LPCTSTR);
PRIVATE_CODE BOOL GetILinkInfoData(PCILINKINFO, LINKINFODATATYPE, PCVOID *);
PRIVATE_CODE BOOL DisconnectILinkInfo(PCILINKINFO);

#if defined(DEBUG) || defined(EXPV)

PRIVATE_CODE BOOL IsValidLINKINFODATATYPE(LINKINFODATATYPE);

#endif

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL CheckILIFlags(PCILINKINFO);
PRIVATE_CODE BOOL CheckILICommonPathSuffix(PCILINKINFO);
PRIVATE_CODE BOOL CheckILILocalInfo(PCILINKINFO);
PRIVATE_CODE BOOL CheckILIRemoteInfo(PCILINKINFO);
PRIVATE_CODE BOOL IsValidPCLINKINFO(PCLINKINFO);
PRIVATE_CODE BOOL IsValidPCILINKINFO(PCILINKINFO);

#ifdef SKIP_OLD_LINKINFO_QUIETLY
PRIVATE_CODE BOOL IsNewLinkInfoHackCheck(PCILINKINFO);
#endif

#endif

#ifdef DEBUG

PRIVATE_CODE void DumpILinkInfo(PCILINKINFO);

#endif


/*
** CreateILinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreateILinkInfo(LPCTSTR pcszPath, PILINKINFO *ppili)
{
   BOOL bResult = FALSE;
   TCHAR rgchCanonicalPath[MAX_PATH_LEN];
   DWORD dwCanonicalPathFlags;
   TCHAR rgchCNRName[MAX_PATH_LEN];
   LPTSTR pszRootPathSuffix;

   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppili, PILINKINFO));

   if (GetCanonicalPathInfo(pcszPath, rgchCanonicalPath, &dwCanonicalPathFlags,
                            rgchCNRName, &pszRootPathSuffix))
   {
      if (IS_FLAG_SET(dwCanonicalPathFlags, GCPI_OFL_REMOTE))
         bResult = CreateRemoteILinkInfo(rgchCanonicalPath, rgchCNRName,
                                         pszRootPathSuffix, ppili);
      else
         bResult = CreateLocalILinkInfo(rgchCanonicalPath, ppili);
   }

   return(bResult);
}


/*
** CreateLocalILinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreateLocalILinkInfo(LPCTSTR pcszLocalPath, PILINKINFO *ppili)
{
   BOOL bResult;
   PVOLUMEID pvolid;
   UINT ucbVolumeIDLen;

   ASSERT(IsLocalDrivePath(pcszLocalPath));
   ASSERT(IS_VALID_WRITE_PTR(ppili, PILINKINFO));

   bResult = CreateVolumeID(pcszLocalPath, &pvolid, &ucbVolumeIDLen);

   if (bResult)
   {
      PCNRLINK pcnrl;
      UINT ucbCNRLinkLen;
      TCHAR rgchLocalBasePath[MAX_PATH_LEN];
      LPCTSTR pcszCommonPathSuffix;

      bResult = CreateLocalCNRLink(pcszLocalPath, &pcnrl, &ucbCNRLinkLen,
                                   rgchLocalBasePath, &pcszCommonPathSuffix);

      if (bResult)
      {
         /* Wrap them up. */

         bResult = UnifyILinkInfo(pvolid, ucbVolumeIDLen, rgchLocalBasePath,
                                  pcnrl, ucbCNRLinkLen, pcszCommonPathSuffix,
                                  ppili);

         if (ucbCNRLinkLen > 0)
            DestroyCNRLink(pcnrl);
      }

      if (ucbVolumeIDLen > 0)
         DestroyVolumeID(pvolid);
   }

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*ppili, CILINKINFO));

   return(bResult);
}


/*
** CreateRemoteILinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreateRemoteILinkInfo(LPCTSTR pcszRemotePath,
                                        LPCTSTR pcszCNRName,
                                        LPCTSTR pcszRootPathSuffix,
                                        PILINKINFO *ppili)
{
   BOOL bResult;
   PCNRLINK pcnrl;
   UINT ucbCNRLinkLen;

   ASSERT(IsCanonicalPath(pcszRemotePath));
   ASSERT(IsValidCNRName(pcszCNRName));
   ASSERT(IS_VALID_STRING_PTR(pcszRootPathSuffix, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppili, PILINKINFO));

   bResult = CreateRemoteCNRLink(pcszRemotePath, pcszCNRName, &pcnrl,
                                 &ucbCNRLinkLen);

   if (bResult)
   {
      /* Wrap it up. */

      bResult = UnifyILinkInfo(NULL, 0, EMPTY_STRING, pcnrl, ucbCNRLinkLen,
                               pcszRootPathSuffix, ppili);

      if (EVAL(ucbCNRLinkLen > 0))
         DestroyCNRLink(pcnrl);
   }

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*ppili, CILINKINFO));

   return(bResult);
}


/*
** UnifyILinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL UnifyILinkInfo(PCVOLUMEID pcvolid, UINT ucbVolumeIDLen,
                            LPCTSTR pcszLocalBasePath, PCCNRLINK pccnrl,
                            UINT ucbCNRLinkLen, LPCTSTR pcszCommonPathSuffix,
                            PILINKINFO *ppili)
{
   BOOL bResult;
   UINT ucbILinkInfoLen;
   UINT ucbDataOffset;
   UINT cbAnsiLocalBasePath;
   UINT cbAnsiCommonPathSuffix;
#ifdef UNICODE
   BOOL bUnicode;
   UINT cchChars;
   CHAR szAnsiLocalBasePath[MAX_PATH*2];
   CHAR szAnsiCommonPathSuffix[MAX_PATH*2];
   UINT cbWideLocalBasePath;
   UINT cbWideCommonPathSuffix;
   UINT cbChars;
#endif

   ASSERT(! ucbVolumeIDLen ||
          (IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID) &&
           IsDrivePath(pcszLocalBasePath)));
   ASSERT(! ucbCNRLinkLen ||
          IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));
   ASSERT(IS_VALID_STRING_PTR(pcszCommonPathSuffix, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppili, PILINKINFO));

#ifdef UNICODE
   bUnicode = FALSE;

   cbAnsiCommonPathSuffix = WideCharToMultiByte(CP_ACP, 0,
                                          pcszCommonPathSuffix, -1,
                                          szAnsiCommonPathSuffix, ARRAYSIZE(szAnsiCommonPathSuffix),
                                          0, 0);
   if ( cbAnsiCommonPathSuffix == 0 )
   {
      bUnicode = FALSE;
   }
   else
   {
      WCHAR szWideCommonPathSuffix[MAX_PATH];

      cbChars = MultiByteToWideChar(CP_ACP, 0,
                                    szAnsiCommonPathSuffix, -1,
                                    szWideCommonPathSuffix, MAX_PATH);
      if ( cbChars == 0 || lstrcmp(pcszCommonPathSuffix,szWideCommonPathSuffix) != 0 )
      {
         bUnicode = TRUE;
      }
   }

   if (ucbVolumeIDLen > 0)
   {
      cbAnsiLocalBasePath = WideCharToMultiByte(CP_ACP, 0,
                                         pcszLocalBasePath, -1,
                                         szAnsiLocalBasePath, MAX_PATH*2,
                                         0, 0);
      if ( cbAnsiLocalBasePath == 0 )
      {
         bUnicode = FALSE;
      }
      else
      {
         WCHAR szWideLocalBasePath[MAX_PATH];

         cchChars = MultiByteToWideChar(CP_ACP, 0,
                                        szAnsiLocalBasePath, -1,
                                        szWideLocalBasePath, ARRAYSIZE(szWideLocalBasePath));
         if ( cchChars == 0 || lstrcmp(pcszLocalBasePath,szWideLocalBasePath) != 0 )
         {
            bUnicode = TRUE;
         }
      }
   }
   else
   {
      cbAnsiLocalBasePath = 0;
   }

   if ( bUnicode )
   {
      ucbDataOffset = SIZEOF(ILINKINFOW);

      /* (+ 1) for null terminator. */
      cbWideCommonPathSuffix = (lstrlen(pcszCommonPathSuffix) + 1) * sizeof(TCHAR);

      if (ucbVolumeIDLen > 0)
         cbWideLocalBasePath = (lstrlen(pcszLocalBasePath) + 1) * sizeof(TCHAR);
      else
         cbWideLocalBasePath = 0;

   }
   else
   {
      ucbDataOffset = SIZEOF(ILINKINFOA);

      cbWideCommonPathSuffix = 0;
      cbWideLocalBasePath  = 0;
   }

   ucbILinkInfoLen = ucbDataOffset +
                     ucbVolumeIDLen +
                     cbAnsiLocalBasePath;
   if ( bUnicode && ucbVolumeIDLen > 0 )
   {
      ucbILinkInfoLen = ALIGN_WORD_CNT(ucbILinkInfoLen);
      ucbILinkInfoLen += cbWideLocalBasePath;
   }
   if ( ucbCNRLinkLen > 0 )
   {
      ucbILinkInfoLen = ALIGN_DWORD_CNT(ucbILinkInfoLen);
      ucbILinkInfoLen += ucbCNRLinkLen;
   }
   ucbILinkInfoLen += cbAnsiCommonPathSuffix;
   if ( bUnicode )
   {
      ucbILinkInfoLen = ALIGN_WORD_CNT(ucbILinkInfoLen);
      ucbILinkInfoLen += cbWideCommonPathSuffix;
   }

#else

   /* Calculate total length. */

   /* Assume we don't overflow ucbILinkInfoLen here. */

   /*
    * Base structure size plus common path suffix length.  (+ 1) for null
    * terminator.
    */
   cbAnsiCommonPathSuffix = lstrlen(pcszCommonPathSuffix) + 1;

   ucbILinkInfoLen = SIZEOF(**ppili) +
                     cbAnsiCommonPathSuffix;

   /* Plus size of local information. */

   if (ucbVolumeIDLen > 0)
   {
      /* (+ 1) for null terminator. */
      cbAnsiLocalBasePath = lstrlen(pcszLocalBasePath) + 1;

      ucbILinkInfoLen += ucbVolumeIDLen +
                         cbAnsiLocalBasePath;
   }

   /* Plus size of remote information. */

   if (ucbCNRLinkLen > 0)
      /* (+ 1) for null terminator. */
      ucbILinkInfoLen += ucbCNRLinkLen;

   ucbDataOffset = SIZEOF(**ppili);
#endif

   /* Try to allocate a container. */

   bResult = AllocateMemory(ucbILinkInfoLen, ppili);

   if (bResult)
   {
      (*ppili)->li.ucbSize = ucbILinkInfoLen;

      (*ppili)->ucbHeaderSize = ucbDataOffset;
      (*ppili)->dwFlags = 0;

      /* Do we have local information? */

      if (ucbVolumeIDLen > 0)
      {
         /* Yes.  Add it to the structure. */

         ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));
         ASSERT(IsDrivePath(pcszLocalBasePath));

         /* Append local volume ID. */

         (*ppili)->ucbVolumeIDOffset = ucbDataOffset;
         CopyMemory(ILI_Volume_ID_Ptr(*ppili), pcvolid, ucbVolumeIDLen);
         ucbDataOffset += ucbVolumeIDLen;

         /* Append local path. */

         (*ppili)->ucbLocalBasePathOffset = ucbDataOffset;
#ifdef UNICODE
         lstrcpyA(ILI_Local_Base_Path_PtrA(*ppili), szAnsiLocalBasePath);
         ucbDataOffset += cbAnsiLocalBasePath;

         if ( bUnicode )
         {
            ucbDataOffset = ALIGN_WORD_CNT(ucbDataOffset);
            (*ppili)->ucbLocalBasePathOffsetW = ucbDataOffset;
            lstrcpy(ILI_Local_Base_Path_PtrW(*ppili), pcszLocalBasePath);
            ucbDataOffset += cbWideLocalBasePath;
         }
#else
         lstrcpy(ILI_Local_Base_Path_Ptr(*ppili), pcszLocalBasePath);
         ucbDataOffset += cbAnsiLocalBasePath;
#endif
         SET_FLAG((*ppili)->dwFlags, ILI_FL_LOCAL_INFO_VALID);
      }

      /* Do we have remote information? */

      if (ucbCNRLinkLen > 0)
      {
         ucbDataOffset = ALIGN_DWORD_CNT(ucbDataOffset);

         /* Yes.  Add it to the structure. */

         ASSERT(IS_VALID_STRUCT_PTR(pccnrl, CCNRLINK));

         /* Append CNR link. */

         (*ppili)->ucbCNRLinkOffset = ucbDataOffset;
         CopyMemory(ILI_CNR_Link_Ptr(*ppili), pccnrl, ucbCNRLinkLen);
         ucbDataOffset += ucbCNRLinkLen;

         SET_FLAG((*ppili)->dwFlags, ILI_FL_REMOTE_INFO_VALID);
      }

      /* Append common path suffix. */

      ASSERT(IS_VALID_STRING_PTR(pcszCommonPathSuffix, CSTR));

      (*ppili)->ucbCommonPathSuffixOffset = ucbDataOffset;
#ifdef UNICODE
      lstrcpyA(ILI_Common_Path_Suffix_PtrA(*ppili), szAnsiCommonPathSuffix);
      ucbDataOffset += cbAnsiCommonPathSuffix;
      if ( bUnicode )
      {
         ucbDataOffset = ALIGN_WORD_CNT(ucbDataOffset);

         (*ppili)->ucbCommonPathSuffixOffsetW = ucbDataOffset;
         lstrcpy(ILI_Common_Path_Suffix_Ptr(*ppili), pcszCommonPathSuffix);
         ucbDataOffset += cbWideCommonPathSuffix;
      }
#ifdef DEBUG
      ucbDataOffset += cbWideCommonPathSuffix;
#endif
#else
      lstrcpy(ILI_Common_Path_Suffix_Ptr(*ppili), pcszCommonPathSuffix);
#ifdef DEBUG
      ucbDataOffset += cbAnsiCommonPathSuffix;
#endif
#endif

      /* Do all the calculated lengths match? */

      ASSERT(ucbDataOffset == (*ppili)->li.ucbSize);
      ASSERT(ucbDataOffset == ucbILinkInfoLen);
   }

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*ppili, CILINKINFO));

   return(bResult);
}


/*
** DestroyILinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyILinkInfo(PILINKINFO pili)
{
   ASSERT(IS_VALID_STRUCT_PTR(pili, CILINKINFO));

   FreeMemory(pili);

   return;
}


/*
** UpdateILinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** An ILinkInfo structure is updated in the following cases:
**
** local information:
**
**    1) the local path has changed
**    2) remote information is available for the local path
**
** remote information:
**
**    3) the remote information is local to this machine, and local information
**       is available for the remote path
*/
PRIVATE_CODE BOOL UpdateILinkInfo(PCILINKINFO pcili, LPCTSTR pcszResolvedPath,
                                  PDWORD pdwOutFlags, PILINKINFO *ppiliUpdated)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
   ASSERT(IS_VALID_STRING_PTR(pcszResolvedPath, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));
   ASSERT(IS_VALID_WRITE_PTR(ppiliUpdated, PILINKINFO));

   *pdwOutFlags = 0;

   bResult = CreateILinkInfo(pcszResolvedPath, ppiliUpdated);

   if (bResult)
   {
      if (UseNewILinkInfo(pcili, *ppiliUpdated))
      {
         SET_FLAG(*pdwOutFlags, RLI_OFL_UPDATED);

         WARNING_OUT((TEXT("UpdateILinkInfo(): Updating ILinkInfo for path %s."),
                      pcszResolvedPath));
      }
   }

   ASSERT(! bResult ||
          (IS_FLAG_CLEAR(*pdwOutFlags, RLI_OFL_UPDATED) ||
           IS_VALID_STRUCT_PTR(*ppiliUpdated, CILINKINFO)));

   return(bResult);
}


/*
** UseNewILinkInfo()
**
**
**
** Arguments:
**
** Returns:       TRUE if the new ILinkInfo structure contains more or
**                different information than the old ILinkInfo structure.
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL UseNewILinkInfo(PCILINKINFO pciliOld, PCILINKINFO pciliNew)
{
   BOOL bUpdate = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(pciliOld, CILINKINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pciliNew, CILINKINFO));

   /* Does the new ILinkInfo structure contain local information? */

   if (IS_FLAG_SET(pciliNew->dwFlags, ILI_FL_LOCAL_INFO_VALID))
   {
      /* Yes.  Does the old ILinkInfo structure contain local information? */

      if (IS_FLAG_SET(pciliOld->dwFlags, ILI_FL_LOCAL_INFO_VALID))
         /*
          * Yes.  Update the old ILinkInfo structure if local information
          * differs.
          */
         bUpdate = (CompareILinkInfoLocalData(pciliOld, pciliNew) != CR_EQUAL);
      else
         /* No.  Update the old ILinkInfo structure. */
         bUpdate = TRUE;
   }
   else
      /* No.  Do not update the old ILinkInfo structure. */
      bUpdate = FALSE;

   /*
    * Do we already need to update the old ILinkInfo structure based on local
    * information comparison?
    */

   if (! bUpdate)
   {
      /* No.  Compare remote information. */

      /* Does the new ILinkInfo structure contain remote information? */

      if (IS_FLAG_SET(pciliNew->dwFlags, ILI_FL_REMOTE_INFO_VALID))
      {
         /*
          * Yes.  Does the old ILinkInfo structure contain remote information?
          */

         if (IS_FLAG_SET(pciliOld->dwFlags, ILI_FL_REMOTE_INFO_VALID))
            /*
             * Yes.  Update the old ILinkInfo structure if remote information
             * differs.
             */
            bUpdate = (CompareILinkInfoRemoteData(pciliOld, pciliNew)
                       != CR_EQUAL);
         else
            /* No.  Update the old ILinkInfo structure. */
            bUpdate = TRUE;
      }
   }

   return(bUpdate);
}


/*
** ResolveLocalILinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL ResolveLocalILinkInfo(PCILINKINFO pcili,
                                        LPTSTR pszResolvedPathBuf,
                                        DWORD dwInFlags)
{
   BOOL bResult;
   DWORD dwLocalSearchFlags;
   TCHAR rgchLocalPath[MAX_PATH_LEN];

   ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, MAX_PATH_LEN));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RLI_IFLAGS));

   /* Search for local path. */

   TRACE_OUT((TEXT("ResolveLocalILinkInfo(): Attempting to resolve LinkInfo locally.")));

   GetLocalPathFromILinkInfo(pcili, rgchLocalPath);

   if (IS_FLAG_SET(dwInFlags, RLI_IFL_LOCAL_SEARCH))
      dwLocalSearchFlags = SFLP_IFL_LOCAL_SEARCH;
   else
      dwLocalSearchFlags = 0;

   bResult = SearchForLocalPath(ILI_Volume_ID_Ptr(pcili), rgchLocalPath,
                                dwLocalSearchFlags, pszResolvedPathBuf);

   ASSERT(! bResult ||
          EVAL(IsCanonicalPath(pszResolvedPathBuf)));

   return(bResult);
}


/*
** ResolveRemoteILinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL ResolveRemoteILinkInfo(PCILINKINFO pcili,
                                         LPTSTR pszResolvedPathBuf,
                                         DWORD dwInFlags, HWND hwndOwner,
                                         PDWORD pdwOutFlags)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, MAX_PATH_LEN));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RLI_IFLAGS));
   ASSERT(IS_FLAG_CLEAR(dwInFlags, RLI_IFL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));

   ASSERT(IS_FLAG_CLEAR(dwInFlags, RLI_IFL_TEMPORARY) ||
          IS_FLAG_SET(dwInFlags, RLI_IFL_CONNECT));

   TRACE_OUT((TEXT("ResolveRemoteILinkInfo(): Attempting to resolve LinkInfo remotely.")));

   /* Connect if requested. */

   if (IS_FLAG_SET(dwInFlags, RLI_IFL_CONNECT))
   {
      DWORD dwConnectInFlags;
      DWORD dwConnectOutFlags;

      dwConnectInFlags = 0;

      if (IS_FLAG_SET(dwInFlags, RLI_IFL_TEMPORARY))
         dwConnectInFlags = CONNECT_TEMPORARY;

      if (IS_FLAG_SET(dwInFlags, RLI_IFL_ALLOW_UI))
         SET_FLAG(dwConnectInFlags, CONNECT_INTERACTIVE);

      if (IS_FLAG_SET(dwInFlags, RLI_IFL_REDIRECT))
         SET_FLAG(dwConnectInFlags, CONNECT_REDIRECT);

      bResult = ConnectToCNR(ILI_CNR_Link_Ptr(pcili), dwConnectInFlags,
                             hwndOwner, pszResolvedPathBuf,
                             &dwConnectOutFlags);

      if (bResult)
      {
#ifdef UNICODE
         WCHAR szWideCommonPathSuffix[MAX_PATH];
         LPWSTR pszWideCommonPathSuffix;

         if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
         {
            pszWideCommonPathSuffix = szWideCommonPathSuffix;
            MultiByteToWideChar(CP_ACP, 0,
                                ILI_Common_Path_Suffix_PtrA(pcili), -1,
                                szWideCommonPathSuffix, MAX_PATH);
         }
         else
         {
            pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
         }
         CatPath(pszResolvedPathBuf, pszWideCommonPathSuffix);
#else
         CatPath(pszResolvedPathBuf, ILI_Common_Path_Suffix_Ptr(pcili));
#endif

         if (IS_FLAG_SET(dwConnectOutFlags, CONNECT_REFCOUNT))
         {
            ASSERT(IS_FLAG_CLEAR(dwConnectOutFlags, CONNECT_LOCALDRIVE));

            SET_FLAG(*pdwOutFlags, RLI_OFL_DISCONNECT);
         }
      }
   }
   else
   {
      /*
       * It's ok that IsCNRAvailable() and GetRemotePathFromILinkInfo() are
       * broken for NPs whose CNR names are not valid file system root paths.
       *
       * For NPs whose CNR names are valid file system root paths,
       * IsCNRAvailable() will succeed or fail, and
       * GetRemotePathFromILinkInfo() will be called only on success.
       *
       * For NPs whose CNR names are not valid file system root paths,
       * IsCNRAvailable() will fail and GetRemotePathFromILinkInfo() will not
       * be called.
       */

      bResult = IsCNRAvailable(ILI_CNR_Link_Ptr(pcili));

      if (bResult)
         GetRemotePathFromILinkInfo(pcili, pszResolvedPathBuf);
   }

   ASSERT(! bResult ||
          (EVAL(IsCanonicalPath(pszResolvedPathBuf)) &&
           FLAGS_ARE_VALID(*pdwOutFlags, ALL_RLI_OFLAGS)));

   return(bResult);
}


/*
** ResolveILinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL ResolveILinkInfo(PCILINKINFO pcili, LPTSTR pszResolvedPathBuf,
                                   DWORD dwInFlags, HWND hwndOwner,
                                   PDWORD pdwOutFlags)
{
   BOOL bResult;
   BOOL bLocalInfoValid;
   BOOL bRemoteInfoValid;
   BOOL bLocalShare;

   ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, MAX_PATH_LEN));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_RLI_IFLAGS));
   ASSERT(IS_FLAG_CLEAR(dwInFlags, RLI_IFL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));

   *pdwOutFlags = 0;

   /* Describe LinkInfo contents. */

   bRemoteInfoValid = IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID);
   bLocalInfoValid = IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID);

   ASSERT(bLocalInfoValid || bRemoteInfoValid);

   /*
    * RAIDRAID: (15703) We will resolve to the wrong local path for a share
    * that has been moved to another path here.
    */

   bLocalShare = FALSE;

   if (bRemoteInfoValid)
   {
      DWORD dwLocalShareFlags;

      /* Ask the server for the local path. */

      bResult = ResolveLocalPathFromServer(pcili, pszResolvedPathBuf,
                                           &dwLocalShareFlags);

      if (IS_FLAG_SET(dwLocalShareFlags, CNR_FL_LOCAL))
         bLocalShare = TRUE;

      if (bResult)
      {
         ASSERT(IS_FLAG_SET(dwLocalShareFlags, CNR_FL_LOCAL));

         TRACE_OUT((TEXT("ResolveILinkInfo(): Resolved local path from server.")));
      }
   }
   else
      /* Can't tell if the referent is local or not. */
      bResult = FALSE;

   if (! bResult)
   {
      /* Try local path. */

      if (bLocalInfoValid)
         bResult = ResolveLocalILinkInfo(pcili, pszResolvedPathBuf, dwInFlags);

      if (! bResult)
      {
         /* Try remote path. */

         if (bRemoteInfoValid && ! bLocalShare)
            bResult = ResolveRemoteILinkInfo(pcili, pszResolvedPathBuf,
                                             dwInFlags, hwndOwner,
                                             pdwOutFlags);
      }
   }

   ASSERT(! bResult ||
          (EVAL(IsCanonicalPath(pszResolvedPathBuf)) &&
           FLAGS_ARE_VALID(*pdwOutFlags, ALL_RLI_OFLAGS)));

   return(bResult);
}


/*
** ResolveLocalPathFromServer()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL ResolveLocalPathFromServer(PCILINKINFO pcili,
                                             LPTSTR pszResolvedPathBuf,
                                             PDWORD pdwOutFlags)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, MAX_PATH_LEN));
   ASSERT(IS_VALID_WRITE_PTR(pdwOutFlags, DWORD));

   ASSERT(IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID));

   /* Try to get local path from server. */

   bResult = GetLocalPathFromCNRLink(ILI_CNR_Link_Ptr(pcili),
                                     pszResolvedPathBuf, pdwOutFlags);

   if (bResult)
   {

#ifdef UNICODE
      WCHAR szWideCommonPathSuffix[MAX_PATH];
      LPWSTR pszWideCommonPathSuffix;

      ASSERT(IS_FLAG_SET(*pdwOutFlags, CNR_FL_LOCAL));

      if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
      {
         pszWideCommonPathSuffix = szWideCommonPathSuffix;
         MultiByteToWideChar(CP_ACP, 0,
                             ILI_Common_Path_Suffix_PtrA(pcili), -1,
                             szWideCommonPathSuffix, MAX_PATH);
      }
      else
      {
         pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
      }
      CatPath(pszResolvedPathBuf, pszWideCommonPathSuffix);
#else
      ASSERT(IS_FLAG_SET(*pdwOutFlags, CNR_FL_LOCAL));

      CatPath(pszResolvedPathBuf, ILI_Common_Path_Suffix_Ptr(pcili));
#endif
   }

   ASSERT(FLAGS_ARE_VALID(*pdwOutFlags, ALL_CNR_FLAGS) &&
          (! bResult ||
           (EVAL(IS_FLAG_SET(*pdwOutFlags, CNR_FL_LOCAL)) &&
            EVAL(IsLocalDrivePath(pszResolvedPathBuf)))));

   return(bResult);
}


/*
** GetLocalPathFromILinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void GetLocalPathFromILinkInfo(PCILINKINFO pcili,
                                       LPTSTR pszResolvedPathBuf)
{
#ifdef UNICODE
   WCHAR szWideLocalBasePath[MAX_PATH];
   LPWSTR pszWideLocalBasePath;
   WCHAR szWideCommonPathSuffix[MAX_PATH];
   LPWSTR pszWideCommonPathSuffix;
#endif

   ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, MAX_PATH_LEN));

#ifdef UNICODE

   if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
   {
      pszWideLocalBasePath = szWideLocalBasePath;
      MultiByteToWideChar(CP_ACP, 0,
                          ILI_Local_Base_Path_PtrA(pcili), -1,
                          szWideLocalBasePath, MAX_PATH);

      pszWideCommonPathSuffix = szWideCommonPathSuffix;
      MultiByteToWideChar(CP_ACP, 0,
                          ILI_Common_Path_Suffix_PtrA(pcili), -1,
                          szWideCommonPathSuffix, MAX_PATH);
   }
   else
   {
      pszWideLocalBasePath    = ILI_Local_Base_Path_Ptr(pcili);
      pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
   }
   lstrcpy(pszResolvedPathBuf, pszWideLocalBasePath);
   CatPath(pszResolvedPathBuf, pszWideCommonPathSuffix);
#else
   lstrcpy(pszResolvedPathBuf, ILI_Local_Base_Path_Ptr(pcili));
   CatPath(pszResolvedPathBuf, ILI_Common_Path_Suffix_Ptr(pcili));
#endif

   ASSERT(lstrlen(pszResolvedPathBuf) < MAX_PATH_LEN);
   ASSERT(IsDrivePath(pszResolvedPathBuf));

   return;
}


/*
** GetRemotePathFromILinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void GetRemotePathFromILinkInfo(PCILINKINFO pcili,
                                        LPTSTR pszResolvedPathBuf)
{
#ifdef UNICODE
   WCHAR szWideCommonPathSuffix[MAX_PATH];
   LPWSTR pszWideCommonPathSuffix;
#endif

   ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, MAX_PATH_LEN));

   /* It's ok that this is broken for non-UNC CNR names. */

   GetRemotePathFromCNRLink(ILI_CNR_Link_Ptr(pcili), pszResolvedPathBuf);

#ifdef UNICODE
   if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
   {
      pszWideCommonPathSuffix = szWideCommonPathSuffix;
      MultiByteToWideChar(CP_ACP, 0,
                          ILI_Common_Path_Suffix_PtrA(pcili), -1,
                          szWideCommonPathSuffix, MAX_PATH);
   }
   else
   {
      pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
   }
   CatPath(pszResolvedPathBuf, pszWideCommonPathSuffix);
#else
   CatPath(pszResolvedPathBuf, ILI_Common_Path_Suffix_Ptr(pcili));
#endif

   return;
}


/*
** CompareILinkInfoReferents()
**
** Compares the referents of two ILINKINFO structures.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Comparison is performed on ILINKINFO data in only one of the following ways
** in the following order:
**
**    1) local data compared with local data
**    2) remote data compared with remote data
**    3) local data only < remote data only
*/
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoReferents(PCILINKINFO pciliFirst,
                                                   PCILINKINFO pciliSecond)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pciliFirst, CILINKINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pciliSecond, CILINKINFO));

   /*
    * We can't just perform a binary comparison of the two ILinkInfos here.  We
    * may have two LinkInfos that refer to the same path, but differ in case on
    * a non-case-sensitive file system.
    */

   /* Compare ILinkInfos by local or remote data. */

   if (IS_FLAG_SET(pciliFirst->dwFlags, ILI_FL_LOCAL_INFO_VALID) &&
       IS_FLAG_SET(pciliSecond->dwFlags, ILI_FL_LOCAL_INFO_VALID))
      /* Compare local data. */
      cr = CompareILinkInfoLocalData(pciliFirst, pciliSecond);
   else if (IS_FLAG_SET(pciliFirst->dwFlags, ILI_FL_REMOTE_INFO_VALID) &&
            IS_FLAG_SET(pciliSecond->dwFlags, ILI_FL_REMOTE_INFO_VALID))
      /* Compare remote data. */
      cr = CompareILinkInfoRemoteData(pciliFirst, pciliSecond);
   else
   {
      /*
       * One contains only valid local information and the other contains only
       * valid remote information.
       */

      ASSERT(! ((pciliFirst->dwFlags & (ILI_FL_LOCAL_INFO_VALID | ILI_FL_REMOTE_INFO_VALID)) &
                (pciliSecond->dwFlags & (ILI_FL_LOCAL_INFO_VALID | ILI_FL_REMOTE_INFO_VALID))));

      /* By fiat, local only < remote only. */

      if (IS_FLAG_SET(pciliFirst->dwFlags, ILI_FL_LOCAL_INFO_VALID))
         cr = CR_FIRST_SMALLER;
      else
         cr = CR_FIRST_LARGER;
   }

   ASSERT(IsValidCOMPARISONRESULT(cr));

   return(cr);
}


/*
** CompareILinkInfoLocalData()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Local ILinkInfo data is compared in the following order:
**
**    1) volume ID
**    2) sub path from root
*/
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoLocalData(PCILINKINFO pciliFirst,
                                                   PCILINKINFO pciliSecond)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pciliFirst, CILINKINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pciliSecond, CILINKINFO));

   cr = CompareVolumeIDs(ILI_Volume_ID_Ptr(pciliFirst),
                         ILI_Volume_ID_Ptr(pciliSecond));

   if (cr == CR_EQUAL)
      cr = CompareLocalPaths(pciliFirst, pciliSecond);

   ASSERT(IsValidCOMPARISONRESULT(cr));

   return(cr);
}


/*
** CompareLocalPaths()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE COMPARISONRESULT CompareLocalPaths(PCILINKINFO pciliFirst,
                                           PCILINKINFO pciliSecond)
{
   COMPARISONRESULT cr;
   TCHAR rgchFirstLocalPath[MAX_PATH_LEN];
   TCHAR rgchSecondLocalPath[MAX_PATH_LEN];

   ASSERT(IS_VALID_STRUCT_PTR(pciliFirst, CILINKINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pciliSecond, CILINKINFO));

   GetLocalPathFromILinkInfo(pciliFirst, rgchFirstLocalPath);
   GetLocalPathFromILinkInfo(pciliSecond, rgchSecondLocalPath);

   cr = ComparePathStrings(rgchFirstLocalPath, rgchSecondLocalPath);

   ASSERT(IsValidCOMPARISONRESULT(cr));

   return(cr);
}


/*
** CompareILinkInfoRemoteData()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoRemoteData(PCILINKINFO pciliFirst,
                                                    PCILINKINFO pciliSecond)
{
   COMPARISONRESULT cr;
#ifdef UNICODE
   WCHAR szWideCommonPathSuffixFirst[MAX_PATH];
   WCHAR szWideCommonPathSuffixSecond[MAX_PATH];
   LPWSTR pszWideCommonPathSuffixFirst;
   LPWSTR pszWideCommonPathSuffixSecond;
#endif

   ASSERT(IS_VALID_STRUCT_PTR(pciliFirst, CILINKINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pciliSecond, CILINKINFO));

   cr = CompareCNRLinks(ILI_CNR_Link_Ptr(pciliFirst),
                        ILI_CNR_Link_Ptr(pciliSecond));

#ifdef UNICODE
   if (pciliFirst->ucbHeaderSize == SIZEOF(ILINKINFOA))
   {
      pszWideCommonPathSuffixFirst = szWideCommonPathSuffixFirst;
      MultiByteToWideChar(CP_ACP, 0,
                         ILI_Common_Path_Suffix_PtrA(pciliFirst), -1,
                         szWideCommonPathSuffixFirst, MAX_PATH);
   }
   else
   {
      pszWideCommonPathSuffixFirst = ILI_Common_Path_Suffix_Ptr(pciliFirst);
   }

   if (pciliSecond->ucbHeaderSize == SIZEOF(ILINKINFOA))
   {
      pszWideCommonPathSuffixSecond = szWideCommonPathSuffixSecond;
      MultiByteToWideChar(CP_ACP, 0,
                         ILI_Common_Path_Suffix_PtrA(pciliSecond), -1,
                         szWideCommonPathSuffixSecond, MAX_PATH);
   }
   else
   {
      pszWideCommonPathSuffixSecond = ILI_Common_Path_Suffix_Ptr(pciliSecond);
   }
#else
   if (cr == CR_EQUAL)
      cr = ComparePathStrings(ILI_Common_Path_Suffix_Ptr(pciliFirst),
                              ILI_Common_Path_Suffix_Ptr(pciliSecond));
#endif

   ASSERT(IsValidCOMPARISONRESULT(cr));

   return(cr);
}


/*
** CompareILinkInfoVolumes()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE COMPARISONRESULT CompareILinkInfoVolumes(PCILINKINFO pciliFirst,
                                                 PCILINKINFO pciliSecond)
{
   COMPARISONRESULT cr;
   BOOL bFirstLocal;
   BOOL bFirstRemote;
   BOOL bSecondLocal;
   BOOL bSecondRemote;

   ASSERT(IS_VALID_STRUCT_PTR(pciliFirst, CILINKINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pciliSecond, CILINKINFO));

   bFirstLocal = IS_FLAG_SET(((PCILINKINFO)pciliFirst)->dwFlags,
                             ILI_FL_LOCAL_INFO_VALID);
   bFirstRemote = IS_FLAG_SET(((PCILINKINFO)pciliFirst)->dwFlags,
                              ILI_FL_REMOTE_INFO_VALID);

   bSecondLocal = IS_FLAG_SET(((PCILINKINFO)pciliSecond)->dwFlags,
                              ILI_FL_LOCAL_INFO_VALID);
   bSecondRemote = IS_FLAG_SET(((PCILINKINFO)pciliSecond)->dwFlags,
                               ILI_FL_REMOTE_INFO_VALID);

   if (bFirstLocal && bSecondLocal)
      /* First and second have local information. */
      cr = CompareVolumeIDs(ILI_Volume_ID_Ptr((PCILINKINFO)pciliFirst),
                            ILI_Volume_ID_Ptr((PCILINKINFO)pciliSecond));
   else if (bFirstRemote && bSecondRemote)
      /* First and second have remote information. */
      cr = CompareCNRLinks(ILI_CNR_Link_Ptr((PCILINKINFO)pciliFirst),
                           ILI_CNR_Link_Ptr((PCILINKINFO)pciliSecond));
   else
   {
      /*
       * One contains only valid local information and the other contains only
       * valid remote information.
       */

      ASSERT(! ((pciliFirst->dwFlags & (ILI_FL_LOCAL_INFO_VALID | ILI_FL_REMOTE_INFO_VALID)) &
                (pciliSecond->dwFlags & (ILI_FL_LOCAL_INFO_VALID | ILI_FL_REMOTE_INFO_VALID))));

      /* By fiat, local only < remote only. */

      if (bFirstLocal)
         /*
          * First has only local information.  Second has only remote
          * information.
          */
         cr = CR_FIRST_SMALLER;
      else
         /*
          * First has only remote information.  Second has only local
          * information.
          */
         cr = CR_FIRST_LARGER;
   }

   return(cr);
}


/*
** CheckCombinedPathLen()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CheckCombinedPathLen(LPCTSTR pcszBase, LPCTSTR pcszSuffix)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRING_PTR(pcszBase, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszSuffix, CSTR));

   bResult = EVAL(lstrlen(pcszBase) + lstrlen(pcszSuffix) < MAX_PATH_LEN);

   if (bResult)
   {
      TCHAR rgchCombinedPath[MAX_PATH_LEN + 1];

      lstrcpy(rgchCombinedPath, pcszBase);
      CatPath(rgchCombinedPath, pcszSuffix);

      bResult = EVAL(lstrlen(rgchCombinedPath) < MAX_PATH_LEN);
   }

   return(bResult);
}


/*
** GetILinkInfoData()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL GetILinkInfoData(PCILINKINFO pcili, LINKINFODATATYPE lidt,
                              PCVOID *ppcvData)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));
   ASSERT(IsValidLINKINFODATATYPE(lidt));
   ASSERT(IS_VALID_WRITE_PTR(ppcvData, PCVOID));

   switch (lidt)
   {
      case LIDT_VOLUME_SERIAL_NUMBER:
         if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
            bResult = GetVolumeSerialNumber(ILI_Volume_ID_Ptr(pcili),
                                            (PCDWORD *)ppcvData);
         break;

      case LIDT_DRIVE_TYPE:
         if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
            bResult = GetVolumeDriveType(ILI_Volume_ID_Ptr(pcili),
                                         (PCUINT *)ppcvData);
         break;

      case LIDT_VOLUME_LABEL:
         if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
            bResult = GetVolumeLabel(ILI_Volume_ID_Ptr(pcili),
                                     (LPCSTR *)ppcvData);
         break;

      case LIDT_VOLUME_LABELW:
#ifdef UNICODE
         if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
            bResult = GetVolumeLabelW(ILI_Volume_ID_Ptr(pcili),
                                     (LPCTSTR *)ppcvData);
#endif
         break;

      case LIDT_LOCAL_BASE_PATH:
         if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
         {
            *ppcvData = ILI_Local_Base_Path_PtrA(pcili);
            bResult = TRUE;
         }
         break;

      case LIDT_LOCAL_BASE_PATHW:
#ifdef UNICODE
         if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
         {
            if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
               *ppcvData = NULL;
            else
               *ppcvData = ILI_Local_Base_Path_PtrW(pcili);
            bResult = TRUE;
         }
#endif
         break;

      case LIDT_NET_TYPE:
         if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
            bResult = GetCNRNetType(ILI_CNR_Link_Ptr(pcili),
                                    (PCDWORD *)ppcvData);
         break;

      case LIDT_NET_RESOURCE:
         if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
            bResult = GetCNRName(ILI_CNR_Link_Ptr(pcili),
                                 (LPCSTR *)ppcvData);
         break;

      case LIDT_NET_RESOURCEW:
#ifdef UNICODE
         if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
            bResult = GetCNRNameW(ILI_CNR_Link_Ptr(pcili),
                                 (LPCWSTR *)ppcvData);
#endif
         break;

      case LIDT_REDIRECTED_DEVICE:
         if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
            bResult = GetLastRedirectedDevice(ILI_CNR_Link_Ptr(pcili),
                                              (LPCSTR *)ppcvData);
         break;

      case LIDT_REDIRECTED_DEVICEW:
#ifdef UNICODE
         if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
            bResult = GetLastRedirectedDeviceW(ILI_CNR_Link_Ptr(pcili),
                                              (LPCWSTR *)ppcvData);
#endif
         break;

      case LIDT_COMMON_PATH_SUFFIX:
         *ppcvData = ILI_Common_Path_Suffix_PtrA(pcili);
         bResult = TRUE;
         break;

      case LIDT_COMMON_PATH_SUFFIXW:
#ifdef UNICODE
         if (pcili->ucbHeaderSize == sizeof(ILINKINFOA))
         {
            *ppcvData = NULL;
         }
         else
         {
            *ppcvData = ILI_Common_Path_Suffix_PtrW(pcili);
         }
         bResult = TRUE;
#endif
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("GetILinkInfoData(): Bad LINKINFODATATYPE %d."),
                    lidt));
         break;
   }

   return(bResult);
}


/*
** DisconnectILinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL DisconnectILinkInfo(PCILINKINFO pcili)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));

   return(DisconnectFromCNR(ILI_CNR_Link_Ptr(pcili)));
}


#if defined(DEBUG) || defined(EXPV)

/*
** IsValidLINKINFODATATYPE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidLINKINFODATATYPE(LINKINFODATATYPE lidt)
{
   BOOL bResult;

   switch (lidt)
   {
      case LIDT_VOLUME_SERIAL_NUMBER:
      case LIDT_DRIVE_TYPE:
      case LIDT_VOLUME_LABEL:
      case LIDT_VOLUME_LABELW:
      case LIDT_LOCAL_BASE_PATH:
      case LIDT_LOCAL_BASE_PATHW:
      case LIDT_NET_TYPE:
      case LIDT_NET_RESOURCE:
      case LIDT_REDIRECTED_DEVICE:
      case LIDT_COMMON_PATH_SUFFIX:
      case LIDT_COMMON_PATH_SUFFIXW:
         bResult = TRUE;
         break;

      default:
         bResult = FALSE;
         ERROR_OUT((TEXT("IsValidLINKINFODATATYPE(): Invalid LINKINFODATATYPE %d."),
                    lidt));
         break;
   }

   return(bResult);
}

#endif


#if defined(DEBUG) || defined(VSTF)

/*
** CheckILIFlags()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CheckILIFlags(PCILINKINFO pcili)
{
   return(FLAGS_ARE_VALID(pcili->dwFlags, ALL_ILINKINFO_FLAGS) &&
          (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID) ||
           IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID)));
}


/*
** CheckILICommonPathSuffix()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CheckILICommonPathSuffix(PCILINKINFO pcili)
{
   return(IS_VALID_STRING_PTRA(ILI_Common_Path_Suffix_PtrA(pcili), CSTR) &&
          EVAL(IsContained(pcili, pcili->li.ucbSize,
                           ILI_Common_Path_Suffix_PtrA(pcili),
                           lstrlenA(ILI_Common_Path_Suffix_PtrA(pcili)))) &&
          EVAL(! IS_SLASH(*ILI_Common_Path_Suffix_PtrA(pcili))));
}


/*
** CheckILILocalInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CheckILILocalInfo(PCILINKINFO pcili)
{
#ifdef UNICODE
   WCHAR   szWideLocalBasePath[MAX_PATH];
   WCHAR   szWideCommonPathSuffix[MAX_PATH];
   LPWSTR  pszWideLocalBasePath;
   LPWSTR  pszWideCommonPathSuffix;

   if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
      return FALSE;
   if (!IS_VALID_STRUCT_PTR(ILI_Volume_ID_Ptr(pcili), CVOLUMEID))
      return FALSE;
   if (!EVAL(IsContained(pcili, pcili->li.ucbSize,ILI_Volume_ID_Ptr(pcili),
                        GetVolumeIDLen(ILI_Volume_ID_Ptr(pcili)))))
      return FALSE;

   if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
   {
      pszWideLocalBasePath = szWideLocalBasePath;
      MultiByteToWideChar(CP_ACP, 0,
                          ILI_Local_Base_Path_PtrA(pcili), -1,
                          szWideLocalBasePath, MAX_PATH);

      pszWideCommonPathSuffix = szWideCommonPathSuffix;
      MultiByteToWideChar(CP_ACP, 0,
                          ILI_Common_Path_Suffix_PtrA(pcili), -1,
                          szWideCommonPathSuffix, MAX_PATH);

   }
   else
   {
      pszWideLocalBasePath = ILI_Local_Base_Path_Ptr(pcili);
      pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
   }

   if (!EVAL(IsDrivePath(pszWideLocalBasePath)))
      return FALSE;
   if (!EVAL(IsContained(pcili, pcili->li.ucbSize,
                           ILI_Local_Base_Path_PtrA(pcili),
                           lstrlenA(ILI_Local_Base_Path_PtrA(pcili)))))
      return FALSE;
   if (!EVAL(CheckCombinedPathLen(pszWideLocalBasePath,
                                  pszWideCommonPathSuffix)))
      return FALSE;

   return TRUE;
#else
   return(IS_FLAG_CLEAR(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID) ||

           /* Check volume ID. */

          (IS_VALID_STRUCT_PTR(ILI_Volume_ID_Ptr(pcili), CVOLUMEID) &&
           EVAL(IsContained(pcili, pcili->li.ucbSize,
                            ILI_Volume_ID_Ptr(pcili),
                            GetVolumeIDLen(ILI_Volume_ID_Ptr(pcili)))) &&

           /* Check local base path. */

           EVAL(IsDrivePath(ILI_Local_Base_Path_Ptr(pcili))) &&
           EVAL(IsContained(pcili, pcili->li.ucbSize,
                            ILI_Local_Base_Path_PtrA(pcili),
                            lstrlen(ILI_Local_Base_Path_Ptr(pcili)))) &&
           EVAL(CheckCombinedPathLen(ILI_Local_Base_Path_Ptr(pcili),
                                   ILI_Common_Path_Suffix_Ptr(pcili)))));
#endif
}


/*
** CheckILIRemoteInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CheckILIRemoteInfo(PCILINKINFO pcili)
{
   BOOL bResult;

   if (IS_FLAG_CLEAR(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
      bResult = TRUE;
   else
   {
      /* Check CNR link. */

      if (IS_VALID_STRUCT_PTR(ILI_CNR_Link_Ptr(pcili), CCNRLINK) &&
          EVAL(IsContained(pcili, pcili->li.ucbSize,
                           ILI_CNR_Link_Ptr(pcili),
                           GetCNRLinkLen(ILI_CNR_Link_Ptr(pcili)))))
      {
         TCHAR rgchRemoteBasePath[MAX_PATH_LEN];
#ifdef UNICODE
         WCHAR szWideCommonPathSuffix[MAX_PATH];
         LPWSTR pszWideCommonPathSuffix;
#endif
         /* RAIDRAID: (15724) This is broken for non-UNC CNR names. */

         GetRemotePathFromCNRLink(ILI_CNR_Link_Ptr(pcili), rgchRemoteBasePath);

#ifdef UNICODE
         if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
         {
            pszWideCommonPathSuffix = szWideCommonPathSuffix;
            MultiByteToWideChar(CP_ACP, 0,
                                ILI_Common_Path_Suffix_PtrA(pcili), -1,
                                szWideCommonPathSuffix, MAX_PATH);
         }
         else
         {
            pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
         }
         bResult = EVAL(CheckCombinedPathLen(rgchRemoteBasePath,
                                          pszWideCommonPathSuffix));
#else
         bResult = EVAL(CheckCombinedPathLen(rgchRemoteBasePath,
                                          ILI_Common_Path_Suffix_Ptr(pcili)));
#endif

      }
      else
         bResult = FALSE;
   }

   return(bResult);
}


/*
** IsValidPCLINKINFO()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCLINKINFO(PCLINKINFO pcli)
{
   return(IS_VALID_STRUCT_PTR((PCILINKINFO)pcli, CILINKINFO));
}


/*
** IsValidPCILINKINFO()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCILINKINFO(PCILINKINFO pcili)
{
   /*
    * A "valid" LinkInfo structure has the following characteristics:
    *
    * 1) entire structure is readable
    * 2) size of ILINKINFO header structure >= SIZEOF(CILINKINFO)
    * 3) flags are valid
    * 4) either local info or remote info or both are valid
    * 5) contained structures and strings are valid and are entirely contained
    *    in LinkInfo structure
    * 6) lstrlen() of combined paths < MAX_PATH_LEN
    */

   return(IS_VALID_READ_PTR(pcili, CILINKINFO) &&
          IS_VALID_READ_BUFFER_PTR(pcili, CILINKINFO, pcili->li.ucbSize) &&
          EVAL(pcili->ucbHeaderSize >= SIZEOF(*pcili)) &&
          EVAL(CheckILIFlags(pcili)) &&
          EVAL(CheckILICommonPathSuffix(pcili)) &&
          EVAL(CheckILILocalInfo(pcili)) &&
          EVAL(CheckILIRemoteInfo(pcili)));
}


#ifdef SKIP_OLD_LINKINFO_QUIETLY

/*
** IsNewLinkInfoHackCheck()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsNewLinkInfoHackCheck(PCILINKINFO pcili)
{
   BOOL bResult = FALSE;

   /*
    * HACKHACK: We have added the ucbHeaderSize field to the ILINKINFO
    * structure.  The second DWORD in old ILINKINFO structures was the dwFlags
    * field.  We detect an old ILINKINFO structure as one whose ucbHeaderSize
    * field is not the value we expect.
    *
    * HACKHACK: We have added dwFlags and chLastRedirectedDrive to the ICRNLINK
    * structure.  The second DWORD in old ICNRLINK structures was the
    * ucbNetNameOffset field.  We detect an old ICNRLINK structure as one whose
    * old ucbNetNameOffset field was 8, since old ICRNLINK structures only
    * contain ucbSize, ucbNetNameOffset, and the CNR name string.
    *
    * HACKHACK: We have removed the dwFlags field from the IVOLUMEID structure.
    * The second DWORD in old IVOLUMEID structures was the dwFlags field.  We
    * detect an old IVOLUMEID structure as one whose old dwFlags field was 1,
    * representing the only old IVOLUMEID flag IVOLID_FL_VALID_VOLUME_INFO.
    */

   ASSERT((PDWORD)&(pcili->ucbHeaderSize) == ((PDWORD)(pcili)) + 1);

   if (IS_VALID_READ_PTR(pcili, CILINKINFO))
   {
      if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA
          || pcili->ucbHeaderSize == SIZEOF(ILINKINFOW) )
      {
         if (IS_FLAG_CLEAR(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID) ||
             *((PDWORD)(ILI_CNR_Link_Ptr(pcili)) + 1) != 8)
         {
            if (IS_FLAG_CLEAR(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID) ||
                *((PDWORD)(ILI_Volume_ID_Ptr(pcili)) + 1) != 1)
               bResult = TRUE;
            else
               WARNING_OUT((TEXT("IsNewLinkInfoHackCheck(): Failing LinkInfo API called on old LinkInfo structure with dwFlags field in IVOLUMEID sub-structure.")));
         }
         else
            WARNING_OUT((TEXT("IsNewLinkInfoHackCheck(): Failing LinkInfo API called on old LinkInfo structure without dwFlags and chLastRedirectedDrive fields in ICNRLINK sub-structure.")));
      }
      else
         WARNING_OUT((TEXT("IsNewLinkInfoHackCheck(): Failing LinkInfo API called on old LinkInfo structure without ucbHeaderSize field.")));
   }

   return(bResult);
}

#endif

#endif


#ifdef DEBUG

/*
** DumpILinkInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void DumpILinkInfo(PCILINKINFO pcili)
{
#ifdef UNICODE
   WCHAR   szWideCommonPathSuffix[MAX_PATH];
   LPWSTR  pszWideCommonPathSuffix;
#endif

   ASSERT(IS_VALID_STRUCT_PTR(pcili, CILINKINFO));

   PLAIN_TRACE_OUT((TEXT("%s[LinkInfo] ucbSize = %#x"),
                    INDENT_STRING,
                    pcili->li.ucbSize));
   PLAIN_TRACE_OUT((TEXT("%s%s[ILinkInfo] ucbHeaderSize = %#x"),
                    INDENT_STRING,
                    INDENT_STRING,
                    pcili->ucbHeaderSize));
   PLAIN_TRACE_OUT((TEXT("%s%s[ILinkInfo] dwFLags = %#08lx"),
                    INDENT_STRING,
                    INDENT_STRING,
                    pcili->dwFlags));

   if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_LOCAL_INFO_VALID))
   {
#ifdef UNICODE
      WCHAR   szWideLocalBasePath[MAX_PATH];
      LPWSTR  pszWideLocalBasePath;
#endif
      DumpVolumeID(ILI_Volume_ID_Ptr(pcili));
#ifdef UNICODE
      if (pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
      {
         pszWideLocalBasePath = szWideLocalBasePath;
         MultiByteToWideChar(CP_ACP, 0,
                             ILI_Local_Base_Path_PtrA(pcili), -1,
                             szWideLocalBasePath, MAX_PATH);
      }
      else
      {
         pszWideLocalBasePath = ILI_Local_Base_Path_Ptr(pcili);
      }
      PLAIN_TRACE_OUT((TEXT("%s%s[ILinkInfo] local base path \"%s\""),
                       INDENT_STRING,
                       INDENT_STRING,
                       pszWideLocalBasePath));
#else
      PLAIN_TRACE_OUT((TEXT("%s%s[ILinkInfo] local base path \"%s\""),
                       INDENT_STRING,
                       INDENT_STRING,
                       ILI_Local_Base_Path_Ptr(pcili)));
#endif
   }

   if (IS_FLAG_SET(pcili->dwFlags, ILI_FL_REMOTE_INFO_VALID))
      DumpCNRLink(ILI_CNR_Link_Ptr(pcili));

#ifdef UNICODE
   if ( pcili->ucbHeaderSize == SIZEOF(ILINKINFOA))
   {
     pszWideCommonPathSuffix = szWideCommonPathSuffix;
     MultiByteToWideChar(CP_ACP, 0,
                         ILI_Common_Path_Suffix_PtrA(pcili), -1,
                         szWideCommonPathSuffix, MAX_PATH);

   }
   else
   {
      pszWideCommonPathSuffix = ILI_Common_Path_Suffix_Ptr(pcili);
   }

   PLAIN_TRACE_OUT((TEXT("%s%s[ILinkInfo] common path suffix \"%s\""),
                    INDENT_STRING,
                    INDENT_STRING,
                    pszWideCommonPathSuffix));
#else
   PLAIN_TRACE_OUT((TEXT("%s%s[ILinkInfo] common path suffix \"%s\""),
                    INDENT_STRING,
                    INDENT_STRING,
                    ILI_Common_Path_Suffix_Ptr(pcili)));
#endif
   return;
}

#endif


/***************************** Exported Functions ****************************/


/******************************************************************************

@doc LINKINFOAPI

@func BOOL | CreateLinkInfo | Creates a LinkInfo structure for a path.

@parm PCSTR | pcszPath | A pointer to the path string that a LinkInfo structure
is to be created for.

@parm PLINKINFO * | ppli | A pointer to a PLINKINFO to be filled in with a
pointer to the new LinkInfo structure.  *ppli is only valid if TRUE is
returned.

@rdesc If a LinkInfo structure was created successfully, TRUE is returned, and
*ppli contains a pointer to the new LinkInfo structure.  Otherwise, a LinkInfo
structure was not created successfully, and *ppli is undefined.  The reason for
failure may be determined by calling GetLastError().

@comm Once the caller is finshed with the LinkInfo structure returned by
CreateLinkInfo(), DestroyLinkInfo() should be called to free the LinkInfo
structure.<nl>
The contents of the LinkInfo structure returned are opaque to the caller, with
the exception of the first field of the LinkInfo structure.  The first field of
the LinkInfo structure, ucbSize, is a UINT containing the size of the LinkInfo
structure in bytes, including the ucbSize field.<nl>
The LinkInfo structure is created in memory that is private to the LinkInfo
APIs.  The returned LinkInfo structure should be copied into the caller's
memory, and the DestroyLinkInfo() should be called to free the LinkInfo
structure from the LinkInfo APIs' private memory.

@xref DestroyLinkInfo

******************************************************************************/

LINKINFOAPI BOOL WINAPI CreateLinkInfo(LPCTSTR pcszPath, PLINKINFO *ppli)
{
   BOOL bResult;

   DebugEntry(CreateLinkInfo);

#ifdef EXPV
   /* Verify parameters. */

   if (IS_VALID_STRING_PTR(pcszPath, CSTR) &&
       IS_VALID_WRITE_PTR(ppli, PLINKINFO))
#endif
   {
      bResult = CreateILinkInfo(pcszPath, (PILINKINFO *)ppli);

#ifdef DEBUG

      if (bResult)
      {
         TRACE_OUT((TEXT("CreateLinkInfo(): LinkInfo created for path %s:"),
                    pcszPath));
         DumpILinkInfo(*(PILINKINFO *)ppli);
      }

#endif

   }
#ifdef EXPV
   else
   {
      SetLastError(ERROR_INVALID_PARAMETER);
      bResult = FALSE;
   }
#endif

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*ppli, CLINKINFO));

   DebugExitBOOL(CreateLinkInfo, bResult);

   return(bResult);
}

#ifdef UNICODE
LINKINFOAPI BOOL WINAPI CreateLinkInfoA(LPCSTR pcszPath, PLINKINFO *ppli)
{
    LPWSTR  lpwstr;
    UINT    cchPath;

    cchPath = lstrlenA(pcszPath) + 1;

    lpwstr = (LPWSTR)_alloca(cchPath*SIZEOF(WCHAR));

    if ( MultiByteToWideChar( CP_ACP, 0,
                              pcszPath, cchPath,
                              lpwstr, cchPath) == 0)
    {
        return FALSE;
    }
    else
    {
        return CreateLinkInfo(lpwstr,ppli);
    }
}
#endif

/******************************************************************************

@doc LINKINFOAPI

@func void | DestroyLinkInfo | Destroys a LinkInfo structure created by
CreateLinkInfo().

@parm PLINKINFO | pli | A pointer to the LinkInfo structure to be destroyed.

@xref CreateLinkInfo

******************************************************************************/

LINKINFOAPI void WINAPI DestroyLinkInfo(PLINKINFO pli)
{
   DebugEntry(DestroyLinkInfo);

#ifdef EXPV
   /* Verify parameters. */

   if (
#ifdef SKIP_OLD_LINKINFO_QUIETLY
       IsNewLinkInfoHackCheck((PCILINKINFO)pli) &&
#endif
       IS_VALID_STRUCT_PTR(pli, CLINKINFO))
#endif
   {
      DestroyILinkInfo((PILINKINFO)pli);
   }

   DebugExitVOID(DestroyLinkInfo);

   return;
}


/******************************************************************************

@doc LINKINFOAPI

@func int | CompareLinkInfoReferents | Compares the referents of two LinkInfo
structures.

@parm PCLINKINFO | pcliFirst | A pointer to the first LinkInfo structure whose
referent is to be compared.

@parm PCLINKINFO | pcliSecond | A pointer to the second LinkInfo structure
whose referent is to be compared.

@rdesc If the referent of the first LinkInfo structure is less than the
referent of the second LinkInfo structure, a negative value is returned.  If
the referent of the first LinkInfo structure is the same as the referent of the
second LinkInfo structure, zero is returned.  If the referent of the first
LinkInfo structure is larger than the referent of the second LinkInfo
structure, a positive value is returned.  An invalid LinkInfo structure is
considered to have a referent that is less than the referent of any valid
LinkInfo structure.  All invalid LinkInfo structures are considered to have the
same referent.

@comm The value returned is actually a COMPARISONRESULT, for clients that
understand COMPARISONRESULTs, like SYNCENG.DLL.

@xref CompareLinkInfoVolumes

******************************************************************************/

LINKINFOAPI int WINAPI CompareLinkInfoReferents(PCLINKINFO pcliFirst,
                                                PCLINKINFO pcliSecond)
{
   COMPARISONRESULT cr;
   BOOL bFirstValid;
   BOOL bSecondValid;

   DebugEntry(CompareLinkInfoReferents);

   bFirstValid = (
#ifdef SKIP_OLD_LINKINFO_QUIETLY
                  IsNewLinkInfoHackCheck((PCILINKINFO)pcliFirst) &&
#endif
                  IS_VALID_STRUCT_PTR(pcliFirst, CLINKINFO));

   bSecondValid = (
#ifdef SKIP_OLD_LINKINFO_QUIETLY
                  IsNewLinkInfoHackCheck((PCILINKINFO)pcliSecond) &&
#endif
                  IS_VALID_STRUCT_PTR(pcliSecond, CLINKINFO));

   if (bFirstValid)
   {
      if (bSecondValid)
         cr = CompareILinkInfoReferents((PCILINKINFO)pcliFirst,
                                        (PCILINKINFO)pcliSecond);
      else
         cr = CR_FIRST_LARGER;
   }
   else
   {
      if (bSecondValid)
         cr = CR_FIRST_SMALLER;
      else
         cr = CR_EQUAL;
   }

   ASSERT(IsValidCOMPARISONRESULT(cr));

   DebugExitCOMPARISONRESULT(CompareLinkInfoReferents, cr);

   return(cr);
}


/******************************************************************************

@doc LINKINFOAPI

@func int | CompareLinkInfoVolumes | Compares the volumes of the referents of
two LinkInfo structures.

@parm PCLINKINFO | pcliFirst | A pointer to the first LinkInfo structure whose
referent's volume is to be compared.

@parm PCLINKINFO | pcliSecond | A pointer to the second LinkInfo structure
referent's volume is to be compared.

@rdesc If the volume of the referent of the first LinkInfo structure is less
than the volume of the referent of the second LinkInfo structure, a negative
value is returned.  If the volume of the referent of the first LinkInfo
structure is the same as the volume of the referent of the second LinkInfo
structure, zero is returned.  If the volume of the referent of the first
LinkInfo structure is larger than the volume of the referent of the second
LinkInfo structure, a positive value is returned.  An invalid LinkInfo
structure is considered to have a referent's volume that is less than the
referent's volume of any valid LinkInfo structure.  All invalid LinkInfo
structures are considered to have the same referent's volume.

@comm The value returned is actually a COMPARISONRESULT, for clients that
understand COMPARISONRESULTs, like SYNCENG.DLL.

@xref CompareLinkInfoReferents

******************************************************************************/

LINKINFOAPI int WINAPI CompareLinkInfoVolumes(PCLINKINFO pcliFirst,
                                              PCLINKINFO pcliSecond)
{
   COMPARISONRESULT cr;
   BOOL bFirstValid;
   BOOL bSecondValid;

   DebugEntry(CompareLinkInfoVolumes);

   bFirstValid = (
#ifdef SKIP_OLD_LINKINFO_QUIETLY
                  IsNewLinkInfoHackCheck((PCILINKINFO)pcliFirst) &&
#endif
                  IS_VALID_STRUCT_PTR(pcliFirst, CLINKINFO));

   bSecondValid = (
#ifdef SKIP_OLD_LINKINFO_QUIETLY
                  IsNewLinkInfoHackCheck((PCILINKINFO)pcliSecond) &&
#endif
                  IS_VALID_STRUCT_PTR(pcliSecond, CLINKINFO));

   if (bFirstValid)
   {
      if (bSecondValid)
         cr = CompareILinkInfoVolumes((PCILINKINFO)pcliFirst,
                                      (PCILINKINFO)pcliSecond);
      else
         cr = CR_FIRST_LARGER;
   }
   else
   {
      if (bSecondValid)
         cr = CR_FIRST_SMALLER;
      else
         cr = CR_EQUAL;
   }

   ASSERT(IsValidCOMPARISONRESULT(cr));

   DebugExitCOMPARISONRESULT(CompareLinkInfoVolumes, cr);

   return(cr);
}


/******************************************************************************

@doc LINKINFOAPI

@func BOOL | ResolveLinkInfo | Resolves a LinkInfo structure into a file system
path on an available volume.

@parm PCLINKINFO | pcli | A pointer to the LinkInfo structure to be resolved.

@parm PSTR | pszResolvedPathBuf | A pointer to a buffer to be filled in with
the path resolved to the LinkInfo structure's referent.

@parm DWORD | dwInFlags | A bit mask of flags.  This parameter may be any
combination of the following values:

@flag RLI_IFL_CONNECT | If set, connect to the referent's parent connectable
network resource if necessary.  If clear, no connection is established.

@flag RLI_IFL_ALLOW_UI | If set, interaction with the user is permitted, and
the hwndOwner parameter identifies the parent window to be used for any ui
required.  If clear, interaction with the user is not permitted.

@flag RLI_IFL_REDIRECT | If set, the resolved path is a redirected logical
device path.  If clear, the resolved path is only a redirected logical device
path if the RLI_IFL_CONNECT flag is set, and the network requires a redirected
logical device path to make a connection.

@flag RLI_IFL_UPDATE | If set and the source LinkInfo structure needs updating,
RLI_OFL_UPDATED will be set in *pdwOutFlags and *ppliUpdated will point to an
updated LinkInfo structure.  If clear, RLI_OFL_UPDATED will be clear in
*pdwOutFlags and *ppliUpdated is undefined.

@flag RLI_IFL_LOCAL_SEARCH | If set, first the last known logical device for
the referent's volume is checked for the volume, followed by all other local
logical devices that handle the referent's volume's media type.  If clear, only
the last known logical device for the referent's volume is checked for the
volume.

@parm HWND | hwndOwner | A handle to the parent window to be used to bring up
any ui required.  This parameter is only used if RLI_IFL_ALLOW_UI is set in
dwInFlags.  Otherwise, it is ignored.

@parm PDWORD | pdwOutFlags | A pointer to a DWORD to be filled in with a bit
mask of flags. *pdwOutFlags is only valid if TRUE is returned.  *pdwOutFlags
may be any combination of the following values:

@flag RLI_OFL_UPDATED | Only set if RLI_IFL_UPDATE was set in dwInFlags.  If
set, the source LinkInfo structure needed updating, and *ppliUpdated points to
an updated LinkInfo structure.  If clear, either RLI_IFL_UPDATE was clear in
dwInFlags or the source LinkInfo structure didn't need updating, and
*ppliUpdated is undefined.

@parm PLINKINFO * | ppliUpdated | If RLI_IFL_UPDATE is set in dwInFlags,
ppliUpdated is a pointer to a PLINKINFO to be filled in with a pointer to an
updated LinkInfo structure, if necessary.  If RLI_IFL_UPDATE is clear in
dwInFlags, ppliUpdated is ignored.  *ppliUpdated is only valid if
RLI_OFL_UPDATED is set in *pdwOutFlags

@rdesc If the LinkInfo was resolved to a path on an available successfully,
TRUE is returned, pszResolvedPathBuf's buffer is filled in with a file system
path to the LinkInfo structure's referent, and *pdwOutFlags is filled in as
described above.  Otherwise, FALSE is returned, the contents of pszResolved's
buffer are undefined, and the contents of *pdwOutFlags are undefined.  The
reason for failure may be determined by calling GetLastError().

@comm Once the caller is finshed with any new, updated LinkInfo structure
returned by ResolveLinkInfo(), DestroyLinkInfo() should be called to free the
LinkInfo structure.

@xref DestroyLinkInfo DisconnectLinkInfo

******************************************************************************/

LINKINFOAPI BOOL WINAPI ResolveLinkInfo(PCLINKINFO pcli,
                                        LPTSTR pszResolvedPathBuf,
                                        DWORD dwInFlags, HWND hwndOwner,
                                        PDWORD pdwOutFlags,
                                        PLINKINFO *ppliUpdated)
{
   BOOL bResult;

   DebugEntry(ResolveLinkInfo);

#ifdef EXPV
   /* Verify parameters. */

   if (
#ifdef SKIP_OLD_LINKINFO_QUIETLY
       IsNewLinkInfoHackCheck((PCILINKINFO)pcli) &&
#endif
       IS_VALID_STRUCT_PTR(pcli, CLINKINFO) &&
       IS_VALID_WRITE_BUFFER_PTR(pszResolvedPathBuf, STR, MAX_PATH_LEN) &&
       FLAGS_ARE_VALID(dwInFlags, ALL_RLI_IFLAGS) &&
       (IS_FLAG_CLEAR(dwInFlags, RLI_IFL_ALLOW_UI) ||
        IS_VALID_HANDLE(hwndOwner, WND)) &&
       IS_VALID_WRITE_PTR(pdwOutFlags, DWORD) &&
       (IS_FLAG_CLEAR(dwInFlags, RLI_IFL_UPDATE) ||
        IS_VALID_WRITE_PTR(ppliUpdated, PLINKINFO)) &&
       EVAL(IS_FLAG_CLEAR(dwInFlags, RLI_IFL_TEMPORARY) ||
            IS_FLAG_SET(dwInFlags, RLI_IFL_CONNECT)))
#endif
   {
      DWORD dwTempFlags;

      *pdwOutFlags = 0;

      bResult = ResolveILinkInfo((PCILINKINFO)pcli, pszResolvedPathBuf,
                                 dwInFlags, hwndOwner, &dwTempFlags);

      if (bResult)
      {
         *pdwOutFlags |= dwTempFlags;

         if (IS_FLAG_SET(dwInFlags, RLI_IFL_UPDATE))
         {
            bResult = UpdateILinkInfo((PCILINKINFO)pcli, pszResolvedPathBuf,
                                      &dwTempFlags,
                                      (PILINKINFO *)ppliUpdated);

            if (bResult)
               *pdwOutFlags |= dwTempFlags;
         }
      }

#ifdef DEBUG

      TRACE_OUT((TEXT("ResolveLinkInfo(): flags %#08lx, given LinkInfo:"),
                 dwInFlags));
      DumpILinkInfo((PCILINKINFO)pcli);

      if (bResult)
      {
         TRACE_OUT((TEXT("ResolveLinkInfo(): Resolved path %s with flags %#08lx."),
                    pszResolvedPathBuf,
                    *pdwOutFlags));

         if (IS_FLAG_SET(*pdwOutFlags, RLI_OFL_UPDATED))
         {
            ASSERT(IS_FLAG_SET(dwInFlags, RLI_IFL_UPDATE));

            TRACE_OUT((TEXT("UpdateLinkInfo(): updated LinkInfo:")));
            DumpILinkInfo(*(PILINKINFO *)ppliUpdated);
         }
         else
         {
            if (IS_FLAG_SET(dwInFlags, RLI_IFL_UPDATE))
               TRACE_OUT((TEXT("UpdateLinkInfo(): No update required.")));
            else
               TRACE_OUT((TEXT("UpdateLinkInfo(): No update requested.")));
         }
      }
      else
         WARNING_OUT((TEXT("ResolveLinkInfo(): Referent's volume is unavailable.")));

#endif

   }
#ifdef EXPV
   else
   {
      SetLastError(ERROR_INVALID_PARAMETER);
      bResult = FALSE;
   }
#endif

   ASSERT(! bResult ||
          (FLAGS_ARE_VALID(*pdwOutFlags, ALL_RLI_OFLAGS) &&
           EVAL(IsCanonicalPath(pszResolvedPathBuf)) &&
           EVAL(! (IS_FLAG_CLEAR(dwInFlags, RLI_IFL_UPDATE) &&
                   IS_FLAG_SET(*pdwOutFlags, RLI_OFL_UPDATED))) &&
           (IS_FLAG_CLEAR(*pdwOutFlags, RLI_OFL_UPDATED) ||
            IS_VALID_STRUCT_PTR(*ppliUpdated, CLINKINFO))));

   DebugExitBOOL(ResolveLinkInfo, bResult);

   return(bResult);
}

#ifdef UNICODE
LINKINFOAPI BOOL WINAPI ResolveLinkInfoA(PCLINKINFO pcli,
                                        LPSTR pszResolvedPathBuf,
                                        DWORD dwInFlags, HWND hwndOwner,
                                        PDWORD pdwOutFlags,
                                        PLINKINFO *ppliUpdated)
{
    WCHAR   szWideResolvedPathBuf[MAX_PATH];
    BOOL    fResolved;

    fResolved = ResolveLinkInfo(pcli,
                                szWideResolvedPathBuf,
                                dwInFlags, hwndOwner, pdwOutFlags, ppliUpdated);
    if ( fResolved )
    {
        if ( WideCharToMultiByte( CP_ACP, 0,
                                  szWideResolvedPathBuf, -1,
                                  pszResolvedPathBuf, MAX_PATH,
                                  NULL, NULL ) == 0)
        {
            return FALSE;
        }
    }
    return fResolved;
}
#endif

/******************************************************************************

@doc LINKINFOAPI

@func BOOL | DisconnectLinkInfo | Cancels a connection to a net resource
established by a previous call to ResolveLinkInfo().  DisconnectLinkInfo()
should only be called if RLI_OFL_DISCONNECT was set in *pdwOutFlags on return
from ResolveLinkInfo() on the given LinkInfo structure, or its updated
equivalent.

@parm PCLINKINFO | pcli | A pointer to the LinkInfo structure whose connection
is to be canceled.

@rdesc If the function completed successfully, TRUE is returned.  Otherwise,
FALSE is returned.  The reason for failure may be determined by calling
GetLastError().

@xref ResolveLinkInfo

******************************************************************************/

LINKINFOAPI BOOL WINAPI DisconnectLinkInfo(PCLINKINFO pcli)
{
   BOOL bResult;

   DebugEntry(DisconnectLinkInfo);

#ifdef EXPV
   /* Verify parameters. */

   if (
#ifdef SKIP_OLD_LINKINFO_QUIETLY
       IsNewLinkInfoHackCheck((PCILINKINFO)pcli) &&
#endif
       IS_VALID_STRUCT_PTR(pcli, CLINKINFO))
#endif
   {
      bResult = DisconnectILinkInfo((PCILINKINFO)pcli);
   }
#ifdef EXPV
   else
   {
      SetLastError(ERROR_INVALID_PARAMETER);
      bResult = FALSE;
   }
#endif

   DebugExitBOOL(DisconnectLinkInfo, bResult);

   return(bResult);
}


/******************************************************************************

@doc LINKINFOAPI

@func BOOL | GetLinkInfoData | Retrieves a pointer to data in a LinkInfo
structure.

@parm PCLINKINFO | pcli | A pointer to the LinkInfo structure to retrieve data
from.

@parm LINKINFODATATYPE | lidt | The type of data to be retrieved from the
LinkInfo structure.  lidt may be one of the following values:

@flag LIDT_VOLUME_SERIAL_NUMBER | *ppcvData is a PCDWORD that points to the
LinkInfo structure's referent's volume's serial number.

@flag LIDT_DRIVE_TYPE | *ppcvData is a PCUINT that points to the LinkInfo
structure's referent's volume's host drive type.

@flag LIDT_VOLUME_LABEL | *ppcvData is a PCSTR that points to the LinkInfo
structure's referent's volume's label.

@flag LIDT_LOCAL_BASE_PATH | *ppcvData is a PCSTR that points to the LinkInfo
structure's referent's local base path.

@flag LIDT_NET_RESOURCE | *ppcvData is a PCSTR that points to the LinkInfo
structure's referent's parent network resource's name.

@flag LIDT_COMMON_PATH_SUFFIX | *ppcvData is a PCSTR that points to the
LinkInfo structure's referent's common path suffix.

@rdesc If the function completed successfully, TRUE is returned, and *ppcvData
is filled in with a pointer to the data requested from LinkInfo structure.
Otherwise, FALSE is returned, and the contents of *ppcvData are undefined.  The
reason for failure may be determined by calling GetLastError().

@comm A LinkInfo structure may only contain some of the LinkInfo data listed
above.

******************************************************************************/

LINKINFOAPI BOOL WINAPI GetLinkInfoData(PCLINKINFO pcli, LINKINFODATATYPE lidt,
                                        PCVOID *ppcvData)
{
   BOOL bResult;

   DebugEntry(GetLinkInfoData);

#ifdef EXPV
   /* Verify parameters. */

   if (
#ifdef SKIP_OLD_LINKINFO_QUIETLY
       IsNewLinkInfoHackCheck((PCILINKINFO)pcli) &&
#endif
       IS_VALID_STRUCT_PTR(pcli, CLINKINFO) &&
       EVAL(IsValidLINKINFODATATYPE(lidt)) &&
       IS_VALID_WRITE_PTR(ppcvData, PCVOID))
#endif
   {
      bResult = GetILinkInfoData((PCILINKINFO)pcli, lidt, ppcvData);
   }
#ifdef EXPV
   else
   {
      SetLastError(ERROR_INVALID_PARAMETER);
      bResult = FALSE;
   }
#endif

   ASSERT(! bResult ||
          IS_VALID_READ_BUFFER_PTR(*ppcvData, LinkInfoData, 1));

   DebugExitBOOL(GetLinkInfoData, bResult);

   return(bResult);
}


/******************************************************************************

@doc LINKINFOAPI

@func BOOL | IsValidLinkInfo | Determines whether or not a LinkInfo structure
is valid.

@parm PCLINKINFO | pcli | A pointer to the LinkInfo structure to be checked for
validity.

@rdesc If the function completed successfully, TRUE is returned.  Otherwise,
FALSE is returned.

******************************************************************************/

LINKINFOAPI BOOL WINAPI IsValidLinkInfo(PCLINKINFO pcli)
{
   BOOL bResult;

   DebugEntry(IsValidLinkInfo);

#ifdef SKIP_OLD_LINKINFO_QUIETLY

   bResult = (IsNewLinkInfoHackCheck((PCILINKINFO)pcli) &&
              IS_VALID_STRUCT_PTR(pcli, CLINKINFO));

#else

   bResult = IS_VALID_STRUCT_PTR(pcli, CLINKINFO);

#endif

   DebugExitBOOL(IsValidLinkInfo, bResult);

   return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\serial.c ===
/*
 * serial.c - Access serialization routines module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "init.h"


/* Types
 ********/

/* process information */

typedef struct _processinfo
{
   HANDLE hModule;
}
PROCESSINFO;
DECLARE_STANDARD_TYPES(PROCESSINFO);

#ifdef DEBUG

/* debug flags */

typedef enum _serialdebugflags
{
   SERIAL_DFL_BREAK_ON_PROCESS_ATTACH  = 0x0001,

   SERIAL_DFL_BREAK_ON_THREAD_ATTACH   = 0x0002,

   ALL_SERIAL_DFLAGS                   = (SERIAL_DFL_BREAK_ON_PROCESS_ATTACH |
                                          SERIAL_DFL_BREAK_ON_THREAD_ATTACH)
}
SERIALDEBUGFLAGS;

#endif   /* DEBUG */


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_SHARED)

/*
 * RAIDRAID: (16273) The use of Mnrcs in a shared data section is broken under
 * NT.  To run under NT, this code should be changed to use a shared mutex
 * referenced by hMutex in Mpi.
 */

/* critical section used for access serialization */

PRIVATE_DATA NONREENTRANTCRITICALSECTION Mnrcs =
{
   { 0 },

#ifdef DEBUG
   INVALID_THREAD_ID,
#endif   /* DEBUG */

   FALSE
};

/* number of attached processes */

PRIVATE_DATA ULONG MulcProcesses = 0;

#pragma data_seg(DATA_SEG_PER_INSTANCE)

/* information about current process */

/*
 * Initialize Mpi so it is actually put in the .instanc section instead of the
 * .bss section.
 */

PRIVATE_DATA PROCESSINFO Mpi =
{
   NULL
};

#pragma data_seg()

#ifdef DEBUG

#pragma data_seg(DATA_SEG_SHARED)

/* debug flags */

PRIVATE_DATA DWORD MdwSerialModuleFlags = 0;

#pragma data_seg(DATA_SEG_READ_ONLY)

/* .ini file switch descriptions */

PRIVATE_DATA CBOOLINISWITCH cbisBreakOnProcessAttach =
{
   IST_BOOL,
  TEXT( "BreakOnProcessAttach"),
   &MdwSerialModuleFlags,
   SERIAL_DFL_BREAK_ON_PROCESS_ATTACH
};

PRIVATE_DATA CBOOLINISWITCH cbisBreakOnThreadAttach =
{
   IST_BOOL,
   TEXT("BreakOnThreadAttach"),
   &MdwSerialModuleFlags,
   SERIAL_DFL_BREAK_ON_THREAD_ATTACH
};

PRIVATE_DATA const PCVOID MrgcpcvisSerialModule[] =
{
   &cbisBreakOnProcessAttach,
   &cbisBreakOnThreadAttach
};

#pragma data_seg()

#endif   /* DEBUG */


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCSERIALCONTROL(PCSERIALCONTROL);
PRIVATE_CODE BOOL IsValidPCPROCESSINFO(PCPROCESSINFO);
PRIVATE_CODE BOOL IsValidPCCRITICAL_SECTION(PCCRITICAL_SECTION);
PRIVATE_CODE BOOL IsValidThreadId(DWORD);
PRIVATE_CODE BOOL IsValidPCNONREENTRANTCRITICALSECTION(PCNONREENTRANTCRITICALSECTION);

#endif


#ifdef DEBUG

/*
** IsValidPCSERIALCONTROL()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCSERIALCONTROL(PCSERIALCONTROL pcserctrl)
{
   return(IS_VALID_READ_PTR(pcserctrl, CSERIALCONTROL) &&
          (! pcserctrl->AttachProcess ||
           IS_VALID_CODE_PTR(pcserctrl->AttachProcess, AttachProcess)) &&
          (! pcserctrl->DetachProcess ||
           IS_VALID_CODE_PTR(pcserctrl->DetachProcess, DetachProcess)) &&
          (! pcserctrl->AttachThread ||
           IS_VALID_CODE_PTR(pcserctrl->AttachThread, AttachThread)) &&
          (! pcserctrl->DetachThread||
           IS_VALID_CODE_PTR(pcserctrl->DetachThread, DetachThread)));
}


/*
** IsValidPCPROCESSINFO()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCPROCESSINFO(PCPROCESSINFO pcpi)
{
   return(IS_VALID_READ_PTR(pcpi, CPROCESSINFO) &&
          IS_VALID_HANDLE(pcpi->hModule, MODULE));
}


/*
** IsValidPCCRITICAL_SECTION()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCCRITICAL_SECTION(PCCRITICAL_SECTION pccritsec)
{
   return(IS_VALID_READ_PTR(pccritsec, CCRITICAL_SECTION));
}


/*
** IsValidThreadId()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidThreadId(DWORD dwThreadId)
{
   return(dwThreadId != INVALID_THREAD_ID);
}


/*
** IsValidPCNONREENTRANTCRITICALSECTION()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCNONREENTRANTCRITICALSECTION(
                                          PCNONREENTRANTCRITICALSECTION pcnrcs)
{
   /* bEntered may be any value. */

   return(IS_VALID_READ_PTR(pcnrcs, CNONREENTRANTCRITICALSECTION) &&
          IS_VALID_STRUCT_PTR(&(pcnrcs->critsec), CCRITICAL_SECTION) &&
          EVAL(pcnrcs->dwOwnerThread == INVALID_THREAD_ID ||
               IsValidThreadId(pcnrcs->dwOwnerThread)));
}

#endif


/****************************** Public Functions *****************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

#ifdef DEBUG

/*
** SetSerialModuleIniSwitches()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SetSerialModuleIniSwitches(void)
{
   BOOL bResult;

   bResult = SetIniSwitches(MrgcpcvisSerialModule,
                            ARRAY_ELEMENTS(MrgcpcvisSerialModule));

   ASSERT(FLAGS_ARE_VALID(MdwSerialModuleFlags, ALL_SERIAL_DFLAGS));

   return(bResult);
}

#endif


/*
** AttachProcess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL AttachProcess(HMODULE hmod)
{
   BOOL bResult;

   ReinitializeNonReentrantCriticalSection(&Mnrcs);

   bResult = EnterNonReentrantCriticalSection(&Mnrcs);

   if (bResult)
   {

#ifdef DEBUG

      ASSERT(SetAllIniSwitches());

      TRACE_OUT((TEXT("AttachProcess(): Called for module %#lx."),
                 hmod));

      if (IS_FLAG_SET(MdwSerialModuleFlags, SERIAL_DFL_BREAK_ON_PROCESS_ATTACH))
      {
         WARNING_OUT((TEXT("AttachProcess(): Breaking on process attach, as requested.")));
         DebugBreak();
      }

#endif   /* DEBUG */

      Mpi.hModule = hmod;

      ASSERT(MulcProcesses < ULONG_MAX);

      if (! MulcProcesses++)
      {
         TRACE_OUT((TEXT("AttachProcess(): First process attached.  Calling InitializeDLL().")));

         bResult = InitializeDLL();
      }
      else
      {

#ifdef PRIVATE_HEAP

         bResult = TRUE;

#else
         /* 
          * Initialize the per-instance memory manager heap for 
          * subsequent processes.
          */

         bResult = InitMemoryManagerModule();

#endif

      }

      if (bResult)
      {
         ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

         if (g_cserctrl.AttachProcess)
            bResult = g_cserctrl.AttachProcess(hmod);
      }

      TRACE_OUT((TEXT("AttachProcess(): There are now %lu processes attached."),
                 MulcProcesses));

      LeaveNonReentrantCriticalSection(&Mnrcs);
   }

   return(bResult);
}


/*
** DetachProcess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL DetachProcess(HMODULE hmod)
{
   BOOL bResult;

   bResult = EnterNonReentrantCriticalSection(&Mnrcs);

   if (bResult)
   {
      ASSERT(hmod == Mpi.hModule);

      ASSERT(MulcProcesses > 0);

      TRACE_OUT((TEXT("DetachProcess(): Called for module %#lx."),
                 hmod));

      ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

      if (g_cserctrl.DetachProcess)
         bResult = g_cserctrl.DetachProcess(hmod);

      if (--MulcProcesses)
      {
         bResult = TRUE;

#ifndef PRIVATE_HEAP

         /* 
          * Terminate the per-instance memory manager heap.
          */

         ExitMemoryManagerModule();

#endif
      }
      else
      {
         TRACE_OUT((TEXT("DetachProcess(): Last process detached.  Calling TerminateDLL().")));

         bResult = TerminateDLL();
      }

      TRACE_OUT((TEXT("DetachProcess(): There are now %lu processes attached."),
                 MulcProcesses));

      LeaveNonReentrantCriticalSection(&Mnrcs);
   }

   /*
    * Do not call DeleteCriticalSection(&(Mnrcs->critsec)) here, since doing so
    * at the right time would require unprotected access to shared data
    * MulcProcesses and Mnrcs->critsec.  Assume Kernel32 will clean up
    * Mnrcs->critsec for us at termination.
    */

   return(bResult);
}


/*
** AttachThread()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL AttachThread(HMODULE hmod)
{
   BOOL bResult;

   bResult = EnterNonReentrantCriticalSection(&Mnrcs);

   if (bResult)
   {

#ifdef DEBUG

      ASSERT(SetAllIniSwitches());

      TRACE_OUT((TEXT("AttachThread() called for module %#lx, thread ID %#lx."),
                 hmod,
                 GetCurrentThreadId()));

      if (IS_FLAG_SET(MdwSerialModuleFlags, SERIAL_DFL_BREAK_ON_THREAD_ATTACH))
      {
         WARNING_OUT((TEXT("AttachThread(): Breaking on thread attach, as requested.")));
         DebugBreak();
      }

#endif

      ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

      if (g_cserctrl.AttachThread)
         bResult = g_cserctrl.AttachThread(hmod);
      else
         bResult = TRUE;

      LeaveNonReentrantCriticalSection(&Mnrcs);
   }

   return(bResult);
}


/*
** DetachThread()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL DetachThread(HMODULE hmod)
{
   BOOL bResult;

   bResult = EnterNonReentrantCriticalSection(&Mnrcs);

   if (bResult)
   {
      TRACE_OUT((TEXT("DetachThread() called for module %#lx, thread ID %#lx."),
                 hmod,
                 GetCurrentThreadId()));

      ASSERT(IS_VALID_STRUCT_PTR(&g_cserctrl, CSERIALCONTROL));

      if (g_cserctrl.DetachThread)
         bResult = g_cserctrl.DetachThread(hmod);
      else
         bResult = TRUE;

      LeaveNonReentrantCriticalSection(&Mnrcs);
   }

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** ReinitializeNonReentrantCriticalSection()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ReinitializeNonReentrantCriticalSection(
                                          PNONREENTRANTCRITICALSECTION pnrcs)
{
   ASSERT(IS_VALID_STRUCT_PTR(pnrcs, CNONREENTRANTCRITICALSECTION));

   InitializeCriticalSection(&(pnrcs->critsec));

   return;
}


/*
** EnterNonReentrantCriticalSection()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL EnterNonReentrantCriticalSection(
                                          PNONREENTRANTCRITICALSECTION pnrcs)
{
   BOOL bEntered;

#ifdef DEBUG

   BOOL bBlocked;

   ASSERT(IS_VALID_STRUCT_PTR(pnrcs, CNONREENTRANTCRITICALSECTION));

   /* Is the critical section already owned by another thread? */

   /* Use pnrcs->bEntered and pnrcs->dwOwnerThread unprotected here. */

   bBlocked = (pnrcs->bEntered &&
               GetCurrentThreadId() != pnrcs->dwOwnerThread);

   if (bBlocked)
      WARNING_OUT((TEXT("EnterNonReentrantCriticalSection(): Blocking thread %lx.  Critical section is already owned by thread %#lx."),
                   GetCurrentThreadId(),
                   pnrcs->dwOwnerThread));

#endif

   EnterCriticalSection(&(pnrcs->critsec));

   bEntered = (! pnrcs->bEntered);

   if (bEntered)
   {
      pnrcs->bEntered = TRUE;

#ifdef DEBUG

      pnrcs->dwOwnerThread = GetCurrentThreadId();

      if (bBlocked)
         WARNING_OUT((TEXT("EnterNonReentrantCriticalSection(): Unblocking thread %lx.  Critical section is now owned by this thread."),
                      pnrcs->dwOwnerThread));
#endif

   }
   else
   {
      LeaveCriticalSection(&(pnrcs->critsec));

      ERROR_OUT((TEXT("EnterNonReentrantCriticalSection(): Thread %#lx attempted to reenter non-reentrant code."),
                 GetCurrentThreadId()));
   }

   return(bEntered);
}


/*
** LeaveNonReentrantCriticalSection()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void LeaveNonReentrantCriticalSection(
                                          PNONREENTRANTCRITICALSECTION pnrcs)
{
   ASSERT(IS_VALID_STRUCT_PTR(pnrcs, CNONREENTRANTCRITICALSECTION));

   if (EVAL(pnrcs->bEntered))
   {
      pnrcs->bEntered = FALSE;
#ifdef DEBUG
      pnrcs->dwOwnerThread = INVALID_THREAD_ID;
#endif

      LeaveCriticalSection(&(pnrcs->critsec));
   }

   return;
}


#ifdef DEBUG

/*
** NonReentrantCriticalSectionIsOwned()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL NonReentrantCriticalSectionIsOwned(
                                          PCNONREENTRANTCRITICALSECTION pcnrcs)
{
   return(pcnrcs->bEntered);
}

#endif


/*
** BeginExclusiveAccess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL BeginExclusiveAccess(void)
{
   return(EnterNonReentrantCriticalSection(&Mnrcs));
}


/*
** EndExclusiveAccess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void EndExclusiveAccess(void)
{
   LeaveNonReentrantCriticalSection(&Mnrcs);

   return;
}


#ifdef DEBUG

/*
** AccessIsExclusive()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL AccessIsExclusive(void)
{
   return(NonReentrantCriticalSectionIsOwned(&Mnrcs));
}

#endif   /* DEBUG */


/*
** GetThisModulesHandle()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HMODULE GetThisModulesHandle(void)
{
   ASSERT(IS_VALID_STRUCT_PTR((PCPROCESSINFO)&Mpi, CPROCESSINFO));

   return(Mpi.hModule);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\makefile.inc ===
#
# Copy shared source code.
#

doit: init.c serial.c memmgr.c valid.c comc.c inifile.c resstr.c debug.c

SHARED_DIR=..\core

init.c: $(SHARED_DIR)\init.c
   copy $(SHARED_DIR)\init.c

serial.c: $(SHARED_DIR)\serial.c
   copy $(SHARED_DIR)\serial.c

memmgr.c: $(SHARED_DIR)\memmgr.c
   copy $(SHARED_DIR)\memmgr.c

valid.c: $(SHARED_DIR)\valid.c
   copy $(SHARED_DIR)\valid.c

comc.c: $(SHARED_DIR)\comc.c
   copy $(SHARED_DIR)\comc.c

inifile.c: $(SHARED_DIR)\inifile.c
   copy $(SHARED_DIR)\inifile.c

resstr.c: $(SHARED_DIR)\resstr.c
   copy $(SHARED_DIR)\resstr.c

debug.c: $(SHARED_DIR)\debug.c
   copy $(SHARED_DIR)\debug.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\project.h ===
/*
 * project.h - Project header file for LinkInfo DLL.
 */


/* System Headers
 *****************/

#define BUILDDLL              /* for windows.h */
#define STRICT                /* for windows.h (robustedness) */

#ifdef WINNT
#if DBG
#define DEBUG 1
#endif
#endif

/*
 * RAIDRAID: (16282) Get rid of warnings about unused Int64 inline
 * functions in winnt.h for all modules.  Emasculate other warnings only for
 * windows.h.
 */

#pragma warning(disable:4514) /* "unreferenced inline function" warning */

#pragma warning(disable:4001) /* "single line comment" warning */
#pragma warning(disable:4115) /* "named type definition in parentheses" warning */
#pragma warning(disable:4201) /* "nameless struct/union" warning */
#pragma warning(disable:4209) /* "benign typedef redefinition" warning */
#pragma warning(disable:4214) /* "bit field types other than int" warning */
#pragma warning(disable:4218) /* "must specify at least a storage class or type" warning */

#include <windows.h>

#pragma warning(default:4218) /* "must specify at least a storage class or type" warning */
#pragma warning(default:4214) /* "bit field types other than int" warning */
#pragma warning(default:4209) /* "benign typedef redefinition" warning */
#pragma warning(default:4201) /* "nameless struct/union" warning */
#pragma warning(default:4115) /* "named type definition in parentheses" warning */
#pragma warning(default:4001) /* "single line comment" warning */

#ifdef WINNT
#define ReinitializeCriticalSection NoThunkReinitializeCriticalSection
VOID WINAPI NoThunkReinitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
    );

#define ALIGN_CNT(x,y)    (((x)+(y)-1) & ~((y)-1))
#else
#define ALIGN_CNT(x,y)    (x)
#endif

#define ALIGN_PTR(x,y)      ALIGN_CNT((DWORD)(x),(y))
#define ALIGN_DWORD_CNT(x)  ALIGN_CNT((x),SIZEOF(DWORD))
#define ALIGN_DWORD_PTR(x)  ALIGN_PTR((x),SIZEOF(DWORD))
#define ALIGN_WORD_CNT(x)   ALIGN_CNT((x),SIZEOF(WORD))
#define ALIGN_WORD_PTR(x)   ALIGN_PTR((x),SIZEOF(WORD))

#include <limits.h>

#define _LINKINFO_            /* for linkinfo.h */
#include <linkinfo.h>


/* Constants
 ************/

#ifdef DEBUG

#define INDENT_STRING         "    "

#endif


/* Project Headers
 ******************/

/* The order of the following include files is significant. */

#include "..\core\stock.h"
#include "..\core\serial.h"

#ifdef DEBUG

#include "..\core\inifile.h"
#include "..\core\resstr.h"

#endif

#include "..\core\debug.h"
#include "..\core\valid.h"
#include "..\core\memmgr.h"
#include "..\core\comc.h"

#include "util.h"
#include "canon.h"


/* Constants
 ************/

/*
 * constants to be used with #pragma data_seg()
 *
 * These section names must be given the associated attributes in the project's
 * module definition file.
 */

#define DATA_SEG_READ_ONLY       ".text"
#define DATA_SEG_PER_INSTANCE    ".instanc"
#define DATA_SEG_SHARED          ".data"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\server.h ===
/*
 * server.h - Server vtable functions module description.
 */


/* Types
 ********/

#include <msshrui.h>

typedef struct _servervtable
{
   PFNGETNETRESOURCEFROMLOCALPATH GetNetResourceFromLocalPath;
   PFNGETLOCALPATHFROMNETRESOURCE GetLocalPathFromNetResource;
}
SERVERVTABLE;
DECLARE_STANDARD_TYPES(SERVERVTABLE);


/* Prototypes
 *************/

/* server.c */

extern BOOL ProcessInitServerModule(void);
extern void ProcessExitServerModule(void);
extern BOOL GetServerVTable(PCSERVERVTABLE *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\util.h ===
/*
 * util.h - Miscellaneous utility functions module description.
 */


/* Prototypes
 *************/

/* util.h */

extern BOOL IsLocalDrivePath(LPCTSTR);
extern BOOL IsUNCPath(LPCTSTR);
extern BOOL DeleteLastDrivePathElement(LPTSTR);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsContained(PCVOID, UINT, PCVOID, UINT);
extern BOOL IsValidCNRName(LPCTSTR);

#endif

#ifdef DEBUG

extern BOOL IsDriveRootPath(LPCTSTR);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\volumeid.h ===
/*
 * volumeid.h - Volume ID ADT module description.
 */


/* Types
 ********/

typedef struct _volumeid
{
   int nUnused;
}
VOLUMEID;
DECLARE_STANDARD_TYPES(VOLUMEID);

/* SearchForLocalPath() input flags */

typedef enum _searchforlocalpathinflags
{
   /* Search matching local devices for missing volume. */

   SFLP_IFL_LOCAL_SEARCH = 0x0001,

   ALL_SFLP_IFLAGS = SFLP_IFL_LOCAL_SEARCH
}
SEARCHFORLOCALPATHINFLAGS;


/* Prototypes
 *************/

/* volumeid.c */

extern BOOL CreateVolumeID(LPCTSTR, PVOLUMEID *, PUINT);
extern void DestroyVolumeID(PVOLUMEID);
extern COMPARISONRESULT CompareVolumeIDs(PCVOLUMEID, PCVOLUMEID);
extern BOOL SearchForLocalPath(PCVOLUMEID, LPCTSTR, DWORD, LPTSTR);
extern UINT GetVolumeIDLen(PCVOLUMEID);
extern BOOL GetVolumeSerialNumber(PCVOLUMEID, PCDWORD *);
extern BOOL GetVolumeDriveType(PCVOLUMEID, PCUINT *);
extern BOOL GetVolumeLabel(PCVOLUMEID, LPCSTR *);
#ifdef UNICODE
extern BOOL GetVolumeLabelW(PCVOLUMEID, LPCWSTR *);
#endif
extern COMPARISONRESULT CompareDWORDs(DWORD, DWORD);

#if defined(DEBUG) || defined (VSTF)

extern BOOL IsValidPCVOLUMEID(PCVOLUMEID);

#endif

#ifdef DEBUG

extern void DumpVolumeID(PCVOLUMEID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncapp\syncapp.h ===
#ifndef STRICT
#define STRICT
#endif

#define _INC_OLE
#include <windows.h>
#undef _INC_OLE

#include <shlobj.h>
#include <shlapip.h>
#include <shsemip.h>

#define IDI_DEFAULT     100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\volumeid.c ===
/*
 * volumeid.c - Volume ID ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "volumeid.h"


/* Constants
 ************/

/* local root path constants */

#define MAX_LOCAL_DRIVES            (TEXT('z') - TEXT('a') + 1)


/* Macros
 *********/

/* macros for accessing IVOLUMEID data */

#define IVOLID_Volume_Label_PtrA(pivolid) \
   ((LPSTR)(((PBYTE)(pivolid)) + (pivolid)->ucbVolumeLabelOffset))

#ifdef UNICODE
#define IVOLID_Volume_Label_PtrW(pivolid) \
   ((LPTSTR)(((PBYTE)(pivolid)) + (pivolid)->ucbVolumeLabelOffsetW))
#endif

#ifdef UNICODE
#define IVOLID_Volume_Label_Ptr(pivolid)   IVOLID_Volume_Label_PtrW(pivolid)
#else
#define IVOLID_Volume_Label_Ptr(pivolid)   IVOLID_Volume_Label_PtrA(pivolid)
#endif

/* Types
 ********/

/*
   @doc INTERNAL

   @struct IVOLUMEID | Internal definition of relocatable volume ID structure.
   An <t ILINKINFO> structure may contain an IVOLUMEID structure.  An IVOLUMEID
   structure consists of a header described as below, followed by
   variable-length data.
*/

typedef struct _ivolumeidA
{
   /*
      @field UINT | ucbSize | Length of IVOLUMEID structure in bytes, including
      ucbSize field.
   */

   UINT ucbSize;

   /*
      @field UINT | uDriveType | The volume's host drive type, as returned by
      GetDriveType()
   */

   UINT uDriveType;

   /* @field DWORD | dwSerialNumber | The volume's serial number. */

   DWORD dwSerialNumber;

   /*
      @field UINT | ucbVolumeLabelOffset | Offset in bytes of volume label
      string from base of structure.
   */

   UINT ucbVolumeLabelOffset;
}
IVOLUMEIDA;
DECLARE_STANDARD_TYPES(IVOLUMEIDA);

#ifdef UNICODE
typedef struct _ivolumeidW
{
   /*
      @field UINT | ucbSize | Length of IVOLUMEID structure in bytes, including
      ucbSize field.
   */

   UINT ucbSize;

   /*
      @field UINT | uDriveType | The volume's host drive type, as returned by
      GetDriveType()
   */

   UINT uDriveType;

   /* @field DWORD | dwSerialNumber | The volume's serial number. */

   DWORD dwSerialNumber;

   /*
      @field UINT | ucbVolumeLabelOffset | Offset in bytes of volume label
      string from base of structure.
   */

   UINT ucbVolumeLabelOffset;

   /*
      This member is for storing the unicode version of the string
   */

   UINT ucbVolumeLabelOffsetW;
}
IVOLUMEIDW;
DECLARE_STANDARD_TYPES(IVOLUMEIDW);
#endif

#ifdef UNICODE
#define IVOLUMEID   IVOLUMEIDW
#define PIVOLUMEID  PIVOLUMEIDW
#define CIVOLUMEID  CIVOLUMEIDW
#define PCIVOLUMEID PCIVOLUMEIDW
#else
#define IVOLUMEID   IVOLUMEIDA
#define PIVOLUMEID  PIVOLUMEIDA
#define CIVOLUMEID  CIVOLUMEIDA
#define PCIVOLUMEID PCIVOLUMEIDA
#endif

/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL UnifyIVolumeIDInfo(UINT, DWORD, LPCTSTR, PIVOLUMEID *, PUINT);
PRIVATE_CODE BOOL IsPathOnVolume(LPCTSTR, PCIVOLUMEID, PBOOL);
PRIVATE_CODE COMPARISONRESULT CompareUINTs(UINT, UINT);

#if defined(DEBUG) || defined (VSTF)

PRIVATE_CODE BOOL IsValidPCIVOLUMEID(PCIVOLUMEID);

#endif


/*
** UnifyIVolumeIDInfo()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL UnifyIVolumeIDInfo(UINT uDriveType, DWORD dwSerialNumber,
                                LPCTSTR pcszVolumeLabel, PIVOLUMEID *ppivolid,
                                PUINT pucbIVolumeIDLen)
{
   BOOL bResult;
#ifdef UNICODE
   CHAR szAnsiVolumeLabel[MAX_PATH];
   BOOL bUnicode;
   UINT cchVolumeLabel;
   UINT cchChars;
#endif

   /* dwSerialNumber may be any value. */

   ASSERT(IsValidDriveType(uDriveType));
   ASSERT(IS_VALID_STRING_PTR(pcszVolumeLabel, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppivolid, PIVOLUMEID));
   ASSERT(IS_VALID_WRITE_PTR(pucbIVolumeIDLen, UINT));

   /* Assume we won't overflow *pucbIVolumeIDLen here. */

#ifdef UNICODE
   /* Determine whether we need a full fledged UNICODE volume ID */
   bUnicode = FALSE;
   cchVolumeLabel = WideCharToMultiByte(CP_ACP, 0,
                                        pcszVolumeLabel, -1,
                                        szAnsiVolumeLabel, MAX_PATH,
                                        0, 0);
   if ( cchVolumeLabel == 0 )
   {
      bUnicode = TRUE;
   }
   else
   {
      WCHAR szWideVolumeLabel[MAX_PATH];

      cchChars = MultiByteToWideChar(CP_ACP, 0,
                                     szAnsiVolumeLabel, -1,
                                     szWideVolumeLabel, MAX_PATH);
      if ( cchChars == 0 || lstrcmp(pcszVolumeLabel,szWideVolumeLabel) != 0 )
      {
         bUnicode = TRUE;
      }
   }

   if ( bUnicode )
   {
      UINT ucbDataSize;

      /* (+ 1) for null terminator. */

      ucbDataSize = SIZEOF(IVOLUMEIDW) + cchVolumeLabel;
      ucbDataSize = ALIGN_WORD_CNT(ucbDataSize);
      ucbDataSize += (lstrlen(pcszVolumeLabel) + 1) * SIZEOF(TCHAR);
      *pucbIVolumeIDLen = ucbDataSize;
   }
   else
   {
      /* (+ 1) for null terminator. */

      *pucbIVolumeIDLen = SIZEOF(IVOLUMEIDA) +
                          cchVolumeLabel;
   }
#else
   /* (+ 1) for null terminator. */

   *pucbIVolumeIDLen = SIZEOF(**ppivolid) +
                       (lstrlen(pcszVolumeLabel) + 1) * SIZEOF(TCHAR);
#endif

   bResult = AllocateMemory(*pucbIVolumeIDLen, ppivolid);

   if (bResult)
   {
      (*ppivolid)->ucbSize = *pucbIVolumeIDLen;
      (*ppivolid)->uDriveType = uDriveType;
      (*ppivolid)->dwSerialNumber = dwSerialNumber;

      /* Append volume label. */

#ifdef UNICODE
      if ( bUnicode )
      {
          (*ppivolid)->ucbVolumeLabelOffset = SIZEOF(IVOLUMEIDW);
          (*ppivolid)->ucbVolumeLabelOffsetW = ALIGN_WORD_CNT(
                                         SIZEOF(IVOLUMEIDW)+cchVolumeLabel);

          lstrcpy(IVOLID_Volume_Label_PtrW(*ppivolid), pcszVolumeLabel);
      }
      else
      {
          (*ppivolid)->ucbVolumeLabelOffset = SIZEOF(IVOLUMEIDA);
      }
      lstrcpyA(IVOLID_Volume_Label_PtrA(*ppivolid), szAnsiVolumeLabel);
#else

      lstrcpy(IVOLID_Volume_Label_Ptr(*ppivolid), pcszVolumeLabel);
#endif
   }

   ASSERT(! bResult ||
          (IS_VALID_STRUCT_PTR(*ppivolid, CIVOLUMEID) &&
           EVAL(*pucbIVolumeIDLen == GetVolumeIDLen((PCVOLUMEID)*ppivolid))));

   return(bResult);
}


/*
** IsPathOnVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsPathOnVolume(LPCTSTR pcszDrivePath, PCIVOLUMEID pcivolid,
                                 PBOOL pbOnVolume)
{
   BOOL bResult;
   PVOLUMEID pvolid;
   UINT ucbVolumeIDLen;

   ASSERT(IsDrivePath(pcszDrivePath));
   ASSERT(IS_VALID_STRUCT_PTR(pcivolid, CIVOLUMEID));
   ASSERT(IS_VALID_WRITE_PTR(pcivolid, CIVOLUMEID));

   bResult = CreateVolumeID(pcszDrivePath, &pvolid, &ucbVolumeIDLen);

   if (bResult)
   {
      *pbOnVolume = (CompareVolumeIDs(pvolid, (PCVOLUMEID)pcivolid)
                     == CR_EQUAL);

      DestroyVolumeID(pvolid);
   }

   return(bResult);
}


/*
** CompareUINTs()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE COMPARISONRESULT CompareUINTs(UINT uFirst, UINT uSecond)
{
   COMPARISONRESULT cr;

   /* Any UINTs are valid input. */

   if (uFirst < uSecond)
      cr = CR_FIRST_SMALLER;
   else if (uFirst > uSecond)
      cr = CR_FIRST_LARGER;
   else
      cr = CR_EQUAL;

   ASSERT(IsValidCOMPARISONRESULT(cr));

   return(cr);
}


#if defined(DEBUG) || defined (VSTF)

/*
** IsValidPCIVOLUMEID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCIVOLUMEID(PCIVOLUMEID pcivolid)
{
   /* dwSerialNumber may be any value. */

   return(IS_VALID_READ_PTR(pcivolid, CIVOLUMEID) &&
          IS_VALID_READ_BUFFER_PTR(pcivolid, CIVOLUMEID, pcivolid->ucbSize) &&
          EVAL(IsValidDriveType(pcivolid->uDriveType)) &&
          EVAL(IsContained(pcivolid, pcivolid->ucbSize,
                           IVOLID_Volume_Label_Ptr(pcivolid),
                           lstrlen(IVOLID_Volume_Label_Ptr(pcivolid))*SIZEOF(TCHAR))));
}

#endif


/****************************** Public Functions *****************************/


/*
** CreateVolumeID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreateVolumeID(LPCTSTR pcszDrivePath, PVOLUMEID *ppvolid,
                                PUINT pucbVolumeIDLen)
{
   BOOL bResult;
   /* "C:\" + null terminator. */
   TCHAR rgchRootPath[3 + 1];
   TCHAR rgchVolumeLabel[MAX_PATH_LEN];
   DWORD dwSerialNumber;

   ASSERT(IsDrivePath(pcszDrivePath));
   ASSERT(IS_VALID_WRITE_PTR(ppvolid, PVOLUMEID));
   ASSERT(IS_VALID_WRITE_PTR(pucbVolumeIDLen, UINT));

   /* Get volume's label and serial number. */

   MyLStrCpyN(rgchRootPath, pcszDrivePath, ARRAYSIZE(rgchRootPath));

   bResult = GetVolumeInformation(rgchRootPath, rgchVolumeLabel,
                                  ARRAYSIZE(rgchVolumeLabel), &dwSerialNumber,
                                  NULL, NULL, NULL, 0);

   if (bResult)
      /* Wrap them up. */
      bResult = UnifyIVolumeIDInfo(GetDriveType(rgchRootPath), dwSerialNumber,
                                   rgchVolumeLabel, (PIVOLUMEID *)ppvolid,
                                   pucbVolumeIDLen);

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR((PCIVOLUMEID)*ppvolid, CIVOLUMEID));

   return(bResult);
}


/*
** DestroyVolumeID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyVolumeID(PVOLUMEID pvolid)
{
   ASSERT(IS_VALID_STRUCT_PTR(pvolid, CVOLUMEID));

   FreeMemory(pvolid);

   return;
}


/*
** CompareVolumeIDs()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Volume ID data is compared in the following order:
**    1) drive type
**    2) volume serial number
**
** N.b., volume labels are ignored.
*/
PUBLIC_CODE COMPARISONRESULT CompareVolumeIDs(PCVOLUMEID pcvolidFirst,
                                         PCVOLUMEID pcvolidSecond)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pcvolidFirst, CVOLUMEID));
   ASSERT(IS_VALID_STRUCT_PTR(pcvolidSecond, CVOLUMEID));

   /* Compare VOLUMEIDs piece by piece. */

   cr = CompareUINTs(((PCIVOLUMEID)pcvolidFirst)->uDriveType,
                     ((PCIVOLUMEID)pcvolidSecond)->uDriveType);

   if (cr == CR_EQUAL)
      cr = CompareDWORDs(((PCIVOLUMEID)pcvolidFirst)->dwSerialNumber,
                         ((PCIVOLUMEID)pcvolidSecond)->dwSerialNumber);

   return(cr);
}


/*
** SearchForLocalPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SearchForLocalPath(PCVOLUMEID pcvolid, LPCTSTR pcszFullPath,
                               DWORD dwInFlags, LPTSTR pszFoundPathBuf)
{
   BOOL bResult;
   BOOL bAvailable;
#if defined(DEBUG) && defined(UNICODE)
   WCHAR szWideVolumeLabel[MAX_PATH];
   LPWSTR pszWideVolumeLabel;
#endif

   ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));
   ASSERT(IsFullPath(pcszFullPath));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_SFLP_IFLAGS));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszFoundPathBuf, STR, MAX_PATH_LEN));

#if defined(DEBUG) && defined(UNICODE)
   if (((PCIVOLUMEID)pcvolid)->ucbVolumeLabelOffset == SIZEOF(IVOLUMEIDA))
   {
      pszWideVolumeLabel = szWideVolumeLabel;
      MultiByteToWideChar(CP_ACP, 0,
                          IVOLID_Volume_Label_PtrA((PCIVOLUMEID)pcvolid), -1,
                          szWideVolumeLabel, MAX_PATH);
   }
   else
   {
      pszWideVolumeLabel = IVOLID_Volume_Label_Ptr((PCIVOLUMEID)pcvolid);
   }
#endif

   /* Were we given a local path to check first? */

   if (IsLocalDrivePath(pcszFullPath))
      /* Yes.  Check it. */
      bResult = IsPathOnVolume(pcszFullPath, (PCIVOLUMEID)pcvolid,
                               &bAvailable);
   else
   {
      /* No. */

      bAvailable = FALSE;
      bResult = TRUE;
   }

   if (bResult)
   {
      /* Did we find the volume? */

      if (bAvailable)
      {
         /* Yes. */

         ASSERT(lstrlen(pcszFullPath) < MAX_PATH_LEN);
         lstrcpy(pszFoundPathBuf, pcszFullPath);
      }
      else
      {
         /*
          * No.  Should we search other matching local devices for the volume?
          */

         if (IS_FLAG_SET(dwInFlags, SFLP_IFL_LOCAL_SEARCH))
         {
            TCHAR chOriginalDrive;
            UINT uDrive;
            DWORD dwLogicalDrives;

            /* Yes. */

#ifdef UNICODE
            WARNING_OUT((TEXT("SearchForLocalPath(): Searching for local volume \"%s\", as requested."),
                         pszWideVolumeLabel));
#else
            WARNING_OUT((TEXT("SearchForLocalPath(): Searching for local volume \"%s\", as requested."),
                         IVOLID_Volume_Label_Ptr((PCIVOLUMEID)pcvolid)));
#endif

            ASSERT(IsCharAlpha(*pcszFullPath));
            chOriginalDrive = *pcszFullPath;

            ASSERT(lstrlen(pcszFullPath) < MAX_PATH_LEN);
            lstrcpy(pszFoundPathBuf, pcszFullPath);

            /* Get bit mask of local logical drives. */

            dwLogicalDrives = GetLogicalDrives();

            for (uDrive = 0; uDrive < MAX_LOCAL_DRIVES; uDrive++)
            {
               if (IS_FLAG_SET(dwLogicalDrives, (1 << uDrive)))
               {
                  TCHAR chDrive;

                  chDrive = (TCHAR)(TEXT('A') + uDrive);
                  ASSERT(IsCharAlpha(chDrive));

                  if (chDrive != chOriginalDrive)
                  {
                     TCHAR rgchLocalRootPath[DRIVE_ROOT_PATH_LEN];

                     lstrcpy(rgchLocalRootPath, TEXT("A:\\"));
                     rgchLocalRootPath[0] = chDrive;

                     /*
                      * Does this drive's type match the target volume's drive
                      * type?
                      */

                     if (GetDriveType(rgchLocalRootPath) == ((PCIVOLUMEID)pcvolid)->uDriveType)
                     {
                        /* Yes.  Check the volume. */

                        TRACE_OUT((TEXT("SearchForLocalPath(): Checking local root path %s."),
                                   rgchLocalRootPath));

                        bResult = IsPathOnVolume(rgchLocalRootPath,
                                                 (PCIVOLUMEID)pcvolid,
                                                 &bAvailable);

                        if (bResult)
                        {
                           if (bAvailable)
                           {
                              ASSERT(lstrlen(pcszFullPath) < MAX_PATH_LEN);
                              lstrcpy(pszFoundPathBuf, pcszFullPath);

                              ASSERT(IsCharAlpha(*pszFoundPathBuf));
                              *pszFoundPathBuf = chDrive;

                              TRACE_OUT((TEXT("SearchForLocalPath(): Found matching volume on local path %s."),
                                         pszFoundPathBuf));

                              break;
                           }
                        }
                        else
                           break;
                     }
                  }
               }
            }
         }
         else
            /* No. */
#ifdef UNICODE
            WARNING_OUT((TEXT("SearchForLocalPath(): Not searching for local volume \"%s\", as requested."),
                         pszWideVolumeLabel));
#else
            WARNING_OUT((TEXT("SearchForLocalPath(): Not searching for local volume \"%s\", as requested."),
                         IVOLID_Volume_Label_Ptr((PCIVOLUMEID)pcvolid)));
#endif
      }
   }

   ASSERT(! bResult ||
          ! bAvailable ||
          IsLocalDrivePath(pszFoundPathBuf));

   return(bResult && bAvailable);
}


/*
** GetVolumeIDLen()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE UINT GetVolumeIDLen(PCVOLUMEID pcvolid)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));

   return(((PCIVOLUMEID)pcvolid)->ucbSize);
}


/*
** GetVolumeSerialNumber()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetVolumeSerialNumber(PCVOLUMEID pcvolid,
                                  PCDWORD *ppcdwSerialNumber)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));
   ASSERT(IS_VALID_WRITE_PTR(ppcdwSerialNumber, PCDWORD));

   *ppcdwSerialNumber = &(((PCIVOLUMEID)pcvolid)->dwSerialNumber);

   ASSERT(IS_VALID_READ_PTR(*ppcdwSerialNumber, CDWORD));

   return(TRUE);
}


/*
** GetVolumeDriveType()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetVolumeDriveType(PCVOLUMEID pcvolid, PCUINT *ppcuDriveType)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));
   ASSERT(IS_VALID_WRITE_PTR(ppcuDriveType, PCUINT));

   *ppcuDriveType = &(((PCIVOLUMEID)pcvolid)->uDriveType);

   ASSERT(IS_VALID_READ_PTR(*ppcuDriveType, CUINT));

   return(TRUE);
}


/*
** GetVolumeLabel()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetVolumeLabel(PCVOLUMEID pcvolid, LPCSTR *ppcszVolumeLabel)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));
   ASSERT(IS_VALID_WRITE_PTR(ppcszVolumeLabel, LPCTSTR));

   *ppcszVolumeLabel = IVOLID_Volume_Label_PtrA((PCIVOLUMEID)pcvolid);

   ASSERT(IS_VALID_STRING_PTRA(*ppcszVolumeLabel, CSTR));

   return(TRUE);
}

#ifdef UNICODE
/*
** GetVolumeLabelW()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetVolumeLabelW(PCVOLUMEID pcvolid, LPCWSTR *ppcszVolumeLabel)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));
   ASSERT(IS_VALID_WRITE_PTR(ppcszVolumeLabel, LPCTSTR));

   if (((PCIVOLUMEID)pcvolid)->ucbVolumeLabelOffset == SIZEOF(IVOLUMEIDW))
   {
       *ppcszVolumeLabel = IVOLID_Volume_Label_PtrW((PCIVOLUMEID)pcvolid);

       ASSERT(IS_VALID_STRING_PTR(*ppcszVolumeLabel, CSTR));
   }
   else
   {
       *ppcszVolumeLabel = NULL;
   }

   return(TRUE);
}
#endif

/*
** CompareDWORDs()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE COMPARISONRESULT CompareDWORDs(DWORD dwFirst, DWORD dwSecond)
{
   COMPARISONRESULT cr;

   /* Any DWORDs are valid input. */

   if (dwFirst < dwSecond)
      cr = CR_FIRST_SMALLER;
   else if (dwFirst > dwSecond)
      cr = CR_FIRST_LARGER;
   else
      cr = CR_EQUAL;

   ASSERT(IsValidCOMPARISONRESULT(cr));

   return(cr);
}


#if defined(DEBUG) || defined (VSTF)

/*
** IsValidPCVOLUMEID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCVOLUMEID(PCVOLUMEID pcvolid)
{
   return(IS_VALID_STRUCT_PTR((PCIVOLUMEID)pcvolid, CIVOLUMEID));
}

#endif


#ifdef DEBUG

/*
** DumpVolumeID()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DumpVolumeID(PCVOLUMEID pcvolid)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcvolid, CVOLUMEID));

   PLAIN_TRACE_OUT((TEXT("%s%s[local volume ID] ucbSize = %#x"),
                    INDENT_STRING,
                    INDENT_STRING,
                    ((PCIVOLUMEID)pcvolid)->ucbSize));
   PLAIN_TRACE_OUT((TEXT("%s%s[local volume ID] drive type %u"),
                    INDENT_STRING,
                    INDENT_STRING,
                    ((PCIVOLUMEID)pcvolid)->uDriveType));
   PLAIN_TRACE_OUT((TEXT("%s%s[local volume ID] serial number %#08lx"),
                    INDENT_STRING,
                    INDENT_STRING,
                    ((PCIVOLUMEID)pcvolid)->dwSerialNumber));
   PLAIN_TRACE_OUT((TEXT("%s%s[local volume ID] label \"%s\""),
                    INDENT_STRING,
                    INDENT_STRING,
                    IVOLID_Volume_Label_Ptr((PCIVOLUMEID)pcvolid)));

   return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncapp\syncapp.c ===
#include "syncapp.h"

#ifndef WIN32
#include <w32sys.h>             // for IsPEFormat definition
#endif

static TCHAR const g_szAppName [] = TEXT("SYNCAPP") ;
static TCHAR const c_szDLL[]      = TEXT("SYNCUI.DLL");
static CHAR  const c_szFunction[] = "Briefcase_Create"; // Lib entry point (never UNICODE)

static HINSTANCE hInst;
static HICON g_hIcon;

static HINSTANCE g_hModule;
static RUNDLLPROC g_lpfnCommand;
static HWND g_hwndStub;

static TCHAR s_szRunDLL32[] = TEXT("SYNCAPP.EXE ");

static BOOL   ParseCommand(void)
{
        // Load the library and get the procedure address
        // Note that we try to get a module handle first, so we don't need
        // to pass full file names around
        //

        g_hModule = GetModuleHandle(c_szDLL);
        if (g_hModule)
        {
                TCHAR szName[MAXPATHLEN];

                GetModuleFileName(g_hModule, szName, ARRAYSIZE(szName));
                LoadLibrary(szName);
        }
        else
        {
                g_hModule = LoadLibrary(c_szDLL);
                if ((UINT)g_hModule <= 32)
                {
                        return(FALSE);
                }
        }

        g_lpfnCommand = (RUNDLLPROC)GetProcAddress(g_hModule, c_szFunction);
        if (!g_lpfnCommand)
        {
                FreeLibrary(g_hModule);
                return(FALSE);
        }

        return(TRUE);
}


LRESULT CALLBACK WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
        switch(iMessage)
        {
        case WM_CREATE:
                g_hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_DEFAULT));
                break;

        case WM_DESTROY:
                break;

        default:
                return DefWindowProc(hWnd, iMessage, wParam, lParam) ;
                break;
        }

        return 0L;
}


static BOOL   InitStubWindow(HINSTANCE hInst, HINSTANCE hPrevInstance)
{
        WNDCLASS wndclass;

        if (!hPrevInstance)
        {
                wndclass.style         = 0 ;
                wndclass.lpfnWndProc   = (WNDPROC)WndProc ;
                wndclass.cbClsExtra    = 0 ;
                wndclass.cbWndExtra    = 0 ;
                wndclass.hInstance     = hInst ;
                wndclass.hIcon         = LoadIcon(hInst, MAKEINTRESOURCE(IDI_DEFAULT)) ;
                wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
                wndclass.hbrBackground = GetStockObject (WHITE_BRUSH) ;
                wndclass.lpszMenuName  = NULL ;
                wndclass.lpszClassName = g_szAppName ;

                if (!RegisterClass(&wndclass))
                {
                        return(FALSE);
                }
        }

        g_hwndStub = CreateWindow(g_szAppName, TEXT(""), 0,
                0, 0, 0, 0, NULL, NULL, hInst, NULL);

        return(g_hwndStub != NULL);
}


static void   CleanUp(void)
{
        DestroyWindow(g_hwndStub);

        FreeLibrary(g_hModule);
}


int  WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszWinMainCmdLine, int nCmdShow)
{
        LPTSTR lpszCmdLine;
        hInst = hInstance;

        //
        // The command line passed to WinMain is always ANSI, so for UNICODE
        // builds we need to ask for the command line in UNICODE
        //

#ifdef UNICODE

        //
        // Since the command line returned from GetCommandLine includes
        // argv[0], but the one passed to Winmain does not, we have
        // to strip argv[0] in order to be equivalent
        //

        lpszCmdLine = GetCommandLine();
        
        //
        // Skip past program name (first token in command line).
        // Check for and handle quoted program name.
        //
        
        if ( *lpszCmdLine == '\"' ) 
        {
    
            //
            // Scan, and skip over, subsequent characters until
            // another double-quote or a null is encountered.
            //
    
            while ( *++lpszCmdLine && (*lpszCmdLine
                 != '\"') );
            //
            // If we stopped on a double-quote (usual case), skip
            // over it.
            //
    
            if ( *lpszCmdLine == '\"' )
                lpszCmdLine++;
        }
        else 
        {
            while (*lpszCmdLine > ' ')
                lpszCmdLine++;
        }

        //
        // Skip past any white space preceeding the second token.
        //
    
        while (*lpszCmdLine && (*lpszCmdLine <= ' ')) 
        {
            lpszCmdLine++;
        }

#else
        lpszCmdLine = lpszWinMainCmdLine;
#endif

        // turn off critical error stuff
        SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

        if (!ParseCommand())
        {
                goto Error0;
        }

        if (!InitStubWindow(hInstance, hPrevInstance))
        {
                goto Error1;
        }

        (*g_lpfnCommand)(g_hwndStub, hInstance, lpszCmdLine, nCmdShow);

Error1:
        CleanUp();
Error0:
        return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\util.c ===
/*
 * util.c - Miscellaneous utility functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/****************************** Public Functions *****************************/


/*
** IsLocalDrivePath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsLocalDrivePath(LPCTSTR pcszFullPath)
{
   BOOL bResult;

   ASSERT(IsFullPath(pcszFullPath));

   bResult = IsDrivePath(pcszFullPath);

   if (bResult)
   {
      TCHAR rgchRootPath[DRIVE_ROOT_PATH_LEN];

      ASSERT(IsCharAlpha(*pcszFullPath));

      lstrcpy(rgchRootPath, TEXT("A:\\"));
      rgchRootPath[0] = *pcszFullPath;

      bResult = (GetDriveType(rgchRootPath) != DRIVE_REMOTE);
   }

   return(bResult);
}


/*
** IsUNCPath()
**
** Determines whether or not a path is in "\\server\share" UNC form.
**
** Arguments:     pcszPath - path to examine
**
** Returns:       TRUE if path is a UNC path.  FALSE if not.
**
** Side Effects:  none
**
** A UNC path is a string of the form two slashes, one or more non-slashes, one
** slash, one or more non-slashes
*/
PUBLIC_CODE BOOL IsUNCPath(LPCTSTR pcszFullPath)
{
   BOOL bResult = FALSE;

   ASSERT(IsFullPath(pcszFullPath));

   if (lstrlen(pcszFullPath) >= 5 &&
       IS_SLASH(pcszFullPath[0]) &&
       IS_SLASH(pcszFullPath[1]) &&
       ! IS_SLASH(pcszFullPath[2]))
   {
      LPCTSTR pcsz;

      for (pcsz = &(pcszFullPath[2]); *pcsz; pcsz = CharNext(pcsz))
      {
         if (IS_SLASH(*pcsz))
         {
            bResult = (*(pcsz + 1) &&
                       ! IS_SLASH(*(pcsz + 1)));

            break;
         }
      }
   }

   return(bResult);
}


/*
** DeleteLastDrivePathElement()
**
** Deletes the last path element from a drive path.
**
** Arguments:     pszDrivePath - drive path whose last element is to be deleted
**
** Returns:       TRUE if path element deleted.  FALSE if not, i.e., given path
**                is root path.
**
** Side Effects:  none
**
** Examples:
**
**    input path                    output path
**    ----------                    -----------
**    c:\                           c:\
**    c:\foo                        c:\
**    c:\foo\bar                    c:\foo
**    c:\foo\bar\                   c:\foo\bar
**
** N.b., this function does not perform any validity tests on the format of the
** input path string.
*/
PUBLIC_CODE BOOL DeleteLastDrivePathElement(LPTSTR pszDrivePath)
{
   BOOL bHackIt;
   LPTSTR pszEndOfDriveSpec;

   ASSERT(IsDrivePath(pszDrivePath));

   pszEndOfDriveSpec = pszDrivePath + 3;

   /* Is this a a root path? */

   bHackIt = *pszEndOfDriveSpec;

   if (bHackIt)
      DeleteLastPathElement(pszEndOfDriveSpec);

   ASSERT(IsDrivePath(pszDrivePath));

   return(bHackIt);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsContained()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsContained(PCVOID pcvJar, UINT ucbJarLen, PCVOID pcvJelly,
                        UINT ucbJellyLen)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_READ_BUFFER_PTR(pcvJar, CVOID, ucbJarLen));
   ASSERT(IS_VALID_READ_BUFFER_PTR(pcvJelly, CVOID, ucbJellyLen));

   if (EVAL(pcvJelly >= pcvJar))
   {
      UINT ucbJellyOffset;

      ucbJellyOffset = (PCBYTE)pcvJelly - (PCBYTE)pcvJar;

      if (EVAL(ucbJellyOffset < ucbJarLen) &&
          EVAL(ucbJellyLen < ucbJarLen - ucbJellyOffset))
         bResult = TRUE;
   }

   return(bResult);
}


/*
** IsValidCNRName()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidCNRName(LPCTSTR pcszCNRName)
{
   BOOL bResult;

   /* Any valid string < MAX_PATH_LEN bytes long is a valid CNR name. */

   bResult = (IS_VALID_STRING_PTR(pcszCNRName, CSTR) &&
              EVAL(lstrlen(pcszCNRName) < MAX_PATH_LEN));

#ifdef DEBUG

   /*
    * RIP if a CNR name ends in a slash 
    */

   if (bResult)
   {
      if (IsUNCPath(pcszCNRName))
      {
         ASSERT(! IS_SLASH(*(CharPrev(pcszCNRName, pcszCNRName + lstrlen(pcszCNRName)))));
      }
   }

#endif

   return(bResult);
}

#endif


#ifdef DEBUG

/*
** IsDriveRootPath()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsDriveRootPath(LPCTSTR pcszPath)
{
   return(IsDrivePath(pcszPath) &&
          lstrlen(pcszPath) == 3);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\linkinfo\server.c ===
/*
 * server.c - Server vtable functions module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "server.h"


/* Module Variables
 *******************/

#pragma data_seg(DATA_SEG_PER_INSTANCE)

/*
 * Assume that we don't need to serialize access to MhinstServerDLL and Msvt
 * since they are only modified during first PROCESS_ATTACH.  Access to shared
 * data is protected during AttachProcess().
 */

PRIVATE_DATA HINSTANCE MhinstServerDLL = NULL;

PRIVATE_DATA SERVERVTABLE Msvt =
{
   NULL,
   NULL
};

#pragma data_seg()


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCSERVERVTABLE(PCSERVERVTABLE);

#endif


#ifdef DEBUG

/*
** IsValidPCSERVERVTABLE()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCSERVERVTABLE(PCSERVERVTABLE pcsvt)
{
   return(IS_VALID_READ_PTR(pcsvt, CSERVERVTABLE) &&
          IS_VALID_CODE_PTR(pcsvt->GetNetResourceFromLocalPath, PFNGETNETRESOURCEFROMLOCALPATH) &&
          IS_VALID_CODE_PTR(pcsvt->GetLocalPathFromNetResource, PFNGETLOCALPATHFROMNETRESOURCE));
}

#endif


/****************************** Public Functions *****************************/


/*
** ProcessInitServerModule()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ProcessInitServerModule(void)
{
   TCHAR rgchDLLPath[MAX_PATH_LEN];
   LONG lcb;

   /* Load server DLL. */

   lcb = SIZEOF(rgchDLLPath);

   if (RegQueryValue(HKEY_CLASSES_ROOT, TEXT("Network\\SharingHandler"), rgchDLLPath,
                     &lcb) == ERROR_SUCCESS)
   {
      if (rgchDLLPath[0])
      {
         HINSTANCE hinst;

         hinst = LoadLibrary(rgchDLLPath);

         if (hinst)
         {
            PFNGETNETRESOURCEFROMLOCALPATH GetNetResourceFromLocalPath;
            PFNGETLOCALPATHFROMNETRESOURCE GetLocalPathFromNetResource;

#ifdef UNICODE
            GetNetResourceFromLocalPath = (PFNGETNETRESOURCEFROMLOCALPATH)
					GetProcAddress(hinst, "GetNetResourceFromLocalPathW");
            GetLocalPathFromNetResource = (PFNGETLOCALPATHFROMNETRESOURCE)
					GetProcAddress(hinst, "GetLocalPathFromNetResourceW");
#else // UNICODE
#ifdef WINNT
            GetNetResourceFromLocalPath = (PFNGETNETRESOURCEFROMLOCALPATH)
					GetProcAddress(hinst, "GetNetResourceFromLocalPathA");
            GetLocalPathFromNetResource = (PFNGETLOCALPATHFROMNETRESOURCE)
					GetProcAddress(hinst, "GetLocalPathFromNetResourceA");
#else // WINNT
            GetNetResourceFromLocalPath = (PFNGETNETRESOURCEFROMLOCALPATH)
					GetProcAddress(hinst, "GetNetResourceFromLocalPath");
            GetLocalPathFromNetResource = (PFNGETLOCALPATHFROMNETRESOURCE)
					GetProcAddress(hinst, "GetLocalPathFromNetResource");
#endif // WINNT
#endif // UNICODE

            if (GetNetResourceFromLocalPath && GetLocalPathFromNetResource)
            {
               ASSERT(AccessIsExclusive());

               Msvt.GetNetResourceFromLocalPath = GetNetResourceFromLocalPath;
               Msvt.GetLocalPathFromNetResource = GetLocalPathFromNetResource;

               MhinstServerDLL = hinst;

               ASSERT(IS_VALID_STRUCT_PTR((PCSERVERVTABLE)&Msvt, CSERVERVTABLE));
               ASSERT(IS_VALID_HANDLE(MhinstServerDLL, INSTANCE));

               TRACE_OUT((TEXT("ProcessInitServerModule(): Loaded sharing handler DLL %s."),
                          rgchDLLPath));
            }
         }
      }
   }

   return(TRUE);
}


/*
** ProcessExitServerModule()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void ProcessExitServerModule(void)
{
   /* Unload server DLL. */

   if (MhinstServerDLL)
   {
      ASSERT(IS_VALID_HANDLE(MhinstServerDLL, INSTANCE));
      EVAL(FreeLibrary(MhinstServerDLL));
      MhinstServerDLL = NULL;

      TRACE_OUT((TEXT("ProcessExitServerModule(): Unloaded sharing handler DLL.")));
   }

   return;
}


/*
** GetServerVTable()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL GetServerVTable(PCSERVERVTABLE *ppcsvt)
{
   BOOL bResult;

   ASSERT(IS_VALID_WRITE_PTR(ppcsvt, PCSERVERVTABLE));

   if (MhinstServerDLL)
   {
      *ppcsvt = &Msvt;

      bResult = TRUE;
   }
   else
      bResult = FALSE;

   ASSERT(! bResult || IS_VALID_STRUCT_PTR(*ppcsvt, CSERVERVTABLE));

   return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\atoms.h ===
//
// atoms.h: Atom handling
//
//

#ifndef __ATOMS_H__
#define __ATOMS_H__


/////////////////////////////////////////////////////  DEFINES

// Atom Table 
//
// We have our own atoms for two reasons:
//
//  1) Gives us greater flexibility for partial string searches,
//      in-place string replacements, and table resize
//  2) We don't know yet if Windows' local atom tables are sharable
//      in separate instances in Win32.
//

BOOL    PUBLIC Atom_Init (void);
void    PUBLIC Atom_Term (void);
int     PUBLIC Atom_Add (LPCTSTR psz);
UINT    PUBLIC Atom_AddRef(int atom);
void    PUBLIC Atom_Delete (int atom);
BOOL    PUBLIC Atom_Replace (int atom, LPCTSTR pszNew);
int     PUBLIC Atom_Find (LPCTSTR psz);
LPCTSTR  PUBLIC Atom_GetName (int atom);
BOOL    PUBLIC Atom_IsPartialMatch(int atom1, int atom2);
BOOL    PUBLIC Atom_Translate(int atomOld, int atomNew);

#define Atom_IsChildOf(atom1, atom2)    Atom_IsPartialMatch(atom1, atom2)
#define Atom_IsParentOf(atom1, atom2)   Atom_IsPartialMatch(atom2, atom1)

#define ATOM_ERR    (-1)

#define Atom_IsValid(atom)      (ATOM_ERR != (atom) && 0 != (atom))

#ifdef DEBUG

void    PUBLIC Atom_ValidateFn(int atom);
void    PUBLIC Atom_DumpAll();

#define VALIDATE_ATOM(atom)     Atom_ValidateFn(atom)

#else  // DEBUG

#define VALIDATE_ATOM(atom)

#endif // DEBUG

#endif // __ATOMS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\cache.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cache.c
//
//  This files contains code for the common cache lists
//
// History:
//  09-02-93 ScottH     Created
//  01-31-94 ScottH     Split into separate files
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers

/////////////////////////////////////////////////////  TYPEDEFS

typedef struct tagCITEM
    {
    int atomKey;        
    DEBUG_CODE( LPCTSTR pszKey; )

    LPVOID pvValue;
    UINT ucRef;
    } CITEM;        // item for generic cache


#define Cache_EnterCS(this)    EnterCriticalSection(&(this)->cs)
#define Cache_LeaveCS(this)    LeaveCriticalSection(&(this)->cs)


#define CACHE_GROW  8

#define Cache_Bogus(this)  (!(this)->hdpa || !(this)->hdpaFree || !(this)->hdsa)

// Given an index into the DPA, get the pointer to the DSA
//  
#define MyGetPtr(this, idpa)     DSA_GetItemPtr((this)->hdsa, (int)DPA_FastGetPtr((this)->hdpa, idpa))

#define DSA_GetPtrIndex(hdsa, ptr, cbItem)      \
                ((int)( (DWORD)(ptr) - (DWORD)DSA_GetItemPtr(hdsa, 0) ) / (cbItem))


/*----------------------------------------------------------
Purpose: Compare two CRLs by pathname
Returns: -1 if <, 0 if ==, 1 if >
Cond:    --
*/
int CALLBACK _export Cache_CompareIndexes(
    LPVOID lpv1,
    LPVOID lpv2,
    LPARAM lParam)      
    {
    int i1 = (int)lpv1;
    int i2 = (int)lpv2;
    HDSA hdsa = (HDSA)lParam;
    CITEM  * pitem1 = (CITEM  *)DSA_GetItemPtr(hdsa, i1);
    CITEM  * pitem2 = (CITEM  *)DSA_GetItemPtr(hdsa, i2);

    if (pitem1->atomKey < pitem2->atomKey)
        return -1;
    else if (pitem1->atomKey == pitem2->atomKey)
        return 0;
    else 
        return 1;
    }


/*----------------------------------------------------------
Purpose: Compare two CRLs by pathname
Returns: -1 if <, 0 if ==, 1 if >
Cond:    --
*/
int CALLBACK _export Cache_Compare(
    LPVOID lpv1,
    LPVOID lpv2,
    LPARAM lParam)      
    {
    // HACK: we know the first param is the address to a struct
    //  that contains the search criteria.  The second is an index 
    //  into the DSA.
    //
    int i2 = (int)lpv2;
    HDSA hdsa = (HDSA)lParam;
    CITEM  * pitem1 = (CITEM  *)lpv1;
    CITEM  * pitem2 = (CITEM  *)DSA_GetItemPtr(hdsa, i2);

    if (pitem1->atomKey < pitem2->atomKey)
        return -1;
    else if (pitem1->atomKey == pitem2->atomKey)
        return 0;
    else 
        return 1;
    }


/*----------------------------------------------------------
Purpose: Initialize the cache structure
Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC Cache_Init(
    CACHE  * pcache)
    {
    BOOL bRet;

    ASSERT(pcache);

    Cache_EnterCS(pcache);
        {
        if ((pcache->hdsa = DSA_Create(sizeof(CITEM), CACHE_GROW)) != NULL)
            {
            if ((pcache->hdpa = DPA_Create(CACHE_GROW)) == NULL)
                {
                DSA_Destroy(pcache->hdsa);
                pcache->hdsa = NULL;
                }
            else
                {
                if ((pcache->hdpaFree = DPA_Create(CACHE_GROW)) == NULL)
                    {
                    DPA_Destroy(pcache->hdpa);
                    DSA_Destroy(pcache->hdsa);
                    pcache->hdpa = NULL;
                    pcache->hdsa = NULL;
                    }
                }
            }
        bRet = pcache->hdsa != NULL;
        }
    Cache_LeaveCS(pcache);

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Initializes the cache's critical section.

Returns: --
Cond:    --
*/
void PUBLIC Cache_InitCS(
    CACHE  * pcache)
    {
    ASSERT(pcache);
    ZeroInit(pcache, CACHE);
    InitializeCriticalSection(&pcache->cs);
    }


/*----------------------------------------------------------
Purpose: Destroy the cache 
Returns: --
Cond:    --
*/
void PUBLIC Cache_Term(
    CACHE  * pcache,
    HWND hwndOwner,
    PFNFREEVALUE pfnFree)
    {
    ASSERT(pcache);
    ASSERT(!IsBadCodePtr((PROC)pfnFree));
    Cache_EnterCS(pcache);
        {
        if (pcache->hdpa != NULL)
            {
            CITEM  * pitem;
            int idpa;
            int cItem;
    
            ASSERT(pcache->hdsa != NULL);
    
            cItem = DPA_GetPtrCount(pcache->hdpa);
            for (idpa = 0; idpa < cItem; idpa++)
                {
                pitem = MyGetPtr(pcache, idpa);
    
                if (!IsBadCodePtr((PROC)pfnFree))
                    pfnFree(pitem->pvValue, hwndOwner);
    
                // Decrement reference count of atomKey
                Atom_Delete(pitem->atomKey);
                }
            DPA_Destroy(pcache->hdpa);
            pcache->hdpa = NULL;
            }
    
        if (pcache->hdpaFree != NULL)
            {
            DPA_Destroy(pcache->hdpaFree);
            pcache->hdpaFree = NULL;
            }
    
        if (pcache->hdsa != NULL)
            {
            DSA_Destroy(pcache->hdsa);
            pcache->hdsa = NULL;
            }
        }
    Cache_LeaveCS(pcache);
    }


/*----------------------------------------------------------
Purpose: Deletes the cache's critical section.

Returns: --
Cond:    --
*/
void PUBLIC Cache_DeleteCS(
    CACHE  * pcache)
    {
    // The cache should not be in use now (ie, it should be bogus)
    ASSERT(Cache_Bogus(pcache));

    if (Cache_Bogus(pcache))
        {
        DeleteCriticalSection(&pcache->cs);
        }
    }


/*----------------------------------------------------------
Purpose: Add an item to the cache list.  
Returns: TRUE on success

Cond:    If this fails, pvValue is not automatically freed
*/
BOOL PUBLIC Cache_AddItem(
    CACHE  * pcache,
    int atomKey,
    LPVOID pvValue)
    {
    BOOL bRet = FALSE;
    CITEM  * pitem = NULL;
    int cItem;
    int cFree;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
        {
        VALIDATE_ATOM(atomKey);
            
        if (!Cache_Bogus(pcache))
            {
            int iItem;

            // Add a new entry to the cache.  The cache has no set size limitation.
            //
            cFree = DPA_GetPtrCount(pcache->hdpaFree);
            if (cFree > 0)
                {
                // Use a free entry 
                //
                cFree--;
                iItem = (int)DPA_DeletePtr(pcache->hdpaFree, cFree);
                pitem = DSA_GetItemPtr(pcache->hdsa, iItem);
                }
            else
                {
                CITEM itemDummy;
        
                // Allocate a new entry
                //
                cItem = DSA_GetItemCount(pcache->hdsa);
                if ((iItem = DSA_InsertItem(pcache->hdsa, cItem+1, &itemDummy)) != -1)
                    pitem = DSA_GetItemPtr(pcache->hdsa, iItem);
                }
        
            // Fill in the info
            //
            if (pitem)
                {
                pitem->ucRef = 0;
                pitem->pvValue = pvValue;
                pitem->atomKey = atomKey;
                DEBUG_CODE( pitem->pszKey = Atom_GetName(atomKey); )
            
                // Now increment the reference count on this atomKey so it doesn't
                //  get deleted from beneath us!
                Atom_AddRef(atomKey);
            
                // Add the new entry to the ptr list and sort
                //
                cItem = DPA_GetPtrCount(pcache->hdpa);
                if (DPA_InsertPtr(pcache->hdpa, cItem+1, (LPVOID)iItem) == -1)
                    goto Add_Fail;
                DPA_Sort(pcache->hdpa, Cache_CompareIndexes, (LPARAM)pcache->hdsa);
            
                // Reset the FindFirst/FindNext in case this gets called in the
                //  middle of an enumeration.
                //    
                pcache->atomPrev = ATOM_ERR;
                bRet = TRUE;
                }

Add_Fail:
            if (!bRet)
                {
                // Add the entry to the free list and fail.  If even this 
                //  fails, we simply lose some slight efficiency, but this is 
                //  not a memory leak.
                //
                DPA_InsertPtr(pcache->hdpaFree, cFree+1, (LPVOID)iItem);
                }
            }
        }
    Cache_LeaveCS(pcache);

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Delete an item from the cache.
         If the reference count is 0, we do nothing.
         This also frees the actual value as well, using the
          pfnFreeValue function.

Returns: The reference count.  If 0, then we deleted it from cache.

Cond:    N.b.  Decrements the reference count.
*/
int PUBLIC Cache_DeleteItem(
    CACHE  * pcache,
    int atomKey,
    BOOL bNuke,         // TRUE to ignore reference count
    HWND hwndOwner,
    PFNFREEVALUE pfnFree)
    {
    int nRet = 0;
    CITEM item;
    CITEM  * pitem;
    int idpa;
    int cFree;

    ASSERT(pcache);
    ASSERT(!IsBadCodePtr((PROC)pfnFree));
    Cache_EnterCS(pcache);
        {
        if (!Cache_Bogus(pcache))
            {
            item.atomKey = atomKey;
            idpa = DPA_Search(pcache->hdpa, &item, 0, Cache_Compare, (LPARAM)pcache->hdsa, 
                DPAS_SORTED);
            if (idpa != -1)
                {
                VALIDATE_ATOM(atomKey);
            
                pitem = MyGetPtr(pcache, idpa);

                if (!bNuke && pitem->ucRef-- > 0)
                    {
                    nRet = pitem->ucRef+1;
                    }
                else
                    {
                    int iItem;

                    DPA_DeletePtr(pcache->hdpa, idpa);
                
                    // Free old pointer
                    if (!IsBadCodePtr((PROC)pfnFree))
                        pfnFree(pitem->pvValue, hwndOwner);        
                
                    Atom_Delete(pitem->atomKey);
                
                    DEBUG_CODE( pitem->atomKey = -1; )
                    DEBUG_CODE( pitem->pszKey = NULL; )
                    DEBUG_CODE( pitem->pvValue = NULL; )
                    DEBUG_CODE( pitem->ucRef = 0; )

                    // Reset the FindFirst/FindNext in case this gets 
                    //  called in the middle of an enumeration.
                    //    
                    pcache->atomPrev = ATOM_ERR;
                
                    // Add ptr to the free list.  If this fails, we simply lose 
                    //  some efficiency in reusing this portion of the cache.  
                    //  This is not a memory leak.
                    //
                    cFree = DPA_GetPtrCount(pcache->hdpaFree);
                    iItem = DSA_GetPtrIndex(pcache->hdsa, pitem, sizeof(CITEM));
                    DPA_InsertPtr(pcache->hdpaFree, cFree+1, (LPVOID)iItem);
                    }
                }
            }
        }
    Cache_LeaveCS(pcache);

    return nRet;
    }


/*----------------------------------------------------------
Purpose: Replace the contents of the value in the cache list.  
          If a value does not exist for the given key, return FALSE.
Returns: TRUE if success
Cond:    --
*/
BOOL PUBLIC Cache_ReplaceItem(
    CACHE  * pcache,
    int atomKey,
    LPVOID pvBuf,
    int cbBuf)
    {
    BOOL bRet = FALSE;
    CITEM item;
    CITEM  * pitem;
    int idpa;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
        {
        if (!Cache_Bogus(pcache))
            {
            // Search for an existing cache entry 
            //
            item.atomKey = atomKey;
            idpa = DPA_Search(pcache->hdpa, &item, 0, Cache_Compare, (LPARAM)pcache->hdsa, 
                DPAS_SORTED);
        
            if (idpa != -1)
                {
                // Found a value for this key.  Replace the contents.
                //
                pitem = MyGetPtr(pcache, idpa);
                ASSERT(pitem);

                BltByte(pvBuf, pitem->pvValue, cbBuf);
                bRet = TRUE;

                // No need to sort because key hasn't changed.
                }
            }
        }
    Cache_LeaveCS(pcache);

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Get the value of the given key and return a ptr to it
Returns: Ptr to actual entry

Cond:    Reference count is incremented
*/
LPVOID PUBLIC Cache_GetPtr(
    CACHE  * pcache,
    int atomKey)
    {
    LPVOID pvRet = NULL;
    CITEM item;
    CITEM  * pitem;
    int idpa;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
        {
        if (!Cache_Bogus(pcache))
            {
            item.atomKey = atomKey;
            idpa = DPA_Search(pcache->hdpa, &item, 0, Cache_Compare, (LPARAM)pcache->hdsa, 
                DPAS_SORTED);
            if (idpa != -1)
                {
                pitem = MyGetPtr(pcache, idpa);
                ASSERT(pitem);

                pitem->ucRef++;
                pvRet = pitem->pvValue;
                }
            }
        }
    Cache_LeaveCS(pcache);

    return pvRet;
    }


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Get the current reference count
Returns: Ptr to actual entry

Cond:    Used for debugging
*/
UINT PUBLIC Cache_GetRefCount(
    CACHE  * pcache,
    int atomKey)
    {
    UINT ucRef = (UINT)-1;
    CITEM item;
    CITEM  * pitem;
    int idpa;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
        {
        if (!Cache_Bogus(pcache))
            {
            item.atomKey = atomKey;
            idpa = DPA_Search(pcache->hdpa, &item, 0, Cache_Compare, (LPARAM)pcache->hdsa, 
                DPAS_SORTED);
            if (idpa != -1)
                {
                pitem = MyGetPtr(pcache, idpa);
                ASSERT(pitem);

                ucRef = pitem->ucRef;
                }
            }
        }
    Cache_LeaveCS(pcache);

    return ucRef;
    }
#endif


/*----------------------------------------------------------
Purpose: Get the value of the given key and return a copy of it
         in the supplied buffer
Returns: Copy of value in buffer
         TRUE if found, FALSE if not

Cond:    --
*/
BOOL PUBLIC Cache_GetItem(
    CACHE  * pcache,
    int atomKey,
    LPVOID pvBuf,
    int cbBuf)
    {
    BOOL bRet = FALSE;
    CITEM item;
    CITEM  * pitem;
    int idpa;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
        {
        if (!Cache_Bogus(pcache))
            {
            item.atomKey = atomKey;
            idpa = DPA_Search(pcache->hdpa, &item, 0, Cache_Compare, (LPARAM)pcache->hdsa, 
                DPAS_SORTED);
            if (idpa != -1)
                {
                pitem = MyGetPtr(pcache, idpa);
                ASSERT(pitem);

                BltByte(pvBuf, pitem->pvValue, cbBuf);
                bRet = TRUE;
                }
            }
        }
    Cache_LeaveCS(pcache);

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Get the first key in the cache.
Returns: Atom
         ATOM_ERR if cache is empty
Cond:    --
*/
int PUBLIC Cache_FindFirstKey(
    CACHE  * pcache)
    {
    int atomRet = ATOM_ERR;
    CITEM  * pitem;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
        {
        if (!Cache_Bogus(pcache))
            {
            int i;

            pcache->iPrev = 0;
            if (DPA_GetPtrCount(pcache->hdpa) > 0)
                {
                i = (int)DPA_FastGetPtr(pcache->hdpa, 0);

                pitem = DSA_GetItemPtr(pcache->hdsa, i);

                pcache->atomPrev = pitem->atomKey;
                atomRet = pitem->atomKey;

                VALIDATE_ATOM(atomRet);
                }
            }
        }
    Cache_LeaveCS(pcache);

    return atomRet;
    }


/*----------------------------------------------------------
Purpose: Get the next key in the cache.
Returns: Atom
         ATOM_ERR if we're at the end of the cache
Cond:    --
*/
int PUBLIC Cache_FindNextKey(
    CACHE  * pcache,
    int atomPrev)
    {
    int atomRet = ATOM_ERR;
    CITEM  * pitem;

    ASSERT(pcache);
    Cache_EnterCS(pcache);
        {
        if (!Cache_Bogus(pcache))
            {
            if (atomPrev != ATOM_ERR)
                {
                int i;

                if (atomPrev != pcache->atomPrev)
                    {
                    CITEM item;
            
                    // Search for atomPrev or next one nearest to it.  
                    //
                    item.atomKey = atomPrev;
                    pcache->iPrev = DPA_Search(pcache->hdpa, &item, 0, Cache_Compare, 
                        (LPARAM)pcache->hdsa, DPAS_SORTED | DPAS_INSERTBEFORE);
                    }
                else
                    pcache->iPrev++;
            
                if (DPA_GetPtrCount(pcache->hdpa) > pcache->iPrev)
                    {
                    i = (int)DPA_FastGetPtr(pcache->hdpa, pcache->iPrev);
                    pitem = DSA_GetItemPtr(pcache->hdsa, i);

                    pcache->atomPrev = pitem->atomKey;
                    atomRet = pitem->atomKey;

                    VALIDATE_ATOM(atomRet);
                    }
                }
            }
        }
    Cache_LeaveCS(pcache);

    return atomRet;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\cbs.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cbs.c
//
//  This files contains code for the cached briefcase structs
//
// History:
//  09-02-93 ScottH     Created
//  01-31-94 ScottH     Moved from cache.c
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers
#include "res.h"


CACHE g_cacheCBS = {0, 0, 0};        // Briefcase structure cache

#define CBS_EnterCS()    EnterCriticalSection(&g_cacheCBS.cs)
#define CBS_LeaveCS()    LeaveCriticalSection(&g_cacheCBS.cs)

#pragma data_seg(DATASEG_READONLY)  

SETbl const c_rgseOpenBriefcase[] = {
        { E_TR_OUT_OF_MEMORY,         IDS_OOM_OPENBRIEFCASE,      MB_ERROR },
        { E_OUTOFMEMORY,              IDS_OOM_OPENBRIEFCASE,      MB_ERROR },
        { E_TR_BRIEFCASE_LOCKED,      IDS_ERR_BRIEFCASE_LOCKED,   MB_WARNING },
        { E_TR_BRIEFCASE_OPEN_FAILED, IDS_ERR_OPEN_ACCESS_DENIED, MB_WARNING },
        { E_TR_NEWER_BRIEFCASE,       IDS_ERR_NEWER_BRIEFCASE,    MB_INFO },
        { E_TR_SUBTREE_CYCLE_FOUND,   IDS_ERR_OPEN_SUBTREECYCLE,  MB_WARNING },
        };

#pragma data_seg()


#ifdef DEBUG
void PRIVATE CBS_DumpEntry(
    CBS  * pcbs)
    {
    ASSERT(pcbs);

    TRACE_MSG(TF_ALWAYS, TEXT("CBS:  Atom %d: %s"), pcbs->atomBrf, Atom_GetName(pcbs->atomBrf));
    TRACE_MSG(TF_ALWAYS, TEXT("               Ref [%u]  Hbrf = %lx  "), 
        Cache_GetRefCount(&g_cacheCBS, pcbs->atomBrf),
        pcbs->hbrf);
    }


void PUBLIC CBS_DumpAll()
    {
    CBS  * pcbs;
    int atom;
    BOOL bDump;

    ENTEREXCLUSIVE()
        {
        bDump = IsFlagSet(g_uDumpFlags, DF_CBS);
        }
    LEAVEEXCLUSIVE()

    if (!bDump)
        return ;

    atom = Cache_FindFirstKey(&g_cacheCBS);
    while (atom != ATOM_ERR)
        {
        pcbs = Cache_GetPtr(&g_cacheCBS, atom);
        ASSERT(pcbs);
        if (pcbs)
            {
            CBS_DumpEntry(pcbs);
            CBS_Delete(atom, NULL);         // Decrement count
            }

        atom = Cache_FindNextKey(&g_cacheCBS, atom);
        }
    }
#endif


/*----------------------------------------------------------
Purpose: Save and close the briefcase.
Returns: --
Cond:    
         This function is serialized by the caller (Cache_Term or
         Cache_DeleteItem).
*/
void CALLBACK CBS_Free(
    LPVOID lpv,
    HWND hwndOwner)
    {
    HBRFCASE hbrf;
    CBS  * pcbs = (CBS  *)lpv;
    CRL  * pcrl;
    int atomPath = pcbs->atomBrf;
    int atom;
    TWINRESULT tr1;
    TWINRESULT tr2;
    DECLAREHOURGLASS;

    hbrf = pcbs->hbrf;

    // Save the briefcase with the same name it was opened
    //
    DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Saving and closing Briefcase %s (0x%lx)"), 
        Atom_GetName(atomPath), hbrf); )

    // Search thru the CRL cache for entries 
    //  sharing the same partial path as this briefcase
    //  and nuke them.
    //
    atom = Cache_FindFirstKey(&g_cacheCRL);
    while (atom != ATOM_ERR)
        {
        pcrl = Cache_GetPtr(&g_cacheCRL, atom);
        ASSERT(pcrl);

        if (pcrl)
            {
            if (hbrf == pcrl->hbrf)
                {
                // This atomKey belongs to this briefcase.  Nuke it.
                //
                DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Nuking CRL %d"), atom); )
                CRL_Nuke(atom);
                }
#ifdef DEBUG
            else
                DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  NOT Nuking CRL %d"), atom); )
#endif

            Cache_DeleteItem(&g_cacheCRL, atom, FALSE, hwndOwner, CRL_Free);     // Decrement count
            }

        atom = Cache_FindNextKey(&g_cacheCRL, atom);
        }

    // Save the briefcase.  We normally (re)specify the database
    //  pathname to handle the rename case.  However, if the
    //  move bit has been set, then we use the NULL parameter
    //  (save under current name) because we will depend on the
    //  shell to move the database.
    //
    ASSERT(Sync_IsEngineLoaded());

    // First check if the disk is available.  If it isn't, Windows will
    // blue-screen because we cannot close the database file.  So before
    // that happens, bring up a friendlier retry messagebox.
    RETRY_BEGIN(FALSE)
        {
        // Is disk unavailable?
        if ( !PathExists(Atom_GetName(atomPath)) )
            {
            // Yes; ask user to retry/cancel
            int id = MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_CLOSE_UNAVAIL_VOL),
                MAKEINTRESOURCE(IDS_CAP_SAVE),NULL,GUID_NULL,NULL, MB_RETRYCANCEL | MB_ICONWARNING);
            if (IDRETRY == id)
                RETRY_SET();
            }
        }
    RETRY_END()

    SetHourglass();
    tr1 = Sync_SaveBriefcase(pcbs->hbrf);
    tr2 = Sync_CloseBriefcase(pcbs->hbrf);
    if (TR_SUCCESS != tr1 || TR_SUCCESS != tr2)
        {
        DWORD dwError = GetLastError();

        switch (dwError)
            {
        case ERROR_ACCESS_DENIED:
            MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_SAVE_UNAVAIL_VOL), 
                MAKEINTRESOURCE(IDS_CAP_SAVE),NULL,GUID_NULL, NULL, MB_ERROR);
            break;
            
        default:
            if (TR_BRIEFCASE_WRITE_FAILED == tr1 || TR_BRIEFCASE_WRITE_FAILED == tr2)
                {
                LPTSTR psz;

                static UINT rgids[2] = { IDS_ERR_1_FullDiskSave, IDS_ERR_2_FullDiskSave };

                if (FmtString(&psz, IDS_ERR_F_FullDiskSave, rgids, ARRAYSIZE(rgids)))
                    {
                    MsgBox(hwndOwner, psz, MAKEINTRESOURCE(IDS_CAP_SAVE),NULL,GUID_NULL, NULL, MB_ERROR);
                    GFree(psz);
                    }
                }
            break;
            }
        }
    ResetHourglass();

    AbortEvt_Free(pcbs->pabortevt);

    SharedFree(&pcbs);
    }


/*----------------------------------------------------------
Purpose: Actually opens the briefcase and adds the briefcase
         handle to the given CBS struct.

Returns: standard hresult
Cond:    --
*/
HRESULT PRIVATE OpenTheBriefcase(
    LPCTSTR pszDatPath,
    int atomPath,
    CBS * pcbs,
    HWND hwndOwner)
    {
    HRESULT hres;
    TWINRESULT tr;
    BOOL bRet = FALSE;
    DWORD dwFlags = OB_FL_OPEN_DATABASE | OB_FL_TRANSLATE_DB_FOLDER | OB_FL_ALLOW_UI;
    int nDrive;
    int nDriveType;

    // Determine if we want to record the existence of this briefcase.
    // We don't care about briefcases on remote or floppy drives.
    nDrive = PathGetDriveNumber(pszDatPath);

    // Record this briefcase?
    nDriveType = DriveType(nDrive);
    if (DRIVE_CDROM != nDriveType && DRIVE_REMOVABLE != nDriveType && 
        DRIVE_RAMDRIVE != nDriveType &&
        !PathIsUNC(pszDatPath) && !IsNetDrive(nDrive))
        {
        // Yes
        SetFlag(dwFlags, OB_FL_LIST_DATABASE);

        TRACE_MSG(TF_GENERAL, TEXT("Remembering briefcase %s"), pszDatPath);
        }

    RETRY_BEGIN(FALSE)
        {
        tr = Sync_OpenBriefcase(pszDatPath, dwFlags, GetDesktopWindow(), &pcbs->hbrf);
        hres = HRESULT_FROM_TR(tr);

        // Unavailable disk?
        if (FAILED(hres))
            {
            DWORD dwError = GetLastError();

            if (ERROR_INVALID_DATA == dwError || ERROR_ACCESS_DENIED == dwError)
                {
                // Yes; ask user to retry/cancel
                int id = MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_OPEN_UNAVAIL_VOL),
                    MAKEINTRESOURCE(IDS_CAP_OPEN), NULL,GUID_NULL,NULL, MB_RETRYCANCEL | MB_ICONWARNING);

                // Set specific error value
                hres = E_TR_UNAVAILABLE_VOLUME;

                if (IDRETRY == id)
                    {
                    RETRY_SET();    // Try again
                    }
                }
            }
        }
    RETRY_END()

    if (SUCCEEDED(hres))
        {
        if (!Cache_AddItem(&g_cacheCBS, atomPath, (LPVOID)pcbs))
            {
            Sync_CloseBriefcase(pcbs->hbrf);
            hres = ResultFromScode(E_OUTOFMEMORY);
            }
        else
            {
            TCHAR szTmp[MAXPATHLEN]; 
            BOOL bRunWizard;

            lstrcpy(szTmp, pszDatPath);
            PathRemoveFileSpec(szTmp);
            PathAppend(szTmp, c_szDesktopIni);
            bRunWizard = GetPrivateProfileInt(STRINI_CLASSINFO, c_szRunWizard, 0, szTmp);

            // Run the wizard?
            if (bRunWizard)
                {
                // Yes; set a flag for the wizard
                SetFlag(pcbs->uFlags, CBSF_RUNWIZARD);

                // Delete the .ini entry
                WritePrivateProfileString(STRINI_CLASSINFO, c_szRunWizard, NULL, szTmp);
                }

            TRACE_MSG(TF_GENERAL, TEXT("Opened Briefcase %s (0x%lx)"), pszDatPath, pcbs->hbrf);
            }
        }
    return hres;
    }


/*----------------------------------------------------------
Purpose: This function handles the case when the engine fails 
         to open the database because the database file is
         corrupt.

Returns: standard hresult
Cond:    --
*/
HRESULT PRIVATE HandleCorruptDatabase(
    CBS * pcbs,
    int atomPath,
    LPCTSTR pszDatPath,      // Path of database file
    HWND hwndOwner)
    {
    TCHAR szTemplate[MAXPATHLEN];
    TCHAR szNewFile[MAXPATHLEN];
    LPTSTR pszNewPath = szTemplate;
    LPCTSTR pszPath = Atom_GetName(atomPath);
    LPTSTR psz;
    DWORD dwAttr;

    static UINT rgids[2] = { IDS_ERR_1_CorruptDB, IDS_ERR_2_CorruptDB };

    ASSERT(pszPath);

    // Create the new database name
    //
    SzFromIDS(IDS_BOGUSDBTEMPLATE, szTemplate, ARRAYSIZE(szTemplate));
    PathMakeUniqueName(szNewFile, ARRAYSIZE(szNewFile), TEXT("badbc.dat"), szTemplate,
        pszPath);
    lstrcpy(pszNewPath, pszPath);
    PathAppend(pszNewPath, szNewFile);

    // Move the database
    //
    MoveFile(pszDatPath, pszNewPath);

    // Unhide the corrupt database 
    //
    dwAttr = GetFileAttributes(pszNewPath);
    if (dwAttr != 0xFFFFFFFF)
        {
        ClearFlag(dwAttr, FILE_ATTRIBUTE_HIDDEN);
        SetFileAttributes(pszNewPath, dwAttr);
        }

    if (FmtString(&psz, IDS_ERR_F_CorruptDB, rgids, ARRAYSIZE(rgids)))
        {
        MsgBox(hwndOwner, psz, MAKEINTRESOURCE(IDS_CAP_OPEN),NULL,GUID_NULL, NULL, MB_ERROR);
        GFree(psz);
        }
    DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Renaming corrupt database to %s"), pszNewPath); )

    // Retry opening...
    //
    return OpenTheBriefcase(pszDatPath, atomPath, pcbs, hwndOwner);
    }


/*----------------------------------------------------------
Purpose: Add the atomPath to the cache.  We open the briefcase
         database if it needs opening.  If atomPath is already
         in the cache, simply return the pointer to the entry.

Returns: standard hresult

Cond:    Must call CBS_Delete for every call to this function
*/
HRESULT PUBLIC CBS_Add(
    PCBS * ppcbs,
    int atomPath,
    HWND hwndOwner)
    {
    HRESULT hres = NOERROR;
    TCHAR szDatPath[MAXPATHLEN];
    CBS  * pcbs;
    
    CBS_EnterCS();
        {
        pcbs = Cache_GetPtr(&g_cacheCBS, atomPath);
        if (NULL == pcbs)
            {
            // Allocate using commctrl's Alloc, so the structure will be in
            // shared heap space across processes.
            pcbs = SharedAllocType(CBS);
            if (NULL == pcbs)
                {
                hres = ResultFromScode(E_OUTOFMEMORY);
                }
            else
                {
                LPCTSTR pszPath = Atom_GetName(atomPath);
                LPCTSTR pszDBName;

                ASSERT(pszPath);

                pcbs->atomBrf = atomPath;
                pcbs->uFlags = 0;

                // Create an abort event object simply so we can programmatically
                // cancel a createreclist call in the worker thread.  This
                // would happen if the user closed the briefcase during
                // CreateRecList.  

                // (it is ok if this fails)
                AbortEvt_Create(&pcbs->pabortevt, AEF_SHARED);
                    
                DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Opening Briefcase %s..."), pszPath); )

                if (IsLFNDrive(pszPath))
                    {
                    pszDBName = g_szDBName;
                    SetFlag(pcbs->uFlags, CBSF_LFNDRIVE);
                    }
                else
                    pszDBName = g_szDBNameShort;

                if (PathsTooLong(pszPath, pszDBName))
                    {
                    MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_OPEN_TOOLONG), 
                           MAKEINTRESOURCE(IDS_CAP_OPEN), NULL,GUID_NULL,NULL, MB_ERROR);
                    hres = E_FAIL;
                    }
                else
                    {
                    PathCombine(szDatPath, pszPath, pszDBName);
                    hres = OpenTheBriefcase(szDatPath, atomPath, pcbs, hwndOwner);
                    if (FAILED(hres))
                        {
                        DEBUG_CODE( TRACE_MSG(TF_ERROR, TEXT("Open failed.  Error is %s"), SzFromTR(GET_TR(hres))); )

                        SEMsgBox(hwndOwner, IDS_CAP_OPEN, hres, c_rgseOpenBriefcase, ARRAYSIZE(c_rgseOpenBriefcase));

                        // Is this a corrupt briefcase?
                        if (E_TR_CORRUPT_BRIEFCASE == hres)
                            {
                            // Yes; try to create a new database
                            hres = HandleCorruptDatabase(pcbs, atomPath, szDatPath, hwndOwner);
                            }
                        }
                    }
                }
            }

        // Did something fail above?
        if (FAILED(hres))
            {
            // Yes; cleanup
            if (pcbs)
                {
                if (pcbs->hbrf)
                    Sync_CloseBriefcase(pcbs->hbrf);

                SharedFree(&pcbs);
                }
            }

        *ppcbs = pcbs;
        }
    CBS_LeaveCS();

    return hres;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\comm.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: comm.c
//
//  This files contains all common utility routines
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"     // common s
#include "res.h"


// Some of these are replacements for the C runtime routines.
//  This is so we don't have to link to the CRT libs.
//

/*----------------------------------------------------------
Purpose: memset

         Swiped from the C 7.0 runtime sources.

Returns:
Cond:
*/
CHAR * PUBLIC lmemset(      // DO NO UNICODIZE
    CHAR * dst,
    CHAR val,
    UINT count)
    {
    CHAR * start = dst;

    while (count--)
        *dst++ = val;
    return(start);
    }


/*----------------------------------------------------------
Purpose: memmove

         Swiped from the C 7.0 runtime sources.

Returns:
Cond:
*/
CHAR * PUBLIC lmemmove(
    CHAR *  dst,
    CHAR * src,
    int count)
    {
    CHAR * ret = dst;

    if (dst <= src || dst >= (src + count)) {
        /*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
        while (count--)
            *dst++ = *src++;
        }
    else {
        /*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        dst += count - 1;
        src += count - 1;

        while (count--)
            *dst-- = *src--;
        }

    return(ret);
    }


/*----------------------------------------------------------
Purpose: My verion of atoi.  Supports hexadecimal too.
Returns: integer
Cond:    --
*/
int PUBLIC AnsiToInt(
    LPCTSTR pszString)
    {
    int n;
    BOOL bNeg = FALSE;
    LPCTSTR psz;
    LPCTSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == TEXT(' ') || *psz == TEXT('\n') || *psz == TEXT('\t'); psz = CharNext(psz))
        ;

    // Determine possible explicit signage
    //
    if (*psz == TEXT('+') || *psz == TEXT('-'))
        {
        bNeg = (*psz == TEXT('+')) ? FALSE : TRUE;
        psz = CharNext(psz);
        }

    // Or is this hexadecimal?
    //
    pszAdj = CharNext(psz);
    if (*psz == TEXT('0') && (*pszAdj == TEXT('x') || *pszAdj == TEXT('X')))
        {
        bNeg = FALSE;   // Never allow negative sign with hexadecimal numbers
        psz = CharNext(pszAdj);

        // Do the conversion
        //
        for (n = 0; ; psz = CharNext(psz))
            {
            if (*psz >= TEXT('0') && *psz <= TEXT('9'))
                n = 0x10 * n + *psz - TEXT('0');
            else
                {
                TCHAR ch = *psz;
                int n2;

                if (ch >= TEXT('a'))
                    ch -= TEXT('a') - TEXT('A');

                n2 = ch - TEXT('A') + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
                }
            }
        }
    else
        {
        for (n = 0; *psz >= TEXT('0') && *psz <= TEXT('9'); psz = CharNext(psz))
            n = 10 * n + *psz - TEXT('0');
        }

    return bNeg ? -n : n;
    }


/*----------------------------------------------------------
Purpose: General front end to invoke dialog boxes
Returns: result from EndDialog
Cond:    --
*/
int PUBLIC DoModal(
    HWND hwndParent,            // owner of dialog
    DLGPROC lpfnDlgProc,        // dialog proc
    UINT uID,                   // dialog template ID
    LPARAM lParam)              // extra parm to pass to dialog (may be NULL)
    {
    int nResult = -1;

    nResult = DialogBoxParam(g_hinst, MAKEINTRESOURCE(uID), hwndParent,
        lpfnDlgProc, lParam);

    return nResult;
    }


/*----------------------------------------------------------
Purpose: Sets the rectangle with the bounding extent of the given string.
Returns: Rectangle
Cond:    --
*/
void PUBLIC SetRectFromExtent(
    HDC hdc,
    LPRECT lprect,
    LPCTSTR lpcsz)
    {
    SIZE size;

    GetTextExtentPoint(hdc, lpcsz, lstrlen(lpcsz), &size);
    SetRect(lprect, 0, 0, size.cx, size.cy);
    }


/*----------------------------------------------------------
Purpose: Sees whether the entire string will fit in *prc.
         If not, compute the numbder of chars that will fit
         (including ellipses).  Returns length of string in
         *pcchDraw.

         Taken from COMMCTRL.

Returns: TRUE if the string needed ellipses
Cond:    --
*/
BOOL PRIVATE NeedsEllipses(
    HDC hdc,
    LPCTSTR pszText,
    RECT * prc,
    int * pcchDraw,
    int cxEllipses)
    {
    int cchText;
    int cxRect;
    int ichMin, ichMax, ichMid;
    SIZE siz;

    cxRect = prc->right - prc->left;

    cchText = lstrlen(pszText);

    if (cchText == 0)
        {
        *pcchDraw = cchText;
        return FALSE;
        }

    GetTextExtentPoint(hdc, pszText, cchText, &siz);

    if (siz.cx <= cxRect)
        {
        *pcchDraw = cchText;
        return FALSE;
        }

    cxRect -= cxEllipses;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxRect > 0)
        {
        // Binary search to find character that will fit
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
            {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            //
            ichMid = (ichMin + ichMax + 1) / 2;

            GetTextExtentPoint(hdc, &pszText[ichMin], ichMid - ichMin, &siz);

            if (siz.cx < cxRect)
                {
                ichMin = ichMid;
                cxRect -= siz.cx;
                }
            else if (siz.cx > cxRect)
                {
                ichMax = ichMid - 1;
                }
            else
                {
                // Exact match up up to ichMid: just exit.
                //
                ichMax = ichMid;
                break;
                }
            }

        // Make sure we always show at least the first character...
        //
        if (ichMax < 1)
            ichMax = 1;
        }

    *pcchDraw = ichMax;
    return TRUE;
    }


#define CCHELLIPSES     3
#define DT_LVWRAP       (DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)

/*----------------------------------------------------------
Purpose: Draws text the shell's way.

         Taken from COMMCTRL.

Returns: --

Cond:    This function requires TRANSPARENT background mode
         and a properly selected font.
*/
void PUBLIC MyDrawText(
    HDC hdc, 
    LPCTSTR pszText, 
    RECT * prc, 
    UINT flags, 
    int cyChar, 
    int cxEllipses, 
    COLORREF clrText, 

    COLORREF clrTextBk)
    {
    int cchText;
    COLORREF clrSave;
    COLORREF clrSaveBk;
    UINT uETOFlags = 0;
    RECT rc;
    TCHAR ach[MAX_PATH + CCHELLIPSES];

    // REVIEW: Performance idea:
    // We could cache the currently selected text color
    // so we don't have to set and restore it each time
    // when the color is the same.
    //
    if (!pszText)
        return;

    rc = *prc;

    // If needed, add in a little extra margin...
    //
    if (IsFlagSet(flags, MDT_EXTRAMARGIN))
        {
        rc.left  += g_cxLabelMargin * 3;
        rc.right -= g_cxLabelMargin * 3;
        }
    else
        {
        rc.left  += g_cxLabelMargin;
        rc.right -= g_cxLabelMargin;
        }

    if (IsFlagSet(flags, MDT_ELLIPSES) &&
        NeedsEllipses(hdc, pszText, &rc, &cchText, cxEllipses))
        {
        hmemcpy(ach, pszText, cchText * sizeof(TCHAR));
        lstrcpy(ach + cchText, c_szEllipses);

        pszText = ach;

        // Left-justify, in case there's no room for all of ellipses
        //
        ClearFlag(flags, (MDT_RIGHT | MDT_CENTER));
        SetFlag(flags, MDT_LEFT);

        cchText += CCHELLIPSES;
        }
    else
        {
        cchText = lstrlen(pszText);
        }

    if (IsFlagSet(flags, MDT_TRANSPARENT))
        {
        clrSave = SetTextColor(hdc, 0x000000);
        }
    else
        {
        uETOFlags |= ETO_OPAQUE;

        if (IsFlagSet(flags, MDT_SELECTED))
            {
            clrSave = SetTextColor(hdc, g_clrHighlightText);
            clrSaveBk = SetBkColor(hdc, g_clrHighlight);

            if (IsFlagSet(flags, MDT_DRAWTEXT))
                {
                FillRect(hdc, prc, g_hbrHighlight);
                }
            }
        else
            {
            if (clrText == CLR_DEFAULT && clrTextBk == CLR_DEFAULT)
                {
                clrSave = SetTextColor(hdc, g_clrWindowText);
                clrSaveBk = SetBkColor(hdc, g_clrWindow);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                    {
                    FillRect(hdc, prc, g_hbrWindow);
                    }
                }
            else
                {
                HBRUSH hbr;

                if (clrText == CLR_DEFAULT)
                    clrText = g_clrWindowText;

                if (clrTextBk == CLR_DEFAULT)
                    clrTextBk = g_clrWindow;

                clrSave = SetTextColor(hdc, clrText);
                clrSaveBk = SetBkColor(hdc, clrTextBk);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                    {
                    hbr = CreateSolidBrush(GetNearestColor(hdc, clrTextBk));
                    if (hbr)
                        {
                        FillRect(hdc, prc, hbr);
                        DeleteObject(hbr);
                        }
                    else
                        FillRect(hdc, prc, GetStockObject(WHITE_BRUSH));
                    }
                }
            }
        }

    // If we want the item to display as if it was depressed, we will
    // offset the text rectangle down and to the left
    if (IsFlagSet(flags, MDT_DEPRESSED))
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    if (IsFlagSet(flags, MDT_DRAWTEXT))
        {
        UINT uDTFlags = DT_LVWRAP;

        if (IsFlagClear(flags, MDT_CLIPPED))
            uDTFlags |= DT_NOCLIP;

        DrawText(hdc, pszText, cchText, &rc, uDTFlags);
        }
    else
        {
        if (IsFlagClear(flags, MDT_LEFT))
            {
            SIZE siz;

            GetTextExtentPoint(hdc, pszText, cchText, &siz);

            if (IsFlagSet(flags, MDT_CENTER))
                rc.left = (rc.left + rc.right - siz.cx) / 2;
            else
                {
                ASSERT(IsFlagSet(flags, MDT_RIGHT));
                rc.left = rc.right - siz.cx;
                }
            }

        if (IsFlagSet(flags, MDT_VCENTER))
            {
            // Center vertically
            rc.top += (rc.bottom - rc.top - cyChar) / 2;
            }

        if (IsFlagSet(flags, MDT_CLIPPED))
            uETOFlags |= ETO_CLIPPED;

        ExtTextOut(hdc, rc.left, rc.top, uETOFlags, prc, pszText, cchText, NULL);
        }

    if (flags & (MDT_SELECTED | MDT_DESELECTED | MDT_TRANSPARENT))
        {
        SetTextColor(hdc, clrSave);
        if (IsFlagClear(flags, MDT_TRANSPARENT))
            SetBkColor(hdc, clrSaveBk);
        }
    }


/*----------------------------------------------------------
Purpose: Takes a DWORD value and converts it to a string, adding
         commas on the way.

         This was taken from the shell.

Returns: Pointer to buffer

Cond:    --
*/


LPTSTR PRIVATE BrfAddCommas(
    DWORD dw,
    LPTSTR pszBuffer,
    UINT cbBuffer)
    {
    TCHAR  szTemp[30];
    TCHAR  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, ARRAYSIZE(szSep));
    nfmt.Grouping = StrToInt(szSep);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, ARRAYSIZE(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    wsprintf(szTemp, TEXT("%lu"), dw);

    GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszBuffer, cbBuffer);
    return pszBuffer;
    }


const short s_rgidsOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB, IDS_ORDERGB, IDS_ORDERTB};


/*----------------------------------------------------------
Purpose: Converts a number into a short, string format.

         This code was taken from the shell.

            532     -> 523 bytes
            1340    -> 1.3KB
            23506   -> 23.5KB
                    -> 2.4MB
                    -> 5.2GB

Returns: pointer to buffer
Cond:    --
*/
LPTSTR PRIVATE ShortSizeFormat64(
    __int64 dw64,
    LPTSTR szBuf)
    {
    int i;
    UINT wInt, wLen, wDec;
    TCHAR szTemp[10], szOrder[20], szFormat[5];

    if (dw64 < 1000)
        {
        wsprintf(szTemp, TEXT("%d"), LODWORD(dw64));
        i = 0;
        goto AddOrder;
        }

    for (i = 1; i<ARRAYSIZE(s_rgidsOrders)-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = LODWORD(dw64 >> 10);
    BrfAddCommas(wInt, szTemp, ARRAYSIZE(szTemp));
    wLen = lstrlen(szTemp);
    if (wLen < 3)
        {
        wDec = LODWORD(dw64 - (__int64)wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        lstrcpy(szFormat, TEXT("%02d"));

        szFormat[2] = TEXT('0') + 3 - wLen;
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, ARRAYSIZE(szTemp)-wLen);
        wLen = lstrlen(szTemp);
        wLen += wsprintf(szTemp+wLen, szFormat, wDec);
        }

AddOrder:
    LoadString(g_hinst, s_rgidsOrders[i], szOrder, ARRAYSIZE(szOrder));
    wsprintf(szBuf, szOrder, (LPTSTR)szTemp);

    return szBuf;
    }



/*----------------------------------------------------------
Purpose: Converts a number into a short, string format.

         This code was taken from the shell.

            532     -> 523 bytes
            1340    -> 1.3KB
            23506   -> 23.5KB
                    -> 2.4MB
                    -> 5.2GB

Returns: pointer to buffer
Cond:    --
*/
LPTSTR PRIVATE ShortSizeFormat(DWORD dw, LPTSTR szBuf)
    {
    return(ShortSizeFormat64((__int64)dw, szBuf));
    }


#ifdef NOTUSED
/*----------------------------------------------------------
Purpose: Gets the index of the image of the file

Returns: index into the shell's cached imagelist
Cond:    --
*/
int PUBLIC GetImageIndex(
    LPCTSTR pszPath)
    {
    int iImage = 0;
    LPITEMIDLIST pidl;

    pidl = ILCreateFromPath(pszPath);
    if (pidl)
        {
        LPITEMIDLIST pidlParent = ILClone(pidl);
        if (pidlParent)
            {
            IShellFolder * psf;
            IShellFolder * psfDesktop;

            ILRemoveLastID(pidlParent);

            psfDesktop = GetDesktopShellFolder();
            if (SUCCEEDED(psfDesktop->lpVtbl->BindToObject(psfDesktop, pidlParent, NULL, &IID_IShellFolder, &psf)))
                {
                // Use the shell's cached system image list
                iImage = SHMapPIDLToSystemImageListIndex(psf, ILFindLastID(pidl), NULL);
                if (0 > iImage)
                    {
                    // Use the non-associated document image on error
                    iImage = 0;
                    }

                psf->lpVtbl->Release(psf);
                }
            ILFree(pidlParent);
            }
        ILFree(pidl);
        }

    return iImage;
    }
#endif


/*----------------------------------------------------------
Purpose: Gets the file info given a path.  If the path refers
         to a directory, then simply the path field is filled.

         If himl != NULL, then the function will add the file's
         image to the provided image list and set the image index
         field in the *ppfi.

Returns: standard hresult
Cond:    --
*/
HRESULT PUBLIC FICreate(
    LPCTSTR pszPath,
    FileInfo ** ppfi,
    UINT uFlags)
    {
    HRESULT hres = ResultFromScode(E_OUTOFMEMORY);
    int cchPath;
    SHFILEINFO sfi;
    UINT uInfoFlags = SHGFI_DISPLAYNAME | SHGFI_ATTRIBUTES;
    DWORD dwAttr;

    ASSERT(pszPath);
    ASSERT(ppfi);

    // Get shell file info
    if (IsFlagSet(uFlags, FIF_ICON))
        uInfoFlags |= SHGFI_ICON;
    if (IsFlagSet(uFlags, FIF_DONTTOUCH))
        {
        uInfoFlags |= SHGFI_USEFILEATTRIBUTES;

        // Today, FICreate is not called for folders, so this is ifdef'd out
#ifdef SUPPORT_FOLDERS
        dwAttr = IsFlagSet(uFlags, FIF_FOLDER) ? FILE_ATTRIBUTE_DIRECTORY : 0;
#else
        dwAttr = 0;
#endif
        }
    else
        dwAttr = 0;

    if (SHGetFileInfo(pszPath, dwAttr, &sfi, sizeof(sfi), uInfoFlags))
        {
        // Allocate enough for the structure, plus buffer for the fully qualified
        // path and buffer for the display name (and extra null terminator).
        cchPath = lstrlen(pszPath);

        *ppfi = GAlloc(sizeof(FileInfo) +
                      (cchPath+1) * sizeof(TCHAR) -
                      sizeof((*ppfi)->szPath) +
                      (lstrlen(sfi.szDisplayName)+1) * sizeof(TCHAR));
        if (*ppfi)
            {
            FileInfo * pfi = *ppfi;

            pfi->pszDisplayName = pfi->szPath+cchPath+1;
            lstrcpy(pfi->pszDisplayName, sfi.szDisplayName);

            if (IsFlagSet(uFlags, FIF_ICON))
                pfi->hicon = sfi.hIcon;

            pfi->dwAttributes = sfi.dwAttributes;

            // Does the path refer to a directory?
            if (FIIsFolder(pfi))
                {
                // Yes; just fill in the path field
                lstrcpy(pfi->szPath, pszPath);
                hres = NOERROR;
                }
            else
                {
                // No; assume the file exists?
                if (IsFlagClear(uFlags, FIF_DONTTOUCH))
                    {
                    // Yes; get the time, date and size of the file
                    HANDLE hfile = CreateFile(pszPath, GENERIC_READ, 
                                FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                NULL);

                    if (hfile == INVALID_HANDLE_VALUE)
                        {
                        GFree(*ppfi);
                        hres = ResultFromScode(E_HANDLE);
                        }
                    else
                        {
                        hres = NOERROR;

                        lstrcpy(pfi->szPath, pszPath);
                        pfi->dwSize = GetFileSize(hfile, NULL);
                        GetFileTime(hfile, NULL, NULL, &pfi->ftMod);
                        CloseHandle(hfile);
                        }
                    }
                else
                    {
                    // No; use what we have
                    hres = NOERROR;
                    lstrcpy(pfi->szPath, pszPath);
                    }
                }
            }
        }
    else if (!PathExists(pszPath))
        {
        // Differentiate between out of memory and file not found
        hres = E_FAIL;
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Get some file info of the given path.
         The returned string is of the format "# bytes <date>"

         If the path is a folder, the string is empty.

Returns: FALSE if path is not found
Cond:    --
*/
BOOL PUBLIC FIGetInfoString(
    FileInfo * pfi,
    LPTSTR pszBuf,
    int cchBuf)
    {
    BOOL bRet;

    ASSERT(pfi);
    ASSERT(pszBuf);

    *pszBuf = NULL_CHAR;

    if (pfi)
        {
        // Is this a file?
        if ( !FIIsFolder(pfi) )
            {
            // Yes
            TCHAR szSize[MAXMEDLEN];
            TCHAR szDate[MAXMEDLEN];
            TCHAR szTime[MAXMEDLEN];
            LPTSTR pszMsg;
            SYSTEMTIME st;
            FILETIME ftLocal;

            // Construct the string
            FileTimeToLocalFileTime(&pfi->ftMod, &ftLocal);
            FileTimeToSystemTime(&ftLocal, &st);
            GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE, &st, NULL, szDate, ARRAYSIZE(szDate));
            GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, szTime, ARRAYSIZE(szTime));

            if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(IDS_DATESIZELINE),
                ShortSizeFormat(FIGetSize(pfi), szSize), szDate, szTime))
                {
                lstrcpy(pszBuf, pszMsg);
                GFree(pszMsg);
                }
            else
                *pszBuf = 0;

            bRet = TRUE;
            }
        else
            bRet = FALSE;
        }
    else
        bRet = FALSE;

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Set the path entry.  This can move the pfi.

Returns: FALSE on out of memory
Cond:    --
*/
BOOL PUBLIC FISetPath(
    FileInfo ** ppfi,
    LPCTSTR pszPathNew,
    UINT uFlags)
    {
    ASSERT(ppfi);
    ASSERT(pszPathNew);

    FIFree(*ppfi);

    return SUCCEEDED(FICreate(pszPathNew, ppfi, uFlags));
    }


/*----------------------------------------------------------
Purpose: Free our file info struct
Returns: --
Cond:    --
*/
void PUBLIC FIFree(
    FileInfo * pfi)
    {
    if (pfi)
        {
        if (pfi->hicon)
            DestroyIcon(pfi->hicon);

        GFree(pfi);     // This macro already checks for NULL pfi condition
        }
    }


/*----------------------------------------------------------
Purpose: Convert FILETIME struct to a readable string

Returns: String
Cond:    --
*/
void PUBLIC FileTimeToDateTimeString(
    LPFILETIME pft,
    LPTSTR pszBuf,
    int cchBuf)
    {
    SYSTEMTIME st;
    FILETIME ftLocal;

    FileTimeToLocalFileTime(pft, &ftLocal);
    FileTimeToSystemTime(&ftLocal, &st);
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, pszBuf, cchBuf/2);
    pszBuf += lstrlen(pszBuf);
    *pszBuf++ = TEXT(' ');
    GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, pszBuf, cchBuf/2);
    }


/*----------------------------------------------------------
Purpose: Copies psz into *ppszBuf.  Will alloc or realloc *ppszBuf
         accordingly.

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC GSetString(
    LPTSTR * ppszBuf,
    LPCTSTR psz)
    {
    BOOL bRet = FALSE;
    DWORD cb;

    ASSERT(ppszBuf);
    ASSERT(psz);

    cb = CbFromCch(lstrlen(psz)+CCH_NUL);

    if (*ppszBuf)
        {
        // Need to reallocate?
        if (cb > GGetSize(*ppszBuf))
            {
            // Yes
            LPTSTR pszT = GReAlloc(*ppszBuf, cb);
            if (pszT)
                {
                *ppszBuf = pszT;
                bRet = TRUE;
                }
            }
        else
            {
            // No
            bRet = TRUE;
            }
        }
    else
        {
        *ppszBuf = (LPTSTR)GAlloc(cb);
        if (*ppszBuf)
            {
            bRet = TRUE;
            }
        }

    if (bRet)
        {
        ASSERT(*ppszBuf);
        lstrcpy(*ppszBuf, psz);
        }
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Concatenates psz onto *ppszBuf.  Will alloc or realloc *ppszBuf
         accordingly.

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC GCatString(
    LPTSTR * ppszBuf,
    LPCTSTR psz)
    {
    BOOL bRet = FALSE;
    DWORD cb;

    ASSERT(ppszBuf);
    ASSERT(psz);

    cb = CbFromCch(lstrlen(psz)+CCH_NUL);

    if (*ppszBuf)
        {
        // (Don't need to count nul because it is already counted in cb)
        DWORD cbExisting = CbFromCch(lstrlen(*ppszBuf));

        // Need to reallocate?
        if ((cb+cbExisting) > GGetSize(*ppszBuf))
            {
            // Yes; realloc at least MAXBUFLEN to cut down on the amount
            // of calls in the future
            LPTSTR pszT = GReAlloc(*ppszBuf, cbExisting+max(cb, MAXBUFLEN));
            if (pszT)
                {
                *ppszBuf = pszT;
                bRet = TRUE;
                }
            }
        else
            {
            // No
            bRet = TRUE;
            }
        }
    else
        {
        *ppszBuf = (LPTSTR)GAlloc(max(cb, MAXBUFLEN));
        if (*ppszBuf)
            {
            bRet = TRUE;
            }
        }

    if (bRet)
        {
        ASSERT(*ppszBuf);
        lstrcat(*ppszBuf, psz);
        }
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Waits for on object to signal.  This function "does
         the right thing" to prevent deadlocks which can occur
         because the calculation thread calls SendMessage.

Returns: value of MsgWaitForMultipleObjects
Cond:    --
*/
DWORD PUBLIC MsgWaitObjectsSendMessage(
    DWORD cObjects,
    LPHANDLE phObjects,
    DWORD dwTimeout)
    {
    DWORD dwRet;

    while (TRUE)
        {
        dwRet = MsgWaitForMultipleObjects(cObjects, phObjects, FALSE,
                                        dwTimeout, QS_SENDMESSAGE);

        // If it is not a message, return
        if ((WAIT_OBJECT_0 + cObjects) != dwRet)
            {
            return dwRet;
            }
        else
            {
            // Process all the sent messages
            MSG msg;
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Call this if PeekMessage is going to be called during
         an expensive operation and a new window has (or is)
         appeared.

         Details: simply calling SetCursor to change the cursor
         to an hourglass, then calling an expensive operation
         which will call PeekMessage, will result in the cursor
         changing back prematurely.  The reason is because SetCursorPos
         inserts a fake WM_MOUSEMOVE to set the cursor to the
         window class when a window appears for the first time.
         Since PeekMessage is processing this message, the cursor
         gets changed to the window class cursor.

         The trick is to remove the WM_MOUSEMOVE messages from
         the queue.

Returns: Previous cursor
Cond:    --
*/
HCURSOR PUBLIC SetCursorRemoveWigglies(
    HCURSOR hcur)
    {
    MSG msg;

    // Remove any mouse moves
    while (PeekMessage(&msg, NULL, WM_MOUSEMOVE, WM_MOUSEMOVE, PM_REMOVE))
        ;

    return SetCursor(hcur);
    }


/*----------------------------------------------------------
Purpose: Load the string (if necessary) and format the string
         properly.

Returns: A pointer to the allocated string containing the formatted
         message or
         NULL if out of memory

Cond:    --
*/
LPTSTR PUBLIC _ConstructMessageString(
    HINSTANCE hinst,
    LPCTSTR pszMsg,
    va_list *ArgList)
    {
    TCHAR szTemp[MAXBUFLEN];
    LPTSTR pszRet;
    LPTSTR pszRes;

    if (HIWORD(pszMsg))
        pszRes = (LPTSTR)pszMsg;
    else if (LOWORD(pszMsg) && LoadString(hinst, LOWORD(pszMsg), szTemp, ARRAYSIZE(szTemp)))
        pszRes = szTemp;
    else
        pszRes = NULL;

    if (pszRes)
        {
        if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                           pszRes, 0, 0, (LPTSTR)&pszRet, 0, ArgList))
            {
            pszRet = NULL;
            }
        }
    else
        {
        // Bad parameter
        pszRet = NULL;
        }

    return pszRet;      // free with LocalFree()
    }


/*----------------------------------------------------------
Purpose: Constructs a formatted string.  The returned string
         must be freed using GFree().

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC ConstructMessage(
    LPTSTR * ppsz,
    HINSTANCE hinst,
    LPCTSTR pszMsg, ...)
    {
    BOOL bRet;
    LPTSTR pszRet;
    va_list ArgList;

    va_start(ArgList, pszMsg);

    pszRet = _ConstructMessageString(hinst, pszMsg, &ArgList);

    va_end(ArgList);

    *ppsz = NULL;

    if (pszRet)
        {
        bRet = GSetString(ppsz, pszRet);
        LocalFree(pszRet);
        }
    else
        bRet = FALSE;

    return bRet;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\atoms.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: atoms.c
//
//  This files contains the atom list code.
//
// History:
//  01-31-94 ScottH     Moved from cache.c
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers

/////////////////////////////////////////////////////  TYPEDEFS

typedef struct tagA_ITEM
    {
    int atom;           // index into hdsa
    LPTSTR psz;          // allocated
    UINT ucRef;
    } A_ITEM;       // item for atom table

typedef struct tagATOMTABLE
    {
    CRITICAL_SECTION cs;
    HDSA hdsa;          // Actual list of A_ITEMs
    HDPA hdpa;          // List into hdsa (sorted).  Values are indexes, not pointers
    HDPA hdpaFree;      // Free list.  Values are indexes, not pointers.
    } ATOMTABLE;

#define Atom_EnterCS(this)    EnterCriticalSection(&(this)->cs)
#define Atom_LeaveCS(this)    LeaveCriticalSection(&(this)->cs)

#define ATOM_GROW   32


#define Cache_Bogus(this)  (!(this)->hdpa || !(this)->hdpaFree || !(this)->hdsa)

// Given an index into the DPA, get the pointer to the DSA
//  
#define MyGetPtr(this, idpa)     DSA_GetItemPtr((this)->hdsa, (int)DPA_FastGetPtr((this)->hdpa, idpa))

/////////////////////////////////////////////////////  MODULE DATA

static ATOMTABLE s_atomtable;

#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Validates the given atom is within the atomtable's range
Returns: --
Cond:    --
*/
void PUBLIC Atom_ValidateFn(
    int atom)
    {
    ATOMTABLE  * this = &s_atomtable;
    BOOL bError = FALSE;

    Atom_EnterCS(this);
        {
        if (atom >= DSA_GetItemCount(this->hdsa) || 
            atom < 0)
            {
            bError = TRUE;
            }
        }
    Atom_LeaveCS(this);

    if (bError)
        {
        // This is a problem!
        //
        DEBUG_MSG(TF_ERROR, TEXT("err BRIEFCASE: atom %d is out of range!"), atom);
        DEBUG_BREAK(BF_ONVALIDATE);
        }
    }


/*----------------------------------------------------------
Purpose: Dump the table contents
Returns: --
Cond:    For debugging purposes
*/
void PUBLIC Atom_DumpAll()
    {
    ATOMTABLE  * this = &s_atomtable;
    Atom_EnterCS(this);
        {
        if (IsFlagSet(g_uDumpFlags, DF_ATOMS))
            {
            A_ITEM  * pitem;
            int idpa;
            int cItem;

            ASSERT(this);
            ASSERT(this->hdsa != NULL);

            cItem = DPA_GetPtrCount(this->hdpa);
            for (idpa = 0; idpa < cItem; idpa++)
                {
                pitem = MyGetPtr(this, idpa);

                // The zero'th entry is reserved, so skip it
                if (pitem->atom == 0)
                    continue;

                TRACE_MSG(TF_ALWAYS, TEXT("ATOM:  Atom %d [%u]: %s"), 
                    pitem->atom, pitem->ucRef, pitem->psz);
                }
            }
        }
    Atom_LeaveCS(this);
    }
#endif


/*----------------------------------------------------------
Purpose: Compare A_ITEMs 
Returns: -1 if <, 0 if ==, 1 if >
Cond:    --
*/
int CALLBACK _export Atom_CompareIndexes(
    LPVOID lpv1,
    LPVOID lpv2,
    LPARAM lParam)
    {
    int i1 = (int)lpv1;
    int i2 = (int)lpv2;
    HDSA hdsa = (HDSA)lParam;
    A_ITEM  * pitem1 = DSA_GetItemPtr(hdsa, i1);
    A_ITEM  * pitem2 = DSA_GetItemPtr(hdsa, i2);

    ASSERT(pitem1);
    ASSERT(pitem2);

    return lstrcmpi(pitem1->psz, pitem2->psz);
    }


/*----------------------------------------------------------
Purpose: Compare A_ITEMs 
Returns: -1 if <, 0 if ==, 1 if >
Cond:    --
*/
int CALLBACK _export Atom_Compare(
    LPVOID lpv1,
    LPVOID lpv2,
    LPARAM lParam)
    {
    // HACK: we know the first param is the address to a struct
    //  that contains the search criteria.  The second is an index 
    //  into the DSA.
    //
    int i2 = (int)lpv2;
    HDSA hdsa = (HDSA)lParam;
    A_ITEM  * pitem1 = (A_ITEM  *)lpv1;
    A_ITEM  * pitem2 = DSA_GetItemPtr(hdsa, i2);

    ASSERT(pitem1);
    ASSERT(pitem2);

    return lstrcmpi(pitem1->psz, pitem2->psz);
    }


/*----------------------------------------------------------
Purpose: Initialize the atom table
Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC Atom_Init()
    {
    BOOL bRet;
    ATOMTABLE  * this = &s_atomtable;

    ASSERT(this);
    ZeroInit(this, ATOMTABLE);

    InitializeCriticalSection(&this->cs);

    Atom_EnterCS(this);
        {
        if ((this->hdsa = DSA_Create(sizeof(A_ITEM), ATOM_GROW)) != NULL)
            {
            if ((this->hdpa = DPA_Create(ATOM_GROW)) == NULL)
                {
                DSA_Destroy(this->hdsa);
                this->hdsa = NULL;
                }
            else
                {
                if ((this->hdpaFree = DPA_Create(ATOM_GROW)) == NULL)
                    {
                    DPA_Destroy(this->hdpa);
                    DSA_Destroy(this->hdsa);
                    this->hdpa = NULL;
                    this->hdsa = NULL;
                    }
                else
                    {
                    // We've successfully initialized.  Keep the zero'th
                    //  atom reserved.  This way null atoms will not accidentally
                    //  munge data.  
                    //                       
                    int atom = Atom_Add(TEXT("SHDD"));
                    ASSERT(atom == 0);
                    }
                }
            }
        bRet = this->hdsa != NULL;
        }
    Atom_LeaveCS(this);

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Destroy the atom table
Returns: --
Cond:    --
*/
void PUBLIC Atom_Term()
    {
    ATOMTABLE  * this = &s_atomtable;

    Atom_EnterCS(this);
        {
        if (this->hdpa != NULL)
            {
            A_ITEM  * pitem;
            int idpa;
            int cItem;
    
            ASSERT(this->hdsa != NULL);
    
            cItem = DPA_GetPtrCount(this->hdpa);
            for (idpa = 0; idpa < cItem; idpa++)
                {
                pitem = MyGetPtr(this, idpa);
    
                // The zero'th entry is reserved, so skip it
                if (pitem->atom == 0)
                    continue;
    
                SharedFree(&pitem->psz);
                }
            DPA_Destroy(this->hdpa);
            this->hdpa = NULL;
            }
    
        if (this->hdpaFree != NULL)
            {
            DPA_Destroy(this->hdpaFree);
            this->hdpaFree = NULL;
            }
    
        if (this->hdsa != NULL)
            {
            DSA_Destroy(this->hdsa);
            this->hdsa = NULL;
            }
        }
    Atom_LeaveCS(this);

    DeleteCriticalSection(&this->cs);
    }


/*----------------------------------------------------------
Purpose: Add a string to the atom table.  If the string already
          exists, return its atom.
Returns: Atom 
         ATOM_ERR on failure

Cond:    Reference count is incremented always
*/
int PUBLIC Atom_Add(
    LPCTSTR psz)
    {
    ATOMTABLE  * this = &s_atomtable;
    A_ITEM  * pitem = NULL;
    A_ITEM item;
    int atomRet = ATOM_ERR;
    int idpa;
    int cItem;
    int cFree;

    ASSERT(psz);

    Atom_EnterCS(this);
        {
        int iItem;

        DEBUG_CODE( iItem = -1; )

        // Search for the string in the atom table first.
        //  If we find it, return the atom.
        //
        item.psz = (LPTSTR)(LPVOID)psz;
        idpa = DPA_Search(this->hdpa, &item, 0, Atom_Compare, (LPARAM)this->hdsa, DPAS_SORTED);
        if (idpa != -1)
            {
            // String is already in table
            //
            pitem = MyGetPtr(this, idpa);
            pitem->ucRef++;
            atomRet = pitem->atom;

            ASSERT(IsSzEqual(psz, pitem->psz));

            VALIDATE_ATOM(pitem->atom);
            }
        else
            {
            // Add the string to the table.  Take any available entry
            //  from the free list first.  Otherwise allocate more space
            //  in the table.  Then add a ptr to the sorted ptr list.
            //
            cFree = DPA_GetPtrCount(this->hdpaFree);
            if (cFree > 0)
                {
                // Use a free entry 
                //
                cFree--;
                iItem = (int)DPA_DeletePtr(this->hdpaFree, cFree);
                pitem = DSA_GetItemPtr(this->hdsa, iItem);
        
                // atom field for pitem should already be set

                VALIDATE_ATOM(pitem->atom);
                }
            else
                {
                // Allocate a new entry.  item has bogus data in it.
                //  That's okay, we fill in good stuff below.
                //
                cItem = DSA_GetItemCount(this->hdsa);
                if ((iItem = DSA_InsertItem(this->hdsa, cItem+1, &item)) != -1)
                    {
                    pitem = DSA_GetItemPtr(this->hdsa, iItem);
                    pitem->atom = iItem;

                    VALIDATE_ATOM(pitem->atom);
                    }
                }
        
            // Fill in the info
            //
            if (pitem)
                {
                pitem->ucRef = 1;
                pitem->psz = 0;
                if (!Str_SetPtr(&pitem->psz, psz))
                    goto Add_Fail;
            
                // Add the new entry to the ptr list and sort
                //
                cItem = DPA_GetPtrCount(this->hdpa);
                if (DPA_InsertPtr(this->hdpa, cItem+1, (LPVOID)iItem) == -1)
                    goto Add_Fail;
                DPA_Sort(this->hdpa, Atom_CompareIndexes, (LPARAM)this->hdsa);
                atomRet = pitem->atom;

                TRACE_MSG(TF_ATOM, TEXT("ATOM  Adding %d [%u]: %s"), atomRet, pitem->ucRef, pitem->psz);
                }
            }
    
Add_Fail:
        // Add the entry to the free list and fail.  If even this fails, 
        //  then we simply lose some slight efficiency, but this is not 
        //  a memory leak.
        //
#ifdef DEBUG
        if (atomRet == ATOM_ERR)
            TRACE_MSG(TF_ATOM, TEXT("ATOM  **Failed adding %s"), psz);
#endif
        if (atomRet == ATOM_ERR && pitem)
            {
            ASSERT(iItem != -1);

            DPA_InsertPtr(this->hdpaFree, cFree+1, (LPVOID)iItem);
            }
        }
    Atom_LeaveCS(this);

    return atomRet;
    }


/*----------------------------------------------------------
Purpose: Increment the reference count of this atom.

Returns: Last count
         0 if the atom doesn't exist
Cond:    --
*/
UINT PUBLIC Atom_AddRef(
    int atom)
    {
    ATOMTABLE  * this = &s_atomtable;
    UINT cRef;

    if (!Atom_IsValid(atom))
        {
        ASSERT(0);
        return 0;
        }

    VALIDATE_ATOM(atom);

    Atom_EnterCS(this);
        {
        A_ITEM * pitem = DSA_GetItemPtr(this->hdsa, atom);
        if (pitem)
            {
            cRef = pitem->ucRef++;
            }
        else
            {
            cRef = 0;
            }
        }
    Atom_LeaveCS(this);

    return cRef;
    }


/*----------------------------------------------------------
Purpose: Delete a string from the atom table.

         If the reference count is not zero, we do nothing.
Returns: --

Cond:    N.b.  Decrements the reference count.
*/
void PUBLIC Atom_Delete(
    int atom)
    {
    ATOMTABLE  * this = &s_atomtable;
    A_ITEM  * pitem;

    if (!Atom_IsValid(atom))
        {
        ASSERT(0);
        return;         
        }

    VALIDATE_ATOM(atom);

    Atom_EnterCS(this);
        {
        pitem = DSA_GetItemPtr(this->hdsa, atom);
        if (pitem)
            {
            int idpa;
            int cFree;
    
            ASSERT(pitem->atom == atom);

            // Is the reference count already at zero?
            if (0 == pitem->ucRef)
                {
                // Yes; somebody is calling Atom_Delete one-too-many times!
                DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Deleting %d once-too-many!!"), 
                    pitem->atom); )
                ASSERT(0);
                }
            else if (0 == --pitem->ucRef)
                {
                // Yes
                idpa = DPA_GetPtrIndex(this->hdpa, (LPVOID)atom);     // linear search

                DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Deleting %d: %s"), 
                    pitem->atom, pitem->psz ? pitem->psz : (LPCTSTR)TEXT("NULL")); )
        
                ASSERT(atom == (int)DPA_GetPtr(this->hdpa, idpa));
                if (DPA_ERR != idpa)
                    {
                    DPA_DeletePtr(this->hdpa, idpa);

                    ASSERT(pitem->psz);
                    SharedFree(&pitem->psz);
                    
                    DEBUG_CODE( pitem->psz = NULL; )
                    }
                else
                    {
                    ASSERT(0);      // Should never get here
                    }

                // Add ptr to the free list.  If this fails, we simply 
                //  lose some efficiency in reusing this portion of the cache.  
                //  This is not a memory leak.
                //
                cFree = DPA_GetPtrCount(this->hdpaFree);
                DPA_InsertPtr(this->hdpaFree, cFree+1, (LPVOID)atom);
                }
            }
        }
    Atom_LeaveCS(this);
    }


/*----------------------------------------------------------
Purpose: Replace the string corresponding with the atom with
         another string.  The atom will not change.
Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC Atom_Replace(
    int atom,
    LPCTSTR pszNew)
    {
    ATOMTABLE  * this = &s_atomtable;
    BOOL bRet = FALSE;
    A_ITEM  * pitem;

    ASSERT(pszNew);

    if (!Atom_IsValid(atom))
        {
        return FALSE;         
        }

    VALIDATE_ATOM(atom);

    Atom_EnterCS(this);
        {
        pitem = DSA_GetItemPtr(this->hdsa, atom);
        if (pitem)
            {
            ASSERT(atom == pitem->atom);
            ASSERT(pitem->psz);
            DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Change %d [%u]: %s -> %s"), 
                atom, pitem->ucRef, pitem->psz, pszNew); )

            if (Str_SetPtr(&pitem->psz, pszNew))
                {
                DPA_Sort(this->hdpa, Atom_CompareIndexes, (LPARAM)this->hdsa);
                bRet = TRUE;
                }
#ifdef DEBUG
            else
                TRACE_MSG(TF_ATOM, TEXT("ATOM  **Change failed"));
#endif
            }
        }
    Atom_LeaveCS(this);
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Translate all atoms with that contain the partial
          string atomOld with the partial string atomNew.
Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC Atom_Translate(
    int atomOld,
    int atomNew)
    {
    BOOL bRet = FALSE;
    ATOMTABLE  * this = &s_atomtable;
    A_ITEM  * pitem;
    int idpa;
    int cItem;
    int atomSave = 0;
    int cchOld;
    LPCTSTR psz;
    LPCTSTR pszOld;
    LPCTSTR pszNew;
    LPCTSTR pszRest;
    TCHAR sz[MAXPATHLEN];

    if ( !(Atom_IsValid(atomOld) && Atom_IsValid(atomNew)) )
        {
        return FALSE;
        }

    Atom_EnterCS(this);
        {
        pszOld = Atom_GetName(atomOld);
        cchOld = lstrlen(pszOld);
        pszNew = Atom_GetName(atomNew);
    
        cItem = DPA_GetPtrCount(this->hdpa);
        for (idpa = 0; idpa < cItem; idpa++)
            {
            pitem = MyGetPtr(this, idpa);
            ASSERT(pitem);
    
            if (pitem->atom == 0)
                continue;                   // skip reserved atom
    
            if (atomOld == pitem->atom)
                {
                atomSave = pitem->atom;     // Save this one for last
                continue;
                }
    
            psz = Atom_GetName(pitem->atom);
            ASSERT(psz);

            if (PathIsPrefix(pszOld, psz) && lstrlen(psz) >= cchOld)
                {
                // Translate this atom
                //
                pszRest = psz + cchOld;     // whack up the path
    
                PathCombine(sz, pszNew, pszRest);
    
                DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Translate %d [%u]: %s -> %s"), 
                    pitem->atom, pitem->ucRef, pitem->psz, (LPCTSTR)sz); )
    
                if (!Str_SetPtr(&pitem->psz, sz))
                    goto Translate_Fail;
                }
            }
    
        ASSERT(Atom_IsValid(atomSave));      // this means trouble

        VALIDATE_ATOM(atomSave);
    
        pitem = DSA_GetItemPtr(this->hdsa, atomSave);
        if (pitem)
            {
            ASSERT(atomSave == pitem->atom);
            ASSERT(pitem->psz);

            DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Translate %d [%u]: %s -> %s"), 
                pitem->atom, pitem->ucRef, pitem->psz, pszNew); )

            if (!Str_SetPtr(&pitem->psz, pszNew))
                goto Translate_Fail;
            }
        bRet = TRUE;

Translate_Fail:
        ASSERT(bRet);

        // Sort here, even on a fail, so we correctly sort whatever
        //  got translated before the failure.
        //
        DPA_Sort(this->hdpa, Atom_CompareIndexes, (LPARAM)this->hdsa);
        }
    Atom_LeaveCS(this);

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Search for a string in the atom table and return the atom
Returns: Atom
         ATOM_ERR if the string is not in the table

Cond:    Reference count is NOT incremented
*/
int PUBLIC Atom_Find(
    LPCTSTR psz)
    {
    ATOMTABLE  * this = &s_atomtable;
    A_ITEM item;
    A_ITEM  * pitem;
    int atomRet = ATOM_ERR;
    int idpa;

    ASSERT(psz);

    Atom_EnterCS(this);
        {
        item.psz = (LPTSTR)(LPVOID)psz;
        idpa = DPA_Search(this->hdpa, &item, 0, Atom_Compare, (LPARAM)this->hdsa, 
                          DPAS_SORTED);
        if (idpa != -1)
            {
            pitem = MyGetPtr(this, idpa);
            atomRet = pitem->atom;

            DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Find %s.  Found %d [%u]: %s"), 
                psz, pitem->atom, pitem->ucRef, pitem->psz); )
            ASSERT(IsSzEqual(psz, pitem->psz));
            }
#ifdef DEBUG
        else
            TRACE_MSG(TF_ATOM, TEXT("ATOM  **Not found %s"), psz);
#endif
        }
    Atom_LeaveCS(this);

    return atomRet;
    }


/*----------------------------------------------------------
Purpose: Get the string for this atom
Returns: Ptr to the string
         NULL if the atom is bogus

Cond:    The caller must serialize this.
*/
LPCTSTR PUBLIC Atom_GetName(
    int atom)
    {
    ATOMTABLE  * this = &s_atomtable;
    LPCTSTR pszRet = NULL;
    A_ITEM  * pitem;

    VALIDATE_ATOM(atom);

    Atom_EnterCS(this);
        {
        pitem = DSA_GetItemPtr(this->hdsa, atom);
        if (pitem)
            {
            pszRet = pitem->psz;

            DEBUG_CODE( TRACE_MSG(TF_ATOM, TEXT("ATOM  Getting name %d [%u]: %s"), 
                atom, pitem->ucRef, pszRet); )
            ASSERT(atom == pitem->atom);
            }
#ifdef DEBUG
        else
            TRACE_MSG(TF_ATOM, TEXT("ATOM  **Cannot get %d"), atom);
#endif
        }
    Atom_LeaveCS(this);

    return pszRet;
    }


/*----------------------------------------------------------
Purpose: Return TRUE if atom2 is a partial path match of atom1.

Returns: boolean

Cond:    Requires atom1 and atom2 to be valid.
*/
BOOL PUBLIC Atom_IsPartialMatch(
    int atom1,
    int atom2)
    {
    LPCTSTR psz1 = Atom_GetName(atom1);
    LPCTSTR psz2 = Atom_GetName(atom2);

    ASSERT(psz1);
    ASSERT(psz2);
        
    return PathIsPrefix(psz1, psz2);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\brfprv.h ===
//
// brfprv.h:  Includes all files that are to be part of the precompiled
//             header.
//

#ifndef __BRFPRV_H__
#define __BRFPRV_H__

/////////////////////////////////////////////////////  INCLUDES

#define NEW_REC

#define STRICT
#define NOWINDOWSX
#define NOSHELLDEBUG
#define NO_COMMCTRL_DA
#define NO_COMMCTRL_ALLOCFCNS
#define USE_MONIKER

#define _INC_OLE            // WIN32

#include <windows.h>
#include <windowsx.h>

#include <shellapi.h>       // for registration functions
#include "port32.h"

#include <shlobj.h>         // WIN32
#include "shlapip.h"       
#include "shsemip.h"
#include "winuserp.h"
#include "shlwapi.h"
#include "commctrl.h"      
#include "comctrlp.h"
#include <ole2.h>           // object binding
#include "syncmgr.h"

// Internal Shell headers
#include "shellp.h"
#include "brfcasep.h"

#include <prsht.h>          // Property sheet stuff

#include "synceng.h"        // Twin Engine include file
#include "indirect.h"    // For type-safe indirect calling

#include <shlguidp.h>

//----------------------------------------------------------------------------        /* ;Internal */
// Internal helper macro                                              	              /* ;Internal */
//---------------------------------------------------------------------------- 	      /* ;Internal */
										      /* ;Internal */
#define _IOffset(class, itf)         ((UINT)&(((class *)0)->itf))                     /* ;Internal */
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_IOffset(class, itf))) /* ;Internal */
#define IToClassN(class, itf, pitf)  IToClass(class, itf, pitf)                       /* ;Internal */
                                                                                      /* ;Internal */
// end of rogerg add

#define PUBLIC           
#define CPUBLIC          _cdecl
#define PRIVATE          

#define MAXBUFLEN       260
#define MAXMSGLEN       520
#define MAXMEDLEN       64
#define MAXSHORTLEN     32

#define NULL_CHAR       TEXT('\0')

#define HIDWORD(_qw)    (DWORD)((_qw)>>32)
#define LODWORD(_qw)    (DWORD)(_qw)

#define DPA_ERR         (-1)
#define DPA_APPEND      0x7fff

#define CRL_FLAGS       CRL_FL_DELETE_DELETED_TWINS

//---------------------------------------------------------------------------
// misc.c
//---------------------------------------------------------------------------

// Structure for handling abort events
typedef struct 
    {
    UINT    uFlags;
    } ABORTEVT, * PABORTEVT;

// Flags for ABORTEVT struct
#define AEF_DEFAULT     0x0000
#define AEF_SHARED      0x0001
#define AEF_ABORT       0x0002

BOOL PUBLIC AbortEvt_Create(PABORTEVT * ppabortevt, UINT uFlags);
void PUBLIC AbortEvt_Free(PABORTEVT this);
BOOL PUBLIC AbortEvt_Set(PABORTEVT this, BOOL bAbort);
BOOL PUBLIC AbortEvt_Query(PABORTEVT this);


// Structure for the update progress bar
typedef struct
{
UINT uFlags;
PABORTEVT pabortevt;
HWND hwndParent;
DWORD dwTickShow;   // Tick count at which to display dialog
HCURSOR hcurSav;

LPSYNCMGRSYNCHRONIZECALLBACK pCallback;
SYNCMGRITEMID ItemID;

} UPDBAR, * PUPDBAR;      // Update progress bar struct

HWND PUBLIC UpdBar_Show (HWND hwndParent, UINT uFlags, UINT nSecs,
			LPSYNCMGRSYNCHRONIZECALLBACK pCallback,SYNCMGRITEMID ItemID);
void PUBLIC UpdBar_Kill (HWND hdlg);
void PUBLIC UpdBar_SetCount (HWND hdlg, ULONG ulcFiles);
void PUBLIC UpdBar_SetRange (HWND hdlg, WORD wRangeMax);
void PUBLIC UpdBar_DeltaPos (HWND hdlg, WORD wdelta);
void PUBLIC UpdBar_SetPos(HWND hdlg, WORD wPos);
void PUBLIC UpdBar_SetName (HWND hdlg, LPCTSTR lpcszName);
void PUBLIC UpdBar_SetDescription(HWND hdlg, LPCTSTR psz);
void PUBLIC UpdBar_SetAvi(HWND hdlg, UINT uFlags);
HWND PUBLIC UpdBar_GetStatusWindow(HWND hdlg);
PABORTEVT PUBLIC UpdBar_GetAbortEvt(HWND hdlg);
BOOL PUBLIC UpdBar_QueryAbort (HWND hdlg);

#define DELAY_UPDBAR    3       // 3 seconds

// Flags for UpdBar_Show
#define UB_UPDATEAVI    0x0001
#define UB_CHECKAVI     0x0002
#define UB_NOSHOW       0x0004
#define UB_NOCANCEL     0x0008
#define UB_TIMER        0x0010
#define UB_NOPROGRESS   0x0020

#define UB_CHECKING     (UB_CHECKAVI | UB_NOPROGRESS | UB_TIMER)
#define UB_UPDATING     UB_UPDATEAVI


// Additional MB_ flags
#define MB_WARNING  (MB_OK | MB_ICONWARNING)
#define MB_INFO     (MB_OK | MB_ICONINFORMATION)
#define MB_ERROR    (MB_OK | MB_ICONERROR)
#define MB_QUESTION (MB_YESNO | MB_ICONQUESTION)

int PUBLIC MsgBox(HWND hwndParent, LPCTSTR pszText, LPCTSTR pszCaption,
		   LPSYNCMGRSYNCHRONIZECALLBACK pCallBack,SYNCMGRITEMID ItemID,
		   HICON hicon, UINT uStyle, ...);

int PUBLIC ConfirmReplace_DoModal(HWND hwndOwner, LPCTSTR pszPathExisting, LPCTSTR pszPathOther, UINT uFlags);

// Flags for ConfirmReplace_DoModal
#define CRF_DEFAULT     0x0000
#define CRF_MULTI       0x0001
#define CRF_FOLDER      0x0002      // Internal

int PUBLIC Intro_DoModal(HWND hwndParent);


//---------------------------------------------------------------------------
// Local includes
//---------------------------------------------------------------------------

#include "mem.h"            // Shared heap functions
#include "da.h"             // Dynamic array functions
#include "cstrings.h"       // Read-only string constants
#include "init.h"           // Global DLL and initialization
#include "strings.h"        // Private string include
#include "comm.h"           // Common functions
#include "err.h"            // Error/debug code
#include "twin.h"           // Engine specific macros
#include "cache.h"          // Cache functions
#include "atoms.h"          // Atom functions

//---------------------------------------------------------------------------
// Critical section stuff
//---------------------------------------------------------------------------

// Notes:
//  1. Never "return" from the critical section.
//  2. Never "SendMessage" or "Yield" from the critical section.
//  3. Never call USER API which may yield.
//  4. Always make the critical section as small as possible.
//

void PUBLIC Brief_EnterExclusive(void);
void PUBLIC Brief_LeaveExclusive(void);
extern UINT g_cRefSyncUI;

#define ENTEREXCLUSIVE()    Brief_EnterExclusive();
#define LEAVEEXCLUSIVE()    Brief_LeaveExclusive();
#define ASSERTEXCLUSIVE()       ASSERT(0 < g_cRefSyncUI)
#define ASSERT_NOT_EXCLUSIVE()  ASSERT(0 == g_cRefSyncUI)

UINT PUBLIC Delay_Own(void);
UINT PUBLIC Delay_Release(void);


//---------------------------------------------------------------------------
// IDataObject prototypes
//---------------------------------------------------------------------------

BOOL    PUBLIC DataObj_KnowsBriefObj(LPDATAOBJECT pdtobj);
HRESULT PUBLIC DataObj_QueryBriefPath(LPDATAOBJECT pdtobj, LPTSTR pszBriefPath);
HRESULT PUBLIC DataObj_QueryPath(LPDATAOBJECT pdtobj, LPTSTR pszPath);
HRESULT PUBLIC DataObj_QueryFileList(LPDATAOBJECT pdtobj, LPTSTR * ppszList, LPUINT puCount);
void    PUBLIC DataObj_FreeList(LPTSTR pszList);

// Helper macros
#define NextString(psz)             while (*(psz)++)
#define DataObj_NextFile(psz)       NextString(psz)

//---------------------------------------------------------------------------
// path.c
//---------------------------------------------------------------------------

// Events for PathNotifyShell
typedef enum _notifyshellevent
    {
    NSE_CREATE       = 0,
    NSE_MKDIR,
    NSE_UPDATEITEM,
    NSE_UPDATEDIR
    } NOTIFYSHELLEVENT;

LPTSTR   PUBLIC MyPathRemoveBackslash(LPTSTR lpszPath);
LPTSTR   PUBLIC PathRemoveExt(LPCTSTR pszPath, LPTSTR pszBuf);
BOOL    PUBLIC PathIsPrefix(LPCTSTR lpcszPath1, LPCTSTR lpcszPath2);
void    PUBLIC PathMakePresentable(LPTSTR pszPath);
LPTSTR   PUBLIC PathGetDisplayName(LPCTSTR pszPath, LPTSTR pszBuf);
void    PUBLIC BrfPathCanonicalize(LPCTSTR pszPath, LPTSTR pszBuf);
BOOL    PUBLIC PathCheckForBriefcase(LPCTSTR pszPath, DWORD dwAttrib);
BOOL    PUBLIC PathIsBriefcase(LPCTSTR pszPath);
BOOL    PUBLIC PathExists(LPCTSTR pszPath);
UINT    PUBLIC PathGetLocality(LPCTSTR pszPath, LPTSTR pszBuf);
void    PUBLIC PathNotifyShell(LPCTSTR pszPath, NOTIFYSHELLEVENT nse, BOOL bDoNow);
LPCTSTR  PUBLIC PathFindEndOfRoot(LPCTSTR pszPath);
LPTSTR   PUBLIC PathFindNextComponentI(LPCTSTR lpszPath);
BOOL    PUBLIC PathsTooLong(LPCTSTR pszFolder, LPCTSTR pszName);

// Path locality values, relative to a briefcase
//
#define PL_FALSE   0       // path is not related at all to a briefcase
#define PL_ROOT    1       // path directly references the root of a briefcase
#define PL_INSIDE  2       // path is somewhere inside a briefcase

//---------------------------------------------------------------------------
// state.c
//---------------------------------------------------------------------------

#ifdef DEBUG

BOOL PUBLIC ProcessIniFile(void);
BOOL PUBLIC CommitIniFile(void);

#else

#define ProcessIniFile()
#define CommitIniFile()

#endif

//---------------------------------------------------------------------------
// oledup.c
//---------------------------------------------------------------------------

HRESULT MyReleaseStgMedium(LPSTGMEDIUM pmedium);

//---------------------------------------------------------------------------
// thread.c
//---------------------------------------------------------------------------

BOOL PUBLIC RunDLLThread(HWND hwnd, LPCTSTR pszCmdLine, int nCmdShow);


//---------------------------------------------------------------------------
// ibrfext.c
//---------------------------------------------------------------------------

// This structure shares common data between all briefcase 
// property pages
typedef struct tagPAGEDATA
    {
    LPBRIEFCASESTG  pbrfstg;        // IBriefcaseStg instance
    int             atomPath;
    PCBS            pcbs;
    UINT            cRef;

    PRECLIST        prl;
    PFOLDERTWINLIST pftl;
    BOOL            bOrphan:1;      // TRUE: This is an orphan
    BOOL            bFolder:1;      // TRUE: This is a folder
    BOOL            bRecalc:1;      // TRUE: Need to recalc

    LPARAM          lParam;         // Page-specific data
    } PAGEDATA, * PPAGEDATA;

HRESULT PUBLIC PageData_Init(PPAGEDATA this, HWND hwndOwner);
HRESULT PUBLIC PageData_Query(PPAGEDATA this, HWND hwndOwner, PRECLIST * pprl, PFOLDERTWINLIST * ppftl);
void    PUBLIC PageData_Orphanize(PPAGEDATA this);

#define PageData_GetHbrf(this)      ((this)->pcbs->hbrf)

HRESULT CALLBACK BriefExt_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID * ppvOut);


//---------------------------------------------------------------------------
// status.c
//---------------------------------------------------------------------------

BOOL _export CALLBACK Stat_WrapperProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void PUBLIC SelectItemInCabinet(HWND hwndCabinet, LPCITEMIDLIST pidl, BOOL bEdit);
void PUBLIC OpenCabinet(HWND hwnd, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl, BOOL bEdit);


//---------------------------------------------------------------------------
// info.c
//---------------------------------------------------------------------------

typedef struct
    {
    int     atomTo;
    HDPA    hdpaTwins;    // handle to array of twin handles which will
                          //  be filled by dialog.
                          //  N.b.  Caller must release these twins!
    BOOL    bStandAlone;  // private: should only be set by Info_DoModal
    } INFODATA, * PINFODATA;

BOOL _export CALLBACK Info_WrapperProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

HRESULT PUBLIC Info_DoModal(HWND hwndParent, LPCTSTR pszPath1, LPCTSTR pszPath2, HDPA hdpaTwin, PCBS pcbs);


//---------------------------------------------------------------------------
// ibrfstg.c
//---------------------------------------------------------------------------

void    PUBLIC TermCacheTables(void);
HRESULT CALLBACK BriefStg_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID * ppvOut);

//---------------------------------------------------------------------------
// update.c
//---------------------------------------------------------------------------

// Flags for Upd_DoModal
#define UF_SELECTION    0x0001
#define UF_ALL          0x0002

HRESULT PUBLIC Upd_DoModal(HWND hwndOwner, CBS * pcbs, LPCTSTR pszList, UINT cFiles, UINT uFlags);

//---------------------------------------------------------------------------
// init.c
//---------------------------------------------------------------------------

LPSHELLFOLDER PUBLIC GetDesktopShellFolder(void);


//---------------------------------------------------------------------------
// Semaphores
//---------------------------------------------------------------------------

// The BusySemaphore is used only for areas of code that do not
// rely on the sync engine v-table.  One example is the IContextMenu
// code.
//
// The BriefSemaphore is used for any code that opens/closes a
// Briefcase storage interface.
//
// These must be serialized.

extern UINT g_cBusyRef;            // Semaphore
extern UINT g_cBriefRef;           // Semaphore

#define IsBusySemaphore()       (g_cBusyRef > 0)
#define IncBusySemaphore()      (g_cBusyRef++)
#define DecBusySemaphore()      (g_cBusyRef--)

#define IncBriefSemaphore()     (g_cBriefRef++)
#define DecBriefSemaphore()     (g_cBriefRef--)
#define IsOpenBriefSemaphore()  (g_cBriefRef > 0)
#define IsFirstBriefSemaphore() (g_cBriefRef == 1)
#define IsLastBriefSemaphore()  (g_cBriefRef == 0)

#endif  //!__BRFPRV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\cache.h ===
//
// cache.h: Declares data, defines and struct types for the
//          cache list module.
//
//

#ifndef __CACHE_H__
#define __CACHE_H__


/////////////////////////////////////////////////////////////
//  
//  Generic cache structures
//
/////////////////////////////////////////////////////////////


typedef void (CALLBACK *PFNFREEVALUE)(void * pv, HWND hwndOwner);

typedef struct tagCACHE
    {
    CRITICAL_SECTION cs;
    HDSA hdsa;          // Actual list of CITEMs
    HDPA hdpa;          // Sorted ptr list
    HDPA hdpaFree;      // Free list
    int iPrev;          // Index into hdpa.  Used by FindFirst/FindNext
    int atomPrev;
    } CACHE;

// Generic cache APIs
//
BOOL    PUBLIC Cache_Init (CACHE  * pcache);
void    PUBLIC Cache_InitCS(CACHE  * pcache);
void    PUBLIC Cache_Term (CACHE  * pcache, HWND hwndOwner, PFNFREEVALUE pfnFree);
void    PUBLIC Cache_DeleteCS(CACHE  * pcache);
BOOL    PUBLIC Cache_AddItem (CACHE  * pcache, int atomKey, LPVOID pvValue);
int     PUBLIC Cache_DeleteItem (CACHE  * pcache, int atomKey, BOOL bNuke, HWND hwndOwner, PFNFREEVALUE pfnFree);
BOOL    PUBLIC Cache_ReplaceItem (CACHE  * pcache, int atomKey, LPVOID pvBuf, int cbBuf);
LPVOID  PUBLIC Cache_GetPtr (CACHE  * pcache, int atomKey);
BOOL    PUBLIC Cache_GetItem(CACHE  * pcache, int atomKey, LPVOID pvBuf, int cbBuf);
int     PUBLIC Cache_FindFirstKey(CACHE  * pcache);
int     PUBLIC Cache_FindNextKey(CACHE  * pcache, int atomPrev);
UINT    PUBLIC Cache_GetRefCount(CACHE  * pcache, int atomKey);


/////////////////////////////////////////////////////////////
//  
//  Cached briefcase handle list
//
/////////////////////////////////////////////////////////////

// Cache briefcase structure 
//
typedef struct tagCBS
    {
    int      atomBrf;           // Useful for reference
    HBRFCASE hbrf;              // Opened on add, closed on delete
    HWND     hwndParent;        // Volatile
    PABORTEVT pabortevt;        // Abort event object
    UINT     uFlags;            // One of CBSF_ flags

    } CBS, * PCBS;

#define CBSF_RUNWIZARD      0x0001
#define CBSF_LFNDRIVE       0x0002

extern CACHE g_cacheCBS;        // Briefcase structure cache


void CALLBACK CBS_Free(LPVOID lpv, HWND hwnd);

DEBUG_CODE( void PUBLIC CBS_DumpAll(); )

//      BOOL CBS_Init(void);
//
#define CBS_Init()                      Cache_Init(&g_cacheCBS)

//      void CBS_InitCS(void);
//
#define CBS_InitCS()                    Cache_InitCS(&g_cacheCBS)

//      void CBS_Term(HWND hwndOwner);
//
#define CBS_Term(hwndOwner)             Cache_Term(&g_cacheCBS, hwndOwner, CBS_Free)

//      void CBS_DeleteCS(void);
//
#define CBS_DeleteCS()                  Cache_DeleteCS(&g_cacheCBS)

//      HRESULT CBS_Add(PCBS * ppcbs, int atomPath, HWND hwndOwner);
//          Must call CBS_Delete for each call to this guy.
//
HRESULT PUBLIC CBS_Add(PCBS * ppcbs, int atomPath, HWND hwndOwner);

//      CBS FAR * CBS_Get(int atomPath);
//          Must call CBS_Delete for each call to this guy.
//
#define CBS_Get(atomPath)               Cache_GetPtr(&g_cacheCBS, atomPath)

//      int CBS_Delete(int atomPath, HWND hwndOwner);
//          Returns reference count (0 if deleted)
//
#define CBS_Delete(atomPath, hwndOwner) Cache_DeleteItem(&g_cacheCBS, atomPath, FALSE, hwndOwner, CBS_Free)

//      int CBS_Nuke(int atomPath, HWND hwndOwner);
//          Returns 0
//
#define CBS_Nuke(atomPath, hwndOwner)   Cache_DeleteItem(&g_cacheCBS, atomPath, TRUE, hwndOwner, CBS_Free)


/////////////////////////////////////////////////////////////
//  
//  Cached reclist 
//
/////////////////////////////////////////////////////////////

// Cache reclist structure
//
typedef struct tagCRL
    {
    int atomPath;           // Inside path for this CRL
    int atomOutside;        // Outside path of the sync copy pair
    UINT idsStatus;         // resource ID for status string

    PABORTEVT pabortevt;    // Abort event object, owned by CBS
    HBRFCASE hbrf;          // Briefcase this reclist belongs to
    int atomBrf;
    PRECLIST lprl;          // Created
    PFOLDERTWINLIST lpftl;  // Created.  May be NULL
    UINT ucUse;             // Use count (dirty entry is not cleaned until 
                            //   ucUse == 0)
    UINT uFlags;            // CRLF_* flags
    } CRL, * PCRL;

// Flags for CRL
#define CRLF_DIRTY          0x00000001      // cache item is dirty
#define CRLF_NUKE           0x00000002      // nuke when use count is 0
#define CRLF_SUBFOLDERTWIN  0x00000004      // folder is subfolder of subtree twin
#define CRLF_ISFOLDER       0x00000008      // atomPath is a folder
#define CRLF_ISLFNDRIVE     0x00000010      // is on an LFN drive
#define CRLF_ORPHAN         0x00000020      // item is orphan

extern CACHE g_cacheCRL;        // Reclist cache

void CALLBACK CRL_Free(LPVOID lpv, HWND hwndOwner);

DEBUG_CODE( void PUBLIC CRL_DumpAll(); )

#define CRL_IsOrphan(pcrl)              IsFlagSet((pcrl)->uFlags, CRLF_ORPHAN)
#define CRL_IsSubfolderTwin(pcrl)       IsFlagSet((pcrl)->uFlags, CRLF_SUBFOLDERTWIN)
#define CRL_IsFolder(pcrl)              IsFlagSet((pcrl)->uFlags, CRLF_ISFOLDER)

//      BOOL CRL_Init(void);
//
#define CRL_Init()                      Cache_Init(&g_cacheCRL)

//      void CRL_InitCS(void);
//
#define CRL_InitCS()                    Cache_InitCS(&g_cacheCRL)

//      void CRL_Term(void);
//
#define CRL_Term()             Cache_Term(&g_cacheCRL, NULL, CRL_Free)

//      void CRL_DeleteCS(void);
//
#define CRL_DeleteCS()                  Cache_DeleteCS(&g_cacheCRL)

BOOL PUBLIC IsSubfolderTwin(HBRFCASE hbrf, LPCTSTR pcszPath);

//      HRESULT CRL_Add(PCBS pcbs, int atomPath);
//          Must call CRL_Delete for each call to this function.
//
HRESULT     PUBLIC CRL_Add(PCBS pcbs, int atomPath);

//      HRESULT CRL_Get(int atomPath, PCRL * ppcrl);
//          Must call CRL_Delete for each successful call to this function.
//
HRESULT     PUBLIC CRL_Get(int atomPath, PCRL * ppcrl);

//      HRESULT CRL_Replace(int atomPath);
//
HRESULT     PUBLIC CRL_Replace(int atomPath);

//      void CRL_Delete(int atomPath);
//
void        PUBLIC CRL_Delete(int atomPath);

//      int CRL_Nuke(int atomPath);
//
void        PUBLIC CRL_Nuke(int atomPath);

//      BOOL CRL_Dirty(int atomPath);
BOOL        PUBLIC CRL_Dirty(int atomPath, int atomCabinetFolder, LONG lEvent, LPBOOL pbRefresh);

//      void CRL_DirtyAll(int atomBrf);
//
void        PUBLIC CRL_DirtyAll(int atomBrf);


/////////////////////////////////////////////////////////////
//  
//  Cached briefcase paths
//
/////////////////////////////////////////////////////////////

typedef struct tagCPATH
    {
    int atomPath;           // Useful for reference 

    } CPATH;

extern CACHE g_cacheCPATH;        // Volume ID cache

void CALLBACK CPATH_Free(LPVOID lpv, HWND hwndOwner);

DEBUG_CODE( void PUBLIC CPATH_DumpAll(); )

//      BOOL CPATH_Init(void);
//
#define CPATH_Init()                    Cache_Init(&g_cacheCPATH)

//      void CPATH_InitCS(void);
//
#define CPATH_InitCS()                  Cache_InitCS(&g_cacheCPATH)

//      void CPATH_Term();
//
#define CPATH_Term()                    Cache_Term(&g_cacheCPATH, NULL, CPATH_Free)

//      void CPATH_DeleteCS(void);
//
#define CPATH_DeleteCS()                Cache_DeleteCS(&g_cacheCPATH)

//      CPATH FAR * CPATH_Replace(int atomPath);
//          Must call CPATH_Delete for each call to this function.
//
CPATH  *  PUBLIC CPATH_Replace(int atomPath);

//      UINT CPATH_GetLocality(LPCSTR pszPath, LPSTR pszBuf);
//
UINT    PUBLIC CPATH_GetLocality(LPCTSTR pszPath, LPTSTR pszBuf);

#endif // __CACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\comm.h ===
//
// comm.h: Declares data, defines and struct types for common code
//            module.
//
//

#ifndef __COMM_H__
#define __COMM_H__



/////////////////////////////////////////////////////  DEFINES

#define BLOCK        
#define Unref(x)     x

#ifdef DEBUG
#define INLINE
#define DEBUG_CODE(x)   x
#else
#define INLINE          __inline
#define DEBUG_CODE(x)   
#endif

#define CbFromCch(cch)              ((cch)*sizeof(TCHAR))
#define CCH_NUL                     (sizeof(TCHAR))


/////////////////////////////////////////////////////  MACROS

// Zero-initialize data-item
//
#define ZeroInit(pobj, type)        lmemset((CHAR *)pobj, 0, sizeof(type))

// Copy chunk of memory
//
#define BltByte(pdest, psrc, cb)    lmemmove((CHAR *)pdest, (CHAR *)psrc, cb)

// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))  
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))  

#define InRange(id, idFirst, idLast)  ((UINT)(id-idFirst) <= (UINT)(idLast-idFirst))

//
// Non-shared memory allocation
//

//      void * GAlloc(DWORD cbBytes)
//          Alloc a chunk of memory, quickly, with no 64k limit on size of
//          individual objects or total object size.  Initialize to zero.
//
#define GAlloc(cbBytes)         GlobalAlloc(GPTR, cbBytes)

//      void * GReAlloc(void * pv, DWORD cbNewSize)
//          Realloc one of above.  If pv is NULL, then this function will do
//          an alloc for you.  Initializes new portion to zero.
//
#define GReAlloc(pv, cbNewSize) GlobalReAlloc(pv, cbNewSize, GMEM_MOVEABLE | GMEM_ZEROINIT)

//      void GFree(void *pv)
//          Free pv if it is nonzero.  Set pv to zero.  
//
#define GFree(pv)        do { (pv) ? GlobalFree(pv) : (void)0;  pv = NULL; } while (0)

//      DWORD GGetSize(void *pv)
//          Get the size of a block allocated by Alloc()
//
#define GGetSize(pv)            GlobalSize(pv)

//      type * GAllocType(type);                    (macro)
//          Alloc some memory the size of <type> and return pointer to <type>.
//
#define GAllocType(type)                (type *)GAlloc(sizeof(type))

//      type * GAllocArray(type, int cNum);         (macro)
//          Alloc an array of data the size of <type>.
//
#define GAllocArray(type, cNum)          (type *)GAlloc(sizeof(type) * (cNum))

//      type * GReAllocArray(type, void * pb, int cNum);
//
#define GReAllocArray(type, pb, cNum)    (type *)GReAlloc(pb, sizeof(type) * (cNum))

// Copies psz into *ppszBuf and (re)allocates *ppszBuf accordingly
BOOL PUBLIC GSetString(LPTSTR * ppszBuf, LPCTSTR psz);

// Concatenates psz onto *ppszBuf and (re)allocates *ppszBuf accordingly
BOOL PUBLIC GCatString(LPTSTR * ppszBuf, LPCTSTR psz);


// FileInfo struct that contains file time/size info
//
typedef struct _FileInfo
    {
    HICON   hicon;
    FILETIME ftMod;
    DWORD   dwSize;         // size of the file
    DWORD   dwAttributes;   // attributes
    LPARAM  lParam;
    LPTSTR   pszDisplayName; // points to the display name
    TCHAR    szPath[1];      
    } FileInfo;

#define FIGetSize(pfi)          ((pfi)->dwSize)
#define FIGetPath(pfi)          ((pfi)->szPath)
#define FIGetDisplayName(pfi)   ((pfi)->pszDisplayName)
#define FIGetAttributes(pfi)    ((pfi)->dwAttributes)
#define FIIsFolder(pfi)         (IsFlagSet((pfi)->dwAttributes, SFGAO_FOLDER))

// Flags for FICreate
#define FIF_DEFAULT     0x0000
#define FIF_ICON        0x0001
#define FIF_DONTTOUCH   0x0002
#define FIF_FOLDER      0x0004

HRESULT PUBLIC FICreate(LPCTSTR pszPath, FileInfo ** ppfi, UINT uFlags);
BOOL    PUBLIC FISetPath(FileInfo ** ppfi, LPCTSTR pszPathNew, UINT uFlags);
BOOL    PUBLIC FIGetInfoString(FileInfo * pfi, LPTSTR pszBuf, int cchBuf);
void    PUBLIC FIFree(FileInfo * pfi);

void    PUBLIC FileTimeToDateTimeString(LPFILETIME pft, LPTSTR pszBuf, int cchBuf);


// Color macros
//
#define ColorText(nState)   (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT)
#define ColorBk(nState)     (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_WINDOW)
#define ColorMenuText(nState)   (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT)
#define ColorMenuBk(nState)     (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_MENU)
#define GetImageDrawStyle(nState)   (((nState) & ODS_SELECTED) ? ILD_SELECTED : ILD_NORMAL)

// Sets the dialog handle in the given data struct on first
//  message that the dialog gets (WM_SETFONT).
//
#define SetDlgHandle(hwnd, msg, lp)     if((msg)==WM_SETFONT) (lp)->hdlg=(hwnd);

#define DECLAREHOURGLASS    HCURSOR hcurSavHourglass
#define SetHourglass()      hcurSavHourglass = SetCursor(LoadCursor(NULL, IDC_WAIT))
#define ResetHourglass()    SetCursor(hcurSavHourglass)

// UNICODE WARNING: These must stay as CHARS for the math to be right

CHAR *   PUBLIC lmemset(CHAR * dst, CHAR val, UINT count);
CHAR *   PUBLIC lmemmove(CHAR * dst, CHAR * src, int count);

int     PUBLIC AnsiToInt(LPCTSTR pszString);

int PUBLIC DoModal (HWND hwndParent, DLGPROC lpfnDlgProc, UINT uID, LPARAM lParam);

VOID PUBLIC SetRectFromExtent(HDC hdc, LPRECT lprc, LPCTSTR lpcsz);

// Flags for MyDrawText()
#define MDT_DRAWTEXT        0x00000001                                  
#define MDT_ELLIPSES        0x00000002                                  
#define MDT_LINK            0x00000004                                  
#define MDT_SELECTED        0x00000008                                  
#define MDT_DESELECTED      0x00000010                                  
#define MDT_DEPRESSED       0x00000020                                  
#define MDT_EXTRAMARGIN     0x00000040                                  
#define MDT_TRANSPARENT     0x00000080
#define MDT_LEFT            0x00000100
#define MDT_RIGHT           0x00000200
#define MDT_CENTER          0x00000400
#define MDT_VCENTER         0x00000800
#define MDT_CLIPPED         0x00001000

void PUBLIC MyDrawText(HDC hdc, LPCTSTR pszText, RECT * prc, UINT flags, int cyChar, int cxEllipses, COLORREF clrText, COLORREF clrTextBk);

DWORD PUBLIC MsgWaitObjectsSendMessage(DWORD cObjects, LPHANDLE phObjects, DWORD dwTimeout);

HCURSOR PUBLIC SetCursorRemoveWigglies(HCURSOR hcur);

LPTSTR PUBLIC _ConstructMessageString(HINSTANCE hinst, LPCTSTR pszMsg, va_list *ArgList);

BOOL PUBLIC ConstructMessage(LPTSTR * ppsz, HINSTANCE hinst, LPCTSTR pszMsg, ...);

#endif // __COMM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\crl.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: crl.c
//
//  This files contains code for the cached reclists
//
// History:
//  09-02-93 ScottH     Created
//  01-31-94 ScottH     Moved from cache.c
//
//---------------------------------------------------------------------------

#include "brfprv.h"         // common headers
#include "recact.h"

#include "res.h"

#define CRL_Iterate(atom)       \
            for (atom = Cache_FindFirstKey(&g_cacheCRL);        \
                ATOM_ERR != atom;                               \
                atom = Cache_FindNextKey(&g_cacheCRL, atom))

CACHE g_cacheCRL = {0, 0, 0};        // Reclist cache

#define CRL_EnterCS()    EnterCriticalSection(&g_cacheCRL.cs)
#define CRL_LeaveCS()    LeaveCriticalSection(&g_cacheCRL.cs)


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Dump a CRL entry
Returns: --
Cond:    --
*/
void PRIVATE CRL_DumpEntry(
    CRL  * pcrl)
    {
    TCHAR sz[MAXBUFLEN];

    ASSERT(pcrl);

    TRACE_MSG(TF_ALWAYS, TEXT("CRL:  Atom %d: %s"), pcrl->atomPath, Atom_GetName(pcrl->atomPath));
    TRACE_MSG(TF_ALWAYS, TEXT("      Outside %d: %s"), pcrl->atomOutside, Atom_GetName(pcrl->atomOutside));
    TRACE_MSG(TF_ALWAYS, TEXT("               Ref [%u]  Use [%u]  %s  %s  %s  %s"), 
        Cache_GetRefCount(&g_cacheCRL, pcrl->atomPath),
        pcrl->ucUse,
        CRL_IsOrphan(pcrl) ? (LPCTSTR) TEXT("Orphan") : (LPCTSTR) TEXT(""),
        IsFlagSet(pcrl->uFlags, CRLF_DIRTY) ? (LPCTSTR) TEXT("Dirty") : (LPCTSTR) TEXT(""),
        IsFlagSet(pcrl->uFlags, CRLF_NUKE) ? (LPCTSTR) TEXT("Nuke") : (LPCTSTR) TEXT(""),
        CRL_IsSubfolderTwin(pcrl) ? (LPCTSTR) TEXT("SubfolderTwin") : (LPCTSTR) TEXT(""));
    TRACE_MSG(TF_ALWAYS, TEXT("               Status: %s"), SzFromIDS(pcrl->idsStatus, sz, ARRAYSIZE(sz)));
    }


void PUBLIC CRL_DumpAll()
    {
    CRL  * pcrl;
    int atom;
    BOOL bDump;

    ENTEREXCLUSIVE()
        {
        bDump = IsFlagSet(g_uDumpFlags, DF_CRL);
        }
    LEAVEEXCLUSIVE()

    if (!bDump)
        return ;

    CRL_Iterate(atom)
        {
        pcrl = Cache_GetPtr(&g_cacheCRL, atom);
        ASSERT(pcrl);
        if (pcrl)
            {
            CRL_DumpEntry(pcrl);
            Cache_DeleteItem(&g_cacheCRL, atom, FALSE, NULL, CRL_Free);    // Decrement count
            }
        }
    }
#endif


/*----------------------------------------------------------
Purpose: Return the resource string ID describing the action to take
Returns: --
Cond:    --
*/
UINT PRIVATE IdsFromRAItem(
    LPRA_ITEM pitem)
    {
    UINT ids;

    ASSERT(IsFlagSet(pitem->mask, RAIF_ACTION));

    switch (pitem->uAction)
        {
    case RAIA_TOOUT:
    case RAIA_TOIN:
    case RAIA_CONFLICT:
    case RAIA_DELETEOUT:
    case RAIA_DELETEIN:
    case RAIA_MERGE:
    case RAIA_SOMETHING:
        ids = IDS_STATE_NeedToUpdate;
        break;

    case RAIA_ORPHAN:
        ids = IDS_STATE_Orphan;
        break;

    case RAIA_DONTDELETE:
    case RAIA_SKIP:
        ASSERT(SI_UNAVAILABLE == pitem->siInside.uState ||
               SI_UNAVAILABLE == pitem->siOutside.uState);
        if (SI_UNAVAILABLE == pitem->siOutside.uState)
            {
            if (SI_UNCHANGED == pitem->siInside.uState)
                {
                ids = IDS_STATE_UptodateInBrf;
                }
            else if (SI_UNAVAILABLE != pitem->siInside.uState)
                {
                ids = IDS_STATE_NeedToUpdate;
                }
            else
                {
                ids = IDS_STATE_Unavailable;
                }
            }
        else
            {
            ASSERT(SI_UNAVAILABLE == pitem->siInside.uState);
            ids = IDS_STATE_Unavailable;
            }
        break;

    case RAIA_NOTHING:
        ids = IDS_STATE_Uptodate;
        break;

    default:
        ASSERT(0);
        ids = 0;
        break;
        }

    return ids;
    }


/*----------------------------------------------------------
Purpose: Gets the outside sync copy and the resource ID to the
         status string that indicates the status between the 
         sync copies.

Returns: --
Cond:    --
*/
void PRIVATE SetPairInfo(
    PCRL pcrl)
    {
    LPCTSTR pszPath = Atom_GetName(pcrl->atomPath);
    LPCTSTR pszName = PathFindFileName(pszPath);

    // Is this an orphan?
    if (CRL_IsOrphan(pcrl))
        {
        // Yes; special case: is this one of the briefcase system files?
        LPCTSTR pszDBName;

        if (IsFlagSet(pcrl->uFlags, CRLF_ISLFNDRIVE))
            pszDBName = g_szDBName;
        else
            pszDBName = g_szDBNameShort;

        if (IsSzEqual(pszName, pszDBName) || 
            IsSzEqual(pszName, c_szDesktopIni))
            {
            // Yes
            pcrl->idsStatus = IDS_STATE_SystemFile;
            }
        // Is this a subfolder twin?  (Only orphans are
        // candidates for being subfolder twins.)
        else if (CRL_IsSubfolderTwin(pcrl))
            {
            // Yes
            ASSERT(PathIsDirectory(pszPath));

            pcrl->idsStatus = IDS_STATE_Subfolder;
            }
        else
            {
            // No
            pcrl->idsStatus = IDS_STATE_Orphan;
            }

        if (Atom_IsValid(pcrl->atomOutside))
            {
            Atom_Delete(pcrl->atomOutside);     // delete the old one
            }
        pcrl->atomOutside = Atom_Add(TEXT(""));
        }
    else
        {
        // No; get the info for this sync copy
        HRESULT hres;
        LPRA_ITEM pitem;
        TCHAR sz[MAXPATHLEN];

        ASSERT(pcrl->lprl);

        hres = RAI_Create(&pitem, Atom_GetName(pcrl->atomBrf), pszPath, 
            pcrl->lprl, pcrl->lpftl);

        if (SUCCEEDED(hres))
            {
            lstrcpy(sz, pitem->siOutside.pszDir);

            // Is this a file?
            if ( !CRL_IsFolder(pcrl) )
                {
                // Yes; atomOutside needs to be a fully qualified path to
                // the outside file/folder--not just the parent folder.
                // That's why we tack on the filename here.
                PathAppend(sz, pszName);
                }

            if (Atom_IsValid(pcrl->atomOutside))
                {
                Atom_Delete(pcrl->atomOutside);     // delete the old one
                }

            pcrl->atomOutside = Atom_Add(sz);
            pcrl->idsStatus = IdsFromRAItem(pitem);
            RAI_Free(pitem);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Determines whether or not a subfolder of a briefcase 
         is the root of a subtree twin.
Returns: --
Cond:    --
*/
BOOL PRIVATE IsSubtreeTwin(HBRFCASE hbrf, LPCTSTR pcszFolder)
{
   BOOL bIsSubtreeTwin = FALSE;
   PFOLDERTWINLIST pftl;

   ASSERT(PathIsDirectory(pcszFolder));

   /* Create a folder twin list for the folder. */

   if (Sync_CreateFolderList(hbrf, pcszFolder, &pftl) == TR_SUCCESS)
   {
      PCFOLDERTWIN pcft;

      /*
       * Look through the folder twin list for any folder twins with the
       * FT_FL_SUBTREE flag set.
       */

      for (pcft = pftl->pcftFirst; pcft; pcft = pcft->pcftNext)
      {
         if (pcft->dwFlags & FT_FL_SUBTREE)
         {
            bIsSubtreeTwin = TRUE;
            break;
         }
      }

      Sync_DestroyFolderList(pftl);
   }

   return(bIsSubtreeTwin);
}


/*----------------------------------------------------------
Purpose: Determines whether or not a path is a subfolder of a subtree twin in a
         briefcase.
Returns: --
Cond:    --
*/
BOOL PUBLIC IsSubfolderTwin(HBRFCASE hbrf, LPCTSTR pcszPath)
{
   BOOL bIsSubfolderTwin = FALSE;
   TCHAR szBrfRoot[MAXPATHLEN];

   if (PathIsDirectory(pcszPath) &&
       PathGetLocality(pcszPath, szBrfRoot) == PL_INSIDE)
   {
      int ncchBrfRootLen;
      TCHAR szParent[MAXPATHLEN];

      ASSERT(PathIsPrefix(pcszPath, szBrfRoot));

      ncchBrfRootLen = lstrlen(szBrfRoot);

      ASSERT(lstrlen(pcszPath) < ARRAYSIZE(szParent));
      lstrcpy(szParent, pcszPath);

      /*
       * Keep whacking off the last path component until we find a parent
       * subtree twin root, or we hit the briefcase root.
       */

      while (! bIsSubfolderTwin &&
             PathRemoveFileSpec(szParent) &&
             lstrlen(szParent) > ncchBrfRootLen)
      {
         BOOL bIsFolderTwin;

         if (Sync_IsFolder(hbrf, szParent, &bIsFolderTwin) == TR_SUCCESS &&
             bIsFolderTwin)
         {
            bIsSubfolderTwin = IsSubtreeTwin(hbrf, szParent);

#ifdef DEBUG
            TRACE_MSG(TF_CACHE, TEXT("CACHE  Found subfolder twin %s with parent subtree twin root %s."),
                      pcszPath,
                      szParent);
#endif
         }
      }
   }

   return(bIsSubfolderTwin);
}


/*----------------------------------------------------------
Purpose: Sets the bSubfolderTwin member of a CRL.
Returns: --
Cond:    The lprl and lpftl members of the CRL must be filled in before calling
         this function.
*/
void PRIVATE SetSubfolderTwinFlag(PCRL pcrl)
    {
    if (! pcrl->lprl && ! pcrl->lpftl)
        {
        if (IsSubfolderTwin(pcrl->hbrf, Atom_GetName(pcrl->atomPath)))
            SetFlag(pcrl->uFlags, CRLF_SUBFOLDERTWIN);
        else
            ClearFlag(pcrl->uFlags, CRLF_SUBFOLDERTWIN);
        }
    else
        {
        ClearFlag(pcrl->uFlags, CRLF_SUBFOLDERTWIN);
        }
    }


/*----------------------------------------------------------
Purpose: Free the reclist
Returns: --

Cond:    hwndOwner is not used, so it is okay for all CRL_ routines
         to pass NULL as hwndOwner.

         This function is serialized by the caller (Cache_Term or
         Cache_DeleteItem).
*/
void CALLBACK CRL_Free(
    LPVOID lpv,
    HWND hwndOwner)
    {
    CRL  * pcrl = (CRL  *)lpv;

    ASSERT(Sync_IsEngineLoaded());

    DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Destroying CRL for %s (0x%lx)"), 
        Atom_GetName(pcrl->atomPath), pcrl->hbrf); )
   
    if (Atom_IsValid(pcrl->atomOutside))
        Atom_Delete(pcrl->atomOutside);

    if (Atom_IsValid(pcrl->atomBrf))
        Atom_Delete(pcrl->atomBrf);

    if (pcrl->lprl)
        Sync_DestroyRecList(pcrl->lprl);

    if (pcrl->lpftl)
        Sync_DestroyFolderList(pcrl->lpftl);

    // The CRL does not own pabortevt, leave it alone

    SharedFree(&pcrl);
    }


/*----------------------------------------------------------
Purpose: Create a reclist and (optional) folder twin list for a path.
          
Returns: standard result
         S_OK if the item is a twin
         S_FALSE if the item is an orphan

Cond:    --
*/
HRESULT PRIVATE CreatePathLists(
    HBRFCASE hbrf,
    PABORTEVT pabortevt,
    int atomPath,
    PRECLIST  * lplprl,
    PFOLDERTWINLIST  * lplpftl)
    {
    HRESULT hres;
    LPCTSTR pszPath = Atom_GetName(atomPath);

    ASSERT(pszPath);
    ASSERT(hbrf);
    ASSERT(lplprl);
    ASSERT(lplpftl);

    *lplprl = NULL;
    *lplpftl = NULL;

    // Two routes.  
    //
    //  1) If the path is to the root of a briefcase,
    //     create a complete reclist.
    //
    //  2) Otherwise create a reclist for the individual file or folder
    //
    // Hack: a quick way of telling if atomPath is a briefcase
    // root is by looking for it in the CBS cache.

    // Is this the root of a briefcase?
    if (CBS_Get(atomPath))
        {
        // Yes
        CBS_Delete(atomPath, NULL);       // Decrement count
        hres = Sync_CreateCompleteRecList(hbrf, pabortevt, lplprl);
        }
    else
        {
        // No; is this a twin?
        hres = Sync_IsTwin(hbrf, pszPath, 0);
        if (S_OK == hres)
            {
            // Yes; create a reclist (and an optional folder twin list).
            HTWINLIST htl;

            hres = E_OUTOFMEMORY;   // assume error

            if (Sync_CreateTwinList(hbrf, &htl) == TR_SUCCESS)
                {
                if (Sync_AddPathToTwinList(hbrf, htl, pszPath, lplpftl))
                    {
                    hres = Sync_CreateRecListEx(htl, pabortevt, lplprl);

                    if (SUCCEEDED(hres))
                        {
                        // The object may have been implicitly deleted
                        // in CreateRecList.  Check again.
                        hres = Sync_IsTwin(hbrf, pszPath, 0);
                        }
                    }
                Sync_DestroyTwinList(htl);
                }
            }
        }

    if (FAILED(hres))
        {
        // Cleanup on failure
        //
        if (*lplpftl)
            Sync_DestroyFolderList(*lplpftl);

        *lplprl = NULL;
        *lplpftl = NULL;
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Add a CRL entry for the atomPath to the cache.  This 
         consists of creating the reclist (and folder twin list 
         possibly).

         If the atomPath is already in the cache, this function
         increments the reference count of the item and calls
         CRL_Replace.

Returns: standard result

Cond:    Must call CRL_Delete for every call to this function.

         IMPORTANT: Some portions of code call PathIsDirectory,
         which will fail if atomPath does not exist.

*/
HRESULT PUBLIC CRL_Add(
    PCBS pcbs,
    int atomPath)
    {
    HRESULT hres = E_OUTOFMEMORY;
    PRECLIST lprl = NULL;
    PFOLDERTWINLIST lpftl = NULL;
    CRL  * pcrl;

    ASSERT(pcbs);

    CRL_EnterCS();
        {
        // Caller wants to add.  If it already exists, we simply return
        //  the existing entry.
        //
        // This CRL_Get increments the count (if it succeeds)
        pcrl = Cache_GetPtr(&g_cacheCRL, atomPath);

        // Is the item in the cache?
        if (pcrl)
            {
            // Yes; attempt to get fresh contents
            hres = CRL_Replace(atomPath);
            }
        else
            {
            // No; the entry is not in the cache.  Add it.
            LPCTSTR pszPath = Atom_GetName(atomPath);

            ASSERT(pszPath);

            DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Adding CRL for %s (0x%lx)"), 
                pszPath, pcbs->hbrf); )

            // Leave the critical section while we do expensive calculation
            CRL_LeaveCS();
                {
                hres = CreatePathLists(pcbs->hbrf, pcbs->pabortevt,
                    atomPath, &lprl, &lpftl);
                }
            CRL_EnterCS();

            if (FAILED(hres))
                goto Fail;
            else
                {
                LPCTSTR pszBrf;

                // Allocate using commctrl's Alloc, so the structure will be in
                // shared heap space across processes.
                pcrl = SharedAllocType(CRL);
                if (!pcrl)
                    {
                    hres = E_OUTOFMEMORY;
                    goto Fail;
                    }

                pcrl->atomPath = atomPath;

                pcrl->hbrf = pcbs->hbrf;
                
                pszBrf = Atom_GetName(pcbs->atomBrf);
                pcrl->atomBrf = Atom_Add(pszBrf);

                pcrl->pabortevt = pcbs->pabortevt;
                pcrl->lpftl = lpftl;
                pcrl->lprl = lprl;
                pcrl->ucUse = 0;

                pcrl->uFlags = 0;       // reset
                SetSubfolderTwinFlag(pcrl);
                if (S_FALSE == hres)
                    SetFlag(pcrl->uFlags, CRLF_ORPHAN);

                if (PathIsDirectory(Atom_GetName(atomPath)))
                    SetFlag(pcrl->uFlags, CRLF_ISFOLDER);

                if (IsFlagSet(pcbs->uFlags, CBSF_LFNDRIVE))
                    SetFlag(pcrl->uFlags, CRLF_ISLFNDRIVE);

                SetPairInfo(pcrl);

                // This Cache_AddItem does the increment count
                if ( !Cache_AddItem(&g_cacheCRL, atomPath, (LPVOID)pcrl) )
                    {
                    // Failed
                    Atom_Delete(pcrl->atomBrf);
                    Atom_Delete(pcrl->atomOutside);
                    hres = E_OUTOFMEMORY;
                    goto Fail;
                    }
                }
            }
        }
    CRL_LeaveCS();

    return hres;
    
Fail:
    // Cleanup on failure
    //
    if (lprl)
        Sync_DestroyRecList(lprl);
    if (lpftl)
        Sync_DestroyFolderList(lpftl);
    SharedFree(&pcrl);
    CRL_LeaveCS();

    DEBUG_MSG(TF_ERROR, TEXT("SyncUI   CRL_Add failed!"));
    return hres;
    }


/*----------------------------------------------------------
Purpose: Decrement the reference count and the use count to 
         the reclist cache entry.

         If the reference count == 0, the entry is deleted.
         
Returns: --
Cond:    --
*/
void PUBLIC CRL_Delete(
    int atomPath)
    {
    CRL  * pcrl;

    CRL_EnterCS();
        {
        // Decrement the use count
        //
        pcrl = Cache_GetPtr(&g_cacheCRL, atomPath);
        if (pcrl)
            {
            DEBUG_CODE( LPCTSTR pszPath = Atom_GetName(atomPath); )

            if (pcrl->ucUse > 0)
                pcrl->ucUse--;

            if (IsFlagSet(pcrl->uFlags, CRLF_NUKE))
                {
                if (pcrl->ucUse == 0)
                    {
                    DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Nuking late CRL %s..."), 
                        pszPath); )

                    // A nuke was deferred.  Now we can really do it.
                    //
                    Cache_DeleteItem(&g_cacheCRL, atomPath, TRUE, NULL, CRL_Free);
                    goto Done;
                    }
#ifdef DEBUG
                else
                    {
                    TRACE_MSG(TF_CACHE, TEXT("CACHE  Deferring nuke CRL %s..."), 
                        pszPath);
                    }
#endif
                }
            Cache_DeleteItem(&g_cacheCRL, atomPath, FALSE, NULL, CRL_Free);    // Decrement for Cache_GetPtr

            // The real delete...
            Cache_DeleteItem(&g_cacheCRL, atomPath, FALSE, NULL, CRL_Free);
            }
Done:;
        }
    CRL_LeaveCS();
    }


/*----------------------------------------------------------
Purpose: Nuke the cache entry if the use count is 0.  Otherwise,
         set the nuke bit, and this entry will get nuked on the
         next CRL_Get when the use count is 0.

Returns: --
Cond:    --
*/
void PUBLIC CRL_Nuke(
    int atomPath)
    {
    CRL  * pcrl;

    CRL_EnterCS();
        {
        // Check the use count
        //
        pcrl = Cache_GetPtr(&g_cacheCRL, atomPath);
        if (pcrl)
            {
            if (pcrl->ucUse > 0)
                {
                DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Marking to nuke CRL for %s (0x%lx)"), 
                    Atom_GetName(atomPath), pcrl->hbrf); )

                SetFlag(pcrl->uFlags, CRLF_NUKE);
                Cache_DeleteItem(&g_cacheCRL, atomPath, FALSE, NULL, CRL_Free);    // Decrement for Cache_GetPtr
                }
            else
                {
                DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Nuking CRL for %s (0x%lx)"), 
                    Atom_GetName(atomPath), pcrl->hbrf); )

                Cache_DeleteItem(&g_cacheCRL, atomPath, TRUE, NULL, CRL_Free);
                }
            }
        }
    CRL_LeaveCS();
    }


/*----------------------------------------------------------
Purpose: Replace the atomPath in the cache.  This consists of 
         creating the reclist (and folder twin list possibly)
         and replacing the contents of pcrl.  
         
         The pcrl pointer remains unchanged.

         The reference and use-counts remain unchanged.

Returns: standard result 

Cond:    
         IMPORTANT: Some portions of code call PathIsDirectory,
         which will fail if atomPath does not exist.

*/
HRESULT PUBLIC CRL_Replace(
    int atomPath)
    {
    HRESULT hres;
    CRL * pcrl;

    CRL_EnterCS();
        {
        pcrl = Cache_GetPtr(&g_cacheCRL, atomPath);

        // Does the item exist?
        if (pcrl)
            {
            DEBUG_CODE( LPCTSTR pszPath = Atom_GetName(atomPath); )
            ASSERT(pszPath);
            DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Replacing CRL for %s (0x%lx)"), 
                pszPath, pcrl->hbrf); )

            // Yes; mark it dirty and call CRL_Get on it.
            SetFlag(pcrl->uFlags, CRLF_DIRTY);

            // Note: pay attention to the difference between Cache_Delete
            //  and CRL_Delete.  Cache_Delete must match Cache_Add/Get and
            //  CRL_Delete must match CRL_Add/Get.
            //
            Cache_DeleteItem(&g_cacheCRL, atomPath, FALSE, NULL, CRL_Free);    // Decrement count for Cache_GetPtr

            hres = CRL_Get(atomPath, &pcrl);  // This does the replace

            CRL_Delete(atomPath);             // Decrement count for CRL_Get
            }
        else
            {
            hres = E_FAIL;
            }
        }
    CRL_LeaveCS();

    return hres;
    }


/*----------------------------------------------------------
Purpose: Get the reclist from the cache.  If the cache item exists
          and is marked dirty and the use count is 0, then recreate 
          the reclist.

         If the nuke bit is set, then the entry is nuked and this
          function returns NULL.

Returns: standard result
         Ptr to cache entry.  

Cond:    Must call CRL_Delete for every call to CRL_Get

         IMPORTANT: Some portions of code call PathIsDirectory,
         which will fail if atomPath does not exist.

*/
HRESULT PUBLIC CRL_Get(
    int atomPath,
    PCRL * ppcrl)
    {
    HRESULT hres;
    PCRL pcrl;
    PRECLIST lprl = NULL;
    PFOLDERTWINLIST lpftl = NULL;

    CRL_EnterCS();
        {
        // Don't need to decrement the reference count in this 
        //  function -- this is Get!
        //
        pcrl = Cache_GetPtr(&g_cacheCRL, atomPath);     
        if (pcrl)
            {
            HBRFCASE hbrf = pcrl->hbrf;

            // Is this item pending a nuke?
            if (IsFlagSet(pcrl->uFlags, CRLF_NUKE))
                {
                // Yes; return NULL as if it were already nuked.
                DEBUG_CODE( LPCTSTR pszPath = Atom_GetName(atomPath); )

                DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Attempt to get deferred nuke CRL %s (0x%lx)..."), 
                    pszPath, hbrf); )

                // (Decrement counter for Cache_GetPtr to keep count even,
                // since we are returning NULL.)
                Cache_DeleteItem(&g_cacheCRL, atomPath, FALSE, NULL, CRL_Free);     
                pcrl = NULL;
                hres = E_FAIL;
                }

            // Is this item tagged dirty and the use-count is 0?
            else if (IsFlagSet(pcrl->uFlags, CRLF_DIRTY) && pcrl->ucUse == 0)
                {
                // Yes; we are free to re-create the reclist.
                LPCTSTR pszPath = Atom_GetName(atomPath);

                ASSERT(pszPath);

                DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Getting clean CRL %s (0x%lx)..."), 
                    pszPath, hbrf); )

                // Since we'll be leaving the critical section below,
                // temporarily increase the use count to keep the pcrl
                // from getting nuked from under us.
                pcrl->ucUse++;

                // Replace the contents of the cache entry
                // Leave the critical section while we do expensive calculation
                CRL_LeaveCS();
                    {
                    hres = CreatePathLists(hbrf, pcrl->pabortevt, atomPath,
                        &lprl, &lpftl);
                    }
                CRL_EnterCS();

                // Decrement use count
                pcrl->ucUse--;

                if (FAILED(hres))
                    {
                    DEBUG_CODE( DEBUG_MSG(TF_ERROR, TEXT("SyncUI   CRL_Get failed in cleaning dirty entry!")); )

                    // Still return pcrl since it exists
                    hres = NOERROR;
                    }
                else
                    {
                    // Put the new lists in the cache entry
                    if (pcrl->lprl)
                        {
                        Sync_DestroyRecList(pcrl->lprl);
                        }
                    pcrl->lprl = lprl;

                    if (pcrl->lpftl)
                        {
                        Sync_DestroyFolderList(pcrl->lpftl);
                        }
                    pcrl->lpftl = lpftl;

                    if (S_FALSE == hres)
                        SetFlag(pcrl->uFlags, CRLF_ORPHAN);
                    else
                        {
                        ASSERT(S_OK == hres);
                        ClearFlag(pcrl->uFlags, CRLF_ORPHAN);
                        }

                    ClearFlag(pcrl->uFlags, CRLF_DIRTY);
                    SetSubfolderTwinFlag(pcrl);

                    SetPairInfo(pcrl);
                    hres = NOERROR;
                    }
                }
            else
                {
#ifdef DEBUG
                LPCTSTR pszPath = Atom_GetName(atomPath);

                ASSERT(pszPath);

                if (IsFlagSet(pcrl->uFlags, CRLF_DIRTY))
                    {
                    TRACE_MSG(TF_CACHE, TEXT("CACHE  Getting dirty CRL %s (0x%lx)..."), 
                        pszPath, hbrf);
                    }
                else
                    {
                    TRACE_MSG(TF_CACHE, TEXT("CACHE  Getting CRL %s (0x%lx)..."), 
                        pszPath, hbrf);
                    }
#endif
                hres = NOERROR;
                }
            }
        else
            hres = E_FAIL;

        // Now increment the use count
        //
        if (pcrl)
            pcrl->ucUse++;

        *ppcrl = pcrl;

        ASSERT((FAILED(hres) && !*ppcrl) || 
               (SUCCEEDED(hres) && *ppcrl));
        }
    CRL_LeaveCS();

    return hres;
    }


/*----------------------------------------------------------
Purpose: Mark any related CRLs dirty.  Which CRLs get marked dirty
         depends on the lEvent.

         In addition, *pbRefresh is set to TRUE if the window that
         is calling this function should refresh itself.

         (N.b. in the following rules, we never refresh the immediate
         folder unless explicitly stated, since the shell will do this
         automatically.  E.g., if C:\Bar\Foo.txt received NOE_DIRTYITEM,
         the shell will automatically repaint C:\Bar.)

         Rules:

         NOE_CREATE     Cause:   A file is created.
                        Dirty?   Any CRLs whose atomInside or atomOutside
                                 are parents or equal to atomPath.
                        Refresh? Only in windows of parent folders on either
                                 side OR
                                 in immediate window on the briefcase side 
                                 if atomPath was created on the outside.

         NOE_CREATEFOLDER  same as above

         NOE_DELETE     Cause:   A file or folder was deleted.
                        Dirty?   Any CRLs whose atomInside or atomOutside
                                 are parents or equal to atomPath.
                                 Delete CRL if atomPath matches atomInside
                        Refresh? Only in windows of parent folders on either
                                 side OR
                                 in immediate window on the briefcase side 
                                 if atomPath was deleted on the outside.

         NOE_DELETEFOLDER  same as above

         NOE_RENAME     Cause:   A file or folder was renamed or moved.
                        Dirty?   Any CRLs whose atomInside or atomOutside
                                 are parents or equal to atomPath.
                                 Rename CRL (and related database entry) if
                                 atomPath is inside briefcase
                        Refresh? Only in windows of parent folders on either
                                 side OR
                                 in immediate window on the briefcase side
                                 if atomPath is renamed on the outside.

         NOE_RENAMEFOLDER  same as above

         NOE_DIRTY      Cause:   Varies.  Typically something needs refreshed.
                        Dirty?   Any CRLs whose atomInside or atomOutside
                                 are parents or equal to atomPath.
                                 If atomPath is folder, any CRLs which are
                                 children of atomPath.
                        Refresh? Only in windows of parent folders on either
                                 side OR
                                 in immediate window on the briefcase side
                                 if atomPath is updated on the outside.

Returns: FALSE if nothing was marked
         TRUE if something was marked
Cond:    --
*/
BOOL PUBLIC CRL_Dirty(
    int atomPath,
    int atomCabFolder,      // path of open cabinet window
    LONG lEvent,
    LPBOOL pbRefresh)       // return TRUE to refresh cabinet window
    {
    BOOL bRet = FALSE;
    CRL  * pcrl;
    int atom;
    int atomParent;

    ASSERT(pbRefresh);

    *pbRefresh = FALSE;

    CRL_EnterCS();
        {
        BOOL bIsFolder;

        // Get the atomParent of the atomPath
        TCHAR szParent[MAXPATHLEN];
        
        lstrcpy(szParent, Atom_GetName(atomPath));
        PathRemoveFileSpec(szParent);
        if (0 == *szParent)         // skip blank parent paths 
            goto Done;
        atomParent = Atom_Add(szParent);
        if (ATOM_ERR == atomParent)
            goto Done;

        // Is the path that is being updated a folder?
        pcrl = Cache_GetPtr(&g_cacheCRL, atomPath);
        if (pcrl)
            {
            bIsFolder = CRL_IsFolder(pcrl);
            Cache_DeleteItem(&g_cacheCRL, atomPath, FALSE, NULL, CRL_Free);    // Decrement count
            }
        else
            {
            bIsFolder = FALSE;
            }

        CRL_Iterate(atom)
            {
            pcrl = Cache_GetPtr(&g_cacheCRL, atom);
            ASSERT(pcrl);
            if (pcrl)
                {
                // Is CRL a parent or equal of atomPath?
                if (Atom_IsParentOf(atom, atomPath))
                    {
                    // Yes; mark it
                    DEBUG_CODE( LPCTSTR pszDbg = Atom_GetName(atom); )
                    DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Tagging CRL for %s (0x%lx)"), 
                        pszDbg, pcrl->hbrf); )
    
                    SetFlag(pcrl->uFlags, CRLF_DIRTY);
                    bRet = TRUE;

                    // Refresh this window?
                    // (Only if the cabinet folder is > than an immediate
                    // parent folder.)
                    *pbRefresh = Atom_IsParentOf(atomCabFolder, atom) &&
                                 atomCabFolder != atomParent;

                    switch (lEvent)
                        {
                    case NOE_DELETE:
                    case NOE_DELETEFOLDER:
                        // Is this CRL the item being deleted?
                        if (pcrl->atomPath == atomPath) 
                            {
                            // Yes; delete the CRL
                            CRL_Delete(atom);
                            }
                        break;

                    case NOE_RENAME:
                    case NOE_RENAMEFOLDER:
                        // Is this CRL being renamed (inside briefcase only)?
                        if (pcrl->atomPath == atomPath)
                            {
                            // Yes; mark it for renaming
                            }
                        break;

                    case NOE_DIRTY:
                    case NOE_DIRTYFOLDER:
                        // Is the atomPath a folder and this CRL a child?
                        if (bIsFolder && Atom_IsChildOf(pcrl->atomPath, atomPath))
                            {
                            // Yes; mark it
                            DEBUG_CODE( LPCTSTR pszDbg = Atom_GetName(atom); )
                            DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Tagging CRL for %s (0x%lx)"), 
                                pszDbg, pcrl->hbrf); )
            
                            SetFlag(pcrl->uFlags, CRLF_DIRTY);
                            bRet = TRUE;
                            }
                        break;
                        }
                    }

                // Is CRL's atomOutside a parent or equal of atomPath?
                if (Atom_IsParentOf(pcrl->atomOutside, atomPath))
                    {
                    // Yes; mark it
                    DEBUG_CODE( LPCTSTR pszDbg = Atom_GetName(atom); )
                    DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Tagging CRL for %s (0x%lx)"), 
                        pszDbg, pcrl->hbrf); )
    
                    SetFlag(pcrl->uFlags, CRLF_DIRTY);
                    bRet = TRUE;

                    // Refresh this window?
                    *pbRefresh = Atom_IsParentOf(atomCabFolder, atom);
                    }

                Cache_DeleteItem(&g_cacheCRL, atom, FALSE, NULL, CRL_Free);    // Decrement count
                }
            }
Done:;
        }
    CRL_LeaveCS();
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Mark the entire cache dirty
Returns: --
Cond:    --
*/
void PUBLIC CRL_DirtyAll(
    int atomBrf)
    {
    CRL_EnterCS();
        {
        CRL  * pcrl;
        int atom;

        CRL_Iterate(atom)
            {
            pcrl = Cache_GetPtr(&g_cacheCRL, atom);
            ASSERT(pcrl);
            if (pcrl && pcrl->atomBrf == atomBrf)
                {
                DEBUG_CODE( LPCTSTR pszDbg = Atom_GetName(atom); )
            
                DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CACHE  Tagging CRL for %s (0x%lx)"), pszDbg, 
                    pcrl->hbrf); )
    
                SetFlag(pcrl->uFlags, CRLF_DIRTY);
                Cache_DeleteItem(&g_cacheCRL, atom, FALSE, NULL, CRL_Free);    // Decrement count
                }
            }
        }
    CRL_LeaveCS();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\cpath.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cpath.c
//
//  This files contains code for the cached briefcase paths.
//
// History:
//  01-31-94 ScottH     Created
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers

CACHE g_cacheCPATH = {0, 0, 0};       // Briefcase path cache

#define CPATH_EnterCS()    EnterCriticalSection(&g_cacheCPATH.cs)
#define CPATH_LeaveCS()    LeaveCriticalSection(&g_cacheCPATH.cs)



#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Dumps a CPATH entry
Returns: 
Cond:    --
*/
void PRIVATE CPATH_DumpEntry(
    CPATH  * pcpath)
    {
    ASSERT(pcpath);

    TRACE_MSG(TF_ALWAYS, TEXT("CPATH:  Atom %d: %s"), pcpath->atomPath, Atom_GetName(pcpath->atomPath));
    TRACE_MSG(TF_ALWAYS, TEXT("               Ref [%u]  "), 
        Cache_GetRefCount(&g_cacheCPATH, pcpath->atomPath));
    }


/*----------------------------------------------------------
Purpose: Dumps all CPATH cache
Returns: 
Cond:    --
*/
void PUBLIC CPATH_DumpAll()
    {
    CPATH  * pcpath;
    int atom;
    BOOL bDump;

    ENTEREXCLUSIVE()
        {
        bDump = IsFlagSet(g_uDumpFlags, DF_CPATH);
        }
    LEAVEEXCLUSIVE()

    if (!bDump)
        return ;

    atom = Cache_FindFirstKey(&g_cacheCPATH);
    while (atom != ATOM_ERR)
        {
        pcpath = Cache_GetPtr(&g_cacheCPATH, atom);
        ASSERT(pcpath);
        if (pcpath)
            {
            CPATH_DumpEntry(pcpath);
            Cache_DeleteItem(&g_cacheCPATH, atom, FALSE, NULL, CPATH_Free);    // Decrement count
            }

        atom = Cache_FindNextKey(&g_cacheCPATH, atom);
        }
    }
#endif


/*----------------------------------------------------------
Purpose: Release the volume ID handle
Returns: --

Cond:    hwndOwner is not used.

         This function is serialized by the caller (Cache_Term or
         Cache_DeleteItem).
*/
void CALLBACK CPATH_Free(
    LPVOID lpv,
    HWND hwndOwner)
    {
    CPATH  * pcpath = (CPATH  *)lpv;

    DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CPATH   Freeing Briefcase path %s"), Atom_GetName(pcpath->atomPath)); )

    // Delete the atom one extra time, because we explicitly added
    // it for this cache.
    Atom_Delete(pcpath->atomPath);

    SharedFree(&pcpath);
    }


/*----------------------------------------------------------
Purpose: Add the atomPath to the cache.  
          If atomPath is already in the cache, we replace it
          with a newly obtained path.

Returns: Pointer to CPATH
         NULL on OOM

Cond:    --
*/
CPATH  * PUBLIC CPATH_Replace(
    int atomPath)
    {
    CPATH  * pcpath;
    BOOL bJustAllocd;
    
    CPATH_EnterCS();
        {
        pcpath = Cache_GetPtr(&g_cacheCPATH, atomPath);
        if (pcpath)
            bJustAllocd = FALSE;
        else
            {
            // Allocate using commctrl's Alloc, so the structure will be in
            // shared heap space across processes.
            pcpath = SharedAllocType(CPATH);
            bJustAllocd = TRUE;
            }

        if (pcpath)
            {
            LPCTSTR pszPath = Atom_GetName(atomPath);

            ASSERT(pszPath);

            DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CPATH  Adding known Briefcase %s"), pszPath); )

            pcpath->atomPath = atomPath;

            if (bJustAllocd)
                {
                if (!Cache_AddItem(&g_cacheCPATH, atomPath, (LPVOID)pcpath))
                    {
                    // Cache_AddItem failed here
                    //
                    SharedFree(&pcpath);
                    }
                }
            else
                Cache_DeleteItem(&g_cacheCPATH, atomPath, FALSE, NULL, CPATH_Free);    // Decrement count
            }
        }
    CPATH_LeaveCS();

    return pcpath;
    }


/*----------------------------------------------------------
Purpose: Search for the given path in the cache.  If the path
         exists, its locality will be returned.

         If it is not found, its locality is not known (but
         PL_FALSE is returned).

Returns: path locality (PL_) value
Cond:    --
*/
UINT PUBLIC CPATH_GetLocality(
    LPCTSTR pszPath,
    LPTSTR pszBuf)           // Can be NULL, or must be MAXPATHLEN
    {
    UINT uRet = PL_FALSE;
    LPCTSTR pszBrf;
    int atom;

    ASSERT(pszPath);

    CPATH_EnterCS();
        {
        atom = Cache_FindFirstKey(&g_cacheCPATH);
        while (atom != ATOM_ERR)
            {
            pszBrf = Atom_GetName(atom);

            ASSERT(pszBrf);

            if (IsSzEqual(pszBrf, pszPath))
                {
                uRet = PL_ROOT;
                break;
                }
            else if (PathIsPrefix(pszPath, pszBrf))
                {
                uRet = PL_INSIDE;
                break;
                }

            atom = Cache_FindNextKey(&g_cacheCPATH, atom);
            }

        if (uRet != PL_FALSE && pszBuf)
            lstrcpy(pszBuf, pszBrf);
        }
    CPATH_LeaveCS();
        
    return uRet;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\cvol.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cvol.c
//
//  This files contains code for the cached volume ID structs.
//
// History:
//  09-02-93 ScottH     Created
//  01-31-94 ScottH     Moved from cache.c
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers

/////////////////////////////////////////////////////  TYPEDEFS

/////////////////////////////////////////////////////  CONTROLLING DEFINES

/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MACROS

/////////////////////////////////////////////////////  MODULE DATA

CACHE g_cacheCVOL = {0, 0, 0};       // Volume ID cache

/////////////////////////////////////////////////////  Generic Cache Routines


#ifdef DEBUG
void PRIVATE CVOL_DumpEntry(
    CVOL  * pcvol)
    {
    ASSERT(pcvol);

    TRACE_MSG(TF_ALWAYS, TEXT("CVOL:  Atom %d: %s"), pcvol->atomPath, Atom_GetName(pcvol->atomPath));
    TRACE_MSG(TF_ALWAYS, TEXT("               Ref [%u]  Hvid = %lx"), 
        Cache_GetRefCount(&g_cacheCVOL, pcvol->atomPath),
        pcvol->hvid);
    }


void PUBLIC CVOL_DumpAll()
    {
    CVOL  * pcvol;
    int atom;
    BOOL bDump;

    ENTEREXCLUSIVE()
        {
        bDump = IsFlagSet(g_uDumpFlags, DF_CVOL);
        }
    LEAVEEXCLUSIVE()

    if (!bDump)
        return ;

    atom = Cache_FindFirstKey(&g_cacheCVOL);
    while (atom != ATOM_ERR)
        {
        pcvol = Cache_GetPtr(&g_cacheCVOL, atom);
        ASSERT(pcvol);
        if (pcvol)
            {
            CVOL_DumpEntry(pcvol);
            Cache_DeleteItem(&g_cacheCVOL, atom, FALSE);    // Decrement count
            }

        atom = Cache_FindNextKey(&g_cacheCVOL, atom);
        }
    }
#endif


/*----------------------------------------------------------
Purpose: Release the volume ID handle
Returns: --
Cond:    --
*/
void CALLBACK CVOL_Free(
    LPVOID lpv)
    {
    CVOL  * pcvol = (CVOL  *)lpv;

    DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CVOL  Releasing volume ID %s"), Atom_GetName(pcvol->atomPath)); )

    ASSERT(Sync_IsEngineLoaded());

    Sync_ReleaseVolumeIDHandle(pcvol->hvid);

    SharedFree(&pcvol);
    }


/*----------------------------------------------------------
Purpose: Add the atomPath to the cache.  We add the volume ID.
          If atomPath is already in the cache, we replace it
          with a newly obtained volume ID.

Returns: Pointer to CVOL
         NULL on OOM

Cond:    --
*/
CVOL  * PUBLIC CVOL_Replace(
    int atomPath)
    {
    CVOL  * pcvol;
    BOOL bJustAllocd;
    
    pcvol = Cache_GetPtr(&g_cacheCVOL, atomPath);
    if (pcvol)
        bJustAllocd = FALSE;
    else
        {
        // Allocate using commctrl's Alloc, so the structure will be in
        // shared heap space across processes.
        pcvol = SharedAllocType(CVOL);
        bJustAllocd = TRUE;
        }

    if (pcvol)
        {
        HVOLUMEID hvid;
        LPCTSTR pszPath = Atom_GetName(atomPath);

        ASSERT(pszPath);

        DEBUG_CODE( TRACE_MSG(TF_CACHE, TEXT("CVOL  Adding volume ID %s"), pszPath); )

        if (Sync_GetVolumeIDHandle(pszPath, &hvid) != TR_SUCCESS)
            {
            if (bJustAllocd)
                SharedFree(&pcvol);
            else
                Cache_DeleteItem(&g_cacheCVOL, atomPath, FALSE);    // Decrement count

            pcvol = NULL;       // Fail
            }
        else
            {
            ENTEREXCLUSIVE()
                {
                pcvol->atomPath = atomPath;
                pcvol->hvid = hvid;
                }
            LEAVEEXCLUSIVE()

            if (bJustAllocd)
                {
                if (!Cache_AddItem(&g_cacheCVOL, atomPath, (LPVOID)pcvol))
                    {
                    // Cache_AddItem failed here
                    //
                    Sync_ReleaseVolumeIDHandle(hvid);
                    SharedFree(&pcvol);
                    }
                }
            else
                Cache_DeleteItem(&g_cacheCVOL, atomPath, FALSE);    // Decrement count
            }
        }
    return pcvol;
    }


/*----------------------------------------------------------
Purpose: Search for the given volume ID in the cache.  Return
          the atomKey if it exists, otherwise ATOM_ERR.

Returns: atom
         ATOM_ERR if not found
Cond:    --
*/
int PUBLIC CVOL_FindID(
    HVOLUMEID hvid)
    {
    int atom;
    CVOL  * pcvol;

    atom = Cache_FindFirstKey(&g_cacheCVOL);
    while (atom != ATOM_ERR)
        {
        LPCTSTR pszPath = Atom_GetName(atom);

        ASSERT(pszPath);

        ENTEREXCLUSIVE()
            {
            pcvol = CVOL_Get(atom);
            ASSERT(pcvol);
            if (pcvol)
                {
                int nCmp;
    
                Sync_CompareVolumeIDs(pcvol->hvid, hvid, &nCmp);
                if (Sync_GetLastError() == TR_SUCCESS && nCmp == 0)
                    {
                    // We found it
                    CVOL_Delete(atom);
                    LEAVEEXCLUSIVE()
                    return atom;
                    }
    
                CVOL_Delete(atom);       // decrement count
                }
            }
        LEAVEEXCLUSIVE()

        atom = Cache_FindNextKey(&g_cacheCVOL, atom);
        }

    return ATOM_ERR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\cstrings.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cstrings.h
//
//---------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

extern TCHAR const  c_szNULL[];
extern TCHAR const  c_szZero[];
extern TCHAR const  c_szDelim[];
extern TCHAR const  c_szAllFiles[];
extern TCHAR const  c_szEllipses[];

// Class names

// Executable and DLL names

extern TCHAR const  c_szEngineDLL[];
extern TCHAR const  c_szCabinet[];
extern TCHAR const  c_szCabinetClass[];
extern TCHAR const  c_szWinHelpFile[];
extern TCHAR const  c_szDllGetClassObject[];
extern TCHAR const  c_szOpen[];

#ifdef DEBUG

// These declarations are located in err.c
//
extern TCHAR const  c_szNewline[];
extern TCHAR const  c_szTrace[];
extern TCHAR const  c_szDbg[];
extern TCHAR const  c_szAssertFailed[];

#endif

// Ini file name

extern TCHAR const  c_szIniFile[];
extern TCHAR const  c_szDesktopIni[];
extern TCHAR const  c_szRunWizard[];

// Ini section names

extern TCHAR const  c_szIniSecExclude[];
extern TCHAR const  c_szIniSecFilter[];
extern TCHAR const  c_szIniSecBriefcase[];

#ifdef DEBUG

extern TCHAR const  c_szIniSecDebugUI[];

#endif

// Ini key names

extern TCHAR const  c_szIniKeyCLSID[];
extern TCHAR const  c_szCLSID[];

extern TCHAR const  c_szIniKeyPBar[];
extern TCHAR const  c_szIniKeyFile[];
extern TCHAR const  c_szIniKeyType[];

#ifdef DEBUG

extern TCHAR const  c_szIniKeyTraceFlags[];
extern TCHAR const  c_szIniKeyDumpFlags[];
extern TCHAR const  c_szIniKeyBreakOnOpen[];
extern TCHAR const  c_szIniKeyBreakOnClose[];
extern TCHAR const  c_szIniKeyBreakOnRunOnce[];
extern TCHAR const  c_szIniKeyBreakOnValidate[];
extern TCHAR const  c_szIniKeyBreakOnThreadAtt[];
extern TCHAR const  c_szIniKeyBreakOnThreadDet[];
extern TCHAR const  c_szIniKeyBreakOnProcessAtt[];
extern TCHAR const  c_szIniKeyBreakOnProcessDet[];

#endif


#endif  // _CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\da.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: da.c
//
//  This file contains dynamic array functions.
//
// History:
//  09-27-94 ScottH     Taken from commctrl
//
//---------------------------------------------------------------------------


#include "brfprv.h"         // common headers

//
// Heapsort is a bit slower, but it doesn't use any stack or memory...
// Mergesort takes a bit of memory (O(n)) and stack (O(log(n)), but very fast...
//
#ifdef WIN32
#define MERGESORT
#else
#define USEHEAPSORT
#endif

#ifdef DEBUG
#define DSA_MAGIC   (TEXT('S') | (TEXT('A') << 256))
#define IsDSA(pdsa) ((pdsa) && (pdsa)->magic == DSA_MAGIC)
#define DPA_MAGIC   (TEXT('P') | (TEXT('A') << 256))
#define IsDPA(pdpa) ((pdpa) && (pdpa)->magic == DPA_MAGIC)
#else
#define IsDSA(pdsa)
#define IsDPA(pdsa)
#endif


typedef struct {
    void * * pp;
    PFNDPACOMPARE pfnCmp;
    LPARAM lParam;
    int cp;
#ifdef MERGESORT
    void * * ppT;
#endif
} SORTPARAMS;

BOOL  DPA_QuickSort(SORTPARAMS * psp);
BOOL  DPA_QuickSort2(int i, int j, SORTPARAMS * psp);
BOOL  DPA_HeapSort(SORTPARAMS * psp);
void  DPA_HeapSortPushDown(int first, int last, SORTPARAMS * psp);
BOOL  DPA_MergeSort(SORTPARAMS * psp);
void  DPA_MergeSort2(SORTPARAMS * psp, int iFirst, int cItems);



//========== Dynamic structure array ====================================

// Dynamic structure array

typedef struct _DSA {
// NOTE: The following field MUST be defined at the beginning of the
// structure in order for GetItemCount() to work.
//
    int cItem;          // # of elements in dsa

    void * aItem;       // memory for elements
    int cItemAlloc;     // # items which fit in aItem
    int cbItem;         // size of each item
    int cItemGrow;      // # items to grow cItemAlloc by
#ifdef DEBUG
    UINT magic;
#endif
} DSA;

#define DSA_PITEM(pdsa, index)    ((void *)(((BYTE *)(pdsa)->aItem) + ((index) * (pdsa)->cbItem)))


HDSA PUBLIC DSA_Create(int cbItem, int cItemGrow)
{
    HDSA pdsa = SharedAlloc(sizeof(DSA));

    ASSERT(cbItem);

    if (pdsa)
    {
        pdsa->cItem = 0;
        pdsa->cItemAlloc = 0;
        pdsa->cbItem = cbItem;
        pdsa->cItemGrow = (cItemGrow == 0 ? 1 : cItemGrow);
        pdsa->aItem = NULL;
#ifdef DEBUG
        pdsa->magic = DSA_MAGIC;
#endif
    }
    return pdsa;
}

BOOL PUBLIC DSA_Destroy(HDSA pdsa)
{
    ASSERT(IsDSA(pdsa));

    if (pdsa == NULL)       // allow NULL for low memory cases, still assert
        return TRUE;

#ifdef DEBUG
    pdsa->cItem = 0;
    pdsa->cItemAlloc = 0;
    pdsa->cbItem = 0;
    pdsa->magic = 0;
#endif
    if (pdsa->aItem && !SharedFree(&pdsa->aItem))
        return FALSE;

    return SharedFree(&pdsa);
}

BOOL PUBLIC DSA_GetItem(HDSA pdsa, int index, void * pitem)
{
    ASSERT(IsDSA(pdsa));
    ASSERT(pitem);

    if (index < 0 || index >= pdsa->cItem)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: Invalid index: %d"), index);
        return FALSE;
    }

    hmemcpy(pitem, DSA_PITEM(pdsa, index), pdsa->cbItem);
    return TRUE;
}

void * PUBLIC DSA_GetItemPtr(HDSA pdsa, int index)
{
    ASSERT(IsDSA(pdsa));

    if (index < 0 || index >= pdsa->cItem)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: Invalid index: %d"), index);
        return NULL;
    }
    return DSA_PITEM(pdsa, index);
}

BOOL PUBLIC DSA_SetItem(HDSA pdsa, int index, void * pitem)
{
    ASSERT(pitem);
    ASSERT(IsDSA(pdsa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: Invalid index: %d"), index);
        return FALSE;
    }

    if (index >= pdsa->cItem)
    {
        if (index + 1 > pdsa->cItemAlloc)
        {
            int cItemAlloc = (((index + 1) + pdsa->cItemGrow - 1) / pdsa->cItemGrow) * pdsa->cItemGrow;

            void * aItemNew = SharedReAlloc(pdsa->aItem, cItemAlloc * pdsa->cbItem);
            if (!aItemNew)
                return FALSE;

            pdsa->aItem = aItemNew;
            pdsa->cItemAlloc = cItemAlloc;
        }
        pdsa->cItem = index + 1;
    }

    hmemcpy(DSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return TRUE;
}

int PUBLIC DSA_InsertItem(HDSA pdsa, int index, void * pitem)
{
    ASSERT(pitem);
    ASSERT(IsDSA(pdsa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: Invalid index: %d"), index);
        return -1;
    }

    if (index > pdsa->cItem)
        index = pdsa->cItem;

    if (pdsa->cItem + 1 > pdsa->cItemAlloc)
    {
        void * aItemNew = SharedReAlloc(pdsa->aItem,
                (pdsa->cItemAlloc + pdsa->cItemGrow) * pdsa->cbItem);
        if (!aItemNew)
            return -1;

        pdsa->aItem = aItemNew;
        pdsa->cItemAlloc += pdsa->cItemGrow;
    }

    if (index < pdsa->cItem)
    {
        hmemcpy(DSA_PITEM(pdsa, index + 1), DSA_PITEM(pdsa, index),
            (pdsa->cItem - index) * pdsa->cbItem);
    }
    pdsa->cItem++;
    hmemcpy(DSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return index;
}

BOOL PUBLIC DSA_DeleteItem(HDSA pdsa, int index)
{
    ASSERT(IsDSA(pdsa));

    if (index < 0 || index >= pdsa->cItem)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: Invalid index: %d"), index);
        return FALSE;
    }

    if (index < pdsa->cItem - 1)
    {
        hmemcpy(DSA_PITEM(pdsa, index), DSA_PITEM(pdsa, index + 1),
            (pdsa->cItem - (index + 1)) * pdsa->cbItem);
    }
    pdsa->cItem--;

    if (pdsa->cItemAlloc - pdsa->cItem > pdsa->cItemGrow)
    {
        void * aItemNew = SharedReAlloc(pdsa->aItem,
                (pdsa->cItemAlloc - pdsa->cItemGrow) * pdsa->cbItem);

        ASSERT(aItemNew);
        pdsa->aItem = aItemNew;
        pdsa->cItemAlloc -= pdsa->cItemGrow;
    }
    return TRUE;
}

BOOL PUBLIC DSA_DeleteAllItems(HDSA pdsa)
{
    ASSERT(IsDSA(pdsa));

    if (pdsa->aItem && !SharedFree(&pdsa->aItem))
        return FALSE;

    pdsa->aItem = NULL;
    pdsa->cItem = pdsa->cItemAlloc = 0;
    return TRUE;
}


//================== Dynamic pointer array implementation ===========

typedef struct _DPA {
// NOTE: The following two fields MUST be defined in this order, at
// the beginning of the structure in order for the macro APIs to work.
//
    int cp;
    void * * pp;

    HANDLE hheap;        // Heap to allocate from if NULL use shared

    int cpAlloc;
    int cpGrow;
#ifdef DEBUG
    UINT magic;
#endif
} DPA;



HDPA PUBLIC DPA_Create(int cpGrow)
{
    HDPA pdpa = SharedAlloc(sizeof(DPA));
    if (pdpa)
    {
        pdpa->cp = 0;
        pdpa->cpAlloc = 0;
        pdpa->cpGrow = (cpGrow < 8 ? 8 : cpGrow);
        pdpa->pp = NULL;
#ifdef WIN32
        pdpa->hheap = g_hSharedHeap;   // Defaults to use shared one (for now...)
#else
        pdpa->hheap = NULL;       // Defaults to use shared one (for now...)
#endif
#ifdef DEBUG
        pdpa->magic = DPA_MAGIC;
#endif
    }
    return pdpa;
}

// Should nuke the standard DPA above...
HDPA PUBLIC DPA_CreateEx(int cpGrow, HANDLE hheap)
{
    HDPA pdpa;
    if (hheap == NULL)
    {
        pdpa = SharedAlloc(sizeof(DPA));
#ifdef WIN32
        hheap = g_hSharedHeap;
#endif
    }
    else
        pdpa = MemAlloc(hheap, sizeof(DPA));
    if (pdpa)
    {
        pdpa->cp = 0;
        pdpa->cpAlloc = 0;
        pdpa->cpGrow = (cpGrow < 8 ? 8 : cpGrow);
        pdpa->pp = NULL;
        pdpa->hheap = hheap;
#ifdef DEBUG
        pdpa->magic = DPA_MAGIC;
#endif
    }
    return pdpa;
}

BOOL PUBLIC DPA_Destroy(HDPA pdpa)
{
    ASSERT(IsDPA(pdpa));

    if (pdpa == NULL)       // allow NULL for low memory cases, still assert
        return TRUE;

#ifdef WIN32
    ASSERT (pdpa->hheap);
#endif

#ifdef DEBUG
    pdpa->cp = 0;
    pdpa->cpAlloc = 0;
    pdpa->magic = 0;
#endif
    if (pdpa->pp && !MemFree(pdpa->hheap, pdpa->pp))
        return FALSE;

    return MemFree(pdpa->hheap, pdpa);
}

HDPA PUBLIC DPA_Clone(HDPA pdpa, HDPA pdpaNew)
{
    BOOL fAlloc = FALSE;

    if (!pdpaNew)
    {
        pdpaNew = DPA_CreateEx(pdpa->cpGrow, pdpa->hheap);
        if (!pdpaNew)
            return NULL;

        fAlloc = TRUE;
    }

    if (!DPA_Grow(pdpaNew, pdpa->cpAlloc)) {
        if (!fAlloc)
            DPA_Destroy(pdpaNew);
        return NULL;
    }

    pdpaNew->cp = pdpa->cp;
    hmemcpy(pdpaNew->pp, pdpa->pp, pdpa->cp * sizeof(void *));

    return pdpaNew;
}

void * PUBLIC DPA_GetPtr(HDPA pdpa, int index)
{
    ASSERT(IsDPA(pdpa));

    if (index < 0 || index >= pdpa->cp)
        return NULL;

    return pdpa->pp[index];
}

int PUBLIC DPA_GetPtrIndex(HDPA pdpa, void * p)
{
    void * * pp;
    void * * ppMax;

    ASSERT(IsDPA(pdpa));
    if (pdpa->pp)
    {
        pp = pdpa->pp;
        ppMax = pp + pdpa->cp;
        for ( ; pp < ppMax; pp++)
        {
            if (*pp == p)
                return (pp - pdpa->pp);
        }
    }
    return -1;
}

BOOL PUBLIC DPA_Grow(HDPA pdpa, int cpAlloc)
{
    ASSERT(IsDPA(pdpa));

    if (cpAlloc > pdpa->cpAlloc)
    {
        void * * ppNew;

        cpAlloc = ((cpAlloc + pdpa->cpGrow - 1) / pdpa->cpGrow) * pdpa->cpGrow;

        if (pdpa->pp)
            ppNew = (void * *)MemReAlloc(pdpa->hheap, pdpa->pp, cpAlloc * sizeof(void *));
        else
            ppNew = (void * *)MemAlloc(pdpa->hheap, cpAlloc * sizeof(void *));
        if (!ppNew)
            return FALSE;

        pdpa->pp = ppNew;
        pdpa->cpAlloc = cpAlloc;
    }
    return TRUE;
}

BOOL PUBLIC DPA_SetPtr(HDPA pdpa, int index, void * p)
{
    ASSERT(IsDPA(pdpa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: Invalid index: %d"), index);
        return FALSE;
    }

    if (index >= pdpa->cp)
    {
        if (!DPA_Grow(pdpa, index + 1))
            return FALSE;
        pdpa->cp = index + 1;
    }

    pdpa->pp[index] = p;

    return TRUE;
}

int PUBLIC DPA_InsertPtr(HDPA pdpa, int index, void * p)
{
    ASSERT(IsDPA(pdpa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: Invalid index: %d"), index);
        return -1;
    }
    if (index > pdpa->cp)
        index = pdpa->cp;

    // Make sure we have room for one more item
    //
    if (pdpa->cp + 1 > pdpa->cpAlloc)
    {
        if (!DPA_Grow(pdpa, pdpa->cp + 1))
            return -1;
    }

    // If we are inserting, we need to slide everybody up
    //
    if (index < pdpa->cp)
    {
        hmemcpy(&pdpa->pp[index + 1], &pdpa->pp[index],
            (pdpa->cp - index) * sizeof(void *));
    }

    pdpa->pp[index] = p;
    pdpa->cp++;

    return index;
}

void * PUBLIC DPA_DeletePtr(HDPA pdpa, int index)
{
    void * p;

    ASSERT(IsDPA(pdpa));

    if (index < 0 || index >= pdpa->cp)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: Invalid index: %d"), index);
        return NULL;
    }

    p = pdpa->pp[index];

    if (index < pdpa->cp - 1)
    {
        hmemcpy(&pdpa->pp[index], &pdpa->pp[index + 1],
            (pdpa->cp - (index + 1)) * sizeof(void *));
    }
    pdpa->cp--;

    if (pdpa->cpAlloc - pdpa->cp > pdpa->cpGrow)
    {
        void * * ppNew;
        ppNew = MemReAlloc(pdpa->hheap, pdpa->pp, (pdpa->cpAlloc - pdpa->cpGrow) * sizeof(void *));

        ASSERT(ppNew);
        pdpa->pp = ppNew;
        pdpa->cpAlloc -= pdpa->cpGrow;
    }
    return p;
}

BOOL PUBLIC DPA_DeleteAllPtrs(HDPA pdpa)
{
    ASSERT(IsDPA(pdpa));

    if (pdpa->pp && !MemFree(pdpa->hheap, pdpa->pp))
        return FALSE;
    pdpa->pp = NULL;
    pdpa->cp = pdpa->cpAlloc = 0;
    return TRUE;
}

BOOL PUBLIC DPA_Sort(HDPA pdpa, PFNDPACOMPARE pfnCmp, LPARAM lParam)
{
    SORTPARAMS sp;

    sp.cp = pdpa->cp;
    sp.pp = pdpa->pp;
    sp.pfnCmp = pfnCmp;
    sp.lParam = lParam;

#ifdef USEQUICKSORT
    return DPA_QuickSort(&sp);
#endif
#ifdef USEHEAPSORT
    return DPA_HeapSort(&sp);
#endif
#ifdef MERGESORT
    return DPA_MergeSort(&sp);
#endif
}

#ifdef USEQUICKSORT

BOOL  DPA_QuickSort(SORTPARAMS * psp)
{
    return DPA_QuickSort2(0, psp->cp - 1, psp);
}

BOOL  DPA_QuickSort2(int i, int j, SORTPARAMS * psp)
{
    void * * pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNDPACOMPARE pfnCmp = psp->pfnCmp;

    int iPivot;
    void * pFirst;
    int k;
    int result;

    iPivot = -1;
    pFirst = pp[i];
    for (k = i + 1; k <= j; k++)
    {
        result = (*pfnCmp)(pp[k], pFirst, lParam);

        if (result > 0)
        {
            iPivot = k;
            break;
        }
        else if (result < 0)
        {
            iPivot = i;
            break;
        }
    }

    if (iPivot != -1)
    {
        int l = i;
        int r = j;
        void * pivot = pp[iPivot];

        do
        {
            void * p;

            p = pp[l];
            pp[l] = pp[r];
            pp[r] = p;

            while ((*pfnCmp)(pp[l], pivot, lParam) < 0)
                l++;
            while ((*pfnCmp)(pp[r], pivot, lParam) >= 0)
                r--;
        } while (l <= r);

        if (l - 1 > i)
            DPA_QuickSort2(i, l - 1, psp);
        if (j > l)
            DPA_QuickSort2(l, j, psp);
    }
    return TRUE;
}
#endif  // USEQUICKSORT

#ifdef USEHEAPSORT

void  DPA_HeapSortPushDown(int first, int last, SORTPARAMS * psp)
{
    void * * pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNDPACOMPARE pfnCmp = psp->pfnCmp;
    int r;
    int r2;
    void * p;

    r = first;
    while (r <= last / 2)
    {
        int wRTo2R;
        r2 = r * 2;

        wRTo2R = (*pfnCmp)(pp[r-1], pp[r2-1], lParam);

        if (r2 == last)
        {
            if (wRTo2R < 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2-1]; pp[r2-1] = p;
            }
            break;
        }
        else
        {
            int wR2toR21 = (*pfnCmp)(pp[r2-1], pp[r2+1-1], lParam);

            if (wRTo2R < 0 && wR2toR21 >= 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2-1]; pp[r2-1] = p;
                r = r2;
            }
            else if ((*pfnCmp)(pp[r-1], pp[r2+1-1], lParam) < 0 && wR2toR21 < 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2+1-1]; pp[r2+1-1] = p;
                r = r2 + 1;
            }
            else
            {
                break;
            }
        }
    }
}

BOOL  DPA_HeapSort(SORTPARAMS * psp)
{
    void * * pp = psp->pp;
    int c = psp->cp;
    int i;

    for (i = c / 2; i >= 1; i--)
        DPA_HeapSortPushDown(i, c, psp);

    for (i = c; i >= 2; i--)
    {
        void * p = pp[0]; pp[0] = pp[i-1]; pp[i-1] = p;

        DPA_HeapSortPushDown(1, i - 1, psp);
    }
    return TRUE;
}
#endif  // USEHEAPSORT

#if defined(MERGESORT) && defined(WIN32)

#define SortCompare(psp, pp1, i1, pp2, i2) \
        (psp->pfnCmp(pp1[i1], pp2[i2], psp->lParam))

//
//  This function merges two sorted lists and makes one sorted list.
//   psp->pp[iFirst, iFirst+cItes/2-1], psp->pp[iFirst+cItems/2, iFirst+cItems-1]
//
void  DPA_MergeThem(SORTPARAMS * psp, int iFirst, int cItems)
{
    //
    // Notes:
    //  This function is separated from DPA_MergeSort2() to avoid comsuming
    // stack variables. Never inline this.
    //
    int cHalf = cItems/2;
    int iIn1, iIn2, iOut;
    LPVOID * ppvSrc = &psp->pp[iFirst];

    // Copy the first part to temp storage so we can write directly into
    // the final buffer.  Note that this takes at most psp->cp/2 DWORD's
    hmemcpy(psp->ppT, ppvSrc, cHalf*sizeof(LPVOID));

    for (iIn1=0, iIn2=cHalf, iOut=0;;)
    {
        if (SortCompare(psp, psp->ppT, iIn1, ppvSrc, iIn2) <= 0) {
            ppvSrc[iOut++] = psp->ppT[iIn1++];

            if (iIn1==cHalf) {
                // We used up the first half; the rest of the second half
                // should already be in place
                break;
            }
        } else {
            ppvSrc[iOut++] = ppvSrc[iIn2++];
            if (iIn2==cItems) {
                // We used up the second half; copy the rest of the first half
                // into place
                hmemcpy(&ppvSrc[iOut], &psp->ppT[iIn1], (cItems-iOut)*sizeof(LPVOID));
                break;
            }
        }
    }
}

//
//  This function sorts a give list (psp->pp[iFirst,iFirst-cItems-1]).
//
void  DPA_MergeSort2(SORTPARAMS * psp, int iFirst, int cItems)
{
    //
    // Notes:
    //   This function is recursively called. Therefore, we should minimize
    //  the number of local variables and parameters. At this point, we
    //  use one local variable and three parameters.
    //
    int cHalf;

    switch(cItems)
    {
    case 1:
        return;

    case 2:
        // Swap them, if they are out of order.
        if (SortCompare(psp, psp->pp, iFirst, psp->pp, iFirst+1) > 0)
        {
            psp->ppT[0] = psp->pp[iFirst];
            psp->pp[iFirst] = psp->pp[iFirst+1];
            psp->pp[iFirst+1] = psp->ppT[0];
        }
        break;

    default:
        cHalf = cItems/2;
        // Sort each half
        DPA_MergeSort2(psp, iFirst, cHalf);
        DPA_MergeSort2(psp, iFirst+cHalf, cItems-cHalf);
        // Then, merge them.
        DPA_MergeThem(psp, iFirst, cItems);
        break;
    }
}

BOOL  DPA_MergeSort(SORTPARAMS * psp)
{
    if (psp->cp==0)
        return TRUE;

    // Note that we divide by 2 below; we want to round down
    psp->ppT = LocalAlloc(LPTR, psp->cp/2 * sizeof(LPVOID));
    if (!psp->ppT)
        return FALSE;

    DPA_MergeSort2(psp, 0, psp->cp);
    LocalFree(psp->ppT);
    return TRUE;
}
#endif // MERGESORT

// Search function
//
int PUBLIC DPA_Search(HDPA pdpa, void * pFind, int iStart,
            PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options)
{
    int cp = DPA_GetPtrCount(pdpa);

    ASSERT(pfnCompare);
    ASSERT(0 <= iStart);

    // Only allow these wierd flags if the list is sorted
    ASSERT((options & DPAS_SORTED) || !(options & (DPAS_INSERTBEFORE | DPAS_INSERTAFTER)));

    if (!(options & DPAS_SORTED))
    {
        // Not sorted: do linear search.
        int i;

        for (i = iStart; i < cp; i++)
        {
            if (0 == pfnCompare(pFind, DPA_FastGetPtr(pdpa, i), lParam))
                return i;
        }
        return -1;
    }
    else
    {
        // Search the array using binary search.  If several adjacent 
        // elements match the target element, the index of the first
        // matching element is returned.

        int iRet = -1;      // assume no match
        BOOL bFound = FALSE;
        int nCmp = 0;
        int iLow = 0;       // Don't bother using iStart for binary search
        int iMid = 0;
        int iHigh = cp - 1;

        // (OK for cp == 0)
        while (iLow <= iHigh)
        {
            iMid = (iLow + iHigh) / 2;

            nCmp = pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid), lParam);

            if (0 > nCmp)
                iHigh = iMid - 1;       // First is smaller
            else if (0 < nCmp)
                iLow = iMid + 1;        // First is larger
            else
            {
                // Match; search back for first match
                bFound = TRUE;
                while (0 < iMid)
                {
                    if (0 != pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid-1), lParam))
                        break;
                    else
                        iMid--;
                }
                break;
            }
        }

        if (bFound)
        {
            ASSERT(0 <= iMid);
            iRet = iMid;
        }

        // Did the search fail AND
        // is one of the strange search flags set?
        if (!bFound && (options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)))
        {
            // Yes; return the index where the target should be inserted
            // if not found
            if (0 < nCmp)       // First is larger
                iRet = iLow;
            else
                iRet = iMid;
            // (We don't distinguish between the two flags anymore)
        }
        else if ( !(options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)) )
        {
            // Sanity check with linear search
            ASSERT(DPA_Search(pdpa, pFind, iStart, pfnCompare, lParam, options & ~DPAS_SORTED) == iRet);
        }
        return iRet;
    }
}

//===========================================================================
//
// String ptr management routines
//
// Copy as much of *psz to *pszBuf as will fit
//
int PUBLIC Str_GetPtr(LPCTSTR psz, LPTSTR pszBuf, int cchBuf)
{
    int cch = 0;

    // if pszBuf is NULL, just return length of string.
    //
    if (!pszBuf && psz)
        return lstrlen(psz);

    if (cchBuf)
    {
        if (psz)
        {
            cch = lstrlen(psz);

            if (cch > cchBuf - 1)
                cch = cchBuf - 1;

            hmemcpy(pszBuf, psz, cch * sizeof(TCHAR));
        }
        pszBuf[cch] = 0;
    }
    return cch;
}

// Set *ppsz to a copy of psz, reallocing as needed
//
BOOL PUBLIC Str_SetPtr(LPTSTR * ppsz, LPCTSTR psz)
{
    if (!psz)
    {
        if (*ppsz)
        {
            SharedFree(ppsz);
            *ppsz = NULL;
        }
    }
    else
    {
        LPTSTR pszNew = (LPTSTR)SharedReAlloc(*ppsz, (lstrlen(psz) + 1) * sizeof(TCHAR));
        if (!pszNew)
            return FALSE;

        lstrcpy(pszNew, psz);
        *ppsz = pszNew;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\da.h ===
//
// da.h:  Dynamic array functions taken from commctrl.
//

#ifndef _DA_H_
#define _DA_H_

//====== Dynamic Array routines ==========================================      /* ;Internal */
// Dynamic structure array                                                      /* ;Internal */
typedef struct _DSA * HDSA;                                             /* ;Internal */
                                                                                /* ;Internal */
HDSA   PUBLIC DSA_Create(int cbItem, int cItemGrow);                            /* ;Internal */
BOOL   PUBLIC DSA_Destroy(HDSA hdsa);                                           /* ;Internal */
BOOL   PUBLIC DSA_GetItem(HDSA hdsa, int i, void * pitem);                      /* ;Internal */
LPVOID PUBLIC DSA_GetItemPtr(HDSA hdsa, int i);                                 /* ;Internal */
BOOL   PUBLIC DSA_SetItem(HDSA hdsa, int i, void * pitem);                      /* ;Internal */
int    PUBLIC DSA_InsertItem(HDSA hdsa, int i, void * pitem);                   /* ;Internal */
BOOL   PUBLIC DSA_DeleteItem(HDSA hdsa, int i);                                 /* ;Internal */
BOOL   PUBLIC DSA_DeleteAllItems(HDSA hdsa);                                    /* ;Internal */
#define       DSA_GetItemCount(hdsa) (*(int *)(hdsa))                           /* ;Internal */
                                                                                /* ;Internal */
// Dynamic pointer array                                                        /* ;Internal */
typedef struct _DPA * HDPA;                                             /* ;Internal */
                                                                                /* ;Internal */
HDPA   PUBLIC DPA_Create(int cItemGrow);                                        /* ;Internal */
HDPA   PUBLIC DPA_CreateEx(int cpGrow, HANDLE hheap);                           /* ;Internal */
BOOL   PUBLIC DPA_Destroy(HDPA hdpa);                                           /* ;Internal */
HDPA   PUBLIC DPA_Clone(HDPA hdpa, HDPA hdpaNew);                               /* ;Internal */
LPVOID PUBLIC DPA_GetPtr(HDPA hdpa, int i);                                     /* ;Internal */
int    PUBLIC DPA_GetPtrIndex(HDPA hdpa, LPVOID p);                             /* ;Internal */
BOOL   PUBLIC DPA_Grow(HDPA pdpa, int cp);                                      /* ;Internal */
BOOL   PUBLIC DPA_SetPtr(HDPA hdpa, int i, LPVOID p);                           /* ;Internal */
int    PUBLIC DPA_InsertPtr(HDPA hdpa, int i, LPVOID p);                        /* ;Internal */
LPVOID PUBLIC DPA_DeletePtr(HDPA hdpa, int i);                                  /* ;Internal */
BOOL   PUBLIC DPA_DeleteAllPtrs(HDPA hdpa);                                     /* ;Internal */
#define       DPA_GetPtrCount(hdpa)   (*(int *)(hdpa))                          /* ;Internal */
#define       DPA_GetPtrPtr(hdpa)     (*((LPVOID * *)((BYTE *)(hdpa) + sizeof(int))))   /* ;Internal */
#define       DPA_FastGetPtr(hdpa, i) (DPA_GetPtrPtr(hdpa)[i])                  /* ;Internal */

typedef int (CALLBACK *PFNDPACOMPARE)(LPVOID p1, LPVOID p2, LPARAM lParam);     /* ;Internal */
                                                                                /* ;Internal */
BOOL   PUBLIC DPA_Sort(HDPA hdpa, PFNDPACOMPARE pfnCompare, LPARAM lParam);     /* ;Internal */
                                                                                /* ;Internal */
// Search array.  If DPAS_SORTED, then array is assumed to be sorted            /* ;Internal */
// according to pfnCompare, and binary search algorithm is used.                /* ;Internal */
// Otherwise, linear search is used.                                            /* ;Internal */
//                                                                              /* ;Internal */
// Searching starts at iStart (-1 to start search at beginning).                /* ;Internal */
//                                                                              /* ;Internal */
// DPAS_INSERTBEFORE/AFTER govern what happens if an exact match is not         /* ;Internal */
// found.  If neither are specified, this function returns -1 if no exact       /* ;Internal */
// match is found.  Otherwise, the index of the item before or after the        /* ;Internal */
// closest (including exact) match is returned.                                 /* ;Internal */
//                                                                              /* ;Internal */
// Search option flags                                                          /* ;Internal */
//                                                                              /* ;Internal */
#define DPAS_SORTED             0x0001                                          /* ;Internal */
#define DPAS_INSERTBEFORE       0x0002                                          /* ;Internal */
#define DPAS_INSERTAFTER        0x0004                                          /* ;Internal */
                                                                                /* ;Internal */
int PUBLIC DPA_Search(HDPA hdpa, LPVOID pFind, int iStart,                      /* ;Internal */
                      PFNDPACOMPARE pfnCompare,                                 /* ;Internal */
                      LPARAM lParam, UINT options);                             /* ;Internal */

                                                                                /* ;Internal */
//======================================================================        /* ;Internal */
// String management helper routines                                            /* ;Internal */
                                                                                /* ;Internal */
int  PUBLIC Str_GetPtr(LPCTSTR psz, LPTSTR pszBuf, int cchBuf);                 /* ;Internal */
BOOL PUBLIC Str_SetPtr(LPTSTR * ppsz, LPCTSTR psz);                             /* ;Internal */

#endif // _DA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\dlgids.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by syncui.rc
//
#define IDB_ACTIONS                     108
#define IDD_INTRO_WIZARD                117
#define IDB_LOGO                        118
#define IDC_MSGBOX                      119
#define IDI_LEATHER_BRIEF               120
#define IDI_METAL_BRIEF                 121
#define IDI_SPLIT_FILE                  122
#define IDI_SPLIT_FOLDER                123
#define IDI_SPLIT_MULT                  124
#define IDI_UPDATE_FILE                 125
#define IDI_UPDATE_FOLDER               126
#define IDI_UPDATE_MULT                 127
#define IDI_UPDATE_DOCK                 128
#define IDI_ADD_FOLDER                  129
#define IDI_REPLACE_FILE                130
#define IDI_REPLACE_FOLDER              131
#define IDI_UPDATE                      132
#define IDA_UPDATE                      133
#define IDC_CURSOR1                     133
#define IDA_CHECK                       134
#define IDI_OPEN_FOLDER                 135
#define IDC_INTRO_PAR1                  1012
#define IDC_INTRO_PAR2                  1013
#define IDC_INTRO_PAR3                  1014
#define IDC_INTRO_PAR4                  1015
#define IDC_INTRO_PAR5                  1016
#define IDC_INTRO_PAR6                  1017
#define IDC_INTRO_PAR7                  1018
#define IDC_CREATE_PAR                  1019
#define IDC_CREATE_PAR2                 1020
#define IDC_ATROOT                      1022
#define IDC_ONDESKTOP                   1023
#define IDC_BUTTON1                     1024
#define IDC_BUTTON2                     1025
#define IDC_BUTTON3                     1026
#define IDC_TEXT                        1027
#define IDC_MSGICON                     1028
#define IDC_UPDATEACTIONS               1029
#define IDC_NAME                        1030
#define IDC_EXISTING                    1031
#define IDC_OTHER                       1032
#define IDC_DESC                        1033
#define IDC_BUTTON4                     1034
#define IDD_INFOCREATE                  1100
#define IDD_INFO                        1101
#define IDC_GBIN                        1110
#define IDC_RBINALL                     1111
#define IDC_RBINSELECTED                1112
#define IDC_LBINTYPES                   1113
#define IDC_CHININCLUDE                 1114
#define IDD_UPDATE                      1200
#define IDC_STUPTEXT                    1201
#define IDC_ICTSMAIN                    1310
#define IDC_PBTSRECON                   1324
#define IDC_PBTSFIND                    1328
#define IDC_PBTSSPLIT                   1329
#define IDC_STTSDIRECT                  1339
#define IDD_UPDATEPROGRESS              1400
#define IDC_TONAME                      1410
#define IDC_PROGRESS                    1414
#define IDC_ANIMATE                     1417
#define IDD_STATUS                      1800
#define IDD_REPLACE_FILE                1900
#define IDD_CREATE_WIZARD               1901
#define IDD_PROGRESS                    1902
#define IDC_ICCR                        1910
#define IDC_ICON1                       1911
#define IDC_ICON2                       1912
#define IDC_ICON_EXISTING               1913
#define IDC_ICON_OTHER                  1914
#define IDC_YESTOALL                    1915
#define IDD_REPLACE_FOLDER              1916
#define IDC_LOGO                        -1
#define IDC_UPDICON                     -1
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         105
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\cstrings.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cstrings.c
//
//  This file contains read-only string constants
//
// History:
//  12-21-93 ScottH     Created file
//
//---------------------------------------------------------------------------

#include "brfprv.h"

#pragma data_seg(DATASEG_READONLY)

TCHAR const  c_szNULL[] = TEXT("");
TCHAR const  c_szZero[] = TEXT("0");
TCHAR const  c_szDelim[] = TEXT(" \t,");
TCHAR const  c_szAllFiles[] = TEXT("*.*");
TCHAR const  c_szEllipses[] = TEXT("...");

// Class names

// Executable and DLL names

TCHAR const  c_szEngineDLL[] = TEXT("SYNCENG.DLL");
TCHAR const  c_szCabinet[] = TEXT("Explorer.exe");
TCHAR const  c_szCabinetClass[] = TEXT("CabinetWClass");
TCHAR const  c_szWinHelpFile[] = TEXT("windows.hlp");
TCHAR const  c_szDllGetClassObject[]  = TEXT("DllGetClassObject");
TCHAR const  c_szOpen[] = TEXT("open");

// Ini file name

TCHAR const  c_szIniFile[] = TEXT("rover.ini");
TCHAR const  c_szDesktopIni[]  = STR_DESKTOPINI;
TCHAR const  c_szRunWizard[] = TEXT("RunWizard");

// Ini section names

TCHAR const  c_szIniSecExclude[] = TEXT("Exclude");
TCHAR const  c_szIniSecFilter[] = TEXT("Filter");
TCHAR const  c_szIniSecBriefcase[] = TEXT("Briefcase");

#ifdef DEBUG

TCHAR const  c_szIniSecDebugUI[] = TEXT("SyncUIDebugOptions");

#endif

// Ini key names

TCHAR const  c_szIniKeyCLSID[] = TEXT("CLSID");
TCHAR const  c_szCLSID[] = TEXT("{85BBD920-42A0-1069-A2E4-08002B30309D}");

TCHAR const  c_szIniKeyPBar[] = TEXT("ProgressBar");
TCHAR const  c_szIniKeyFile[] = TEXT("File");
TCHAR const  c_szIniKeyType[] = TEXT("Type");

#ifdef DEBUG

TCHAR const  c_szIniKeyTraceFlags[] = TEXT("TraceFlags");
TCHAR const  c_szIniKeyDumpFlags[] = TEXT("DumpFlags");
TCHAR const  c_szIniKeyBreakOnOpen[] = TEXT("BreakOnOpen");
TCHAR const  c_szIniKeyBreakOnClose[] = TEXT("BreakOnClose");
TCHAR const  c_szIniKeyBreakOnRunOnce[] = TEXT("BreakOnRunOnce");
TCHAR const  c_szIniKeyBreakOnValidate[] = TEXT("BreakOnValidate");
TCHAR const  c_szIniKeyBreakOnThreadAtt[] = TEXT("BreakOnThreadAttach");
TCHAR const  c_szIniKeyBreakOnThreadDet[] = TEXT("BreakOnThreadDetach");
TCHAR const  c_szIniKeyBreakOnProcessAtt[] = TEXT("BreakOnProcessAttach");
TCHAR const  c_szIniKeyBreakOnProcessDet[] = TEXT("BreakOnProcessDetach");

#endif

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\err.h ===
//
// err.h: Declares data, defines and struct types for error handling
//          module.
//
//

#ifndef __ERR_H__
#define __ERR_H__

// Requires comm.h to be included prior to this
//

/////////////////////////////////////////////////////  INCLUDES
/////////////////////////////////////////////////////  DEFINES

#ifdef DEBUG

// Dump flags used in g_uDumpFlags
//
#define DF_RECLIST      0x0001
#define DF_RECITEM      0x0002
#define DF_RECNODE      0x0004
#define DF_CREATETWIN   0x0008
#define DF_ATOMS        0x0010
#define DF_CRL          0x0020
#define DF_CBS          0x0040
#define DF_CPATH        0x0080
#define DF_PATHS        0x0100
#define DF_UPDATECOUNT  0x0200
#define DF_TWINPAIR     0x0400
#define DF_FOLDERTWIN   0x0800
#define DF_CHOOSESIDE   0x1000

// Break flags used in g_uBreakFlags
//
#define BF_ONOPEN       0x0001
#define BF_ONCLOSE      0x0002
#define BF_ONRUNONCE    0x0004
#define BF_ONVALIDATE   0x0010
#define BF_ONTHREADATT  0x0100
#define BF_ONTHREADDET  0x0200
#define BF_ONPROCESSATT 0x0400
#define BF_ONPROCESSDET 0x0800

#endif

// Trace flags used in g_uTraceFlags (defined in retail on purpose)
//
#define TF_ALWAYS       0x0000
#define TF_WARNING      0x0001
#define TF_ERROR        0x0002
#define TF_GENERAL      0x0004      // Standard briefcase trace messages
#define TF_FUNC         0x0008      // Trace function calls
#define TF_CACHE        0x0010      // Cache-specific trace messages
#define TF_ATOM         0x0020      // Atom-specific trace messages
#define TF_PROGRESS     0x0040      // Progress bar deltas

//---------------------------------------------------------------------------
// HRESULT error codes
//---------------------------------------------------------------------------

// Map a TWINRESULT error value into a HRESULT
// Note: TR_SUCCESS should not be mapped
// Note: This assumes that TWINRESULT errors fall in the range -32k to 32k.
//
#define TR_DELTAVALUE           1000
#define FACILITY_TR             0x018a          // magic number

#define HRESULT_FROM_TR(x)      (TR_SUCCESS == (x) ? NOERROR : \
                                                   ((HRESULT) ((((x) + TR_DELTAVALUE) & 0x0000FFFF) | (FACILITY_TR << 16) | 0x80000000)))
#define IS_ENGINE_ERROR(hr)     IsFlagSet(hr, ((FACILITY_TR << 16) | 0x80000000))
#define GET_TR(hr)              ((TWINRESULT)((hr) & 0x0000FFFF) - TR_DELTAVALUE)

HRESULT PUBLIC MapToOfficialHresult(HRESULT hres);

// SCODE values that correspond to TWINRESULT values
#define E_TR_RH_LOAD_FAILED         MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_RH_LOAD_FAILED)
#define E_TR_SRC_OPEN_FAILED        MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SRC_OPEN_FAILED)
#define E_TR_SRC_READ_FAILED        MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SRC_READ_FAILED)
#define E_TR_DEST_OPEN_FAILED       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DEST_OPEN_FAILED)
#define E_TR_DEST_WRITE_FAILED      MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DEST_WRITE_FAILED)
#define E_TR_ABORT                  MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_ABORT)
#define E_TR_UNAVAILABLE_VOLUME     MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_UNAVAILABLE_VOLUME)
#define E_TR_OUT_OF_MEMORY          MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_OUT_OF_MEMORY)
#define E_TR_FILE_CHANGED           MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_FILE_CHANGED)
#define E_TR_DUPLICATE_TWIN         MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DUPLICATE_TWIN)
#define E_TR_DELETED_TWIN           MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_DELETED_TWIN)
#define E_TR_HAS_FOLDER_TWIN_SRC    MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_HAS_FOLDER_TWIN_SRC)
#define E_TR_INVALID_PARAMETER      MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_INVALID_PARAMETER)
#define E_TR_SAME_FOLDER            MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SAME_FOLDER)
#define E_TR_SUBTREE_CYCLE_FOUND    MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_SUBTREE_CYCLE_FOUND)
#define E_TR_NO_MERGE_HANDLER       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_NO_MERGE_HANDLER)
#define E_TR_MERGE_INCOMPLETE       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_MERGE_INCOMPLETE)
#define E_TR_TOO_DIFFERENT          MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_TOO_DIFFERENT)
#define E_TR_BRIEFCASE_LOCKED       MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_LOCKED)
#define E_TR_BRIEFCASE_OPEN_FAILED  MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_OPEN_FAILED)
#define E_TR_BRIEFCASE_READ_FAILED  MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_READ_FAILED)
#define E_TR_BRIEFCASE_WRITE_FAILED MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_BRIEFCASE_WRITE_FAILED)
#define E_TR_CORRUPT_BRIEFCASE      MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_CORRUPT_BRIEFCASE)
#define E_TR_NEWER_BRIEFCASE        MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_NEWER_BRIEFCASE)
#define E_TR_NO_MORE                MAKE_SCODE(SEVERITY_ERROR, FACILITY_TR, TR_DELTAVALUE + TR_NO_MORE)

/////////////////////////////////////////////////////  MACROS

// Error table for lookup strings.  Usually an array of these
// structures is created and placed in the readonly data segment.
//
typedef struct _SETbl
    {
    HRESULT hres;       // standard result
    UINT    ids;        // String ID of message
    UINT    uStyle;     // MB_ flags
    } SETbl, * PSETBL;

typedef SETbl const *  PCSETBL;

int PUBLIC SEMsgBox(HWND hwnd, UINT idsCaption, SCODE sc, PCSETBL pseTable, UINT cArraySize);


// Retry loop
//
#define RETRY_BEGIN(bInit)      {BOOL bMyRetry; do { bMyRetry = (bInit);
#define RETRY_END()             } while (bMyRetry); }
#define RETRY_SET()             bMyRetry = TRUE
#define RETRY_CLEAR()           bMyRetry = FALSE


// Debugging macros
//

#ifdef DEBUG

#define DEBUG_CASE_STRING(x)    case x: return TEXT( #x )

#define ASSERTSEG

// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR ASSERTSEG sz[] = msg;

void PUBLIC BrfAssertFailed(LPCTSTR szFile, int line);
void CPUBLIC BrfAssertMsg(BOOL f, LPCTSTR pszMsg, ...);
void CPUBLIC BrfDebugMsg(UINT mask, LPCTSTR pszMsg, ...);

// ASSERT(f)  -- Generate "assertion failed in line x of file.c"
//               message if f is NOT true.
//
#define ASSERT(f)                                                       \
    {                                                                   \
        DEBUGTEXT(szFile, TEXT(__FILE__));                              \
        if (!(f))                                                       \
            BrfAssertFailed(szFile, __LINE__);                          \
    }
#define ASSERT_E(f)  ASSERT(f)

// ASSERT_MSG(f, msg, args...)  -- Generate wsprintf-formatted msg w/params
//                          if f is NOT true.
//
#define ASSERT_MSG   BrfAssertMsg

// DEBUG_MSG(mask, msg, args...) - Generate wsprintf-formatted msg using
//                          specified debug mask.  System debug mask
//                          governs whether message is output.
//
#define DEBUG_MSG    BrfDebugMsg
#define TRACE_MSG    DEBUG_MSG

// VERIFYSZ(f, msg, arg)  -- Generate wsprintf-formatted msg w/ 1 param
//                          if f is NOT true 
//
#define VERIFYSZ(f, szFmt, x)   ASSERT_MSG(f, szFmt, x)


// VERIFYSZ2(f, msg, arg1, arg2)  -- Generate wsprintf-formatted msg w/ 2
//                          param if f is NOT true 
//
#define VERIFYSZ2(f, szFmt, x1, x2)   ASSERT_MSG(f, szFmt, x1, x2)



// DBG_ENTER(szFn)  -- Generates a function entry debug spew for
//                          a function 
//
#define DBG_ENTER(szFn)                  \
    TRACE_MSG(TF_FUNC, TEXT(" > ") szFn TEXT("()"))


// DBG_ENTER_SZ(szFn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(szFn, sz)                  \
    TRACE_MSG(TF_FUNC, TEXT(" > ") szFn TEXT("(..., \"%s\",...)"), Dbg_SafeStr(sz))


// DBG_ENTER_DTOBJ(szFn, pdtobj, szBuf)  -- Generates a function entry 
//                          debug spew for a function that accepts a 
//                          string as one of its parameters.
//
#define DBG_ENTER_DTOBJ(szFn, pdtobj, szBuf) \
    TRACE_MSG(TF_FUNC, TEXT(" > ") szFn TEXT("(..., %s,...)"), Dbg_DataObjStr(pdtobj, szBuf))


// DBG_ENTER_RIID(szFn, riid)  -- Generates a function entry debug spew for
//                          a function that accepts an riid as one of its
//                          parameters.
//
#define DBG_ENTER_RIID(szFn, riid)                  \
    TRACE_MSG(TF_FUNC, TEXT(" > ") szFn TEXT("(..., %s,...)"), Dbg_GetRiidName(riid))


// DBG_EXIT(szFn)  -- Generates a function exit debug spew 
//
#define DBG_EXIT(szFn)                              \
        TRACE_MSG(TF_FUNC, TEXT(" < ") szFn TEXT("()"))

// DBG_EXIT_US(szFn, us)  -- Generates a function exit debug spew for
//                          functions that return a USHORT.
//
#define DBG_EXIT_US(szFn, us)                       \
        TRACE_MSG(TF_FUNC, TEXT(" < ") szFn TEXT("() with %#x"), (USHORT)us)

// DBG_EXIT_UL(szFn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#define DBG_EXIT_UL(szFn, ul)                   \
        TRACE_MSG(TF_FUNC, TEXT(" < ") szFn TEXT("() with %#lx"), (ULONG)ul)

// DBG_EXIT_PTR(szFn, pv)  -- Generates a function exit debug spew for
//                          functions that return a pointer.
//
#define DBG_EXIT_PTR(szFn, pv)                   \
        TRACE_MSG(TF_FUNC, TEXT(" < ") szFn TEXT("() with %#lx"), (LPVOID)pv)

// DBG_EXIT_HRES(szFn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(szFn, hres)                   \
        TRACE_MSG(TF_FUNC, TEXT(" < ") szFn TEXT("() with %s"), Dbg_GetScode(hres))


#else

#define ASSERT(f)
#define ASSERT_E(f)      (f)
#define ASSERT_MSG   1 ? (void)0 : (void)
#define DEBUG_MSG    1 ? (void)0 : (void)
#define TRACE_MSG    1 ? (void)0 : (void)

#define VERIFYSZ(f, szFmt, x)     (f)

#define DBG_ENTER(szFn)
#define DBG_ENTER_SZ(szFn, sz)
#define DBG_ENTER_DTOBJ(szFn, pdtobj, sz)
#define DBG_ENTER_RIID(szFn, riid)   

#define DBG_EXIT(szFn)                            
#define DBG_EXIT_US(szFn, us)
#define DBG_EXIT_UL(szFn, ul)
#define DBG_EXIT_PTR(szFn, ptr)                            
#define DBG_EXIT_HRES(szFn, hres)   

#endif

/////////////////////////////////////////////////////  TYPEDEFS

/////////////////////////////////////////////////////  EXPORTED DATA

/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

#ifdef DEBUG

void PUBLIC DEBUG_BREAK(UINT flag);

LPCTSTR PUBLIC Dbg_GetRiidName(REFIID riid);
LPCTSTR PUBLIC Dbg_GetScode(HRESULT hres);
LPCTSTR PUBLIC Dbg_SafeStr(LPCTSTR psz);
LPCTSTR PUBLIC Dbg_DataObjStr(LPDATAOBJECT pdtobj, LPTSTR pszBuf);

#endif

#endif // __ERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\dobj.h ===
//
// dobj.h: Declares data, defines and struct types for RecAct
//          module.
//
//

#ifndef __DOBJ_H__
#define __DOBJ_H__

// DOBJ is the draw object structure for drawing listbox entries
//
// DOBJ kinds
//
#define DOK_ICON        1   // lpvObject is the HICON
#define DOK_STRING      2   // lpvObject is the LPCSTR
#define DOK_BITMAP      3   // lpvObject is the HBITMAP
#define DOK_SIDEITEM    4   // lpvObject points to LPSIDEITEM
#define DOK_IMAGE       5   // 
#define DOK_IDS         6   // lpvObject is the resource ID

// DOBJ item styles
//
#define DOF_LEFT        0x0000
#define DOF_CENTER      0x0001
#define DOF_RIGHT       0x0002
#define DOF_DIFFER      0x0004  // This item's appearance is affected by uState
#define DOF_MENU        0x0008  // Use menu colors
#define DOF_DISABLED    0x0010
#define DOF_IGNORESEL   0x0020  // Ignore selection state
#define DOF_USEIDS      0x0040  // lpvObject is a resource string ID
#define DOF_NODRAW      0x1000  // Don't draw 

typedef struct tagDOBJ
    {
    UINT    uKind;          // One of DOK_* ordinals
    UINT    uFlags;         // One of DOF_* styles
    LPVOID  lpvObject;      // ptr or handle
    HIMAGELIST himl;        // 
    int     iImage;         // 
    int     x;
    int     y;
    RECT    rcBounding;     // Bounding rect of entire object
    union 
        {
        RECT rcSrc;         // DOK_BITMAP: source rect to blt from
        RECT rcClip;        // Clipping rect
        RECT rcLabel;       // Clipping rect for label
        };

    } DOBJ,  * LPDOBJ;


void PUBLIC Dobj_Draw(HDC hdc, LPDOBJ pdobj, int cItems, UINT uState, int cxEllipses, int cyText, COLORREF clrBkgnd);

void PUBLIC ComputeImageRects(LPCTSTR psz, HDC hdc, LPPOINT ppt, LPRECT prcIcon, LPRECT prcLabel, int cxIcon, int cyIcon, int cxIconSpacing, int cyText);

#endif // __DOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\dobj.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: dobj.c
//
//  This file contains support routines for the reconciliation-action 
//   control class code
//
//
// History:
//  09-13-93 ScottH     Extracted from recact.c
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers
#include "res.h"
#include "recact.h"
#include "dobj.h"

/////////////////////////////////////////////////////  CONTROLLING DEFINES


/////////////////////////////////////////////////////  DEFINES

#define DT_CALCWRAP     (DT_CALCRECT | DT_CENTER | DT_WORDBREAK | DT_NOPREFIX)
#define DT_CALC         (DT_CALCRECT | DT_CENTER | DT_SINGLELINE | DT_NOPREFIX)

/*----------------------------------------------------------
Purpose: Formats the given path to the correct location format
Returns: --
Cond:    --
*/
void PRIVATE FormatLocationPath(
    LPCTSTR pszPath,
    LPTSTR pszBuffer)        // Must be MAX_PATH
    {
    UINT ids;
    TCHAR szBrfDir[MAX_PATH];
    LPCTSTR psz;
    LPTSTR pszMsg;

    //  The format for the directory location is:
    //
    //      Inside briefcase:       "In Briefcase"
    //      Below briefcase:        "In Briefcase\FolderName"
    //      Outside briefcase:      "In FullPath"
    //
    // We assume that paths outside the current briefcase
    //  never consist of a briefcase name of another.
    //
    if (PathGetLocality(pszPath, szBrfDir) != PL_FALSE)
        {
        // Inside the briefcase
        psz = &pszPath[lstrlen(szBrfDir)];
        ids = IDS_InBriefcase;
        }
    else
        {
        // Outside the briefcase
        psz = pszPath;
        ids = IDS_InLocation;
        }

    if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(ids), psz))
        {
        lstrcpy(pszBuffer, pszMsg);
        GFree(pszMsg);
        }
    else
        *pszBuffer = 0;
    }


/*----------------------------------------------------------
Purpose: Return the string describing the status of this sideitem
Returns: ptr to status string
Cond:    --
*/
LPTSTR PRIVATE SideItem_GetStatus(
    LPSIDEITEM this,
    LPTSTR pszBuf,
    UINT cchBuf)
    {
    switch (this->uState)
        {
    case SI_CHANGED:
        return SzFromIDS(IDS_STATE_Changed, pszBuf, cchBuf);
    case SI_UNCHANGED:
        return SzFromIDS(IDS_STATE_Unchanged, pszBuf, cchBuf);
    case SI_NEW:
        return SzFromIDS(IDS_STATE_NewFile, pszBuf, cchBuf);
    case SI_UNAVAILABLE:
        return SzFromIDS(IDS_STATE_Unavailable, pszBuf, cchBuf);
    case SI_NOEXIST:
        return SzFromIDS(IDS_STATE_DoesNotExist, pszBuf, cchBuf);
    case SI_DELETED:
        return SzFromIDS(IDS_STATE_Deleted, pszBuf, cchBuf);
    default:
        ASSERT(0);
        return NULL;
        }
    }


/*----------------------------------------------------------
Purpose: Displays the 3-liner: location, status, and timestamp
Returns: --
Cond:    --
*/
void PRIVATE SideItem_Display(
    LPSIDEITEM this,
    HDC hdc,
    LPRECT prc,
    int cxEllipses,
    int cyText)
    {
    TCHAR sz[MAX_PATH];
    TCHAR szBuf[MAXBUFLEN];
    LPTSTR psz;
    RECT rc = *prc;

    // Directory location.  

    FormatLocationPath(this->pszDir, sz);
    MyDrawText(hdc, sz, &rc, MDT_LEFT | MDT_TRANSPARENT | MDT_ELLIPSES, 
        cyText, cxEllipses, CLR_DEFAULT, CLR_DEFAULT);

    // Status string
    psz = SideItem_GetStatus(this, szBuf, ARRAYSIZE(szBuf));
    if (psz)
        {
        // Only bother with these two lines if the file actually
        // exists.

        rc.top += cyText;
        MyDrawText(hdc, psz, &rc, MDT_LEFT | MDT_TRANSPARENT, 
            cyText, cxEllipses, CLR_DEFAULT, CLR_DEFAULT);

        // Date stamp.  Skip this if this is a folder or unavailable.
        //
        if (SI_DELETED != this->uState && 
            SI_NOEXIST != this->uState &&
            SI_UNAVAILABLE != this->uState &&
            FS_COND_UNAVAILABLE != this->fs.fscond) // hack for folders
            {
            FileTimeToDateTimeString(&this->fs.ftMod, sz, ARRAYSIZE(sz));

            rc.top += cyText;
            MyDrawText(hdc, sz, &rc, MDT_LEFT | MDT_TRANSPARENT, 
                cyText, cxEllipses, CLR_DEFAULT, CLR_DEFAULT);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Return the bounding rect for a labelled image.

Returns: --
Cond:    --
*/
void PUBLIC ComputeImageRects(
    LPCTSTR psz,
    HDC hdc,
    LPPOINT pptInOut,       
    LPRECT prcWhole,        // May be NULL
    LPRECT prcLabel,        // May be NULL
    int cxIcon,
    int cyIcon,
    int cxIconSpacing,
    int cyText)
    {
    RECT rc;
    int yLabel;
    int cxLabel;
    int cyLabel;
    int cchLabel;
    POINT pt;

    ASSERT(psz);

    // Set our minimum rect size for icon spacing
    if (cxIconSpacing < cxIcon)
        cxIconSpacing = cxIcon + g_cxIconMargin * 2;

    // Upon entry, *pptInOut is expected to be the upper left corner of the 
    // icon-spacing rect.  This function will set it to the upper left
    // corner of the icon itself.

    pt.x = pptInOut->x + (cxIconSpacing - cxIcon) / 2;
    pt.y = pptInOut->y + g_cyIconMargin;

    // Determine rectangle of label with wrap

    rc.left = rc.top = rc.bottom = 0;
    rc.right = cxIconSpacing - g_cxLabelMargin * 2;

    cchLabel = lstrlen(psz);
    if (0 < cchLabel)
        {
        DrawText(hdc, psz, cchLabel, &rc, DT_CALCWRAP);
        }
    else
        {
        rc.bottom = rc.top + cyText;
        }

    yLabel = pptInOut->y + g_cyIconMargin + cyIcon + g_cyLabelSpace;
    cxLabel = (rc.right - rc.left) + 2 * g_cxLabelMargin;
    cyLabel = rc.bottom - rc.top;

    if (prcWhole)
        {
        prcWhole->left   = pptInOut->x;
        prcWhole->right  = prcWhole->left + cxIconSpacing;
        prcWhole->top    = pptInOut->y;
        prcWhole->bottom = max(prcWhole->top + g_cyIconSpacing,
                            yLabel + cyLabel + g_cyLabelSpace);
        }

    if (prcLabel)
        {
        prcLabel->left = pptInOut->x + ((cxIconSpacing - cxLabel) / 2);
        prcLabel->right = prcLabel->left + cxLabel;
        prcLabel->top = yLabel;
        prcLabel->bottom = prcLabel->top + cyLabel;
        }

    *pptInOut = pt;
    }


/*----------------------------------------------------------
Purpose: Set the colors for the given HDC.  The previous colors
          are stored in pcrText and pcrBk.

Returns: uStyle to pass to ImageList_Draw (specific to images only)
Cond:    --
*/
UINT PRIVATE Dobj_SetColors(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    COLORREF clrBkgnd)
    {
    COLORREF clrText;
    COLORREF clrBk;
    UINT uStyleILD = ILD_NORMAL;
    BOOL bSetColors = FALSE;
    BOOL bDiffer;
    BOOL bMenu;
    BOOL bDisabled;

    // Determine selection colors
    //
    bDiffer = IsFlagSet(this->uFlags, DOF_DIFFER);
    bMenu = IsFlagSet(this->uFlags, DOF_MENU);
    bDisabled = IsFlagSet(this->uFlags, DOF_DISABLED);

    switch (this->uKind)
        {
    case DOK_STRING:
    case DOK_IDS:
    case DOK_SIDEITEM:
        bSetColors = TRUE;
        break;
        }
    
    // Set the text and background colors
    //
    if (bSetColors)
        {
        if (bDiffer)
            {
            // Make the colors differ based on selection state
            //
            if (bMenu)
                {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(ColorMenuText(uState));

                clrBk = GetSysColor(ColorMenuBk(uState));
                }
            else
                {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(ColorText(uState));

                clrBk = GetSysColor(ColorBk(uState));
                }
            }
        else
            {
            // Transparent colors
            //
            if (bMenu)
                {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(COLOR_MENUTEXT);

                clrBk = GetSysColor(COLOR_MENU);
                }
            else
                {
                if (bDisabled)
                    clrText = GetSysColor(COLOR_GRAYTEXT);
                else
                    clrText = GetSysColor(COLOR_WINDOWTEXT);

                clrBk = clrBkgnd;
                }
            }
        SetTextColor(hdc, clrText);
        SetBkColor(hdc, clrBk);
        }

    return uStyleILD;
    }


/*----------------------------------------------------------
Purpose: Draw the menu image and text
Returns: --
Cond:    --
*/
void PRIVATE Dobj_DrawMenuImage(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    int cyText,
    COLORREF clrBkgnd)
    {
    UINT uStyleILD;
    UINT uFlagsETO;
    LPCTSTR psz;
    TCHAR szIDS[MAXBUFLEN];
    int cch;
    HIMAGELIST himl = this->himl;
    COLORREF clrText;
    COLORREF clrBk;
    int x;
    int y;
    int cxIcon;
    RECT rc;

    if (IsFlagSet(this->uFlags, DOF_USEIDS))
        psz = SzFromIDS((UINT)this->lpvObject, szIDS, ARRAYSIZE(szIDS));
    else
        psz = (LPCTSTR)this->lpvObject;

    ASSERT(psz);

    cch = lstrlen(psz);
    ImageList_GetImageRect(himl, this->iImage, &rc);
    cxIcon = rc.right-rc.left;

    // Draw the text first

    uFlagsETO = ETO_OPAQUE | ETO_CLIPPED;
    x = this->rcLabel.left + g_cxMargin + cxIcon + g_cxMargin;
    y = this->rcLabel.top + ((this->rcLabel.bottom - this->rcLabel.top - cyText) / 2);

    if (IsFlagSet(this->uFlags, DOF_DISABLED) && 
        IsFlagClear(uState, ODS_SELECTED))
        {
        int imodeOld;
        COLORREF crOld;

        // For disabled menu strings (not selected), we draw the string 
        // twice.  The first is offset down and to the right and drawn 
        // in the 3D hilight color.  The second time is the disabled text
        // color in the normal offset.
        //
        crOld = SetTextColor(hdc, GetSysColor(COLOR_3DHILIGHT));
        imodeOld = SetBkMode(hdc, TRANSPARENT);
        ExtTextOut(hdc, x+1, y+1, uFlagsETO, &this->rcLabel, psz, cch, NULL);

        // Reset back to original color.  Also, turn off the opaqueness.
        //
        SetTextColor(hdc, crOld);
        uFlagsETO ^= ETO_OPAQUE;
        }

    if (IsFlagSet(this->uFlags, DOF_DISABLED))
        clrText = GetSysColor(COLOR_GRAYTEXT);
    else
        clrText = GetSysColor(ColorMenuText(uState));

    clrBk = GetSysColor(ColorMenuBk(uState));
    SetTextColor(hdc, clrText);
    SetBkColor(hdc, clrBk);

    ExtTextOut(hdc, x, y, uFlagsETO, &this->rcLabel, psz, cch, NULL);

    // Draw the image

    if (GetBkColor(hdc) == ImageList_GetBkColor(himl))
        uStyleILD = ILD_NORMAL;     // Paint quicker
    else
        uStyleILD = ILD_TRANSPARENT;

    ImageList_Draw(himl, this->iImage, hdc, this->x, this->y, uStyleILD);
    }


/*----------------------------------------------------------
Purpose: Draw the icon image and label
Returns: --
Cond:    --
*/
void PRIVATE Dobj_DrawIconImage(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    int cxEllipses,
    int cyText,
    COLORREF clrBkgnd)
    {
    UINT uStyleILD;
    UINT uFlagsMDT;
    LPCTSTR psz;
    TCHAR szIDS[MAXBUFLEN];

    if (IsFlagSet(this->uFlags, DOF_USEIDS))
        psz = SzFromIDS((UINT)this->lpvObject, szIDS, ARRAYSIZE(szIDS));
    else
        psz = (LPCTSTR)this->lpvObject;

    ASSERT(psz);

    // Draw the image
    //
    if (IsFlagClear(this->uFlags, DOF_IGNORESEL))
        {
        uStyleILD = GetImageDrawStyle(uState);
        uFlagsMDT = IsFlagSet(uState, ODS_SELECTED) ? MDT_SELECTED : MDT_DESELECTED;
        }
    else
        {
        uStyleILD = ILD_NORMAL;
        uFlagsMDT = MDT_DESELECTED;
        ClearFlag(uState, ODS_FOCUS);
        }

    ImageList_Draw(this->himl, this->iImage, hdc, this->x, this->y, uStyleILD);

    // Draw the file label.  Wrap if it is long.

    if (this->rcLabel.bottom - this->rcLabel.top > cyText)
        uFlagsMDT |= MDT_DRAWTEXT;
    
    MyDrawText(hdc, psz, &this->rcLabel, MDT_CENTER | uFlagsMDT, cyText, 
        cxEllipses, CLR_DEFAULT, clrBkgnd);

    // (uState may have been changed above)
    if (IsFlagSet(uState, ODS_FOCUS))
        DrawFocusRect(hdc, &this->rcLabel);
    }


#ifdef UNUSED
/*----------------------------------------------------------
Purpose: Draw a picture
Returns: --
Cond:    --
*/
void PRIVATE Dobj_DrawPicture(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    UINT uDrawStyle)
    {
    HIMAGELIST himl;
    HDC hdcMem;
    HBITMAP hbmp;
    BITMAP bm;
    RECT rc;
    int iImage;
    int cx;
    int x;
    int y;

    switch (this->uKind)
        {
    case DOK_BITMAP:
        hbmp = (HBITMAP)(DWORD)this->lpvObject;
        GetObject(hbmp, sizeof(BITMAP), &bm);
        cx = this->rcSrc.right - this->rcSrc.left;
        break;

    case DOK_ICON:
        cx = 32;
        break;
        }

    // We only align horizontally
    //
    y = this->y;
    if (IsFlagSet(this->uFlags, DOF_CENTER))
        x = this->x - (cx / 2);
    else if (IsFlagSet(this->uFlags, DOF_RIGHT))
        x = this->x - cx;
    else
        x = this->x;

    // Draw the object
    //
    switch (this->uKind)
        {
    case DOK_ICON:
        DrawIcon(hdc, x, y, (HICON)(DWORD)this->lpvObject);
        break;

    case DOK_BITMAP:
        hdcMem = CreateCompatibleDC(hdc);
        if (hdcMem)
            {
            SIZE size;

            SelectBitmap(hdcMem, hbmp);
    
            size.cx = this->rcSrc.right - this->rcSrc.left;
            size.cy = this->rcSrc.bottom - this->rcSrc.top;

            if (IsFlagSet(this->uFlags, DOF_MENU) && 
                IsFlagSet(this->uFlags, DOF_DISABLED) && 
                IsFlagClear(uState, ODS_SELECTED))
                {
                COLORREF crOld;
    
                // For disabled menu strings (not selected), we draw the bitmap 
                //  twice.  The first is offset down and to the right and drawn 
                //  in the 3D hilight color.  The second time is the disabled 
                //  color in the normal offset.
                //
                crOld = SetTextColor(hdc, GetSysColor(COLOR_3DHILIGHT));
                BitBlt(hdc, x+1, y+1, size.cx, size.cy, hdcMem, this->rcSrc.left, 
                    this->rcSrc.top,  SRCCOPY);
    
                // Reset back to original color.  Also, turn off the opaqueness.
                //
                SetTextColor(hdc, crOld);
                }

            BitBlt(hdc, x, y, size.cx, size.cy, hdcMem, this->rcSrc.left, this->rcSrc.top,  SRCCOPY);
            DeleteDC(hdcMem);
            }
        break;
        }
    }
#endif

/*----------------------------------------------------------
Purpose: Draw a string
Returns: --
Cond:    --
*/
void PRIVATE Dobj_DrawString(
    LPDOBJ this,
    HDC hdc,
    UINT uState,
    int cxEllipses,
    int cyText)
    {
    UINT ufAlignSav;
                                               
    ASSERT(this);

    // Prep the alignment
    //
    if (this->uFlags & (DOF_LEFT | DOF_CENTER | DOF_RIGHT))
        {
        UINT ufMode;

        ufMode = IsFlagSet(this->uFlags, DOF_CENTER) ? TA_CENTER :
                 (IsFlagSet(this->uFlags, DOF_RIGHT) ? TA_RIGHT : TA_LEFT);
        ufAlignSav = SetTextAlign(hdc, ufMode);
        }

    // Draw the string
    //
    switch (this->uKind)
        {
    case DOK_IDS:
    case DOK_STRING:
        {
        TCHAR szBuf[MAXBUFLEN];
        LPTSTR lpsz;
        UINT uflag = ETO_OPAQUE;

        if (this->uKind == DOK_IDS)
            lpsz = SzFromIDS((UINT)(DWORD)this->lpvObject, szBuf, ARRAYSIZE(szBuf));
        else
            lpsz = (LPTSTR)this->lpvObject;

        if (!IsRectEmpty(&this->rcClip))
            uflag |= ETO_CLIPPED;
        
        if (IsFlagSet(this->uFlags, DOF_MENU) && 
            IsFlagSet(this->uFlags, DOF_DISABLED) && 
            IsFlagClear(uState, ODS_SELECTED))
            {
            int imodeOld;
            COLORREF crOld;

            // For disabled menu strings (not selected), we draw the string 
            //  twice.  The first is offset down and to the right and drawn 
            //  in the 3D hilight color.  The second time is the disabled text
            //  color in the normal offset.
            //
            crOld = SetTextColor(hdc, GetSysColor(COLOR_3DHILIGHT));
            imodeOld = SetBkMode(hdc, TRANSPARENT);
            ExtTextOut(hdc, this->x+1, this->y+1, uflag, &this->rcClip, lpsz,
                lstrlen(lpsz), NULL);

            // Reset back to original color.  Also, turn off the opaqueness.
            //
            SetTextColor(hdc, crOld);
            uflag ^= ETO_OPAQUE;
            }

        ExtTextOut(hdc, this->x, this->y, uflag, &this->rcClip, lpsz,
            lstrlen(lpsz), NULL);
        }
        break;

    case DOK_SIDEITEM:
        SideItem_Display((LPSIDEITEM)this->lpvObject, hdc, &this->rcClip, 
            cxEllipses, cyText);
        break;
        }

    // Clean up
    //
    if (this->uFlags & (DOF_LEFT | DOF_CENTER | DOF_RIGHT))
        {
        SetTextAlign(hdc, ufAlignSav);
        }
    }


/*----------------------------------------------------------
Purpose: Draw an object
Returns: --
Cond:    --
*/
void PUBLIC Dobj_Draw(
    HDC hdc,
    LPDOBJ rgdobj,
    int cItems,
    UINT uState,            // ODS_*
    int cxEllipses,
    int cyText,
    COLORREF clrBkgnd)
    {
    UINT uDrawStyle;
    LPDOBJ pdobj;
    int i;

    ASSERT(rgdobj);

    for (i = 0, pdobj = rgdobj; i < cItems; i++, pdobj++)
        {
        if (IsFlagSet(pdobj->uFlags, DOF_NODRAW))
            continue ;
    
        uDrawStyle = Dobj_SetColors(pdobj, hdc, uState, clrBkgnd);

        // Draw the object
        //
        switch (pdobj->uKind)
            {
        case DOK_IMAGE:
            if (IsFlagSet(pdobj->uFlags, DOF_MENU))
                Dobj_DrawMenuImage(pdobj, hdc, uState, cyText, clrBkgnd);
            else
                Dobj_DrawIconImage(pdobj, hdc, uState, cxEllipses, cyText, clrBkgnd);
            break;

#ifdef UNUSED
        case DOK_BITMAP:
        case DOK_ICON:
            Dobj_DrawPicture(pdobj, hdc, uState, uDrawStyle);
            break;
#endif
    
        case DOK_IDS:
        case DOK_STRING:
        case DOK_SIDEITEM:
            Dobj_DrawString(pdobj, hdc, uState, cxEllipses, cyText);
            break;
            }
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\info.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: info.c
//
//  This files contains dialog code for the Info property sheet
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------


#include "brfprv.h"         // common headers
#include <brfcasep.h>

#include "res.h"
#ifdef WINNT
// #include <help.h>
#else
// #include "..\..\..\win\core\inc\help.h"   // help IDs, rogerg commendted out
#endif

#include <help.h>


//---------------------------------------------------------------------------
// INFO dialog struct
//---------------------------------------------------------------------------

// State flags for the INFO dialog
#define IS_ALLTYPES         0x0001
#define IS_INCLUDESUBS      0x0002
#define IS_DENYAPPLY        0x0004
#define IS_CHANGED          0x0008
#define IS_LAST_INCLUDESUBS 0x0010

typedef struct tagINFO
    {
    HWND    hwnd;               // dialog handle
    PPAGEDATA ppagedata;
    PINFODATA pinfodata;
    int     cselPrev;           // previous count of selections
    
    LPTSTR   pszExtListPrev;     // alloc: last saved settings
    UINT    uState;
    BOOL    bInit;
    
    } INFO,  * PINFO;


// Struct for CHANGETWINPROC callback
typedef struct tagCHANGEDATA
    {
    HBRFCASE    hbrf;
    HFOLDERTWIN hft;

    HDPA        hdpaTwins;
    int         idpaTwin;
    HDPA        hdpaFolders;
    int         idpaStart;

    UINT        uState;

    } CHANGEDATA, * PCHANGEDATA;

typedef HRESULT (CALLBACK * CHANGETWINPROC)(PNEWFOLDERTWIN, TWINRESULT, PCHANGEDATA);


// Struct for Info_AddTwins
typedef struct tagADDTWINSDATA
    {
    CHANGETWINPROC pfnCallback;
    HDPA hdpaSortedFolders;
    int idpaStart;
    } ADDTWINSDATA, * PADDTWINSDATA;


#define MAX_EXT_LEN     6       // Length for "*.ext"

#pragma data_seg(DATASEG_READONLY)

static TCHAR const c_szAllFilesExt[] = TEXT(".*");

#pragma data_seg()

// Helper macros

#define Info_StandAlone(this)       ((this)->pinfodata->bStandAlone)

#define Info_GetPtr(hwnd)           (PINFO)GetWindowLong(hwnd, DWL_USER)
#define Info_SetPtr(hwnd, lp)       (PINFO)SetWindowLong(hwnd, DWL_USER, (LONG)(lp))


#pragma data_seg(DATASEG_READONLY)  
SETbl const c_rgseInfo[4] = {       // change in ibrfstg.c too
        { E_TR_OUT_OF_MEMORY, IDS_OOM_ADDFOLDER, MB_ERROR },
        { E_OUTOFMEMORY, IDS_OOM_ADDFOLDER, MB_ERROR },
        { E_TR_UNAVAILABLE_VOLUME, IDS_ERR_ADDFOLDER_UNAVAIL_VOL, MB_RETRYCANCEL | MB_ICONWARNING },
        { E_TR_SUBTREE_CYCLE_FOUND, IDS_ERR_ADD_SUBTREECYCLE, MB_WARNING },
        };
#pragma data_seg()


//---------------------------------------------------------------------------
// Info dialog functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Searches for an occurrence of the given extension
         in the folder twin list.

Returns: TRUE if the extension was found
Cond:    --
*/
BOOL PRIVATE FindExtension(
    PFOLDERTWINLIST pftl,
    LPCTSTR pszExt)
    {
    PCFOLDERTWIN pcft;
    
    for (pcft = pftl->pcftFirst; pcft; pcft = pcft->pcftNext)
        {
        if (IsSzEqual(pszExt, pcft->pcszName))
            {
            return TRUE;       // Found a match!
            }
        }
    return FALSE;
    }


/*---------------------