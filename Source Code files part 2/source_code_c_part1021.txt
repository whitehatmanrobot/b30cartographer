nother node, or it may be RAW.
    //
    if ( m_idxNextPartition == 0 )
    {
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    //
    //  A disk must have at least one NTFS partition in order to be a quorum device.
    //
    m_fIsQuorumCapable = FALSE;
    m_fIsQuorumJoinable = FALSE;

    LOG_STATUS_REPORT_STRING( L"Marking disk %1!ws! as not being quorum capable", ( m_bstrFriendlyName != NULL ) ? m_bstrFriendlyName : m_bstrName, hr );

    //
    //  Enum the partitions and set the quorum capable flag if an NTFS partition is found.
    //
    for ( idx = 0; idx < m_idxNextPartition; idx++ )
    {
        hr = ( ((*m_prgPartitions)[ idx ])->TypeSafeQI( IClusCfgPartitionProperties, &piccpp ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = STHR( piccpp->IsNTFS() );
        if ( hr == S_OK )
        {
            m_fIsQuorumCapable = TRUE;
            m_fIsQuorumJoinable = TRUE;
            m_fIsManaged = TRUE;
            LOG_STATUS_REPORT_STRING( L"Marking disk %1!ws! as being quorum capable", ( m_bstrFriendlyName != NULL ) ? m_bstrFriendlyName : m_bstrName, hr );
            break;
        } // if:

        piccpp->Release();
        piccpp = NULL;
    } // for:

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CPhysicalDisk::CanBeManaged failed. (hr = %#08x)", hr );
    } // if:

    if ( piccpp != NULL )
    {
        piccpp->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::CanBeManaged


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk class -- IClusCfgManagedResourceCfg
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::PreCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::PreCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRESULT                     hr = S_OK;
    IClusCfgResourcePreCreate * pccrpc = NULL;
    BSTR                        bstr = m_bstrFriendlyName != NULL ? m_bstrFriendlyName : m_bstrName;

    hr = THR( punkServicesIn->TypeSafeQI( IClusCfgResourcePreCreate, &pccrpc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccrpc->SetType( (LPCLSID) &RESTYPE_PhysicalDisk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pccrpc->SetClassType( (LPCLSID) &RESCLASSTYPE_StorageDevice ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

#if 0 // test code only
    hr = THR( pccrpc->SetDependency( (LPCLSID) &IID_NULL, dfSHARED ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:
#endif // test code only

Cleanup:

    STATUS_REPORT_STRING( TASKID_Major_Configure_Resources, TASKID_Minor_PhysDisk_PreCreate, IDS_INFO_PHYSDISK_PRECREATE, bstr, hr );

    if ( pccrpc != NULL )
    {
        pccrpc->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::PreCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Create
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Create( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRESULT                     hr = S_OK;
    IClusCfgResourceCreate *    pccrc = NULL;
    BSTR                        bstr = m_bstrFriendlyName != NULL ? m_bstrFriendlyName : m_bstrName;

    hr = THR( punkServicesIn->TypeSafeQI( IClusCfgResourceCreate, &pccrc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( m_dwSignature != 0 )
    {
        hr = THR( pccrc->SetPropertyDWORD( L"Signature", m_dwSignature ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

Cleanup:

    STATUS_REPORT_STRING( TASKID_Major_Configure_Resources, TASKID_Minor_PhysDisk_Create, IDS_INFO_PHYSDISK_CREATE, bstr, hr );

    if ( pccrc != NULL )
    {
        pccrc->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::Create


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::PostCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::PostCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CPhysicalDisk::PostCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::Evict
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CPhysicalDisk::Evict( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CPhysicalDisk::Evict


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CPhysicalDisk class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CPhysicalDisk::HrInit


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk::HrGetPartitionInfo
//
//  Description:
//      Gather the partition information.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrGetPartitionInfo(
      IWbemClassObject *    pDiskIn
    , bool *                pfRetainObjectOut
    )
{
    TraceFunc( "" );
    Assert( pDiskIn != NULL );
    Assert( pfRetainObjectOut != NULL );

    HRESULT                 hr;
    VARIANT                 var;
    VARIANT                 varDiskName;
    WCHAR                   szBuf[ 256 ];
    IEnumWbemClassObject *  pPartitions = NULL;
    IWbemClassObject *      pPartition = NULL;
    ULONG                   ulReturned;
    BSTR                    bstrQuery = NULL;
    BSTR                    bstrWQL = NULL;
    DWORD                   c;

    bstrWQL = TraceSysAllocString( L"WQL" );
    if ( bstrWQL == NULL )
    {
        goto OutOfMemory;
    } // if:

    VariantInit( &var );
    VariantInit( &varDiskName );

    //
    //  Need to enum the partition(s) of this disk to determine if it is booted
    //  bootable.
    //
    hr = THR( HrGetWMIProperty( pDiskIn, L"DeviceID", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    _snwprintf( szBuf,
                ARRAYSIZE( szBuf ),
                L"Associators of {Win32_DiskDrive.DeviceID='%s'} where AssocClass=Win32_DiskDriveToDiskPartition",
                var.bstrVal
                );

    bstrQuery = TraceSysAllocString( szBuf );
    if ( bstrQuery == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( m_pIWbemServices->ExecQuery( bstrWQL, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &pPartitions ) );
    if ( FAILED( hr ) )
    {
        STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_WMI_DiskDrivePartitions_Qry_Failed, IDS_ERROR_WMI_DISKDRIVEPARTITIONS_QRY_FAILED, var.bstrVal, hr );
        goto Cleanup;
    } // if:

    for ( c = 0; ; c++ )
    {
        hr = STHR( pPartitions->Next( WBEM_INFINITE, 1, &pPartition, &ulReturned ) );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            hr = STHR( HrIsPartitionLDM( pPartition ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  If the partition is logical disk manager (LDM)  then we cannot accept this disk therefore cannot manage it.
            //
            if ( hr == S_OK )
            {
                hr = THR( HrGetWMIProperty( pDiskIn, L"Name", VT_BSTR, &varDiskName ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                hr = S_FALSE;
                *pfRetainObjectOut = false;
                STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_Partition_LDM_Disk, IDS_ERROR_LDM_DISK, varDiskName.bstrVal, hr );
                goto Cleanup;
            } // if:

            hr = STHR( HrIsPartitionGPT( pPartition ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            //
            //  If the partition is GPT then we cannot accept this disk therefore cannot manage it.
            //
            if ( hr == S_OK )
            {
                hr = THR( HrGetWMIProperty( pDiskIn, L"Name", VT_BSTR, &varDiskName ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                } // if:

                hr = S_FALSE;
                *pfRetainObjectOut = false;
                STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_Partition_GPT_Disk, IDS_ERROR_GPT_DISK, varDiskName.bstrVal, hr );
                goto Cleanup;
            } // if:

            hr = THR( HrCreatePartitionInfo( pPartition ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            pPartition->Release();
            pPartition = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            break;
        } // else if:
        else
        {
            STATUS_REPORT_STRING( TASKID_Major_Find_Devices, TASKID_Minor_WQL_Partition_Qry_Next_Failed, IDS_ERROR_WQL_QRY_NEXT_FAILED, bstrQuery, hr );
            goto Cleanup;
        } // else:
    } // for:

    //
    //  The enumerator can be empty because we cannot read the partition info from
    //  clustered disks.  If the enumerator was empty retain the S_FALSE, otherwise
    //  return S_OK if count is greater than 0.
    //
    if ( c > 0 )
    {
        hr = S_OK;
    } // if:
    else
    {
        LOG_STATUS_REPORT_STRING( L"The physical disk '%1!ws!' does not have any partitions and will not be managed", var.bstrVal, hr );
        m_fIsManaged = FALSE;
    } // else:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrGetPartitionInfo, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    VariantClear( &var );
    VariantClear( &varDiskName );

    TraceSysFreeString( bstrQuery );
    TraceSysFreeString( bstrWQL );

    if ( pPartition != NULL )
    {
        pPartition->Release();
    } // if:

    if ( pPartitions != NULL )
    {
        pPartitions->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetPartitionInfo


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrAddPartitionToArray
//
//  Description:
//      Add the passed in partition to the array of punks that holds the
//      partitions.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrAddPartitionToArray( IUnknown * punkIn )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;
    IUnknown *  ((*prgpunks)[]) = NULL;

    prgpunks = (IUnknown *((*)[])) TraceReAlloc( m_prgPartitions, sizeof( IUnknown * ) * ( m_idxNextPartition + 1 ), HEAP_ZERO_MEMORY );
    if ( prgpunks == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrAddPartitionToArray, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    m_prgPartitions = prgpunks;

    (*m_prgPartitions)[ m_idxNextPartition++ ] = punkIn;
    punkIn->AddRef();
    m_cPartitions += 1;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrAddPartitionToArray


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrCreatePartitionInfo
//
//  Description:
//      Create a partition info from the passes in WMI partition.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      S_FALSE
//          The file system was not NTFS.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrCreatePartitionInfo( IWbemClassObject * pPartitionIn )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    IUnknown *              punk = NULL;
    IClusCfgSetWbemObject * piccswo = NULL;
    bool                    fRetainObject = true;

    hr = THR( CClusCfgPartitionInfo::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    punk = TraceInterface( L"CClusCfgPartitionInfo", IUnknown, punk, 1 );

    hr = THR( HrSetInitialize( punk, m_picccCallback, m_lcid ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrSetWbemServices( punk, m_pIWbemServices ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( punk->TypeSafeQI( IClusCfgSetWbemObject, &piccswo ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccswo->SetWbemObject( pPartitionIn, &fRetainObject ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( fRetainObject )
    {
        hr = THR( HrAddPartitionToArray( punk ) );
    } // if:

Cleanup:

    if ( piccswo != NULL )
    {
        piccswo->Release();
    } // if:

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::HrCreatePartitionInfo


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrCreateFriendlyName
//
//  Description:
//      Create a cluster friendly name.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrCreateFriendlyName( void )
{
    TraceFunc( "" );
    Assert( m_idxNextPartition > 0 );

    HRESULT                         hr = S_FALSE;
    WCHAR *                         psz = NULL;
    WCHAR *                         pszTmp = NULL;
    DWORD                           cch = 5;        // length of "Disk" plus EOS
    DWORD                           idx;
    IClusCfgPartitionProperties *   piccpp = NULL;
    BSTR                            bstrName = NULL;
    bool                            fFoundLogicalDisk = false;
    BSTR                            bstr = NULL;

    if ( m_idxNextPartition == 0 )
    {
        goto Cleanup;
    } // if:

    psz = (WCHAR * ) TraceAlloc( HEAP_ZERO_MEMORY, sizeof( WCHAR ) * cch );
    if ( psz == NULL )
    {
        goto OutOfMemory;
    } // if:

    wcscpy( psz, L"Disk" );

    for ( idx = 0; idx < m_idxNextPartition; idx++ )
    {
        hr = THR( ((*m_prgPartitions)[ idx ])->TypeSafeQI( IClusCfgPartitionProperties, &piccpp ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        hr = STHR( piccpp->GetFriendlyName( &bstrName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        if ( hr == S_FALSE )
        {
            continue;
        } // if:

        fFoundLogicalDisk = true;

        cch += ( UINT ) wcslen( bstrName ) + 1;

        pszTmp = (WCHAR * ) TraceReAlloc( psz, sizeof( WCHAR ) * cch, HEAP_ZERO_MEMORY );
        if ( pszTmp == NULL )
        {
            goto OutOfMemory;
        } // if:

        psz = pszTmp;
        pszTmp = NULL;

        wcscat( psz, bstrName );

        TraceSysFreeString( bstrName );
        bstrName = NULL;

        piccpp->Release();
        piccpp = NULL;
    } // for:

    //
    //  KB: 31-JUL-2000
    //
    //  If we didn't find any logical disk IDs then we don't want
    //  to touch m_bstrFriendlyName.
    //
    if ( !fFoundLogicalDisk )
    {
        hr = S_OK;                          // ensure that that the caller doesn't fail since this is not a fatal error...
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( psz );
    if ( bstr == NULL )
    {
        goto OutOfMemory;
    } // if:

    TraceSysFreeString( m_bstrFriendlyName );
    m_bstrFriendlyName = bstr;

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrCreateFriendlyName_VOID, IDS_ERROR_OUTOFMEMORY, hr );

Cleanup:

    if ( piccpp != NULL )
    {
        piccpp->Release();
    } // if:

    if ( psz != NULL )
    {
        TraceFree( psz );
    } // if:

    if ( pszTmp != NULL )
    {
        free( pszTmp );
    } // if:

    TraceSysFreeString( bstrName );

    HRETURN( hr );

} //*** CPhysicalDisk::HrCreateFriendlyName


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrCreateFriendlyName
//
//  Description:
//      Convert the WMI disk name into a more freindly version.
//      Create a cluster friendly name.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrCreateFriendlyName( BSTR bstrNameIn )
{
    TraceFunc1( "bstrNameIn = '%ws'", bstrNameIn == NULL ? L"<null>" : bstrNameIn );

    HRESULT hr = S_OK;
    WCHAR * psz = NULL;
    BSTR    bstr = NULL;

    //
    //  KB: 27-JUN-2000 GalenB
    //
    //  Disk names in WMI start with "\\.\".  As a better and easy
    //  friendly name I am just going to trim these leading chars
    //  off.
    //
    psz = bstrNameIn + wcslen( L"\\\\.\\" );

    bstr = TraceSysAllocString( psz );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_HrCreateFriendlyName_BSTR, IDS_ERROR_OUTOFMEMORY, hr );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrFriendlyName );
    m_bstrFriendlyName = bstr;

Cleanup:

    HRETURN( hr );

} //*** CPhysicalDisk::HrCreateFriendlyName


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrIsPartitionGPT
//
//  Description:
//      Is the passed in partition a GPT partition.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          The partition is a GPT partition.
//
//      S_FALSE
//          The partition is not GPT.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      If the type property of a Win32_DiskPartition starts with "GPT"
//      then the whole spindle has GPT partitions.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrIsPartitionGPT( IWbemClassObject * pPartitionIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    VARIANT var;
    WCHAR   szData[ 4 ];
    BSTR    bstrGPT = NULL;

    VariantInit( &var );

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_GPT, &bstrGPT ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetWMIProperty( pPartitionIn, L"Type", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    //  Get the fist three characters.  When the spindle has GPT partitions then
    //  these characters will be "GPT".  I am unsure if this will be localized?
    //
    wcsncpy( szData, var.bstrVal, ARRAYSIZE( szData ) - 1 );
    szData[ 3 ] = UNICODE_NULL;

    CharUpper( szData );

    if ( wcscmp( szData, bstrGPT ) != 0 )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    VariantClear( &var );

    TraceSysFreeString( bstrGPT );

    HRETURN( hr );

} //*** CPhysicalDisk::HrIsPartitionGPT


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrIsPartitionLDM
//
//  Description:
//      Is the passed in partition an LDM partition.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          The partition is an LDM partition.
//
//      S_FALSE
//          The partition is not LDM.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//      If the type property of a Win32_DiskPartition is "logical disk
//      manager" then this disk is an LDM disk.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrIsPartitionLDM( IWbemClassObject * pPartitionIn )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    VARIANT var;
    BSTR    bstrLDM = NULL;

    VariantInit( &var );

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_LDM, &bstrLDM ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrGetWMIProperty( pPartitionIn, L"Type", VT_BSTR, &var ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    CharUpper( var.bstrVal );

    if ( wcscmp( var.bstrVal, bstrLDM ) != 0 )
    {
        hr = S_FALSE;
    } // if:

Cleanup:

    VariantClear( &var );

    TraceSysFreeString( bstrLDM );

    HRETURN( hr );

} //*** CPhysicalDisk::HrIsPartitionLDM


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrGetDiskFirmwareSerialNumber
//
//  Description:
//      Get the disk firmware serial number.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      S_FALSE
//          There wasn't a firmware serial number.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrGetDiskFirmwareSerialNumber( void )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    HANDLE                      hVolume = NULL;
    DWORD                       dwSize;
    DWORD                       sc;
    STORAGE_PROPERTY_QUERY      spq;
    BOOL                        fRet;
    PSTORAGE_DEVICE_DESCRIPTOR  pddBuffer = NULL;
    DWORD                       cbBuffer;
    PCHAR                       psz = NULL;

    //
    // get handle to disk
    //
    hVolume = CreateFile(
                          m_bstrDeviceID
                        , GENERIC_READ
                        , FILE_SHARE_READ
                        , NULL
                        , OPEN_EXISTING
                        , FILE_ATTRIBUTE_NORMAL
                        , NULL
                        );
    if ( hVolume == INVALID_HANDLE_VALUE )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    cbBuffer = sizeof( STORAGE_DEVICE_DESCRIPTOR) + 2048;

    pddBuffer = (PSTORAGE_DEVICE_DESCRIPTOR ) TraceAlloc( 0, cbBuffer );
    if ( pddBuffer == NULL )
    {
        goto OutOfMemory;
    } // if:

    ZeroMemory( pddBuffer, cbBuffer );
    ZeroMemory( &spq, sizeof( spq ) );

    spq.PropertyId = StorageDeviceProperty;
    spq.QueryType  = PropertyStandardQuery;

    //
    // issue storage class ioctl to get the disk's firmware serial number.
    //

    fRet = DeviceIoControl(
                          hVolume
                        , IOCTL_STORAGE_QUERY_PROPERTY
                        , &spq
                        , sizeof( spq )
                        , pddBuffer
                        , cbBuffer
                        , &dwSize
                        , NULL
                           );
    if ( !fRet )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( dwSize > 0 )
    {
        //
        //  Ensure that there is a serial number offset and that it is within the buffer extents.
        //
        if ( ( pddBuffer->SerialNumberOffset == 0 ) || ( pddBuffer->SerialNumberOffset > pddBuffer->Size ) )
        {
            LOG_STATUS_REPORT_STRING( L"The disk '%1!ws!' does not have a firmware serial number.", m_bstrDeviceID, hr );
            hr = S_FALSE;
            goto Cleanup;
        } // if:

        //
        //  Serial number string is a zero terminated ASCII string.

        //
        //  The header ntddstor.h says the for devices with no serial number,
        //  the offset will be zero.  This doesn't seem to be TRUE.
        //
        //  For devices with no serial number, it looks like a string with a single
        //  null character '\0' is returned.
        //

        psz = (PCHAR) pddBuffer + (DWORD) pddBuffer->SerialNumberOffset;

        hr = THR( HrAnsiStringToBSTR( psz, &m_bstrFirmwareSerialNumber ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        LOG_STATUS_REPORT_STRING3(
              L"Disk '%1!ws!' has firmware serial number '%2!ws!' at offset '%3!#08x!'."
            , m_bstrDeviceID
            , m_bstrFirmwareSerialNumber
            , pddBuffer->SerialNumberOffset
            , hr
            );
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    LogMsg( L"[SRV] HrGetDiskFirmwareSerialNumber() is out of memory. (hr = %#08x)", hr );

Cleanup:

    if ( hVolume != NULL )
    {
        CloseHandle( hVolume );
    } // if:

    TraceFree( pddBuffer );

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetDiskFirmwareSerialNumber


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrGetDiskFirmwareVitalData
//
//  Description:
//      Get the disk firmware vital data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      S_FALSE
//          There wasn't a firmware serial number.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrGetDiskFirmwareVitalData( void )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    HANDLE                          hVolume = NULL;
    DWORD                           dwSize;
    DWORD                           sc;
    STORAGE_PROPERTY_QUERY          spq;
    BOOL                            fRet;
    PSTORAGE_DEVICE_ID_DESCRIPTOR   psdidBuffer = NULL;
    DWORD                           cbBuffer;

    //
    // get handle to disk
    //
    hVolume = CreateFile(
                          m_bstrDeviceID
                        , GENERIC_READ
                        , FILE_SHARE_READ
                        , NULL
                        , OPEN_EXISTING
                        , FILE_ATTRIBUTE_NORMAL
                        , NULL
                        );
    if ( hVolume == INVALID_HANDLE_VALUE )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    cbBuffer = sizeof( STORAGE_DEVICE_ID_DESCRIPTOR ) + 2048;

    psdidBuffer = (PSTORAGE_DEVICE_ID_DESCRIPTOR) TraceAlloc( 0, cbBuffer );
    if ( psdidBuffer == NULL )
    {
        goto OutOfMemory;
    } // if:

    ZeroMemory( psdidBuffer, cbBuffer );
    ZeroMemory( &spq, sizeof( spq ) );

    spq.PropertyId = StorageDeviceIdProperty;
    spq.QueryType  = PropertyStandardQuery;

    //
    // issue storage class ioctl to get the disk's firmware vital data
    //

    fRet = DeviceIoControl(
                          hVolume
                        , IOCTL_STORAGE_QUERY_PROPERTY
                        , &spq
                        , sizeof( spq )
                        , psdidBuffer
                        , cbBuffer
                        , &dwSize
                        , NULL
                           );
    if ( !fRet )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    if ( dwSize > 0 )
    {
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    LogMsg( L"[SRV] HrGetDiskFirmwareVitalData() is out of memory. (hr = %#08x)", hr );

Cleanup:

    if ( hVolume != NULL )
    {
        CloseHandle( hVolume );
    } // if:

    TraceFree( psdidBuffer );

    HRETURN( hr );

} //*** CPhysicalDisk::HrGetDiskFirmwareVitalData


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysicalDisk:HrIsClusterCapable
//
//  Description:
//      Is this disk cluster capable?
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          The disk is cluster capable.
//
//      S_FALSE
//          The disk is not cluster capable.
//
//      E_OUTOFMEMORY
//          Couldn't allocate memeory.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CPhysicalDisk::HrIsClusterCapable( void )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    HANDLE  hVolume = NULL;
    DWORD   dwSize;
    DWORD   sc;
    BOOL    fRet;

    //
    // get handle to disk
    //
    hVolume = CreateFile(
                          m_bstrDeviceID
                        , GENERIC_READ
                        , FILE_SHARE_READ
                        , NULL
                        , OPEN_EXISTING
                        , FILE_ATTRIBUTE_NORMAL
                        , NULL
                        );
    if ( hVolume == INVALID_HANDLE_VALUE )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    //
    // issue cluster storage ioctl to determine whether the disk is cluster capable
    //
    fRet = DeviceIoControl(
                          hVolume
                        , IOCTL_DISK_CLUSTER_NOT_CLUSTER_CAPABLE
                        , NULL
                        , 0
                        , NULL
                        , 0
                        , &dwSize
                        , NULL
                        );
    if ( !fRet )
    {
        hr = S_OK;
    } // if:

Cleanup:

    if ( hVolume != NULL )
    {
        CloseHandle( hVolume );
    } // if:

    HRETURN( hr );

} //*** CPhysicalDisk::HrIsClusterCapable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cmajoritynodeset.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      CMajorityNodeSet.cpp
//
//  Description:
//      This file contains the definition of the CMajorityNodeSet class.
//
//      The class CMajorityNodeSet represents a cluster manageable
//      device. It implements the IClusCfgManagedResourceInfo interface.
//
//  Documentation:
//
//  Header File:
//      CMajorityNodeSet.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 13-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CMajorityNodeSet.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CMajorityNodeSet" );

#define MAJORITY_NODE_SET L"Majority Node Set"


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet class
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::S_HrCreateInstance
//
//  Description:
//      Create a CMajorityNodeSet instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CMajorityNodeSet instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CMajorityNodeSet::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr;
    CMajorityNodeSet *     lpccs = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    lpccs = new CMajorityNodeSet();
    if ( lpccs == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if: error allocating object

    hr = THR( lpccs->HrInit() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: HrInit() failed

    hr = THR( lpccs->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] CMajorityNodeSet::S_HrCreateInstance() failed. (hr = %#08x)", hr );
    } // if:

    if ( lpccs != NULL )
    {
        lpccs->Release();
    } // if:

    HRETURN( hr );

} //*** CMajorityNodeSet::S_HrCreateInstance


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet class -- Private Methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::CMajorityNodeSet
//
//  Description:
//      Constructor of the CMajorityNodeSet class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CMajorityNodeSet::CMajorityNodeSet( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    Assert( m_lcid == 0 );
    Assert( m_picccCallback == NULL );
    Assert( !m_fIsQuorum );
    Assert( !m_fIsJoinable );
    Assert( !m_fIsManaged );
    Assert( m_bstrName == NULL );

    TraceFuncExit();

} //*** CMajorityNodeSet::CMajorityNodeSet


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::~CMajorityNodeSet
//
//  Description:
//      Desstructor of the CMajorityNodeSet class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CMajorityNodeSet::~CMajorityNodeSet( void )
{
    TraceFunc( "" );

    if ( m_picccCallback != NULL )
    {
        m_picccCallback->Release();
    } // if:

    TraceSysFreeString( m_bstrName );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CMajorityNodeSet::~CMajorityNodeSet


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//      None.
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CMajorityNodeSet::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //
    //  BUGBUG: 16-MAR-2001 GalenB
    //
    //  Make this device joinable by default.  Need to figure how to do this
    //  properly.  Depending upon Node Quorum this may be the right way to
    //  do it...
    //

    m_fIsJoinable = TRUE;

    m_bstrName = TraceSysAllocString( MAJORITY_NODE_SET );
    if ( m_bstrName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
    } // if:

    HRETURN( hr );

} //*** CMajorityNodeSet::HrInit


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CMajorityNodeSet:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CMajorityNodeSet::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( & m_cRef );

    RETURN(  m_cRef );

} //*** CMajorityNodeSet::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CMajorityNodeSet:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CMajorityNodeSet::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );
    if ( cRef == 0 )
    {
        TraceDo( delete this );
    } // if: reference count equal to zero

    RETURN( cRef );

} //*** CMajorityNodeSet::Release


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
         *ppv = static_cast< IClusCfgManagedResourceInfo * >( this );
         hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgInitialize ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgInitialize, this, 0 );
        hr   = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IClusCfgManagedResourceCfg ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgManagedResourceCfg, this, 0 );
        hr   = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown *) *ppv)->AddRef( );
    } // if: success

     QIRETURN_IGNORESTDMARSHALLING1( hr, riid, IID_IEnumClusCfgPartitions );

} //*** CMajorityNodeSet::QueryInterface


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet -- IClusCfgInitialize interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::Initialize
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//    IN  IUknown * punkCallbackIn
//
//    IN  LCID      lcidIn
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::Initialize(
    IUnknown *  punkCallbackIn,
    LCID        lcidIn
    )
{
    TraceFunc( "[IClusCfgInitialize]" );
    Assert( m_picccCallback == NULL );

    HRESULT hr = S_OK;

    m_lcid = lcidIn;

    if ( punkCallbackIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    hr = THR( punkCallbackIn->TypeSafeQI( IClusCfgCallback, &m_picccCallback ) );

Cleanup:

    HRETURN( hr );

} //*** CMajorityNodeSet::Initialize


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::GetUID
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrUIDOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_MajorityNodeSet_GetUID_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( MAJORITY_NODE_SET );
    if ( *pbstrUIDOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_MajorityNodeSet_GetUID_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CMajorityNodeSet::GetUID


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::GetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::GetName( BSTR * pbstrNameOut )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
    {
        hr = THR( E_POINTER );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_MajorityNodeSet_GetName_Pointer, IDS_ERROR_NULL_POINTER, hr );
        goto Cleanup;
    } // if:

    *pbstrNameOut = SysAllocString( m_bstrName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        STATUS_REPORT( TASKID_Major_Find_Devices, TASKID_Minor_MajorityNodeSet_GetName_Memory, IDS_ERROR_OUTOFMEMORY, hr );
    } // if:

Cleanup:

    HRETURN( hr );

} //*** CMajorityNodeSet::GetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::SetName
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszNameIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszNameIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrName );
    m_bstrName = bstr;

Cleanup:

    HRETURN( hr );

} //*** CMajorityNodeSet::SetName


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::IsManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is managed.
//
//      S_FALSE
//          The device is not managed.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsManaged )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CMajorityNodeSet::IsManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::SetManaged
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::SetManaged( BOOL fIsManagedIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_fIsManaged = fIsManagedIn;

    HRETURN( S_OK );

} //*** CMajorityNodeSet::SetManaged


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::IsQuorumDevice
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is the quorum device.
//
//      S_FALSE
//          The device is not the quorum device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::IsQuorumDevice( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsQuorum )
    {
        hr = S_OK;
    } // if:

    LOG_STATUS_REPORT_STRING(
                          L"Node quorum '%1!ws!' the quorum device."
                        , m_fIsQuorum ? L"is" : L"is not"
                        , hr
                        );

Cleanup:

    HRETURN( hr );

} //*** CMajorityNodeSet::IsQuorumDevice


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::SetQuorumedDevice
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::SetQuorumedDevice( BOOL fIsQuorumDeviceIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    m_fIsQuorum = fIsQuorumDeviceIn;

    LOG_STATUS_REPORT_STRING(
                          L"Setting node quorum '%1!ws!' the quorum device."
                        , m_fIsQuorum ? L"to be" : L"to not be"
                        , hr
                        );

Cleanup:

    HRETURN( hr );

} //*** CMajorityNodeSet::SetQuorumedDevice


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::IsQuorumCapable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device is a quorum capable device.
//
//      S_FALSE
//          The device is not a quorum capable device.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( S_OK );

} //*** CMajorityNodeSet::IsQuorumCapable


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::GetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_FALSE
//          There are not drive letters on this device.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( S_FALSE );

} //*** CMajorityNodeSet::GetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::SetDriveLetterMappings
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( THR( E_NOTIMPL ) );

} //*** CMajorityNodeSet::SetDriveLetterMappings


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::IsDeviceJoinable
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device allows join.
//
//      S_FALSE
//          The device does not allow join.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::IsDeviceJoinable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( m_fIsJoinable )
    {
        hr = S_OK;
    } // if:

    HRETURN( hr );

} //*** CMajorityNodeSet::IsDeviceJoinable

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::SetDeviceJoinable
//
//  Description:
//      Sets the joinable flag
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The device allows join.
//
//      S_FALSE
//          The device does not allow join.
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::SetDeviceJoinable( BOOL fIsJoinableIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    m_fIsJoinable = fIsJoinableIn;

    HRETURN( S_OK );

} //*** CMajorityNodeSet::IsDeviceJoinable


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CMajorityNodeSet class -- IClusCfgManagedResourceCfg
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::PreCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::PreCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CMajorityNodeSet::PreCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::Create
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::Create( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CMajorityNodeSet::Create


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::PostCreate
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::PostCreate( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CMajorityNodeSet::PostCreate


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CMajorityNodeSet::Evict
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      Win32 error as HRESULT when an error occurs.
//
//  Remarks:
//      This functions should do nothing but return S_OK.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CMajorityNodeSet::Evict( IUnknown * punkServicesIn )
{
    TraceFunc( "[IClusCfgManagedResourceCfg]" );

    HRETURN( S_OK );

} //*** CMajorityNodeSet::Evict
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\privateinterfaces.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      PrivateInterfaces.h
//
//  Description:
//      This file contains the declaration of the private interfaces used in
//      the cluster configuration server.
//
//  Documentation:
//
//  Implementation Files:
//      None.
//
//  Maintained By:
//      Galen Barbee (GalenB) 29-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <ClusApi.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgWbemServices
//
//  Description:
//      The interface IClusCfgWbemServices is the private interface
//      used by the cluster configuration server to set the WBEM provider
//      in its children.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgWbemServices : public IUnknown
{
public:
    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn ) PURE;

}; //*** Class IClusCfgWbemServices


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgDeviceEnums
//
//  Description:
//      The interface IClusCfgDeviceEnums is the private interface
//      used by the cluster configuration server to set the devices and
//      network enums in its children.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgDeviceEnums : public IUnknown
{
public:
    STDMETHOD( SetDevices )( IUnknown * punkEnumStorage, IUnknown * punkEnumNetworks ) PURE;

}; //*** Class IClusCfgDeviceEnums


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgSetWbemObject
//
//  Description:
//      The interface IClusCfgSetWbemObject is the private interface used by the
//      cluster configuration server to set the WBem object.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgSetWbemObject : public IUnknown
{
public:
    STDMETHOD( SetWbemObject )(
              IWbemClassObject *    pObjectIn
            , bool *                pfRetainObjectOut
            ) PURE;

}; //*** Class IClusCfgSetWbemObject


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgSetClusterNodeInfo
//
//  Description:
//      The interface IClusCfgSetClusterNodeInfo is the private
//      interface used by the cluster configuration server to tell the
//      IClusCfgClusterInfo object if this node is part of a cluster.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgSetClusterNodeInfo : public IUnknown
{
public:
    STDMETHOD( SetClusterNodeInfo )( IClusCfgNodeInfo * pNodeInfoIn ) PURE;

}; //*** Class IClusCfgSetClusterNodeInfo


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgSetClusterHandles
//
//  Description:
//      The interface IClusCfgSetClusterHandles is the private
//      interface used by the cluster configuration server to tell the
//      IClusCfgClusterServices object what handles to use.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgSetClusterHandles : public IUnknown
{
public:
    STDMETHOD( SetClusterGroupHandle )( HGROUP hGroupIn ) PURE;

    STDMETHOD( SetClusterHandle )( HCLUSTER hClusterIn ) PURE;

}; //*** Class IClusCfgSetClusterHandles

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgPhysicalDiskProperties
//
//  Description:
//      The interface IClusCfgPhysicalDiskProperties is the private
//      interface used by the cluster configuration server to get the
//      SCSI bus number and whether the disk was booted or not.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgPhysicalDiskProperties : public IUnknown
{
public:
    STDMETHOD( IsThisLogicalDisk )( WCHAR cLogicalDiskIn ) PURE;

    STDMETHOD( HrGetSCSIBus )( ULONG * pulSCSIBusOut ) PURE;

    STDMETHOD( HrGetSCSIPort )( ULONG * pulSCSIPortOut ) PURE;

    STDMETHOD( CanBeManaged )( void ) PURE;

    STDMETHOD( HrGetDeviceID )( BSTR * pbstrDeviceIDOut ) PURE;

    STDMETHOD( HrGetSignature )( DWORD * pdwSignatureOut ) PURE;

    STDMETHOD( HrSetFriendlyName )( LPCWSTR pcszFriendlyNameIn ) PURE;

}; //*** Class IClusCfgPhysicalDiskProperties

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgPartitionProperties
//
//  Description:
//      The interface IClusCfgPartitionProperties is the private
//      interface used by the cluster configuration server to get the
//      properties of a disk partition.
//
//  Interfaces:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgPartitionProperties : public IUnknown
{
public:
    STDMETHOD( IsThisLogicalDisk )( WCHAR cLogicalDiskIn ) PURE;

    STDMETHOD( IsNTFS )( void ) PURE;

    STDMETHOD( GetFriendlyName )( BSTR * pbstrNameOut ) PURE;

}; //*** Class IClusCfgPartitionProperties

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgLoadResource
//
//  Description:
//      The interface IClusCfgLoadResource is the private interface used
//      by the cluster configuration server to get a resource loaded from
//      a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgLoadResource : public IUnknown
{
public:
    STDMETHOD( LoadResource )( HCLUSTER hClusterIn, HRESOURCE hResourceIn ) PURE;

}; //*** Class IClusCfgLoadResource

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgSetPollingCallback
//
//  Description:
//      The interface IClusCfgSetPollingCallback is the private interface used
//      by the cluster configuration server to tell the callback object that
//      it should do polling.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgSetPollingCallback : public IUnknown
{
public:
    STDMETHOD( SetPollingMode )( BOOL fUsePollingModeIn ) PURE;

}; //*** Class IClusCfgSetPollingCallback

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class IClusCfgClusterNetworkInfo
//
//  Description:
//      The interface IClusCfgClusterNetworkInfo is the private interface used
//      by the cluster configuration server to tell whether or not a network
//      is already a cluster network.
//
//--
//////////////////////////////////////////////////////////////////////////////
class IClusCfgClusterNetworkInfo : public IUnknown
{
public:
    STDMETHOD( HrIsClusterNetwork )( void ) PURE;

}; //*** Class IClusCfgClusterNetworkInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING
#endif // DBG==1 || _DEBUG

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <Pragmas.h>
#include <windows.h>
#include <objbase.h>
#include <wchar.h>
#include <ComCat.h>
#include <clusapi.h>

#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <guids.h>
#include <WBemCli.h>

#include <ClusCfgGuids.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>
#include <LoadString.h>
#include "ServerResources.h"
#include "WMIHelpers.h"
#include <StatusReports.h>
#include "ClusCfgServerGuids.h"
#include <ClusCfgConstants.h>
#include <ClusterUtils.h>

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

const HRESULT   E_PROPTYPEMISMATCH = HRESULT_FROM_WIN32( ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH );
const WCHAR     g_szNameSpaceRoot [] = { L"\\\\?\\GLOBALROOT" };

const int       STATUS_CONNECTED = 2;

#define LOG_STATUS_REPORT( _psz_, _hr_ ) \
    { \
        HRESULT _hrTemp_;\
        \
        _hrTemp_ = THR( HrSendStatusReport( \
                            m_picccCallback, \
                            TASKID_Major_Server_Log, \
                            TASKID_Minor_Update_Progress, \
                            0, \
                            1, \
                            1, \
                            _hr_,\
                            _psz_ \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
    }

#define LOG_STATUS_REPORT1( _minor_, _psz_, _hr_ ) \
    { \
        HRESULT _hrTemp_;\
        \
        _hrTemp_ = THR( HrSendStatusReport( \
                            m_picccCallback, \
                            TASKID_Major_Server_Log, \
                            _minor_, \
                            0, \
                            1, \
                            1, \
                            _hr_,\
                            _psz_ \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
    }

#define LOG_STATUS_REPORT_STRING( _pszFormat_, _psz_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( _pszFormat_, &_bstrMsg_, _psz_ ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            goto Cleanup; \
        } \
        \
        _hrTemp_ = THR( HrSendStatusReport( \
                            m_picccCallback, \
                            TASKID_Major_Server_Log, \
                            TASKID_Minor_Update_Progress, \
                            0, \
                            1, \
                            1, \
                            _hr_,\
                            _bstrMsg_ \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define LOG_STATUS_REPORT_STRING2( _pszFormat_, _arg0_, _arg1_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( _pszFormat_, &_bstrMsg_, _arg0_, _arg1_ ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            goto Cleanup; \
        } \
        \
        _hrTemp_ = THR( HrSendStatusReport( \
                            m_picccCallback, \
                            TASKID_Major_Server_Log, \
                            TASKID_Minor_Update_Progress, \
                            0, \
                            1, \
                            1, \
                            _hr_,\
                            _bstrMsg_ \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define LOG_STATUS_REPORT_STRING3( _pszFormat_, _arg0_, _arg1_, _arg2_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( _pszFormat_, &_bstrMsg_, _arg0_, _arg1_, _arg2_ ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            goto Cleanup; \
        } \
        \
        _hrTemp_ = THR( HrSendStatusReport( \
                            m_picccCallback, \
                            TASKID_Major_Server_Log, \
                            TASKID_Minor_Update_Progress, \
                            0, \
                            1, \
                            1, \
                            _hr_,\
                            _bstrMsg_ \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define STATUS_REPORT( _major_, _minor_, _uid_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrLoadStringIntoBSTR( g_hInstance, _uid_, &_bstrMsg_) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            goto Cleanup; \
        } \
        \
        _hrTemp_ = THR( HrSendStatusReport( \
                            m_picccCallback, \
                            _major_, \
                            _minor_, \
                            0, \
                            1, \
                            1, \
                            _hr_,\
                            _bstrMsg_ \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define STATUS_REPORT_STRING( _major_, _minor_, _uid_, _psz_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( g_hInstance, _uid_, &_bstrMsg_, _psz_ ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            goto Cleanup; \
        } \
        \
        _hrTemp_ = THR( HrSendStatusReport( \
                            m_picccCallback, \
                            _major_, \
                            _minor_, \
                            0, \
                            1, \
                            1, \
                            _hr_,\
                            _bstrMsg_ \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }

#define STATUS_REPORT_STRING2( _major_, _minor_, _uid_, _arg0_, _arg1_, _hr_ ) \
    { \
        BSTR    _bstrMsg_ = NULL; \
        HRESULT _hrTemp_; \
        \
        _hrTemp_ = THR( HrFormatStringIntoBSTR( g_hInstance, _uid_, &_bstrMsg_, _arg0_, _arg1_ ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            goto Cleanup; \
        } \
        \
        _hrTemp_ = THR( HrSendStatusReport( \
                            m_picccCallback, \
                            _major_, \
                            _minor_, \
                            0, \
                            1, \
                            1, \
                            _hr_,\
                            _bstrMsg_ \
                            ) ); \
        if ( FAILED( _hrTemp_ ) ) \
        { \
            _hr_ = _hrTemp_; \
        } \
        \
        TraceSysFreeString( _bstrMsg_ ); \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cphysicaldisk.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CPhysicalDisk.h
//
//  Description:
//      This file contains the declaration of the CPhysicalDisk
//      class.
//
//      The class CPhysicalDisk represents a cluster storage
//      device. It implements the IClusCfgManagaedResourceInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CPhysicalDisk.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "PrivateInterfaces.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CPhysicalDisk
//
//  Description:
//      The class CPhysicalDisk represents a cluster storage
//      device.
//
//  Interfaces:
//      IClusCfgManagedResourceInfo
//      IClusCfgWbemServices
//      IClusCfgSetWbemObject
//      IEnumClusCfgPartitions
//      IClusCfgPhysicalDiskProperties
//      IClusCfgManagedResourceCfg
//      IClusCfgInitialize
//--
//////////////////////////////////////////////////////////////////////////////
class CPhysicalDisk
    : public IClusCfgManagedResourceInfo
    , public IClusCfgWbemServices
    , public IClusCfgSetWbemObject
    , public IEnumClusCfgPartitions
    , public IClusCfgPhysicalDiskProperties
    , public IClusCfgManagedResourceCfg
    , public IClusCfgInitialize
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    IWbemServices *     m_pIWbemServices;
    BSTR                m_bstrName;
    BSTR                m_bstrDeviceID;
    BSTR                m_bstrDescription;
    IUnknown *          ((*m_prgPartitions)[]);
    ULONG               m_idxNextPartition;
    ULONG               m_ulSCSIBus;
    ULONG               m_ulSCSITid;
    ULONG               m_ulSCSIPort;
    ULONG               m_ulSCSILun;
    ULONG               m_idxEnumPartitionNext;
    DWORD               m_dwSignature;
    BOOL                m_fIsManaged:1;
    BOOL                m_fIsQuorumDevice:1;
    BOOL                m_fIsQuorumCapable:1;
    BOOL                m_fIsQuorumJoinable:1;
    BSTR                m_bstrFriendlyName;
    BSTR                m_bstrFirmwareSerialNumber;
    DWORD               m_cPartitions;

    // Private constructors and destructors
    CPhysicalDisk( void );
    ~CPhysicalDisk( void );

    // Private copy constructor to prevent copying.
    CPhysicalDisk( const CPhysicalDisk & nodeSrc );

    // Private assignment operator to prevent copying.
    const CPhysicalDisk & operator = ( const CPhysicalDisk & nodeSrc );

    HRESULT HrInit( void );
    HRESULT HrGetPartitionInfo( IWbemClassObject * pDiskIn, bool * pfRetainObjectOut );
    HRESULT HrCreatePartitionInfo( IWbemClassObject * pPartitionIn );
    HRESULT HrAddPartitionToArray( IUnknown * punkIn );
    HRESULT HrCreateFriendlyName( void );
    HRESULT HrCreateFriendlyName( BSTR bstrNameIn );
    HRESULT HrIsPartitionGPT( IWbemClassObject * pPartitionIn );
    HRESULT HrIsPartitionLDM( IWbemClassObject * pPartitionIn );
    HRESULT HrGetDiskFirmwareSerialNumber( void );
    HRESULT HrGetDiskFirmwareVitalData( void );
    HRESULT HrIsClusterCapable( void );

public:
    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    //
    // IUnknown Interface
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgWbemServices Interface
    //

    STDMETHOD( SetWbemServices )( IWbemServices * pIWbemServicesIn );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgSetWbemObject Interface
    //

    STDMETHOD( SetWbemObject )( IWbemClassObject * pDiskIn, bool * pfRetainObjectOut );

    //
    // IClusCfgManagedResourceInfo Interface
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );

    STDMETHOD( IsManaged )( void );

    STDMETHOD( SetManaged )( BOOL fIsManagedIn );

    STDMETHOD( IsQuorumDevice )( void );

    STDMETHOD( SetQuorumedDevice )( BOOL fIsQuorumDeviceIn );

    STDMETHOD( IsQuorumCapable )( void );

    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingOut );

    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappings );

    STDMETHOD( IsDeviceJoinable )( void );

    STDMETHOD( SetDeviceJoinable )( BOOL fIsJoinableIn );

    //
    // IEnumClusCfgPartitions Interface
    //

    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgPartitionInfo ** rgpPartitionInfoOut, ULONG * pcNumberFetchedOut );

    STDMETHOD( Skip )( ULONG cNumberToSkipIn );

    STDMETHOD( Reset )( void );

    STDMETHOD( Clone )( IEnumClusCfgPartitions ** ppEnumClusCfgPartitionsOut );

    STDMETHOD( Count )( DWORD * pnCountOut );

    //
    // IClusCfgPhysicalDiskProperties Interface
    //

    STDMETHOD( IsThisLogicalDisk )( WCHAR cLogicalDiskIn );

    STDMETHOD( HrGetSCSIBus )( ULONG * pulSCSIBusOut );

    STDMETHOD( HrGetSCSIPort )( ULONG * pulSCSIPortOut );

    STDMETHOD( CanBeManaged )( void );

    STDMETHOD( HrGetDeviceID )( BSTR * pbstrDeviceIDOut );

    STDMETHOD( HrGetSignature )( DWORD * pdwSignatureOut );

    STDMETHOD( HrSetFriendlyName )( LPCWSTR pcszFriendlyNameIn );

    //
    //  IClusCfgManagedResourceCfg
    //

    STDMETHOD( PreCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Create )( IUnknown * punkServicesIn );

    STDMETHOD( PostCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Evict )( IUnknown * punkServicesIn );

}; //*** Class CPhysicalDisk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\cunknownquorum.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      CUnknownQuorum.h
//
//  Description:
//      This file contains the declaration of the CUnknownQuorum
//      class.
//
//      The class CUnknownQuorum represents a cluster quorum
//      device. It implements the IClusCfgManagaedResourceInfo interface.
//
//  Documentation:
//
//  Implementation Files:
//      CUnknownQuorum.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 18-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CUnknownQuorum
//
//  Description:
//      The class CUnknownQuorum represents a cluster quorum
//      device.
//
//  Interfaces:
//      IClusCfgManagedResourceInfo
//      IClusCfgInitialize
//--
//////////////////////////////////////////////////////////////////////////////
class CUnknownQuorum
    : public IClusCfgManagedResourceInfo
    , public IClusCfgInitialize
    , public IClusCfgManagedResourceCfg
{
private:

    //
    // Private member functions and data
    //

    LONG                m_cRef;
    LCID                m_lcid;
    IClusCfgCallback *  m_picccCallback;
    BOOL                m_fIsQuorum:1;
    BOOL                m_fIsJoinable:1;
    BOOL                m_fIsManaged:1;
    BSTR                m_bstrName;

    // Private constructors and destructors
    CUnknownQuorum( void );
    ~CUnknownQuorum( void );

    // Private copy constructor to prevent copying.
    CUnknownQuorum( const CUnknownQuorum & nodeSrc );

    // Private assignment operator to prevent copying.
    const CUnknownQuorum & operator = ( const CUnknownQuorum & nodeSrc );

    HRESULT HrInit( LPCWSTR pcszNameIn, BOOL fMakeQuorumIn = FALSE );

public:

    //
    // Public, non interface methods.
    //

    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );

    static HRESULT S_HrCreateInstance( LPCWSTR pcszNameIn, BOOL fMakeQuorumIn, IUnknown ** ppunkOut );

    //
    // IUnknown Interface
    //

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );

    STDMETHOD_( ULONG, AddRef )( void );

    STDMETHOD_( ULONG, Release )( void );

    //
    // IClusCfgInitialize Interfaces
    //

    // Register callbacks, locale id, etc.
    STDMETHOD( Initialize )( IUnknown * punkCallbackIn, LCID lcidIn );

    //
    // IClusCfgManagedResourceInfo Interface
    //

    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );

    STDMETHOD( IsManaged )( void );

    STDMETHOD( SetManaged )( BOOL fIsManagedIn );

    STDMETHOD( IsQuorumDevice )( void );

    STDMETHOD( SetQuorumedDevice )( BOOL fIsQuorumDeviceIn );

    STDMETHOD( IsQuorumCapable )( void );

    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingOut );

    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappings );

    STDMETHOD( IsDeviceJoinable )( void );

    STDMETHOD( SetDeviceJoinable )( BOOL fIsJoinableIn );

    //
    //  IClusCfgManagedResourceCfg
    //

    STDMETHOD( PreCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Create )( IUnknown * punkServicesIn );

    STDMETHOD( PostCreate )( IUnknown * punkServicesIn );

    STDMETHOD( Evict )( IUnknown * punkServicesIn );

}; //*** Class CUnknownQuorum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\test\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <CITrackerSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\serverresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ServerResources.h
//
//  Description:
//      Contains the definition of the string ids used by this library.
//      This file will be included in the main resource header of the project.
//
//  Maintained By:
//      Galen Barbee (GalenB) 28-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

// The starting ID for these strings.
#define ID_CCS_START    4000

/////////////////////////////////////////////////////////////////////
// Strings
/////////////////////////////////////////////////////////////////////

#define IDS_WARNING_NO_IP_ADDRESSES                     ( ID_CCS_START +  1 )
#define IDS_ERROR_NODE_INFO_CREATE                      ( ID_CCS_START +  2 )
#define IDS_ERROR_MANAGED_RESOURCE_ENUM_CREATE          ( ID_CCS_START +  3 )
#define IDS_ERROR_NETWORKS_ENUM_CREATE                  ( ID_CCS_START +  4 )
#define IDS_ERROR_COMMIT_CHANGES                        ( ID_CCS_START +  5 )
#define IDS_ERROR_CLUSTER_NAME_NOT_FOUND                ( ID_CCS_START +  6 )
#define IDS_ERROR_CLUSTER_IP_ADDRESS_NOT_FOUND          ( ID_CCS_START +  7 )
#define IDS_ERROR_CLUSTER_IP_SUBNET_NOT_FOUND           ( ID_CCS_START +  8 )
#define IDS_ERROR_CLUSTER_NETWORKS_NOT_FOUND            ( ID_CCS_START +  9 )
#define IDS_ERROR_WMI_NETWORKADAPTERSETTINGS_QRY_FAILED ( ID_CCS_START + 10 )
#define IDS_ERROR_IP_ADDRESS_SUBNET_COUNT_UNEQUAL       ( ID_CCS_START + 11 )
#define IDS_ERROR_PRIMARY_IP_NOT_FOUND                  ( ID_CCS_START + 12 )
//#define             ( ID_CCS_START + 13 )
//#define             ( ID_CCS_START + 14 )
#define IDS_ERROR_PHYSDISK_SIGNATURE                    ( ID_CCS_START + 15 )
#define IDS_ERROR_NODE_DOWN                             ( ID_CCS_START + 16 )
#define IDS_ERROR_WMI_OS_QRY_FAILED                     ( ID_CCS_START + 17 )
#define IDS_ERROR_PHYSDISK_NO_FILE_SYSTEM               ( ID_CCS_START + 18 )
#define IDS_ERROR_WMI_PAGEFILE_QRY_FAILED               ( ID_CCS_START + 19 )
#define IDS_ERROR_WMI_PHYS_DISKS_QRY_FAILED             ( ID_CCS_START + 20 )
#define IDS_ERROR_PHYSDISK_NOT_NTFS                     ( ID_CCS_START + 21 )
#define IDS_ERROR_WMI_NETWORKADAPTER_QRY_FAILED         ( ID_CCS_START + 22 )
#define IDS_ERROR_WMI_DISKDRIVEPARTITIONS_QRY_FAILED    ( ID_CCS_START + 23 )
#define IDS_ERROR_WBEM_CONNECTION_FAILURE               ( ID_CCS_START + 24 )
#define IDS_WARNING_BOOT_PARTITION_NOT_NTFS             ( ID_CCS_START + 25 )
#define IDS_ERROR_WMI_GET_LOGICALDISK_FAILED            ( ID_CCS_START + 26 )
#define IDS_ERROR_WMI_NETWORKADAPTER_DUPE_FOUND         ( ID_CCS_START + 27 )
#define IDS_WARNING__NON_TCP_CONFIG                     ( ID_CCS_START + 28 )
#define IDS_ERROR_WQL_QRY_NEXT_FAILED                   ( ID_CCS_START + 29 )
#define IDS_WARNING_NO_VALID_TCP_CONFIGS                ( ID_CCS_START + 30 )
#define IDS_ERROR_CONVERT_TO_DOTTED_QUAD_FAILED         ( ID_CCS_START + 31 )
#define IDS_ERROR_NULL_POINTER                          ( ID_CCS_START + 32 )
#define IDS_ERROR_OUTOFMEMORY                           ( ID_CCS_START + 33 )
#define IDS_ERROR_OPEN_CLUSTER_FAILED                   ( ID_CCS_START + 34 )
#define IDS_ERROR_INVALIDARG                            ( ID_CCS_START + 35 )
#define IDS_ERROR_WBEM_LOCATOR_CREATE_FAILED            ( ID_CCS_START + 36 )
#define IDS_ERROR_WBEM_BLANKET_FAILURE                  ( ID_CCS_START + 37 )
#define IDS_ERROR_NETWORK_ENUM                          ( ID_CCS_START + 38 )
#define IDS_WARNING_NETWORK_NOT_CONNECTED               ( ID_CCS_START + 39 )
#define IDS_WARNING_NETWORK_SKIPPED                     ( ID_CCS_START + 40 )
#define IDS_LDM                                         ( ID_CCS_START + 41 )
#define IDS_ERROR_WMI_OS_QRY_NEXT_FAILED                ( ID_CCS_START + 42 )
#define IDS_ERROR_WMI_PAGEFILE_QRY_NEXT_FAILED          ( ID_CCS_START + 43 )
#define IDS_NODE_INFO_CREATE                            ( ID_CCS_START + 44 )
#define IDS_MANAGED_RESOURCE_ENUM_CREATE                ( ID_CCS_START + 45 )
#define IDS_NETWORKS_ENUM_CREATE                        ( ID_CCS_START + 46 )
#define IDS_COMMIT_CHANGES                              ( ID_CCS_START + 47 )
#define IDS_NLBS_SOFT_ADAPTER_NAME                      ( ID_CCS_START + 48 )
#define IDS_WARNING_NLBS_DETECTED                       ( ID_CCS_START + 49 )
#define IDS_VALIDATING_NODE_OS_VERSION                  ( ID_CCS_START + 50 )
//#define                          ( ID_CCS_START + 51 )
#define IDS_INFO_PHYSDISK_PRECREATE                     ( ID_CCS_START + 52 )
#define IDS_INFO_PHYSDISK_CREATE                        ( ID_CCS_START + 53 )
#define IDS_ERROR_GPT_DISK                              ( ID_CCS_START + 54 )
#define IDS_GPT                                         ( ID_CCS_START + 55 )
#define IDS_ERROR_CLUSTER_NETWORK_NOT_FOUND             ( ID_CCS_START + 56 )
#define IDS_INFO_PRUNING_PAGEFILEDISK_BUS               ( ID_CCS_START + 57 )
#define IDS_INFO_PRUNING_BOOTDISK_BUS                   ( ID_CCS_START + 58 )
#define IDS_INFO_PRUNING_SYSTEMDISK_BUS                 ( ID_CCS_START + 59 )
#define IDS_INFO_PAGEFILEDISK_PRUNED                    ( ID_CCS_START + 60 )
#define IDS_INFO_BOOTDISK_PRUNED                        ( ID_CCS_START + 61 )
#define IDS_INFO_SYSTEMDISK_PRUNED                      ( ID_CCS_START + 62 )
//#define                           ( ID_CCS_START + 63 )
#define IDS_WARNING_SERVICES_FOR_MAC_INSTALLED          ( ID_CCS_START + 64 )
#define IDS_ERROR_SERICES_FROM_MAC_FAILED               ( ID_CCS_START + 65 )
#define IDS_ERROR_WIN32                                 ( ID_CCS_START + 66 )
#define IDS_ERROR_NO_NETWORK_NAME                       ( ID_CCS_START + 67 )
#define IDS_ERROR_INVALID_NETWORK_ROLE                  ( ID_CCS_START + 68 )
#define IDS_ERROR_LDM_DISK                              ( ID_CCS_START + 69 )
#define IDS_INFO_PHYSDISK_NOT_CLUSTER_CAPABLE           ( ID_CCS_START + 70 )
#define IDS_ERROR_FOUND_NON_SCSI_DISK                   ( ID_CCS_START + 71 )
#define IDS_WARNING_DHCP_ENABLED                        ( ID_CCS_START + 72 )

/////////////////////////////////////////////////////////////////////
// Notification strings
/////////////////////////////////////////////////////////////////////

#define IDS_NOTIFY_SERVER_INITIALIZED           ( ID_CCS_START + 1000 )


// The ending ID for these strings.
#define ID_CCS_END      5999
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\test\callback.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusCfgCallback.h
//
//  Description:
//      Header file for Callback.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 12-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////


#pragma once


////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the IClusCfgCallback interface
#include "ClusCfgServer.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class Callback
//
//  Description:
//      This class implements the IClusCfgBaseCluster interface.
//
//--
//////////////////////////////////////////////////////////////////////////////
class Callback
    : public IClusCfgCallback
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructor and Destructor
    //////////////////////////////////////////////////////////////////////////

    // Constructor
    Callback( void );

    // Destructor
    ~Callback( void );


    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgCallback methods
    //////////////////////////////////////////////////////////////////////////
    STDMETHOD( SendStatusReport )(
            BSTR        bstrNodeNameIn,
            CLSID       clsidTaskMajorIn,
            CLSID       clsidTaskMinorIn,
            ULONG       ulMinIn,
            ULONG       ulMaxIn,
            ULONG       ulCurrentIn,
            HRESULT     hrStatusIn,
            BSTR        bstrDescriptionIn,
            FILETIME *  pftTimeIn,
            BSTR        bstrReferenceIn
            );

    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

private:
    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Reference count for this object.
    LONG                m_cRef;

}; //*** class Callback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\test\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <DebugSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\test\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "LogSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\test\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <InterfaceTableSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\test\callback.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Callback.cpp
//
//  Description:
//      This file contains the implementation of the Callback
//      class.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Header File:
//      Callback.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 12-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "pch.h"
#include "Callback.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  Callback::Callback()
//
//  Description:
//      Constructor of the Callback class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
Callback::Callback( void )
    : m_cRef( 1 )
{
} //*** Callback::Callback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  Callback::~Callback()
//
//  Description:
//      Destructor of the Callback class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
Callback::~Callback( void )
{
} //*** Callback::~Callback


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  Callback::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a Callback instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface to the newly create object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
Callback::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    Callback *  pccb;
    HRESULT hr;

    pccb = new Callback();
    if ( pccb != NULL )
    {
        hr = pccb->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) );
        pccb->Release( );

    } // if: error allocating object
    else
    {
        hr = E_OUTOFMEMORY;
    } // else: out of memory

    return hr;

} //*** Callback::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  Callback::AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
Callback::AddRef( void )
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;

} //*** Callback::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  Callback::Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
Callback::Release( void )
{
    InterlockedDecrement( &m_cRef );

    if ( m_cRef == 0 )
    {
        delete this;
        return 0;
    } // if: reference count decremented to zero

    return m_cRef;

} //*** Callback::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  Callback::QueryInterface()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
Callback::QueryInterface( REFIID  riid, void ** ppv )
{

    HRESULT hr = S_OK;

    if ( ppv != NULL )
    {
        if ( IsEqualIID( riid, IID_IUnknown ) )
        {
             *ppv = static_cast< IClusCfgCallback * >( this );
        } // if: IUnknown
        else if ( IsEqualIID( riid, IID_IClusCfgCallback ) )
        {
            *ppv = static_cast< IClusCfgCallback * >( this );
        } // else if:
        else
        {
            hr = E_NOINTERFACE;
        } // else

        if ( SUCCEEDED( hr ) )
        {
            ((IUnknown *) *ppv)->AddRef( );
        } // if: success
        else
        {
            *ppv = NULL;
        } // else: something failed

    } // if: the output pointer was valid
    else
    {
        hr = E_INVALIDARG;
    } // else: the output pointer is invalid

    return hr;

} //*** Callback::QueryInterface()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  Callback::SendStatusReport
//
//  Description:
//      Handle a progress notification
//
//  Arguments:
//      bstrNodeNameIn
//          Name of the node that sent the status report.
//
//      clsidTaskMajorIn
//      clsidTaskMinorIn
//          GUID identifying the notification.
//
//      ulMinIn
//      ulMaxIn
//      ulCurrentIn
//          Values that indicate the percentage of this task that is
//          completed.
//
//      hrStatusIn
//          Error code.
//
//      bstrDescriptionIn
//          String describing the notification.
//
//  Return Value:
//      Always
//
//  Exceptions Thrown:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
Callback::SendStatusReport(
      BSTR          bstrNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , BSTR          bstrDescriptionIn
    , FILETIME *    pftTimeIn
    , BSTR          bstrReferenceIn
    ) throw()
{
    wprintf( L"Notification ( %d, %d, %d ) =>\n  '%s' ( Error Code %#X )\n", ulMinIn, ulMaxIn, ulCurrentIn, bstrDescriptionIn, hrStatusIn );

    return S_OK;

} //*** Callback::SendStatusReport()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\wmihelpers.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      WMIHelpers.h
//
//  Description:
//      This file contains the declaration of the WMI helper functions.
//
//  Documentation:
//
//  Implementation Files:
//      WMIHelpers.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 27-Apr-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Function Declarations
//////////////////////////////////////////////////////////////////////////////


HRESULT
HrGetWMIProperty(
    IWbemClassObject *  pWMIObjectIn,
    LPCWSTR             pcszPropertyNameIn,
    ULONG               ulPropertyTypeIn,
    VARIANT *           pVariantOut
    );

HRESULT
HrSetWbemServices(
    IUnknown *      punkIn,
    IWbemServices * pIWbemServicesIn
    );

HRESULT
HrSetInitialize(
    IUnknown *          punkIn,
    IClusCfgCallback *  picccIn,
    LCID                lcidIn
    );

HRESULT
HrCreateNetworksEnum(
    IClusCfgCallback *  picccIn,
    LCID                lcidIn,
    IWbemServices *     pIWbemServicesIn,
    IUnknown **         ppunkOut
    );

HRESULT
HrLoadOperatingSystemInfo(
    IClusCfgCallback *  picccIn,
    IWbemServices *     pIWbemServicesIn,
    BSTR *              pbstrBootDeviceOut,
    BSTR *              pbstrSystemDeviceOut
    );

HRESULT
HrConvertDeviceVolumeToLogicalDisk(
    BSTR    bstrDeviceVolumeIn,
    BSTR *  pbstrLogicalDiskOut
    );

HRESULT
HrConvertDeviceVolumeToWMIDeviceID(
    BSTR    bstrDeviceVolumeIn,
    BSTR *  pbstrWMIDeviceIDOut
    );

HRESULT
HrGetPageFileLogicalDisks(
    IClusCfgCallback *  picccIn,
    IWbemServices *     pIWbemServicesIn,
    WCHAR               szLogicalDisksOut[ 26 ],
    int *               pcLogicalDisksOut
    );

HRESULT
HrGetSystemDevice( BSTR * pbstrSystemDeviceOut );

HRESULT
HrGetBootLogicalDisk( BSTR * pbstrBootDeviceOut );

HRESULT
HrCheckSecurity( void );

#ifdef DEBUG
    void TraceWMIProperties( IWbemClassObject * pDiskIn );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\wmihelpers.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      WmiHelpers.cpp
//
//  Description:
//      This file contains the implementation of WMI help functions.
//
//  Documentation:
//
//  Header File:
//      WmiHelpers.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 27-Apr-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "PrivateInterfaces.h"
#include "CEnumClusCfgNetworks.h"
#include <WinIOCTL.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

const WCHAR g_szPhysicalDriveFormat [] = { L"\\\\.\\PHYSICALDRIVE%lu\0" };


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetWMIProperty
//
//  Description:
//      Get a named property from a WMI object.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The IWbemClassObject param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetWMIProperty(
    IWbemClassObject *  pWMIObjectIn,
    LPCWSTR             pcszPropertyNameIn,
    ULONG               ulPropertyTypeIn,
    VARIANT *           pVariantOut
    )
{
    TraceFunc1( "pcszPropertyNameIn = '%ws'", pcszPropertyNameIn );

    Assert( pWMIObjectIn != NULL );
    Assert( pcszPropertyNameIn != NULL );
    Assert( pVariantOut != NULL );

    HRESULT hr;
    BSTR    bstrProp = NULL;

    VariantClear( pVariantOut );

    bstrProp = TraceSysAllocString( pcszPropertyNameIn );
    if ( bstrProp == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pWMIObjectIn->Get( bstrProp, 0L, pVariantOut, NULL, NULL ) );
    if ( FAILED( hr ) )
    {
        LogMsg( L"[SRV] Could not get the value for WMI property '%ws'. (hr = %#08x)", bstrProp, hr );
        goto Cleanup;
    } // if:

    //
    //  KB: 28-JUN-2000 GalenB
    //
    //  For reasons only known to WMI boolean properties are of type VT_NULL instead of
    //  VT_BOOL when they are not set or false...
    //
    //  KB: 27-JUL-2000 GalenB
    //
    //  Added the special case check for signature.  We know that signature will be NULL
    //  when the spindle is under ClusDisk control...
    //
    if ( ( ulPropertyTypeIn != VT_BOOL ) && ( _wcsicmp( bstrProp, L"Signature" ) != 0 ) )
    {
        if ( pVariantOut->vt != ulPropertyTypeIn )
        {
            LogMsg( L"[SRV] Variant type for WMI Property '%ws' was supposed to be '%d', but was '%d' instead.", pcszPropertyNameIn, ulPropertyTypeIn, pVariantOut->vt );
            hr = THR( E_PROPTYPEMISMATCH );
        } // if:
    } // if:

Cleanup:

    TraceSysFreeString( bstrProp );

    HRETURN( hr );

} //*** HrGetWMIProperty()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSetWbemServices
//
//  Description:
//      Set the WBemServices object into the passed in punk.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The IUnknown param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSetWbemServices( IUnknown * punkIn, IWbemServices * pIWbemServicesIn )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT                 hr;
    IClusCfgWbemServices *  pWbemProvider;

    if ( punkIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Exit;
    } // if:

    hr = punkIn->TypeSafeQI( IClusCfgWbemServices, &pWbemProvider );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( pWbemProvider->SetWbemServices( pIWbemServicesIn ) );
        pWbemProvider->Release();
    } // if:
    else if ( hr == E_NOINTERFACE )
    {
        hr = S_OK;
    } // else if:
    else
    {
        THR( hr );
    }

Exit:

    HRETURN( hr );

} //*** HrSetWbemServices()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrSetInitialize
//
//  Description:
//      Initialize the passed in punk.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The IUnknown param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrSetInitialize(
    IUnknown *          punkIn,
    IClusCfgCallback *  picccIn,
    LCID                lcidIn
    )
{
    TraceFunc( "" );
    Assert( punkIn != NULL );

    HRESULT                 hr;
    IClusCfgInitialize *    pcci;
    IUnknown *              punkCallback = NULL;

    if ( punkIn == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( picccIn != NULL )
    {
        hr = THR( picccIn->TypeSafeQI( IUnknown, &punkCallback ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:
    } // if:

    hr = THR( punkIn->TypeSafeQI( IClusCfgInitialize, &pcci ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = STHR( pcci->Initialize( punkCallback, lcidIn ) );
        pcci->Release();
    } // if:
    else if ( hr == E_NOINTERFACE )
    {
        hr = S_OK;
    } // else if:

Cleanup:

    if ( punkCallback != NULL )
    {
        punkCallback->Release();
    } // if:

    HRETURN( hr );

} //*** HrSetInitialize()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCreateNetworksEnum
//
//  Description:
//      Create a network enumerator.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Success
//
//      E_POINTER
//          The IUnknown param is NULL.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCreateNetworksEnum(
    IClusCfgCallback *  picccIn,
    LCID                lcidIn,
    IWbemServices *     pIWbemServicesIn,
    IUnknown **         ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        LogMsg( L"[SRV] HrCreateNetworksEnum() was given a NULL pointer argument." );
        goto Exit;
    } // if:

    hr = THR( CEnumClusCfgNetworks::S_HrCreateInstance( ppunkOut ) );
    if ( FAILED( hr ) )
    {
        goto Exit;
    } // if:

    *ppunkOut = TraceInterface( L"CEnumClusCfgNetworks", IUnknown, *ppunkOut, 1 );

    hr = THR( HrSetInitialize( *ppunkOut, picccIn, lcidIn ) );
    if ( FAILED( hr ) )
    {
        goto Exit;
    } // if:

    hr = THR( HrSetWbemServices( *ppunkOut, pIWbemServicesIn ) );
    if ( FAILED( hr ) )
    {
        goto Exit;
    } // if:

Exit:

    HRETURN( hr );

} //*** HrCreateNetworksEnum()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrLoadOperatingSystemInfo()
//
//  Description:
//      Load the Win32_OperatingSystem object and determine which partition
//      were booted and have the OS installed on them.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLoadOperatingSystemInfo(
    IClusCfgCallback *  picccIn,
    IWbemServices *     pIWbemServicesIn,
    BSTR *              pbstrBootDeviceOut,
    BSTR *              pbstrSystemDeviceOut
    )
{
    TraceFunc( "" );
    Assert( picccIn != NULL );
    Assert( pIWbemServicesIn != NULL );
    Assert( pbstrBootDeviceOut != NULL );
    Assert( pbstrSystemDeviceOut != NULL );

    HRESULT     hr = S_OK;

    BSTR                    bstrClass;
    IEnumWbemClassObject *  pOperatingSystems = NULL;
    ULONG                   ulReturned;
    IWbemClassObject *      pOperatingSystem = NULL;
    int                     c;
    VARIANT                 var;
    HRESULT                 hrTemp;

    VariantInit( &var );

    bstrClass = TraceSysAllocString( L"Win32_OperatingSystem" );
    if ( bstrClass == NULL )
    {
        goto OutOfMemory;
    } // if:

    hr = THR( pIWbemServicesIn->CreateInstanceEnum( bstrClass, WBEM_FLAG_SHALLOW, NULL, &pOperatingSystems ) );
    if ( FAILED( hr ) )
    {
        hrTemp = THR( HrSendStatusReport(
            picccIn,
            TASKID_Major_Find_Devices,
            TASKID_Minor_WMI_OS_Qry_Failed,
            0,
            1,
            1,
            hr,
            IDS_ERROR_WMI_OS_QRY_FAILED
            ) );
        if ( FAILED( hrTemp ) )
        {
            hr = hrTemp;
        } // if:

        goto Cleanup;
    } // if:

    for ( c = 1; ; c++ )
    {
        hr = pOperatingSystems->Next( WBEM_INFINITE, 1, &pOperatingSystem, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            Assert( c < 2 );        // only expect one of these!

            hr = THR( HrGetWMIProperty( pOperatingSystem, L"BootDevice", VT_BSTR, &var ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            *pbstrBootDeviceOut = TraceSysAllocString( var.bstrVal );
            if ( *pbstrBootDeviceOut == NULL )
            {
                goto OutOfMemory;
            } // if:

            VariantClear( &var );

            hr = THR( HrGetWMIProperty( pOperatingSystem, L"SystemDevice", VT_BSTR, &var ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            *pbstrSystemDeviceOut = TraceSysAllocString( var.bstrVal );
            if ( *pbstrSystemDeviceOut == NULL )
            {
                goto OutOfMemory;
            } // if:

            pOperatingSystem->Release();
            pOperatingSystem = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            hrTemp = THR( HrSendStatusReport(
                            picccIn,
                            TASKID_Major_Find_Devices,
                            TASKID_Minor_WMI_OS_Qry_Next_Failed,
                            0,
                            1,
                            1,
                            hr,
                            IDS_ERROR_WMI_OS_QRY_NEXT_FAILED
                            ) );
            if ( FAILED( hrTemp ) )
            {
                hr = hrTemp;
            } // if:

            goto Cleanup;
        } // else:
    } // for:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    VariantClear( &var );

    if ( pOperatingSystem != NULL )
    {
        pOperatingSystem->Release();
    } // if:

    if ( pOperatingSystems != NULL )
    {
        pOperatingSystems->Release();
    } // if:

    TraceSysFreeString( bstrClass );

    HRETURN( hr );

} //*** HrLoadOperatingSystemInfo()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrConvertDeviceVolumeToLogicalDisk()
//
//  Description:
//      Convert a device volume to a logical disk.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//      Win32 Error
//          something failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrConvertDeviceVolumeToLogicalDisk(
    BSTR    bstrDeviceVolumeIn,
    BSTR *  pbstrLogicalDiskOut
    )
{
    TraceFunc( "" );
    Assert( pbstrLogicalDiskOut != NULL );

    HRESULT     hr = S_OK;
    BOOL        fRet;
    size_t      cchMountPoint;
    WCHAR *     pszMountPoint = NULL;
    WCHAR       szVolume[  MAX_PATH ];
    DWORD       sc;
    DWORD       cchPaths = 16;
    WCHAR *     pszPaths = NULL;
    int         c;
    DWORD       cch;

    cchMountPoint = wcslen( g_szNameSpaceRoot ) + wcslen( bstrDeviceVolumeIn ) + 2;
    pszMountPoint = new WCHAR[ cchMountPoint ];
    if ( pszMountPoint == NULL )
    {
        goto OutOfMemory;
    } // if:

    wcscpy( pszMountPoint, g_szNameSpaceRoot );
    wcscat( pszMountPoint, bstrDeviceVolumeIn );
    wcscat( pszMountPoint, L"\\" );

    fRet = GetVolumeNameForVolumeMountPoint( pszMountPoint, szVolume, sizeof( szVolume ) );
    if ( !fRet )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );

        LogMsg( L"[SRV] GetVolumeNameForVolumeMountPoint() failed.  Mount point is '%ws'. (hr = %#08x)", pszMountPoint, hr );

        //
        //  GetVolumeNameForVolumeMountPoint() is no longer supported for IA64 EFI partitions.  If the error is
        //  ERROR_INVALID_FUNCTION then we should try to get the device number using an IOCTL.
        //
        if ( HRESULT_CODE( hr ) == ERROR_INVALID_FUNCTION )
        {
            LogMsg( L"[SRV] Device volume '%ws' must be an IA64 EFI volume.", bstrDeviceVolumeIn );
        } // if:

        goto Cleanup;
    } // if:

    pszPaths = new WCHAR[ cchPaths ];
    if ( pszPaths == NULL )
    {
        goto OutOfMemory;
    } // if:

    //
    //  KB: 16 JAN 2001 GalenB
    //
    //  Since the device name that is passed in is for a volume there will never be more than
    //  one logical disk in the multisz pszPaths.
    //
    for ( c = 0; ; c++ )
    {
        Assert( c < 2 );            // expect to go through here no more than twice.

        fRet = GetVolumePathNamesForVolumeName( szVolume, pszPaths, cchPaths, &cch );
        if ( fRet )
        {
            break;
        } // if:
        else
        {
            sc = GetLastError();
            if ( sc == ERROR_MORE_DATA )
            {
                cchPaths = cch;

                delete [] pszPaths;
                pszPaths = new WCHAR[ cchPaths ];
                if ( pszPaths == NULL )
                {
                    goto OutOfMemory;
                } // if:

                continue;
            } // if:

            hr = THR( HRESULT_FROM_WIN32( sc ) );
            LogMsg( L"[SRV] GetVolumePathNamesForVolumeName() failed. Volume is is '%ws'. (hr = %#08x)", szVolume, hr );
            goto Cleanup;
        } // else:
    } // for:

    *pbstrLogicalDiskOut = TraceSysAllocString( pszPaths );
    if ( *pbstrLogicalDiskOut == NULL )
    {
        goto OutOfMemory;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    delete [] pszPaths;

    delete [] pszMountPoint;

    HRETURN( hr );

} //*** HrConvertDeviceVolumeToLogicalDisk()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrConvertDeviceVolumeToWMIDeviceID()
//
//  Description:
//      Since IA64 EFI partitions no longer support the call to
//      GetVolumeNameForVolumeMountPoint() to convert the device name
//      into a logical disk, since there will not longer be logical disks
//      for these partitions.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrConvertDeviceVolumeToWMIDeviceID(
    BSTR    bstrDeviceVolumeIn,
    BSTR *  pbstrWMIDeviceIDOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    HANDLE                  hVolume = NULL;
    DWORD                   dwSize;
    DWORD                   sc;
    STORAGE_DEVICE_NUMBER   sdnDevNumber;
    BOOL                    fRet;
    size_t                  cchDevice;
    WCHAR *                 pszDevice = NULL;
    WCHAR                   sz[ 64 ];

    cchDevice = wcslen( g_szNameSpaceRoot ) + wcslen( bstrDeviceVolumeIn ) + 2;
    pszDevice = new WCHAR[ cchDevice ];
    if ( pszDevice == NULL )
    {
        goto OutOfMemory;
    } // if:

    wcscpy( pszDevice, g_szNameSpaceRoot );
    wcscat( pszDevice, bstrDeviceVolumeIn );
    //
    // get handle to partition
    //
    hVolume = CreateFile(
                        pszDevice
                      , GENERIC_READ
                      , FILE_SHARE_READ
                      , NULL
                      , OPEN_EXISTING
                      , FILE_ATTRIBUTE_NORMAL
                      , NULL
                      );

    if ( hVolume == INVALID_HANDLE_VALUE )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    //
    // issue storage class ioctl to get drive and partition numbers
    // for this device
    //

    fRet = DeviceIoControl(
                          hVolume
                        , IOCTL_STORAGE_GET_DEVICE_NUMBER
                        , NULL
                        , 0
                        , &sdnDevNumber
                        , sizeof( sdnDevNumber )
                        , &dwSize
                        , NULL
                        );
    if ( !fRet )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    _snwprintf( sz, ARRAYSIZE( sz ), g_szPhysicalDriveFormat, sdnDevNumber.DeviceNumber );

    *pbstrWMIDeviceIDOut = SysAllocString( sz );
    if ( *pbstrWMIDeviceIDOut == NULL )
    {
        goto OutOfMemory;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    LogMsg( L"[SRV] HrConvertDeviceVolumeToWMIDeviceID() is out of memory. (hr = %#08x)", hr );

Cleanup:

    if ( hVolume != NULL )
    {
        CloseHandle( hVolume );
    } // if:

    delete [] pszDevice;

    HRETURN( hr );

} //*** HrConvertDeviceVolumeToWMIDeviceID()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetPageFileLogicalDisks()
//
//  Description:
//      Mark the drives that have paging files on them.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetPageFileLogicalDisks(
    IClusCfgCallback *  picccIn,
    IWbemServices *     pIWbemServicesIn,
    WCHAR               szLogicalDisksOut[ 26 ],
    int *               pcLogicalDisksOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_FALSE;
    IEnumWbemClassObject *  pPagingFiles = NULL;
    BSTR                    bstrClass;
    ULONG                   ulReturned;
    IWbemClassObject *      pPagingFile = NULL;
    VARIANT                 var;
    int                     idx;
    HRESULT                 hrTemp;

    bstrClass = TraceSysAllocString( L"Win32_PageFile" );
    if ( bstrClass == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pIWbemServicesIn->CreateInstanceEnum( bstrClass, WBEM_FLAG_SHALLOW, NULL, &pPagingFiles ) );
    if ( FAILED( hr ) )
    {
        hrTemp = THR( HrSendStatusReport(
                        picccIn,
                        TASKID_Major_Find_Devices,
                        TASKID_Minor_WMI_PageFile_Qry_Failed,
                        0,
                        1,
                        1,
                        hr,
                        IDS_ERROR_WMI_PAGEFILE_QRY_FAILED
                        ) );
        if ( FAILED( hrTemp ) )
        {
            hr = hrTemp;
        } // if:

        goto Cleanup;
    } // if:

    VariantInit( &var );

    for ( idx = 0; idx < sizeof( szLogicalDisksOut ); idx++ )
    {
        hr = pPagingFiles->Next( WBEM_INFINITE, 1, &pPagingFile, &ulReturned );
        if ( ( hr == S_OK ) && ( ulReturned == 1 ) )
        {
            VariantClear( &var );

            hr = THR( HrGetWMIProperty( pPagingFile, L"Drive", VT_BSTR, &var ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:

            CharUpper( var.bstrVal );

            szLogicalDisksOut[ idx ] = var.bstrVal[ 0 ];

            pPagingFile->Release();
            pPagingFile = NULL;
        } // if:
        else if ( ( hr == S_FALSE ) && ( ulReturned == 0 ) )
        {
            hr = S_OK;
            break;
        } // else if:
        else
        {
            hrTemp = THR( HrSendStatusReport(
                            picccIn,
                            TASKID_Major_Find_Devices,
                            TASKID_Minor_WMI_PageFile_Qry_Next_Failed,
                            0,
                            1,
                            1,
                            hr,
                            IDS_ERROR_WMI_PAGEFILE_QRY_NEXT_FAILED
                            ) );
            if ( FAILED( hrTemp ) )
            {
                hr = hrTemp;
            } // if:

            goto Cleanup;
        } // else:
    } // for:

    if ( pcLogicalDisksOut != NULL )
    {
        *pcLogicalDisksOut = idx;
    } // if:

Cleanup:

    VariantClear( &var );

    TraceSysFreeString( bstrClass );

    if ( pPagingFile != NULL )
    {
        pPagingFile->Release();
    } // if:

    if ( pPagingFiles != NULL )
    {
        pPagingFiles->Release();
    } // if:

    HRETURN( hr );

} //*** HrGetPageFileLogicalDisks()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetSystemDevice()
//
//  Description:
//      Returns the system (booted) device.
//
//  Arguments:
//
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetSystemDevice( BSTR * pbstrSystemDeviceOut )
{
    TraceFunc( "" );
    Assert( pbstrSystemDeviceOut != NULL );

    HRESULT hr = S_OK;
    DWORD   sc;
    HKEY    hKey = NULL;
    WCHAR * pszSystemDevice = NULL;
    DWORD   cbSystemDevice = 0; // no need to but prefix complains #318170

    sc = TW32( RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"System\\Setup", 0, KEY_READ, &hKey ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] RegOpenKeyEx() failed. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    sc = TW32( RegQueryValueEx( hKey, L"SystemPartition", NULL, NULL, NULL, &cbSystemDevice ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] RegQueryValueEx() failed. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    pszSystemDevice = new WCHAR[ cbSystemDevice / sizeof( WCHAR ) ];
    if ( pszSystemDevice == NULL )
    {
        goto OutOfMemory;
    } // if:

    sc = TW32( RegQueryValueEx( hKey, L"SystemPartition", NULL, NULL, (BYTE *) pszSystemDevice, &cbSystemDevice ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] RegQueryValueEx() failed. (hr = %#08x)", hr );
        goto Cleanup;
    } // if:

    *pbstrSystemDeviceOut = TraceSysAllocString( pszSystemDevice );
    if ( *pbstrSystemDeviceOut == NULL )
    {
        goto OutOfMemory;
    } // if:

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    LogMsg( L"[SRV] HrGetSystemDevice() is out of memory. (hr = %#08x)", hr );

Cleanup:

    delete [] pszSystemDevice;

    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
    } // if:

    HRETURN( hr );

} //*** HrGetSystemDevice()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetBootLogicalDisk()
//
//  Description:
//      Returns the boot (system) logical disk.
//
//  Arguments:
//
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrGetBootLogicalDisk( BSTR * pbstrBootLogicalDiskOut )
{
    TraceFunc( "" );
    Assert( pbstrBootLogicalDiskOut != NULL );

    HRESULT hr = S_OK;
    DWORD   sc;
    WCHAR   szWindowsDir[ MAX_PATH ];
    WCHAR   szVolume[ MAX_PATH ];
    BOOL    fRet;

    sc = GetWindowsDirectory( szWindowsDir, ARRAYSIZE( szWindowsDir ) );
    if ( sc == 0 )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] GetWindowsDirectory() failed. (hr = %#08x)", hr );
        goto Exit;
    } // if:

    fRet = GetVolumePathName( szWindowsDir, szVolume, ARRAYSIZE( szVolume ) );
    if ( !fRet )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        LogMsg( L"[SRV] GetVolumePathName() failed. (hr = %#08x)", hr );
        goto Exit;
    } // if:

    *pbstrBootLogicalDiskOut = TraceSysAllocString( szVolume );
    if ( *pbstrBootLogicalDiskOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
    } // if:

Exit:

    HRETURN( hr );

} //*** HrGetBootLogicalDisk()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCheckSecurity()
//
//  Description:
//      Checks the server security level.
//
//  Arguments:
//
//
//  Return Value:
//      S_OK
//          Secutity is high enough.
//
//      E_ACCESSDENIED
//          Security is not high enough.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCheckSecurity( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    IServerSecurity *   piss = NULL;
    DWORD               dwAuthnSvc;
    DWORD               dwAuthzSvc;
    BSTR                bstrServerPrincName = NULL;
    DWORD               dwAuthnLevel;
    DWORD               dwImpersonationLevel;
    void *              pvPrivs = NULL;
    DWORD               dwCapabilities;

    hr = THR( CoGetCallContext( IID_IServerSecurity, reinterpret_cast< void ** >( &piss  ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piss->QueryBlanket(
                &dwAuthnSvc,
                &dwAuthzSvc,
                &bstrServerPrincName,
                &dwAuthnLevel,
                &dwImpersonationLevel,
                &pvPrivs,
                &dwCapabilities ) );

Cleanup:

    SysFreeString( bstrServerPrincName );

    if ( piss != NULL )
    {
        piss->Release();
    } // if:

    HRETURN( hr );

} //*** HrCheckSecurity()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceWMIProperties()
//
//  Description:
//      Trace the properties to the debugger.
//
//  Arguments:
//
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG
void
TraceProperties( IWbemClassObject * pDiskIn )
{
    TraceFunc( "" );

    HRESULT hr = S_FALSE;
    VARIANT var;
    BSTR    bstrPropName;
    CIMTYPE cimType;
    LONG    lFlags;

    VariantInit( &var );

    hr = THR( pDiskIn->BeginEnumeration( 0 ) );
    if ( FAILED( hr ) )
    {
        goto Exit;
    } // if:

    for ( ; ; )
    {
        VariantClear( &var );

        hr = pDiskIn->Next( 0, &bstrPropName, &var, &cimType, &lFlags );
        if ( FAILED( hr ) )
        {
            break;
        } // if:
        else if ( hr == S_OK )
        {
            if ( var.vt == VT_BSTR )
            {
                DebugMsg( L"Property %ws = %ws", bstrPropName, var.bstrVal );
            } // if:

            if ( var.vt == VT_I4 )
            {
                DebugMsg( L"Property %ws = %d", bstrPropName, var.iVal );
            } // if:

            if ( var.vt == VT_BOOL )
            {
                if ( var.boolVal == VARIANT_TRUE )
                {
                    DebugMsg( L"Property %ws = True", bstrPropName );
                } // if:
                else
                {
                    DebugMsg( L"Property %ws = False", bstrPropName );
                } // else:
            } // if:

            if ( var.vt == VT_NULL )
            {
                DebugMsg( L"Property %ws = NULL", bstrPropName );
            } // if:

            TraceSysFreeString( bstrPropName );
            VariantClear( &var );
        } // else if:
        else
        {
            break;
        } // else:
    } // for:

Exit:

    VariantClear( &var );

    TraceFuncExit( );

} //*** TraceWMIProperties()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\startup\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file for the EvictCleanup library.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#define _UNICODE
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#define USES_SYSALLOCSTRING
#endif


////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the windows API and types
#include <windows.h>

// For COM
#include <objbase.h>
#include <ComCat.h>

// Required to be a part of this DLL
#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <Guids.h>
#include <ClusCfgGuids.h>
#include <ClusCfgServer.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\uuid\cluscfgguids.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ClusCfgGuids.cpp
//
//  Description:
//      GUIDs from ClusCfgGuids.h
//
//  Maintained By:
//      David Potter (DavidP) 18-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#include <initguid.h>
#include <ClusCfgGuids.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\test\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      main.cpp
//
//  Description:
//      The entry point for the application that launches unattended
//      installation of the cluster. This application parses input parameters,
//      CoCreates the Configuration Wizard Component, passes the parsed
//      parameters and invokes the Wizard. The Wizard may or may not show any
//      UI depending on swithes and the (in)availability of information.
//
//  Maintained By:
//      Galen Barbee (GalenB)       22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "pch.h"
#include <initguid.h>
#include <guids.h>
#include <ClusRtl.h>
#include "Callback.h"

DEFINE_MODULE( "CLUSCFGSERVERTEST" )

//
//  Declarations
//
typedef HRESULT (* PDLLREGISTERSERVER)( void );

//
//  Globals
//
HINSTANCE           g_hInstance = NULL;
LONG                g_cObjects  = 0;
IClusCfgServer *    g_pccs      = NULL;


//
//  Register the DLL
//
HRESULT
HrRegisterTheDll( void )
{
    TraceFunc( "" );

    HRESULT hr;

    PDLLREGISTERSERVER  pDllRegisterServer;

    HMODULE hLib    = NULL;

    //
    //  Make sure the DLL is properly registered.
    //

    hLib = LoadLibrary( L"..\\..\\..\\..\\dll\\obj\\i386\\ClusCfgServer.dll" );
    if ( hLib == NULL )
        goto Win32Error;

    pDllRegisterServer = reinterpret_cast< PDLLREGISTERSERVER >( GetProcAddress( hLib, "DllRegisterServer" ) );
    if ( pDllRegisterServer == NULL )
        goto Win32Error;

    hr = THR( pDllRegisterServer() );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:

    if ( hLib != NULL )
    {
        FreeLibrary( hLib );
    }

    HRETURN( hr );

Win32Error:
    hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
    goto Cleanup;
}

//
//  This tests the Storage device enumeration.
//
HRESULT
HrTestManagedResourceEnum( void )
{
    TraceFunc( "" );

    HRESULT                         hr;
    IEnumClusCfgManagedResources *  pesd    = NULL;
    ULONG                           cReceived = 0;
    IClusCfgManagedResourceInfo *   rgDevices[ 10 ];

    hr = g_pccs->GetManagedResourcesEnum( &pesd );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    while ( hr == S_OK )
    {
        hr = pesd->Next( sizeof( rgDevices ) / sizeof( rgDevices[ 0 ] ), &rgDevices[ 0 ], &cReceived );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        DebugMsg( "cReceived = %u", cReceived );

        for ( ULONG idx = 0; idx < cReceived; idx++ )
        {
            BSTR    bstr;

            THR( rgDevices[ idx ]->GetUID( &bstr ) );
            DebugMsg( "Device %u, UID = %ws", idx, bstr );
            SysFreeString( bstr );
            rgDevices[ idx ]->Release();
        } // for:
    } // while:

    if ( hr == S_FALSE )
    {
        hr = S_OK;
    } // if:

Cleanup:

    if ( pesd != NULL )
    {
        pesd->Release();
    }

    HRETURN( hr );

} //*** HrTestManagedResourceEnum()


//
//  This tests the Storage device enumeration.
//
HRESULT
HrTestNetworksEnum( void )
{
    TraceFunc( "" );

    HRESULT                 hr;
    IEnumClusCfgNetworks *  pens    = NULL;
    ULONG                   cReceived = 0;
    IClusCfgNetworkInfo *   rdNetworks[ 10 ];
    BSTR                    bstrUID;
    LPWSTR                  lpsz = NULL;
    ULONG                   ulDottedQuad;
    IClusCfgIPAddressInfo * piccipai = NULL;

    hr = g_pccs->GetNetworksEnum( &pens );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    while ( hr == S_OK )
    {
        hr = STHR( pens->Next( sizeof( rdNetworks ) / sizeof( rdNetworks[ 0 ] ), &rdNetworks[ 0 ], &cReceived ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if:

        for ( ULONG idx = 0; idx < cReceived; idx++ )
        {
            hr = THR( rdNetworks[ idx ]->GetPrimaryNetworkAddress( &piccipai ) );
            if ( SUCCEEDED( hr ) )
            {
                hr = THR( piccipai->GetIPAddress( &ulDottedQuad ) );
                if ( SUCCEEDED( hr ) )
                {
                    DWORD   sc;

                    sc = ClRtlTcpipAddressToString( ulDottedQuad, &lpsz );
                    if ( sc == ERROR_SUCCESS )
                    {
                        LocalFree( lpsz );
                        lpsz = NULL;
                    } // if:
                } // if:

                piccipai->Release();
            } // if:

            hr = THR( rdNetworks[ idx ]->GetUID( &bstrUID ) );
            if ( SUCCEEDED( hr ) )
            {
                SysFreeString( bstrUID );
            } // if:

            rdNetworks[ idx ]->Release();
        } // for:
    } // while:

    if ( hr == S_FALSE )
    {
        hr = S_OK;
    } // if:

Cleanup:

    if ( pens != NULL )
    {
        pens->Release();
    }

    if ( lpsz != NULL )
    {
        LocalFree( lpsz );
    } // if:

    HRETURN( hr );

} //*** HrTestNetworksEnum()


//
//  This tests the node information
//
HRESULT
HrTestNodeInfo( void )
{
    TraceFunc( "" );

    HRESULT                 hr;
    IClusCfgNodeInfo *      pccni   = NULL;
    DWORD                   dwNodeHighestVersion;
    DWORD                   dwNodeLowestVersion;
    SDriveLetterMapping     dlmDriveLetterUsage;
    IClusCfgClusterInfo *   pccci = NULL;
    DWORD                   dwMajorVersion;
    DWORD                   dwMinorVersion;
    WORD                    wSuiteMask;
    BYTE                    bProductType;
    BSTR                    bstrCSDVersion = NULL;

    hr = g_pccs->GetClusterNodeInfo( &pccni );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = pccni->GetClusterVersion( &dwNodeHighestVersion, &dwNodeLowestVersion );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = pccni->GetOSVersion( &dwMajorVersion, &dwMinorVersion, &wSuiteMask, &bProductType, &bstrCSDVersion );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = pccni->GetDriveLetterMappings( &dlmDriveLetterUsage );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = pccni->GetClusterConfigInfo( &pccci );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( pccci != NULL )
    {
        pccci->Release();
    }

    if ( pccni != NULL )
    {
        pccni->Release();
    }

    SysFreeString( bstrCSDVersion );

    HRETURN( hr );

} //*** HrTestNodeInfo()


//////////////////////////////////////////////////////////////////////////////
//
//  int
//  _cdecl
//  main( void )
//
//  Description:
//      Program entrance.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK (0)        - Success.
//      other HRESULTs  - Error.
//
//////////////////////////////////////////////////////////////////////////////
int _cdecl
main( void )
{
    HRESULT                 hr;
    IClusCfgInitialize *    pgcci = NULL;
    IClusCfgCapabilities *  piccc = NULL;
    IUnknown *              punkCallback = NULL;

    TraceInitializeProcess();

#if 0
    hr = THR( HrRegisterTheDll() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:
#endif

    //
    //  Start up the Cluster configuration server
    //

    hr = THR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( CoInitializeSecurity(
                    NULL,
                    -1,
                    NULL,
                    NULL,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_NONE,
                    0
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( CoCreateInstance( CLSID_ClusCfgServer, NULL, CLSCTX_SERVER, TypeSafeParams( IClusCfgServer, &g_pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( g_pccs->TypeSafeQI( IClusCfgInitialize, &pgcci ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( Callback::S_HrCreateInstance( &punkCallback ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = pgcci->Initialize( punkCallback, GetUserDefaultLCID() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( g_pccs->TypeSafeQI( IClusCfgCapabilities, &piccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccc->CanNodeBeClustered() );
    if ( FAILED( hr ) || ( hr == S_FALSE ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrTestNodeInfo() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrTestManagedResourceEnum() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( HrTestNetworksEnum() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

Cleanup:

    if ( punkCallback != NULL )
    {
        punkCallback->Release();
    } // if:

    if ( piccc != NULL )
    {
        piccc->Release();
    } // if:

    if ( pgcci != NULL )
    {
        pgcci->Release();
    } // if:

    if ( g_pccs != NULL )
    {
        g_pccs->Release();
    }

    CoUninitialize();

    TraceTerminateProcess();

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\startup\startupnotify.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      StartupNotify.cpp
//
//  Description:
//      This file contains the implementation of the CStartupNotify
//      class.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Header File:
//      StartupNotify.h
//
//  Maintained By:
//      Vij Vasu (VVasu) 15-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header for this library
#include "pch.h"

// The header file for this class
#include "StartupNotify.h"

// For POSTCONFIG_COMPLETE_EVENT_NAME
#include "EventName.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS( "CStartupNotify" );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStartupNotify::CStartupNotify()
//
//  Description:
//      Constructor of the CStartupNotify class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CStartupNotify::CStartupNotify( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    // Increment the count of components in memory so the DLL hosting this
    // object cannot be unloaded.
    InterlockedIncrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CStartupNotify::CStartupNotify


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStartupNotify::~CStartupNotify()
//
//  Description:
//      Destructor of the CStartupNotify class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CStartupNotify::~CStartupNotify( void )
{
    TraceFunc( "" );

    // There's going to be one less component in memory. Decrement component count.
    InterlockedDecrement( &g_cObjects );

    TraceFlow1( "Component count = %d.", g_cObjects );

    TraceFuncExit();

} //*** CStartupNotify::~CStartupNotify


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CStartupNotify::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Creates a CStartupNotify instance.
//
//  Arguments:
//      ppunkOut
//          The IUnknown interface of the new object.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_OUTOFMEMORY
//          Not enough memory to create the object.
//
//      other HRESULTs
//          Object initialization failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CStartupNotify::S_HrCreateInstance( IUnknown ** ppunkOut )
{
    TraceFunc( "" );

    HRESULT             hr = E_INVALIDARG;
    CStartupNotify *     pStartupNotify = NULL;

    do
    {
        // Allocate memory for the new object.
        pStartupNotify = new CStartupNotify();
        if ( pStartupNotify == NULL )
        {
            LogMsg( "Could not allocate memory for a evict cleanup object." );
            TraceFlow( "Could not allocate memory for a evict cleanup object." );
            hr = THR( E_OUTOFMEMORY );
            break;
        } // if: out of memory

        hr = THR( pStartupNotify->QueryInterface( IID_IUnknown, reinterpret_cast< void ** >( ppunkOut ) ) );

        TraceFlow1( "*ppunkOut = %#X.", *ppunkOut );
    }
    while( false ); // dummy do-while loop to avoid gotos.

    if ( pStartupNotify != NULL )
    {
        pStartupNotify->Release();
    } // if: the pointer to the notification object is not NULL

    HRETURN( hr );

} //*** CStartupNotify::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CStartupNotify::AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CStartupNotify::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    TraceFlow1( "m_cRef = %d", m_cRef );

    RETURN( m_cRef );

} //*** CStartupNotify::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CStartupNotify::Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CStartupNotify::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    TraceFlow1( "m_cRef = %d", m_cRef );

    if ( m_cRef == 0 )
    {
        TraceDo( delete this );
        RETURN( 0 );
    } // if: reference count decremented to zero

    RETURN( m_cRef );

} //*** CStartupNotify::Release()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CStartupNotify::QueryInterface()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      IN  REFIID  riid
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStartupNotify::QueryInterface( REFIID  riid, void ** ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = S_OK;

    if ( ppv != NULL )
    {
        if ( IsEqualIID( riid, IID_IUnknown ) )
        {
            *ppv = static_cast< IClusCfgStartupNotify * >( this );
        } // if: IUnknown
        else if ( IsEqualIID( riid, IID_IClusCfgStartupNotify ) )
        {
            *ppv = TraceInterface( __THISCLASS__, IClusCfgStartupNotify, this, 0 );
        } // else if:
        else
        {
            hr = E_NOINTERFACE;
        } // else

        if ( SUCCEEDED( hr ) )
        {
            ((IUnknown *) *ppv)->AddRef( );
        } // if: success
        else
        {
            *ppv = NULL;
        } // else: something failed

    } // if: the output pointer was valid
    else
    {
        hr = E_INVALIDARG;
    } // else: the output pointer is invalid


    QIRETURN( hr, riid );

} //*** CStartupNotify::QueryInterface()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CStartupNotify::SendNotifications()
//
//  Description:
//      This method is called by the Cluster Service to inform the implementor
//      of this interface to send out notification of cluster service startup
//      to interested listeners. If this method is being called for the first
//      time, the method waits till the post configuration steps are complete
//      before sending out the notifications.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CStartupNotify::SendNotifications( void )
{
    TraceFunc( "[IClusCfgStartupNotify]" );

    HRESULT     hr = S_OK;
    HANDLE      heventPostCfgCompletion = NULL;
    
    do
    {
        //
        // If the cluster service is being started for the first time, as a part
        // of adding this node to a cluster (forming or joining), then we have
        // to wait till the post-configuration steps are completed before we
        // can send out notifications.
        //

        TraceFlow1( "Trying to create an event named '%s'.", POSTCONFIG_COMPLETE_EVENT_NAME );

        // Create an event in the signalled state. If this event already existed
        // we get a handle to that event, and the state of the event is not changed.
        heventPostCfgCompletion = CreateEvent(
              NULL                                  // event security attributes
            , TRUE                                  // manual-reset event
            , TRUE                                  // create in signaled state
            , POSTCONFIG_COMPLETE_EVENT_NAME
            );

        if ( heventPostCfgCompletion == NULL )
        {
            hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
            LogMsg( "Error %#x occurred trying to create an event named '%s'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            TraceFlow2( "Error %#x occurred trying to create an event named '%s'.", hr, POSTCONFIG_COMPLETE_EVENT_NAME );
            break;
        } // if: we could not get a handle to the event
        

        TraceFlow( "Waiting for the event to be signaled." );

        //
        // Now, wait for this event to be signaled. If this method was called due to this
        // node being part of a cluster, this event would have been created in the unsignaled state
        // by the cluster configuration server. However, if this was not the first time that
        // the cluster service is starting on this node, the event would have been created in the
        // signaled state above, and so, the wait below will exit immediately.
        //

        do
        {
            DWORD dwStatus; 

            // Wait for any message sent or posted to this queue 
            // or for our event to be signaled.
            dwStatus = MsgWaitForMultipleObjects(
                  1
                , &heventPostCfgCompletion
                , FALSE
                , 900000                    // If no one has signaled this event in 15 minutes, abort.
                , QS_ALLINPUT
                ); 

            // The result tells us the type of event we have.
            if ( dwStatus == ( WAIT_OBJECT_0 + 1 ) )
            {
                MSG msg;

                // Read all of the messages in this next loop, 
                // removing each message as we read it.
                while ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 ) 
                { 
                    // If it is a quit message, we are done pumping messages.
                    if ( msg.message == WM_QUIT)
                    {
                        TraceFlow( "Get a WM_QUIT message. Exit message pump loop." );
                        break;
                    } // if: we got a WM_QUIT message

                    // Otherwise, dispatch the message.
                    DispatchMessage( &msg ); 
                } // while: there are still messages in the window message queue

            } // if: we have a message in the window message queue
            else
            {
                if ( dwStatus == WAIT_OBJECT_0 )
                {
                    TraceFlow( "Our event has been signaled. Exiting wait loop." );
                    break;
                } // else if: our event is signaled
                else
                {
                    if ( dwStatus == -1 )
                    {
                        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
                        LogMsg( "Error %#x occurred trying to wait for an event to be signaled.", hr );
                        TraceFlow1( "Error %#x occurred trying to wait for an event to be signaled.", hr );
                    } // if: MsgWaitForMultipleObjects() returned an error
                    else
                    {
                        hr = THR( HRESULT_FROM_WIN32( dwStatus ) );
                        LogMsg( "An error occurred trying to wait for an event to be signaled. Status code is %d.", dwStatus );
                        TraceFlow1( "An error occurred trying to wait for an event to be signaled. Status code is %d.", dwStatus );
                    } // else: an unexpected value was returned by MsgWaitForMultipleObjects()

                    break;
                } // else: an unexpected result
            } // else: MsgWaitForMultipleObjects() exited for a reason other than a waiting message
        } 
        while( true ); // do-while: loop infinitely

        if ( FAILED( hr ) )
        {
            TraceFlow( "Something went wrong trying to wait for the event to be signaled." );
            break;
        } // if: something has gone wrong

        TraceFlow( "Our event has been signaled. Proceed with the notifications." );

        // Send out the notifications
        hr = THR( HrNotifyListeners() );
        if ( FAILED( hr ) )
        {
            TraceFlow1( "Error %#x occurred trying to notify cluster startup listeners.", hr );
            LogMsg( "Error %#x occurred trying to notify cluster startup listeners.", hr );
            break;
        } // if: something went wrong while sending out notifications

        TraceFlow( "Sending of cluster startup notifications complete." );
        LogMsg( "Sending of cluster startup notifications complete." );
    }
    while( false ); // dummy do-while loop to avoid gotos

    //
    // Clean up
    //

    if ( heventPostCfgCompletion != NULL )
    {
        CloseHandle( heventPostCfgCompletion );
    } // if: we had created the event

    HRETURN( hr );

} //*** CStartupNotify::SendNotifications()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CStartupNotify::HrNotifyListeners
//
//  Description:
//      Enumerate all components on the local computer registered for cluster
//      startup notification.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the enumeration.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CStartupNotify::HrNotifyListeners( void )
{
    TraceFunc( "" );

    const UINT          uiCHUNK_SIZE = 16;

    HRESULT             hr = S_OK;
    ICatInformation *   pciCatInfo = NULL;
    IEnumCLSID *        psleStartupListenerClsidEnum = NULL;
    IUnknown *          punkResTypeServices = NULL;


    do
    {
        ULONG   cReturned = 0;
        CATID   rgCatIdsImplemented[ 1 ];

        rgCatIdsImplemented[ 0 ] = CATID_ClusCfgStartupListeners;

        //
        // Enumerate all the enumerators registered in the
        // CATID_ClusCfgStartupListeners category
        //
        hr = THR(
                CoCreateInstance(
                      CLSID_StdComponentCategoriesMgr
                    , NULL
                    , CLSCTX_SERVER
                    , IID_ICatInformation
                    , reinterpret_cast< void ** >( &pciCatInfo )
                    )
                );

        if ( FAILED( hr ) )
        {
            TraceFlow1( "Error %#x occurred trying to get a pointer to the enumerator of the CATID_ClusCfgStartupListeners category.", hr );
            LogMsg( "Error %#x occurred trying to get a pointer to the enumerator of the CATID_ClusCfgStartupListeners category.", hr );
            break;
        } // if: we could not get a pointer to the ICatInformation interface

        // Get a pointer to the enumerator of the CLSIDs that belong to the CATID_ClusCfgStartupListeners category.
        hr = THR(
            pciCatInfo->EnumClassesOfCategories(
                  1
                , rgCatIdsImplemented
                , 0
                , NULL
                , &psleStartupListenerClsidEnum
                )
            );

        if ( FAILED( hr ) )
        {
            TraceFlow1( "Error %#x occurred trying to get a pointer to the enumerator of the CATID_ClusCfgStartupListeners category.", hr );
            LogMsg( "Error %#x occurred trying to get a pointer to the enumerator of the CATID_ClusCfgStartupListeners category.", hr );
            break;
        } // if: we could not get a pointer to the IEnumCLSID interface

        //
        // Create an instance of the resource type services component
        //
        hr = THR(
            CoCreateInstance(
                  CLSID_ClusCfgResTypeServices
                , NULL
                , CLSCTX_INPROC_SERVER
                , __uuidof( punkResTypeServices )
                , reinterpret_cast< void ** >( &punkResTypeServices )
                )
            );

        if ( FAILED( hr ) )
        {
            TraceFlow1( "Error %#x occurred trying to create the resource type services component.", hr );
            LogMsg( "Error %#x occurred trying to create the resource type services component.", hr );
            break;
        } // if: we could not create the resource type services component


        // Enumerate the CLSIDs of the registered startup listeners
        do
        {
            CLSID   rgStartupListenerClsids[ uiCHUNK_SIZE ];
            ULONG   idxCLSID;

            cReturned = 0;
            hr = STHR(
                psleStartupListenerClsidEnum->Next(
                      uiCHUNK_SIZE
                    , rgStartupListenerClsids
                    , &cReturned
                    )
                );

            if ( FAILED( hr ) )
            {
                TraceFlow1( "Error %#x occurred trying enumerate startup listener components.", hr );
                LogMsg( "Error %#x occurred trying enumerate startup listener components.", hr );
                break;
            } // if: we could not get the next set of CLSIDs

            // hr may be S_FALSE here, so reset it.
            hr = S_OK;

            for ( idxCLSID = 0; idxCLSID < cReturned; ++idxCLSID )
            {
                hr = THR( HrProcessListener( rgStartupListenerClsids[ idxCLSID ], punkResTypeServices ) );

                if ( FAILED( hr ) )
                {
                    // The processing of one of the listeners failed.
                    // Log the error, but continue processing other listeners.
                    TraceFlow1( "Error %#x occurred trying to process a cluster startup listener. Other listeners will be processed.", hr );
                    TraceMsgGUID( mtfALWAYS, "The CLSID of the failed listener is ", rgStartupListenerClsids[ idxCLSID ] );
                    LogMsg( "Error %#x occurred trying to process a cluster startup listener. Other listeners will be processed.", hr );
                    hr = S_OK;
                } // if: this enumerator failed
            } // for: iterate through the returned CLSIDs
        }
        while( cReturned > 0 ); // while: there are still CLSIDs to be enumerated

        if ( FAILED( hr ) )
        {
            break;
        } // if: something went wrong in the loop above
    }
    while( false ); // dummy do-while loop to avoid gotos.

    //
    // Cleanup code
    //

    if ( pciCatInfo != NULL )
    {
        pciCatInfo->Release();
    } // if: we had obtained a pointer to the ICatInformation interface

    if ( psleStartupListenerClsidEnum != NULL )
    {
        psleStartupListenerClsidEnum->Release();
    } // if: we had obtained a pointer to the enumerator of startup listener CLSIDs

    if ( punkResTypeServices != NULL )
    {
        punkResTypeServices->Release();
    } // if: we had created the resource type services component

    HRETURN( hr );

} //*** CStartupNotify::HrNotifyListeners()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CStartupNotify::HrProcessListener
//
//  Description:
//      This function instantiates a cluster startup listener component
//      and calls the appropriate methods.
//
//  Arguments:
//      rclsidListenerCLSIDIn
//          CLSID of the startup listener component
//
//      punkResTypeServicesIn
//          Pointer to the IUnknown interface on the resource type services
//          component. This interface provides methods that help configure
//          resource types.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          Something went wrong during the processing of the listener.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CStartupNotify::HrProcessListener(
      const CLSID &   rclsidListenerCLSIDIn
    , IUnknown *      punkResTypeServicesIn
    )
{
    TraceFunc( "" );

    HRESULT                         hr = S_OK;
    IClusCfgStartupListener *       pcslStartupListener = NULL;

    TraceMsgGUID( mtfALWAYS, "The CLSID of this startup listener is ", rclsidListenerCLSIDIn );

    do
    {
        //
        // Create the component represented by the CLSID passed in
        //
        hr = THR(
                CoCreateInstance(
                      rclsidListenerCLSIDIn
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , __uuidof( pcslStartupListener )
                    , reinterpret_cast< void ** >( &pcslStartupListener )
                    )
                );

        if ( FAILED( hr ) )
        {
            TraceFlow1( "Error %#x occurred trying to create the cluster startup listener component.", hr );
            LogMsg( "Error %#x occurred trying to create a cluster startup listener component.", hr );
            break;
        } // if: we could not create the cluster startup listener component

        // Notify this listener.
        hr = THR( pcslStartupListener->Notify( punkResTypeServicesIn ) );

        if ( FAILED( hr ) )
        {
            TraceFlow1( "Error %#x occurred trying to notify this startup listener.", hr );
            LogMsg( "Error %#x occurred trying to notify a cluster startup listener.", hr );
            break;
        } // if: this notification
    }
    while( false ); // dummy do-while loop to avoid gotos.

    //
    // Cleanup code
    //

    if ( pcslStartupListener != NULL )
    {
        pcslStartupListener->Release();
    } // if: we had obtained a pointer to the startup listener interface

    HRETURN( hr );

} //*** CStartupNotify::HrProcessListener()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\startup\startupnotify.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      StartupNotify.h
//
//  Description:
//      This file contains the declaration of the CStartupNotify
//      class. This class handles is used to clean up a node after it has been
//      evicted from a cluster.
//
//  Documentation:
//      TODO: fill in pointer to external documentation
//
//  Implementation Files:
//      StartupNotify.cpp
//
//  Maintained By:
//      Vij Vasu (VVasu) 04-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For IUnknown
#include <unknwn.h>

// For IClusCfgStartup
#include "ClusCfgServer.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CStartupNotify
//
//  Description:
//      This class handles is used to clean up a node after it has been
//      evicted from a cluster.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CStartupNotify
    : public IClusCfgStartupNotify
{
public:
    //////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    //////////////////////////////////////////////////////////////////////////

    STDMETHOD( QueryInterface )( REFIID riid, void ** ppvObject );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgStartupNotify methods
    //////////////////////////////////////////////////////////////////////////

    // Send out notification of cluster service startup to interested listeners
    STDMETHOD( SendNotifications )( void );


    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create an instance of this class.
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut );


private:
    //////////////////////////////////////////////////////////////////////////
    //  Private member functions
    //////////////////////////////////////////////////////////////////////////

    // Enumerate all components on the local computer registered for cluster 
    // startup notification.
    HRESULT HrNotifyListeners( void );

    // Instantiate a cluster startup listener component and call the 
    // appropriate methods.
    HRESULT HrProcessListener(
        const CLSID &   rclsidListenerCLSIDIn
      , IUnknown *      punkResTypeServicesIn
      );


    //
    // Private constructors, destructor and assignment operator.
    // All of these methods are private for two reasons:
    // 1. Lifetimes of objects of this class are controlled by S_HrCreateInstance and Release.
    // 2. Copying of an object of this class is prohibited.
    //

    // Default constructor.
    CStartupNotify( void );

    // Destructor.
    ~CStartupNotify( void );

    // Copy constructor.
    CStartupNotify( const CStartupNotify & );

    // Assignment operator.
    CStartupNotify & operator =( const CStartupNotify & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // Reference count for this object.
    LONG                        m_cRef;

}; //*** class CStartupNotify
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\server\test\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     22-JAN-2000
//      Vijay Vasu (VVasu)          22-JAN-2000
//      Galen Barbee (GalenB)       22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE = 1
#define _UNICODE = 1

#if DBG==1 || defined( _DEBUG )
#define DEBUG
// Define these to change Interface Tracking
//#define NO_TRACE_INTERFACES
//#define NOISY_TRACE_INTERFACES
//#define USES_SYSALLOCSTRING
#endif // DBG==1

//////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>
#include <wchar.h>

#include <common.h>
#include <debug.h>
#include <Log.h>
#include <citracker.h>
#include <guids.h>
#include <ObjectCookie.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>

//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////
extern HINSTANCE g_hInstance;
extern LONG g_cObjects;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cenumcfgnetworks.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumCfgNetworks.cpp
//
//  Description:
//      CEnumCfgNetworks implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CProxyCfgNetworkInfo.h"
#include "CEnumCfgNetworks.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////


DEFINE_THISCLASS("CEnumCfgNetworks")


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::S_HrCreateInstance
//
//  Description:
//      Create a CClusCfgClusterInfo instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCfgNetworks::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown * punkOuterIn,
    HCLUSTER * phClusterIn,
    CLSID * pclsidMajorIn
    )
{
    TraceFunc( "" );

    HRESULT            hr  = S_OK;
    CEnumCfgNetworks * pcecn = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if

    pcecn = new CEnumCfgNetworks;
    if ( pcecn == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pcecn->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( pcecn->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( pcecn != NULL )
    {
        pcecn->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumCfgNetworks::S_HrCreateInstance


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::CEnumCfgNetworks
//
//  Description:
//      Constructor of the CEnumCfgNetworks class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumCfgNetworks::CEnumCfgNetworks( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_cRef == 1 );
    Assert( m_pcccb == NULL );
    Assert( m_phCluster == NULL );
    Assert( m_pclsidMajor == NULL );
    Assert( m_dwIndex == 0 );
    Assert( m_hClusEnum == NULL );

    TraceFuncExit();

} //*** CEnumCfgNetworks::CEnumCfgNetworks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::~CEnumCfgNetworks
//
//  Description:
//      Desstructor of the CEnumCfgNetworks class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CEnumCfgNetworks::~CEnumCfgNetworks( void )
{
    TraceFunc( "" );

    // m_cRef - noop

    if ( m_pcccb )
    {
        m_pcccb->Release();
    } //if:

    // m_phCluster - DO NOT CLOSE!

    // m_pclsidMajor - noop
    // m_dwIndex - noop

    if ( m_hClusEnum != NULL )
        ClusterCloseEnum( m_hClusEnum );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumCfgNetworks::~CEnumCfgNetworks


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::HrInit
//
//  Description:
//      Initialize this component.
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCfgNetworks::HrInit(
    IUnknown * punkOuterIn,
    HCLUSTER * phClusterIn,
    CLSID * pclsidMajorIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef();
    }

    if ( phClusterIn == NULL )
        goto InvalidArg;

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    if ( punkOuterIn != NULL )
    {
        hr = THR( punkOuterIn->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    //
    //  Open the enumer.
    //

    m_hClusEnum = ClusterOpenEnum( *m_phCluster, CLUSTER_ENUM_NETWORK );
    if ( m_hClusEnum == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ClusterOpenEnum_Failed, hr );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_InvalidArg, hr );
    goto Cleanup;

} //*** CEnumCfgNetworks::HrInit


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCfgNetworks -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks:: [INKNOWN] QueryInterface
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IEnumClusCfgNetworks * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumClusCfgNetworks ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgNetworks, this, 0 );
        hr = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CEnumCfgNetworks::QueryInterface


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumCfgNetworks:: [IUNKNOWN] AddRef
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCfgNetworks::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CEnumCfgNetworks::AddRef


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CEnumCfgNetworks:: [IUNKNOWN] Release
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCfgNetworks::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN( 0 );

} //*** CEnumCfgNetworks::Release


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCfgNetworks -- IEnumClusCfgNetworks interface
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::Next
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::Next(
    ULONG                   cNumberRequestedIn,
    IClusCfgNetworkInfo **  rgpNetworkInfoOut,
    ULONG *                 pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr;
    ULONG   cFetched = 0;

    if ( rgpNetworkInfoOut == NULL )
        goto InvalidPointer;

    for ( ; cFetched < cNumberRequestedIn; m_dwIndex ++ )
    {
        hr = STHR( HrGetItem( m_dwIndex, &(rgpNetworkInfoOut[ cFetched ]) ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
            continue;   // not a network

        if (  hr == MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NO_MORE_ITEMS ) )
            break;  // no more items

        cFetched ++;

    } // for:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:
    else
    {
        hr = S_OK;
    } // else:

Cleanup:
    if ( FAILED( hr ) )
    {
        ULONG idx;

        for ( idx = 0; idx < cFetched; idx++ )
        {
            (rgpNetworkInfoOut[ idx ])->Release();
        } // for:

        cFetched = 0;

    } // if:

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_Next_InvalidPointer, hr );
    goto Cleanup;

} //*** CEnumCfgNetworks::Next


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::Reset
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::Reset( void )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    m_dwIndex = 0;

    HRETURN( S_OK );

} //*** CEnumCfgNetworks::Reset


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::Skip
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT                 hr;
    DWORD                   idx;
    IClusCfgNetworkInfo *   piccni = NULL;

    for ( idx = 0; idx < cNumberToSkipIn; m_dwIndex ++ )
    {
        hr = STHR( HrGetItem( m_dwIndex, &piccni ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
            continue;   // not a network

        if (  hr == MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NO_MORE_ITEMS ) )
            break;  // no more items

        piccni->Release();
        piccni = NULL;

        idx ++;

    } // for:

    if ( idx < cNumberToSkipIn )
    {
        hr = S_FALSE;
    } // if:
    else
    {
        hr = S_OK;
    }

Cleanup:
    Assert( piccni == NULL );

    HRETURN( hr );

} //*** CEnumCfgNetworks::Skip

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::Clone
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::Clone( IEnumClusCfgNetworks ** ppNetworkInfoOut )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CEnumCfgNetworks::Clone


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::Count
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::Count( DWORD * pnCountOut )
{
    TraceFunc( "[IEnumClusCfgNetworks]" );

    Assert( m_hClusEnum != NULL );
    
    HRESULT hr = S_OK;

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }
    
    *pnCountOut = ClusterGetEnumCount(m_hClusEnum);

Cleanup:

    HRETURN( hr );

} //*** CEnumCfgNetworks::Count



//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::SendStatusReport
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgNetworks::SendStatusReport(
      BSTR          bstrNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , BSTR          bstrDescriptionIn
    , FILETIME *    pftTimeIn
    , BSTR          bstrReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport(
                              bstrNodeNameIn
                            , clsidTaskMajorIn
                            , clsidTaskMinorIn
                            , ulMinIn
                            , ulMaxIn
                            , ulCurrentIn
                            , hrStatusIn
                            , bstrDescriptionIn
                            , pftTimeIn
                            , bstrReferenceIn
                            ) );
    } // if:

    HRETURN( hr );

}  //*** CEnumCfgNetworks::SendStatusReport


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CEnumCfgNetworks -- Private methods.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgNetworks::HrGetItem
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCfgNetworks::HrGetItem(
      DWORD                     dwItem
    , IClusCfgNetworkInfo **    ppNetworkInfoOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;
    DWORD   dwTypeDummy;
    DWORD   cchName = 64;   // good starting value
    BSTR    bstrName = NULL;

    IUnknown * punk = NULL;

    Assert( ppNetworkInfoOut != NULL );
    Assert( m_hClusEnum != NULL );

    bstrName = TraceSysAllocStringLen( NULL, cchName );
    if ( bstrName == NULL )
        goto OutOfMemory;

    cchName ++; // SysAllocStringLen allocates cchName + 1.

    // We are wrapping this a cchName should be significantly large enough to handle
    // most of our testing.
    sc = ClusterEnum( m_hClusEnum, m_dwIndex, &dwTypeDummy, bstrName, &cchName );
    if ( sc == ERROR_MORE_DATA )
    {
        //
        //  Our "typical" buffer is too small. Try make it to the size ClusterEnum
        //  returned.
        //

        TraceSysFreeString( bstrName );

        bstrName = TraceSysAllocStringLen( NULL, cchName );
        if ( bstrName == NULL )
            goto OutOfMemory;

        cchName ++; // SysAllocStringLen allocates cchName + 1.

        sc = TW32( ClusterEnum( m_hClusEnum, m_dwIndex, &dwTypeDummy, bstrName, &cchName ) );
    }
    else if ( sc == ERROR_NO_MORE_ITEMS )
    {
        hr = MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NO_MORE_ITEMS );
        goto Cleanup;
    }

    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrGetItem_ClusterEnum_Failed, hr );
        goto Cleanup;
    }

    Assert( dwTypeDummy == CLUSTER_ENUM_NETWORK );

    //
    // Create the requested object and store it.
    //

    hr = STHR( CProxyCfgNetworkInfo::S_HrCreateInstance( &punk,
                                                         m_punkOuter,
                                                         m_phCluster,
                                                         m_pclsidMajor,
                                                         bstrName
                                                         ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrGetItem_Create_CProxyCfgNetworkInfo_Failed, hr );
        goto Cleanup;
    }

    if ( hr == S_FALSE )
        goto Cleanup;   // This means that the object was not a network resource.

    //
    //  The CProxyCfgNetworkInfo takes ownership of the BSTR
    //

    bstrName = NULL;

    //
    //  QI for the interface to return.
    //

    hr = THR( punk->TypeSafeQI( IClusCfgNetworkInfo, ppNetworkInfoOut ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrGetItem_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:

    TraceSysFreeString( bstrName );

    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

OutOfMemory:

    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrGetItem_OutOfMemory, hr );
    goto Cleanup;

} // *** CEnumCfgNetworks::HrGetItem
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cenumcfgnetworks.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumCfgNetworks.h
//
//  Description:
//      This file contains the declaration of the CEnumCfgNetworks
//      class.
//
//      The class CEnumCfgNetworks is the enumeration of
//      cluster networks. It implements the IEnumClusCfgNetworks interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumCfgNetworks.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumCfgNetworks
//
//  Description:
//      The class CEnumClusCfgNetworks is the enumeration of cluster networks.
//
//  Interfaces:
//      CBaseEnum
//      IEnumClusCfgNetworks
//      IClusCfgSetHandle
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumCfgNetworks
    : public IEnumClusCfgNetworks
{
private:
    LONG                m_cRef;                 //  Reference counter
    IUnknown *          m_punkOuter;            //  Interface to Outer W2K Proxy object
    IClusCfgCallback *  m_pcccb;                //  Callback interface
    HCLUSTER *          m_phCluster;            //  Pointer to cluster handle
    CLSID *             m_pclsidMajor;          //  Pointer to CLSID to use for logging errors to the UI
    DWORD               m_dwIndex;              //  Current enumer index
    HCLUSENUM           m_hClusEnum;            //  Cluster enumer handle

    CEnumCfgNetworks( void );
    ~CEnumCfgNetworks( void );

    // Private copy constructor to prevent copying.
    CEnumCfgNetworks( const CEnumCfgNetworks & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumCfgNetworks & operator = ( const CEnumCfgNetworks & nodeSrc );

    HRESULT HrInit( IUnknown * punkOuterIn, HCLUSTER * phClusterIn, CLSID * pclsidMajorIn );
    HRESULT HrGetItem( DWORD dwItem, IClusCfgNetworkInfo ** ppNetworkInfoOut );

public:
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut,
                                       IUnknown * punkOuterIn,
                                       HCLUSTER * phClusterIn,
                                       CLSID * pclsidMajorIn
                                       );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnum
    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgNetworkInfo ** rgpNetworkInfoOut, ULONG * pcNumberFetchedOut );
    STDMETHOD( Reset )( void );
    STDMETHOD( Skip )( ULONG cNumberToSkipIn );
    STDMETHOD( Clone )( IEnumClusCfgNetworks ** ppNetworkInfoOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )( BSTR bstrNodeNameIn,
                                   CLSID        clsidTaskMajorIn,
                                   CLSID        clsidTaskMinorIn,
                                   ULONG        ulMinIn,
                                   ULONG        ulMaxIn,
                                   ULONG        ulCurrentIn,
                                   HRESULT      hrStatusIn,
                                   BSTR         bstrDescriptionIn,
                                   FILETIME *   pftTimeIn,
                                   BSTR         bstrReferenceIn
                                   );

}; //*** class CEnumCfgNetworks
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cenumcfgresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumCfgResources.h
//
//  Description:
//      This file contains the declaration of the CEnumCfgResources
//      class.
//
//      The class CEnumCfgResources is the enumeration of
//      cluster networks. It implements the IEnumClusCfgNetworks interface.
//
//  Documentation:
//
//  Implementation Files:
//      CEnumCfgResources.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CEnumCfgResources
//
//  Description:
//      The class CEnumCfgResources is the enumeration of cluster resoruces.
//
//  Interfaces:
//      CBaseEnum
//      IEnumClusCfgManagedResources
//      IClusCfgSetHandle
//      IClusCfgInitialize
//
//--
//////////////////////////////////////////////////////////////////////////////
class CEnumCfgResources
    : public IEnumClusCfgManagedResources
{
private:
    LONG                m_cRef;
    IUnknown *          m_punkOuter;                //  Outer control object - It can't be deleted until we get deleted.
    HCLUSTER *          m_phCluster;                //  Pointer to the handle of the cluster/node - DO NOT CLOSE!
    CLSID *             m_pclsidMajor;              //  Pointer to the clsid to log UI information to.
    IClusCfgCallback *  m_pcccb;                    //  Callback interface to log information.
    HCLUSENUM           m_hClusEnum;                //  Cluster enumer handle
    DWORD               m_dwIndex;                  //  Current index

    CEnumCfgResources( void );
    ~CEnumCfgResources( void );

    // Private copy constructor to prevent copying.
    CEnumCfgResources( const CEnumCfgResources & nodeSrc );

    // Private assignment operator to prevent copying.
    const CEnumCfgResources & operator = ( const CEnumCfgResources & nodeSrc );

    HRESULT HrInit( IUnknown * pOuterIn, HCLUSTER * phClusterIn, CLSID * pclsidMajorIn );
    HRESULT HrGetItem( IClusCfgManagedResourceInfo ** ppManagedResourceInfoOut );

public: // methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut,
                            IUnknown *  pOuterIn,
                            HCLUSTER *  phClusterIn,
                            CLSID *     pclsidMajorIn
                            );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IEnum
    STDMETHOD( Next )( ULONG cNumberRequestedIn,
                       IClusCfgManagedResourceInfo **   rgpManagedResourceInfoOut,
                       ULONG * pcNumberFetchedOut
                       );
    STDMETHOD( Reset )( void );
    STDMETHOD( Skip )( ULONG cNumberToSkipIn );
    STDMETHOD( Clone )( IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )( BSTR bstrNodeNameIn,
                                   CLSID        clsidTaskMajorIn,
                                   CLSID        clsidTaskMinorIn,
                                   ULONG        ulMinIn,
                                   ULONG        ulMaxIn,
                                   ULONG        ulCurrentIn,
                                   HRESULT      hrStatusIn,
                                   BSTR         bstrDescriptionIn,
                                   FILETIME *   pftTimeIn,
                                   BSTR         bstrReferenceIn
                                   );

}; //*** class CEnumCfgResources
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\configclusapi.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ConfigClusApi.h
//
//  Description:
//      ConfigClusApi implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CConfigClusApi
//
//  Description:
//
//  Interfaces:
//      IConfigurationConnection
//      IClusCfgServer
//      IClusCfgInitialize
//      IClusCfgCallback
//      IClusCfgCapabilities
//      IClusCfgClusterConnection
//
//--
//////////////////////////////////////////////////////////////////////////////
class
CConfigClusApi
    : public IConfigurationConnection
    , public IClusCfgServer
    , public IClusCfgCallback
    , public IClusCfgCapabilities
    , public IClusCfgVerify
{
private:
    LONG                        m_cRef;
    HCLUSTER                    m_hCluster;                 //  Cluster connection.
    IClusCfgCallback *          m_pcccb;                    //  Callback interface
    CLSID                       m_clsidMajor;               //  What TASKID to log UI errors to.
    CLSID                       m_clsidType;                //  What type of cookie was used to open connection.
    BSTR                        m_bstrName;                 //  Name of node or cluster connected to.
    BSTR                        m_bstrBindingString;        //  Binding string

    CConfigClusApi( void );
    ~CConfigClusApi( void );

    // Private copy constructor to prevent copying.
    CConfigClusApi( const CConfigClusApi & nodeSrc );

    // Private assignment operator to prevent copying.
    const CConfigClusApi & operator = ( const CConfigClusApi & nodeSrc );

public: // Methods
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IConfigurationConnection
    STDMETHOD( ConnectTo )( OBJECTCOOKIE cookieIn );
    STDMETHOD( ConnectToObject )( OBJECTCOOKIE cookieIn, REFIID riidIn, LPUNKNOWN * ppunkOut );

    // IClusCfgServer
    STDMETHOD( GetClusterNodeInfo )( IClusCfgNodeInfo ** ppClusterNodeInfoOut );
    STDMETHOD( GetManagedResourcesEnum )( IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut );
    STDMETHOD( GetNetworksEnum )( IEnumClusCfgNetworks ** ppEnumNetworksOut );
    STDMETHOD( CommitChanges )( void );
    STDMETHOD( GetBindingString )( BSTR * pbstrBindingStringOut );
    STDMETHOD( SetBindingString )( LPCWSTR bstrBindingStringIn );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

    // IClusCfgCapabilities
    STDMETHOD( CanNodeBeClustered )( void );

    // IClusCfgVerify
    STDMETHOD( VerifyCredentials )( LPCWSTR bstrUserIn, LPCWSTR bstrDomainIn, LPCWSTR bstrPasswordIn );
    STDMETHOD( VerifyConnectionToCluster )( LPCWSTR bstrClusterNameIn );
    STDMETHOD( VerifyConnectionToNode )( LPCWSTR bstrNodeNameIn );

}; //*** class CConfigClusApi
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\configclusapi.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ConfigClusApi.cpp
//
//  Description:
//      CConfigClusApi implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "ConfigClusApi.h"
#include "CProxyCfgNodeInfo.h"
#include "CEnumCfgResources.h"
#include "CEnumCfgNetworks.h"
#include "StatusReports.h"
#include "nameutil.h"

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CConfigClusApi")


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::S_HrCreateInstance()
//
//  Description:
//      Create a CConfigClusApi instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConfigClusApi::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CConfigClusApi *    pcc = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto CleanUp;
    } // if:

    pcc = new CConfigClusApi;
    if ( pcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto CleanUp;
    } // if:

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );

CleanUp:

    if ( pcc != NULL )
    {
        pcc->Release();
    } // if:

    HRETURN( hr );

} //*** CConfigClusApi::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::CConfigClusApi()
//
//  Description:
//      Constructor of the CConfigClusApi class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CConfigClusApi::CConfigClusApi( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_cRef == 1 );
    Assert( m_pcccb == NULL );
    Assert( IsEqualIID( m_clsidMajor, IID_NULL ) );
    Assert( m_bstrName == NULL );
    Assert( m_bstrBindingString == NULL );

    TraceFuncExit();

} //*** CConfigClusApi::CConfigClusApi()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::~CConfigClusApi()
//
//  Description:
//      Destructor of the CConfigClusApi class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CConfigClusApi::~CConfigClusApi( void )
{
    TraceFunc( "" );

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    } // if:

    TraceSysFreeString( m_bstrName );
    TraceSysFreeString( m_bstrBindingString );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CConfigClusApi::~CConfigClusApi()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CConfigClusApi -- IUnknown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi:: [INKNOWN] QueryInterface()
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IConfigurationConnection * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IConfigurationConnection ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IConfigurationConnection, this, 0 );
        hr   = S_OK;
    } // else if: IConfigClusApi
    else if ( IsEqualIID( riid, IID_IClusCfgServer ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgServer, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgServer
    else if ( IsEqualIID( riid, IID_IClusCfgCallback ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgCallback
    else if ( IsEqualIID( riid, IID_IClusCfgCapabilities ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgCapabilities, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgCapabilities
    else if ( IsEqualIID( riid, IID_IClusCfgVerify ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgVerify, this, 0 );
        hr   = S_OK;
    } // else if: IClusCfgVerify

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CConfigClusApi::QueryInterface()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CConfigClusApi:: [IUNKNOWN] AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CConfigClusApi::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CConfigClusApi::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CConfigClusApi:: [IUNKNOWN] Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CConfigClusApi::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN( 0 );

} //*** CConfigClusApi::Release()


//****************************************************************************
//
// IConfigClusApi
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::ConnectTo()
//
//  Description:
//
//
//  Arguments
//    OBJECTCOOKIE cookieIn,  The Object Cookie.
//    REFIID riidIn,          The IID. of the interface
//    LPUNKNOWN * ppunkOut    The return pointer
//
//  Description:
//    Connects to the given object.
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::ConnectTo(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[IConfigClusApi]" );

    HRESULT hr;

    IServiceProvider *          psp   = NULL;
    IObjectManager *            pom   = NULL;
    IStandardInfo *             psi   = NULL;
    IConnectionPoint *          pcp   = NULL;
    IConnectionPointContainer * pcpc  = NULL;

    //
    //  Retrieve the managers needs for the task ahead.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IServiceProvider,
                                reinterpret_cast< void ** >( &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->QueryService( CLSID_ObjectManager,
                                 TypeSafeParams( IObjectManager, &pom )
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->QueryService( CLSID_NotificationManager,
                                 TypeSafeParams( IConnectionPointContainer, &pcpc )
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    psp->Release();        // release promptly
    psp = NULL;

    //
    //  Find the callback interface connection point.
    //

    hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &pcp ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcp->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Get the name of the node to contact.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              reinterpret_cast< IUnknown ** >( &psi )
                              ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectTo_GetObject_Failed, hr );
        goto Cleanup;
    }

    TraceSysFreeString( m_bstrName );
    m_bstrName = NULL;

    hr = THR( psi->GetName( &m_bstrName ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectTo_GetName_Failed, hr );
        goto Cleanup;
    }

    //
    //  Find out the type of object we are going to connect to (cluster or node).
    //

    hr = THR( psi->GetType( &m_clsidType ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectTo_GetType_Failed, hr );
        goto Cleanup;
    }

    //
    //  Figure out where to logging information in the UI.
    //

    if ( IsEqualIID( m_clsidType, CLSID_NodeType ) )
    {
        CopyMemory( &m_clsidMajor, &TASKID_Major_Establish_Connection, sizeof(m_clsidMajor) );
    }
    else if ( IsEqualIID( m_clsidType, CLSID_ClusterConfigurationType ) )
    {
        CopyMemory( &m_clsidMajor, &TASKID_Major_Checking_For_Existing_Cluster, sizeof(m_clsidMajor) );
    }
    else
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    }

    //
    //  Create a binding string.
    //

    TraceSysFreeString( m_bstrBindingString );
    m_bstrBindingString = NULL;

    hr = THR( HrCreateBinding( m_pcccb, &m_clsidMajor, m_bstrName, &m_bstrBindingString ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectTo_CreateBinding_Failed, hr );
        goto Cleanup;
    }

    //
    //  Connect to cluster/node.
    //

    m_hCluster = OpenCluster( m_bstrBindingString );
    if ( m_hCluster == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError( ) ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectTo_OpenCluster_Failed, hr );
        goto Cleanup;
    }

Cleanup:
    //  This should be released first... always!
    if ( psp != NULL )
    {
        psp->Release( );
    } // if: psp

    if ( pom != NULL )
    {
        pom->Release();
    } // if: pom

    if ( psi != NULL )
    {
        psi->Release();
    } // if: psi

    if ( pcpc != NULL )
    {
        pcpc->Release( );
    } // if: pcpc

    if ( pcp != NULL )
    {
        pcp->Release( );
    } // if: pcp

    HRETURN( hr );

} //*** CConfigClusApi::ConnectTo()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::ConnectToObject()
//
//  Description:
//
//  Arguments
//    OBJECTCOOKIE cookieIn,  The Object Cookie.
//    REFIID riidIn,          The IID. of the interface
//    LPUNKNOWN * ppunkOut    The return pointer
//
//  Description:
//    Connects to the given object.
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::ConnectToObject(
    OBJECTCOOKIE    cookieIn,
    REFIID          riidIn,
    LPUNKNOWN *     ppunkOut
    )
{
    TraceFunc( "[IConfigClusApi]" );

    HRESULT hr;
    CLSID   clsid;

    IServiceProvider *  psp;

    IObjectManager * pom = NULL;
    IStandardInfo *  psi = NULL;

    //
    // Check the parameters.
    //

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    //
    //  Check my state.
    //

    if ( m_hCluster == NULL )
        goto NotInitialized;

    //
    //  Retrieve the managers needs for the task ahead.
    //

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IServiceProvider,
                                reinterpret_cast< void ** >( &psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( psp->QueryService( CLSID_ObjectManager,
                                 TypeSafeParams( IObjectManager, &pom )
                                 ) );
    psp->Release();    // release promptly
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Retrieve the type of the object.
    //

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              cookieIn,
                              reinterpret_cast< IUnknown ** >( &psi )
                              ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectToObject_GetObject_Failed, hr );
        goto Cleanup;
    }

    hr = THR( psi->GetType( &clsid ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectToObject_GetType_Failed, hr );
        goto Cleanup;
    }

    if ( !IsEqualIID( clsid, CLSID_NodeType )
      && !IsEqualIID( clsid, CLSID_ClusterType )
       )
    {
        hr = THR( E_INVALIDARG );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectToObject_InvalidCookie, hr );
        goto Cleanup;
    }

    //
    //  Return the requested interface.
    //

    hr = THR( QueryInterface( riidIn, reinterpret_cast<void**>( ppunkOut ) ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectToObject_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:
    if ( pom != NULL )
    {
        pom->Release();
    } // if: pom

    if ( psi != NULL )
    {
        psi->Release();
    } // if: psi

    HRETURN( hr );

NotInitialized:
    hr = THR( OLE_E_BLANK );    // the error text is better than the message id.
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_ConnectToObject_NotInitialized, hr );
    goto Cleanup;

} //*** CConfigClusApi::ConnectToObject()


//****************************************************************************
//
// IClusCfgServer
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::GetClusterNodeInfo()
//
//  Description:
//
//  Arguments
//    IClusCfgNodeInfo ** ppClusterNodeInfoOut         The Node Info object.
//
//  Description:
//    Returns the Node Info of the Cluster.
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::GetClusterNodeInfo(
    IClusCfgNodeInfo ** ppClusterNodeInfoOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr;
    LPWSTR  psz;

    BSTR    bstrDomain = NULL;

    IUnknown * punk = NULL;

    //
    // Check for valid parameters.
    //

    if ( ppClusterNodeInfoOut == NULL )
        goto InvalidPointer;

    //
    //  Check my state
    //

    if ( m_hCluster == NULL )
        goto NotInitialized;

    //
    //  Figure out the domain name.
    //

    psz = wcschr( m_bstrName, L'.' );
    if ( psz == NULL )
    {
        bstrDomain = TraceSysAllocString( L"" );
        // error checked below
    }
    else
    {
        psz ++; // move past the dot

        bstrDomain = TraceSysAllocString( psz );
        // error checked below
    }

    if( bstrDomain == NULL )
        goto OutOfMemory;

    //
    // Create the Node Info Object.
    //

    if ( IsEqualIID( m_clsidType, CLSID_NodeType ) )
    {
        hr = THR( CProxyCfgNodeInfo::S_HrCreateInstance( &punk,
                                                         static_cast< IConfigurationConnection * >( this ),
                                                         &m_hCluster,
                                                         &m_clsidMajor,
                                                         m_bstrName,
                                                         bstrDomain
                                                         ) );
        if ( FAILED( hr ) )
        {
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterNodeInfo_Create_CProxyCfgNodeInfo, hr );
            goto Cleanup;
        }
    }
    else
    {
        hr = THR( CProxyCfgNodeInfo::S_HrCreateInstance( &punk,
                                                         static_cast< IConfigurationConnection * >( this ),
                                                         &m_hCluster,
                                                         &m_clsidMajor,
                                                         NULL,          // not open by a node name
                                                         bstrDomain
                                                         ) );
        if ( FAILED( hr ) )
        {
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterNodeInfo_Create_CProxyCfgNodeInfo, hr );
            goto Cleanup;
        }
    }

    //
    // Done.  Return the interface.
    //

    hr = THR( punk->TypeSafeQI( IClusCfgNodeInfo, ppClusterNodeInfoOut ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterNodeInfo_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:

    TraceSysFreeString( bstrDomain );

    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

NotInitialized:
    hr = THR( OLE_E_BLANK );    // the error text is better than the message id.
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterNodeInfo_NotInitialized, hr );
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterNodeInfo_InvalidPointer, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterNodeInfo_OutOfMemory, hr );
    goto Cleanup;

} //*** CConfigClusApi::GetClusterNodeInfo()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::GetManagedResourcesEnum()
//
//  Description:
//
//  Arguments
//    IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut
//         The Resources enumerator for the clusters.
//
//  Description:
//    Returns the resources enumerator for the cluster.
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::GetManagedResourcesEnum(
    IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr;

    IUnknown * punk = NULL;

    //
    // Check for valid parameters.
    //

    if ( ppEnumManagedResourcesOut == NULL )
        goto InvalidPointer;

    //
    //  Check my state
    //

    if ( m_hCluster == NULL )
        goto NotInitialized;

    //
    //  Create the resource enumer.
    //

    hr = THR( CEnumCfgResources::S_HrCreateInstance( &punk, static_cast< IConfigurationConnection * >( this ), &m_hCluster, &m_clsidMajor ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetManagedResourcesEnum_Create_CEnumCfgResources_Failed, hr );
        goto Cleanup;
    }

    //
    //  QI for the interface.
    //

    hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, ppEnumManagedResourcesOut ) );
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetManagedResourcesEnum_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release( );
    }

    HRETURN( hr );

NotInitialized:
    hr = THR( OLE_E_BLANK );    // the error text is better than the message id.
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetManagedResourcesEnum_NotInitialized, hr );
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetManagedResourcesEnum_InvalidPointer, hr );
    goto Cleanup;

} //*** CConfigClusApi::GetManagedResourcesEnum()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::GetNetworksEnum()
//
//  Description:
//    Returns the network enumerator for the cluster.
//
//  Arguments:
//    IEnumClusCfgNetworks ** ppEnumNetworksOut   The Network Enumerator
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::GetNetworksEnum(
    IEnumClusCfgNetworks ** ppEnumNetworksOut
    )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr;

    IUnknown * punk = NULL;

    //
    // Check for valid parameters.
    //

    if ( ppEnumNetworksOut == NULL )
        goto InvalidPointer;

    //
    //  Check my state
    //

    if ( m_hCluster == NULL )
        goto NotInitialized;

    //
    // Create an instance of the enumeratore and initialize it.
    //

    hr = THR( CEnumCfgNetworks::S_HrCreateInstance( &punk, static_cast< IConfigurationConnection * >( this ), &m_hCluster, &m_clsidMajor ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetNetworksEnum_Create_CEnumCfgNetworks_Failed, hr );
        goto Cleanup;
    }

    //
    // Return the Enum interface.
    //

    hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks , ppEnumNetworksOut) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetNetworksEnum_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );

NotInitialized:
    hr = THR( OLE_E_BLANK );    // the error text is better than the message id.
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetNetworksEnum_NotInitialized, hr );
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetNetworksEnum_InvalidPointer, hr );
    goto Cleanup;

} //*** CConfigClusApi::GetNetworksEnum()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::CommitChanges()
//
//  Description:
//      NOT IMPLEMENTED.
//
//  Arguments:
//
//  Return Values:
//      S_FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::CommitChanges( void )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CConfigClusApi::CommitChanges()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::GetBindingString()
//
//  Description:
//      Get the binding string.
//
//  Arguments:
//
//  Return Values:
//      S_FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::GetBindingString( BSTR * pbstrBindingStringOut )
{
    TraceFunc1( "[IClusCfgServer] pbstrBindingStringOut = %p", pbstrBindingStringOut );

    HRESULT hr = S_FALSE;

    if ( pbstrBindingStringOut == NULL )
        goto InvalidPointer;

    //  If local server, then there isn't a binding context.
    if ( m_bstrBindingString == NULL )
    {
        Assert( hr == S_FALSE );
        goto Cleanup;
    }

    *pbstrBindingStringOut = SysAllocString( m_bstrBindingString );
    if ( *pbstrBindingStringOut == NULL )
        goto OutOfMemory;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetBindingString_InvalidPointer, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetBindingString_OutOfMemory, hr );
    goto Cleanup;

} //*** CConfigClusApi::GetBindingString()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::SetBindingString()
//
//  Description:
//      Set the binding string.
//
//  Arguments:
//
//  Return Values:
//      S_FALSE
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::SetBindingString( LPCWSTR pcszBindingStringIn )
{
    TraceFunc( "[IClusCfgServer]" );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszBindingStringIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszBindingStringIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrBindingString );
    m_bstrBindingString = bstr;

Cleanup:

    HRETURN( hr );

} //*** CConfigClusApi::SetBindingString()


//****************************************************************************
//
// IClusCfgCapabilities
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::CanNodeBeClustered()
//
//  Description:
//      Returns whether the node can be clustered.
//
//  Arguments:
//
//  Return Values:
//      S_OK      True
//      S_FALSE   False
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::CanNodeBeClustered( void )
{
    TraceFunc( "[IClusCfgCapabilities]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CConfigClusApi::CanNodeBeClustered()


//****************************************************************************
//
// IClusCfgVerify
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::VerifyCredentials()
//
//  Description:
//      Validate the passed in credentials.
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          The credentials are valid.
//
//      S_FALSE
//          The credentials are not valid.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::VerifyCredentials(
    LPCWSTR pcszNameIn,
    LPCWSTR pcszDomainIn,
    LPCWSTR pcszPasswordIn
    )
{
    TraceFunc( "[IClusCfgVerify]" );

    HRESULT hr;

    BSTR    bstrNotification = NULL;

    THR( HrLoadStringIntoBSTR( g_hInstance,
                               IDS_WARNING_MINOR_BAD_CREDENTIALS,
                               &bstrNotification
                               ) );

    hr = THR( SendStatusReport( NULL,
                                m_clsidMajor,
                                TASKID_Minor_Bad_Credentials,
                                0,
                                1,
                                1,
                                S_FALSE,
                                bstrNotification,
                                NULL,
                                NULL
                                ) );

    TraceSysFreeString( bstrNotification );

    HRETURN( hr );

} //*** CConfigClusApi::VerifyCredentials()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::VerifyConnectionToCluster()
//
//  Description:
//      Verify that that this server is the same as the passed in server.
//
//  Arguments:
//      bstrServerNameIn
//
//  Return Value:
//      S_OK
//          This is the server.
//
//      S_FALSE
//          This is not the server.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::VerifyConnectionToCluster( LPCWSTR pcszClusterNameIn )
{
    TraceFunc1( "pcszClusterNameIn = '%ls'", pcszClusterNameIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // CConfigClusApi::VerifyConnection()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::VerifyConnectionToNode()
//
//  Description:
//      Verify that that this server is the same as the passed in server.
//
//  Arguments:
//      bstrServerNameIn
//
//  Return Value:
//      S_OK
//          This is the server.
//
//      S_FALSE
//          This is not the server.
//
//      other HRESULTs
//          The call failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::VerifyConnectionToNode( LPCWSTR pcszNodeNameIn )
{
    TraceFunc1( "pcszNodeNameIn = '%ls'", pcszNodeNameIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // CConfigClusApi::VerifyConnection()


//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CConfigClusApi::SendStatusReport()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConfigClusApi::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;
    FILETIME    ft;

    if ( pcszNodeNameIn == NULL )
    {
        pcszNodeNameIn = m_bstrName;
    }

    if ( pftTimeIn == NULL )
    {
        GetSystemTimeAsFileTime( &ft );
        pftTimeIn = &ft;
    } // if:

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             pcszDescriptionIn,
                                             pftTimeIn,
                                             pcszReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

}  //*** CConfigClusApi::SendStatusReport()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cenumcfgresources.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CEnumCfgResource.cpp
//
//  Description:
//      CEnumCfgResource implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "CEnumCfgResources.h"
#include "CResourcePhysicalDisk.h"

DEFINE_THISCLASS("CEnumCfgResources")


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCfgResources::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCfgResources::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown * punkOuterIn,
    HCLUSTER * phClusterIn,
    CLSID * pclsidMajorIn
    )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    CEnumCfgResources * pcc = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pcc = new CEnumCfgResources;
    if ( pcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pcc->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( pcc != NULL )
    {
        pcc->Release();
    } // if:

    HRETURN( hr );

} //*** CEnumCfgResources::S_HrCreateInstance( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumCfgResources::CEnumCfgResources( void )
//
//////////////////////////////////////////////////////////////////////////////
CEnumCfgResources::CEnumCfgResources( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_cRef == 1 );
    Assert( m_punkOuter == NULL );
    Assert( m_phCluster == NULL );
    Assert( m_pclsidMajor == NULL );
    Assert( m_pcccb == NULL );
    Assert( m_hClusEnum == NULL );
    Assert( m_dwIndex == 0 );

    TraceFuncExit();

} //*** CEnumCfgResources::CEnumCfgResources( )

//////////////////////////////////////////////////////////////////////////////
//
//  CEnumCfgResources::~CEnumCfgResources( )
//
//////////////////////////////////////////////////////////////////////////////
CEnumCfgResources::~CEnumCfgResources( )
{
    TraceFunc( "" );

    // m_cRef

    if ( m_punkOuter != NULL )
    {
        m_punkOuter->Release( );
    }

    // m_phCluster - DO NOT CLOSE!

    // m_pclsidMajor

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    if ( m_hClusEnum != NULL )
    {
        ClusterCloseEnum( m_hClusEnum );
    }

    // m_dwIndex

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CEnumCfgResources::~CEnumCfgResources()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CEnumCfgResources::HrInit( )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CEnumCfgResources::HrInit(
    IUnknown * punkOuterIn,
    HCLUSTER * phClusterIn,
    CLSID *    pclsidMajorIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef( );
    }

    if ( phClusterIn == NULL )
        goto InvalidArg;

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    if ( punkOuterIn != NULL )
    {
        hr = THR( punkOuterIn->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    //
    //  Open the enumer.
    //

    m_hClusEnum = ClusterOpenEnum( *m_phCluster, CLUSTER_ENUM_RESOURCE );
    if ( m_hClusEnum == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError( ) ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_Resources_HrInit_ClusterOpenEnum_Failed, hr );
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** CEnumCfgResources::HrInit()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CEnumCfgResources::QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgResources::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IEnumClusCfgManagedResources * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IEnumClusCfgManagedResources ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgManagedResources, this, 0 );
        hr = S_OK;
    }

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CEnumCfgResources::QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumCfgResources::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCfgResources::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CEnumCfgResources::AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP_(ULONG)
//  CEnumCfgResources::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CEnumCfgResources::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN( 0 );

} //*** CEnumCfgResources::Release( )


//****************************************************************************
//
//  IEnumClusCfgManagedResources
//
//****************************************************************************

//
//
//
STDMETHODIMP
CEnumCfgResources::Next(
    ULONG                           cNumberRequestedIn,
    IClusCfgManagedResourceInfo **  rgpManagedResourceInfoOut,
    ULONG *                         pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr;
    ULONG   cFetched = 0;

    if ( rgpManagedResourceInfoOut == NULL )
        goto InvalidPointer;

    for( ; cFetched < cNumberRequestedIn; m_dwIndex++ )
    {
        hr = STHR( HrGetItem( &(rgpManagedResourceInfoOut[ cFetched ]) ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_FALSE )
            continue; // resource was not type physical disk

        if (  hr == MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NO_MORE_ITEMS ) )
            break;  // no more items

        cFetched ++;

    } // for: cFetched

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    } // if:

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    } // if:
    else
    {
        hr = S_OK;
    }

Cleanup:
    if ( FAILED( hr ) )
    {
        ULONG idx;

        for ( idx = 0; idx < cFetched; idx++ )
        {
            (rgpManagedResourceInfoOut[ idx ])->Release();
        } // for:

        cFetched = 0;
    } // if:

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_Resources_Next_InvalidPointer, hr );
    goto Cleanup;
}

//
//
//
STDMETHODIMP
CEnumCfgResources::Reset( void )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    m_dwIndex = 0;

    HRETURN( hr );
}

//
//
//
STDMETHODIMP
CEnumCfgResources::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = S_OK;

    //
    //  TODO:   GalenB  27 SEPT 2000
    //
    //  Need to ensure that we don't run off the end of the enumeration.
    //

    m_dwIndex += cNumberToSkipIn;

    HRETURN( hr );
}

//
//
//
STDMETHODIMP
CEnumCfgResources::Clone( IEnumClusCfgManagedResources ** ppEnumManagedResourcesOut )
{
    TraceFunc( "[IEnumClusCfgManagedResources]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );
}

//
//
//
STDMETHODIMP
CEnumCfgResources::Count( DWORD * pnCountOut)
{

    TraceFunc( "[IEnumClusCfgManagedResources]" );

    Assert( m_hClusEnum != NULL );
    HRESULT hr = S_OK;
    
    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = ClusterGetEnumCount(m_hClusEnum);

Cleanup:
    HRETURN( hr );
}

//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnumCfgResources::SendStatusReport()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CEnumCfgResources::SendStatusReport(
    BSTR        bstrNodeNameIn,
    CLSID       clsidTaskMajorIn,
    CLSID       clsidTaskMinorIn,
    ULONG       ulMinIn,
    ULONG       ulMaxIn,
    ULONG       ulCurrentIn,
    HRESULT     hrStatusIn,
    BSTR        bstrDescriptionIn,
    FILETIME *  pftTimeIn,
    BSTR        bstrReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( bstrNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             bstrDescriptionIn,
                                             pftTimeIn,
                                             bstrReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

}  //*** CEnumCfgResources::SendStatusReport()


//****************************************************************************
//
// Local methods.
//
//****************************************************************************


//
//
//
HRESULT
CEnumCfgResources::HrGetItem(
    IClusCfgManagedResourceInfo **  ppManagedResourceInfoOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;
    DWORD   dwTypeDummy;
    DWORD   cchName = 64;   // good starting value
    BSTR    bstrName = NULL;

    IUnknown * punk = NULL;

    Assert( ppManagedResourceInfoOut != NULL );
    Assert( m_hClusEnum != NULL );

    bstrName = TraceSysAllocStringLen( NULL, cchName );
    if ( bstrName == NULL )
        goto OutOfMemory;
    cchName ++; // SysAllocStringLen allocates cchName + 1.

    // We are wrapping this a cchName should be significantly large enough to handle
    // most of our testing.
    sc = ClusterEnum( m_hClusEnum, m_dwIndex, &dwTypeDummy, bstrName, &cchName );
    if ( sc == ERROR_MORE_DATA )
    {
        //
        //  Our "typical" buffer is too small. Try make it to the size ClusterEnum
        //  returned.
        //

        TraceSysFreeString( bstrName );

        bstrName = TraceSysAllocStringLen( NULL, cchName );
        if ( bstrName == NULL )
            goto OutOfMemory;
        cchName ++; // SysAllocStringLen allocates cchName + 1.

        sc = TW32( ClusterEnum( m_hClusEnum, m_dwIndex, &dwTypeDummy, bstrName, &cchName ) );
    }
    else if ( sc == ERROR_NO_MORE_ITEMS )
    {
        hr = MAKE_HRESULT( 0, FACILITY_WIN32, ERROR_NO_MORE_ITEMS );
        goto Cleanup;
    }

    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_Resources_HrGetItem_ClusterEnum_Failed, hr );
        goto Cleanup;
    }

    Assert( dwTypeDummy == CLUSTER_ENUM_RESOURCE );

    //
    // Create the requested object and store it.
    //

    hr = STHR( CResourcePhysicalDisk::S_HrCreateInstance( &punk,
                                                          m_punkOuter,
                                                          m_phCluster,
                                                          m_pclsidMajor,
                                                          bstrName
                                                          ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrGetItem_Create_CResourcePhysicalDisk_Failed, hr );
        goto Cleanup;
    }

    if ( hr == S_FALSE )
        goto Cleanup;   // This means that the object was not a physical disk resource.

    //
    //  The CResourcePhysicalDisk takes ownership of the BSTR
    //

    bstrName = NULL;

    //
    //  QI for the interface to return.
    //

    hr = THR( punk->TypeSafeQI( IClusCfgManagedResourceInfo, ppManagedResourceInfoOut ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_Resources_HrGetItem_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:

    TraceSysFreeString( bstrName );

    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_Resources_HrGetItem_OutOfMemory, hr );
    goto Cleanup;

} // *** HrGetItem( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgclusterinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgClusterInfo.h
//
//  Description:
//      CProxyCfgClusterInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProxyCfgClusterInfo
//
//  Description:
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProxyCfgClusterInfo
    : public IClusCfgClusterInfo
{
private:

    LONG                    m_cRef;                 //  Reference counter
    IUnknown *              m_punkOuter;            //  Interface to Outer Proxy object
    IClusCfgCallback *      m_pcccb;                //  Callback interface
    HCLUSTER *              m_phCluster;            //  Pointer to the handle of the cluster.
    CLSID *                 m_pclsidMajor;          //  CLSID to use to log errors to the UI.

    BSTR                    m_bstrClusterName;      //  Cluster FQDN name
    ULONG                   m_ulIPAddress;          //  Cluster IP Address
    ULONG                   m_ulSubnetMask;         //  Cluster Network mask
    BSTR                    m_bstrNetworkName;      //  Cluster Network name
    IClusCfgCredentials *   m_pccc;                 //  Cluster Credentials object
    BSTR                    m_bstrBindingString;    //  Cluster binding string.

    CProxyCfgClusterInfo( void );
    ~CProxyCfgClusterInfo( void );

    // Private copy constructor to prevent copying.
    CProxyCfgClusterInfo( const CProxyCfgClusterInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CProxyCfgClusterInfo & operator = ( const CProxyCfgClusterInfo & nodeSrc );

    HRESULT HrInit( IUnknown * punkOuterIn, HCLUSTER * phClusterIn, CLSID * pclsidMajorIn, LPCWSTR pcszDomainIn );
    HRESULT HrLoadCredentials( void );

public:
    static HRESULT S_HrCreateInstance(
                              IUnknown **   ppunkOut
                            , IUnknown *    punkOuterIn
                            , HCLUSTER *    phClusterIn
                            , CLSID *       pclsidMajorIn
                            , LPCWSTR       pcszDomainIn
                            );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgClusterInfo
    STDMETHOD( SetCommitMode )( ECommitMode eccbNewModeIn );
    STDMETHOD( GetCommitMode )( ECommitMode * peccmCurrentModeOut );

    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( GetIPAddress )( DWORD * pdwIPAddress );
    STDMETHOD( GetSubnetMask )( DWORD * pdwNetMask  );
    STDMETHOD( GetNetworkInfo )( IClusCfgNetworkInfo ** ppICCNetInfoOut );
    STDMETHOD( GetClusterServiceAccountCredentials )( IClusCfgCredentials ** ppICCCredentials );
    STDMETHOD( GetBindingString )( BSTR * pbstrBindingStringOut );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( SetIPAddress )( DWORD dwIPAddressIn );
    STDMETHOD( SetSubnetMask )( DWORD dwNetMaskIn );
    STDMETHOD( SetNetworkInfo )( IClusCfgNetworkInfo * pICCNetInfoIn );
    STDMETHOD( SetBindingString )( LPCWSTR bstrBindingStringIn );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; //*** Class CProxyCfgClusterInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgclusterinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ConfigClusApi.cpp
//
//  Description:
//      CConfigClusApi implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "CProxyCfgClusterInfo.h"
#include "CClusCfgCredentials.h"
#include "CProxyCfgNetworkInfo.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CProxyCfgClusterInfo")

//
//
//
HRESULT
CProxyCfgClusterInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszDomainIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    CProxyCfgClusterInfo *  pcc = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pcc = new CProxyCfgClusterInfo;
    if ( pcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pcc->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn, pcszDomainIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( pcc != NULL )
    {
        pcc->Release();
    } // if:

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::S_HrCreateInstance()


//
//
//
CProxyCfgClusterInfo::CProxyCfgClusterInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_cRef == 1 );
    Assert( m_punkOuter == NULL );
    Assert( m_pcccb == NULL );
    Assert( m_phCluster == NULL );
    Assert( m_pclsidMajor == NULL );

    Assert( m_bstrClusterName == NULL);
    Assert( m_ulIPAddress == 0 );
    Assert( m_ulSubnetMask == 0 );
    Assert( m_bstrNetworkName == NULL);
    Assert( m_pccc == NULL );
    Assert( m_bstrBindingString == NULL );

    TraceFuncExit();

} //*** CProxyCfgClusterInfo::CProxyCfgClusterInfo()

//
//
//
CProxyCfgClusterInfo::~CProxyCfgClusterInfo( void )
{
    TraceFunc( "" );

    //  m_cRef - noop

    if ( m_punkOuter != NULL )
    {
        m_punkOuter->Release( );
    }

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    } // if:

    //  m_phCluster - DO NOT CLOSE!

    //  m_pclsidMajor - noop

    TraceSysFreeString( m_bstrClusterName );

    // m_ulIPAddress

    // m_ulSubnetMask

    TraceSysFreeString( m_bstrNetworkName );
    TraceSysFreeString( m_bstrBindingString );

    if ( m_pccc != NULL )
    {
        m_pccc->Release( );
    }

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CProxyCfgClusterInfo::~CProxyCfgClusterInfo()

//
//
//
HRESULT
CProxyCfgClusterInfo::HrInit(
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszDomainIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    DWORD   sc;
    DWORD   cch;

    BSTR    bstrClusterName = NULL;

    CLUSTERVERSIONINFO cvi;

    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef( );
    }

    if ( phClusterIn == NULL )
        goto InvalidArg;

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    if ( punkOuterIn != NULL )
    {
        hr = THR( punkOuterIn->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    //
    //  Get the cluster's name and version info.
    //

    cvi.dwVersionInfoSize = sizeof(cvi);
    cch = 64;    //  arbitary starting buffer size

    bstrClusterName = TraceSysAllocStringLen( NULL, cch );
    if ( bstrClusterName == NULL )
        goto OutOfMemory;

    cch ++;  // SysAllocStringLen allocates an extra character

    sc = GetClusterInformation( *m_phCluster, bstrClusterName, &cch, &cvi );
    if ( sc == ERROR_MORE_DATA )
    {
        TraceSysFreeString( bstrClusterName );

        bstrClusterName = TraceSysAllocStringLen( NULL, cch );
        if ( bstrClusterName == NULL )
            goto OutOfMemory;

        cch ++;  // SysAllocStringLen allocates an extra character

        sc = GetClusterInformation( *m_phCluster, bstrClusterName, &cch, &cvi );
    }

    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_GetClusterInformation_Failed, hr );
        goto Cleanup;
    }

    // Give up ownership
    m_bstrClusterName = TraceSysAllocStringLen( NULL, SysStringLen( bstrClusterName ) + 1 + (UINT) wcslen( pcszDomainIn ) );
    if ( m_bstrClusterName == NULL )
        goto OutOfMemory;

    wcscpy( m_bstrClusterName, bstrClusterName );
    wcscat( m_bstrClusterName, L"." );
    wcscat( m_bstrClusterName, pcszDomainIn );

    Assert( m_bstrNetworkName == NULL );
    hr = THR( HrGetIPAddressOfCluster( *m_phCluster, &m_ulIPAddress, &m_ulSubnetMask, &m_bstrNetworkName ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( HrLoadCredentials( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = S_OK;

Cleanup:

    TraceSysFreeString( bstrClusterName );

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_ClusterInfo_HrInit_InvalidArg, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_ClusterInfo_HrInit_OutOfMemory, hr );
    goto Cleanup;

} //*** CProxyCfgClusterInfo::HrInit()

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgClusterInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IClusCfgClusterInfo * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgClusterInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgClusterInfo, this, 0 );
        hr = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CConfigClusApi::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProxyCfgClusterInfo:: [IUNKNOWN] AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CProxyCfgClusterInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CProxyCfgClusterInfo::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProxyCfgClusterInfo:: [IUNKNOWN] Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CProxyCfgClusterInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN( 0 );

} //*** CProxyCfgClusterInfo::Release()


//****************************************************************************
//
//  IClusCfgClusterInfo
//
//****************************************************************************

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
        goto InvalidPointer;

    *pbstrNameOut = SysAllocString( m_bstrClusterName );
    if ( *pbstrNameOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
    }

    CharLower( *pbstrNameOut );

Cleanup:

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2kProxy_ClusterInfo_GetName_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgClusterInfo::GetName()

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetIPAddress(
    DWORD * pdwIPAddress
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pdwIPAddress == NULL )
        goto InvalidPointer;

    *pdwIPAddress = m_ulIPAddress;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_ClusterInfo_GetIPAddress_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgClusterInfo::GetIPAddress()

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetSubnetMask(
    DWORD * pdwNetMask
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pdwNetMask == NULL )
        goto InvalidPointer;

    *pdwNetMask = m_ulSubnetMask;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_ClusterInfo_GetSubnetMask_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgClusterInfo::GetSubnetMask()

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetNetworkInfo(
    IClusCfgNetworkInfo ** ppICCNetInfoOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr;

    IUnknown * punk = NULL;

    if ( ppICCNetInfoOut == NULL )
        goto InvalidPointer;

    //
    // Create the network info object.
    //

    hr = THR( CProxyCfgNetworkInfo::S_HrCreateInstance( &punk,
                                                        m_punkOuter,
                                                        m_phCluster,
                                                        m_pclsidMajor,
                                                        m_bstrNetworkName
                                                        ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( IClusCfgNetworkInfo, ppICCNetInfoOut ) );

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetNetworkInfo_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgClusterInfo::GetNetworkInfo()


//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetClusterServiceAccountCredentials(
    IClusCfgCredentials ** ppICCCredentialsOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr;

    if ( ppICCCredentialsOut == NULL )
        goto InvalidPointer;

    hr = THR( m_pccc->TypeSafeQI( IClusCfgCredentials, ppICCCredentialsOut ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterServiceAccountCredentials_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgClusterInfo::GetClusterServiceAccountCredentials()

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetBindingString(
    BSTR * pbstrBindingStringOut
    )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( pbstrBindingStringOut == NULL )
        goto InvalidPointer;

    *pbstrBindingStringOut = SysAllocString( m_bstrBindingString );
    if ( *pbstrBindingStringOut == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
    }

Cleanup:

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2kProxy_ClusterInfo_GetBindingString_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgClusterInfo::GetBindingString()

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::SetCommitMode( ECommitMode ecmNewModeIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );
    Assert( ecmNewModeIn != cmUNKNOWN );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::SetCommitMode()

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::GetCommitMode( ECommitMode * pecmCurrentModeOut  )
{
    TraceFunc( "[IClusCfgClusterInfo]" );
    Assert( pecmCurrentModeOut != NULL );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::GetCommitMode()

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgClusterInfo] pcszNameIn = '%ls'", pcszNameIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::SetName()

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::SetIPAddress( DWORD dwIPAddressIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( dwIPAddressIn != m_ulIPAddress )
    {
        hr = THR( E_FAIL );
    }

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::SetIPAddress()

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::SetSubnetMask( DWORD dwNetMaskIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = S_OK;

    if ( dwNetMaskIn != m_ulSubnetMask )
    {
        hr = THR( E_FAIL );
    }

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::SetSubnetMask()

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::SetNetworkInfo( IClusCfgNetworkInfo * pICCNetInfoIn )
{
    TraceFunc( "[IClusCfgClusterInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::SetNetworkInfo()

//
//
//
STDMETHODIMP
CProxyCfgClusterInfo::SetBindingString( LPCWSTR pcszBindingStringIn )
{
    TraceFunc1( "[IClusCfgClusterInfo] pcszBindingStringIn = '%ls'", pcszBindingStringIn );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;

    if ( pcszBindingStringIn == NULL )
    {
        hr = THR( E_INVALIDARG );
        goto Cleanup;
    } // if:

    bstr = TraceSysAllocString( pcszBindingStringIn );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    TraceSysFreeString( m_bstrBindingString );
    m_bstrBindingString = bstr;

Cleanup:

    HRETURN( hr );

} //*** CProxyCfgClusterInfo::SetName()


//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgClusterInfo::SendStatusReport()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgClusterInfo::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             pcszDescriptionIn,
                                             pftTimeIn,
                                             pcszReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

}  //*** CProxyCfgClusterInfo::SendStatusReport()


//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgClusterInfo::HrLoadCredentials()
//
//  Description:
//
//
//  Arguments:
//
//
//  Return Value:
//
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CProxyCfgClusterInfo::HrLoadCredentials( void )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    SC_HANDLE                   schSCM = NULL;
    SC_HANDLE                   schClusSvc = NULL;
    DWORD                       sc;
    DWORD                       cbpqsc = 128;
    DWORD                       cbRequired;
    QUERY_SERVICE_CONFIG *      pqsc = NULL;
	IUnknown *					punk = NULL;
    IClusCfgSetCredentials *    piccsc = NULL;

    schSCM = OpenSCManager( m_bstrClusterName, NULL, GENERIC_READ );
    if ( schSCM == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrLoadCredentials_OpenSCManager_Failed, hr );
        goto Cleanup;
    } // if:

    schClusSvc = OpenService( schSCM, L"ClusSvc", GENERIC_READ );
    if ( schClusSvc == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrLoadCredentials_OpenService_Failed, hr );
        goto Cleanup;
    } // if:

    for ( ; ; )
    {
        BOOL fRet;

        pqsc = (QUERY_SERVICE_CONFIG *) TraceAlloc( 0, cbpqsc );
        if ( pqsc == NULL )
            goto OutOfMemory;

        fRet = QueryServiceConfig( schClusSvc, pqsc, cbpqsc, &cbRequired );
        if ( !fRet )
        {
            sc = GetLastError();
            if ( sc == ERROR_INSUFFICIENT_BUFFER )
            {
                TraceFree( pqsc );
                pqsc = NULL;
                cbpqsc = cbRequired;
                continue;
            } // if:
            else
            {
                hr = HRESULT_FROM_WIN32( TW32( sc ) );
                SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrLoadCredentials_QueryServiceConfig_Failed, hr );
                goto Cleanup;
            } // else:
        } // if:
        else
        {
            break;
        } // else:
    } // for:

    Assert( m_pccc == NULL );

    hr = THR( CClusCfgCredentials::S_HrCreateInstance( &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

	hr = THR( punk->TypeSafeQI( IClusCfgCredentials, &m_pccc ) );
	if ( FAILED( hr ) )
		goto Cleanup;

    hr = THR( m_pccc->TypeSafeQI( IClusCfgSetCredentials, &piccsc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    hr = THR( piccsc->SetDomainCredentials( pqsc->lpServiceStartName ) );

Cleanup:
	if ( punk != NULL )
	{
		punk->Release( );
	}
    if ( schClusSvc != NULL )
    {
        CloseServiceHandle( schClusSvc );
    } // if:

    if ( schSCM != NULL )
    {
        CloseServiceHandle( schSCM );
    } // if:

    if ( pqsc != NULL )
    {
        TraceFree( pqsc );
    } // if:

    if ( piccsc != NULL )
    {
        piccsc->Release();
    } // if:

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrLoadCredentials_OutOfMemory, hr );
    goto Cleanup;

} //*** CProxyCfgClusterInfo::HrLoadCredentials()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgipaddressinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgIPAddressInfo.cpp
//
//  Description:
//      CProxyCfgIPAddressInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CProxyCfgIPAddressInfo.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CProxyCfgIPAddressInfo")


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgIPAddressInfo::S_HrCreateInstance()
//
//  Description:
//      Create a CProxyCfgIPAddressInfo instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CProxyCfgIPAddressInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    ULONG       ulIPAddressIn,
    ULONG       ulSubnetMaskIn
    )
{
    TraceFunc( "" );

    HRESULT                     hr = S_OK;
    CProxyCfgIPAddressInfo *    pcc = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pcc = new CProxyCfgIPAddressInfo;
    if ( pcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pcc->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn, ulIPAddressIn, ulSubnetMaskIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( pcc != NULL )
    {
        pcc->Release();
    } // if:

    HRETURN( hr );

} //*** CProxyCfgIPAddressInfo::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgIPAddressInfo::CProxyCfgIPAddressInfo()
//
//  Description:
//      Constructor of the CProxyCfgIPAddressInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgIPAddressInfo::CProxyCfgIPAddressInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_pcccb == NULL );

    TraceFuncExit();

} //*** CProxyCfgIPAddressInfo::CProxyCfgIPAddressInfo()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgIPAddressInfo::~CProxyCfgIPAddressInfo()
//
//  Description:
//      Destructor of the CProxyCfgIPAddressInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgIPAddressInfo::~CProxyCfgIPAddressInfo( void )
{
    TraceFunc( "" );

    //  m_cRef - noop

    if ( m_punkOuter != NULL )
    {
        m_punkOuter->Release( );
    }

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    } // if:

    //  m_phCluster - DO NOT CLOSE!

    //  m_pclsidMajor - noop

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CProxyCfgIPAddressInfo::~CProxyCfgIPAddressInfo()

//
//
//
HRESULT
CProxyCfgIPAddressInfo::HrInit(
    IUnknown * punkOuterIn,
    HCLUSTER * phClusterIn,
    CLSID * pclsidMajorIn,
    ULONG  ulIPAddressIn,
    ULONG  ulSubnetMaskIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef( );
    }

    if ( phClusterIn == NULL )
        goto InvalidArg;

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    if ( punkOuterIn != NULL )
    {
        hr = THR( punkOuterIn->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    m_ulIPAddress = ulIPAddressIn;
    m_ulSubnetMask = ulSubnetMaskIn;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_IPAddressInfo_HrInit_InvalidArg, hr );
    goto Cleanup;

} // *** HrInit


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgIPAddressInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgIPAddressInfo:: [INKNOWN] QueryInterface()
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgIPAddressInfo::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IClusCfgIPAddressInfo * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgIPAddressInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgIPAddressInfo, this, 0 );
        hr = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CProxyCfgIPAddressInfo::QueryInterface()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProxyCfgIPAddressInfo:: [IUNKNOWN] AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CProxyCfgIPAddressInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CProxyCfgIPAddressInfo::AddRef()

    // IClusSetHandleProvider

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProxyCfgIPAddressInfo:: [IUNKNOWN] Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CProxyCfgIPAddressInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN( 0 );

} //*** CProxyCfgIPAddressInfo::Release()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgIPAddressInfo -- IClusCfgIPAddressInfo interface.
/////////////////////////////////////////////////////////////////////////////


//
//
//
STDMETHODIMP
CProxyCfgIPAddressInfo::GetUID(
    BSTR * pbstrUIDOut
    )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr;
    DWORD   sc;
    DWORD   ulNetwork = m_ulIPAddress & m_ulSubnetMask;

    LPWSTR  psz = NULL;

    if ( pbstrUIDOut == NULL )
        goto InvalidPointer;

    sc = TW32( ClRtlTcpipAddressToString( ulNetwork, &psz ) ); // KB: Allocates to psz using LocalAlloc().
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_IPAddressInfo_GetUID_ClRtlTcpipAddressToString_Failed, hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( psz );
    if ( *pbstrUIDOut == NULL )
        goto OutOfMemory;

    hr = S_OK;

Cleanup:
    if ( psz != NULL )
    {
        LocalFree( psz ); // KB: Don't use TraceFree() here!
    } // if:

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2kProxy_IPAddressInfo_GetName_InvalidPointer, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_IPAddressInfo_GetUID_OutOfMemory, hr );
    goto Cleanup;

} //***CProxyCfgIPAddressInfo::GetUID()

//
//
//
STDMETHODIMP
CProxyCfgIPAddressInfo::GetIPAddress(
    ULONG * pulDottedQuadOut
    )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr;

    if ( pulDottedQuadOut == NULL )
        goto InvalidPointer;

    *pulDottedQuadOut = m_ulIPAddress;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetIPAddress_InvalidPointer, hr );
    goto Cleanup;

} //***CProxyCfgIPAddressInfo::GetIPAddress()

//
//
//
STDMETHODIMP
CProxyCfgIPAddressInfo::SetIPAddress(
    ULONG ulDottedQuadIn
    )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //***CProxyCfgIPAddressInfo::SetIPAddress()

//
//
//
STDMETHODIMP
CProxyCfgIPAddressInfo::GetSubnetMask(
    ULONG * pulDottedQuadOut
    )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr;

    if ( pulDottedQuadOut == NULL )
        goto InvalidPointer;

    *pulDottedQuadOut = m_ulSubnetMask;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetSubnetMask_InvalidPointer, hr );
    goto Cleanup;

} //***CProxyCfgIPAddressInfo::GetSubnetMask()

//
//
//
STDMETHODIMP
CProxyCfgIPAddressInfo::SetSubnetMask(
    ULONG ulDottedQuadIn
    )
{
    TraceFunc( "[IClusCfgIPAddressInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //***CProxyCfgIPAddressInfo::SetSubnetMask()



//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgIPAddressInfo::SendStatusReport()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgIPAddressInfo::SendStatusReport(
    BSTR        bstrNodeNameIn,
    CLSID       clsidTaskMajorIn,
    CLSID       clsidTaskMinorIn,
    ULONG       ulMinIn,
    ULONG       ulMaxIn,
    ULONG       ulCurrentIn,
    HRESULT     hrStatusIn,
    BSTR        bstrDescriptionIn,
    FILETIME *  pftTimeIn,
    BSTR        bstrReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( bstrNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             bstrDescriptionIn,
                                             pftTimeIn,
                                             bstrReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

}  //*** CProxyCfgIPAddressInfo::SendStatusReport()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgnetworkinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgNetworkInfo.cpp
//
//  Description:
//      CProxyCfgNetworkInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB) 02-SEP-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CProxyCfgNetworkInfo.h"
#include "CProxyCfgIPAddressInfo.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CProxyCfgNetworkInfo")


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNetworkInfo::S_HrCreateInstance()
//
//  Description:
//      Create a CProxyCfgNetworkInfo instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CProxyCfgNetworkInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszNetworkNameIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr S_OK;
    CProxyCfgNetworkInfo *  pcc = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pcc = new CProxyCfgNetworkInfo;
    if ( pcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pcc->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn, pcszNetworkNameIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( pcc != NULL )
    {
        pcc->Release();
    } // if:

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNetworkInfo::CProxyCfgNetworkInfo()
//
//  Description:
//      Constructor of the CProxyCfgNetworkInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgNetworkInfo::CProxyCfgNetworkInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_cRef == 1 );
    Assert( m_punkOuter == NULL );
    Assert( m_pcccb == NULL );
    Assert( m_phCluster == NULL );
    Assert( m_pclsidMajor == NULL );
    //  m_cplNetwork??
    //  m_cplNetworkRO??

    TraceFuncExit();

} //*** CProxyCfgNetworkInfo::CProxyCfgNetworkInfo()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNetworkInfo::~CProxyCfgNetworkInfo()
//
//  Description:
//      Destructor of the CProxyCfgNetworkInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgNetworkInfo::~CProxyCfgNetworkInfo( void )
{
    TraceFunc( "" );

    //  m_cRef - noop

    if ( m_punkOuter != NULL )
    {
        m_punkOuter->Release( );
    }

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    } // if:

    //  m_phCluster - DO NOT CLOSE

    //  m_pclsidMajor - noop

    //  m_cplNetwork - has own dtor code

    //  m_cplNetworkRO - has own dtor code

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CProxyCfgNetworkInfo::~CProxyCfgNetworkInfo()


//
//
//
HRESULT
CProxyCfgNetworkInfo::HrInit(
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszNetworkNameIn
    )
{
    TraceFunc( "" );

    HRESULT  hr;
    DWORD    sc;
    HNETWORK hNetwork = NULL;


    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef( );
    }

    if ( phClusterIn == NULL )
        goto InvalidArg;

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    if ( punkOuterIn != NULL )
    {
        hr = THR( punkOuterIn->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if ( pcszNetworkNameIn == NULL )
        goto InvalidArg;

    //
    //  Gather network properties
    //

    hNetwork = OpenClusterNetwork( *m_phCluster, pcszNetworkNameIn );
    if ( hNetwork == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError( ) ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_OpenClusterNetInterface_Failed, hr );
        goto Cleanup;
    }

    //
    // Retrieve the properties.
    //

    sc = TW32( m_cplNetwork.ScGetNetworkProperties( hNetwork, CLUSCTL_NETWORK_GET_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetNetworkProperties_Failed, hr );
        goto Cleanup;
    } // if:

    //
    //  Rettrieve the READ ONLY properties
    //

    sc = TW32( m_cplNetworkRO.ScGetNetworkProperties( hNetwork, CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetNetworkProperties_Failed, hr );
        goto Cleanup;
    } // if:


    hr = S_OK;

Cleanup:
    if ( hNetwork != NULL )
    {
        CloseClusterNetwork( hNetwork );
    }

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_NetworkInfo_HrInit_InvalidArg, hr );
    goto Cleanup;

} //*** CProxyCfgNetworkInfo::HrInit()

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgNetworkInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNetworkInfo:: [INKNOWN] QueryInterface()
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgNetworkInfo::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IClusCfgNetworkInfo * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgNetworkInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgNetworkInfo, this, 0 );
        hr = S_OK;
    } // else if:
    else if ( IsEqualIID( riid, IID_IEnumClusCfgIPAddresses ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgIPAddresses, this, 0 );
        hr = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CConfigClusApi::QueryInterface()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProxyCfgNetworkInfo:: [IUNKNOWN] AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CProxyCfgNetworkInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CProxyCfgNetworkInfo::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProxyCfgNetworkInfo:: [IUNKNOWN] Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CProxyCfgNetworkInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} //*** CProxyCfgNetworkInfo::Release()

//*************************************************************************//

/////////////////////////////////////////////////////////////////////////////
// CProxyCfgNetworkInfo -- IClusCfgNetworkInfo interface.
/////////////////////////////////////////////////////////////////////////////

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::GetUID( BSTR * pbstrUIDOut )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr ;
    DWORD   sc;
    LPWSTR  psz = NULL;
    DWORD   ulIPAddress;
    DWORD   ulSubnetMask;
    DWORD   ulNetwork;

    if ( pbstrUIDOut == NULL )
        goto InvalidPointer;

    sc = TW32( m_cplNetworkRO.ScMoveToPropertyByName( L"Address" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ScMoveToPropetyByName_Address_Failed, hr );
        goto Cleanup;
    }

    Assert( m_cplNetworkRO.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( m_cplNetworkRO.CbhCurrentValue( ).pStringValue->sz, &ulIPAddress ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ClRtlTcpipStringToAddress_Address_Failed, hr );
        goto Cleanup;
    }

    sc = TW32( m_cplNetworkRO.ScMoveToPropertyByName( L"AddressMask" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ScMoveToPropetyByName_AddressMask_Failed, hr );
        goto Cleanup;
    }

    Assert( m_cplNetworkRO.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( m_cplNetworkRO.CbhCurrentValue( ).pStringValue->sz, &ulSubnetMask ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ClRtlTcpipStringToAddress_AddressMask_Failed, hr );
        goto Cleanup;
    }

    ulNetwork = ulIPAddress & ulSubnetMask;

    sc = TW32( ClRtlTcpipAddressToString( ulNetwork, &psz ) ); // KB: Allocates to psz using LocalAlloc().
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ClRtlTcpipAddressToString_Failed, hr );
        goto Cleanup;
    } // if:

    *pbstrUIDOut = SysAllocString( psz );
    if ( *pbstrUIDOut == NULL )
        goto OutOfMemory;

    hr = S_OK;

Cleanup:
    if ( psz != NULL )
    {
        LocalFree( psz ); // KB: Don't use TraceFree() here!
    } // if:

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_NetworkInfo_GetUID_InvalidPointer, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_NetworkInfo_GetUID_OutOfMemory, hr );
    goto Cleanup;

} //*** CProxyCfgNetworkInfo::GetUID()

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;
    DWORD   sc;

    if ( pbstrNameOut == NULL )
        goto InvalidPointer;

    //
    //  "Major Version"
    //

    sc = TW32( m_cplNetworkRO.ScMoveToPropertyByName( L"Name" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_NetworkInfo_GetName_ScMoveToPropertyByName_MajorVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplNetworkRO.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    *pbstrNameOut = SysAllocString( m_cplNetworkRO.CbhCurrentValue( ).pStringValue->sz );
    if ( *pbstrNameOut == NULL )
        goto OutOfMemory;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_INVALIDARG );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2kProxy_NetworkInfo_GetName_InvalidPointer, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_NetworkInfo_GetName_OutOfMemory, hr );
    goto Cleanup;

} //*** CProxyCfgNetworkInfo::GetName()

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::GetDescription(
    BSTR * pbstrDescriptionOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;
    DWORD   sc;

    if ( pbstrDescriptionOut == NULL )
        goto InvalidPointer;

    //
    //  "Major Version"
    //

    sc = TW32( m_cplNetwork.ScMoveToPropertyByName( L"Description" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetDescription_ScMoveToPropertyByName_MajorVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplNetwork.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    *pbstrDescriptionOut = SysAllocString( m_cplNetwork.CbhCurrentValue( ).pStringValue->sz );
    if ( *pbstrDescriptionOut == NULL )
        goto OutOfMemory;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_INVALIDARG );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetDescription_InvalidPointer, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetDescription_OutOfMemory, hr );
    goto Cleanup;

} //*** CProxyCfgNetworkInfo::GetDescription()

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::GetPrimaryNetworkAddress(
    IClusCfgIPAddressInfo ** ppIPAddressOut
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;
    DWORD   sc;
    DWORD   ulIPAddress;
    DWORD   ulSubnetMask;

    IUnknown * punk = NULL;

    if ( ppIPAddressOut == NULL )
        goto InvalidPointer;

    sc = TW32( m_cplNetworkRO.ScMoveToPropertyByName( L"Address" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetPrimaryNetworkAddress_ScMoveToPropetyByName_Address_Failed, hr );
        goto Cleanup;
    }

    Assert( m_cplNetworkRO.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( m_cplNetworkRO.CbhCurrentValue( ).pStringValue->sz, &ulIPAddress ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetPrimaryNetworkAddress_ClRtlTcpipStringToAddress_Address_Failed, hr );
        goto Cleanup;
    }

    sc = TW32( m_cplNetworkRO.ScMoveToPropertyByName( L"AddressMask" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetPrimaryNetworkAddress_ScMoveToPropetyByName_AddressMask_Failed, hr );
        goto Cleanup;
    }

    Assert( m_cplNetworkRO.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    sc = TW32( ClRtlTcpipStringToAddress( m_cplNetworkRO.CbhCurrentValue( ).pStringValue->sz, &ulSubnetMask ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetPrimaryNetworkAddress_ClRtlTcpipStringToAddress_AddressMask_Failed, hr );
        goto Cleanup;
    }

    hr = THR( CProxyCfgIPAddressInfo::S_HrCreateInstance( &punk,
                                                          m_punkOuter,
                                                          m_phCluster,
                                                          m_pclsidMajor,
                                                          ulIPAddress,
                                                          ulSubnetMask
                                                          ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetPrimaryNetworkAddress_Create_CProxyCfgIPAddressInfo_Failed, hr );
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgIPAddressInfo, ppIPAddressOut ) );

Cleanup:
    if ( punk != NULL )
    {
        punk->Release( );
    }

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_INVALIDARG );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetPrimaryNetworkAddress_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgNetworkInfo::GetPrimaryNetworkAddress()

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::IsPublic( void )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;
    DWORD   sc;
    DWORD   dwRole;

    sc = TW32( m_cplNetwork.ScMoveToPropertyByName( L"Role" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_IsPublic_ScMoveToPropetyByName_Address_Failed, hr );
        goto Cleanup;
    }

    Assert( m_cplNetwork.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_DWORD );
    dwRole = *m_cplNetwork.CbhCurrentValue( ).pdw;

    if ( dwRole == ClusterNetworkRoleClientAccess
      || dwRole == ClusterNetworkRoleInternalAndClient
       )
    {
        hr = S_OK;
    } // if:
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::IsPublic()

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::IsPrivate( void )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr;
    DWORD   sc;
    DWORD   dwRole;

    sc = TW32( m_cplNetwork.ScMoveToPropertyByName( L"Role" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_IsPrivate_ScMoveToPropetyByName_Address_Failed, hr );
        goto Cleanup;
    }

    Assert( m_cplNetwork.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_DWORD );
    dwRole = *m_cplNetwork.CbhCurrentValue( ).pdw;

    if ( dwRole == ClusterNetworkRoleInternalUse
      || dwRole == ClusterNetworkRoleInternalAndClient
       )
    {
        hr = S_OK;
    } // if:
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::IsPrivate()

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::SetPublic(
    BOOL fIsPublicIn
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::SetPublic()

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::SetPrivate(
    BOOL fIsPrivateIn
    )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::SetPrivate()

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::SetPrimaryNetworkAddress( IClusCfgIPAddressInfo * pIPAddressIn )
{
    TraceFunc( "[IClusCfgNetworkInfo]" );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::SetPrimaryNetworkAddress()

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::SetDescription(
    LPCWSTR pcszDescriptionIn
    )
{
    TraceFunc1( "[IClusCfgNetworkInfo] bstrDescription = '%ls'", pcszDescriptionIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::SetDescription()

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IClusCfgNetworkInfo] pcszNameIn = '%ls'", pcszNameIn );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CProxyCfgNetworkInfo::SetName()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgNetworkInfo -- IEnumClusCfgIPAddresses interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// This interface exists and must be supported, but since we only have the
// information about the primary network address available, All we can do is
// return an empty iterator.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgNetworkInfo::Next(
        ULONG                       cNumberRequestedIn,
        IClusCfgIPAddressInfo **    rgpIPAddressInfoOut,
        ULONG *                     pcNumberFetchedOut
        )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = S_FALSE;

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = 0;
    } // if:

    HRETURN( hr );

} // *** CProxyCfgNetworkInfo::Next()

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::Reset( void )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // *** CProxyCfgNetworkInfo::Reset()

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::Skip( ULONG cNumberToSkipIn )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // *** CProxyCfgNetworkInfo::Skip()

//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::Clone( IEnumClusCfgIPAddresses ** ppiIPAddressInfoOut )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} // *** CProxyCfgNetworkInfo::Clone()


//
//
//
STDMETHODIMP
CProxyCfgNetworkInfo::Count ( DWORD * pnCountOut  )
{
    TraceFunc( "[IEnumClusCfgIPAddresses]" );

    HRESULT hr = THR( S_OK );

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = 0;

Cleanup:

    HRETURN( hr );

} // *** CProxyCfgNetworkInfo::Count()


//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNetworkInfo::SendStatusReport()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgNetworkInfo::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             pcszDescriptionIn,
                                             pftTimeIn,
                                             pcszReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

}  //*** CProxyCfgNetworkInfo::SendStatusReport()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgnodeinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgNodeInfo.cpp
//
//  Description:
//      CProxyCfgNodeInfo implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CProxyCfgNodeInfo.h"
#include "CProxyCfgClusterInfo.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CProxyCfgNodeInfo")

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::S_HrCreateInstance()
//
//  Description:
//      Create a CProxyCfgNodeInfo instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CProxyCfgNodeInfo::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszNodeNameIn,
    LPCWSTR     pcszDomainIn
    )
{
    TraceFunc( "" );

    HRESULT             hr;
    CProxyCfgNodeInfo * pcc = NULL;

    if ( ppunkOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    pcc = new CProxyCfgNodeInfo;
    if ( pcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = THR( pcc->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn, pcszNodeNameIn, pcszDomainIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:

    if ( pcc != NULL )
    {
        pcc->Release();
    } // if:

    HRETURN( hr );

} //*** CProxyCfgNodeInfo::S_HrCreateInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::CProxyCfgNodeInfo()
//
//  Description:
//      Constructor of the CProxyCfgNodeInfo class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgNodeInfo::CProxyCfgNodeInfo( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_cRef == 1 );
    Assert( m_punkOuter == NULL );
    Assert( m_phCluster == NULL );
    Assert( m_pclsidMajor == NULL );
    Assert( m_pcccb == NULL );
    // m_cplNode?
    // m_cplNodeRO?
    Assert( m_hNode == NULL );

    TraceFuncExit();

} //*** CProxyCfgNodeInfo::CProxyCfgNodeInfo()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::~CProxyCfgNodeInfo()
//
//  Description:
//      Destructor of the CProxyCfgNodeInfo class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CProxyCfgNodeInfo::~CProxyCfgNodeInfo( void )
{
    TraceFunc( "" );

    //  m_cRef

    if ( m_punkOuter != NULL )
    {
        m_punkOuter->Release( );
    }

    //  m_phCluster - DO NOT CLOSE!

    //  m_pclsidMajor

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    }

    //  m_cplNode - has its own dotr

    //  m_cplNodeRO - has its own dotr

    if ( m_hNode != NULL )
    {
        BOOL bRet;
        bRet = CloseClusterNode( m_hNode );
        Assert( bRet );
    }

    TraceSysFreeString( m_bstrDomain );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CProxyCfgNodeInfo::~CProxyCfgNodeInfo()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::HrInit()
//
//  Description:
//      Initializes the object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Succeeded
//
//      other HRESULTs
//          Failed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CProxyCfgNodeInfo::HrInit(
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszNodeNameIn,
    LPCWSTR     pcszDomainIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    DWORD   sc;

    BSTR    bstrName = NULL;

    //
    //  Gather information from the input parameters.
    //

    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef( );
    }

    if ( phClusterIn == NULL )
        goto InvalidArg;

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    //
    //  See if we can callback.
    //

    hr = THR( m_punkOuter->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Save away the domain.
    //

    m_bstrDomain = TraceSysAllocString( pcszDomainIn );
    if ( m_bstrDomain == NULL )
        goto OutOfMemory;

    //
    //  Use only the hostname of the node and open the node.
    //

    if ( pcszNodeNameIn != NULL )
    {
        //
        //  Caller supplied the node name.
        //

        LPWSTR psz = wcschr( pcszNodeNameIn, L'.' );
        if ( psz == NULL )
        {
            m_hNode = OpenClusterNode( *m_phCluster, pcszNodeNameIn );
            // error case handled outside if statement
        }
        else
        {
            //  Truncate the name at the dot
            Assert( psz > pcszNodeNameIn );
            bstrName = TraceSysAllocStringLen( pcszNodeNameIn, (DWORD)( psz - pcszNodeNameIn ) );
            if ( bstrName == NULL )
                goto OutOfMemory;

            m_hNode = OpenClusterNode( *m_phCluster, bstrName );
            // error case handled outside if statement
        }

        if ( m_hNode == NULL )
        {
            sc = GetLastError( );
            if ( sc != ERROR_NOT_FOUND )
            {
                hr = HRESULT_FROM_WIN32( TW32( sc ) );
                SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_OpenClusterNode_Failed, hr );
                goto Cleanup;
            }
        }
    }
    else
    {

        sc = TW32( ResUtilEnumResourcesEx( *m_phCluster,
                                           NULL,
                                           L"Network Name",
                                           &DwEnumResourcesExCallback,
                                           this
                                           ) );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ResUtilEnumResourcesEx_Failed, hr );
            goto Cleanup;
        }

        Assert( m_hNode != NULL );
    }

    //
    // Retrieve the properties.
    //

    sc = TW32( m_cplNode.ScGetNodeProperties( m_hNode, CLUSCTL_NODE_GET_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetNodeProperties_Failed, hr );
        goto Cleanup;
    } // if:

    sc = TW32( m_cplNodeRO.ScGetNodeProperties( m_hNode, CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetNodeProperties_Failed, hr );
        goto Cleanup;
    } // if:

Cleanup:

    TraceSysFreeString( bstrName );

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CProxyCfgNodeInfo::HrInit()



//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgNodeInfo -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo:: [INKNOWN] QueryInterface()
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgNodeInfo::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IClusCfgNodeInfo * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgNodeInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgNodeInfo, this, 0 );
        hr = S_OK;
    } // else if:

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CConfigClusApi::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProxyCfgNodeInfo:: [IUNKNOWN] AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CProxyCfgNodeInfo::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CProxyCfgNodeInfo::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CProxyCfgNodeInfo:: [IUNKNOWN] Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CProxyCfgNodeInfo::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN( 0 );

} //*** CProxyCfgNodeInfo::Release()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CProxyCfgNodeInfo -- IClusCfgNodeInfo interface.
/////////////////////////////////////////////////////////////////////////////

//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::GetClusterConfigInfo(
        IClusCfgClusterInfo ** ppClusCfgClusterInfoOut
        )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr;
    IUnknown * punk = NULL;

    //
    //  Check parameters.
    //

    if ( ppClusCfgClusterInfoOut == NULL )
        goto InvalidPointer;

    //
    // Create the cluster object
    //

    hr = THR( CProxyCfgClusterInfo::S_HrCreateInstance( &punk,
                                                        m_punkOuter,
                                                        m_phCluster,
                                                        m_pclsidMajor,
                                                        m_bstrDomain
                                                        ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterConfigInfo_Create_CProxyCfgClusterInfo_Failed, hr );
        goto Cleanup;
    } // if:

    //
    //  QI for the return interface.
    //

    hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, ppClusCfgClusterInfoOut ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterConfigInfo_QI_Failed, hr );
        goto Cleanup;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    } // if:

    HRETURN( hr );
InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterConfigInfo_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgNodeInfo::GetClusterConfigInfo()


//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::GetOSVersion(
            DWORD * pdwMajorVersionOut,
            DWORD * pdwMinorVersionOut,
            WORD *  pwSuiteMaskOut,
            BYTE *  pbProductTypeOut,
            BSTR *  pbstrCSDVersionOut
            )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr;
    DWORD   sc;

    //
    //  Check parameters.
    //

    if ( pdwMajorVersionOut == NULL )
        goto InvalidPointer;

    if ( pdwMinorVersionOut == NULL )
        goto InvalidPointer;

    if ( pwSuiteMaskOut == NULL )
        goto InvalidPointer;

    if ( pbProductTypeOut == NULL )
        goto InvalidPointer;

    if ( pbstrCSDVersionOut == NULL )
        goto InvalidPointer;

    //
    //  "Major Version"
    //

    sc = TW32( m_cplNodeRO.ScMoveToPropertyByName( L"MajorVersion" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_MajorVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplNodeRO.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_DWORD );
    *pdwMajorVersionOut = *m_cplNodeRO.CbhCurrentValue( ).pdw;

    //
    //  "Minor Version"
    //

    sc = TW32( m_cplNodeRO.ScMoveToPropertyByName( L"MinorVersion" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_MinorVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplNodeRO.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_DWORD );
    *pdwMinorVersionOut = *m_cplNodeRO.CbhCurrentValue( ).pdw;

    //
    //  "CSD Version"
    //

    sc = TW32( m_cplNodeRO.ScMoveToPropertyByName( L"CSDVersion" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_CSDVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplNodeRO.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );
    *pbstrCSDVersionOut  = SysAllocString( m_cplNodeRO.CbhCurrentValue( ).pStringValue->sz );
    if ( *pbstrCSDVersionOut == NULL )
        goto OutOfMemory;

    //
    //  Stuff we can't gather (yet?)
    //

    *pwSuiteMaskOut      = 0;
    *pbProductTypeOut    = 0;

    hr = S_OK;

Cleanup:

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_InvalidPointer, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_OutOfMemory, hr );
    goto Cleanup;

} //*** CProxyCfgNodeInfo::GetOSVersion()

//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;
    DWORD   sc;

    if ( pbstrNameOut == NULL )
        goto InvalidPointer;

    sc = TW32( m_cplNodeRO.ScMoveToPropertyByName( L"NodeName" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_MinorVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplNodeRO.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );
    *pbstrNameOut = SysAllocString( m_cplNodeRO.CbhCurrentValue( ).pStringValue->sz );
    if ( *pbstrNameOut == NULL )
        goto OutOfMemory;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2kProxy_NodeInfo_GetName_InvalidPointer, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_NodeInfo_GetName_OutOfMemory, hr );
    goto Cleanup;

} //*** CProxyCfgNodeInfo::GetName()

//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::IsMemberOfCluster( void )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CProxyCfgNodeInfo::IsMemberOfCluster()

//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::GetClusterVersion(
    DWORD * pdwNodeHighestVersionOut,
    DWORD * pdwNodeLowestVersionOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;
    BSTR    bstrClusterName = NULL;
    CLUSTERVERSIONINFO ClusInfo;

    if ( pdwNodeHighestVersionOut == NULL )
        goto InvalidPointer;

    if ( pdwNodeLowestVersionOut == NULL )
        goto InvalidPointer;

    // Initialize variables.
    ClusInfo.dwVersionInfoSize = sizeof(CLUSTERVERSIONINFO);

    hr = THR( HrGetClusterInformation( *m_phCluster, &bstrClusterName, &ClusInfo ) );
    if ( FAILED( hr ) )
    {
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterInformation_Failed, hr );
        goto Cleanup;
    }

    *pdwNodeHighestVersionOut = ClusInfo.dwClusterHighestVersion;
    *pdwNodeLowestVersionOut = ClusInfo.dwClusterLowestVersion;

Cleanup:
    TraceSysFreeString( bstrClusterName );

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetClusterVersion_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgNodeInfo::GetClusterVersion()

//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterUsageOut
    )
{
    TraceFunc( "[IClusCfgNodeInfo]" );

    HRESULT hr = S_OK;

    if ( pdlmDriveLetterUsageOut == NULL )
        goto InvalidPointer;

    //
    // NOTE:  This really does not do anything (yet). Just clear the array.
    //

    ZeroMemory( pdlmDriveLetterUsageOut, sizeof(*pdlmDriveLetterUsageOut) );

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetDriveLetterMappings_InvalidPointer, hr );
    goto Cleanup;

} //*** CProxyCfgNodeInfo::GetDriveLetterMappings()

//
//
//
STDMETHODIMP
CProxyCfgNodeInfo::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc1( "[IClusCfgNodeInfo] pcszNameIn = '%ls'", pcszNameIn );

    HRESULT hr = S_FALSE;

    AssertMsg( FALSE, "Why is someone calling this?" );

    HRETURN( hr );

} //*** CProxyCfgNodeInfo::SetName()


//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CProxyCfgNodeInfo::SendStatusReport()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CProxyCfgNodeInfo::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             pcszDescriptionIn,
                                             pftTimeIn,
                                             pcszReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

}  //*** CProxyCfgNodeInfo::SendStatusReport()


//****************************************************************************
//
// Privates
//
//****************************************************************************


//
//
//
DWORD
CProxyCfgNodeInfo::DwEnumResourcesExCallback(
    HCLUSTER hClusterIn,
    HRESOURCE hResourceSelfIn,
    HRESOURCE hResourceIn,
    PVOID pvIn
    )
{
    TraceFunc( "" );

    DWORD sc;
    DWORD dwFlags;
    DWORD cchName;

    CLUSTER_RESOURCE_STATE state;

    BSTR  bstrName = NULL;
    CProxyCfgNodeInfo * pthis = reinterpret_cast< CProxyCfgNodeInfo * >( pvIn );

    sc = TW32( ClusterResourceControl( hResourceIn,
                                       NULL,
                                       CLUSCTL_RESOURCE_GET_FLAGS,
                                       NULL,
                                       0,
                                       &dwFlags,
                                       sizeof(dwFlags),
                                       NULL
                                       ) );
    if ( sc != ERROR_SUCCESS )
        goto Cleanup;

    if ( !( dwFlags & CLUS_FLAG_CORE ) )
    {
        Assert( sc == ERROR_SUCCESS );
        goto Cleanup;
    }

    cchName = 64;   // arbitary size

    bstrName = TraceSysAllocStringLen( NULL, cchName );
    if ( bstrName == NULL )
        goto OutOfMemory;

    cchName ++; // SysAllocStringLen allocate cchName + 1

    state = GetClusterResourceState( hResourceIn, bstrName, &cchName, NULL, NULL );
    if ( state == ClusterResourceStateUnknown )
    {
        sc = TW32( GetLastError( ) );
        if ( sc == ERROR_MORE_DATA )
        {
            TraceSysFreeString( bstrName );

            bstrName = TraceSysAllocStringLen( NULL, cchName );
            if ( bstrName == NULL )
                goto OutOfMemory;

            cchName ++; // SysAllocStringLen allocate cchName + 1

            state = GetClusterResourceState( hResourceIn, bstrName, &cchName, NULL, NULL );
            if ( state == ClusterResourceStateUnknown )
            {
                sc = TW32( GetLastError( ) );
                goto Cleanup;
            }
        }
        else
        {
            goto Cleanup;
        }
    }

    pthis->m_hNode = OpenClusterNode( hClusterIn, bstrName );
    if ( pthis->m_hNode == NULL )
    {
        sc = TW32( GetLastError( ) );
        goto Cleanup;
    }

    sc = ERROR_SUCCESS;

Cleanup:

    TraceSysFreeString( bstrName );

    RETURN( sc );

OutOfMemory:
    sc = ERROR_NOT_ENOUGH_MEMORY;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cresourcephysicaldisk.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CResourcePhysicalDisk.h
//
//  Description:
//      CResourcePhysicalDisk definition.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CResourcePhysicalDisk
//
//  Description:
//      The class CResourcePhysicalDisk is the cluster storage device.
//
//  Interfaces:
//      CBaseClusterResourceInfo
//      IClusCfgManagedResourceInfo
//      IClusCfgInitialize
//      IEnumClusCfgPartitions
//
//--
//////////////////////////////////////////////////////////////////////////////
class CResourcePhysicalDisk
    : public IClusCfgManagedResourceInfo
    , public IEnumClusCfgPartitions
{
private:

    LONG                        m_cRef;                 //  Reference counter
    IUnknown *                  m_punkOuter;            //  Interface to Outer W2KProxy object
    IClusCfgCallback *          m_pcccb;                //  Callback interface
    HCLUSTER *                  m_phCluster;            //  Pointer to cluster handle.
    CLSID *                     m_pclsidMajor;          //  CLSID to use when log errors to the UI
    CClusPropList               m_cplResource;          //  Property list for the resource
    CClusPropList               m_cplResourceRO;        //  Property list for the resource READ ONLY
    CClusPropValueList          m_cpvlDiskInfo;         //  GetDiskInfo property value list
    DWORD                       m_dwFlags;              //  CLUSCTL_RESOURCE_GET_FLAGS
    ULONG                       m_cParitions;           //  Number of partitions
    IClusCfgPartitionInfo **    m_ppPartitions;         //  Array of partition objects - length is m_cPartitions
    ULONG                       m_ulCurrent;            //  Current index into the array

    CResourcePhysicalDisk( void );
    ~CResourcePhysicalDisk( void );

    // Private copy constructor to prevent copying.
    CResourcePhysicalDisk( const CResourcePhysicalDisk & nodeSrc );

    // Private assignment operator to prevent copying.
    const CResourcePhysicalDisk & operator = ( const CResourcePhysicalDisk & nodeSrc );

    HRESULT
            HrInit( IUnknown *  punkOuterIn,
                    HCLUSTER *  phClusterIn,
                    CLSID *     pclsidMajorIn,
                    LPCWSTR     pcszNameIn
                    );

public:
    static HRESULT
        S_HrCreateInstance( IUnknown ** punkOut,
                            IUnknown *  punkOuterIn,
                            HCLUSTER *  phClusterIn,
                            CLSID *     pclsidMajorIn,
                            LPCWSTR     pcszNameIn
                            );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgManagedResourceInfo
    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( IsManaged )( void );
    STDMETHOD( SetManaged )( BOOL fIsManagedIn );
    STDMETHOD( IsQuorumDevice )( void );
    STDMETHOD( SetQuorumedDevice )( BOOL fIsQuorumDeviceIn );
    STDMETHOD( IsQuorumCapable )( void );
    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterMappingOut );
    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappingIn );
    STDMETHOD( IsDeviceJoinable )( void );
    STDMETHOD( SetDeviceJoinable )( BOOL fIsJoinableIn );

    // IEnumClusCfgPartitions
    STDMETHOD( Next  )( ULONG cNumberRequestedIn, IClusCfgPartitionInfo ** rgpPartitionInfoOut, ULONG * pcNumberFetchedOut );
    STDMETHOD( Reset )( void );
    STDMETHOD( Skip  )( ULONG cNumberToSkipIn );
    STDMETHOD( Clone )( IEnumClusCfgPartitions ** ppEnumPartitions );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; //*** Class CResourcePhysicalDisk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgnetworkinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgNetworkInfo.h
//
//  Description:
//      CProxyCfgNetworkInfo definition.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProxyCfgNetworkInfo
//
//  Description:
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProxyCfgNetworkInfo
    : public IClusCfgNetworkInfo
    , public IEnumClusCfgIPAddresses
{
private:
    LONG                m_cRef;                 //  Reference counter
    IUnknown *          m_punkOuter;            //  Interface to outer W2K proxy object
    IClusCfgCallback *  m_pcccb;                //  Callback interface
    HCLUSTER  *         m_phCluster;            //  Pointer to cluster handle
    CLSID *             m_pclsidMajor;          //  CLSID to log errors to the UI with.
    CClusPropList       m_cplNetwork;           //  Property list with Network info
    CClusPropList       m_cplNetworkRO;         //  Property list with Network info READ ONLY

    CProxyCfgNetworkInfo( void );
    ~CProxyCfgNetworkInfo( void );

    // Private copy constructor to prevent copying.
    CProxyCfgNetworkInfo( const CProxyCfgNetworkInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CProxyCfgNetworkInfo & operator = ( const CProxyCfgNetworkInfo & nodeSrc );

    HRESULT HrInit( IUnknown * punkOuterIn, HCLUSTER * phClusterIn, CLSID * pclsidMajorIn, LPCWSTR pcszNetworkNameIn );

public:
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut,
                            IUnknown *  punkOuterIn,
                            HCLUSTER *  phClusterIn,
                            CLSID *     pclsidMajorIn,
                            LPCWSTR     pcszNetworkNameIn
                            );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgNetworkInfo
    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );
    STDMETHOD( GetName )(  BSTR * pbstrNameOut );
    STDMETHOD( SetName )(  LPCWSTR pcszNameIn );
    STDMETHOD( GetDescription )(  BSTR * pbstrDescriptionOut );
    STDMETHOD( SetDescription )(  LPCWSTR pcszDescriptionIn );
    STDMETHOD( GetPrimaryNetworkAddress )(  IClusCfgIPAddressInfo ** ppIPAddressOut );
    STDMETHOD( SetPrimaryNetworkAddress )(  IClusCfgIPAddressInfo * pIPAddressIn );
    STDMETHOD( IsPublic )( void );
    STDMETHOD( SetPublic )(  BOOL fIsPublicIn );
    STDMETHOD( IsPrivate )( void );
    STDMETHOD( SetPrivate )(  BOOL fIsPrivateIn );

    // IEnumClusCfgIPAddresses
    STDMETHOD( Next )( ULONG cNumberRequestedIn, IClusCfgIPAddressInfo ** rgpIPAddressInfoOut, ULONG * pcNumberFetchedOut );
    STDMETHOD( Reset )( void );
    STDMETHOD( Skip )( ULONG cNumberToSkipIn );
    STDMETHOD( Clone )( IEnumClusCfgIPAddresses ** ppiEnumOut );
    STDMETHOD( Count )( DWORD * pnCountOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; //*** Class CProxyCfgNetworkInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cresourcephysicaldisk.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CResourcePhysicalDisk.cpp
//
//  Description:
//      CResourcePhysicalDisk implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CResourcePhysicalDisk.h"
#include "CResourcePhysicalDiskPartition.h"


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CResourcePhysicalDisk")


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::S_HrCreateInstance()
//
//  Description:
//      Create a CResourcePhysicalDisk instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourcePhysicalDisk::S_HrCreateInstance(
    IUnknown ** ppunkOut,
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszNameIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    CResourcePhysicalDisk * pcc = NULL;

    Assert( ppunkOut != NULL );
    if ( ppunkOut == NULL )
        goto InvalidArg;

    pcc = new CResourcePhysicalDisk;
    if ( pcc == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    hr = STHR( pcc->HrInit( punkOuterIn, phClusterIn, pclsidMajorIn, pcszNameIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;
	if ( hr == S_FALSE )
	{
		*ppunkOut = NULL;
		goto Cleanup;
	}

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:
    if ( pcc != NULL )
    {
        pcc->Release( );
    } // if:

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} //*** CResourcePhysicalDisk::S_HrCreateInitializedInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::CResourcePhysicalDisk()
//
//  Description:
//      Constructor of the CResourcePhysicalDisk class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResourcePhysicalDisk::CResourcePhysicalDisk( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    Assert( m_cRef == 1 );
    Assert( m_punkOuter == NULL );
    Assert( m_pcccb == NULL );
    Assert( m_phCluster == NULL );
    Assert( m_pclsidMajor == NULL );
    //  Assert( m_cplResource );
    //  Assert( m_cplResourceRO );
    //  Assert( m_cpvlDiskInfo );
    Assert( m_dwFlags == 0 );
    Assert( m_cParitions == 0 );
    Assert( m_ppPartitions == NULL );
    Assert( m_ulCurrent == 0 );

    TraceFuncExit();

} //*** CResourcePhysicalDisk::CResourcePhysicalDisk()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::CResourcePhysicalDisk()
//
//  Description:
//      Destructor of the CResourcePhysicalDisk class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResourcePhysicalDisk::~CResourcePhysicalDisk( void )
{
    TraceFunc( "" );

    //  m_cRef - noop

    if ( m_punkOuter != NULL )
    {
        m_punkOuter->Release( );
    }

    if ( m_pcccb != NULL )
    {
        m_pcccb->Release();
    } // if:

    // m_phCluster - DO NOT CLOSE!

    // m_pclsidMajor - noop

    // m_cplResource - has its own dtor

    // m_cplResourceRO - has its own dtor

    // m_cpvlDiskInfo - has its own dtor

    // m_dwFlags - noop

    if ( m_ppPartitions != NULL )
    {
        while( m_cParitions != 0 )
        {
            m_cParitions --;

            if ( m_ppPartitions[ m_cParitions ] != NULL )
            {
                m_ppPartitions[ m_cParitions ]->Release( );
            }
        }

        TraceFree( m_ppPartitions );
    }

    // m_ulCurrent

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CResourcePhysicalDisk::~CResourcePhysicalDisk()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::HrInit()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourcePhysicalDisk::HrInit(
    IUnknown *  punkOuterIn,
    HCLUSTER *  phClusterIn,
    CLSID *     pclsidMajorIn,
    LPCWSTR     pcszNameIn
    )
{
    TraceFunc( "" );

    HRESULT hr;
    DWORD   sc;
    DWORD   cb;
    ULONG   cPartition;

    HRESOURCE hResource = NULL;
    IUnknown * punk = NULL;

    //
    //  Gather information from the input parameters.
    //

    if ( punkOuterIn != NULL )
    {
        m_punkOuter = punkOuterIn;
        m_punkOuter->AddRef( );
    }

    if ( phClusterIn == NULL )
        goto InvalidArg;

    m_phCluster = phClusterIn;

    if ( pclsidMajorIn != NULL )
    {
        m_pclsidMajor = pclsidMajorIn;
    }
    else
    {
        m_pclsidMajor = (CLSID *) &TASKID_Major_Client_And_Server_Log;
    }

    if ( pcszNameIn == NULL )
        goto InvalidArg;

    //
    //  See if we can callback.
    //

    hr = THR( m_punkOuter->TypeSafeQI( IClusCfgCallback, &m_pcccb ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Retrieve the properties.
    //

    hResource = OpenClusterResource( *m_phCluster, pcszNameIn );
    if ( hResource == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError( ) ) );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_OpenClusterResource_Failed, hr );
        goto Cleanup;
    }

    sc = TW32( m_cplResource.ScGetResourceProperties( hResource, CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetResourceProperties_Failed, hr );
        goto Cleanup;
    }

    //
    //  We only handle Physical Disk resources.
    //

    sc = TW32( m_cplResource.ScMoveToPropertyByName( L"Type" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScMoveToPropertyByName_Failed, hr );
        goto Cleanup;
    }

    Assert( m_cplResource.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    if ( _wcsicmp( m_cplResource.CbhCurrentValue( ).pStringValue->sz, L"Physical Disk" ) != 0 )
    {
        //
        //  The resource isn't a physical disk.
        //

        hr = S_FALSE;
        goto Cleanup;
    }

    sc = TW32( m_cplResourceRO.ScGetResourceProperties( hResource, CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetResourceProperties_Failed, hr );
        goto Cleanup;
    }

    sc = TW32( m_cpvlDiskInfo.ScGetResourceValueList( hResource, CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ScGetResourceValueList_Failed, hr );
        goto Cleanup;
    }

    sc = TW32( ClusterResourceControl( hResource, NULL, CLUSCTL_RESOURCE_GET_FLAGS, NULL, NULL, &m_dwFlags, sizeof(m_dwFlags), &cb ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_ClusterResourceControl_Failed, hr );
        goto Cleanup;
    }
    Assert( cb == sizeof(m_dwFlags) );

    //
    //  Figure out how many partitions there are.
    //

    m_cParitions = 0;

    sc = TW32( m_cpvlDiskInfo.ScMoveToFirstValue() );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_HrInit_ScMoveToFirstValue_Failed, hr );
        goto Cleanup;
    } // if:

    do
    {
        if ( m_cpvlDiskInfo.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO )
        {
            m_cParitions ++;
        }

        // Move to the next item.
        sc = m_cpvlDiskInfo.ScCheckIfAtLastValue();
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
           break;
        } // if:

        sc = TW32( m_cpvlDiskInfo.ScMoveToNextValue() );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_HrInit_ScMoveToNextValue_Failed, hr );
            goto Cleanup;
        }

    } while( sc == ERROR_SUCCESS );

    //
    //  Allocate the array to store pointers to the partition objects.
    //

    m_ppPartitions = (IClusCfgPartitionInfo **) TraceAlloc( 0, m_cParitions * sizeof(IClusCfgPartitionInfo *) );
    if ( m_ppPartitions == NULL )
        goto OutOfMemory;

    //
    //  Now loop again creating partition objects.
    //

    cPartition = 0;

    sc = TW32( m_cpvlDiskInfo.ScMoveToFirstValue() );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_HrInit_ScMoveToFirstValue_Failed, hr );
        goto Cleanup;
    } // if:

    do
    {
        if ( m_cpvlDiskInfo.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO )
        {
            // Create the object
            hr = THR( CResourcePhysicalDiskPartition::S_HrCreateInstance( &punk ) );
            if ( FAILED( hr ) )
            {
                SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_HrInit_Create_CResourcePhysicalDiskPartition_Failed, hr );
                goto Cleanup;
            }

            hr = THR( punk->TypeSafeQI( IClusCfgPartitionInfo, &m_ppPartitions[ cPartition ] ) );
            if ( FAILED( hr ) )
            {
                SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_HrInit_QI_Failed, hr );
                goto Cleanup;
            }

            punk->Release( );
            punk = NULL;

            cPartition ++;
        }

        // Move to the next item.
        sc = m_cpvlDiskInfo.ScCheckIfAtLastValue();
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
           break;
        } // if:

        sc = TW32( m_cpvlDiskInfo.ScMoveToNextValue() );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_HrInit_ScMoveToNextValue2_Failed, hr );
            goto Cleanup;
        }

    } while( sc == ERROR_SUCCESS && cPartition < m_cParitions );

    hr = S_OK;

Cleanup:
    if ( hResource != NULL )
    {
        BOOL bRet;
        bRet = CloseClusterResource( hResource );
        Assert( bRet );
    }
    if ( punk != NULL )
    {
        punk->Release( );
    }

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2KProxy_PhysDisk_HrInit_InvalidArg, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_HrInit_OutOfMemory, hr );
    goto Cleanup;

} //*** CResourcePhysicalDisk::HrInit()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourcePhysicalDisk -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk:: [INKNOWN] QueryInterface()
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IClusCfgManagedResourceInfo * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgManagedResourceInfo ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgManagedResourceInfo, this, 0 );
        hr = S_OK;
    }
    else if ( IsEqualIID( riid, IID_IEnumClusCfgPartitions ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IEnumClusCfgPartitions, this, 0 );
        hr = S_OK;
    }

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CConfigClusApi::QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CResourcePhysicalDisk:: [IUNKNOWN] AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CResourcePhysicalDisk::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CResourcePhysicalDisk::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CResourcePhysicalDisk:: [IUNKNOWN] Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CResourcePhysicalDisk::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN( 0 );

} //*** CResourcePhysicalDisk::Release()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourcePhysicalDisk -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::GetName()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;
    DWORD   sc;

    if ( pbstrNameOut == NULL )
        goto InvalidPointer;

    //
    //  "Major Version"
    //

    sc = TW32( m_cplResourceRO.ScMoveToPropertyByName( L"Name" ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetName_ScMoveToPropertyByName_MajorVersion_Failed, hr );
        goto Cleanup;
    } // if:

    Assert( m_cplResourceRO.CbhCurrentValue( ).pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

    *pbstrNameOut = SysAllocString( m_cplResourceRO.CbhCurrentValue( ).pStringValue->sz );
    if ( *pbstrNameOut == NULL )
        goto OutOfMemory;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_INVALIDARG );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetName_InvalidPointer, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetName_OutOfMemory, hr );
    goto Cleanup;

} //*** CResourcePhysicalDisk::GetName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::GetUID()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::GetUID(
    BSTR * pbstrUIDOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;
    DWORD   sc;
    UCHAR   TargetId;
    UCHAR   Lun;

    WCHAR   sz[ 32 ];

    if ( pbstrUIDOut == NULL )
        goto InvalidPointer;

    // loop through all the properties.
    sc = TW32( m_cpvlDiskInfo.ScMoveToFirstValue() );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ScMoveToFirstValue_Failed, hr );
        goto Cleanup;
    } // if:

    do
    {
        if ( m_cpvlDiskInfo.CbhCurrentValue().pSyntax->dw == CLUSPROP_SYNTAX_SCSI_ADDRESS )
            break;  // found it!

        // Move to the next item.
        sc = m_cpvlDiskInfo.ScCheckIfAtLastValue();
        if ( sc == ERROR_NO_MORE_ITEMS )
        {
           break;
        } // if:

        sc = TW32( m_cpvlDiskInfo.ScMoveToNextValue() );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_ScMoveToNextValue_Failed, hr );
            goto Cleanup;
        }

    } while( sc == ERROR_SUCCESS );

    TargetId = m_cpvlDiskInfo.CbhCurrentValue().pScsiAddressValue->TargetId;
    Lun = m_cpvlDiskInfo.CbhCurrentValue().pScsiAddressValue->Lun;

    // Print the UID identical to the others.
    _snwprintf( sz, ARRAYSIZE( sz ), L"SCSI Tid %ld, SCSI Lun %ld", TargetId, Lun );

    *pbstrUIDOut = TraceSysAllocString( sz );
    if ( *pbstrUIDOut == NULL )
        goto OutOfMemory;

    hr = S_OK;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_InvalidPointer, hr );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_GetUID_OutOfMemory, hr );
    goto Cleanup;

} //*** CResourcePhysicalDisk::GetUID()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::IsManaged()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Is managed.
//
//      S_FALSE
//          Is not managed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::IsManaged( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CResourcePhysicalDisk::IsManaged()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::IsQuorumDevice()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Is quorum device.
//
//      S_FALSE
//          Is not quorum device.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::IsQuorumDevice( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;

    if ( m_dwFlags & CLUS_FLAG_CORE )
    {
        hr = S_OK;
    } // if:
    else
    {
        hr = S_FALSE;
    } // else:

    HRETURN( hr );

} //*** CResourcePhysicalDisk::IsQuorumDevice()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::IsQuorumCapable()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Is quorum capable device.
//
//      S_FALSE
//          Is not quorum capable device.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::IsQuorumCapable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CResourcePhysicalDisk::IsQuorumCapable()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::GetDriveLetterMappings()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterMappingOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( pdlmDriveLetterMappingOut == NULL )
    {
        hr = THR( E_POINTER );
    } // if:

    ZeroMemory( pdlmDriveLetterMappingOut, sizeof(*pdlmDriveLetterMappingOut) );

    HRETURN( hr );

} //*** CResourcePhysicalDisk::GetDriveLetterMappings()

//
// KB:  Some of these methods are supported in a limited sense for compatability.
//      Those methods compare the request with the current data and succeede if they
//      match, and fail otherwise.  All other methods assert and fail when called.
//      If they are used, appropriate handling should be done in the upper level,
//      And the THR removed from that section of code.
//

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::SetDriveLetterMappings()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDisk::SetDriveLetterMappings()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::IsDeviceJoinable()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Is Joinable device.
//
//      S_FALSE
//          Is not quorum capable device.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::IsDeviceJoinable( void )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    HRETURN( hr );

} //*** CResourcePhysicalDisk::IsDeviceJoinable()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::SetDeviceJoinable()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//      S_OK
//          Is Joinable device.
//
//      S_FALSE
//          Is not quorum capable device.
//
//  Remarks:
//      This function should never be called.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SetDeviceJoinable( BOOL fIsJoinableIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRETURN( THR( E_NOTIMPL ) );

} //*** CResourcePhysicalDisk::SetDeviceJoinable()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::SetName()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SetName(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IClusCfgManagedResourceInfo] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_FALSE;

    HRETURN( hr );

} //*** CResourcePhysicalDisk::SetName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::SetManaged()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SetManaged(
    BOOL fIsManagedIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    Assert( fIsManagedIn );

    if ( !fIsManagedIn )
    {
        hr = THR( E_FAIL );
    }

    HRETURN( hr );

} //*** CResourcePhysicalDisk::SetManaged()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::SetQuorumedDevice()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SetQuorumedDevice(
    BOOL fIsQuorumDeviceIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr;

    if ( m_dwFlags & CLUS_FLAG_CORE )
    {
        if ( fIsQuorumDeviceIn )
        {
            hr = S_OK;
        }
        else
        {
            hr = THR( E_FAIL );
        }
    }
    else
    {
        if ( !fIsQuorumDeviceIn )
        {
            hr = S_OK;
        }
        else
        {
            hr = THR( E_FAIL );
        }
    }

    HRETURN( hr );

} //*** CResourcePhysicalDisk::SetQuorumedDevice()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourcePhysicalDisk -- IEnumClusCfgPartitions interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::Next()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::Next(
    ULONG                       cNumberRequestedIn,
    IClusCfgPartitionInfo **    rgpPartitionInfoOut,
    ULONG *                     pcNumberFetchedOut
    )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr;
    ULONG   cFetched = min(cNumberRequestedIn, m_cParitions - m_ulCurrent);

    if ( rgpPartitionInfoOut == NULL )
        goto InvalidPointer;

    for ( ; cFetched < cNumberRequestedIn; cFetched++, m_ulCurrent++ )
    {
        hr = THR( (m_ppPartitions[ m_ulCurrent ])->TypeSafeQI( IClusCfgPartitionInfo,
                                                               &rgpPartitionInfoOut[ cFetched ]
                                                               ) );
        if ( FAILED( hr ) )
        {
            SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_Next_QI_Failed, hr );
            goto Cleanup;
        }
    }

    if ( cFetched < cNumberRequestedIn )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

Cleanup:
    if ( FAILED( hr ) )
    {
        while ( cFetched != 0 );
        {
            cFetched --;

            rgpPartitionInfoOut[ cFetched ]->Release( );
        }
    }

    if ( pcNumberFetchedOut != NULL )
    {
        *pcNumberFetchedOut = cFetched;
    }

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    SSR_W2KPROXY_STATUS( TASKID_Major_Client_And_Server_Log, TASKID_Minor_W2kProxy_PhysDisk_Next_InvalidPointer, hr );
    goto Cleanup;

} //*** CResourcePhysicalDisk::Next()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::Reset()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::Reset( void )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = S_OK;

    m_ulCurrent = 0;

    HRETURN( hr );

} //*** CResourcePhysicalDisk::Reset()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::Skip()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::Skip(
    ULONG cNumberToSkipIn
    )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = S_OK;

    m_ulCurrent += cNumberToSkipIn;

    if ( m_ulCurrent >= m_cParitions )
    {
        hr = S_FALSE;
        m_ulCurrent = m_cParitions;
    }
    else
    {
        hr = S_OK;
    }

    HRETURN( hr );

} //*** CResourcePhysicalDisk::Skip()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::Clone()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::Clone( IEnumClusCfgPartitions ** ppEnumPartitions )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDisk::Clone()



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::Count()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::Count(  DWORD * pnCountOut  )
{
    TraceFunc( "[IEnumClusCfgPartitions]" );

    HRESULT hr = THR( S_OK );

    if ( pnCountOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    }

    *pnCountOut = m_cParitions;

Cleanup:

    HRETURN( hr );

} //*** CResourcePhysicalDisk::Count()



//****************************************************************************
//
// IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDisk::SendStatusReport()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDisk::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT     hr = S_OK;

    if ( m_pcccb != NULL )
    {
        hr = THR( m_pcccb->SendStatusReport( pcszNodeNameIn,
                                             clsidTaskMajorIn,
                                             clsidTaskMinorIn,
                                             ulMinIn,
                                             ulMaxIn,
                                             ulCurrentIn,
                                             hrStatusIn,
                                             pcszDescriptionIn,
                                             pftTimeIn,
                                             pcszReferenceIn
                                             ) );
    } // if:

    HRETURN( hr );

}  //*** CResourcePhysicalDisk::SendStatusReport()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgipaddressinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgIPAddressInfo.h
//
//  Description:
//      CProxyCfgIPAddressInfo definition.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProxyCfgIPAddressInfo
//
//  Description:
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProxyCfgIPAddressInfo
    : public IClusCfgIPAddressInfo
{
private:
    LONG                m_cRef;             //  Reference counter
    IUnknown *          m_punkOuter;        //  Pointer to outer W2K Proxy object
    IClusCfgCallback *  m_pcccb;            //  Callback interface
    HCLUSTER *          m_phCluster;        //  Pointer to handle of cluster
    CLSID *             m_pclsidMajor;      //  Pointer to the CLSID to use to log errors to the UI.
    ULONG               m_ulIPAddress;      //  IP Address
    ULONG               m_ulSubnetMask;     //  Subnet Mask

    CProxyCfgIPAddressInfo( void );
    ~CProxyCfgIPAddressInfo( void );

    // Private copy constructor to prevent copying.
    CProxyCfgIPAddressInfo( const CProxyCfgIPAddressInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CProxyCfgIPAddressInfo & operator = ( const CProxyCfgIPAddressInfo & nodeSrc );

    HRESULT
        HrInit( IUnknown * punkOuterIn,
                HCLUSTER * phClusterIn,
                CLSID *    pclsidMajorIn,
                ULONG      ulIPAddressIn,
                ULONG      ulSubnetMaskIn
                );

public:
    static HRESULT S_HrCreateInstance( IUnknown ** ppunkOut,
                                       IUnknown *  punkOuterIn,
                                       HCLUSTER *  phClusterIn,
                                       CLSID *     pclsidMajorIn,
                                       ULONG       ulIPAddressIn,
                                       ULONG       ulSubnetMaskIn
                                       );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgIPAddressInfo
    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );
    STDMETHOD( GetIPAddress )( ULONG * pulDottedQuadOut );
    STDMETHOD( SetIPAddress )( ULONG ulDottedQuadIn );
    STDMETHOD( GetSubnetMask )( ULONG * pulDottedQuadOut );
    STDMETHOD( SetSubnetMask )( ULONG ulDottedQuadIn );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )( BSTR bstrNodeNameIn,
                                   CLSID        clsidTaskMajorIn,
                                   CLSID        clsidTaskMinorIn,
                                   ULONG        ulMinIn,
                                   ULONG        ulMaxIn,
                                   ULONG        ulCurrentIn,
                                   HRESULT      hrStatusIn,
                                   BSTR         bstrDescriptionIn,
                                   FILETIME *   pftTimeIn,
                                   BSTR         bstrReferenceIn
                                   );

}; //*** Class CProxyCfgIPAddressInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cproxycfgnodeinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CProxyCfgNodeInfo.h
//
//  Description:
//      CProxyCfgNodeInfo definition.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////

// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CProxyCfgNodeInfo
//
//--
//////////////////////////////////////////////////////////////////////////////
class CProxyCfgNodeInfo
    : public IClusCfgNodeInfo
{
private:

    LONG                m_cRef;
    IUnknown *          m_punkOuter;                //  Outer control object - It can't be deleted until we get deleted.
    HCLUSTER *          m_phCluster;                //  Pointer to the handle of the cluster/node - DO NOT CLOSE!
    CLSID *             m_pclsidMajor;              //  Pointer to the clsid to log UI information to.
    IClusCfgCallback *  m_pcccb;                    //  Callback interface to log information.
    CClusPropList       m_cplNode;                  //  Property list with Node info
    CClusPropList       m_cplNodeRO;                //  Property list with Node info READ ONLY
    HNODE               m_hNode;                    //  Handle to node
    BSTR                m_bstrDomain;               //  Domain name for the node.

    CProxyCfgNodeInfo( void );
    ~CProxyCfgNodeInfo( void );

    // Private copy constructor to prevent copying.
    CProxyCfgNodeInfo( const CProxyCfgNodeInfo & nodeSrc );

    // Private assignment operator to prevent copying.
    const CProxyCfgNodeInfo & operator = ( const CProxyCfgNodeInfo & nodeSrc );

    HRESULT HrInit( IUnknown *   punkOuterIn,
                    HCLUSTER *   phClusterIn,
                    CLSID *      pclsidMajorIn,
                    LPCWSTR      pcszNodeNameIn,
                    LPCWSTR      pcszDomainIn
                    );

    static DWORD
        DwEnumResourcesExCallback( HCLUSTER hClusterIn,
                                   HRESOURCE hResourceSelfIn,
                                   HRESOURCE hResourceIn,
                                   PVOID pvIn
                                   );

public:
    static HRESULT S_HrCreateInstance( IUnknown **  ppunkOut,
                                       IUnknown *   punkOuterIn,
                                       HCLUSTER *   phClusterIn,
                                       CLSID *      pclsidMajorIn,
                                       LPCWSTR      pcszNodeNameIn,
                                       LPCWSTR      pcszDomainIn
                                       );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgNodeInfo
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( IsMemberOfCluster) ( void );
    STDMETHOD( GetClusterConfigInfo )( IClusCfgClusterInfo ** ppClusCfgClusterInfoOut );
    STDMETHOD( GetOSVersion )(
                DWORD * pdwMajorVersionOut,
                DWORD * pdwMinorVersionOut,
                WORD *  pwSuiteMaskOut,
                BYTE *  pbProductTypeOut,
                BSTR *  pbstrCSDVersionOut );

    STDMETHOD( GetClusterVersion )( DWORD * pdwNodeHighestVersion, DWORD * pdwNodeLowestVersion );
    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterUsageOut );

    // IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; //*** Class CProxyCfgNodeInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\test\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <DebugSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\test\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <InterfaceTableSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\test\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <CITrackerSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\test\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "LogSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cresourcephysicaldiskpartition.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CResourcePhysicalDiskPartition.cpp
//
//  Description:
//      CResourcePhysicalDiskPartition implementation.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include "pch.h"
#include "CResourcePhysicalDiskPartition.h"
#include <ClusCfgPrivate.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CResourcePhysicalDiskPartition")


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::S_HrCreateInitializedInstance()
//
//  Description:
//      Create a CResourcePhysicalDiskPartition instance.
//
//  Arguments:
//      ppunkOut
//
//  Return Values:
//      S_OK
//          Success.
//
//      E_POINTER
//          A passed in argument is NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      Other HRESULT error.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CResourcePhysicalDiskPartition::S_HrCreateInstance(
    IUnknown **     ppunkOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    CResourcePhysicalDiskPartition * pcc = NULL;

    if ( ppunkOut == NULL )
        goto InvalidPointer;

    pcc = new CResourcePhysicalDiskPartition;
    if ( pcc == NULL )
        goto OutOfMemory;

    hr = THR( pcc->HrInit( ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pcc->TypeSafeQI( IUnknown, ppunkOut ) );

Cleanup:
    if ( pcc != NULL )
    {
        pcc->Release( );
    } // if:

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CResourcePhysicalDiskPartition::S_HrCreateInitializedInstance()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::CResourcePhysicalDiskPartition()
//
//  Description:
//      Constructor of the CResourcePhysicalDiskPartition class. This initializes
//      the m_cRef variable to 1 instead of 0 to account of possible
//      QueryInterface failure in DllGetClassObject.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResourcePhysicalDiskPartition::CResourcePhysicalDiskPartition( void )
    : m_cRef( 1 )
{
    TraceFunc( "" );

    Assert( m_cRef == 1 );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CResourcePhysicalDiskPartition::CResourcePhysicalDiskPartition()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::~CResourcePhysicalDiskPartition()
//
//  Description:
//      Destructor of the CResourcePhysicalDiskPartition class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CResourcePhysicalDiskPartition::~CResourcePhysicalDiskPartition( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CResourcePhysicalDiskPartition::~CResourcePhysicalDiskPartition()

//
//
//
HRESULT
CResourcePhysicalDiskPartition::HrInit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HRETURN( hr );
}


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourcePhysicalDiskPartition -- IUknkown interface.
/////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition:: [INKNOWN] QueryInterface()
//
//  Description:
//      Query this object for the passed in interface.
//
//  Arguments:
//      IN  REFIID  riid,
//          Id of interface requested.
//
//      OUT void ** ppv
//          Pointer to the requested interface.
//
//  Return Value:
//      S_OK
//          If the interface is available on this object.
//
//      E_NOINTERFACE
//          If the interface is not available.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::QueryInterface( REFIID riid, LPVOID *ppv )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riid, IID_IUnknown ) )
    {
        *ppv = static_cast< IClusCfgPartitionInfo * >( this );
        hr   = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClusCfgPartitionInfo) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClusCfgPartitionInfo, this, 0 );
        hr = S_OK;
    } // else if: IID_IClusCfgPartitionInfo

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riid );

} //*** CResourcePhysicalDiskPartition::QueryInterface( )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CResourcePhysicalDiskPartition:: [IUNKNOWN] AddRef()
//
//  Description:
//      Increment the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CResourcePhysicalDiskPartition::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CResourcePhysicalDiskPartition::AddRef()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CResourcePhysicalDiskPartition:: [IUNKNOWN] Release()
//
//  Description:
//      Decrement the reference count of this object by one.
//
//  Arguments:
//      None.
//
//  Return Value:
//      The new reference count.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CResourcePhysicalDiskPartition::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN( 0 );

} //*** CResourcePhysicalDiskPartition::Release()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourcePhysicalDiskPartition -- IClusCfgManagedResourceInfo interface.
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::GetName()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::GetName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::GetName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::GetDescription()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::GetDescription(
    BSTR * pbstrDescOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::GetDescription()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::GetUID()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::GetUID(
    BSTR * pbstrUIDOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::GetUID()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::GetSize()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::GetSize(
    ULONG * pcMegaBytes
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_OK;

    if ( pcMegaBytes == NULL )
        goto InvalidPointer;

    *pcMegaBytes = 0;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CResourcePhysicalDiskPartition::GetSize()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::GetDriveLetterMappings()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::GetDriveLetterMappings(
    SDriveLetterMapping * pdlmDriveLetterUsageOut
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = S_FALSE;

    if ( pdlmDriveLetterUsageOut == NULL )
        goto InvalidPointer;

    ZeroMemory( pdlmDriveLetterUsageOut, sizeof(*pdlmDriveLetterUsageOut) );

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CResourcePhysicalDiskPartition::GetDriveLetterMappings()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::SetName()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::SetName( LPCWSTR pcszNameIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::SetName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::SetDescription()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::SetDescription( LPCWSTR pcszDescriptionIn )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::SetDescription()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePhysicalDiskPartition::SetDriveLetterMappings()
//
//  Description:
//
//  Arguments:
//
//  Return Value:
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CResourcePhysicalDiskPartition::SetDriveLetterMappings(
    SDriveLetterMapping dlmDriveLetterMappingIn
    )
{
    TraceFunc( "[IClusCfgManagedResourceInfo]" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN( hr );

} //*** CResourcePhysicalDiskPartition::SetDriveLetterMappings()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\cresourcephysicaldiskpartition.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CResourcePhysicalDiskPartition.h
//
//  Description:
//      CResourcePhysicalDiskPartition header.
//
//  Maintained By:
//      Galen Barbee (GalenB) 23-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CResourcePhysicalDiskPartition
//
//  Description:
//      The class CResourcePhysicalDiskPartition is the enumeration of cluster
//      storage device partitions.
//
//  Interfaces:
//      IClusCfgPartitionInfo
//
//--
//////////////////////////////////////////////////////////////////////////////
class CResourcePhysicalDiskPartition
    : public IClusCfgPartitionInfo
{
private:

    LONG    m_cRef;         //  Reference counter

    CResourcePhysicalDiskPartition( void );
    ~CResourcePhysicalDiskPartition( void );

    // Private copy constructor to prevent copying.
    CResourcePhysicalDiskPartition( const CResourcePhysicalDiskPartition & nodeSrc );

    // Private assignment operator to prevent copying.
    const CResourcePhysicalDiskPartition & operator = ( const CResourcePhysicalDiskPartition & nodeSrc );

    HRESULT
        HrInit( void );

public:
    static HRESULT
        S_HrCreateInstance( IUnknown ** punkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID * ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IClusCfgPartitionInfo Interface
    STDMETHOD( GetUID )( BSTR * pbstrUIDOut );
    STDMETHOD( GetName )( BSTR * pbstrNameOut );
    STDMETHOD( GetDescription )( BSTR * pbstrDescriptionOut );
    STDMETHOD( GetDriveLetterMappings )( SDriveLetterMapping * pdlmDriveLetterUsageOut );
    STDMETHOD( GetSize )( ULONG * pcMegaBytes );

    STDMETHOD( SetName )( LPCWSTR pcszNameIn );
    STDMETHOD( SetDescription )( LPCWSTR pcszDescriptionIn );
    STDMETHOD( SetDriveLetterMappings )( SDriveLetterMapping dlmDriveLetterMappingIn );

}; //*** Class CResourcePhysicalDiskPartition
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\w2kproxyserverguids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      W2KProxyServerGuids.h
//
//  Description:
//      This file contains the guids used in ClusCfgServer.
//
//  Documentation:
//
//  Maintained By:
//      Galen Barbee (GalenB) 31-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <InitGuid.h>


//////////////////////////////////////////////////////////////////////////////
// Constant Declarations
//////////////////////////////////////////////////////////////////////////////


// {9491EC16-D609-4814-B12E-D6AAD5B4C603}
DEFINE_GUID( TASKID_Minor_HrInit_ClusterOpenEnum_Failed,
0x9491ec16, 0xd609, 0x4814, 0xb1, 0x2e, 0xd6, 0xaa, 0xd5, 0xb4, 0xc6, 0x3);

// {458045A2-5AA7-45b6-BF44-2F725113E8B0}
DEFINE_GUID( TASKID_Minor_HrInit_InvalidArg,
0x458045a2, 0x5aa7, 0x45b6, 0xbf, 0x44, 0x2f, 0x72, 0x51, 0x13, 0xe8, 0xb0);

// {25434924-9296-458b-B11C-A88739D06A31}
DEFINE_GUID( TASKID_Minor_Next_InvalidPointer,
0x25434924, 0x9296, 0x458b, 0xb1, 0x1c, 0xa8, 0x87, 0x39, 0xd0, 0x6a, 0x31);

// {BEFEE4AE-1520-49e8-A3BB-6AEF91DB21BD}
DEFINE_GUID( TASKID_Minor_HrGetItem_ClusterEnum_Failed,
0xbefee4ae, 0x1520, 0x49e8, 0xa3, 0xbb, 0x6a, 0xef, 0x91, 0xdb, 0x21, 0xbd);

// {B51D6B89-47AB-4521-943B-92964E4395F7}
DEFINE_GUID( TASKID_Minor_HrGetItem_Create_CProxyCfgNetworkInfo_Failed,
0xb51d6b89, 0x47ab, 0x4521, 0x94, 0x3b, 0x92, 0x96, 0x4e, 0x43, 0x95, 0xf7);

// {50ACA86D-7ADA-40ad-A062-64170ADAC8E8}
DEFINE_GUID( TASKID_Minor_HrGetItem_QI_Failed,
0x50aca86d, 0x7ada, 0x40ad, 0xa0, 0x62, 0x64, 0x17, 0xa, 0xda, 0xc8, 0xe8);

// {F0B37EC2-6942-4ca1-9D60-CA3F1C622BB1}
DEFINE_GUID( TASKID_Minor_HrGetItem_OutOfMemory,
0xf0b37ec2, 0x6942, 0x4ca1, 0x9d, 0x60, 0xca, 0x3f, 0x1c, 0x62, 0x2b, 0xb1);

// {FACFF7A1-6419-420d-A9D0-16037E87567D}
DEFINE_GUID( TASKID_Minor_HrInit_OpenClusterResource_Failed,
0xfacff7a1, 0x6419, 0x420d, 0xa9, 0xd0, 0x16, 0x3, 0x7e, 0x87, 0x56, 0x7d);

// {E9BB1785-0CCF-4413-9BFD-45FBA6772F1B}
DEFINE_GUID( TASKID_Minor_HrInit_ScGetResourceProperties_Failed,
0xe9bb1785, 0xccf, 0x4413, 0x9b, 0xfd, 0x45, 0xfb, 0xa6, 0x77, 0x2f, 0x1b);

// {0FBA185E-0F12-48ae-9957-1F40994558AF}
DEFINE_GUID( TASKID_Minor_HrInit_ScMoveToPropertyByName_Failed,
0xfba185e, 0xf12, 0x48ae, 0x99, 0x57, 0x1f, 0x40, 0x99, 0x45, 0x58, 0xaf);

// {9206FB5A-9FF8-4aa6-AB95-6993D5334140}
DEFINE_GUID( TASKID_Minor_W2KProxy_PhysDisk_HrInit_InvalidArg,
0x9206fb5a, 0x9ff8, 0x4aa6, 0xab, 0x95, 0x69, 0x93, 0xd5, 0x33, 0x41, 0x40);

// {232BCA76-98CF-40ca-9E0C-FF0502B7849B}
DEFINE_GUID( TASKID_Minor_HrInit_OutOfMemory,
0x232bca76, 0x98cf, 0x40ca, 0x9e, 0xc, 0xff, 0x5, 0x2, 0xb7, 0x84, 0x9b);

// {7049CE22-11EF-4a09-92B3-5892E9C1BDB4}
DEFINE_GUID( TASKID_Minor_HrInit_ScGetResourceValueList_Failed,
0x7049ce22, 0x11ef, 0x4a09, 0x92, 0xb3, 0x58, 0x92, 0xe9, 0xc1, 0xbd, 0xb4);

// {C48BEE66-BB89-4a04-AB9E-ECEBF3D5A02C}
DEFINE_GUID( TASKID_Minor_HrInit_ClusterResourceControl_Failed,
0xc48bee66, 0xbb89, 0x4a04, 0xab, 0x9e, 0xec, 0xeb, 0xf3, 0xd5, 0xa0, 0x2c);

// {805FA623-96E7-4b8b-A4B6-50AEA0B0A6E1}
DEFINE_GUID( TASKID_HrInit_ScMoveToFirstValue_Failed,
0x805fa623, 0x96e7, 0x4b8b, 0xa4, 0xb6, 0x50, 0xae, 0xa0, 0xb0, 0xa6, 0xe1);

// {F8E8366F-F529-4295-8AB2-F311D4C5E527}
DEFINE_GUID( TASKID_HrInit_ScMoveToNextValue_Failed,
0xf8e8366f, 0xf529, 0x4295, 0x8a, 0xb2, 0xf3, 0x11, 0xd4, 0xc5, 0xe5, 0x27);

// {B25995A4-B839-4723-AB81-1BF9D54FA64D}
DEFINE_GUID( TASKID_HrInit_Create_CResourcePhysicalDiskPartition_Failed,
0xb25995a4, 0xb839, 0x4723, 0xab, 0x81, 0x1b, 0xf9, 0xd5, 0x4f, 0xa6, 0x4d);

// {955F1520-8306-4bc0-A4C3-93278F8A7C03}
DEFINE_GUID( TASKID_HrInit_QI_Failed,
0x955f1520, 0x8306, 0x4bc0, 0xa4, 0xc3, 0x93, 0x27, 0x8f, 0x8a, 0x7c, 0x3);

// {255B04C7-DBA1-4fc5-9EB6-7B48B52793CC}
DEFINE_GUID( TASKID_HrInit_ScMoveToNextValue2_Failed,
0x255b04c7, 0xdba1, 0x4fc5, 0x9e, 0xb6, 0x7b, 0x48, 0xb5, 0x27, 0x93, 0xcc);

// {89190A29-D520-4d53-AB92-679A92A08AE3}
DEFINE_GUID( TASKID_Minor_GetName_ScMoveToPropertyByName_MajorVersion_Failed,
0x89190a29, 0xd520, 0x4d53, 0xab, 0x92, 0x67, 0x9a, 0x92, 0xa0, 0x8a, 0xe3);

// {0F0680A3-27EA-47f2-9D31-FD97174FD7B1}
DEFINE_GUID( TASKID_Minor_GetName_InvalidPointer,
0xf0680a3, 0x27ea, 0x47f2, 0x9d, 0x31, 0xfd, 0x97, 0x17, 0x4f, 0xd7, 0xb1);

// {EC6968DE-9AA7-4905-ABCF-16D3C5FE5A3E}
DEFINE_GUID( TASKID_Minor_GetName_OutOfMemory,
0xec6968de, 0x9aa7, 0x4905, 0xab, 0xcf, 0x16, 0xd3, 0xc5, 0xfe, 0x5a, 0x3e);

// {28D5A7E7-942C-4c81-BA94-9C323E375E95}
DEFINE_GUID( TASKID_Minor_GetUID_ScMoveToFirstValue_Failed,
0x28d5a7e7, 0x942c, 0x4c81, 0xba, 0x94, 0x9c, 0x32, 0x3e, 0x37, 0x5e, 0x95);

// {5B32EE5E-093D-493e-A001-0C375B4936DD}
DEFINE_GUID( TASKID_Minor_GetUID_ScMoveToNextValue_Failed,
0x5b32ee5e, 0x93d, 0x493e, 0xa0, 0x1, 0xc, 0x37, 0x5b, 0x49, 0x36, 0xdd);

// {E2D22027-855D-4a3a-84C4-1274CFE9AE78}
DEFINE_GUID( TASKID_Minor_GetUID_InvalidPointer,
0xe2d22027, 0x855d, 0x4a3a, 0x84, 0xc4, 0x12, 0x74, 0xcf, 0xe9, 0xae, 0x78);

// {D34C3403-4440-471f-8188-E73477967B2F}
DEFINE_GUID( TASKID_Minor_GetUID_OutOfMemory,
0xd34c3403, 0x4440, 0x471f, 0x81, 0x88, 0xe7, 0x34, 0x77, 0x96, 0x7b, 0x2f);

// {A496B1F8-C227-4f4f-8E39-06105B37A6A6}
DEFINE_GUID( TASKID_Minor_Next_QI_Failed,
0xa496b1f8, 0xc227, 0x4f4f, 0x8e, 0x39, 0x6, 0x10, 0x5b, 0x37, 0xa6, 0xa6);

// {9BE21DA9-319B-430a-B909-7BBC96AAE3D0}
DEFINE_GUID( TASKID_Minor_W2kProxy_PhysDisk_Next_InvalidPointer,
0x9be21da9, 0x319b, 0x430a, 0xb9, 0x9, 0x7b, 0xbc, 0x96, 0xaa, 0xe3, 0xd0);

// {540B2FB4-A32E-4d9e-86AF-1921E9CFDBF3}
DEFINE_GUID( TASKID_Minor_HrInit_OpenClusterNetInterface_Failed,
0x540b2fb4, 0xa32e, 0x4d9e, 0x86, 0xaf, 0x19, 0x21, 0xe9, 0xcf, 0xdb, 0xf3);

// {E6D15E2A-2420-4f7c-A6CA-54F59E63F649}
DEFINE_GUID( TASKID_Minor_HrInit_ScGetNetworkProperties_Failed,
0xe6d15e2a, 0x2420, 0x4f7c, 0xa6, 0xca, 0x54, 0xf5, 0x9e, 0x63, 0xf6, 0x49);

// {2F1C8C49-24A8-461b-95BD-01BA3C8E3BC2}
DEFINE_GUID( TASKID_Minor_W2KProxy_NetworkInfo_HrInit_InvalidArg,
0x2f1c8c49, 0x24a8, 0x461b, 0x95, 0xbd, 0x1, 0xba, 0x3c, 0x8e, 0x3b, 0xc2);

// {F418431E-CA79-4824-959C-DFE6B651C451}
DEFINE_GUID( TASKID_Minor_GetUID_ScMoveToPropetyByName_Address_Failed,
0xf418431e, 0xca79, 0x4824, 0x95, 0x9c, 0xdf, 0xe6, 0xb6, 0x51, 0xc4, 0x51);

// {87F0AEE6-9053-4a96-B7C0-36D700061522}
DEFINE_GUID( TASKID_Minor_GetUID_ClRtlTcpipStringToAddress_Address_Failed,
0x87f0aee6, 0x9053, 0x4a96, 0xb7, 0xc0, 0x36, 0xd7, 0x0, 0x6, 0x15, 0x22);

// {3BAD166A-B3C9-4ba3-B317-DD8F39654971}
DEFINE_GUID( TASKID_Minor_GetUID_ClRtlTcpipStringToAddress_AddressMask_Failed,
0x3bad166a, 0xb3c9, 0x4ba3, 0xb3, 0x17, 0xdd, 0x8f, 0x39, 0x65, 0x49, 0x71);

// {C9AF04B0-761F-4f4a-8DC3-294D3B92B006}
DEFINE_GUID( TASKID_Minor_GetUID_ScMoveToPropetyByName_AddressMask_Failed,
0xc9af04b0, 0x761f, 0x4f4a, 0x8d, 0xc3, 0x29, 0x4d, 0x3b, 0x92, 0xb0, 0x6);

// {E27B766D-BE66-4f83-93BA-ED1E20B82AC7}
DEFINE_GUID( TASKID_Minor_GetUID_ClRtlTcpipAddressToString_Failed,
0xe27b766d, 0xbe66, 0x4f83, 0x93, 0xba, 0xed, 0x1e, 0x20, 0xb8, 0x2a, 0xc7);

// {A17BD776-A8F5-4f65-81D9-D34B9351766D}
DEFINE_GUID( TASKID_Minor_W2KProxy_NetworkInfo_GetUID_InvalidPointer,
0xa17bd776, 0xa8f5, 0x4f65, 0x81, 0xd9, 0xd3, 0x4b, 0x93, 0x51, 0x76, 0x6d);

// {4964954E-E203-497f-B330-00E97C2C732E}
DEFINE_GUID( TASKID_Minor_W2KProxy_NetworkInfo_GetUID_OutOfMemory,
0x4964954e, 0xe203, 0x497f, 0xb3, 0x30, 0x0, 0xe9, 0x7c, 0x2c, 0x73, 0x2e);

// {96E65D6B-865D-4bdd-BCBE-B7A64B1479BD}
DEFINE_GUID( TASKID_Minor_W2KProxy_NetworkInfo_GetName_ScMoveToPropertyByName_MajorVersion_Failed,
0x96e65d6b, 0x865d, 0x4bdd, 0xbc, 0xbe, 0xb7, 0xa6, 0x4b, 0x14, 0x79, 0xbd);

// {EE6EB070-06AE-443b-BB93-460C1DF15976}
DEFINE_GUID( TASKID_Minor_W2kProxy_NetworkInfo_GetName_InvalidPointer,
0xee6eb070, 0x6ae, 0x443b, 0xbb, 0x93, 0x46, 0xc, 0x1d, 0xf1, 0x59, 0x76);

// {09E61C3D-7381-4202-A201-02C5AF53D228}
DEFINE_GUID( TASKID_Minor_W2KProxy_NetworkInfo_GetName_OutOfMemory,
0x9e61c3d, 0x7381, 0x4202, 0xa2, 0x1, 0x2, 0xc5, 0xaf, 0x53, 0xd2, 0x28);

// {3D095700-CDF8-4208-A309-7A0594768E74}
DEFINE_GUID( TASKID_Minor_GetDescription_ScMoveToPropertyByName_MajorVersion_Failed,
0x3d095700, 0xcdf8, 0x4208, 0xa3, 0x9, 0x7a, 0x5, 0x94, 0x76, 0x8e, 0x74);

// {34ADDED3-7E50-44c0-B19B-0B254D5B39F6}
DEFINE_GUID( TASKID_Minor_GetDescription_InvalidPointer,
0x34added3, 0x7e50, 0x44c0, 0xb1, 0x9b, 0xb, 0x25, 0x4d, 0x5b, 0x39, 0xf6);

// {ACF05075-7F27-4a46-8764-BC3C4540F47C}
DEFINE_GUID( TASKID_Minor_GetDescription_OutOfMemory,
0xacf05075, 0x7f27, 0x4a46, 0x87, 0x64, 0xbc, 0x3c, 0x45, 0x40, 0xf4, 0x7c);

// {80283A7F-9287-4675-95B0-82A7A86477E8}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress_ScMoveToPropetyByName_Address_Failed,
0x80283a7f, 0x9287, 0x4675, 0x95, 0xb0, 0x82, 0xa7, 0xa8, 0x64, 0x77, 0xe8);

// {987C78B3-DA64-4564-8A15-FCF7FD11417B}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress_ClRtlTcpipStringToAddress_Address_Failed,
0x987c78b3, 0xda64, 0x4564, 0x8a, 0x15, 0xfc, 0xf7, 0xfd, 0x11, 0x41, 0x7b);

// {5BBE6DAD-E22F-4739-81CC-1960F0C20AAB}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress_ScMoveToPropetyByName_AddressMask_Failed,
0x5bbe6dad, 0xe22f, 0x4739, 0x81, 0xcc, 0x19, 0x60, 0xf0, 0xc2, 0xa, 0xab);

// {23D52E63-D12C-43f8-8538-427ED0395580}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress_ClRtlTcpipStringToAddress_AddressMask_Failed,
0x23d52e63, 0xd12c, 0x43f8, 0x85, 0x38, 0x42, 0x7e, 0xd0, 0x39, 0x55, 0x80);

// {1B9AE821-AF42-4080-A779-3CD755AFCCC8}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress_Create_CProxyCfgIPAddressInfo_Failed,
0x1b9ae821, 0xaf42, 0x4080, 0xa7, 0x79, 0x3c, 0xd7, 0x55, 0xaf, 0xcc, 0xc8);

// {5C6C05F3-1090-4e63-9EF2-874802EE278A}
DEFINE_GUID( TASKID_Minor_GetPrimaryNetworkAddress_InvalidPointer,
0x5c6c05f3, 0x1090, 0x4e63, 0x9e, 0xf2, 0x87, 0x48, 0x2, 0xee, 0x27, 0x8a);

// {93591182-EDFB-4e5e-A26F-143748C1BB08}
DEFINE_GUID( TASKID_Minor_IsPublic_ScMoveToPropetyByName_Address_Failed,
0x93591182, 0xedfb, 0x4e5e, 0xa2, 0x6f, 0x14, 0x37, 0x48, 0xc1, 0xbb, 0x8);

// {93796908-CBC9-43e4-9016-2F375806D201}
DEFINE_GUID( TASKID_Minor_IsPrivate_ScMoveToPropetyByName_Address_Failed,
0x93796908, 0xcbc9, 0x43e4, 0x90, 0x16, 0x2f, 0x37, 0x58, 0x6, 0xd2, 0x1);

// {966039B7-A549-4774-93C6-C16521F85C03}
DEFINE_GUID( TASKID_Minor_W2KProxy_IPAddressInfo_HrInit_InvalidArg,
0x966039b7, 0xa549, 0x4774, 0x93, 0xc6, 0xc1, 0x65, 0x21, 0xf8, 0x5c, 0x3);

// {5DB84C20-C71C-4c37-8185-9E954B8DC370}
DEFINE_GUID( TASKID_Minor_W2KProxy_IPAddressInfo_GetUID_ClRtlTcpipAddressToString_Failed,
0x5db84c20, 0xc71c, 0x4c37, 0x81, 0x85, 0x9e, 0x95, 0x4b, 0x8d, 0xc3, 0x70);

// {D2AA1F54-CD22-4a42-B926-8243E8B97FDC}
DEFINE_GUID( TASKID_Minor_W2kProxy_IPAddressInfo_GetName_InvalidPointer,
0xd2aa1f54, 0xcd22, 0x4a42, 0xb9, 0x26, 0x82, 0x43, 0xe8, 0xb9, 0x7f, 0xdc);

// {600F2D37-72EC-40af-8850-16C43E72F83C}
DEFINE_GUID( TASKID_Minor_W2KProxy_IPAddressInfo_GetUID_OutOfMemory,
0x600f2d37, 0x72ec, 0x40af, 0x88, 0x50, 0x16, 0xc4, 0x3e, 0x72, 0xf8, 0x3c);

// {AAC251F6-F902-4824-9C88-72FE3F4F2098}
DEFINE_GUID( TASKID_Minor_GetIPAddress_InvalidPointer,
0xaac251f6, 0xf902, 0x4824, 0x9c, 0x88, 0x72, 0xfe, 0x3f, 0x4f, 0x20, 0x98);

// {458045A2-5AA7-45b6-BF44-2F725113E8B0}
DEFINE_GUID( TASKID_Minor_GetSubnetMask_InvalidPointer,
0x458045a2, 0x5aa7, 0x45b6, 0xbf, 0x44, 0x2f, 0x72, 0x51, 0x13, 0xe8, 0xb0);

// {44EE7A1A-EC06-4d06-AC50-103C201D58FA}
DEFINE_GUID( TASKID_Minor_HrInit_GetClusterInformation_Failed,
0x44ee7a1a, 0xec06, 0x4d06, 0xac, 0x50, 0x10, 0x3c, 0x20, 0x1d, 0x58, 0xfa);

// {BBE9914E-7CA8-4ac2-92BB-5B1CDD536132}
DEFINE_GUID( TASKID_Minor_W2KProxy_ClusterInfo_HrInit_InvalidArg,
0xbbe9914e, 0x7ca8, 0x4ac2, 0x92, 0xbb, 0x5b, 0x1c, 0xdd, 0x53, 0x61, 0x32);

// {ECF5732D-83A1-4cfc-88EF-01701B4A1EBC}
DEFINE_GUID( TASKID_Minor_W2KProxy_ClusterInfo_HrInit_OutOfMemory,
0xecf5732d, 0x83a1, 0x4cfc, 0x88, 0xef, 0x1, 0x70, 0x1b, 0x4a, 0x1e, 0xbc);

// {8C42896F-0B5F-475e-BAF3-2942C9C13B59}
DEFINE_GUID( TASKID_Minor_W2kProxy_ClusterInfo_GetName_InvalidPointer,
0x8c42896f, 0xb5f, 0x475e, 0xba, 0xf3, 0x29, 0x42, 0xc9, 0xc1, 0x3b, 0x59);

// {D5B1D012-04EA-4792-9D24-039B2246C109}
DEFINE_GUID( TASKID_Minor_W2KProxy_ClusterInfo_GetIPAddress_InvalidPointer,
0xd5b1d012, 0x4ea, 0x4792, 0x9d, 0x24, 0x3, 0x9b, 0x22, 0x46, 0xc1, 0x9);

// {C40B09FF-8FB0-465e-ABE9-2B5A958838C3}
DEFINE_GUID( TASKID_Minor_W2KProxy_ClusterInfo_GetSubnetMask_InvalidPointer,
0xc40b09ff, 0x8fb0, 0x465e, 0xab, 0xe9, 0x2b, 0x5a, 0x95, 0x88, 0x38, 0xc3);

// {BF026173-29F7-406b-AE59-DC6E2D2AA6DB}
DEFINE_GUID( TASKID_Minor_GetNetworkInfo_InvalidPointer,
0xbf026173, 0x29f7, 0x406b, 0xae, 0x59, 0xdc, 0x6e, 0x2d, 0x2a, 0xa6, 0xdb);

// {00FE754D-34BD-4e97-BCE4-C39E1D8D4222}
DEFINE_GUID( TASKID_Minor_GetClusterServiceAccountCredentials_InvalidPointer,
0xfe754d, 0x34bd, 0x4e97, 0xbc, 0xe4, 0xc3, 0x9e, 0x1d, 0x8d, 0x42, 0x22);

// {955A0957-DE24-4ad2-B4B8-14F7B0C51A18}
DEFINE_GUID( TASKID_Minor_HrLoadCredentials_OpenSCManager_Failed,
0x955a0957, 0xde24, 0x4ad2, 0xb4, 0xb8, 0x14, 0xf7, 0xb0, 0xc5, 0x1a, 0x18);

// {B2F03A50-FDFE-48e7-A63E-6472C9EC6AA7}
DEFINE_GUID( TASKID_Minor_HrLoadCredentials_OpenService_Failed,
0xb2f03a50, 0xfdfe, 0x48e7, 0xa6, 0x3e, 0x64, 0x72, 0xc9, 0xec, 0x6a, 0xa7);

// {C00865C0-EDFD-4691-A9EA-873FAB6BA88B}
DEFINE_GUID( TASKID_Minor_HrLoadCredentials_QueryServiceConfig_Failed,
0xc00865c0, 0xedfd, 0x4691, 0xa9, 0xea, 0x87, 0x3f, 0xab, 0x6b, 0xa8, 0x8b);

// {61664807-6139-4652-A819-7DE9EB4B0EAA}
DEFINE_GUID( TASKID_Minor_HrLoadCredentials_OutOfMemory,
0x61664807, 0x6139, 0x4652, 0xa8, 0x19, 0x7d, 0xe9, 0xeb, 0x4b, 0xe, 0xaa);

// {57E0A0EC-7BED-4fbd-BD26-EEE33FC6054A}
DEFINE_GUID( TASKID_Minor_W2KProxy_Resources_HrInit_ClusterOpenEnum_Failed,
0x57e0a0ec, 0x7bed, 0x4fbd, 0xbd, 0x26, 0xee, 0xe3, 0x3f, 0xc6, 0x5, 0x4a);

// {F9885CDE-E29C-40c9-BE63-7FE458EBD663}
DEFINE_GUID( TASKID_Minor_W2KProxy_Resources_Next_InvalidPointer,
0xf9885cde, 0xe29c, 0x40c9, 0xbe, 0x63, 0x7f, 0xe4, 0x58, 0xeb, 0xd6, 0x63);

// {45F664B7-8219-4457-B3DF-841889D90D5C}
DEFINE_GUID( TASKID_Minor_W2KProxy_Resources_HrGetItem_ClusterEnum_Failed,
0x45f664b7, 0x8219, 0x4457, 0xb3, 0xdf, 0x84, 0x18, 0x89, 0xd9, 0xd, 0x5c);

// {0FCE6BB7-FCDB-42d4-B795-9DFC01740268}
DEFINE_GUID( TASKID_Minor_HrGetItem_Create_CResourcePhysicalDisk_Failed,
0xfce6bb7, 0xfcdb, 0x42d4, 0xb7, 0x95, 0x9d, 0xfc, 0x1, 0x74, 0x2, 0x68);

// {98954BD2-0FBF-4017-91C4-F9DA40DFF602}
DEFINE_GUID( TASKID_Minor_W2KProxy_Resources_HrGetItem_QI_Failed,
0x98954bd2, 0xfbf, 0x4017, 0x91, 0xc4, 0xf9, 0xda, 0x40, 0xdf, 0xf6, 0x2);

// {780151B7-BE75-4a87-89FB-CF2B95BBB668}
DEFINE_GUID( TASKID_Minor_W2KProxy_Resources_HrGetItem_OutOfMemory,
0x780151b7, 0xbe75, 0x4a87, 0x89, 0xfb, 0xcf, 0x2b, 0x95, 0xbb, 0xb6, 0x68);

// {07A2104E-0C4C-4661-B19A-18E940421A3B}
DEFINE_GUID( TASKID_Minor_ConnectTo_GetObject_Failed,
0x7a2104e, 0xc4c, 0x4661, 0xb1, 0x9a, 0x18, 0xe9, 0x40, 0x42, 0x1a, 0x3b);

// {6437294D-0338-4482-B773-A19F4E30DEDB}
DEFINE_GUID( TASKID_Minor_ConnectTo_GetName_Failed,
0x6437294d, 0x338, 0x4482, 0xb7, 0x73, 0xa1, 0x9f, 0x4e, 0x30, 0xde, 0xdb);

// {6473FEB0-7BB0-4e38-A4C1-0DEBD9A7FA28}
DEFINE_GUID( TASKID_Minor_ConnectTo_GetType_Failed,
0x6473feb0, 0x7bb0, 0x4e38, 0xa4, 0xc1, 0xd, 0xeb, 0xd9, 0xa7, 0xfa, 0x28);

// {54587A22-FDD4-4df0-ADC1-DCAA2C677313}
DEFINE_GUID( TASKID_Minor_ConnectTo_CreateBinding_Failed,
0x54587a22, 0xfdd4, 0x4df0, 0xad, 0xc1, 0xdc, 0xaa, 0x2c, 0x67, 0x73, 0x13);

// {838A18DC-A2B4-40ce-9914-6C791DCB32E2}
DEFINE_GUID( TASKID_Minor_ConnectTo_OpenCluster_Failed,
0x838a18dc, 0xa2b4, 0x40ce, 0x99, 0x14, 0x6c, 0x79, 0x1d, 0xcb, 0x32, 0xe2);

// {09706575-33EE-4968-ACE4-5F07908A3008}
DEFINE_GUID( TASKID_Minor_ConnectToObject_GetObject_Failed,
0x9706575, 0x33ee, 0x4968, 0xac, 0xe4, 0x5f, 0x7, 0x90, 0x8a, 0x30, 0x8);

// {16CDA6FF-2F82-40fc-B5D1-2D2B9D5FE2E9}
DEFINE_GUID( TASKID_Minor_ConnectToObject_GetType_Failed,
0x16cda6ff, 0x2f82, 0x40fc, 0xb5, 0xd1, 0x2d, 0x2b, 0x9d, 0x5f, 0xe2, 0xe9);

// {7F6E7CE8-6522-4dc1-8FB3-9642E1DF8F59}
DEFINE_GUID( TASKID_Minor_ConnectToObject_InvalidCookie,
0x7f6e7ce8, 0x6522, 0x4dc1, 0x8f, 0xb3, 0x96, 0x42, 0xe1, 0xdf, 0x8f, 0x59);

// {81A66A97-F1C6-41cd-AE21-4764D8CC8E42}
DEFINE_GUID( TASKID_Minor_ConnectToObject_QI_Failed,
0x81a66a97, 0xf1c6, 0x41cd, 0xae, 0x21, 0x47, 0x64, 0xd8, 0xcc, 0x8e, 0x42);

// {BE3BB350-9357-4ecf-92D7-A544F7E144F6}
DEFINE_GUID( TASKID_Minor_ConnectToObject_NotInitialized,
0xbe3bb350, 0x9357, 0x4ecf, 0x92, 0xd7, 0xa5, 0x44, 0xf7, 0xe1, 0x44, 0xf6);

// {5435EE48-1C10-4e39-95D0-F44A13FC4437}
DEFINE_GUID( TASKID_Minor_GetBindingString_InvalidPointer,
0x5435ee48, 0x1c10, 0x4e39, 0x95, 0xd0, 0xf4, 0x4a, 0x13, 0xfc, 0x44, 0x37);

// {5F883479-8766-4abf-A829-4AEF0FD78E33}
DEFINE_GUID( TASKID_Minor_GetBindingString_OutOfMemory,
0x5f883479, 0x8766, 0x4abf, 0xa8, 0x29, 0x4a, 0xef, 0xf, 0xd7, 0x8e, 0x33);

// {C5F6777B-E7CC-4c95-89F3-8A3B129A0AC8}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo_NotANode,
0xc5f6777b, 0xe7cc, 0x4c95, 0x89, 0xf3, 0x8a, 0x3b, 0x12, 0x9a, 0xa, 0xc8);

// {81668FC6-A737-4552-A94B-965F57CBB959}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo_Create_CProxyCfgNodeInfo,
0x81668fc6, 0xa737, 0x4552, 0xa9, 0x4b, 0x96, 0x5f, 0x57, 0xcb, 0xb9, 0x59);

// {3EBCC239-9176-48aa-8E52-16FA7816F20E}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo_QI_Failed,
0x3ebcc239, 0x9176, 0x48aa, 0x8e, 0x52, 0x16, 0xfa, 0x78, 0x16, 0xf2, 0xe);

// {34F1C706-1044-42e7-9CB5-A7BCBC3CA4D3}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo_NotInitialized,
0x34f1c706, 0x1044, 0x42e7, 0x9c, 0xb5, 0xa7, 0xbc, 0xbc, 0x3c, 0xa4, 0xd3);

// {F9103FBD-AAED-4c7e-A630-C3E546B53EEC}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo_InvalidPointer,
0xf9103fbd, 0xaaed, 0x4c7e, 0xa6, 0x30, 0xc3, 0xe5, 0x46, 0xb5, 0x3e, 0xec);

// {EFC48139-4B6A-47ad-81DF-3856E1B3AB12}
DEFINE_GUID( TASKID_Minor_GetClusterNodeInfo_OutOfMemory,
0xefc48139, 0x4b6a, 0x47ad, 0x81, 0xdf, 0x38, 0x56, 0xe1, 0xb3, 0xab, 0x12);

// {7FABED13-F4DE-47dc-9C80-2A9151DBDC80}
DEFINE_GUID( TASKID_Minor_GetManagedResourcesEnum_Create_CEnumCfgResources_Failed,
0x7fabed13, 0xf4de, 0x47dc, 0x9c, 0x80, 0x2a, 0x91, 0x51, 0xdb, 0xdc, 0x80);

// {FD341F3D-0CB5-45f0-BA92-A16DE93803F1}
DEFINE_GUID( TASKID_Minor_GetManagedResourcesEnum_QI_Failed,
0xfd341f3d, 0xcb5, 0x45f0, 0xba, 0x92, 0xa1, 0x6d, 0xe9, 0x38, 0x3, 0xf1);

// {C96B12A9-E2F9-4217-BBCA-03F373ED9AAC}
DEFINE_GUID( TASKID_Minor_GetManagedResourcesEnum_NotInitialized,
0xc96b12a9, 0xe2f9, 0x4217, 0xbb, 0xca, 0x3, 0xf3, 0x73, 0xed, 0x9a, 0xac);

// {055C2FB6-B334-439f-A6A5-97386371EACC}
DEFINE_GUID( TASKID_Minor_GetManagedResourcesEnum_InvalidPointer,
0x55c2fb6, 0xb334, 0x439f, 0xa6, 0xa5, 0x97, 0x38, 0x63, 0x71, 0xea, 0xcc);

// {1604E621-79BF-45cd-8B7B-4BC6EE0216AE}
DEFINE_GUID( TASKID_Minor_GetNetworksEnum_Create_CEnumCfgNetworks_Failed,
0x1604e621, 0x79bf, 0x45cd, 0x8b, 0x7b, 0x4b, 0xc6, 0xee, 0x2, 0x16, 0xae);

// {B333E856-117B-46a3-B056-9DFA53781169}
DEFINE_GUID( TASKID_Minor_GetNetworksEnum_QI_Failed,
0xb333e856, 0x117b, 0x46a3, 0xb0, 0x56, 0x9d, 0xfa, 0x53, 0x78, 0x11, 0x69);

// {0667C871-C3E0-49ce-B6A7-72DD14D50DCF}
DEFINE_GUID( TASKID_Minor_GetNetworksEnum_NotInitialized,
0x667c871, 0xc3e0, 0x49ce, 0xb6, 0xa7, 0x72, 0xdd, 0x14, 0xd5, 0xd, 0xcf);

// {560B07F2-AB0D-4bf9-BDD2-E7F2A1383CC8}
DEFINE_GUID( TASKID_Minor_GetNetworksEnum_InvalidPointer,
0x560b07f2, 0xab0d, 0x4bf9, 0xbd, 0xd2, 0xe7, 0xf2, 0xa1, 0x38, 0x3c, 0xc8);

// {76508AD7-85D9-4ee6-A86F-FA3ECF22F840}
DEFINE_GUID( TASKID_Minor_W2KProxy_GetClusterNodeInfo,
0x76508ad7, 0x85d9, 0x4ee6, 0xa8, 0x6f, 0xfa, 0x3e, 0xcf, 0x22, 0xf8, 0x40 );

// {BB578D5D-E862-4640-820D-D50B29871E71}
DEFINE_GUID( TASKID_Minor_W2KProxy_GetManagedResourcesEnum,
0xbb578d5d, 0xe862, 0x4640, 0x82, 0xd, 0xd5, 0xb, 0x29, 0x87, 0x1e, 0x71 );

// {2A4A1C98-5C10-4958-9509-FEAFFE6872DB}
DEFINE_GUID( TASKID_Minor_W2KProxy_GetNetworksEnum,
0x2a4a1c98, 0x5c10, 0x4958, 0x95, 0x9, 0xfe, 0xaf, 0xfe, 0x68, 0x72, 0xdb );

// {47935407-8F64-4971-B35A-1682372D10C7}
DEFINE_GUID( TASKID_Minor_HrInit_OpenClusterNode_Failed,
0x47935407, 0x8f64, 0x4971, 0xb3, 0x5a, 0x16, 0x82, 0x37, 0x2d, 0x10, 0xc7);

// {76BD3782-7468-4a1e-8193-DDB3885F679F}
DEFINE_GUID( TASKID_Minor_HrInit_ResUtilEnumResourcesEx_Failed,
0x76bd3782, 0x7468, 0x4a1e, 0x81, 0x93, 0xdd, 0xb3, 0x88, 0x5f, 0x67, 0x9f);

// {B4433748-DD2C-4b6d-9C2C-983D488C5E5C}
DEFINE_GUID( TASKID_Minor_HrInit_ScGetNodeProperties_Failed,
0xb4433748, 0xdd2c, 0x4b6d, 0x9c, 0x2c, 0x98, 0x3d, 0x48, 0x8c, 0x5e, 0x5c);

// {303DB937-B3CD-4d20-8062-40764E0DE21E}
DEFINE_GUID( TASKID_Minor_GetClusterConfigInfo_Create_CProxyCfgClusterInfo_Failed,
0x303db937, 0xb3cd, 0x4d20, 0x80, 0x62, 0x40, 0x76, 0x4e, 0xd, 0xe2, 0x1e);

// {4852B640-D2F1-4606-9917-60052BA6F28B}
DEFINE_GUID( TASKID_Minor_GetClusterConfigInfo_QI_Failed,
0x4852b640, 0xd2f1, 0x4606, 0x99, 0x17, 0x60, 0x5, 0x2b, 0xa6, 0xf2, 0x8b);

// {0929C6B4-139C-4528-BC72-3BB2976F6BA2}
DEFINE_GUID( TASKID_Minor_GetClusterConfigInfo_InvalidPointer,
0x929c6b4, 0x139c, 0x4528, 0xbc, 0x72, 0x3b, 0xb2, 0x97, 0x6f, 0x6b, 0xa2);

// {7D09EE97-7AC3-40b7-A11C-85CC947226FD}
DEFINE_GUID( TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_MajorVersion_Failed,
0x7d09ee97, 0x7ac3, 0x40b7, 0xa1, 0x1c, 0x85, 0xcc, 0x94, 0x72, 0x26, 0xfd);

// {E2F1D370-E1D7-4dc1-B299-00F78DE652A9}
DEFINE_GUID( TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_MinorVersion_Failed,
0xe2f1d370, 0xe1d7, 0x4dc1, 0xb2, 0x99, 0x0, 0xf7, 0x8d, 0xe6, 0x52, 0xa9);

// {EB344B23-20DF-40ba-8BAF-510F1D65B0A7}
DEFINE_GUID( TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_BuildNumber_Failed,
0xeb344b23, 0x20df, 0x40ba, 0x8b, 0xaf, 0x51, 0xf, 0x1d, 0x65, 0xb0, 0xa7);

// {6096C19C-CD2D-4849-8CF2-DB158AE891E1}
DEFINE_GUID( TASKID_Minor_GetOSVersion_ScMoveToPropertyByName_CSDVersion_Failed,
0x6096c19c, 0xcd2d, 0x4849, 0x8c, 0xf2, 0xdb, 0x15, 0x8a, 0xe8, 0x91, 0xe1);

// {1B912803-E1F0-4b2d-8C50-B9300EF08F99}
DEFINE_GUID( TASKID_Minor_GetOSVersion_InvalidPointer,
0x1b912803, 0xe1f0, 0x4b2d, 0x8c, 0x50, 0xb9, 0x30, 0xe, 0xf0, 0x8f, 0x99);

// {8DD80E3A-6F49-499f-B2B1-A6A8CE470A05}
DEFINE_GUID( TASKID_Minor_GetOSVersion_OutOfMemory,
0x8dd80e3a, 0x6f49, 0x499f, 0xb2, 0xb1, 0xa6, 0xa8, 0xce, 0x47, 0xa, 0x5);

// {A29910BF-A68D-44cf-8C92-4A0B70964B65}
DEFINE_GUID( TASKID_Minor_W2kProxy_NodeInfo_GetName_InvalidPointer,
0xa29910bf, 0xa68d, 0x44cf, 0x8c, 0x92, 0x4a, 0xb, 0x70, 0x96, 0x4b, 0x65);

// {C4F2FC21-632F-48f0-BC45-2F53C4AA6F93}
DEFINE_GUID( TASKID_Minor_W2KProxy_NodeInfo_GetName_OutOfMemory,
0xc4f2fc21, 0x632f, 0x48f0, 0xbc, 0x45, 0x2f, 0x53, 0xc4, 0xaa, 0x6f, 0x93);

// {82D15E31-DA75-4b1a-8DA6-6937D847EE28}
DEFINE_GUID( TASKID_Minor_GetClusterInformation_Failed,
0x82d15e31, 0xda75, 0x4b1a, 0x8d, 0xa6, 0x69, 0x37, 0xd8, 0x47, 0xee, 0x28);

// {DD9E98ED-3A3C-40f6-B46F-76A7105514D5}
DEFINE_GUID( TASKID_Minor_GetClusterVersion_InvalidPointer,
0xdd9e98ed, 0x3a3c, 0x40f6, 0xb4, 0x6f, 0x76, 0xa7, 0x10, 0x55, 0x14, 0xd5);

// {2B8B9073-2DCB-476e-818B-91146114E0FF}
DEFINE_GUID( TASKID_Minor_GetDriveLetterMappings_InvalidPointer,
0x2b8b9073, 0x2dcb, 0x476e, 0x81, 0x8b, 0x91, 0x14, 0x61, 0x14, 0xe0, 0xff);

// {F38332D5-05EE-4a27-9B79-B9F06C12F54A}
DEFINE_GUID( TASKID_Minor_W2kProxy_ClusterInfo_GetBindingString_InvalidPointer,
0xf38332d5, 0x5ee, 0x4a27, 0x9b, 0x79, 0xb9, 0xf0, 0x6c, 0x12, 0xf5, 0x4a);

// {BA303E05-C8DF-461c-A685-C19303D772E8}
DEFINE_GUID( TASKID_Minor_W2kProxy_NodeInfo_GetBindingString_InvalidPointer,
0xba303e05, 0xc8df, 0x461c, 0xa6, 0x85, 0xc1, 0x93, 0x3, 0xd7, 0x72, 0xe8);

// {E6519393-B216-4e8a-B50F-94819274ED27}
DEFINE_GUID( TASKID_Minor_W2KProxy_NodeInfo_GetBindingString_OutOfMemory,
0xe6519393, 0xb216, 0x4e8a, 0xb5, 0xf, 0x94, 0x81, 0x92, 0x74, 0xed, 0x27);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\test\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Galen Barbee (GalenB)       22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////

#define UNICODE
#define _UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
// Define these to change Interface Tracking
//#define NO_TRACE_INTERFACES
//#define NOISY_TRACE_INTERFACES
#define USES_SYSALLOCSTRING
#endif // DBG==1

//////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>

#include <common.h>
#include <debug.h>
#include <log.h>
#include <citracker.h>
#include <guids.h>
#include <ObjectCookie.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>

//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////
extern HINSTANCE g_hInstance;
extern LONG g_cObjects;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\w2kproxyresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      W2KProxyResources.h
//
//  Description:
//      Contains the definition of the string ids used by this library.
//      This file will be included in the main resource header of the project.
//
//  Maintained By:
//      Galen Barbee (GalenB) 28-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

// The starting ID for these strings.
#define ID_CCW2K_START    6000

/////////////////////////////////////////////////////////////////////
// Error strings
/////////////////////////////////////////////////////////////////////

#define IDS_F_SVR_CONNECT                   ( ID_CCW2K_START +  1 )
#define IDS_F_NODE_CONNECT                  ( ID_CCW2K_START +  2 )
#define IDS_SVR_CONNECT                     ( ID_CCW2K_START +  3 )
#define IDS_SVR_INIT                        ( ID_CCW2K_START +  4 )
#define IDS_INFO_NODE                       ( ID_CCW2K_START +  5 )
#define IDS_F_INFO_NODE                     ( ID_CCW2K_START +  6 )
#define IDS_INFO_RES                        ( ID_CCW2K_START +  7 )
#define IDS_F_INFO_RES                      ( ID_CCW2K_START +  8 )
#define IDS_INFO_NET                        ( ID_CCW2K_START +  9 )
#define IDS_F_INFO_NET                      ( ID_CCW2K_START + 10 )
#define IDS_GINFO_CLUSTER                   ( ID_CCW2K_START + 11 )
#define IDS_F_GINFO_CLUSTER                 ( ID_CCW2K_START + 12 )
#define IDS_GINFO_IPADDR                    ( ID_CCW2K_START + 13 )
#define IDS_F_GINFO_IPADDR                  ( ID_CCW2K_START + 14 )
#define IDS_GINFO_NET                       ( ID_CCW2K_START + 15 )
#define IDS_F_GINFO_NET                     ( ID_CCW2K_START + 16 )
#define IDS_GINFO_NODE                      ( ID_CCW2K_START + 17 )
#define IDS_F_GINFO_NODE                    ( ID_CCW2K_START + 18 )
#define IDS_INFO_CLUSTER                    ( ID_CCW2K_START + 19 )
#define IDS_F_INFO_CLUSTER                  ( ID_CCW2K_START + 20 )
#define IDS_GINFO_PDISK                     ( ID_CCW2K_START + 21 )
#define IDS_F_GINFO_PDISK                   ( ID_CCW2K_START + 22 )
#define IDS_WARNING_MINOR_BAD_CREDENTIALS   ( ID_CCW2K_START + 23 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\analyzepage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      AnalyzePage.cpp
//
//  Maintained By:
//      Galen Barbee  (GalenB)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskTreeView.h"
#include "AnalyzePage.h"
#include "WizardUtils.h"

DEFINE_THISCLASS("CAnalyzePage");

//
//  Special CLSID_Type for completion cookie.
//
#include <initguid.h>

// {C4173DE0-BB94-4869-8C80-1AC2BE84610F}
DEFINE_GUID( CLSID_AnalyzeTaskCompletionCookieType,
0xc4173de0, 0xbb94, 0x4869, 0x8c, 0x80, 0x1a, 0xc2, 0xbe, 0x84, 0x61, 0xf);

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAnalyzePage::CAnalyzePage(
//      IServiceProvider *  pspIn,
//      ECreateAddMode      ecamCreateAddModeIn,
//      ULONG *             pcCountIn,
//      BSTR **             prgbstrComputersIn,
//      BSTR *              pbstrClusterIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
CAnalyzePage::CAnalyzePage(
      IServiceProvider *  pspIn
    , ECreateAddMode      ecamCreateAddModeIn
    , ULONG *             pcCountIn
    , BSTR **             prgbstrComputersIn
    , BSTR *              pbstrClusterIn
    )
{
    TraceFunc( "" );

    // m_hwnd
    THR( pspIn->TypeSafeQI( IServiceProvider, &m_psp ) );
    m_pcCount             = pcCountIn;
    m_prgbstrComputerName = prgbstrComputersIn;
    m_pbstrClusterName    = pbstrClusterIn;
    m_fNext               = false;
    m_ecamCreateAddMode   = ecamCreateAddModeIn;
    m_cookieCluster       = 0;

    Assert( m_pbstrClusterName != NULL );

    m_cRef = 0;

    m_cookieCompletion = NULL;
    //  m_fTaskDone
    //  m_hrResult
    m_pttv             = NULL;
    m_bstrLogMsg       = NULL;
    m_pcpcb            = NULL;
    m_ptac             = NULL;
    m_pcpui            = NULL;
    m_dwCookieCallback = 0;

    m_dwCookieNotify = 0;

    TraceFuncExit();

} //*** CAnalyzePage::CAnalyzePage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CAnalyzePage::~CAnalyzePage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CAnalyzePage::~CAnalyzePage( void )
{
    TraceFunc( "" );

    //
    //  Cleanup our cookies.
    //

    THR( HrCleanupAnalysis() );

    //
    //  Now cleanup the object.
    //

    if ( m_psp != NULL )
    {
        m_psp->Release();
    }

    if ( m_pttv != NULL )
    {
        delete m_pttv;
    }

    TraceSysFreeString( m_bstrLogMsg );

    if ( m_pcpcb != NULL )
    {
        //  This should have been cleaned up in HrCleanupAnalysis()
        Assert( m_dwCookieCallback == 0 );
        m_pcpcb->Release();
    }

    if ( m_pcpui != NULL )
    {
        //  This should have been cleaned up in HrCleanupAnalysis()
        Assert( m_dwCookieNotify == 0 );
        m_pcpui->Release();
    }

    if ( m_ptac != NULL )
    {
        m_ptac->Release();
    } // if:

    Assert( m_cRef == 0 );

    TraceFuncExit();

} //*** CAnalyzePage::~CAnalyzePage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = FALSE; // didn't set focus

    //
    //  Initialize the tree view
    //

    m_pttv = new CTaskTreeView( m_hwnd, IDC_ANALYZE_TV_TASKS, IDC_ANALYZE_PRG_STATUS, IDC_ANALYZE_S_STATUS );
    if ( m_pttv == NULL )
    {
        goto OutOfMemory;
    }

    THR( m_pttv->HrOnInitDialog() );

Cleanup:
    RETURN( lr );

OutOfMemory:
    goto Cleanup;

} //*** CAnalyzePage::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnCommand(
//      UINT    idNotificationIn,
//      UINT    idControlIn,
//      HWND    hwndSenderIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_ANALYZE_PB_VIEW_LOG:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrViewLogFile( m_hwnd ) );
                lr = TRUE;
            } // if: button click
            break;

        case IDC_ANALYZE_PB_DETAILS:
            if ( idNotificationIn == BN_CLICKED )
            {
                Assert( m_pttv != NULL );
                THR( m_pttv->HrDisplayDetails() );
                lr = TRUE;
            }
            break;

        case IDC_ANALYZE_PB_REANALYZE:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrCleanupAnalysis() );
                OnNotifySetActive();
                lr = TRUE;
            }
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CAnalyzePage::OnCommand()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CAnalyzePage::HrUpdateWizardButtons( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAnalyzePage::HrUpdateWizardButtons( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    DWORD   dwFlags = PSWIZB_BACK | PSWIZB_NEXT;

    // Disable the back & next buttons if the task is not completed yet
    if ( ! m_fTaskDone )
    {
        dwFlags &= ~PSWIZB_BACK;
        dwFlags &= ~PSWIZB_NEXT;
    }

    // Disable the next button if an error occurred
    if ( FAILED (m_hrResult) )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }
    
    PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );

    EnableWindow( GetDlgItem( m_hwnd, IDC_ANALYZE_PB_REANALYZE ), m_fTaskDone );

    HRETURN( hr );

} //*** CAnalyzePage::HrUpdateWizardButtons()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnNotifyQueryCancel( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CAnalyzePage::OnNotifyQueryCancel()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    HRESULT                     hr = S_FALSE;
    ULONG                       idx;
    LRESULT                     lr = TRUE;
    BSTR                        bstrDescription = NULL;
    IUnknown *                  punk = NULL;
    IObjectManager *            pom  = NULL;
    ITaskManager *              ptm  = NULL;
    IConnectionPointContainer * pcpc = NULL;

    SendDlgItemMessage( m_hwnd, IDC_ANALYZE_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0, 0, 0x80 ) );

    if ( m_fNext )
    {
        m_fNext = false;

        hr = THR( HrUpdateWizardButtons() );
        goto Cleanup;
    }

    //
    //  Restore the instructions text.
    //

    m_hrResult = S_OK;

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_ANALYSIS_STARTING_INSTRUCTIONS, &bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SetDlgItemText( m_hwnd, IDC_ANALYZE_S_RESULTS, bstrDescription );

    //
    //  Clear the tree view and status line.
    //

    Assert( m_pttv != NULL );
    hr = THR( m_pttv->HrOnNotifySetActive() );
    if ( FAILED ( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Add the major root task nodes.
    //

    hr = THR( m_pttv->HrAddTreeViewRootItem( IDS_TASKID_MAJOR_CHECKING_FOR_EXISTING_CLUSTER,
                                             TASKID_Major_Checking_For_Existing_Cluster
                                             ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem( IDS_TASKID_MAJOR_ESTABLISH_CONNECTION,
                                             TASKID_Major_Establish_Connection
                                             ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem( IDS_TASKID_MAJOR_CHECK_NODE_FEASIBILITY,
                                             TASKID_Major_Check_Node_Feasibility
                                             ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem( IDS_TASKID_MAJOR_FIND_DEVICES,
                                             TASKID_Major_Find_Devices
                                             ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem( IDS_TASKID_MAJOR_CHECK_CLUSTER_FEASIBILITY,
                                             TASKID_Major_Check_Cluster_Feasibility
                                             ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Grab the notification manager.(if needed)
    //

    if ( m_pcpui == NULL || m_pcpcb == NULL )
    {
        hr = THR( m_psp->TypeSafeQS( CLSID_NotificationManager, IConnectionPointContainer, &pcpc ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( m_pcpui == NULL )
        {
            hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &m_pcpui ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }

        if ( m_pcpcb == NULL )
        {
            hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &m_pcpcb ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }
    }

    //
    //  Register to get UI notification (if needed)
    //

    if ( m_dwCookieNotify == 0 )
    {
        hr = THR( m_pcpui->Advise( static_cast< INotifyUI * >( this ), &m_dwCookieNotify ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    if ( m_dwCookieCallback == 0 )
    {
        hr = THR( m_pcpcb->Advise( static_cast< IClusCfgCallback * >( this ), &m_dwCookieCallback ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //
    //  Grab the object manager.
    //

    hr = THR( m_psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &pom ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Find the cluster cookie.
    //

    Assert( punk == NULL );
    Assert( m_cookieCluster == 0 );
    // don't wrap - this can fail
    hr = pom->FindObject( CLSID_ClusterConfigurationType,
                          NULL,
                          *m_pbstrClusterName,
                          DFGUID_ClusterConfigurationInfo,
                          &m_cookieCluster,
                          &punk
                          );
    if ( hr == HR_S_RPC_S_SERVER_UNAVAILABLE )
    {
        hr = S_OK;  // ignore it - we could be forming
    }
    else if ( hr == E_PENDING )
    {
        hr = S_OK;	// ignore it - we just want the cookie!
    }
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    }

    //
    //  We don't need the cluster configuration info. Release it.
    //

    if ( punk != NULL )
    {
        punk->Release();
        punk = NULL;
    }

    //
    //  Prime the middle tier by asking the object manager to find
    //  each node.
    //

    for ( idx = 0 ; idx < *m_pcCount ; idx ++ )
    {
        OBJECTCOOKIE    cookieDummy;

        // Don't wrap - this can fail with E_PENDING
        hr = pom->FindObject( CLSID_NodeType,
                              m_cookieCluster,
                              (*m_prgbstrComputerName)[ idx ],
                              DFGUID_NodeInformation,
                              &cookieDummy,
                              &punk
                              );
        if ( hr == E_PENDING )
        {
            continue;   // ignore
        }
        else if ( FAILED( hr ) )
        {
            THR( hr );
            goto Cleanup;
        }

        //
        //  Just free the object - we don't need it.
        //

        Assert( punk != NULL );
        punk->Release();
        punk = NULL;

    } // for: idx

    //
    //  Create a completion cookie.
    //

    Assert( punk == NULL );
    if ( m_cookieCompletion == NULL )
    {
        // Don't wrap - this can fail with E_PENDING
        hr = pom->FindObject( CLSID_AnalyzeTaskCompletionCookieType,
                              NULL,
                              *m_pbstrClusterName,
                              IID_NULL,
                              &m_cookieCompletion,
                              &punk // dummy
                              );
        Assert( punk == NULL );
        if ( hr == E_PENDING )
        {
            // no-op.
        }
        else if ( FAILED( hr ) )
        {
            THR( hr );
            goto Cleanup;
        }
    }

    //
    //  Grab the task manager.
    //

    hr = THR( m_psp->TypeSafeQS( CLSID_TaskManager, ITaskManager, &ptm ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Create a new analyze task.
    //

    hr = THR( ptm->CreateTask( TASK_AnalyzeCluster, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( ITaskAnalyzeCluster, &m_ptac ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_ptac->SetClusterCookie( m_cookieCluster ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_ptac->SetCookie( m_cookieCompletion ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( m_ecamCreateAddMode == camADDING )
    {
        hr = THR( m_ptac->SetJoiningMode() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }
    else
    {
        Assert( m_ecamCreateAddMode == camCREATING );
    }

    m_fTaskDone = false;    // reset before commiting task

    hr = THR( ptm->SubmitTask( m_ptac ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrUpdateWizardButtons() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( pom != NULL )
    {
        pom->Release();
    }

    if ( ptm != NULL )
    {
        ptm->Release();
    }

    if ( pcpc != NULL )
    {
        pcpc->Release();
    }

    TraceSysFreeString( bstrDescription );

//    if ( ptac != NULL )
//    {
//        ptac->Release();
//    }

    RETURN( lr );

} //*** CAnalyzePage::OnNotifySetActive()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnNotifyWizNext( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    m_fNext = true;

    RETURN( lr );

} //*** CAnalyzePage::OnNotifyWizNext()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnNotifyWizBack( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnNotifyWizBack( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    THR( HrCleanupAnalysis() );

    RETURN( lr );

} //*** CAnalyzePage::OnNotifyWizBack()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::HrCleanupAnalysis( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAnalyzePage::HrCleanupAnalysis( void )
{
    TraceFunc( "" );

    HRESULT             hr;
    IObjectManager *    pom  = NULL;
    CWaitCursor         WaitCursor;

    if ( m_ptac != NULL )
    {
        THR( m_ptac->StopTask() );
        m_ptac->Release();
        m_ptac = NULL;
    } // if:

    //
    //  Unregister to get UI notification (if needed)
    //

    if ( m_dwCookieNotify != 0 )
    {
        Assert( m_pcpui != NULL );
        hr = THR( m_pcpui->Unadvise( m_dwCookieNotify ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_dwCookieNotify = 0;
    }

    if ( m_dwCookieCallback != 0 )
    {
        Assert( m_pcpcb != NULL );
        hr = THR( m_pcpcb->Unadvise( m_dwCookieCallback ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_dwCookieCallback = 0;
    }

    //
    //  Grab the object manager.
    //

    hr = THR( m_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Cleanup our completion cookie.
    //

    if ( m_cookieCompletion != NULL )
    {
        hr = THR( pom->RemoveObject( m_cookieCompletion ) );
        m_cookieCompletion = NULL;
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //
    //  Remove the configuration because the user might change the
    //  name of the cluster or the user might be change the node
    //  membership, retrying analyze, etc... This makes sure that
    //  we start from scratch.
    //

    if ( m_cookieCluster != 0 )
    {
        hr = THR( pom->RemoveObject( m_cookieCluster ) );
        m_cookieCluster = 0;
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

Cleanup:

    if ( pom != NULL )
    {
        pom->Release();
    }

    RETURN( hr );

} //*** CAnalyzePage::HrCleanupAnalysis()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CAnalyzePage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CAnalyzePage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_WIZNEXT:
            lr = OnNotifyWizNext();
            break;

        case PSN_WIZBACK:
            lr = OnNotifyWizBack();
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;

        default:
            if (    ( idCtrlIn == IDC_ANALYZE_TV_TASKS )
                &&  ( m_pttv != NULL ) )
            {
                // Pass the notification on to the tree control.
                lr = m_pttv->OnNotify( pnmhdrIn );
            }
            break;
    } // switch: notify code

    RETURN( lr );

} //*** CAnalyzePage::OnNotify()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT_PTR
//  CALLBACK
//  CAnalyzePage::S_DlgProc(
//      HWND    hwndDlgIn,
//      UINT    nMsgIn,
//      WPARAM  wParam,
//      LPARAM  lParam
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CAnalyzePage::S_DlgProc(
    HWND    hwndDlgIn,
    UINT    nMsgIn,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CAnalyzePage * pPage;

    if ( nMsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CAnalyzePage * >( ppage->lParam );
        pPage->m_hwnd = hwndDlgIn;
    }
    else
    {
        pPage = reinterpret_cast< CAnalyzePage * >( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );
    }

    if ( pPage != NULL )
    {
        Assert( hwndDlgIn == pPage->m_hwnd );

        switch( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr = pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), reinterpret_cast< HWND >( lParam ) );
                break;

            // no default clause needed
        } // switch: nMsgIn
    } // if: page is specified

    return lr;

} //*** CAnalyzePage::S_DlgProc()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CAnalyzePage::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAnalyzePage::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< INotifyUI * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_INotifyUI ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
        hr = S_OK;
    } // else if: INotifyUI
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
        hr = S_OK;
    } // else if: IClusCfgCallback

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CAnalyzePage::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CAnalyzePage::AddRef( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CAnalyzePage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CAnalyzePage::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CAnalyzePage::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CAnalyzePage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        // do nothing -- COM interface does not control object lifetime
    }

    RETURN( cRef );

} //*** CAnalyzePage::Release()


//****************************************************************************
//
//  INotifyUI
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CAnalyzePage::ObjectChanged(
//      OBJECTCOOKIE cookieIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAnalyzePage::ObjectChanged(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[INotifyUI" );

    HRESULT hr = S_OK;

    BSTR    bstrDescription = NULL;

    IUnknown *          punk = NULL;
    IObjectManager *    pom  = NULL;
    IStandardInfo *     psi  = NULL;

    if ( cookieIn == m_cookieCompletion )
    {
        hr = THR( m_psp->TypeSafeQS( CLSID_ObjectManager,
                                     IObjectManager,
                                     &pom
                                     ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( pom->GetObject( DFGUID_StandardInfo,
                                  m_cookieCompletion,
                                  &punk
                                  ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( psi->GetStatus( &m_hrResult ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        hr = THR( m_pttv->HrShowStatusAsDone() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_fTaskDone = true;

        hr = THR( HrUpdateWizardButtons() );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( SUCCEEDED( m_hrResult ) )
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                            IDS_ANALYSIS_SUCCESSFUL_INSTRUCTIONS,
                                            &bstrDescription
                                            ) );

            SendDlgItemMessage( m_hwnd, IDC_ANALYZE_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0, 0x80, 0 ) );
        }
        else
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                            IDS_ANALYSIS_FAILED_INSTRUCTIONS,
                                            &bstrDescription
                                            ) );

            SendDlgItemMessage( m_hwnd, IDC_ANALYZE_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0x80, 0, 0 ) );
        }

        SetDlgItemText( m_hwnd, IDC_ANALYZE_S_RESULTS, bstrDescription );

        hr = THR( m_pcpcb->Unadvise( m_dwCookieCallback ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        m_dwCookieCallback = 0;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }


    TraceSysFreeString( bstrDescription );

    if ( pom != NULL )
    {
        pom->Release();
    }

    if ( psi != NULL )
    {
        psi->Release();
    }

    HRETURN( hr );

} //*** CAnalyzePage::ObjectChanged()



//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CAnalyzePage::SendStatusReport(
//        LPCWSTR    pcszNodeNameIn
//      , CLSID      clsidTaskMajorIn
//      , CLSID      clsidTaskMinorIn
//      , ULONG      ulMinIn
//      , ULONG      ulMaxIn
//      , ULONG      ulCurrentIn
//      , HRESULT    hrStatusIn
//      , LPCWSTR    pcszDescriptionIn
//      , FILETIME * pftTimeIn
//      , LPCWSTR    pcszReferenceIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CAnalyzePage::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hr;

    hr = THR( m_pttv->HrOnSendStatusReport(
                                          pcszNodeNameIn
                                        , clsidTaskMajorIn
                                        , clsidTaskMinorIn
                                        , ulMinIn
                                        , ulMaxIn
                                        , ulCurrentIn
                                        , hrStatusIn
                                        , pcszDescriptionIn
                                        , pftTimeIn
                                        , pcszReferenceIn
                                        ) );

    HRETURN( hr );

} //*** CAnalyzePage::SendStatusReport()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\test\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      main.cpp
//
//  Description:
//      The entry point for the application that launches unattended
//      installation of the cluster. This application parses input parameters,
//      CoCreates the Configuration Wizard Component, passes the parsed
//      parameters and invokes the Wizard. The Wizard may or may not show any
//      UI depending on swithes and the (in)availability of information.
//
//  Maintained By:
//      Geoffrey Pease (GPease)     22-JAN-2000
//      Vijay Vasu (VVasu)          22-JAN-2000
//      Galen Barbee (GalenB)       22-JAN-2000
//      David Potter (DavidP)       22-JAN-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "pch.h"
#include <initguid.h>
#include <guids.h>
#include <ClusRtl.h>

DEFINE_MODULE( "W2KPROXYTEST" )

//
//  Declarations
//
typedef HRESULT (* PDLLREGISTERSERVER)( void );

//
//  Globals
//
HINSTANCE           g_hInstance = NULL;
LONG                g_cObjects  = 0;
IClusCfgServer *    g_pccs      = NULL;


//
//  Register the DLL
//
HRESULT
HrRegisterTheDll( void )
{
    TraceFunc( "" );

    HRESULT hr;

    PDLLREGISTERSERVER  pDllRegisterServer;

    HMODULE hLib    = NULL;

    //
    //  Make sure the DLL is properly registered.
    //

    hLib = LoadLibrary( L"..\\..\\..\\..\\dll\\obj\\i386\\ClusCfgServer.dll" );
    if ( hLib == NULL )
        goto Win32Error;

    pDllRegisterServer = reinterpret_cast< PDLLREGISTERSERVER >( GetProcAddress( hLib, "DllRegisterServer" ) );
    if ( pDllRegisterServer == NULL )
        goto Win32Error;

    hr = THR( pDllRegisterServer() );
    if ( FAILED( hr ) )
        goto CleanUp;

CleanUp:

    if ( hLib != NULL )
    {
        FreeLibrary( hLib );
    }

    HRETURN( hr );

Win32Error:
    hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
    goto CleanUp;
}

//
//  This tests the Storage device enumeration.
//
HRESULT
HrTestManagedResourceEnum( void )
{
    TraceFunc( "" );

    HRESULT                         hr;
    IEnumClusCfgManagedResources *  pesd    = NULL;
    ULONG                           cReceived = 0;
    IClusCfgManagedResourceInfo *   rgDevices[ 10 ];

    hr = g_pccs->GetManagedResourcesEnum( &pesd );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    while ( hr == S_OK )
    {
        hr = pesd->Next( sizeof( rgDevices ) / sizeof( rgDevices[ 0 ] ), &rgDevices[ 0 ], &cReceived );
        if ( FAILED( hr ) )
        {
            goto CleanUp;
        } // if:

        DebugMsg( "cReceived = %u", cReceived );

        for ( ULONG idx = 0; idx < cReceived; idx++ )
        {
            BSTR    bstr;

            THR( rgDevices[ idx ]->GetUID( &bstr ) );
            DebugMsg( "Device %u, UID = %ws", idx, bstr );
            SysFreeString( bstr );
            rgDevices[ idx ]->Release();
        } // for:
    } // while:

    if ( hr == S_FALSE )
    {
        hr = S_OK;
    } // if:

CleanUp:

    if ( pesd != NULL )
    {
        pesd->Release();
    }

    HRETURN( hr );

} //*** HrTestManagedResourceEnum()


//
//  This tests the Storage device enumeration.
//
HRESULT
HrTestNetworksEnum( void )
{
    TraceFunc( "" );

    HRESULT                 hr;
    IEnumClusCfgNetworks *  pens    = NULL;
    ULONG                   cReceived = 0;
    IClusCfgNetworkInfo *   rdNetworks[ 10 ];
    BSTR                    bstrUID;
    LPWSTR                  lpsz = NULL;
    ULONG                   ulDottedQuad;
    IClusCfgIPAddressInfo * piccipai = NULL;

    hr = g_pccs->GetNetworksEnum( &pens );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    while ( hr == S_OK )
    {
        hr = STHR( pens->Next( sizeof( rdNetworks ) / sizeof( rdNetworks[ 0 ] ), &rdNetworks[ 0 ], &cReceived ) );
        if ( FAILED( hr ) )
        {
            goto CleanUp;
        } // if:

        for ( ULONG idx = 0; idx < cReceived; idx++ )
        {
            hr = THR( rdNetworks[ idx ]->GetPrimaryNetworkAddress( &piccipai ) );
            if ( SUCCEEDED( hr ) )
            {
                hr = THR( piccipai->GetIPAddress( &ulDottedQuad ) );
                if ( SUCCEEDED( hr ) )
                {
                    DWORD   sc;

                    sc = ClRtlTcpipAddressToString( ulDottedQuad, &lpsz );
                    if ( sc == ERROR_SUCCESS )
                    {
                        LocalFree( lpsz );
                        lpsz = NULL;
                    } // if:
                } // if:

                piccipai->Release();
            } // if:

            hr = THR( rdNetworks[ idx ]->GetUID( &bstrUID ) );
            if ( SUCCEEDED( hr ) )
            {
                SysFreeString( bstrUID );
            } // if:

            rdNetworks[ idx ]->Release();
        } // for:
    } // while:

    if ( hr == S_FALSE )
    {
        hr = S_OK;
    } // if:

CleanUp:

    if ( pens != NULL )
    {
        pens->Release();
    }

    if ( lpsz != NULL )
    {
        LocalFree( lpsz );
    } // if:

    HRETURN( hr );

} //*** HrTestNetworksEnum()


//
//  This tests the node information
//
HRESULT
HrTestNodeInfo( void )
{
    TraceFunc( "" );

    HRESULT                 hr;
    IClusCfgNodeInfo *      pccni   = NULL;
    DWORD                   dwNodeHighestVersion;
    DWORD                   dwNodeLowestVersion;
    SDriveLetterMapping     dlmDriveLetterUsage;
    IClusCfgClusterInfo *   pccci = NULL;
    DWORD                   dwMajorVersion;
    DWORD                   dwMinorVersion;
    WORD                    wSuiteMask;
    BYTE                    bProductType;
    BSTR                    bstrCSDVersion = NULL;

    hr = g_pccs->GetClusterNodeInfo( &pccni );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = pccni->GetClusterVersion( &dwNodeHighestVersion, &dwNodeLowestVersion );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = pccni->GetOSVersion( &dwMajorVersion, &dwMinorVersion, &wSuiteMask, &bProductType, &bstrCSDVersion );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = pccni->GetDriveLetterMappings( &dlmDriveLetterUsage );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = pccni->GetClusterConfigInfo( &pccci );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

CleanUp:

    if ( pccci != NULL )
    {
        pccci->Release();
    }

    if ( pccni != NULL )
    {
        pccni->Release();
    }

    SysFreeString( bstrCSDVersion );

    HRETURN( hr );

} //*** HrTestNodeInfo()


//////////////////////////////////////////////////////////////////////////////
//
//  int
//  _cdecl
//  main( void )
//
//  Description:
//      Program entrance.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK (0)        - Success.
//      other HRESULTs  - Error.
//
//////////////////////////////////////////////////////////////////////////////
int _cdecl
main( void )
{
    HRESULT                     hr;
    BSTR                        bstrClusterName = NULL;
    IClusCfgInitialize *        pgcci = NULL;
    IClusCfgCapabilities *      piccc = NULL;
    IClusCfgClusterConnection * picccc = NULL;

    TraceInitializeProcess();

#if 0
    hr = THR( HrRegisterTheDll() );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:
#endif

    bstrClusterName = TraceSysAllocString( L"GalenB-Clus.ntdev.microsoft.com" );
    if ( bstrClusterName == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto CleanUp;
    } // if:

    //
    //  Start up the Cluster configuration server
    //

    hr = THR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( CoInitializeSecurity(
                    NULL,
                    -1,
                    NULL,
                    NULL,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_NONE,
                    0
                    ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( CoCreateInstance( CLSID_ConfigClusApi, NULL, CLSCTX_SERVER, TypeSafeParams( IClusCfgServer, &g_pccs ) ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( g_pccs->TypeSafeQI( IClusCfgInitialize, &pgcci ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = pgcci->Initialize( NULL, GetUserDefaultLCID() );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( g_pccs->TypeSafeQI( IClusCfgCapabilities, &piccc ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( piccc->CanNodeBeClustered() );
    if ( FAILED( hr ) || ( hr == S_FALSE ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( g_pccs->TypeSafeQI( IClusCfgClusterConnection, &picccc ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( picccc->OpenConnection( bstrClusterName ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( HrTestNodeInfo() );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( HrTestManagedResourceEnum() );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    hr = THR( HrTestNetworksEnum() );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

CleanUp:

    TraceSysFreeString( bstrClusterName );

    if ( piccc != NULL )
    {
        piccc->Release();
    } // if:

    if ( picccc != NULL )
    {
        picccc->Release();
    } // if:

    if ( pgcci != NULL )
    {
        pgcci->Release();
    } // if:

    if ( g_pccs != NULL )
    {
        g_pccs->Release();
    }

    CoUninitialize();

    TraceTerminateProcess();

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\w2kproxy\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Galen Barbee (GalenB)   02-AUG-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE = 1
#define _UNICODE = 1

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING
#endif // DBG==1 || _DEBUG

const   int     TIMEOUT = -1;
const   int     PUNKCHUNK = 10;


//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <Pragmas.h>
#include <windows.h>
#include <objbase.h>
#include <wchar.h>
#include <ComCat.h>
#include <clusapi.h>
#include <ClusRtl.h>

#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <guids.h>

#include <loadstring.h>
#include <PropList.h>

#include <ObjectCookie.h>
#include <ClusCfgClient.h>
#include <ClusCfgGuids.h>
#include <ClusCfgServer.h>
#include <ClusCfgPrivate.h>

#include "ClusterUtils.h"

#include "W2KProxyResources.h"
#include <StatusReports.h>
#include "W2KProxyServerGuids.h"

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

//
//  Failure code.
//

#define SSR_W2KPROXY_STATUS( _major, _minor, _hr ) \
    {   \
        HRESULT hrTemp; \
        hrTemp = THR( SendStatusReport( NULL, _major, _minor, 0, 1, 1, _hr, NULL, NULL, NULL ) );   \
        if ( FAILED( hrTemp ) ) \
        {   \
            _hr = hrTemp;   \
        }   \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\analyzepage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      AnalyzePage.h
//
//  Maintained By:
//      Galen Barbee  (GalenB)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CAnalyzePage
    :   public INotifyUI
    ,   public IClusCfgCallback
{
friend class CClusCfgWizard;

private: // data
    HWND                    m_hwnd;                 // Our HWND
    IServiceProvider *      m_psp;                  // Service Manager
    ULONG *                 m_pcCount;              // Count of computers in list
    BSTR **                 m_prgbstrComputerName;  // List of computer names
    BSTR *                  m_pbstrClusterName;     // Cluster Name to analyze
    bool                    m_fNext;                // If Next was pressed...
    ECreateAddMode          m_ecamCreateAddMode;    // Creating or adding?
    OBJECTCOOKIE            m_cookieCluster;        // Cluster cookie
    ITaskAnalyzeCluster *   m_ptac;

    //  IUnknown
    LONG                    m_cRef;                 // Reference count

    //  IClusCfgCallback
    OBJECTCOOKIE            m_cookieCompletion;     // Completion cookie
    bool                    m_fTaskDone;            // Is the task done yet?
    HRESULT                 m_hrResult;             // Result of the analyze task
    CTaskTreeView *         m_pttv;                 // Task TreeView
    BSTR                    m_bstrLogMsg;           // Reusable logging buffer.
    IConnectionPoint *      m_pcpcb;                // IClusCfgCallback Connection Point
    DWORD                   m_dwCookieCallback;     // Notification registration cookie

    //  INotifyUI
    IConnectionPoint *      m_pcpui;                // INotifyUI Connection Point
    DWORD                   m_dwCookieNotify;       // Notification registration cookie

private: // methods
    CAnalyzePage( IServiceProvider *    pspIn,
                  ECreateAddMode        ecamCreateAddModeIn,
                  ULONG *               pcCountIn,
                  BSTR **               prgbstrComputersIn,
                  BSTR *                pbstrClusterIn
                  );
    ~CAnalyzePage( void );

    LRESULT OnInitDialog( void );
    LRESULT OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT OnNotifyQueryCancel( void );
    LRESULT OnNotifySetActive( void );
    LRESULT OnNotifyWizNext( void );
    LRESULT OnNotifyWizBack( void );
    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT HrUpdateWizardButtons( void );
    HRESULT HrCleanupAnalysis( void );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  INotifyUI
    STDMETHOD( ObjectChanged )( OBJECTCOOKIE cookieIn);

    //  IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                      LPCWSTR    pcszNodeNameIn
                    , CLSID      clsidTaskMajorIn
                    , CLSID      clsidTaskMinorIn
                    , ULONG      ulMinIn
                    , ULONG      ulMaxIn
                    , ULONG      ulCurrentIn
                    , HRESULT    hrStatusIn
                    , LPCWSTR    pcszDescriptionIn
                    , FILETIME * pftTimeIn
                    , LPCWSTR    pcszReferenceIn
                    );

}; //*** class CAnalyzePage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\checkingaccesspage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CheckingAccessPage.h
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    17-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CCheckingAccessPage
    : public ITaskLoginDomainCallback
{
friend class CClusCfgWizard;

private: // data
    HWND                m_hwnd;                 // Our HWND
    IServiceProvider *  m_psp;                  // Service Manager
    BOOL *              m_pfShowCredentialsPage;
    BSTR *              m_pbstrClusterName;
    BOOL                m_fNext:1;              // If next was pressed.

    //  IUnknown
    LONG                m_cRef;

    // ITaskLoginDomainCallback
    ITaskLoginDomain *  m_ptld;                 // Login Domain Task
    HANDLE              m_hEvent;               // Event that is singaled when TaskLoginDomain is done.
    HRESULT             m_hrResult;             // The result of the TaskLoginDomain.

private: // methods
    CCheckingAccessPage( IServiceProvider * pspIn, BSTR * pbstrClusterIn,
                         BOOL * pfShowCredentialsPageIn );
    virtual ~CCheckingAccessPage();

    LRESULT
        OnInitDialog( void );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT
        OnNotifySetActive( void );
    LRESULT
        OnNotifyWizNext( void );
    LRESULT
        OnNotifyWizBack( void );
    LRESULT
        OnNotifyQueryCancel( void );
    LRESULT
        OnTimer( void );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  ITaskLoginDomainCallback
    STDMETHOD( ReceiveLoginResult )( HRESULT hrIn );

};  // class CCheckingAccessPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\checkingaccesspage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CheckingAccessPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    22-MAR-2001
//      Geoffrey Pease  (GPease)    17-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "CheckingAccessPage.h"

DEFINE_THISCLASS("CCheckingAccessPage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCheckingAccessPage::CCheckingAccessPage(
//      IServiceProvider *  pspIn,
//      BSTR *              pbstrClusterNameIn,
//      BOOL *              pfShowCredentialsPageIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCheckingAccessPage::CCheckingAccessPage(
    IServiceProvider *  pspIn,
    BSTR *              pbstrClusterNameIn,
    BOOL *              pfShowCredentialsPageIn
    )
{
    TraceFunc( "" );

    // m_hwnd
    THR( pspIn->TypeSafeQI( IServiceProvider, &m_psp ) );
    m_pfShowCredentialsPage = pfShowCredentialsPageIn;
    m_pbstrClusterName      = pbstrClusterNameIn;
    m_fNext                 = FALSE;

    m_cRef                  = 0;

    m_ptld                  = NULL;
    m_hEvent                = NULL;
    // m_hrResult

    Assert( m_pfShowCredentialsPage != NULL );
    *pfShowCredentialsPageIn = FALSE;

    Assert( m_pbstrClusterName != NULL );

    TraceFuncExit();

} //*** CCheckingAccessPage::CCheckingAccessPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCheckingAccessPage::~CCheckingAccessPage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCheckingAccessPage::~CCheckingAccessPage( void )
{
    TraceFunc( "" );

    KillTimer( m_hwnd, 0 );

    if ( m_psp != NULL )
    {
        m_psp->Release();
    }

    if ( m_hEvent != NULL )
    {
        CloseHandle( m_hEvent );
    }

    if ( m_ptld != NULL )
    {
        THR( m_ptld->SetCallback( NULL ) );
        m_ptld->Release();
    }

    Assert( m_cRef == 0 );

    TraceFuncExit();

} //*** CCheckingAccessPage::~CCheckingAccessPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCheckingAccessPage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCheckingAccessPage::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = FALSE; // didn't set focus

    m_hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    Assert( m_hEvent != NULL );

    SendDlgItemMessage( m_hwnd, IDC_CHECKINGACCESS_PRG_STATUS, PBM_SETRANGE, 0, MAKELPARAM( 0, 100 ) );

    RETURN( lr );

} //*** CCheckingAccessPage::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCheckingAccessPage::OnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCheckingAccessPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    HRESULT     hr;
    BOOL        bRet;
    UINT_PTR    iTimer;
    LPWSTR      pszDomain;

    LRESULT lr = TRUE;

    BSTR bstrDomain = NULL;

    IUnknown *      punk = NULL;
    ITaskManager *  ptm  = NULL;

    //
    //  Only cancel available.
    //
    PropSheet_SetWizButtons( GetParent( m_hwnd ), PSWIZB_BACK );

    //
    //  Reset progress bar.
    //
    SendDlgItemMessage( m_hwnd, IDC_CHECKINGACCESS_PRG_STATUS, PBM_SETPOS, 0, 0 );

    //
    //  If m_fNext is TRUE, then that means we are coming into this
    //  page because someone is back-pedalling through the wizard.
    //
    if ( m_fNext && !(*m_pfShowCredentialsPage) )
    {
        //
        //  Don't show us on the way back.
        //
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
        m_fNext = FALSE;
    }
    else
    {
        //
        //  Start the timer.
        //

        if ( m_hEvent != NULL )
        {
            hr = THR( m_psp->TypeSafeQS( CLSID_TaskManager,
                                         ITaskManager,
                                         &ptm
                                         ) );
            if ( FAILED( hr ) )
                goto Error;

            if ( m_ptld != NULL )
            {
                THR( m_ptld->SetCallback( NULL ) );
                m_ptld->Release();
            }

            hr = THR( ptm->CreateTask( TASK_LoginDomain,
                                       &punk
                                       ) );
            if ( FAILED( hr ) )
                goto Error;

            hr = THR( punk->TypeSafeQI( ITaskLoginDomain, &m_ptld ) );
            if ( FAILED( hr ) )
                goto Error;

            bRet = ResetEvent( m_hEvent );
            Assert( bRet );

            iTimer = SetTimer( m_hwnd, 0, 500, NULL );
            Assert( iTimer != 0 );

            pszDomain = wcschr( *m_pbstrClusterName, L'.' );
            Assert( pszDomain != NULL );

            pszDomain++;    // move past the dot.

            bstrDomain = TraceSysAllocString( pszDomain );
            if ( bstrDomain == NULL )
                goto OutOfMemory;

            hr = THR( m_ptld->SetDomain( bstrDomain ) );
            if ( FAILED( hr ) )
                goto Error;

            hr = THR( m_ptld->SetCallback( static_cast< ITaskLoginDomainCallback * >( this ) ) );
            if ( FAILED( hr ) )
                goto Error;

            hr = THR( ptm->SubmitTask( m_ptld ) );
            if ( FAILED( hr ) )
                goto Error;
        }
    }

Cleanup:
    if ( ptm != NULL )
    {
        ptm->Release();
    }

    if ( bstrDomain != NULL )
    {
        TraceSysFreeString( bstrDomain );
    }

    if ( punk != NULL )
    {
        punk->Release();
    }

    RETURN( lr );

Error:
    //
    //  On error, we can't block on the event because it'll never get
    //  set. So we'll just assume that everything would go ok and skip
    //  the login test.
    //
    if ( m_hEvent != NULL )
    {
        bRet = SetEvent( m_hEvent );
        Assert( bRet );
    }
    goto Cleanup;

OutOfMemory:
    goto Error;

} //*** CCheckingAccessPage::OnNotifySetActive()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCheckingAccessPage::OnNotifyQueryCancel( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCheckingAccessPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }
    else
    {
        KillTimer( m_hwnd, 0 );
    }

    RETURN( lr );

} //*** CCheckingAccessPage::OnNotifyQueryCancel()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCheckingAccessPage::OnNotifyWizNext( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCheckingAccessPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    m_fNext = TRUE;

    RETURN( lr );

} //*** CCheckingAccessPage::OnNotifyWizNext()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCheckingAccessPage::OnNotifyWizBack( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCheckingAccessPage::OnNotifyWizBack()
{
    TraceFunc( "" );

    BOOL    bRet;

    LRESULT lr = TRUE;

    m_fNext = FALSE;

    KillTimer( m_hwnd, 0 );

    RETURN( lr );

} //*** CCheckingAccessPage::OnNotifyWizBack()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCheckingAccessPage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCheckingAccessPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
    case PSN_SETACTIVE:
        lr = OnNotifySetActive();
        break;

    case PSN_WIZNEXT:
        lr = OnNotifyWizNext();
        break;

    case PSN_WIZBACK:
        lr = OnNotifyWizBack();
        break;

    case PSN_QUERYCANCEL:
        lr = OnNotifyQueryCancel();
        break;
    }

    RETURN( lr );

} //*** CCheckingAccessPage::OnNotify()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCheckingAccessPage::OnTimer( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCheckingAccessPage::OnTimer( void )
{
    TraceFunc( "" );

    LRESULT lr = 0;

    SendDlgItemMessage( m_hwnd, IDC_CHECKINGACCESS_PRG_STATUS, PBM_DELTAPOS, 1, 0 );

    if ( m_hEvent == NULL
      || WaitForSingleObject( m_hEvent, 0 ) == WAIT_OBJECT_0
       )
    {
        BOOL bRet;

        bRet = KillTimer( m_hwnd, 0 );
        Assert( bRet );

        if ( m_hrResult == S_OK )
        {
            //
            //  Done. Fake the button push. Don't show the login page.
            //
            PropSheet_PressButton( GetParent( m_hwnd ), PSBTN_NEXT );
            *m_pfShowCredentialsPage = FALSE;
        }
        else if ( m_hrResult == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
        {
            //
            //  Found the domain, but we don't have access.
            //  Move to the credentials pages.
            //
            PropSheet_PressButton( GetParent( m_hwnd ), PSBTN_NEXT );
            *m_pfShowCredentialsPage = TRUE;
        }
        else
        {
            MessageBoxFromStrings( m_hwnd,
                                   IDS_ERR_NO_SUCH_DOMAIN_TITLE,
                                   IDS_ERR_NO_SUCH_DOMAIN_TEXT,
                                   MB_OK
                                   );
            PropSheet_PressButton( GetParent( m_hwnd ), PSBTN_BACK );
        }
    }

    RETURN( lr );

} //*** CCheckingAccessPage::OnTimer()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT_PTR
//  CALLBACK
//  CCheckingAccessPage::S_DlgProc(
//      HWND hDlgIn,
//      UINT MsgIn,
//      WPARAM wParam,
//      LPARAM lParam
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CCheckingAccessPage::S_DlgProc(
    HWND hDlgIn,
    UINT MsgIn,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CCheckingAccessPage * pPage = reinterpret_cast< CCheckingAccessPage *> ( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CCheckingAccessPage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
        case WM_INITDIALOG:
            lr = pPage->OnInitDialog();
            break;

        case WM_NOTIFY:
            lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
            break;

        case WM_TIMER:
            lr = pPage->OnTimer();
            break;

        // no default clause needed
        }
    }

    return lr;

} //*** CCheckingAccessPage::S_DlgProc()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCheckingAccessPage::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCheckingAccessPage::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskLoginDomainCallback * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskLoginDomainCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskLoginDomainCallback , this, 0 );
        hr = S_OK;
    } // else if: ITaskLoginDomainCallback

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CCheckingAccessPage::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CCheckingAccessPage::AddRef( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCheckingAccessPage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CCheckingAccessPage::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CCheckingAccessPage::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCheckingAccessPage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        // do nothing -- COM interface does not control object lifetime
    }

    RETURN( cRef );

} //*** CCheckingAccessPage::Release()


//****************************************************************************
//
//  ITaskLoginDomainCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCheckingAccessPage::ReceiveLoginResult(
//      HRESULT hrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCheckingAccessPage::ReceiveLoginResult(
    HRESULT hrIn
    )
{
    TraceFunc( "[ITaskLoginDomainCallback]" );

    HRESULT hr = S_OK;

    BOOL    bRet;

    m_hrResult = hrIn;

    if ( m_hEvent != NULL )
    {
        bRet = SetEvent( m_hEvent );
        Assert( bRet );
    }

    HRETURN( hr );

} //*** CCheckingAccessPage::ReceiveResult()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\clusdomainpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ClusDomainPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    31-JAN-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "ClusDomainPage.h"
#include "WizardUtils.h"

DEFINE_THISCLASS("CClusDomainPage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::CClusDomainPage
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pspIn               -- IServiceProvider
//      ecamCreateAddModeIn -- Creating cluster or adding nodes to cluster
//      pbstrClusterNameIn  -- Name of the cluster
//      idsDescIn           -- Resource ID for the domain description string.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDomainPage::CClusDomainPage(
    IServiceProvider *  pspIn,
    ECreateAddMode      ecamCreateAddModeIn,
    BSTR *              pbstrClusterNameIn,
    UINT                idsDescIn
    )
{
    TraceFunc( "" );

    Assert( pspIn != NULL );
    Assert( pbstrClusterNameIn != NULL );
    Assert( idsDescIn != 0 );

    // m_hwnd
    THR( pspIn->TypeSafeQI( IServiceProvider, &m_psp ) );
    m_pbstrClusterName  = pbstrClusterNameIn;
    m_ecamCreateAddMode = ecamCreateAddModeIn;
    m_idsDesc           = idsDescIn;

    if (    ( ecamCreateAddModeIn == camADDING )
        &&  ( *pbstrClusterNameIn != L'\0' ) )
    {
        //
        //  Don't show the cluster name/domain page if we are joining
        //  and the cluster name has been filled in by the caller.
        //
        m_fDisplayPage = FALSE;
    }
    else
    {
        m_fDisplayPage = TRUE;
    }

    m_cRef = 0;
    m_ptgd = NULL;

    TraceFuncExit();

} //*** CClusDomainPage::CClusDomainPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::~CClusDomainPage
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusDomainPage::~CClusDomainPage( void )
{
    TraceFunc( "" );

    if ( m_psp != NULL )
    {
        m_psp->Release();
    }

    if ( m_ptgd != NULL )
    {
        //  Make sure we don't get called anymore.
        THR( m_ptgd->SetCallback( NULL ) );

        m_ptgd->Release();
    }

    Assert( m_cRef == 0 );

    TraceFuncExit();

} //*** CClusDomainPage::~CClusDomainPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::OnInitDialog
//
//  Description:
//      Handle the WM_INITDIALOG window message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      FALSE   - Didn't set the focus.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CClusDomainPage::OnInitDialog( void )
{
    TraceFunc( "" );

    HRESULT hr;
    LRESULT lr = FALSE; // didn't set focus
    bool    fGetLocalDomain = false;

    LPWSTR  pszDomain;
    BSTR    bstrDomain = NULL;
    BSTR    bstrDomainDesc = NULL;

    IUnknown *      punk = NULL;
    ITaskManager *  ptm  = NULL;

    //
    // (jfranco, bug #373331) Limit cluster name length to MAX_CLUSTERNAME_LENGTH
    //
    // according to msdn, EM_(SET)LIMITTEXT does not return a value, so ignore what SendDlgItemMessage returns
    SendDlgItemMessage( m_hwnd, IDC_CLUSDOMAIN_E_CLUSTERNAME, EM_SETLIMITTEXT, MAX_CLUSTERNAME_LENGTH, 0 );


    //
    // Kick off the GetDomains task.
    //

    hr = THR( m_psp->TypeSafeQS( CLSID_TaskManager, ITaskManager, &ptm ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptm->CreateTask( TASK_GetDomains, &punk ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //TraceMoveFromMemoryList( punk, g_GlobalMemoryList );

    hr = THR( punk->TypeSafeQI( ITaskGetDomains, &m_ptgd ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_ptgd->SetCallback( static_cast< ITaskGetDomainsCallback * >( this ) ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptm->SubmitTask( m_ptgd ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // If a cluster name has already been specified, set it to the page.
    // If the cluster name is fully qualified, select that domain in the
    // domains combobox.
    //

    if ( *m_pbstrClusterName != NULL )
    {
        //
        //  This should be a FQDN. If not, don't fill in the domain.
        //
        pszDomain = wcschr( *m_pbstrClusterName, L'.' );
        if ( pszDomain != NULL )
        {
            *pszDomain = L'\0'; // terminate to fillin cluster hostname
        }

        SetDlgItemText( m_hwnd, IDC_CLUSDOMAIN_E_CLUSTERNAME, *m_pbstrClusterName );

        if ( pszDomain != NULL )
        {
            *pszDomain = L'.';  // restore
            pszDomain++;
            SetDlgItemText( m_hwnd, IDC_CLUSDOMAIN_CB_DOMAIN, pszDomain );
        }
        else
        {
            fGetLocalDomain = true;
        }
    } // if: cluster name specified already
    else
    {
        fGetLocalDomain = true;
    }

    //
    // If a cluster name was not specified or if the cluster name wasn't
    // fully qualified, select the domain of the local computer.
    //

    if ( fGetLocalDomain )
    {
        //
        //  Get the domain of the local computer.
        //

        hr = THR( HrGetComputerName( ComputerNameDnsDomain, &bstrDomain ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        SetDlgItemText( m_hwnd, IDC_CLUSDOMAIN_CB_DOMAIN, bstrDomain );
    } // if: need to get the local domain

    //
    // Set the text of the domain description control.
    //

    hr = HrLoadStringIntoBSTR( g_hInstance, m_idsDesc, &bstrDomainDesc );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SetDlgItemText( m_hwnd, IDC_CLUSDOMAIN_S_DOMAIN_DESC, bstrDomainDesc );

Cleanup:
	TraceSysFreeString( bstrDomainDesc );
    TraceSysFreeString( bstrDomain );

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( ptm != NULL )
    {
        ptm->Release();
    }

    RETURN( lr );

} //*** CClusDomainPage::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::OnNotifySetActive
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CClusDomainPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    if ( m_fDisplayPage )
    {
        THR( HrUpdateWizardButtons( TRUE ) );
    }
    else
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CClusDomainPage::OnNotifySetActive()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::OnNotifyWizNext
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CClusDomainPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    HRESULT     hr;
    DNS_STATUS  dnsStatus;
    DWORD       dwLen;
    LPWSTR      pszDomain;
    DWORD       dwErr;
    WCHAR       szClusterName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    BSTR        bstrClusterName;
    int         idcFocus = 0;

    LRESULT lr = TRUE;

    HWND    hDlgWizard = GetParent( m_hwnd );

    //
    //  Retrieve the text and make sure it is a valid DNS hostname.
    //

    dwLen = GetDlgItemText( m_hwnd, IDC_CLUSDOMAIN_E_CLUSTERNAME, szClusterName, ARRAYSIZE( szClusterName ) );
    AssertMsg( dwLen, "How did we get here?" );

    //
    //  Validate cluster hostname.
    //
    hr = THR( HrValidateDnsHostname(
                      m_hwnd
                    , szClusterName
                    , mvdhoALLOW_ONLY_HOSTNAME_LABEL
                    ) );
    if ( FAILED( hr ) )
    {
        idcFocus = IDC_CLUSDOMAIN_E_CLUSTERNAME;
        goto Error;
    }

    //
    //  Add the DOT after the hostname to build the cluster's FQDN.
    //
    szClusterName[ dwLen ] = L'.';
    dwLen++;

    pszDomain = &szClusterName[ dwLen ];

    //
    //  Add the domain to the cluster hostname to make a FQDN.
    //
    dwLen = GetDlgItemText( m_hwnd, IDC_CLUSDOMAIN_CB_DOMAIN, &szClusterName[ dwLen ], ARRAYSIZE( szClusterName ) - dwLen );
    if ( dwLen != 0 )
    {
        //
        //  Validate the domain name.
        //
        dnsStatus = TW32( DnsValidateName( pszDomain, DnsNameDomain ) );
        if ( dnsStatus != ERROR_SUCCESS )
        {
            MessageBoxFromStrings( m_hwnd,
                                   IDS_ERR_INVALID_DNS_DOMAIN_NAME_TITLE,
                                   IDS_ERR_INVALID_DNS_DOMAIN_NAME_TEXT,
                                   MB_OK | MB_ICONSTOP
                                   );
            hr = HRESULT_FROM_WIN32( dnsStatus );
            idcFocus = IDC_CLUSDOMAIN_CB_DOMAIN;
            goto Error;
        }
    }
    else
    {
        //
        //  Remote the dot.
        //
        dwLen --;
        szClusterName[ dwLen ] = L'\0';
    }

    //
    //  Build a BSTR of the FQDN cluster name.
    //
    bstrClusterName = TraceSysAllocString( szClusterName );
    if ( bstrClusterName == NULL )
    {
        goto OutOfMemory;
    }

    TraceSysFreeString( *m_pbstrClusterName );

    *m_pbstrClusterName = bstrClusterName;

Cleanup:
    RETURN( lr );

Error:
    if ( idcFocus != 0 )
    {
        SetFocus( GetDlgItem( m_hwnd, idcFocus ) );
    }

    //  Don't go to the next page.
    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

} //*** CClusDomainPage::OnNotifyWizNext()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::OnNotifyQueryCancel
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CClusDomainPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** OnNotifyQueryCancel()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::OnNotify
//
//  Description:
//
//  Arguments:
//      idCtrlIn
//      pnmhdrIn
//
//  Return Values:
//      TRUE
//      Other LRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CClusDomainPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch ( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_WIZNEXT:
            lr = OnNotifyWizNext();
            break;

        case PSN_WIZBACK:
            //
            //  Disable the wizard buttons.
            //
            PropSheet_SetWizButtons( GetParent( m_hwnd ), 0 );
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;
    } // switch: notification code

    RETURN( lr );

} //*** CClusDomainPage::OnNotify()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::OnCommand
//
//  Description:
//
//  Arguments:
//      idNotificationIn
//      idControlIn
//      hwndSenderIn
//
//  Return Values:
//      TRUE
//      FALSE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CClusDomainPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_CLUSDOMAIN_E_CLUSTERNAME:
            if ( idNotificationIn == EN_CHANGE )
            {
                THR( HrUpdateWizardButtons( TRUE ) );
                lr = TRUE;
            }
            break;

        case IDC_CLUSDOMAIN_CB_DOMAIN:
            if ( idNotificationIn == CBN_EDITCHANGE )
            {
                THR( HrUpdateWizardButtons( TRUE ) );
                lr = TRUE;
            }
            else if ( idNotificationIn == CBN_SELCHANGE )
            {
                THR( HrUpdateWizardButtons( TRUE ) );
                lr = TRUE;
            }
            break;

    } // switch: control ID

    RETURN( lr );

} //*** CClusDomainPage::OnCommand()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusDomainPage::HrUpdateWizardButtons
//
//  Description:
//
//  Arguments:
//      fIgnoreCombBoxIn
//
//  Return Values:
//      S_OK
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusDomainPage::HrUpdateWizardButtons(
    BOOL fIgnoreComboBoxIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    DWORD   dwFlags = PSWIZB_BACK | PSWIZB_NEXT;
    DWORD   dwLen;
    LRESULT lr;

    dwLen = GetWindowTextLength( GetDlgItem( m_hwnd, IDC_CLUSDOMAIN_E_CLUSTERNAME ) );
    if ( dwLen == 0 )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }

    if ( ! fIgnoreComboBoxIn )
    {
        dwLen = GetWindowTextLength( GetDlgItem( m_hwnd, IDC_CLUSDOMAIN_CB_DOMAIN ) );
        lr = ComboBox_GetCurSel( GetDlgItem( m_hwnd, IDC_CLUSDOMAIN_CB_DOMAIN ) );
        if ( lr == CB_ERR )
        {
            if ( dwLen == 0 )
            {
                dwFlags &= ~PSWIZB_NEXT;
            }
        }
        else if ( dwLen == 0 )
        {
            dwFlags &= ~PSWIZB_NEXT;
        }
    } // if: can't ignore the combobos

    PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );

    HRETURN( hr );

} //*** CClusDomainPage::HrUpdateWizardButtons()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CALLBACK
//  CClusDomainPage::S_DlgProc
//
//  Description:
//      Dialog proc for this page.
//
//  Arguments:
//      hDlgIn
//      MsgIn
//      wParam
//      lParam
//
//  Return Values:
//      FALSE
//      Other LRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CClusDomainPage::S_DlgProc(
    HWND    hDlgIn,
    UINT    MsgIn,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CClusDomainPage * pPage = reinterpret_cast< CClusDomainPage *> ( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CClusDomainPage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr= pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), (HWND) lParam );
                break;

            // no default clause needed
        } // switch: message
    } // if: there is a page associated with the window

    return lr;

} //*** CClusDomainPage::S_DlgProc()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CClusDomainPage::QueryInterface
//
//  Description:
//
//  Arguments:
//      riidIn
//      ppvOut
//
//  Return Values:
//      S_OK
//      E_NOINTERFACE
//      Other HRESULT values.
//
//  Remarks:
//      Supports IUnknown and ITaskGetDomainsCallback.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusDomainPage::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskGetDomainsCallback * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskGetDomainsCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskGetDomainsCallback, this, 0 );
        hr = S_OK;
    } // else if: ITaskGetDomainsCallback

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusDomainPage::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CClusDomainPage::AddRef
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusDomainPage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CClusDomainPage::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CClusDomainPage::Release
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusDomainPage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    InterlockedDecrement( &m_cRef );
    cRef = m_cRef;

    if ( cRef == 0 )
    {
        // TraceDo( delete this );
    }

    RETURN( cRef );

} //*** CClusDomainPage::Release()


//****************************************************************************
//
//  ITaskGetDomainsCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [ITaskGetDomainsCallback]
//  CClusDomainPage::ReceiveDomainResult
//
//  Description:
//
//  Arguments:
//      hrIn
//
//  Return Values:
//      S_OK
//      Other HRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusDomainPage::ReceiveDomainResult(
    HRESULT hrIn
    )
{
    TraceFunc( "[ITaskGetDomainsCallback]" );

    HRESULT hr;

    hr = THR( m_ptgd->SetCallback( NULL ) );

    HRETURN( hr );

} //*** CClusDomainPage::ReceiveResult()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [ITaskGetDomainsCallback]
//  CClusDomainPage::ReceiveDomainName
//
//  Description:
//
//  Arguments:
//      bstrDomainIn
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusDomainPage::ReceiveDomainName(
    LPCWSTR pcszDomainIn
    )
{
    TraceFunc( "[ITaskGetDomainsCallback]" );

    HRESULT hr = S_OK;

    ComboBox_AddString( GetDlgItem( m_hwnd, IDC_CLUSDOMAIN_CB_DOMAIN ), pcszDomainIn );

    HRETURN( hr );

} //*** CClusDomainPage::ReceiveName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\cluscfg.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClusCfg.h
//
//  Description:
//      Declaration of the CClusCfgWizard class.
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    11-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
//  Creating / Adding enum
//
enum ECreateAddMode {
    camUNKNOWN = 0,
    camCREATING,
    camADDING
};

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgWizard
//
//  Description:
//      The Cluster Configuration Wizard object.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgWizard
    : public IClusCfgWizard
{
private:
    //  IUnknown
    ULONG               m_cRef;             // Reference count

    //  IClusCfgWizard
    LPTYPEINFO          m_ptinfo;           //  Type information
    BSTR                m_bstrClusterName;  //  Name of the cluster
    BSTR                m_bstrAccountName;  //  Cluster Service Account Name
    BSTR                m_bstrPassword;     //  Cluster Service Account Password
    BSTR                m_bstrDomain;       //  Cluster Service Account Domain
    ULONG               m_ulIPAddress;      //  IP Address for the cluster
    ULONG               m_ulIPSubnet;       //  Subnet mask for the cluster
    BSTR                m_bstrNetworkName;  //  Name of network for IP address
    ULONG               m_cComputers;       //  Count of computer in Computers list
    ULONG               m_cArraySize;       //  Size of the currently allocated array
    BSTR *              m_rgbstrComputers;  //  Computers list

    IServiceProvider  * m_psp;              //  Middle Tier Service Manager

    HMODULE             m_hRichEdit;        //  RichEdit's module handle

private:
    CClusCfgWizard( void );
    ~CClusCfgWizard( void );

    HRESULT
        HrInit( void );
    HRESULT
        HrAddWizardPage( LPPROPSHEETHEADER  ppshInout,
                         UINT               idTemplateIn,
                         DLGPROC            pfnDlgProcIn,
                         UINT               idTitleIn,
                         UINT               idSubtitleIn,
                         LPARAM             lParam
                         );

public:
    static HRESULT
        S_HrCreateInstance( IUnknown ** ppunkOut );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, PVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    // IDispatch
    STDMETHOD( GetTypeInfoCount )( UINT * pctinfoOut );
    STDMETHOD( GetTypeInfo )( UINT itinfoIn, LCID lcidIn, ITypeInfo ** pptinfoOut );
    STDMETHOD( GetIDsOfNames )( REFIID      riid,
                                OLECHAR **  rgszNames,
                                UINT        cNames,
                                LCID        lcid,
                                DISPID *    rgdispid
                                );
    STDMETHOD( Invoke )( DISPID         dispidMember,
                         REFIID         riid,
                         LCID           lcid,
                         WORD           wFlags,
                         DISPPARAMS *   pdispparams,
                         VARIANT *      pvarResult,
                         EXCEPINFO *    pexcepinfo,
                         UINT *         puArgErr
                         );

    // IClusCfgWizard methods
    STDMETHOD( CreateCluster )( HWND lParentWndIn, BOOL * pfDoneOut );
    STDMETHOD( AddClusterNodes )( HWND lParentWndIn, BOOL * pfDoneOut );
    STDMETHOD( get_ClusterName )( BSTR * pbstrFQDNNameOut );
    STDMETHOD( put_ClusterName )( BSTR bstrFQDNNameIn );
    STDMETHOD( get_ServiceAccountUserName )( BSTR * pbstrAccountNameOut );
    STDMETHOD( put_ServiceAccountUserName )( BSTR bstrAccountNameIn );
    STDMETHOD( get_ServiceAccountPassword )( BSTR * pbstrPasswordOut );
    STDMETHOD( put_ServiceAccountPassword )( BSTR bstrPasswordIn );
    STDMETHOD( get_ServiceAccountDomainName )( BSTR * pbstrDomainOut );
    STDMETHOD( put_ServiceAccountDomainName )( BSTR bstrDomainIn );
    STDMETHOD( get_ClusterIPAddress )( BSTR * pbstrIPAddressOut );
    STDMETHOD( put_ClusterIPAddress )( BSTR bstrIPAddressIn );
    STDMETHOD( get_ClusterIPSubnet )( BSTR * pbstrIPSubnetOut );
    STDMETHOD( put_ClusterIPSubnet )( BSTR bstrIPSubnetIn );
    STDMETHOD( get_ClusterIPAddressNetwork )( BSTR * pbstrNetworkNameOut );
    STDMETHOD( put_ClusterIPAddressNetwork )( BSTR bstrNetworkNameIn );
    STDMETHOD( AddComputer )( LPCWSTR pcszFQDNNameIn );
    STDMETHOD( RemoveComputer )( LPCWSTR pcszFQDNNameIn );
    STDMETHOD( ClearComputerList )( void );

}; //*** class CClusCfgWizard
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\commitpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CommitPage.cpp
//
//  Maintained By:
//      Galen Barbee  (GalenB)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskTreeView.h"
#include "CommitPage.h"
#include "WizardUtils.h"

DEFINE_THISCLASS( "CCommitPage" );

//
//  Special CLSID_Type for completion cookie.
//
#include <initguid.h>
// {FC4D0128-7BAB-4c76-9C38-E3C042F15822}
DEFINE_GUID( CLSID_CommitTaskCompletionCookieType,
0xfc4d0128, 0x7bab, 0x4c76, 0x9c, 0x38, 0xe3, 0xc0, 0x42, 0xf1, 0x58, 0x22);

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommitPage::CCommitPage(
//      IServiceProvider * pspIn,
//      ECreateAddMode     ecamCreateAddModeIn,
//      BSTR *             pbstrClusterIn,
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCommitPage::CCommitPage(
      IServiceProvider * pspIn
    , ECreateAddMode     ecamCreateAddModeIn
    , BSTR *             pbstrClusterIn
    )
{
    TraceFunc( "" );

    Assert( pspIn != NULL );
    Assert( pbstrClusterIn != NULL );

    m_hwnd                      = NULL;
    THR( pspIn->TypeSafeQI( IServiceProvider, &m_psp ) );
    m_pom                       = NULL;
    m_pbstrClusterName          = pbstrClusterIn;
    m_fNext                     = false;
    m_fDisableBack              = false;
    m_fAborted                  = false;
    m_ecamCreateAddMode         = ecamCreateAddModeIn;
    m_htiReanalyze              = NULL;
    m_rgfSubReanalyzeAdded[ 0 ] = false;
    m_rgfSubReanalyzeAdded[ 1 ] = false;
    m_rgfSubReanalyzeAdded[ 2 ] = false;
    m_rgfSubReanalyzeAdded[ 3 ] = false;
    m_rgfSubReanalyzeAdded[ 4 ] = false;

    m_cRef = 0;

    m_cookieCompletion = NULL;
    //  m_fTaskDone
    // m_hrResult
    m_pttv             = NULL;
    m_bstrLogMsg       = NULL;
    m_pcpcb            = NULL;
    m_dwCookieCallback = 0;

    m_pcpui          = NULL;
    m_dwCookieNotify = 0;

    TraceFuncExit();

} //*** CCommitPage::CCommitPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCommitPage::~CCommitPage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCommitPage::~CCommitPage( void )
{
    TraceFunc( "" );

    THR( HrCleanupCommit() );

    if ( m_psp != NULL )
    {
        m_psp->Release();
    }

    if ( m_pom != NULL )
    {
        m_pom->Release();
    }

    if ( m_pcpui != NULL )
    {
        //  This should have been cleaned up by HrCleanupCommit().
        Assert( m_dwCookieNotify == 0 );
        m_pcpui->Release();
    }

    if ( m_pcpcb != NULL )
    {
        //  This should have been cleaned up by HrCleanupCommit().
        Assert( m_dwCookieCallback == 0 );
        m_pcpcb->Release();
    }

    if ( m_pttv != NULL )
    {
        delete m_pttv;
    }

    TraceSysFreeString( m_bstrLogMsg );

    Assert( m_cRef == 0 );

    TraceFuncExit();

} //*** CCommitPage::~CCommitPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = FALSE; // didn't set focus

    //
    //  Initialize the tree view
    //

    m_pttv = new CTaskTreeView( m_hwnd, IDC_COMMIT_TV_TASKS, IDC_COMMIT_PRG_STATUS, IDC_COMMIT_S_STATUS );
    if ( m_pttv == NULL )
    {
        goto OutOfMemory;
    }

    THR( m_pttv->HrOnInitDialog() );

Cleanup:
    RETURN( lr );

OutOfMemory:
    goto Cleanup;

} //*** CCommitPage::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnCommand(
//      UINT    idNotificationIn,
//      UINT    idControlIn,
//      HWND    hwndSenderIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_COMMIT_PB_VIEW_LOG:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrViewLogFile( m_hwnd ) );
                lr = TRUE;
            } // if: button click
            break;

        case IDC_COMMIT_PB_DETAILS:
            if ( idNotificationIn == BN_CLICKED )
            {
                Assert( m_pttv != NULL );
                THR( m_pttv->HrDisplayDetails() );
                lr = TRUE;
            }
            break;

        case IDC_COMMIT_PB_RETRY:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrCleanupCommit() );
                OnNotifySetActive();
                lr = TRUE;
            }
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CCommitPage::OnCommand()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CCommitPage::HrUpdateWizardButtons( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCommitPage::HrUpdateWizardButtons( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    DWORD   dwFlags       = 0;
    bool    fEnableRetry  = false;
    bool    fEnableCancel = false;

    if ( ! m_fDisableBack )
    {
        dwFlags = PSWIZB_BACK;
    }

    if ( m_fTaskDone )
    {
        if ( FAILED( m_hrResult ) )
        {
            fEnableRetry  = true;
            fEnableCancel = true;
        }
        else
        {
            dwFlags |= PSWIZB_NEXT;
        }
    }
    else
    {
        //Disable the back button if task is not completed yet
        dwFlags &= ~PSWIZB_BACK;
        fEnableCancel = true;
    }

    PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );

    EnableWindow( GetDlgItem( GetParent( m_hwnd ), IDCANCEL ), fEnableCancel );
    EnableWindow( GetDlgItem( m_hwnd, IDC_COMMIT_PB_RETRY ), fEnableRetry );

    HRETURN( hr );

} //*** CCommitPage::HrUpdateWizardButtons()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnNotifyQueryCancel( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CCommitPage::OnNotifyQueryCancel()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookieCluster;

    LRESULT lr = TRUE;

    IUnknown *                  punk  = NULL;
    ITaskManager *              ptm   = NULL;
    IConnectionPointContainer * pcpc  = NULL;
    ITaskCommitClusterChanges * ptccc = NULL;

    if ( m_fNext )
    {
        m_fNext = false;

        hr = THR( HrUpdateWizardButtons() );

        goto Cleanup;
    }

    //
    //  Make sure things were cleaned up from the last commit.
    //

    m_hrResult = S_OK;

    m_fAborted = false;
    LogMsg( L"Wizard: Setting commit page active.  Setting aborted to false." );

    Assert( m_dwCookieNotify == 0 );
    Assert( m_cookieCompletion == NULL );

    //
    //  Grab the notification manager.
    //

    if ( m_pcpui == NULL || m_pcpcb == NULL )
    {
        hr = THR( m_psp->TypeSafeQS( CLSID_NotificationManager,
                                     IConnectionPointContainer,
                                     &pcpc
                                     ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        pcpc = TraceInterface( L"CCommitPage!IConnectionPointContainer", IConnectionPointContainer, pcpc, 1 );

        if ( m_pcpui == NULL )
        {
            hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI,
                                                 &m_pcpui
                                                 ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            m_pcpui = TraceInterface( L"CCommitPage!IConnectionPoint!INotifyUI", IConnectionPoint, m_pcpui, 1 );
        }

        if ( m_pcpcb == NULL )
        {
            hr = THR( pcpc->FindConnectionPoint( IID_IClusCfgCallback, &m_pcpcb ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            m_pcpcb = TraceInterface( L"CCommitPage!IConnectionPoint!IClusCfgCallback", IConnectionPoint, m_pcpcb, 1 );
        }
    }

    //
    //  Reset the progress bar's color.
    //

    SendDlgItemMessage( m_hwnd, IDC_COMMIT_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0, 0, 0x80 ) );

    //
    //  Clear the tree view and status line. Disable the retry button.
    //

    Assert( m_pttv != NULL );
    hr = THR( m_pttv->HrOnNotifySetActive() );
    if ( FAILED ( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Add the major root task nodes.
    //  (Minor reanalyze tasks are added dynamically.)
    //

    hr = THR( m_pttv->HrAddTreeViewItem(
                              &m_htiReanalyze
                            , IDS_TASKID_MAJOR_REANALYZE
                            , TASKID_Major_Reanalyze
                            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem(
                              IDS_TASKID_MAJOR_CONFIGURE_CLUSTER_SERVICES
                            , TASKID_Major_Configure_Cluster_Services
                            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem(
                              IDS_TASKID_MAJOR_CONFIGURE_RESOURCE_TYPES
                            , TASKID_Major_Configure_Resource_Types
                            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( m_pttv->HrAddTreeViewRootItem(
                              IDS_TASKID_MAJOR_CONFIGURE_RESOURCES
                            , TASKID_Major_Configure_Resources
                            ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Grab the object manager.
    //

    hr = THR( m_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &m_pom
                                 ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Find the cluster cookie.
    //

    hr = THR( m_pom->FindObject( CLSID_ClusterConfigurationType,
                                 NULL,
                                 *m_pbstrClusterName,
                                 IID_NULL,
                                 &cookieCluster,
                                 &punk
                                 ) );
    Assert( punk == NULL );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Create a completion cookie.
    //

    // Don't wrap - this can fail with E_PENDING
    hr = m_pom->FindObject( CLSID_CommitTaskCompletionCookieType,
                            NULL,
                            *m_pbstrClusterName,
                            IID_NULL,
                            &m_cookieCompletion,
                            &punk
                            );
    Assert( punk == NULL );
    if ( hr == E_PENDING )
    {
        // no-op.
    }
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto Cleanup;
    }

    //
    //  Register to get UI notification (if needed)
    //

    if ( m_dwCookieNotify == 0 )
    {
        hr = THR( m_pcpui->Advise( static_cast< INotifyUI * >( this ), &m_dwCookieNotify ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    if ( m_dwCookieCallback == 0 )
    {
        hr = THR( m_pcpcb->Advise( static_cast< IClusCfgCallback * >( this ), &m_dwCookieCallback ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    //
    //  Grab the task manager.
    //

    hr = THR( m_psp->TypeSafeQS( CLSID_TaskManager,
                                 ITaskManager,
                                 &ptm
                                 ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Create a new analyze task.
    //

    Assert( punk == NULL );
    hr = THR( ptm->CreateTask( TASK_CommitClusterChanges,
                               &punk
                               ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( ITaskCommitClusterChanges, &ptccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptccc->SetClusterCookie( cookieCluster ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( ptccc->SetCookie( m_cookieCompletion ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    m_fTaskDone = false;    // reset before commiting task

    hr = THR( ptm->SubmitTask( ptccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrUpdateWizardButtons() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    if ( ptm != NULL )
    {
        ptm->Release();
    }
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( ptccc != NULL )
    {
        ptccc->Release();
    }

    RETURN( lr );

} //*** CCommitPage::OnNotifySetActive()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnNotifyWizBack( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnNotifyWizBack( void )
{
    TraceFunc( "" );

    HRESULT lr = TRUE;

    m_fAborted = true;

    LogMsg( L"Wizard: Back button pressed on the commit page.  Setting aborted to true." );

    THR( HrCleanupCommit() );

    RETURN( lr );

} //*** CCommitPage::OnNotifyWizBack()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnNotifyWizNext( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    RETURN( lr );

} //*** CCommitPage::OnNotifyWizNext()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCommitPage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCommitPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_WIZNEXT:
            lr = OnNotifyWizNext();
            break;

        case PSN_WIZBACK:
            lr = OnNotifyWizBack();
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;

        default:
            if (    ( idCtrlIn == IDC_COMMIT_TV_TASKS )
                &&  ( m_pttv != NULL ) )
            {
                // Pass the notification on to the tree control.
                lr = m_pttv->OnNotify( pnmhdrIn );
            }
            break;
    } // switch: notify code

    RETURN( lr );

} //*** CCommitPage::OnNotify()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT_PTR
//  CALLBACK
//  CCommitPage::S_DlgProc(
//      HWND    hwndDlgIn,
//      UINT    nMsgIn,
//      WPARAM  wParam,
//      LPARAM  lParam
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CCommitPage::S_DlgProc(
    HWND    hwndDlgIn,
    UINT    nMsgIn,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CCommitPage * pPage = reinterpret_cast< CCommitPage * >( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );

    if ( nMsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CCommitPage * >( ppage->lParam );
        pPage->m_hwnd = hwndDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hwndDlgIn == pPage->m_hwnd );

        switch( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr = pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), reinterpret_cast< HWND >( lParam ) );
                break;

            // no default clause needed
        } // switch: nMsgIn
    } // if: page is specified

    return lr;

} //*** CCommitPage::S_DlgProc()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCommitPage::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCommitPage::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< INotifyUI * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_INotifyUI ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
        hr = S_OK;
    } // else if: INotifyUI
    else if ( IsEqualIID( riidIn, IID_IClusCfgCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgCallback, this, 0 );
        hr = S_OK;
    } // else if: IClusCfgCallback

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CCommitPage::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CCommitPage::AddRef( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCommitPage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CCommitPage::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CCommitPage::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCommitPage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    cRef = InterlockedDecrement( &m_cRef );

    if ( cRef == 0 )
    {
        // do nothing -- COM interface does not control object lifetime
    }

    RETURN( cRef );

} //*** CCommitPage::Release()


//****************************************************************************
//
//  INotifyUI
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCommitPage::ObjectChanged(
//      OBJECTCOOKIE cookieIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCommitPage::ObjectChanged(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[INotifyUI]" );

    HRESULT hr = S_OK;

    BSTR    bstrDescription  = NULL;

    IUnknown *          punk = NULL;
    IStandardInfo *     psi  = NULL;

    if ( cookieIn == m_cookieCompletion )
    {
        hr = THR( m_pom->GetObject( DFGUID_StandardInfo,
                                    m_cookieCompletion,
                                    &punk
                                    ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( psi->GetStatus( &m_hrResult ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( m_pttv->HrShowStatusAsDone() );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( SUCCEEDED( m_hrResult ) )
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                            IDS_COMMIT_SUCCESSFUL_INSTRUCTIONS,
                                            &bstrDescription
                                            ) );

            SendDlgItemMessage( m_hwnd, IDC_COMMIT_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0, 0x80, 0 ) );
        }
        else
        {
            if ( !m_fDisableBack )
            {
                hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                                IDS_COMMIT_FAILED_INSTRUCTIONS_BACK_ENABLED,
                                                &bstrDescription
                                                ) );
            }
            else
            {
                hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                                IDS_COMMIT_FAILED_INSTRUCTIONS,
                                                &bstrDescription
                                                ) );
            }

            SendDlgItemMessage( m_hwnd, IDC_COMMIT_PRG_STATUS, PBM_SETBARCOLOR, 0, RGB( 0x80, 0, 0 ) );
        }

        SetDlgItemText( m_hwnd, IDC_COMMIT_S_RESULTS, bstrDescription );

        m_fTaskDone = true;

        THR( m_pom->RemoveObject( m_cookieCompletion ) );
        //  don't care if it fails.
        m_cookieCompletion = NULL;

        hr = THR( HrUpdateWizardButtons() );

        hr = THR( m_pcpcb->Unadvise( m_dwCookieCallback ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        m_dwCookieCallback = 0;
    }

Cleanup:

    TraceSysFreeString( bstrDescription );

    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }

    HRETURN( hr );

} //*** CCommitPage::ObjectChanged()



//****************************************************************************
//
//  IClusCfgCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCommitPage::SendStatusReport(
//        LPCWSTR    pcszNodeNameIn
//      , CLSID      clsidTaskMajorIn
//      , CLSID      clsidTaskMinorIn
//      , ULONG      ulMinIn
//      , ULONG      ulMaxIn
//      , ULONG      ulCurrentIn
//      , HRESULT    hrStatusIn
//      , LPCWSTR    pcszDescriptionIn
//      , FILETIME * pftTimeIn
//      , LPCWSTR    pcszReferenceIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCommitPage::SendStatusReport(
      LPCWSTR    pcszNodeNameIn
    , CLSID      clsidTaskMajorIn
    , CLSID      clsidTaskMinorIn
    , ULONG      ulMinIn
    , ULONG      ulMaxIn
    , ULONG      ulCurrentIn
    , HRESULT    hrStatusIn
    , LPCWSTR    pcszDescriptionIn
    , FILETIME * pftTimeIn
    , LPCWSTR    pcszReferenceIn
    )
{
    TraceFunc( "[IClusCfgCallback]" );

    HRESULT hr;
    ULONG   idx;

    static const GUID * rgclsidAnalysis[] =
    {
          &TASKID_Major_Checking_For_Existing_Cluster
        , &TASKID_Major_Establish_Connection
        , &TASKID_Major_Check_Node_Feasibility
        , &TASKID_Major_Find_Devices
        , &TASKID_Major_Check_Cluster_Feasibility
    };
    static const UINT rgidsAnalysis[] =
    {
          IDS_TASKID_MAJOR_CHECKING_FOR_EXISTING_CLUSTER
        , IDS_TASKID_MAJOR_ESTABLISH_CONNECTION
        , IDS_TASKID_MAJOR_CHECK_NODE_FEASIBILITY
        , IDS_TASKID_MAJOR_FIND_DEVICES
        , IDS_TASKID_MAJOR_CHECK_CLUSTER_FEASIBILITY
    };

    //
    //  If this is an analyze task, add it below the Reanalyze task item
    //  if it hasn't been added yet.
    //
    
    for ( idx = 0 ; idx < ARRAYSIZE( rgclsidAnalysis ) ; idx ++ )
    {
        if ( clsidTaskMajorIn == *rgclsidAnalysis[ idx ] )
        {
            if ( m_rgfSubReanalyzeAdded[ idx ] == false )
            {
                Assert( m_htiReanalyze != NULL );
                hr = THR( m_pttv->HrAddTreeViewItem(
                                          NULL  // phtiOut
                                        , rgidsAnalysis[ idx ]
                                        , *rgclsidAnalysis[ idx ]
                                        , TASKID_Major_Reanalyze
                                        , m_htiReanalyze
                                        ) );
                if ( SUCCEEDED( hr ) )
                {
                    m_rgfSubReanalyzeAdded[ idx ] = true;
                }
            } // if: major ID not added yet
            break;
        } // if: found known major ID
    } // for: each known major task ID

    //
    //  Remove the "back" button as an option if the tasks have made it past re-analyze.
    //
    if ( ! m_fDisableBack && ( clsidTaskMajorIn == TASKID_Major_Configure_Cluster_Services ) )
    {
        BSTR  bstrDescription  = NULL;

        m_fDisableBack = true;

        hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_COMMIT_SUCCESSFUL_INSTRUCTIONS_BACK_DISABLED, &bstrDescription ) );
        if ( SUCCEEDED( hr ) )
        {
            SetDlgItemText( m_hwnd, IDC_COMMIT_S_RESULTS, bstrDescription );
            TraceSysFreeString( bstrDescription );
        }

        THR( HrUpdateWizardButtons() );
    }

    hr = THR( m_pttv->HrOnSendStatusReport( pcszNodeNameIn,
                                            clsidTaskMajorIn,
                                            clsidTaskMinorIn,
                                            ulMinIn,
                                            ulMaxIn,
                                            ulCurrentIn,
                                            hrStatusIn,
                                            pcszDescriptionIn,
                                            pftTimeIn,
                                            pcszReferenceIn
                                            ) );

    if ( m_fAborted )
    {
        LogMsg( L"Wizard: Commit page -- replacing (hr = %#08x) with E_ABORT", hr );
        hr = E_ABORT;
    } // if:

    HRETURN( hr );

} //*** CCommitPage::SendStatusReport()

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CCommitPage::HrCleanupCommit( void )
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCommitPage::HrCleanupCommit( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    //
    //  Unregister UI notification (if needed)
    //
    if ( ( m_pcpui != NULL ) && ( m_dwCookieNotify != 0 ) )
    {
        // ignore error;
        THR( m_pcpui->Unadvise( m_dwCookieNotify ) );

        m_dwCookieNotify = 0;
    }

    if ( ( m_pcpcb != NULL ) && ( m_dwCookieCallback != 0 ) )
    {
        // ignore error;
        THR( m_pcpcb->Unadvise( m_dwCookieCallback ) );

        m_dwCookieCallback = 0;
    }

    //
    //  Delete the completion cookie.
    //
    if ( ( m_pom != NULL ) && ( m_cookieCompletion != NULL ) )
    {
        // don't care if this fails.
        THR( m_pom->RemoveObject( m_cookieCompletion ) );

        m_cookieCompletion = NULL;
    }

    HRETURN( hr );

} //*** CCommitPage::HrCleanupCommit()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\clusdomainpage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      ClusDomainPage.h
//
//  Maintained By:
//      David Potter    (DavidP)    21-MAR-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CClusDomainPage
    : public ITaskGetDomainsCallback
{
friend class CClusCfgWizard;

private: // data
    HWND                m_hwnd;             // Our HWND
    IServiceProvider *  m_psp;              // Service Manager
    BSTR *              m_pbstrClusterName; // Cluster Name buffer
    ECreateAddMode      m_ecamCreateAddMode;// Creating? Adding?
    UINT                m_idsDesc;          // Resource ID for domain description string.
    BOOL                m_fDisplayPage:1;   // Indicates whether page should be displayed or not

    //  IUnknown
    LONG                m_cRef;
    ITaskGetDomains *   m_ptgd;             // Get Domains Task

    //  ITaskGetDomainsCallback

private: // methods
    CClusDomainPage(
          IServiceProvider *    pspIn
        , ECreateAddMode        ecamCreateAddModeIn
        , BSTR *                pbstrClusterIn
        , UINT                  idsDescIn
        );
    virtual ~CClusDomainPage( void );

    LRESULT
        OnInitDialog( void );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT
        OnNotifySetActive( void );
    LRESULT
        OnNotifyWizNext( void );
    LRESULT
        OnNotifyQueryCancel( void );
    LRESULT
        OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT
        HrUpdateWizardButtons( BOOL fIgnoreCombBoxIn );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  ITaskGetDomainsCallback
    STDMETHOD( ReceiveDomainResult )( HRESULT hrIn );
    STDMETHOD( ReceiveDomainName )( LPCWSTR pcszDomainIn );

}; //*** class CClusDomainPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\cluscfg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ClusCfg.cpp
//
//  Description:
//      Implementation of CClusCfgWizard class.
//
//  Maintained By:
//      David Potter        (DavidP)    14-MAR_2001
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
// #include "ClusCfg.h" -- in the PCH.H
#include "TaskTreeView.h"
#include "AnalyzePage.h"
#include "CheckingAccessPage.h"
#include "ClusDomainPage.h"
#include "CommitPage.h"
#include "CompletionPage.h"
#include "CredLoginPage.h"
#include "CSAccountPage.h"
#include "IPAddressPage.h"
#include "SelNodePage.h"
#include "SelNodesPage.h"
#include "WelcomePage.h"
#include "SummaryPage.h"

//****************************************************************************
//
//  CClusCfgWizard
//
//****************************************************************************

DEFINE_THISCLASS( "CClusCfgWizard" )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  HRESULT
//  CClusCfgWizard::S_HrCreateInstance(
//      IUnknown ** ppunkOut
//      )
//
//  Description:
//      Create a CClusCfgWizard instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      Pointer to CClusCfgWizard instance.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgWizard::S_HrCreateInstance(
    IUnknown ** ppunkOut
    )
{
    TraceFunc( "" );

    Assert( ppunkOut != NULL );

    HRESULT hr;

    CClusCfgWizard *  pClusCfgWizard;

    pClusCfgWizard = new CClusCfgWizard();
    if ( pClusCfgWizard != NULL )
    {
        hr = THR( pClusCfgWizard->HrInit() );
        if ( SUCCEEDED( hr ) )
        {
            hr = THR( pClusCfgWizard->TypeSafeQI( IUnknown, ppunkOut ) );
        }

        pClusCfgWizard->Release( );
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    HRETURN( hr );

} //*** CClusCfgWizard::S_HrCreateInstance()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::CClusCfgWizard( )
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgWizard::CClusCfgWizard( )
{
    TraceFunc( "" );

    TraceFuncExit( );

} // CClusCfgWizard( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgWizard::~CClusCfgWizard( )
//
//--
//////////////////////////////////////////////////////////////////////////////
CClusCfgWizard::~CClusCfgWizard( )
{
    TraceFunc( "" );

    if ( m_bstrClusterName != NULL )
    {
        TraceSysFreeString( m_bstrClusterName );
    }

    if ( m_bstrAccountName != NULL )
    {
        TraceSysFreeString( m_bstrAccountName );
    }

    if ( m_bstrPassword != NULL )
    {
        TraceSysFreeString( m_bstrPassword );
    }

    if ( m_bstrDomain != NULL )
    {
        TraceSysFreeString( m_bstrDomain );
    }

    if ( m_bstrNetworkName != NULL )
    {
        TraceSysFreeString( m_bstrNetworkName );
    }

    if ( m_rgbstrComputers != NULL )
    {
        while( m_cComputers != 0 )
        {
            m_cComputers--;
            TraceSysFreeString( m_rgbstrComputers[ m_cComputers ] );
        }

        TraceFree( m_rgbstrComputers );
    }

    if ( m_psp != NULL )
    {
        m_psp->Release( );
    }

    if ( m_hRichEdit != NULL )
    {
        FreeLibrary( m_hRichEdit );
    }

    TraceFuncExit( );

} // ~CClusCfgWizard( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  CClusCfgWizard::HrInit( void )
//
//  Description:
//      Initialize a CClusCfgWizard instance.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgWizard::HrInit( void )
{
    HRESULT hr = S_OK;

    TraceFunc( "" );

    INITCOMMONCONTROLSEX    icex;

    BOOL    bRet;

    HMODULE hRichEdit;

    Assert( m_cRef == 0 );
    AddRef();

    Assert( m_bstrClusterName == NULL );
    Assert( m_bstrAccountName == NULL );
    Assert( m_bstrPassword == NULL );
    Assert( m_bstrDomain == NULL );
    Assert( m_ulIPAddress == 0 );
    Assert( m_ulIPSubnet == 0 );
    Assert( m_bstrNetworkName == NULL );
    Assert( m_cComputers == 0 );
    Assert( m_cArraySize == 0 );
    Assert( m_rgbstrComputers == NULL );

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_INTERNET_CLASSES
                | ICC_PROGRESS_CLASS
                | ICC_TREEVIEW_CLASSES
                | ICC_LISTVIEW_CLASSES;
    bRet = InitCommonControlsEx( &icex );
    Assert( bRet != FALSE );

    hr = THR( CoCreateInstance( CLSID_ServiceManager,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IServiceProvider,
                                reinterpret_cast< void ** >( &m_psp )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Initialize the RichEdit controls.
    //

    m_hRichEdit = LoadLibrary( L"RichEd32.Dll" );
    if ( m_hRichEdit == NULL )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError( ) ) );
        goto Cleanup;
    }

Cleanup:

    HRETURN( hr );

} //*** CClusCfgWizard::HrInit()


//****************************************************************************
//
//  IUnknown
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  [IUnknown] CClusCfgWizard::QueryInterface(
//      REFIID  riidIn,
//      PVOID * ppvOut
//      )
//
//  Description:
//
//  Arguments:
//      riidIn
//      ppvOut
//
//  Return Values:
//      NOERROR
//      E_NOINTERFACE
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::QueryInterface(
    REFIID  riidIn,
    PVOID * ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< IClusCfgWizard * >( this );
        hr      = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_IDispatch )
           || IsEqualIID( riidIn, IID_IClusCfgWizard )
            )
    {
        *ppvOut = TraceInterface( __THISCLASS__, IClusCfgWizard, this, 0 );
        hr      = S_OK;
    } // else if: IDispatch || IClusCfgWizard

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef( );
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CClusCfgWizard::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  [IUnknown] CClusCfgWizard::AddRef( void )
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgWizard::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    // Apartment object - interlocked not needed.
    m_cRef++;

    RETURN( m_cRef );

} //*** CClusCfgWizard::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  [IUnknown] CClusCfgWizard::Release( void )
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CClusCfgWizard::Release( void )
{
    TraceFunc( "[IUnknown]" );

    // Apartment object - interlocked not needed.
    m_cRef--;

    if ( m_cRef == 0 )
    {
        delete this;
        RETURN( 0 );
    }

    RETURN( m_cRef );

} //*** CClusCfgWizard::Release()


//****************************************************************************
//
//  IClusCfgWizard
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::CreateCluster(
//      LONG    ParentWnd,
//      BOOL *  pfDone
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::CreateCluster(
    HWND    lParentWndIn,
    BOOL *  pfDoneOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HPROPSHEETPAGE  rPages[ 11 ];
    PROPSHEETHEADER pshead;

    BOOL            fShowCredentialPage;
    BOOL            fSuccess;
    INT_PTR         ipStatus;

    HRESULT         hr = S_OK;

    ILogManager *       plm = NULL;

    CWelcomePage        dlgWelcomePage( camCREATING );
    CClusDomainPage     dlgClusDomainPage(     m_psp, camCREATING,        &m_bstrClusterName, IDS_DOMAIN_DESC_CREATE );
    CCheckingAccessPage dlgCheckingAccessPage( m_psp, &m_bstrClusterName, &fShowCredentialPage );
    CCredLoginPage      dlgCredLoginPage(      m_psp, &m_bstrClusterName, &fShowCredentialPage );
    CSelNodePage        dlgSelNodePage(        m_psp, camCREATING,        &m_cComputers,      &m_rgbstrComputers,  &m_bstrClusterName );
    CAnalyzePage        dlgAnalyzePage(        m_psp, camCREATING,        &m_cComputers,      &m_rgbstrComputers,  &m_bstrClusterName );
    CIPAddressPage      dlgIPAddressPage(      m_psp, camCREATING,        &m_ulIPAddress,     &m_ulIPSubnet,       &m_bstrNetworkName, &m_bstrClusterName );
    CCSAccountPage      dlgCSAccountPage(      m_psp, camCREATING,        &m_bstrAccountName, &m_bstrPassword,     &m_bstrDomain,      &m_bstrClusterName );
    CSummaryPage        dlgSummaryPage(        m_psp, camCREATING,        &m_bstrClusterName, IDS_SUMMARY_NEXT_CREATE );
    CCommitPage         dlgCommitPage(         m_psp, camCREATING,        &m_bstrClusterName );
    CCompletionPage     dlgCompletionPage( IDS_COMPLETION_TITLE_CREATE, IDS_COMPLETION_DESC_CREATE );

    //
    //  TODO:   gpease  14-MAY-2000
    //          Do we really need this?
    //
    if ( pfDoneOut == NULL )
        goto InvalidPointer;

    //
    // Start the logger.
    //
    hr = THR( m_psp->TypeSafeQS( CLSID_LogManager,
                                 ILogManager,
                                 &plm
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( plm->StartLogging() );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Create the Wizard.
    //
    ZeroMemory( &pshead, sizeof( pshead ) );
    pshead.dwSize           = sizeof( pshead );
    pshead.dwFlags          = PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
    pshead.hInstance        = g_hInstance;
    pshead.pszCaption       = MAKEINTRESOURCE( IDS_TITLE_FORM );
    pshead.phpage           = rPages;
    pshead.pszbmWatermark   = MAKEINTRESOURCE( IDB_WATERMARK );
    pshead.pszbmHeader      = MAKEINTRESOURCE( IDB_BANNER );
    pshead.hwndParent       = lParentWndIn;

    THR( HrAddWizardPage( &pshead, IDD_WELCOME_CREATE,  CWelcomePage::S_DlgProc,        0,                      0,                      (LPARAM) &dlgWelcomePage ) );
    THR( HrAddWizardPage( &pshead, IDD_CLUSDOMAIN,      CClusDomainPage::S_DlgProc,     IDS_TCLUSTER,           IDS_STCLUSTER_CREATE,   (LPARAM) &dlgClusDomainPage ) );
    THR( HrAddWizardPage( &pshead, IDD_CHECKINGACCESS,  CCheckingAccessPage::S_DlgProc, IDS_TCHECKINGACCESS,    IDS_STCHECKINGACCESS,   (LPARAM) &dlgCheckingAccessPage ) );
    THR( HrAddWizardPage( &pshead, IDD_CREDLOGIN,       CCredLoginPage::S_DlgProc,      IDS_TCREDLOGIN,         IDS_STCREDLOGIN,        (LPARAM) &dlgCredLoginPage ) );
    THR( HrAddWizardPage( &pshead, IDD_SELNODE,         CSelNodePage::S_DlgProc,        IDS_TSELNODE,           IDS_STSELNODE,          (LPARAM) &dlgSelNodePage ) );
    THR( HrAddWizardPage( &pshead, IDD_ANALYZE,         CAnalyzePage::S_DlgProc,        IDS_TANALYZE,           IDS_STANALYZE,          (LPARAM) &dlgAnalyzePage ) );
    THR( HrAddWizardPage( &pshead, IDD_IPADDRESS,       CIPAddressPage::S_DlgProc,      IDS_TIPADDRESS,         IDS_STIPADDRESS,        (LPARAM) &dlgIPAddressPage ) );
    THR( HrAddWizardPage( &pshead, IDD_CSACCOUNT,       CCSAccountPage::S_DlgProc,      IDS_TCSACCOUNT,         IDS_STCSACCOUNT,        (LPARAM) &dlgCSAccountPage ) );
    THR( HrAddWizardPage( &pshead, IDD_SUMMARY,         CSummaryPage::S_DlgProc,        IDS_TSUMMARY,           IDS_STSUMMARY_CREATE,   (LPARAM) &dlgSummaryPage ) );
    THR( HrAddWizardPage( &pshead, IDD_COMMIT,          CCommitPage::S_DlgProc,         IDS_TCOMMIT_CREATE,     IDS_STCOMMIT,           (LPARAM) &dlgCommitPage ) );
    THR( HrAddWizardPage( &pshead, IDD_COMPLETION,      CCompletionPage::S_DlgProc,     0,                      0,                      (LPARAM) &dlgCompletionPage ) );

    AssertMsg( pshead.nPages == ARRAYSIZE( rPages ), "Not enough or too many PROPSHEETPAGEs." );

    ipStatus = PropertySheet( &pshead );
    if ( ipStatus == -1 )
    {
        TW32( GetLastError( ) );
    }
    fSuccess = ipStatus != NULL;
    if ( pfDoneOut != NULL )
    {
        *pfDoneOut = fSuccess;
    }

Cleanup:
    if ( plm != NULL )
    {
        THR( plm->StopLogging() );
        plm->Release();
    }

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CClusCfgWizard::CreateCluster()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::AddClusterNodes(
//      /*[in, defaultvalue(0)]*/   LONG    lParentWndIn,
//      /*[out, retval]*/           BOOL *  pfDoneOut
//      )
//
//  Description:
//      Launch the Cluster Wizard in Add Cluster Nodes mode.
//
//  Parameters
//      ParentWnd           - Handle to the parent window (default NULL).
//                          If not NULL, the wizard will be positionned
//                          in the center of this window.
//      Done                - return TRUE if committed, FALSE if cancelled.
//
//  Return Values:
//      S_OK                - The call succeeded.
//      other HRESULTs      - The call failed.
//      E_POINTER
//      E_FAIL
//      E_OUTOFMEMORY
//
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::AddClusterNodes(
    HWND    lParentWndIn,
    BOOL *  pfDoneOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HPROPSHEETPAGE  rPages[ 10 ];
    PROPSHEETHEADER pshead;

    BOOL            fShowCredentialPage;
    BOOL            fSuccess;
    INT_PTR         ipStatus;

    HRESULT         hr = S_OK;

    ILogManager *   plm = NULL;

    OBJECTCOOKIE    cookieDummy;

    CWelcomePage        dlgWelcomePage( camADDING );
    CClusDomainPage     dlgClusDomainPage(     m_psp, camADDING,          &m_bstrClusterName, IDS_DOMAIN_DESC_ADD );
    CCheckingAccessPage dlgCheckingAccessPage( m_psp, &m_bstrClusterName, &fShowCredentialPage );
    CCredLoginPage      dlgCredLoginPage(      m_psp, &m_bstrClusterName, &fShowCredentialPage );
    CSelNodesPage       dlgSelNodesPage(       m_psp, camADDING,          &m_cComputers,      &m_rgbstrComputers,  &m_bstrClusterName );
    CAnalyzePage        dlgAnalyzePage(        m_psp, camADDING,          &m_cComputers,      &m_rgbstrComputers,  &m_bstrClusterName );
    CCSAccountPage      dlgCSAccountPage(      m_psp, camADDING,          &m_bstrAccountName, &m_bstrPassword,     &m_bstrDomain, &m_bstrClusterName );
    CSummaryPage        dlgSummaryPage(        m_psp, camADDING,          &m_bstrClusterName, IDS_SUMMARY_NEXT_ADD );
    CCommitPage         dlgCommitPage(         m_psp, camADDING,          &m_bstrClusterName );
    CCompletionPage     dlgCompletionPage( IDS_COMPLETION_TITLE_ADD, IDS_COMPLETION_DESC_ADD );

    //
    //  TODO:   gpease  12-JUL-2000
    //          Do we really need this? Or can we have the script implement an event
    //          sink that we signal?
    //
    if ( pfDoneOut == NULL )
        goto InvalidPointer;

    //
    // Start the logger.
    //
    hr = THR( m_psp->TypeSafeQS( CLSID_LogManager,
                                 ILogManager,
                                 &plm
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( plm->StartLogging() );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Create the Wizard.
    //
    ZeroMemory( &pshead, sizeof(pshead) );
    pshead.dwSize           = sizeof(pshead);
    pshead.dwFlags          = PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
    pshead.hInstance        = g_hInstance;
    pshead.pszCaption       = MAKEINTRESOURCE( IDS_TITLE_JOIN );
    pshead.phpage           = rPages;
    pshead.pszbmWatermark   = MAKEINTRESOURCE( IDB_WATERMARK );
    pshead.pszbmHeader      = MAKEINTRESOURCE( IDB_BANNER );
    pshead.hwndParent       = lParentWndIn;

    THR( HrAddWizardPage( &pshead, IDD_WELCOME_ADD,     CWelcomePage::S_DlgProc,        0,                      0,                      (LPARAM) &dlgWelcomePage ) );
    THR( HrAddWizardPage( &pshead, IDD_CLUSDOMAIN,      CClusDomainPage::S_DlgProc,     IDS_TCLUSTER,           IDS_STCLUSTER_ADD,      (LPARAM) &dlgClusDomainPage ) );
    THR( HrAddWizardPage( &pshead, IDD_CHECKINGACCESS,  CCheckingAccessPage::S_DlgProc, IDS_TCHECKINGACCESS,    IDS_STCHECKINGACCESS,   (LPARAM) &dlgCheckingAccessPage ) );
    THR( HrAddWizardPage( &pshead, IDD_CREDLOGIN,       CCredLoginPage::S_DlgProc,      IDS_TCREDLOGIN,         IDS_STCREDLOGIN,        (LPARAM) &dlgCredLoginPage ) );
    THR( HrAddWizardPage( &pshead, IDD_SELNODES,        CSelNodesPage::S_DlgProc,       IDS_TSELNODES,          IDS_STSELNODES,         (LPARAM) &dlgSelNodesPage ) );
    THR( HrAddWizardPage( &pshead, IDD_ANALYZE,         CAnalyzePage::S_DlgProc,        IDS_TANALYZE,           IDS_STANALYZE,          (LPARAM) &dlgAnalyzePage ) );
    THR( HrAddWizardPage( &pshead, IDD_CSACCOUNT,       CCSAccountPage::S_DlgProc,      IDS_TCSACCOUNT,         IDS_STCSACCOUNT,        (LPARAM) &dlgCSAccountPage ) );
    THR( HrAddWizardPage( &pshead, IDD_SUMMARY,         CSummaryPage::S_DlgProc,        IDS_TSUMMARY,           IDS_STSUMMARY_ADD,      (LPARAM) &dlgSummaryPage ) );
    THR( HrAddWizardPage( &pshead, IDD_COMMIT,          CCommitPage::S_DlgProc,         IDS_TCOMMIT_ADD,        IDS_STCOMMIT,           (LPARAM) &dlgCommitPage ) );
    THR( HrAddWizardPage( &pshead, IDD_COMPLETION,      CCompletionPage::S_DlgProc,     0,                      0,                      (LPARAM) &dlgCompletionPage ) );

    AssertMsg( pshead.nPages == ARRAYSIZE( rPages ), "Not enough or too many PROPSHEETPAGEs." );

    ipStatus = PropertySheet( &pshead );
    fSuccess = ipStatus != NULL;
    if ( pfDoneOut != NULL )
    {
        *pfDoneOut = fSuccess;
    }

Cleanup:
    if ( plm != NULL )
    {
        THR( plm->StopLogging() );
        plm->Release();
    }

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

} //*** CClusCfgWizard::AddClusterNodes()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::get_ClusterName(
//      BSTR * pbstrNameOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_ClusterName(
    BSTR * pbstrNameOut
    )
{
    HRESULT hr = S_OK;

    TraceFunc( "[IClusCfgWizard]" );

    if ( pbstrNameOut == NULL )
        goto InvalidPointer;

    if ( m_bstrClusterName == NULL )
        goto ErrorNotFound;

    *pbstrNameOut = TraceSysAllocString( m_bstrClusterName );
    if ( *pbstrNameOut == NULL )
        goto OutOfMemory;

Cleanup:
    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

ErrorNotFound:
    hr = S_FALSE;
    *pbstrNameOut = NULL;
    goto Cleanup;

} //*** CClusCfgWizard::get_ClusterName()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::put_ClusterName(
//      BSTR bstrNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ClusterName(
    BSTR bstrNameIn
    )
{
    TraceFunc1( "[IClusCfgWizard] bstrNameIn = %'ls'", bstrNameIn == NULL ? L"<null>" : bstrNameIn );

    HRESULT hr = S_OK;

    BSTR    bstrNewName;
    WCHAR * pszDomain = NULL;
    BSTR    bstrDomain = NULL;

    DNS_STATUS  dnsStatus;

    if ( bstrNameIn == NULL )
        goto InvalidArg;

    //
    //  BUGBUG: 23-AUG-2000 GalenB
    //
    //  This call succeeds when just a computer name is passed in.  Is it supposed to fail
    //  is the name is not a FQDN?
    //
    dnsStatus = TW32( DnsValidateName( bstrNameIn, DnsNameHostnameFull ) );
    if ( dnsStatus != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dnsStatus );
        goto Cleanup;
    }

    //
    //  KB: 23-AUG-2000 GalenB
    //
    //  If this passed in name is not a FQDN get this client's domain and append it.
    //

    pszDomain = wcschr( bstrNameIn, L'.' );
    if ( pszDomain == NULL )
    {
        hr = THR( HrGetComputerName( ComputerNamePhysicalDnsDomain, &bstrDomain ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        bstrNewName = TraceSysAllocStringLen( NULL, wcslen( bstrNameIn ) + ( UINT ) wcslen( bstrDomain ) + 2 );
        if ( bstrNewName == NULL )
        {
            goto OutOfMemory;
        } // if:

        wcscpy( bstrNewName, bstrNameIn );
        wcscat( bstrNewName, L"." );
        wcscat( bstrNewName, bstrDomain );
    } // if: need to get a domain
    else
    {
        bstrNewName = TraceSysAllocString( bstrNameIn );
        if ( bstrNewName == NULL )
            goto OutOfMemory;
    } // else: passed in name is most likely a FQDN

    if ( m_bstrClusterName != NULL )
    {
        TraceSysFreeString( m_bstrClusterName );
    }

    m_bstrClusterName = bstrNewName;

Cleanup:

    if ( bstrDomain != NULL )
    {
        TraceSysFreeString( bstrDomain );
    } // if:

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CClusCfgWizard::put_ClusterName()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::get_ServiceAccountUserName(
//      BSTR * pbstrNameOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_ServiceAccountUserName(
    BSTR * pbstrNameOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;

    if ( pbstrNameOut == NULL )
        goto InvalidPointer;

    if ( m_bstrAccountName == NULL )
        goto ErrorNotFound;

    *pbstrNameOut = TraceSysAllocString( m_bstrAccountName );
    if ( *pbstrNameOut == NULL )
        goto OutOfMemory;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

ErrorNotFound:
    hr = S_FALSE;
    *pbstrNameOut = NULL;
    goto Cleanup;

} //*** CClusCfgWizard::get_ServiceAccountUserName()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::put_ServiceAccountUserName(
//      BSTR bstrNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ServiceAccountUserName(
    BSTR bstrNameIn
    )
{
    TraceFunc1( "[IClusCfgWizard] bstrNameIn = '%ls'", bstrNameIn == NULL ? L"<null>" : bstrNameIn );

    HRESULT hr = S_OK;

    BSTR    bstrNewName;

    if ( bstrNameIn == NULL )
        goto InvalidArg;

    bstrNewName = TraceSysAllocString( bstrNameIn );
    if ( bstrNewName == NULL )
        goto OutOfMemory;

    if ( m_bstrAccountName != NULL )
    {
        TraceSysFreeString( m_bstrAccountName );
    }

    m_bstrAccountName = bstrNewName;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CClusCfgWizard::put_ServiceAccountUserName()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::get_ServiceAccountPassword(
//      BSTR * pbstrPasswordOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_ServiceAccountPassword(
    BSTR * pbstrPasswordOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;

    if ( pbstrPasswordOut == NULL )
        goto InvalidPointer;

    if ( m_bstrPassword == NULL )
        goto ErrorNotFound;

    *pbstrPasswordOut = SysAllocString( m_bstrPassword );
    if ( *pbstrPasswordOut == NULL )
        goto OutOfMemory;

Cleanup:
    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

ErrorNotFound:
    hr = S_FALSE;
    *pbstrPasswordOut = NULL;
    goto Cleanup;

} //*** CClusCfgWizard::get_ServiceAccountPassword()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::put_ServiceAccountPassword(
//      BSTR bstrPasswordIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ServiceAccountPassword(
    BSTR bstrPasswordIn
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;

    BSTR    bstrNewPassword;

    if ( bstrPasswordIn == NULL )
        goto InvalidArg;

    bstrNewPassword = TraceSysAllocString( bstrPasswordIn );
    if ( bstrNewPassword == NULL )
        goto OutOfMemory;

    if ( m_bstrPassword != NULL )
    {
        TraceSysFreeString( m_bstrPassword );
    }

    m_bstrPassword = bstrNewPassword;

Cleanup:

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CClusCfgWizard::put_ServiceAccountPassword()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::get_ServiceAccountDomainName(
//      BSTR * pbstrDomainOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_ServiceAccountDomainName(
    BSTR * pbstrDomainOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;

    if ( pbstrDomainOut == NULL )
        goto InvalidPointer;

    if ( m_bstrDomain == NULL )
        goto ErrorNotFound;

    *pbstrDomainOut = TraceSysAllocString( m_bstrDomain );
    if ( *pbstrDomainOut == NULL )
        goto OutOfMemory;

Cleanup:

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

ErrorNotFound:
    hr = S_FALSE;
    *pbstrDomainOut = NULL;
    goto Cleanup;

} //*** CClusCfgWizard::get_ServiceAccountDomainName()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::put_ServiceAccountDomainName(
//      BSTR bstrDomainIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ServiceAccountDomainName(
    BSTR bstrDomainIn
    )
{
    TraceFunc1( "[IClusCfgWizard] bstrDomainIn = '%ls'", bstrDomainIn == NULL ? L"<null>" : bstrDomainIn );

    HRESULT hr = S_OK;

    BSTR    bstrNewDomain;

    if ( bstrDomainIn == NULL )
        goto InvalidArg;

    bstrNewDomain = TraceSysAllocString( bstrDomainIn );
    if ( bstrNewDomain == NULL )
        goto OutOfMemory;

    if ( m_bstrDomain != NULL )
    {
        TraceSysFreeString( m_bstrDomain );
    }

    m_bstrDomain = bstrNewDomain;

Cleanup:

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = THR( E_OUTOFMEMORY );
    goto Cleanup;

} //*** CClusCfgWizard::put_ServiceAccountDomainName()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::get_ClusterIPAddress(
//      BSTR * pbstrIPAddressOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_ClusterIPAddress(
    BSTR * pbstrIPAddressOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;
    DWORD   dwStatus;
    LPWSTR  pwszIPAddress = NULL;

    if ( pbstrIPAddressOut == NULL )
        goto InvalidPointer;

    if ( m_ulIPAddress == 0 )
        goto ErrorNotFound;

    dwStatus = ClRtlTcpipAddressToString( m_ulIPAddress, &pwszIPAddress );
    if ( dwStatus != ERROR_SUCCESS )
        goto Win32Error;

    *pbstrIPAddressOut = TraceSysAllocString( pwszIPAddress );
    if ( *pbstrIPAddressOut == NULL )
        goto OutOfMemory;

Cleanup:
    if ( pwszIPAddress != NULL )
    {
        LocalFree( pwszIPAddress );
    }

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

ErrorNotFound:
    hr = S_FALSE;
    *pbstrIPAddressOut = NULL;
    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( hr );
    goto Cleanup;

} //*** CClusCfgWizard::get_ClusterIPAddress()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::put_ClusterIPAddress(
//      BSTR bstrIPAddressIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ClusterIPAddress(
    BSTR bstrIPAddressIn
    )
{
    TraceFunc1( "[IClusCfgWizard] bstrIPAddressIn = '%ls'", bstrIPAddressIn == NULL ? L"<null>" : bstrIPAddressIn );

    HRESULT hr = S_OK;
    DWORD   dwStatus;

    if ( bstrIPAddressIn == NULL )
        goto InvalidArg;

    dwStatus = ClRtlTcpipStringToAddress( bstrIPAddressIn, &m_ulIPAddress );
    if ( dwStatus != ERROR_SUCCESS )
        goto Win32Error;

Cleanup:

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( dwStatus );
    goto Cleanup;

} //*** CClusCfgWizard::put_ClusterIPAddress()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::get_ClusterIPSubnet(
//      BSTR * pbstrIPSubnetOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_ClusterIPSubnet(
    BSTR * pbstrIPSubnetOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;
    DWORD   dwStatus;
    LPWSTR  pwszIPSubnet = NULL;

    if ( pbstrIPSubnetOut == NULL )
        goto InvalidPointer;


    if ( m_ulIPSubnet == 0 )
        goto ErrorNotFound;

    dwStatus = ClRtlTcpipAddressToString( m_ulIPSubnet, &pwszIPSubnet );
    if ( dwStatus != ERROR_SUCCESS )
        goto Win32Error;

    *pbstrIPSubnetOut = TraceSysAllocString( pwszIPSubnet );
    if ( *pbstrIPSubnetOut == NULL )
        goto OutOfMemory;

Cleanup:
    if ( pwszIPSubnet != NULL )
    {
        LocalFree( pwszIPSubnet );
    }

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

ErrorNotFound:
    hr = S_FALSE;
    *pbstrIPSubnetOut = NULL;
    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( hr );
    goto Cleanup;

} //*** CClusCfgWizard::get_ClusterIPSubnet()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::put_ClusterIPSubnet(
//      BSTR bstrSubnetMaskIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ClusterIPSubnet(
    BSTR bstrIPSubnetIn
    )
{
    TraceFunc1( "[IClusCfgWizard] bstrIPSubnetIn = '%ls'", bstrIPSubnetIn );

    HRESULT hr = S_OK;
    DWORD   dwStatus;

    if ( bstrIPSubnetIn == NULL )
        goto InvalidArg;

    dwStatus = ClRtlTcpipStringToAddress( bstrIPSubnetIn, &m_ulIPSubnet );
    if ( dwStatus != ERROR_SUCCESS )
        goto Win32Error;

Cleanup:

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( dwStatus );
    goto Cleanup;

} //*** CClusCfgWizard::put_ClusterIPSubnet()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::get_ClusterIPAddressNetwork(
//      BSTR * pbstrNetworkNameOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::get_ClusterIPAddressNetwork(
    BSTR * pbstrNetworkNameOut
    )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;

    if ( pbstrNetworkNameOut == NULL )
        goto InvalidPointer;

    if ( m_bstrNetworkName == NULL )
        goto ErrorNotFound;

    *pbstrNetworkNameOut = TraceSysAllocString( m_bstrNetworkName );
    if ( *pbstrNetworkNameOut == NULL )
        goto OutOfMemory;

Cleanup:

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

ErrorNotFound:
    hr = S_FALSE;
    *pbstrNetworkNameOut = NULL;
    goto Cleanup;

} //*** CClusCfgWizard::get_ClusterIPAddressNetwork()

//////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CClusCfgWizard::put_ClusterIPAddressNetwork(
//      BSTR bstrNetworkNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::put_ClusterIPAddressNetwork(
    BSTR bstrNetworkNameIn
    )
{
    TraceFunc1( "[IClusCfgWizard] bstrNetworkNameIn = '%ls'", bstrNetworkNameIn == NULL ? L"<null>" : bstrNetworkNameIn );

    HRESULT hr = S_OK;

    BSTR    bstrNewNetworkName;

    if ( bstrNetworkNameIn == NULL )
        goto InvalidArg;

    bstrNewNetworkName = TraceSysAllocString( bstrNetworkNameIn );
    if ( bstrNewNetworkName == NULL )
        goto OutOfMemory;

    if ( m_bstrNetworkName != NULL )
    {
        TraceSysFreeString( m_bstrNetworkName );
    }

    m_bstrNetworkName = bstrNewNetworkName;

Cleanup:

    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

OutOfMemory:
    hr = THR( E_OUTOFMEMORY );
    goto Cleanup;

} //*** CClusCfgWizard::put_ClusterIPAddressNetwork()

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CClusCfgWizard::AddComputer(
//      LPCWSTR bstrNameIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::AddComputer(
    LPCWSTR    pcszNameIn
    )
{
    TraceFunc1( "[IClusCfgWizard] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_OK;

    BSTR * rgbstrNewArray;
    WCHAR  wszNameToAdd[ DNS_MAX_NAME_BUFFER_LENGTH ];
    ULONG  cNewArraySize;
    ULONG  idx;

    if ( ( pcszNameIn == NULL ) || ( wcslen( pcszNameIn ) > DNS_MAX_NAME_BUFFER_LENGTH-1 ) )
        goto InvalidArg;

    //
    //  If pcszNameIn is a FQDN, truncate. Otherwise, simply copy it.
    //
    if ( wcschr( pcszNameIn, L'.' ) == NULL )
    {
        wcscpy( wszNameToAdd, pcszNameIn );
    }
    else
    {
        size_t cHostNameSize;

        cHostNameSize = wcscspn( pcszNameIn, L"." );
        wcsncpy( wszNameToAdd, pcszNameIn, cHostNameSize );
        wszNameToAdd[ cHostNameSize ] = L'\0';
    }


    //
    //  Check to see if it already exists.
    //
    for ( idx = 0; idx < m_cComputers; idx++ )
    {
        if ( wcscmp( m_rgbstrComputers[ idx ], wszNameToAdd ) == 0 )
            goto AlreadyAdded;
    }

    //
    //  Add a new entry to the list.
    //
    if ( m_cComputers == m_cArraySize )
    {
        cNewArraySize = m_cArraySize + 10;

        if ( m_rgbstrComputers == NULL )
        {
            rgbstrNewArray = (BSTR *) TraceAlloc( 0, cNewArraySize * sizeof( BSTR ) );
        }
        else
        {
            rgbstrNewArray = (BSTR *) TraceReAlloc( m_rgbstrComputers, cNewArraySize * sizeof( BSTR ), 0 );
        }

        if ( rgbstrNewArray == NULL )
            goto OutOfMemory;

        m_cArraySize = cNewArraySize;
        m_rgbstrComputers = rgbstrNewArray;
    }

    m_rgbstrComputers[ m_cComputers ] = TraceSysAllocString( wszNameToAdd );
    if ( m_rgbstrComputers[ m_cComputers ] == NULL )
        goto OutOfMemory;

    m_cComputers ++;

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

AlreadyAdded:
    hr = S_OK;
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} // AddComputer( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CClusCfgWizard::RemoveComputer(
//      LPCWSTR pcszNameIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::RemoveComputer(
    LPCWSTR pcszNameIn
    )
{
    TraceFunc1( "[IClusCfgWizard] pcszNameIn = '%ls'", pcszNameIn == NULL ? L"<null>" : pcszNameIn );

    HRESULT hr = S_FALSE;

    ULONG   idx;

    if ( pcszNameIn == NULL )
        goto InvalidArg;

    for( idx = 0; idx < m_cComputers; idx ++ )
    {
        if ( wcscmp( m_rgbstrComputers[ idx ], pcszNameIn ) == 0 )
        {
            //
            //  Match. Remove the entry by shifting the list.
            //
            m_cComputers --;
            MoveMemory( &m_rgbstrComputers[ idx ], &m_rgbstrComputers[ idx + 1], m_cComputers - idx );
            hr = S_OK;
            break;
        }
    }

Cleanup:
    HRETURN( hr );

InvalidArg:
    hr = THR( E_INVALIDARG );
    goto Cleanup;

} // RemoveComputer( )

//////////////////////////////////////////////////////////////////////////////
//
//  STDMETHODIMP
//  CClusCfgWizard::ClearComputerList( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::ClearComputerList( void )
{
    TraceFunc( "[IClusCfgWizard]" );

    HRESULT hr = S_OK;

    ULONG   idx;

    for ( idx = 0; idx < m_cComputers; idx ++ )
    {
        TraceSysFreeString( m_rgbstrComputers[ idx ] );
    }

    m_cComputers = 0;

    HRETURN( hr );

} // ClearComputerList( )


//****************************************************************************
//
//  IDispatch
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  [IDispatch] CClusCfgWizard::GetTypeInfoCount(
//      UINT * pctinfo
//      )
//
//  Description:
//
//  Arguments:
//      pctinfoOut
//
//  Return Values:
//      NOERROR
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::GetTypeInfoCount(
    UINT * pctinfoOut
    )
{
    TraceFunc( "[IDispatch]" );

    *pctinfoOut = 1;
    HRETURN( NOERROR );

} //*** CClusCfgWizard::GetTypeInfoCount()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  [IDispatch] CClusCfgWizard::GetTypeInfo(
//      UINT            itinfoIn,
//      LCID            lcidIn,
//      ITypeInfo **    pptinfoOut
//      )
//
//  Description:
//
//  Arguments:
//      itinfoIn
//      lcidIn
//      pptinfoOut
//
//  Return Values:
//      NOERROR
//      DISP_E_BADINDEX
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusCfgWizard::GetTypeInfo(
    UINT            itinfoIn,
    LCID            lcidIn,
    ITypeInfo **    pptinfoOut
    )
{
    TraceFunc( "[IDispatch]" );

    HRESULT hr = NOERROR;

    *pptinfoOut = NULL;

    if ( itinfoIn != 0 )
    {
        hr = DISP_E_BADINDEX;
    }
    else
    {
        m_ptinfo->AddRef();
        *pptinfoOut = m_ptinfo;
    }

    HRETURN( hr );

} //*** CClusCfgWizard::GetTypeInfo()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  [IDispatch] CClusCfgWizard::GetIDsOfNames(
//      REFIID      riid,
//      OLECHAR **  rgszNames,
//      UINT        cNames,
//      LCID        lcid,
//      DISPID *    rgdispid
//      )
//
//  Description:
//
//  Arguments:
//      riid
//      rgszNames
//      cNames
//      lcid
//      rgdispid
//
//  Return Values:
//      HRESULT from DispGetIDsOfNames().
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::GetIDsOfNames(
    REFIID      riid,
    OLECHAR **  rgszNames,
    UINT        cNames,
    LCID        lcid,
    DISPID *    rgdispid
    )
{
    TraceFunc( "[IDispatch]" );

    HRESULT hr;

    hr = DispGetIDsOfNames( m_ptinfo, rgszNames, cNames, rgdispid );

    HRETURN( hr );

} //*** CClusCfgWizard::GetIDsOfNames()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  [IDispatch] CClusCfgWizard::Invoke(
//      DISPID          dispidMember,
//      REFIID          riid,
//      LCID            lcid,
//      WORD            wFlags,
//      DISPPARAMS *    pdispparams,
//      VARIANT *       pvarResult,
//      EXCEPINFO *     pexcepinfo,
//      UINT *          puArgErr
//      )
//
//  Description:
//
//  Arguments:
//      dispidMember
//      riid
//      lcid
//      pdispparams
//      pvarResult
//      pexceptinfo
//      puArgErr
//
//  Return Values:
//      HRESULT from DispInvoke().
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgWizard::Invoke(
    DISPID          dispidMember,
    REFIID          riid,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    UINT *          puArgErr
    )
{
    TraceFunc( "[IDispatch]" );

    HRESULT hr;

    hr = DispInvoke(
            this,
            m_ptinfo,
            dispidMember,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            puArgErr
            );

    HRETURN( hr );

} //*** CClusCfgWizard::Invoke()


//****************************************************************************
//
//  Private
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  HrAddWizardPage(
//      LPPROPSHEETHEADER ppshInout,
//      UINT idTemplateIn,
//      DLGPROC pfnDlgProcIn,
//      UINT idTitleIn,
//      UINT idSubtitleIn,
//      LPARAM lParam
//      )
//
//  Description:
//      Fills in the PROPSHEETPAGE structure, create the page and adds it to
//      the wizard's PROPSHEETHEADER.
//
//  Parameters:
//      ppshInout
//          LPPROPSHEETHEADER structure to add page to.
//
//      idTemplateIn
//          The dialog template ID of the page.
//
//      pfnDlgProcIn
//          The dialog proc for the page.
//
//      idCaptionIn
//          The page's caption.
//
//      idTitleIn
//          The page's title.
//
//      idSubtitleIn
//          The page's sub-title.
//
//      lParam
//          The lParam to be put into the PROPSHEETPAGE stucture's lParam.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgWizard::HrAddWizardPage(
    LPPROPSHEETHEADER   ppshInout,
    UINT                idTemplateIn,
    DLGPROC             pfnDlgProcIn,
    UINT                idTitleIn,
    UINT                idSubtitleIn,
    LPARAM              lParam
    )
{
    TraceFunc( "" );

    PROPSHEETPAGE psp;

    TCHAR szTitle[ 256 ];
    TCHAR szSubTitle[ 256 ];

    ZeroMemory( &psp, sizeof(psp) );

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USETITLE;
    psp.pszTitle    = ppshInout->pszCaption;
    psp.hInstance   = ppshInout->hInstance;
    psp.pszTemplate = MAKEINTRESOURCE( idTemplateIn );
    psp.pfnDlgProc  = pfnDlgProcIn;
    psp.lParam      = lParam;

    if (    ( idTemplateIn == IDD_WELCOME_CREATE )
        ||  ( idTemplateIn == IDD_WELCOME_ADD )
        ||  ( idTemplateIn == IDD_COMPLETION )
       )
    {
        psp.dwFlags |= PSP_HIDEHEADER;
    }
    else
    {
        if ( idTitleIn != 0 )
        {
            DWORD dw;
            dw = LoadString( g_hInstance, idTitleIn, szTitle, ARRAYSIZE(szTitle) );
            Assert( dw );
            psp.pszHeaderTitle = szTitle;
            psp.dwFlags |= PSP_USEHEADERTITLE;
        }
        else
        {
            psp.pszHeaderTitle = NULL;
        }

        if ( idSubtitleIn != 0 )
        {
            DWORD dw;
            dw = LoadString( g_hInstance, idSubtitleIn, szSubTitle, ARRAYSIZE(szSubTitle) );
            Assert( dw );
            psp.pszHeaderSubTitle = szSubTitle;
            psp.dwFlags |= PSP_USEHEADERSUBTITLE;
        }
        else
        {
            psp.pszHeaderSubTitle = NULL;
        }
    }

    ppshInout->phpage[ ppshInout->nPages ] = CreatePropertySheetPage( &psp );
    Assert( ppshInout->phpage[ ppshInout->nPages ] != NULL );
    if ( ppshInout->phpage[ ppshInout->nPages ] != NULL )
    {
        ppshInout->nPages++;
    }

    HRETURN( S_OK );

} // HrAddWizardPage( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\commitpage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CommitPage.h
//
//  Maintained By:
//      Galen Barbee  (GalenB)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CCommitPage
    : public INotifyUI
    , public IClusCfgCallback
{
friend class CClusCfgWizard;

private: // data
    HWND                    m_hwnd;             // Our HWND
    IServiceProvider *      m_psp;              // Service Manager
    IObjectManager *        m_pom;              // Object Manager
    BSTR *                  m_pbstrClusterName; // Cluster Name to analyze
    bool                    m_fNext;            // If Next was pressed...
    bool                    m_fDisableBack;     // When we passed the point of no return.
    bool                    m_fAborted;         // Back was pressed and we need to tell the servers to abort.
    ECreateAddMode          m_ecamCreateAddMode;// Creating or Adding?
    HTREEITEM               m_htiReanalyze;     // Reanalyze tree item handle.

    bool                    m_rgfSubReanalyzeAdded[ 5 ];

    //  IUnknown
    LONG                    m_cRef;             // Reference count

    //  IClusCfgCallback
    OBJECTCOOKIE            m_cookieCompletion; // Completion cookie
    bool                    m_fTaskDone;        // Is the task done yet?
    HRESULT                 m_hrResult;         // Result of the analyze task
    CTaskTreeView *         m_pttv;             // Task TreeView
    BSTR                    m_bstrLogMsg;       // Logging message buffer
    IConnectionPoint *      m_pcpcb;            // IClusCfgCallback Connection Point
    DWORD                   m_dwCookieCallback; // Notification registration cookie

    //  INotifyUI
    IConnectionPoint *      m_pcpui;            // INotifyUI Connection Point
    DWORD                   m_dwCookieNotify;   // Notification registration cookie

private: // methods
    CCommitPage(
              IServiceProvider * pspIn
            , ECreateAddMode     ecamCreateAddModeIn
            , BSTR *             pbstrClusterIn
             );
    ~CCommitPage( void );

    LRESULT OnInitDialog( void );
    LRESULT OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT OnNotifyQueryCancel( void );
    LRESULT OnNotifySetActive( void );
    LRESULT OnNotifyWizNext( void );
    LRESULT OnNotifyWizBack( void );
    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT HrUpdateWizardButtons( void );
    HRESULT HrCleanupCommit( void );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  INotifyUI
    STDMETHOD( ObjectChanged )( OBJECTCOOKIE cookieIn);

    //  IClusCfgCallback
    STDMETHOD( SendStatusReport )(
                  LPCWSTR    pcszNodeNameIn
                , CLSID      clsidTaskMajorIn
                , CLSID      clsidTaskMinorIn
                , ULONG      ulMinIn
                , ULONG      ulMaxIn
                , ULONG      ulCurrentIn
                , HRESULT    hrStatusIn
                , LPCWSTR    pcszDescriptionIn
                , FILETIME * pftTimeIn
                , LPCWSTR    pcszReferenceIn
                );

};  // class CCommitPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\completionpage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CompletionPage.h
//
//  Maintained By:
//      David Potter    (DavidP)    22-MAR-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CCompletionPage
{
friend class CClusCfgWizard;

private: // data
    HWND            m_hwnd;         // Our HWND
    HFONT           m_hFont;        // Title font
    UINT            m_idsTitle;     // Resource ID for the title string
    UINT            m_idsDesc;      // Resource ID for the description string.

private: // methods
    CCompletionPage( UINT idsTitleIn, UINT idsDescIn );
    virtual ~CCompletionPage();

    LRESULT
        OnInitDialog( void );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT
        OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hwndDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );

}; //*** class CCompletionPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\completionpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CompletionPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    22-MAR-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "CompletionPage.h"
#include "WizardUtils.h"

DEFINE_THISCLASS("CCompletionPage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCompletionPage::CCompletionPage
//
//  Description:
//      Constructor.
//
//  Arguments:
//      idsTitleIn      -- Resource ID for the title string.
//      idsDescIn       -- Resource ID for the description string.
//
//--
//////////////////////////////////////////////////////////////////////////////
CCompletionPage::CCompletionPage(
      UINT  idsTitleIn
    , UINT  idsDescIn
    )
{
    TraceFunc( "" );

    Assert( idsTitleIn != 0 );
    Assert( idsDescIn != 0 );

    //  m_hwnd
    m_hFont = NULL;

    m_idsTitle = idsTitleIn;
    m_idsDesc  = idsDescIn;

    TraceFuncExit();

} //*** CCompletionPage::CCompletionPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCompletionPage::~CCompletionPage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCompletionPage::~CCompletionPage( void )
{
    TraceFunc( "" );
    
    if ( m_hFont != NULL )
    {
        DeleteObject( m_hFont );
    }

    TraceFuncExit();

} //*** CCompletionPage::~CCompletionPage( void )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCompletionPage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCompletionPage::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr      = FALSE;
    HDC     hdc     = NULL;
    HRESULT hr;

    NONCLIENTMETRICS ncm;

    LOGFONT LogFont;
    INT     iSize;

    DWORD   dw;
    BOOL    fRet;
    BSTR    bstr = NULL;

    WCHAR   szFontSize[ 3 ];    // shouldn't be bigger than 2 digits!!

    //
    //  TODO:   gpease  12-MAY-2000
    //          Fill in the summary control.
    //

    //
    //  Make the Title static BIG and BOLD. Why the wizard control itself can't
    //  do this is beyond me!
    //

    ZeroMemory( &ncm, sizeof( ncm ) );
    ZeroMemory( &LogFont, sizeof( LOGFONT ) );

    //
    //  Find out the system default font metrics.
    //
    ncm.cbSize = sizeof( ncm );
    fRet = SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );
    if ( ! fRet )
    {
        goto Win32Error;
    }

    //
    //  Copy it.
    //
    LogFont = ncm.lfMessageFont;

    //
    //  Make it BOLD.
    //
    LogFont.lfWeight = FW_BOLD;

    //
    //  Find out what we want it to look like.
    //
    dw = LoadString( g_hInstance, IDS_LARGEFONTNAME, LogFont.lfFaceName, ARRAYSIZE( LogFont.lfFaceName) );
    AssertMsg( dw != 0, "String missing!" );

    dw = LoadString( g_hInstance, IDS_LARGEFONTSIZE, szFontSize, ARRAYSIZE( szFontSize ) );
    AssertMsg( dw != 0, "String missing!" );

    iSize = wcstoul( szFontSize, NULL, 10 );

    //
    //  Grab the DC.
    //
    hdc = GetDC( m_hwnd );
    if ( hdc == NULL )
    {
        goto Win32Error;
    }

    //
    //  Use the magic equation....
    //
    LogFont.lfHeight = 0 - ( GetDeviceCaps( hdc, LOGPIXELSY ) * iSize / 72 );

    //
    //  Create the font.
    //
    m_hFont = CreateFontIndirect( &LogFont );
    if ( m_hFont == NULL )
    {
        goto Win32Error;
    }

    //
    //  Apply the font.
    //
    SetWindowFont( GetDlgItem( m_hwnd, IDC_COMPLETION_S_TITLE ), m_hFont, TRUE );

    //
    // Set the text of the title control.
    //

    hr = HrLoadStringIntoBSTR( g_hInstance, m_idsTitle, &bstr );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SetDlgItemText( m_hwnd, IDC_COMPLETION_S_TITLE, bstr );

    //
    // Set the text of the description control.
    //

    hr = HrLoadStringIntoBSTR( g_hInstance, m_idsDesc, &bstr );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SetDlgItemText( m_hwnd, IDC_COMPLETION_S_DESC, bstr );

    goto Cleanup;

Win32Error:
    TW32( GetLastError() );

Cleanup:
    TraceSysFreeString( bstr );
    if ( hdc != NULL )
    {
        ReleaseDC( m_hwnd, hdc);
    }

    RETURN( lr );

} //*** CCompletionPage::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCompletionPage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCompletionPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            // Disable cancel
            EnableWindow( GetDlgItem( GetParent( m_hwnd ), IDCANCEL ), FALSE );

            // Show Finish
            PropSheet_SetWizButtons( GetParent( m_hwnd ), PSWIZB_FINISH );
            break;
    } // switch: notify code

    RETURN( lr );

} //*** CCompletionPage::OnNotify()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCompletionPage::OnCommand(
//      UINT    idNotificationIn,
//      UINT    idControlIn,
//      HWND    hwndSenderIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCompletionPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_COMPLETION_PB_VIEW_LOG:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrViewLogFile( m_hwnd ) );
                lr = TRUE;
            } // if: button click
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CCompletionPage::OnCommand()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT_PTR 
//  CALLBACK
//  CCompletionPage::S_DlgProc( 
//      HWND    hwndDlgIn, 
//      UINT    nMsgIn, 
//      WPARAM  wParam, 
//      LPARAM  lParam 
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR 
CALLBACK
CCompletionPage::S_DlgProc( 
    HWND    hwndDlgIn, 
    UINT    nMsgIn, 
    WPARAM  wParam, 
    LPARAM  lParam 
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CCompletionPage * pPage;

    if ( nMsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CCompletionPage * >( ppage->lParam );
        pPage->m_hwnd = hwndDlgIn;
    }
    else
    {
        pPage = reinterpret_cast< CCompletionPage *> ( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );
    }

    if ( pPage != NULL )
    {
        Assert( hwndDlgIn == pPage->m_hwnd );

        switch( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr = pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), reinterpret_cast< HWND >( lParam ) );
                break;

            // no default clause needed
        } // switch: nMsgIn
    } // if: page is specified

    return lr;

} //*** CCompletionPage::S_DlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\csaccountpage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CSAccountPage.h
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CCSAccountPage
    : public ITaskGetDomainsCallback
{
friend class CClusCfgWizard;

private: // data
    HWND                m_hwnd;                 // Our HWND
    IServiceProvider *  m_psp;                  // Service Manager
    ECreateAddMode      m_ecamCreateAddMode;    // Creating or Adding?

    BSTR *              m_pbstrUsername;        // Service Account Username
    BSTR *              m_pbstrPassword;        // Service Account Password
    BSTR *              m_pbstrDomain;          // Service Account Domain
    BSTR *              m_pbstrClusterName;     // Cluster FDQN - Used to get the Default Domain name

    //  IUnknown
    LONG                m_cRef;
    ITaskGetDomains *   m_ptgd;                 // Get Domains Task

private: // methods
    CCSAccountPage( IServiceProvider *  pspIn,
                    ECreateAddMode      ecamCreateAddModeIn,
                    BSTR *              pbstrUsernameIn,
                    BSTR *              pbstrPasswordIn,
                    BSTR *              pbstrDomainIn,
                    BSTR *              pbstrClusterNameIn
                    );
    virtual ~CCSAccountPage();

    LRESULT
        OnInitDialog( void );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT
        OnNotifyQueryCancel( void );
    LRESULT
        OnNotifySetActive( void );
    LRESULT
        OnNotifyWizNext( void );
    LRESULT
        OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT
        HrUpdateWizardButtons( BOOL fIgnoreComboxBoxIn );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  ITaskGetDomainsCallback
    STDMETHOD( ReceiveDomainResult )( HRESULT hrIn );
    STDMETHOD( ReceiveDomainName )( LPCWSTR pcszDomainIn );

};  // class CCSAccountPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\credloginpage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CredLoginPage.h
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CCredLoginPage
    : public ITaskGetDomainsCallback
{
friend class CClusCfgWizard;

private: // data
    HWND                m_hwnd;                     // Our HWND
    IServiceProvider *  m_psp;                      // Service Manager
    BOOL *              m_pfShowCredentialsPage;    // Do we need to show ourselves?
    BSTR *              m_pbstrClusterName;         // Cluster Name
    BOOL                m_fIgnoreBackButton:1;      // If TRUE, don't unset the m_pfShowCredentialsPage.

    // IUnknown
    LONG                m_cRef;                     // Reference counter
    ITaskGetDomains *   m_ptgd;                     // Get Domains Task

private: // methods
    CCredLoginPage( IServiceProvider * pspIn,
                    BSTR * pbstrClusterIn,
                    BOOL * pfShowCredentialsPageIn
                    );
    virtual ~CCredLoginPage();

    LRESULT
        OnInitDialog( void );
    LRESULT
        OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT
        HrUpdateWizardButtons( BOOL fIgnoreComboxBoxIn );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT
        OnNotifySetActive( void );
    LRESULT
        OnNotifyQueryCancel( void );
    LRESULT
        OnNotifyWizNext( void );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  ITaskGetDomainsCallback
    STDMETHOD( ReceiveDomainResult )( HRESULT hrIn );
    STDMETHOD( ReceiveDomainName )( LPCWSTR pcszDomainIn );

};  // class CCredLoginPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\detailsdlg.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      DetailsDlg.h
//
//  Maintained By:
//      David Potter    (DavidP)    27-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CDetailsDlg
//
//  Description:
//      Class to handle the Details dialog which is displayed to show
//      details for an item in a tree control on the Analysis or Commit
//      pages.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CDetailsDlg
{
    friend class CAnalayzePage;
    friend class CCommitPage;
    friend class CTaskTreeView;

private: // data
    HWND                m_hwnd;             // Our HWND
    HICON               m_hiconWarn;        // Warning icon
    HICON               m_hiconError;       // Error icon
    CTaskTreeView *     m_pttv;             // Tree view to traverse
    HTREEITEM           m_htiSelected;      // Selected item when dialog was created.

    CHARRANGE           m_chrgEnLinkClick;  // Character range for EN_LINK messages.

    unsigned int        m_fControlDown : 1; // TRUE if a control key is down.
    unsigned int        m_fAltDown : 1;     // TRUE if an alt key is down.

private: // methods
    CDetailsDlg(
          CTaskTreeView *   pttvIn
        , HTREEITEM         htiSelectedIn
        );
    ~CDetailsDlg( void );

    static INT_PTR CALLBACK
        S_DlgProc( HWND hwndDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );

    LRESULT OnInitDialog( void );
    void OnDestroy( void );
    void OnSysColorChange( void );
    LRESULT OnKeyDown( LPARAM lParamIn );
    LRESULT OnKeyUp( LPARAM lParamIn );

    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    LRESULT OnCommandBnClickedPrev( void );
    LRESULT OnCommandBnClickedNext( void );
    LRESULT OnCommandBnClickedCopy( void );

    LRESULT OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT OnNotifyEnLink( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );

    void HandleLinkClick( ENLINK * penlIn, WPARAM idCtrlIn );
    void UpdateButtons( void );

    HRESULT HrDisplayItem( HTREEITEM htiIn );

    HRESULT
        HrAppendControlStringToClipboardString(
              BSTR *    pbstrClipboard
            , UINT      idsLabelIn
            , UINT      idcDataIn
            , bool      fNewlineBeforeTextIn
            );

public: // methods
    static HRESULT
        S_HrDisplayModalDialog(
              HWND              hwndParentIn
            , CTaskTreeView *   pttvIn
            , HTREEITEM         htiSelectedIn
            );

}; //*** class CDetailsDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\credloginpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CredLoginPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    22-MAR-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "CredLoginPage.h"
#include "WizardUtils.h"

DEFINE_THISCLASS("CCredLoginPage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCredLoginPage::CCredLoginPage(
//      IServiceProvider *  pspIn,
//      BSTR *              pbstrClusterNameIn,
//      BOOL *              pfShowCredentialsPageIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCredLoginPage::CCredLoginPage(
    IServiceProvider *  pspIn,
    BSTR *              pbstrClusterNameIn,
    BOOL *              pfShowCredentialsPageIn
    )
{
    TraceFunc( "" );

    //  m_hwnd
    THR( pspIn->TypeSafeQI( IServiceProvider, &m_psp ) );
    m_pfShowCredentialsPage = pfShowCredentialsPageIn;
    m_pbstrClusterName      = pbstrClusterNameIn;
    m_fIgnoreBackButton     = FALSE;

    m_cRef = 0;
    m_ptgd = NULL;

    Assert( m_pbstrClusterName != NULL );

    TraceFuncExit();

} //*** CCredLoginPage::CCredLoginPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCredLoginPage::~CCredLoginPage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCredLoginPage::~CCredLoginPage( void )
{
    TraceFunc( "" );

    if ( m_psp != NULL )
    {
        m_psp->Release();
    }

    if ( m_ptgd != NULL )
    {
        //  Make sure we don't get called anymore.
        THR( m_ptgd->SetCallback( NULL ) );

        m_ptgd->Release();
    }

    Assert( m_cRef == 0 );

    TraceFuncExit();

} //*** CCredLoginPage::~CCredLoginPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCredLoginPage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCredLoginPage::OnInitDialog( void )
{
    TraceFunc( "" );

    HRESULT hr;

    IUnknown *              punk = NULL;
    ITaskManager *          ptm  = NULL;

    LRESULT lr = FALSE;

    //
    // (jfranco, bug #377545) Limit user name length to MAX_USERNAME_LENGTH
    //
    // according to msdn, EM_(SET)LIMITTEXT does not return a value, so ignore what SendDlgItemMessage returns
    SendDlgItemMessage( m_hwnd, IDC_CREDLOGIN_E_USERNAME, EM_SETLIMITTEXT, MAX_USERNAME_LENGTH, 0 );

    //
    //  Create the task to get the domains.
    //
    hr = THR( m_psp->TypeSafeQS( CLSID_TaskManager,
                                 ITaskManager,
                                 &ptm
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( ptm->CreateTask( TASK_GetDomains, &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( ITaskGetDomains, &m_ptgd ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( m_ptgd->SetCallback( static_cast< ITaskGetDomainsCallback * >( this ) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( ptm->SubmitTask( m_ptgd ) );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( ptm != NULL )
    {
        ptm->Release();
    }


    RETURN( lr );

} //*** CCredLoginPage::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCredLoginPage::OnCommand(
//      UINT    idNotificationIn,
//      UINT    idControlIn,
//      HWND    hwndSenderIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCredLoginPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
    case IDC_CREDLOGIN_E_USERNAME:
    case IDC_CREDLOGIN_E_PASSWORD:
        if ( idNotificationIn == EN_CHANGE )
        {
            THR( HrUpdateWizardButtons( FALSE ) );
            lr = TRUE;
        }
        break;

    case IDC_CREDLOGIN_CB_DOMAIN:
        if ( idNotificationIn == CBN_EDITCHANGE )
        {
            THR( HrUpdateWizardButtons( FALSE ) );
            lr = TRUE;
        }
        else if ( idNotificationIn == CBN_SELCHANGE )
        {
            THR( HrUpdateWizardButtons( TRUE ) );
            lr = TRUE;
        }
        break;

    }

    RETURN( lr );

} //*** CCredLoginPage::OnCommand()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CCredLoginPage::HrUpdateWizardButtons(
//      BOOL fIgnoreComboxBoxIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCredLoginPage::HrUpdateWizardButtons(
    BOOL fIgnoreComboxBoxIn
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    DWORD   dwFlags = PSWIZB_BACK | PSWIZB_NEXT;
    DWORD   dwLen;

    dwLen = GetWindowTextLength( GetDlgItem( m_hwnd, IDC_CREDLOGIN_E_USERNAME ) );
    if ( dwLen == 0 )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }

    //
    //  Password could be blank so don't count on it!
    //

    if ( !fIgnoreComboxBoxIn )
    {
        LRESULT lr;

        dwLen = GetWindowTextLength( GetDlgItem( m_hwnd, IDC_CREDLOGIN_CB_DOMAIN ) );
        lr = ComboBox_GetCurSel( GetDlgItem( m_hwnd, IDC_CREDLOGIN_CB_DOMAIN ) );
        if ( lr == CB_ERR )
        {
            if ( dwLen == 0 )
            {
                dwFlags &= ~PSWIZB_NEXT;
            }
        }
        else if ( dwLen == 0 )
        {
            dwFlags &= ~PSWIZB_NEXT;
        }
    }

    PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );

    HRETURN( hr );

} //*** CCredLoginPage::HrUpdateWizardButtons()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCredLoginPage::OnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCredLoginPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    HRESULT hr;
    LPWSTR  pszDomain;

    LRESULT lr = TRUE;

    //  Reset this
    m_fIgnoreBackButton = FALSE;

    if ( m_pfShowCredentialsPage != NULL
      && !( *m_pfShowCredentialsPage )
       )
    {
        //  Don't need to show this page... skip it.
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
        goto Cleanup;
    }

    pszDomain = wcschr( *m_pbstrClusterName, L'.' );
    if ( pszDomain == NULL )
        goto Cleanup;

    pszDomain ++;   // move past the dot.

    //
    //  Update the UI
    //
    SetDlgItemText( m_hwnd, IDC_CREDLOGIN_E_USERNAME, L"" );
    SetDlgItemText( m_hwnd, IDC_CREDLOGIN_E_PASSWORD, L"" );
    SetDlgItemText( m_hwnd, IDC_CREDLOGIN_CB_DOMAIN, pszDomain == NULL ? L"" : pszDomain );

Cleanup:
    THR( HrUpdateWizardButtons( FALSE ) );

    RETURN( lr );

} //*** CCredLoginPage::OnNotifySetActive()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCredLoginPage::OnNotifyQueryCancel( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCredLoginPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CCredLoginPage::OnNotifyQueryCancel()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCredLoginPage::OnNotifyWizNext( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCredLoginPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    DWORD   dwLen;
    LPWSTR  pszDomain;

    CREDENTIAL credential;

    LRESULT lr = TRUE;
    BSTR    bstrWildcardDomain = NULL;
    BSTR    bstrUsername = NULL;
    BSTR    bstrPassword = NULL;
    BSTR    bstrDomain = NULL;
    BSTR    bstrDomainPlusUser = NULL;

    //
    //  Get the username.
    //

    dwLen = GetWindowTextLength( GetDlgItem( m_hwnd, IDC_CREDLOGIN_E_USERNAME ) );
    Assert( dwLen != 0 );
    dwLen ++;

    bstrUsername = TraceSysAllocStringLen( NULL, dwLen );
    if ( bstrUsername == NULL )
        goto OutOfMemory;

    GetDlgItemText( m_hwnd, IDC_CREDLOGIN_E_USERNAME, bstrUsername, dwLen );

    //
    //  Get the password.
    //

    dwLen = GetWindowTextLength( GetDlgItem( m_hwnd, IDC_CREDLOGIN_E_PASSWORD ) );
    Assert( dwLen != 0 );
    dwLen ++;

    bstrPassword = TraceSysAllocStringLen( NULL, dwLen );
    if ( bstrPassword == NULL )
        goto OutOfMemory;

    GetDlgItemText( m_hwnd, IDC_CREDLOGIN_E_PASSWORD, bstrPassword, dwLen );

    //
    //  Get the domain.
    //

    dwLen = GetWindowTextLength( GetDlgItem( m_hwnd, IDC_CREDLOGIN_CB_DOMAIN ) );
    Assert( dwLen != 0 );
    dwLen ++;

    bstrDomain = TraceSysAllocStringLen( NULL, dwLen );
    if ( bstrDomain == NULL )
        goto OutOfMemory;

    GetDlgItemText( m_hwnd, IDC_CREDLOGIN_CB_DOMAIN, bstrDomain, dwLen );

    //
    //  Build the wildcard string for the domain that the nodes live in.
    //

    pszDomain = wcschr( *m_pbstrClusterName, L'.' );

    //  Does the domain part have a "dot" in it?
    if ( pszDomain != NULL
      && wcschr( pszDomain + 1, L'.' ) != NULL
       )
    {   //  Yes, it does. Assume it is a DNS domain name.

        bstrWildcardDomain = TraceSysAllocStringLen( NULL, ( 2 + wcslen( pszDomain ) ) * sizeof(WCHAR) );
        if ( bstrWildcardDomain == NULL )
            goto OutOfMemory;

        wcscpy( bstrWildcardDomain, L"*" );
        wcscat( bstrWildcardDomain, pszDomain );

        //  The net result should be "*.domain.dom".
    }
    else
    {   //  No, it doesn't. Assume it is a NETBIOS domain name.

        bstrWildcardDomain = TraceSysAllocStringLen( NULL, 2 + wcslen( *m_pbstrClusterName ) + 1 );
        if ( bstrWildcardDomain == NULL )
            goto OutOfMemory;

        wcscpy( bstrWildcardDomain, *m_pbstrClusterName );
        wcscat( bstrWildcardDomain, L"\\*" );

        //  The net result should be "domain\*".
    }

    //
    //  Build the domain\user string.
    //

    bstrDomainPlusUser = TraceSysAllocStringLen( NULL, SysStringLen( bstrUsername ) + 1 + SysStringLen( bstrDomain ) + 1 );
    if ( bstrDomainPlusUser == NULL )
        goto OutOfMemory;

    if ( wcschr( bstrDomain, L'.' ) == NULL )
    {
        wcscpy( bstrDomainPlusUser, bstrDomain );
        wcscat( bstrDomainPlusUser, L"\\" );
        wcscat( bstrDomainPlusUser, bstrUsername );

        //  The net result is "domain\username".
    }
    else
    {
        wcscpy( bstrDomainPlusUser, bstrUsername );
        wcscat( bstrDomainPlusUser, L"@" );
        wcscat( bstrDomainPlusUser, bstrDomain );

        //  The net result is "username@domain.dom".
    }

    //
    //  Initialize the CREDENTIALs structure.
    //

    ZeroMemory( &credential, sizeof(credential) );

    //  credential.Flags = 0;
    credential.Type = CRED_TYPE_DOMAIN_PASSWORD;
    credential.TargetName = bstrWildcardDomain;
    //  credential.Comment = NULL;
    //  credential.LastWritten = { 0 };
    credential.CredentialBlobSize = wcslen( bstrPassword ) * sizeof(WCHAR);
    credential.CredentialBlob = (LPBYTE) bstrPassword;
    credential.Persist = CRED_PERSIST_SESSION;
    //  credential.AttributeCount = 0;
    //  credential.Attributes = NULL;
    //  credential.TargetAlias = NULL;
    credential.UserName = bstrDomainPlusUser;

    //
    //  Set the credentials.
    //

    if ( CredWrite( &credential, 0 ) == FALSE )
        goto CredWriteError;

    //
    //  Done. Fake the button push to go backwards to test the credentials.
    //
    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    m_fIgnoreBackButton = TRUE;
    PropSheet_PressButton( GetParent( m_hwnd ), PSBTN_BACK );

Cleanup:
    if ( bstrWildcardDomain != NULL )
    {
        TraceSysFreeString( bstrWildcardDomain );
    }
    if ( bstrDomainPlusUser != NULL )
    {
        TraceSysFreeString( bstrDomainPlusUser );
    }
    if ( bstrUsername != NULL )
    {
        TraceSysFreeString( bstrUsername );
    }
    if ( bstrPassword != NULL )
    {
        TraceSysFreeString( bstrPassword );
    }
    if ( bstrDomain != NULL )
    {
        TraceSysFreeString( bstrDomain );
    }

    RETURN( lr );

Error:
    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    goto Cleanup;

OutOfMemory:
    goto Error;

CredWriteError:
    HrMessageBoxWithStatus(
          m_hwnd
        , IDS_ERR_WRITE_CREDENTIAL_TITLE
        , IDS_ERR_WRITE_CREDENTIAL_TEXT
        , HRESULT_FROM_WIN32(GetLastError())
        , 0
        , MB_OK | MB_ICONERROR
        , 0
        );
    goto Error;

} //*** CCredLoginPage::OnNotifyWizNext()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCredLoginPage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCredLoginPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
    case PSN_SETACTIVE:
        lr = OnNotifySetActive();
        break;

    case PSN_WIZNEXT:
        lr = OnNotifyWizNext();
        break;

    case PSN_WIZBACK:
        if ( !m_fIgnoreBackButton )
        {
            *m_pfShowCredentialsPage = FALSE;
        }
        break;

    case PSN_QUERYCANCEL:
        lr = OnNotifyQueryCancel();
        break;
    }

    RETURN( lr );

} //*** CCredLoginPage::OnNotify()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT_PTR
//  CALLBACK
//  CCredLoginPage::S_DlgProc(
//      HWND hDlgIn,
//      UINT MsgIn,
//      WPARAM wParam,
//      LPARAM lParam
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CCredLoginPage::S_DlgProc(
    HWND hDlgIn,
    UINT MsgIn,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CCredLoginPage * pPage = reinterpret_cast< CCredLoginPage *> ( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CCredLoginPage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
        case WM_INITDIALOG:
            lr = pPage->OnInitDialog();
            break;

        case WM_NOTIFY:
            lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
            break;

        case WM_COMMAND:
            lr= pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), (HWND) lParam );
            break;

        // no default clause needed
        }
    }

    return lr;

} //*** CCredLoginPage::S_DlgProc()


// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCredLoginPage::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCredLoginPage::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskGetDomainsCallback * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskGetDomainsCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskGetDomainsCallback, this, 0 );
        hr = S_OK;
    } // else if: ITaskGetDomainsCallback

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CCredLoginPage::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CCredLoginPage::AddRef( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCredLoginPage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CCredLoginPage::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CCredLoginPage::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCredLoginPage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    // TraceDo( delete this );

    RETURN(0);

} //*** CCredLoginPage::Release()


//****************************************************************************
//
//  ITaskGetDomainsCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCredLoginPage::ReceiveDomainResult(
//      HRESULT hrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCredLoginPage::ReceiveDomainResult(
    HRESULT hrIn
    )
{
    TraceFunc( "[ITaskGetDomainsCallback]" );

    HRESULT hr;

    hr = THR( m_ptgd->SetCallback( NULL ) );

    HRETURN( hr );

} //*** CCredLoginPage::ReceiveResult()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCredLoginPage::ReceiveDomainName(
//      LPCWSTR pcszDomainIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCredLoginPage::ReceiveDomainName(
    LPCWSTR pcszDomainIn
    )
{
    TraceFunc( "[ITaskGetDomainsCallback]" );

    HRESULT hr = S_OK;

    ComboBox_AddString( GetDlgItem( m_hwnd, IDC_CREDLOGIN_CB_DOMAIN ), pcszDomainIn );

    HRETURN( hr );

} //*** CCredLoginPage::ReceiveName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\csaccountpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      CSAccountPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    22-MAR-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "CSAccountPage.h"

DEFINE_THISCLASS("CCSAccountPage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCSAccountPage::CCSAccountPage(
//      IServiceProvider *  pspIn,
//      ECreateAddMode      ecamCreateAddModeIn,
//      BSTR *              pbstrUsernameIn,
//      BSTR *              pbstrPasswordIn,
//      BSTR *              pbstrDomainIn,
//      BSTR *              pbstrClusterNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCSAccountPage::CCSAccountPage(
    IServiceProvider *  pspIn,
    ECreateAddMode      ecamCreateAddModeIn,
    BSTR *              pbstrUsernameIn,
    BSTR *              pbstrPasswordIn,
    BSTR *              pbstrDomainIn,
    BSTR *              pbstrClusterNameIn
    )
{
    TraceFunc( "" );

    //  m_hwnd
    THR( pspIn->TypeSafeQI( IServiceProvider, &m_psp ) );
    m_ecamCreateAddMode = ecamCreateAddModeIn;

    m_pbstrUsername    = pbstrUsernameIn;
    m_pbstrPassword    = pbstrPasswordIn;
    m_pbstrDomain      = pbstrDomainIn;
    m_pbstrClusterName = pbstrClusterNameIn;

    m_cRef = 0;
    m_ptgd = NULL;

    Assert( m_pbstrUsername != NULL );
    Assert( m_pbstrPassword != NULL );
    Assert( m_pbstrDomain != NULL );
    Assert( m_pbstrClusterName != NULL );

    TraceFuncExit();

} //*** CCSAccountPage::CCSAccountPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CCSAccountPage::~CCSAccountPage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CCSAccountPage::~CCSAccountPage( void )
{
    TraceFunc( "" );

    if ( m_psp != NULL )
    {
        m_psp->Release();
    }

    if ( m_ptgd != NULL )
    {
        //  Make sure we don't get called anymore.
        THR( m_ptgd->SetCallback( NULL ) );

        m_ptgd->Release();
    }

    Assert( m_cRef == 0 );

    TraceFuncExit();

} //*** CCSAccountPage::~CCSAccountPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCSAccountPage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCSAccountPage::OnInitDialog( void )
{
    TraceFunc( "" );

    BOOL    bRet;
    HRESULT hr;

    BSTR   bstrDomain = NULL;

    IUnknown *              punk = NULL;
    ITaskManager *          ptm  = NULL;

    LRESULT lr = FALSE;

    //
    // (jfranco, bug #377545) Limit user name length to MAX_USERNAME_LENGTH
    //
    // according to msdn, EM_(SET)LIMITTEXT does not return a value, so ignore what SendDlgItemMessage returns
    SendDlgItemMessage( m_hwnd, IDC_CSACCOUNT_E_USERNAME, EM_SETLIMITTEXT, MAX_USERNAME_LENGTH, 0 );

    //
    //  Create the task to get the domains.
    //
    hr = THR( m_psp->TypeSafeQS( CLSID_TaskManager,
                                 ITaskManager,
                                 &ptm
                                 ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( ptm->CreateTask( TASK_GetDomains, &punk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

//    TraceMoveFromMemoryList( punk, g_GlobalMemoryList );

    hr = THR( punk->TypeSafeQI( ITaskGetDomains, &m_ptgd ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( m_ptgd->SetCallback( static_cast< ITaskGetDomainsCallback * >( this ) ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( ptm->SubmitTask( m_ptgd ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Default to the script supplied information.
    //

    SetDlgItemText( m_hwnd, IDC_CSACCOUNT_E_USERNAME, *m_pbstrUsername );
    SetDlgItemText( m_hwnd, IDC_CSACCOUNT_E_PASSWORD, *m_pbstrPassword );
    SetDlgItemText( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN,  *m_pbstrDomain );

    //
    //  Get the domain of the current computer.
    //

    hr = THR( HrGetComputerName( ComputerNameDnsDomain, &bstrDomain ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    SetDlgItemText( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN, bstrDomain );

Cleanup:
    THR( HrUpdateWizardButtons( FALSE ) );

    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( ptm != NULL )
    {
        ptm->Release();
    }

    TraceSysFreeString( bstrDomain );

    RETURN( lr );

} //*** CCSAccountPage::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCSAccountPage::OnCommand(
//      UINT    idNotificationIn,
//      UINT    idControlIn,
//      HWND    hwndSenderIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCSAccountPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
    case IDC_CSACCOUNT_E_PASSWORD:
    case IDC_CSACCOUNT_E_USERNAME:
        if ( idNotificationIn == EN_CHANGE )
        {
            THR( HrUpdateWizardButtons( FALSE ) );
            lr = TRUE;
        }
        break;

    case IDC_CSACCOUNT_CB_DOMAIN:
        if ( idNotificationIn == CBN_EDITCHANGE )
        {
            THR( HrUpdateWizardButtons( FALSE ) );
            lr = TRUE;
        }
        else if ( idNotificationIn == CBN_SELCHANGE )
        {
            THR( HrUpdateWizardButtons( TRUE ) );
            lr = TRUE;
        }
        break;

    }

    RETURN( lr );

} //*** CCSAccountPage::OnCommand()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CCSAccountPage::HrUpdateWizardButtons(
//      BOOL fIgnoreComboxBoxIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CCSAccountPage::HrUpdateWizardButtons(
    BOOL fIgnoreComboxBoxIn
    )
{
    TraceFunc( "" );

    DWORD   dwLen;

    HRESULT hr = S_OK;
    DWORD   dwFlags = PSWIZB_BACK | PSWIZB_NEXT;

    dwLen = GetWindowTextLength( GetDlgItem( m_hwnd, IDC_CSACCOUNT_E_USERNAME ) );
    if ( dwLen == 0 )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }

    //
    //  It is valid to have a blank password. No need to check it.
    //

    if ( !fIgnoreComboxBoxIn )
    {
        LRESULT lr;

        dwLen = GetWindowTextLength( GetDlgItem( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN ) );
        lr = ComboBox_GetCurSel( GetDlgItem( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN ) );
        if ( lr == CB_ERR )
        {
            if ( dwLen == 0 )
            {
                dwFlags &= ~PSWIZB_NEXT;
            }
        }
        else if ( dwLen == 0 )
        {
            dwFlags &= ~PSWIZB_NEXT;
        }
    }

    PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );

    HRETURN( hr );

} //*** CCSAccountPage::HrUpdateWizardButtons()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCSAccountPage::OnNotifyQueryCancel( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCSAccountPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CCSAccountPage::OnNotifyQueryCancel()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCSAccountPage::OnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCSAccountPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    HRESULT hr;

    OBJECTCOOKIE    cookieDummy;

    LRESULT lr = TRUE;

    IUnknown *              punk  = NULL;
    IClusCfgClusterInfo *   pccci = NULL;
    IClusCfgCredentials *   piccc = NULL;
    IObjectManager *        pom   = NULL;

    BSTR    bstrUsername    = NULL;
    BSTR    bstrPassword    = NULL;
    BSTR    bstrDomain      = NULL;

    if ( m_ecamCreateAddMode == camADDING )
    {
        Assert( *m_pbstrClusterName != NULL );

        //
        //  See if the cluster configuration information has something
        //  different.
        //

        hr = THR( m_psp->TypeSafeQS( CLSID_ObjectManager,
                                     IObjectManager,
                                     &pom
                                     ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pom->FindObject( CLSID_ClusterConfigurationType,
                                   NULL,
                                   *m_pbstrClusterName,
                                   DFGUID_ClusterConfigurationInfo,
                                   &cookieDummy,
                                   &punk
                                   ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &pccci ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        hr = THR( piccc->GetCredentials( &bstrUsername,
                                         &bstrDomain,
                                         &bstrPassword
                                         ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        SetDlgItemText( m_hwnd, IDC_CSACCOUNT_E_USERNAME, bstrUsername );
        SetDlgItemText( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN,  bstrDomain );

        //
        // Only update the password if we actually received something from GetCredentials().
        // When we first enter this page, this will not be the case and we would nuke the
        // scripted password.
        //
        if ( ( bstrPassword != NULL )
          && ( *bstrPassword != L'\0' ) )
            SetDlgItemText( m_hwnd, IDC_CSACCOUNT_E_PASSWORD, bstrPassword );

        //
        //  Disable the username and domain windows.
        //

        EnableWindow( GetDlgItem( m_hwnd, IDC_CSACCOUNT_E_USERNAME ), FALSE );
        EnableWindow( GetDlgItem( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN ), FALSE );
    }

Cleanup:
    THR( HrUpdateWizardButtons( FALSE ) );

    if ( punk != NULL )
    {
        punk->Release();
    }

    if ( pom != NULL )
    {
        pom->Release();
    }

    if ( piccc != NULL )
    {
        piccc->Release();
    }

    if ( pccci != NULL )
    {
        pccci->Release();
    }

    TraceSysFreeString( bstrUsername );
    TraceSysFreeString( bstrPassword );
    TraceSysFreeString( bstrDomain );

    RETURN( lr );

} //*** CCSAccountPage::OnNotifySetActive()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCSAccountPage::OnNotifyWizNext( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCSAccountPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    HRESULT hr;
    HWND    hwnd;
    DWORD   dwLen;

    BSTR    bstrUsername = NULL;
    BSTR    bstrPassword = NULL;
    BSTR    bstrDomain = NULL;

    OBJECTCOOKIE    cookieDummy;

    LRESULT lr = TRUE;

    IUnknown *              punk = NULL;
    IObjectManager *        pom = NULL;
    IClusCfgClusterInfo *   pccci = NULL;
    IClusCfgCredentials *   piccc = NULL;

    //
    //  Get the username from the UI.
    //

    hwnd = GetDlgItem( m_hwnd, IDC_CSACCOUNT_E_USERNAME );
    Assert( hwnd != NULL );

    dwLen = GetWindowTextLength( hwnd );
    Assert( dwLen != 0 );
    dwLen ++;

    bstrUsername = TraceSysAllocStringByteLen( NULL, sizeof(WCHAR) * ( dwLen + 1 ) );
    if ( bstrUsername == NULL )
        goto OutOfMemory;

    GetWindowText( hwnd, bstrUsername, dwLen  );

    //
    //  Get the password from the UI.
    //

    hwnd = GetDlgItem( m_hwnd, IDC_CSACCOUNT_E_PASSWORD );
    Assert( hwnd != NULL );

    dwLen = GetWindowTextLength( hwnd );
    dwLen ++;

    bstrPassword = TraceSysAllocStringByteLen( NULL, sizeof(WCHAR) * ( dwLen + 1 ) );
    if ( bstrPassword == NULL )
        goto OutOfMemory;

    GetWindowText( hwnd, bstrPassword, dwLen  );

    //
    //  Get the domain from the UI.
    //

    hwnd = GetDlgItem( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN );
    Assert( hwnd != NULL );

    dwLen = GetWindowTextLength( hwnd );
    Assert( dwLen != 0 );
    dwLen ++;

    bstrDomain = TraceSysAllocStringByteLen( NULL, sizeof(WCHAR) * ( dwLen + 1 ) );
    if ( bstrDomain == NULL )
        goto OutOfMemory;

    GetWindowText( hwnd, bstrDomain, dwLen  );

    //
    //  Release the old strings (if any).
    //

    TraceSysFreeString( *m_pbstrUsername );
    TraceSysFreeString( *m_pbstrPassword );
    TraceSysFreeString( *m_pbstrDomain );

    //
    //  Give ownership away.
    //

    *m_pbstrUsername = bstrUsername;
    *m_pbstrPassword = bstrPassword;
    *m_pbstrDomain   = bstrDomain;

    bstrUsername = NULL;
    bstrPassword = NULL;
    bstrDomain   = NULL;

    //
    //  Grab the object manager.
    //

    hr = THR( m_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Get the cluster configuration info.
    //

    hr = THR( pom->FindObject( CLSID_ClusterConfigurationType,
                               NULL,
                               *m_pbstrClusterName,
                               DFGUID_ClusterConfigurationInfo,
                               &cookieDummy,
                               &punk
                               ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &pccci ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Set the cluster service account credentials...
    //

    hr = THR( pccci->GetClusterServiceAccountCredentials( &piccc ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( piccc->SetCredentials( *m_pbstrUsername, *m_pbstrDomain, *m_pbstrPassword ) );
    if ( FAILED( hr ) )
        goto Error;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }

    TraceSysFreeString( bstrUsername );
    TraceSysFreeString( bstrPassword );
    TraceSysFreeString( bstrDomain );

    if ( piccc != NULL )
    {
        piccc->Release();
    }

    if ( pccci != NULL )
    {
        pccci->Release();
    }

    if ( pom != NULL )
    {
        pom->Release();
    }

    RETURN( lr );

Error:
    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    goto Cleanup;

OutOfMemory:
    goto Error;

} //*** CCSAccountPage::OnNotifyWizNext()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CCSAccountPage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CCSAccountPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
    case PSN_SETACTIVE:
        lr = OnNotifySetActive();
        break;

    case PSN_WIZNEXT:
        lr = OnNotifyWizNext();
        break;

    case PSN_QUERYCANCEL:
        lr = OnNotifyQueryCancel();
        break;
    }

    RETURN( lr );

} //*** CCSAccountPage::OnNotify()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT_PTR
//  CALLBACK
//  CCSAccountPage::S_DlgProc(
//      HWND hDlgIn,
//      UINT MsgIn,
//      WPARAM wParam,
//      LPARAM lParam
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CCSAccountPage::S_DlgProc(
    HWND hDlgIn,
    UINT MsgIn,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CCSAccountPage * pPage = reinterpret_cast< CCSAccountPage *> ( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CCSAccountPage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
        case WM_INITDIALOG:
            lr = pPage->OnInitDialog();
            break;

        case WM_NOTIFY:
            lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
            break;

        case WM_COMMAND:
            lr= pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), (HWND) lParam );
            break;

        // no default clause needed
        }
    }

    return lr;

} //*** CCSAccountPage::S_DlgProc()



// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCSAccountPage::QueryInterface(
//      REFIID      riidIn,
//      LPVOID *    ppvOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCSAccountPage::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< ITaskGetDomainsCallback * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_ITaskGetDomainsCallback ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, ITaskGetDomainsCallback, this, 0 );
        hr = S_OK;
    } // else if: ITaskGetDomainsCallback

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CCSAccountPage::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CCSAccountPage::AddRef( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCSAccountPage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CCSAccountPage::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP_( ULONG )
//  CCSAccountPage::Release( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CCSAccountPage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    // TraceDo( delete this );

    RETURN(0);

} //*** CCSAccountPage::Release()


//****************************************************************************
//
//  ITaskGetDomainsCallback
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCSAccountPage::ReceiveDomainResult(
//      HRESULT hrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCSAccountPage::ReceiveDomainResult(
    HRESULT hrIn
    )
{
    TraceFunc( "[ITaskGetDomainsCallback]" );

    HRESULT hr;

    hr = THR( m_ptgd->SetCallback( NULL ) );

    HRETURN( hr );

} //*** CCSAccountPage::ReceiveResult()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  STDMETHODIMP
//  CCSAccountPage::ReceiveDomainName(
//      LPCWSTR pcszDomainIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CCSAccountPage::ReceiveDomainName(
    LPCWSTR pcszDomainIn
    )
{
    TraceFunc( "[ITaskGetDomainsCallback]" );

    HRESULT hr = S_OK;

    ComboBox_AddString( GetDlgItem( m_hwnd, IDC_CSACCOUNT_CB_DOMAIN ), pcszDomainIn );

    HRETURN( hr );

} //*** CCSAccountPage::ReceiveName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\detailsdlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      DetailsDlg.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    27-MAR-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskTreeView.h"
#include "DetailsDlg.h"
#include "WizardUtils.h"

DEFINE_THISCLASS("DetailsDlg");

//////////////////////////////////////////////////////////////////////////////
//  Static Function Prototypes
//////////////////////////////////////////////////////////////////////////////

static
BOOL
ButtonFaceColorIsDark( void );

static
void
SetButtonImage(
      HWND  hwndBtnIn
    , ULONG idIconIn
    );

static
void
FreeButtonImage(
    HWND hwndBtnIn
    );

static
HRESULT
HrAppendStringToClipboardString(
      BSTR *    pbstrClipboard
    , UINT      idsLabelIn
    , LPCWSTR   pszDataIn
    , bool      fNewlineBeforeTextIn
    );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::S_HrDisplayModalDialog
//
//  Description:
//      Display the dialog box.
//
//  Arguments:
//      hwndParentIn    - Parent window for the dialog box.
//      pttvIn          - Task tree view control.
//      htiSelectedIn   - Handle to the selected item.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CDetailsDlg::S_HrDisplayModalDialog(
      HWND              hwndParentIn
    , CTaskTreeView *   pttvIn
    , HTREEITEM         htiSelectedIn
    )
{
    TraceFunc( "" );

    Assert( pttvIn != NULL );
    Assert( htiSelectedIn != NULL );

    HRESULT         hr      = S_OK;
    CDetailsDlg     dlg( pttvIn, htiSelectedIn );

    DialogBoxParam(
          g_hInstance
        , MAKEINTRESOURCE( IDD_DETAILS )
        , hwndParentIn
        , CDetailsDlg::S_DlgProc
        , (LPARAM) &dlg
        );

    HRETURN( hr );

} //*** CDetailsDlg::S_HrDisplayModalDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::CDetailsDlg
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pttvIn          - Tree view to traverse.
//      htiSelectedIn   - Handle to the selected item in the tree control.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CDetailsDlg::CDetailsDlg(
      CTaskTreeView *   pttvIn
    , HTREEITEM         htiSelectedIn
    )
{
    TraceFunc( "" );

    Assert( pttvIn != NULL );
    Assert( htiSelectedIn != NULL );

    // m_hwnd
    m_hiconWarn     = NULL;
    m_hiconError    = NULL;
    m_pttv          = pttvIn;
    m_htiSelected   = htiSelectedIn;

    m_fControlDown  = FALSE;
    m_fAltDown      = FALSE;

    TraceFuncExit();

} //*** CDetailsDlg::CDetailsDlg()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::~CDetailsDlg
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CDetailsDlg::~CDetailsDlg( void )
{
    TraceFunc( "" );

    if ( m_hiconWarn != NULL )
    {
        DeleteObject( m_hiconWarn );
    }

    if ( m_hiconError != NULL )
    {
        DeleteObject( m_hiconError );
    }

    TraceFuncExit();

} //*** CDetailsDlg::~CDetailsDlg()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::S_DlgProc
//
//  Description:
//      Dialog proc for the Details dialog box.
//
//  Arguments:
//      hwndDlgIn   - Dialog box window handle.
//      nMsgIn      - Message ID.
//      wParam      - Message-specific parameter.
//      lParam      - Message-specific parameter.
//
//  Return Values:
//      TRUE        - Message was processed by this procedure.
//      FALSE       - Message was NOT processed by this procedure.
//
//  Remarks:
//      It is expected that this dialog box is invoked by a call to
//      DialogBoxParam() with the lParam argument set to the address of the
//      instance of this class.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CDetailsDlg::S_DlgProc(
      HWND      hwndDlgIn
    , UINT      nMsgIn
    , WPARAM    wParam
    , LPARAM    lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT         lr = FALSE;
    HACCEL          haccel  = NULL;
    CDetailsDlg *   pdlg;

    //
    // Get a pointer to the class.
    //

    if ( nMsgIn == WM_INITDIALOG )
    {
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, lParam );
        pdlg = reinterpret_cast< CDetailsDlg * >( lParam );
        pdlg->m_hwnd = hwndDlgIn;
    }
    else
    {
        pdlg = reinterpret_cast< CDetailsDlg * >( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );
    }

    if ( pdlg != NULL )
    {
        Assert( hwndDlgIn == pdlg->m_hwnd );

        switch( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pdlg->OnInitDialog();
                break;

            case WM_DESTROY:
                pdlg->OnDestroy();
                break;

            case WM_SYSCOLORCHANGE:
                pdlg->OnSysColorChange();
                break;

            case WM_NOTIFY:
                lr = pdlg->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr = pdlg->OnCommand( HIWORD( wParam ), LOWORD( wParam ), reinterpret_cast< HWND >( lParam ) );
                break;

            case WM_KEYDOWN:
                lr = pdlg->OnKeyDown( lParam );
                break;

            case WM_KEYUP:
                lr = pdlg->OnKeyUp( lParam );
                break;

            default:
                lr = FALSE;
        } // switch: nMsgIn
    } // if: page is specified

    return lr;

} //*** CDetailsDlg::S_DlgProc()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnInitDialog
//
//  Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        Focus has been set.
//      FALSE       Focus has not been set.
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE; // did set focus
    HWND    hwnd;

    //
    // Tell the rich edit controls we want to receive notifications of clicks
    // on text that has the link (hyperlink, aka URL) format.   Also, set the
    // background color of the rich edit to match the background color of
    // the dialog.
    //

    hwnd = GetDlgItem( m_hwnd, IDC_DETAILS_RE_DESCRIPTION );

    SendMessage( hwnd, EM_SETEVENTMASK, 0, ENM_LINK );
    SendMessage( hwnd, EM_SETBKGNDCOLOR, 0, GetSysColor( COLOR_BTNFACE ) );
    SendMessage( hwnd, EM_AUTOURLDETECT, TRUE, 0 );

    hwnd = GetDlgItem( m_hwnd, IDC_DETAILS_RE_STATUS );

    SendMessage( hwnd, EM_SETEVENTMASK, 0, ENM_LINK );
    SendMessage( hwnd, EM_SETBKGNDCOLOR, 0, GetSysColor( COLOR_BTNFACE ) );
    SendMessage( hwnd, EM_AUTOURLDETECT, TRUE, 0 );

    hwnd = GetDlgItem( m_hwnd, IDC_DETAILS_RE_REFERENCE );

    SendMessage( hwnd, EM_SETEVENTMASK, 0, ENM_LINK );
    SendMessage( hwnd, EM_SETBKGNDCOLOR, 0, GetSysColor( COLOR_BTNFACE ) );
    SendMessage( hwnd, EM_AUTOURLDETECT, TRUE, 0 );

    //
    // Set the icons for the icon pushbuttons
    //

    OnSysColorChange();
    SetButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_COPY ), IDI_COPY );

    //
    // Load the status icons.
    //

    m_hiconWarn = (HICON) LoadImage(
                              g_hInstance
                            , MAKEINTRESOURCE( IDI_WARN )
                            , IMAGE_ICON
                            , 16
                            , 16
                            , LR_SHARED
                             );
    Assert( m_hiconWarn != NULL );
    m_hiconError = (HICON) LoadImage(
                              g_hInstance
                            , MAKEINTRESOURCE( IDI_FAIL )
                            , IMAGE_ICON
                            , 16
                            , 16
                            , LR_SHARED
                             );
    Assert( m_hiconError != NULL );

    //
    // Display the selected item.
    //

    THR( HrDisplayItem( m_htiSelected ) );

    //
    // Update the buttons based on what is selected.
    //

    UpdateButtons();

    //
    // Set focus to the OK button.
    //

    SetFocus( GetDlgItem( m_hwnd, IDOK ) );

    RETURN( lr );

} //*** CDetailsDlg::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnDestroy
//
//  Description:
//      Handler for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CDetailsDlg::OnDestroy( void )
{
    TraceFunc( "" );

    //
    // Destroy the images loaded for the icon pushbuttons
    //

    FreeButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_PREV ) );
    FreeButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_NEXT ) );
    FreeButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_COPY ) );

} //*** CDetailsDlg::OnDestroy()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnSysColorChange
//
//  Description:
//      Handler for the WM_SYSCOLORCHANGE message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CDetailsDlg::OnSysColorChange( void )
{
    TraceFunc( "" );

    if ( ButtonFaceColorIsDark() )
    {
        SetButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_PREV ), IDI_PREVIOUS_HC );
        SetButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_NEXT ), IDI_NEXT_HC );
    }
    else
    {
        SetButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_PREV ), IDI_PREVIOUS );
        SetButtonImage( GetDlgItem( m_hwnd, IDC_DETAILS_PB_NEXT ), IDI_NEXT );
    }

    SendDlgItemMessage(
          m_hwnd
        , IDC_DETAILS_RE_DESCRIPTION
        , EM_SETBKGNDCOLOR
        , 0
        , GetSysColor( COLOR_BTNFACE )
        );

    TraceFuncExit();

} //*** CDetailsDlg::OnSysColorChange()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnKeyDown
//
//  Description:
//      Handler for the WM_KEYDOWN message.
//
//  Arguments:
//      lParamIn    - Parameter containing information about the key.
//
//  Return Values:
//      TRUE        - Message was processed.
//      FALSE       - Message was not processed.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnKeyDown(
    LPARAM  lParamIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    union
    {
        LPARAM  lParam;
        struct
        {
            BYTE        cRepeat;
            BYTE        nScanCode;
            unsigned    fExtendedKey    : 1;
            unsigned    reserved        : 4;
            unsigned    fIsAltKeyDown   : 1;    // always 0 for WM_KEYDOWN
            unsigned    fKeyDownBefore  : 1;
            unsigned    fKeyReleased    : 1;    // always 0 for WM_KEYDOWN
        };
    } uFlags;

    uFlags.lParam = lParamIn;

    switch ( uFlags.nScanCode )
    {
        case VK_CONTROL:
            m_fControlDown = TRUE;
            lr = TRUE;
            break;

        case VK_MENU:   // ALT
            m_fAltDown = TRUE;
            lr = TRUE;
            break;

        case 'c':
        case 'C':
            if ( m_fControlDown )
            {
                OnCommandBnClickedCopy();
                lr = TRUE;
            }
            break;
    } // switch: scan code

    RETURN( lr );

} //*** CDetailsDlg::OnKeyDown()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnKeyUp
//
//  Description:
//      Handler for the WM_KEYUP message.
//
//  Arguments:
//      lParamIn    - Parameter containing information about the key.
//
//  Return Values:
//      TRUE        - Message was processed.
//      FALSE       - Message was not processed.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnKeyUp(
    LPARAM  lParamIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    union
    {
        LPARAM  lParam;
        struct
        {
            BYTE        cRepeat;
            BYTE        nScanCode;
            unsigned    fExtendedKey    : 1;
            unsigned    reserved        : 4;
            unsigned    fIsAltKeyDown   : 1;    // always 0 for WM_KEYDOWN
            unsigned    fKeyDownBefore  : 1;
            unsigned    fKeyReleased    : 1;    // always 0 for WM_KEYDOWN
        };
    } uFlags;

    uFlags.lParam = lParamIn;

    switch ( uFlags.nScanCode )
    {
        case VK_CONTROL:
            m_fControlDown = FALSE;
            lr = TRUE;
            break;

        case VK_MENU:   // ALT
            m_fAltDown = FALSE;
            lr = TRUE;
            break;
    } // switch: scan code

    RETURN( lr );

} //*** CDetailsDlg::OnKeyUp()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnCommand
//
//  Description:
//      Handler for the WM_COMMAND message.
//
//  Arguments:
//      idNotificationIn    - Notification code.
//      idControlIn         - Control ID.
//      hwndSenderIn        - Handle for the window that sent the message.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnCommand(
      UINT  idNotificationIn
    , UINT  idControlIn
    , HWND  hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_DETAILS_PB_PREV:
            if ( idNotificationIn == BN_CLICKED )
            {
                lr = OnCommandBnClickedPrev();
            }
            break;

        case IDC_DETAILS_PB_NEXT:
            if ( idNotificationIn == BN_CLICKED )
            {
                lr = OnCommandBnClickedNext();
            }
            break;

        case IDC_DETAILS_PB_COPY:
            if ( idNotificationIn == BN_CLICKED )
            {
                lr = OnCommandBnClickedCopy();
            }
            break;

        case IDCANCEL:
            EndDialog( m_hwnd, IDCANCEL );
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CDetailsDlg::OnCommand()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnCommandBnClickedPrev
//
//  Description:
//      Handler for the BN_CLICKED notification on the Prev button.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnCommandBnClickedPrev( void )
{
    TraceFunc( "" );

    LRESULT     lr = FALSE;
    HRESULT     hr;
    HTREEITEM   htiPrev;

    //
    // Find the previous item.
    //

    hr = STHR( m_pttv->HrFindPrevItem( &htiPrev ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Select that item.
    //

    hr = THR( m_pttv->HrSelectItem( htiPrev ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Display the newly selected item.
    //

    if ( htiPrev != NULL )
    {
        hr = THR( HrDisplayItem( htiPrev ) );
    }

    //
    // Update the buttons based on our new position.
    //

    UpdateButtons();

    lr = TRUE;

Cleanup:
    RETURN( lr );

} //*** CDetailsDlg::OnCommandBnClickedPrev()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnCommandBnClickedNext
//
//  Description:
//      Handler for the BN_CLICKED notification on the Next button.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnCommandBnClickedNext( void )
{
    TraceFunc( "" );

    LRESULT     lr = FALSE;
    HRESULT     hr;
    HTREEITEM   htiNext;

    //
    // Find the next item.
    //

    hr = STHR( m_pttv->HrFindNextItem( &htiNext ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Select that item.
    //

    hr = THR( m_pttv->HrSelectItem( htiNext ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Display the newly selected item.
    //

    if ( htiNext != NULL )
    {
        hr = THR( HrDisplayItem( htiNext ) );
    }

    //
    // Update the buttons based on our new position.
    //

    UpdateButtons();

    lr = TRUE;

Cleanup:
    RETURN( lr );

} //*** CDetailsDlg::OnCommandBnClickedNext()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnCommandBnClickedCopy
//
//  Description:
//      Handler for the BN_CLICKED notification on the Copy button.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnCommandBnClickedCopy( void )
{
    TraceFunc( "" );

    LRESULT     lr = FALSE;
    HRESULT     hr;
    DWORD       sc;
    BSTR        bstrClipboard = NULL;
    HGLOBAL     hgbl = NULL;
    LPWSTR      pszGlobal = NULL;
    BOOL        fOpenedClipboard;

    //
    // Open the clipboard.
    //

    fOpenedClipboard = OpenClipboard( m_hwnd );

    if ( ! fOpenedClipboard )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        TraceFlow2( "Can't open clipboard (error = %#08x), currently owned by %#x", sc, GetClipboardOwner() );
        goto Cleanup;
    }

    if ( ! EmptyClipboard() )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    }

    //
    // Construct the text to put on the clipboard.
    //

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_DATE
                    , IDC_DETAILS_E_DATE
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_TIME
                    , IDC_DETAILS_E_TIME
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_COMPUTER
                    , IDC_DETAILS_E_COMPUTER
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_MAJOR
                    , IDC_DETAILS_E_MAJOR_ID
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_MINOR
                    , IDC_DETAILS_E_MINOR_ID
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_DESC
                    , IDC_DETAILS_RE_DESCRIPTION
                    , true      // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_STATUS
                    , IDC_DETAILS_E_STATUS
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , 0
                    , IDC_DETAILS_RE_STATUS
                    , false     // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrAppendControlStringToClipboardString(
                      &bstrClipboard
                    , IDS_DETAILS_CLP_INFO
                    , IDC_DETAILS_RE_REFERENCE
                    , true      // fNewlineBeforeTextIn
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Set the string onto the clipboard.
    //

    {
        //
        // Allocate a global buffer for the string, since
        // clipboard needs this as HGLOBAL.
        //

        hgbl = GlobalAlloc(
                      GMEM_MOVEABLE | GMEM_DDESHARE
                    , ( wcslen( bstrClipboard ) + 1) * sizeof( *bstrClipboard )
                    );
        if ( hgbl == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pszGlobal = (LPWSTR) GlobalLock( hgbl );
        if ( pszGlobal == NULL )
        {
            sc = TW32( GetLastError() );
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        }

        wcscpy( pszGlobal, bstrClipboard );

        //
        // Put it on the clipboard.
        //

        if ( SetClipboardData( CF_UNICODETEXT, hgbl ) )
        {
            // System owns it now.
            pszGlobal = NULL;
            hgbl = NULL;
        }
    } // Set the string onto the clipboard

Cleanup:
    TraceSysFreeString( bstrClipboard );

    if ( pszGlobal != NULL )
    {
        GlobalUnlock( hgbl );
    }
    GlobalFree( hgbl );

    if ( fOpenedClipboard )
    {
        CloseClipboard();
    }

    RETURN( lr );

} //*** CDetailsDlg::OnCommandBnClickedCopy()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::HrAppendControlStringToClipboardString
//
//  Description:
//      Append a string from a control on the dialog box to the clipboard string.
//
//  Arguments:
//      pbstrClipboardInout - Clipboard string.
//      idsLabelIn          - ID for the label string resource.
//      idcDataIn           - ID for the control to read the text from.
//      fNewlineBeforeTextIn- TRUE if a newline should be added before the data.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CDetailsDlg::HrAppendControlStringToClipboardString(
      BSTR *    pbstrClipboard
    , UINT      idsLabelIn
    , UINT      idcDataIn
    , bool      fNewlineBeforeTextIn
    )
{
    TraceFunc( "" );

    HRESULT hr          = S_OK;
    LPWSTR  pszData     = NULL;
    HWND    hwndControl = GetDlgItem( m_hwnd, idcDataIn );
    int     cch;

    //
    // Get the string from the control.
    //

    cch = GetWindowTextLength( hwndControl );

    pszData = new WCHAR[ cch + 1 ];
    if ( pszData == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    GetWindowText( hwndControl, pszData, cch + 1 );

    //
    // Append the string to the clipboard string.
    //

    hr = THR( HrAppendStringToClipboardString( pbstrClipboard, idsLabelIn, pszData, fNewlineBeforeTextIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    delete [] pszData;

    HRETURN( hr );

} //*** HrAppendControlStringToClipboardString()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrAppendStringToClipboardString
//
//  Description:
//      Append a label and data string to the clipboard string.
//
//  Arguments:
//      pbstrClipboardInout - Clipboard string.
//      idsLabelIn          - ID for the label string resource.
//      pszDataIn           - Data string.
//      fNewlineBeforeTextIn- TRUE if a newline should be added before the data.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrAppendStringToClipboardString(
      BSTR *    pbstrClipboard
    , UINT      idsLabelIn
    , LPCWSTR   pszDataIn
    , bool      fNewlineBeforeTextIn
    )
{
    TraceFunc( "" );

    HRESULT     hr          = S_OK;
    BSTR        bstrLabel   = NULL;
    BSTR        bstr        = NULL;
    LPCWSTR     pszLabel;
    LPCWSTR     pszFmt;

    static const WCHAR  s_szBlank[]         = L"";
    static const WCHAR  s_szNoNewlineFmt[]  = L"%1!ws!%2!ws!\n";
    static const WCHAR  s_szNewlineFmt[]    = L"%1!ws!\n%2!ws!\n";

    //
    // Load the label string.
    //

    if ( idsLabelIn == 0 )
    {
        pszLabel = s_szBlank;
    }
    else
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsLabelIn, &bstrLabel ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        pszLabel = bstrLabel;
    }

    //
    // Get the right format string.
    //

    if ( fNewlineBeforeTextIn )
    {
        pszFmt = s_szNewlineFmt;
    }
    else
    {
        pszFmt = s_szNoNewlineFmt;
    }

    //
    // Get the string from the dialog.
    //
    //
    // Format the new label + string.
    //

    hr = THR( HrFormatStringIntoBSTR( pszFmt, &bstr, pszLabel, pszDataIn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Concatenate the resulting string onto the end of the clipboard string.
    //

    hr = THR( HrConcatenateBSTRs( pbstrClipboard, bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    TraceSysFreeString( bstrLabel );
    TraceSysFreeString( bstr );

    HRETURN( hr );

} //*** HrAppendStringToClipboardString()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnNotify
//
//  Description:
//      Handle the WM_NOTIFY message.
//
//  Arguments:
//      idCtrlIn    - Control ID.
//      pnmhdrIn    - Notification structure.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnNotify(
      WPARAM    idCtrlIn
    , LPNMHDR   pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch( pnmhdrIn->code )
    {
        case EN_LINK:
            lr = OnNotifyEnLink( idCtrlIn, pnmhdrIn );
            break;
    } // switch: notify code

    RETURN( lr );

} //*** CDetailsDlg::OnNotify()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::OnNotifyEnLink
//
//  Description:
//      Handle the WM_NOTIFY message.
//
//  Arguments:
//      idCtrlIn    - Control ID.
//      pnmhdrIn    - Notification structure.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CDetailsDlg::OnNotifyEnLink(
      WPARAM    idCtrlIn
    , LPNMHDR   pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT     lr = FALSE;
    ENLINK *    penl = (ENLINK *) pnmhdrIn;

    switch( idCtrlIn )
    {
        case IDC_DETAILS_RE_DESCRIPTION:
        case IDC_DETAILS_RE_STATUS:
        case IDC_DETAILS_RE_REFERENCE:
            if ( penl->msg == WM_LBUTTONDOWN )
            {
                //
                // Rich edit notification user has left clicked on link
                //

                m_chrgEnLinkClick = penl->chrg;
            } // if: left button down
            else if ( penl->msg == WM_LBUTTONUP )
            {
                if (    ( penl->chrg.cpMax == m_chrgEnLinkClick.cpMax )
                    &&  ( penl->chrg.cpMin == m_chrgEnLinkClick.cpMin )
                    )
                {
                    ZeroMemory( &m_chrgEnLinkClick, sizeof m_chrgEnLinkClick );
                    HandleLinkClick( penl, idCtrlIn );
                }
            } // else if: left button up
            break;
    } // switch: notify code

    RETURN( lr );

} //*** CDetailsDlg::OnNotifyEnLink()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::HandleLinkClick
//
//  Description:
//      Handle notification that the user has clicked on text in a richedit
//      control that is marked with the hyperlink attribute.
//
//  Arguments:
//      penlIn      - Contains information about link clicked.
//      idCtrlIn    - Control in which user clicked.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CDetailsDlg::HandleLinkClick(
      ENLINK *  penlIn
    , WPARAM    idCtrlIn
    )
{
    TraceFunc( "" );

    Assert( penlIn->chrg.cpMax > penlIn->chrg.cpMin );

    PWSTR       pszLink = NULL;
    ULONG       cch;
    TEXTRANGE   tr;
    DWORD       sc;

    //
    // Get the text of the link.
    //

    cch = penlIn->chrg.cpMax - penlIn->chrg.cpMin + 1;

    pszLink = new WCHAR[ cch ];
    if ( pszLink == NULL )
    {
        goto Cleanup;
    }

    pszLink[ 0 ] = '\0';

    ZeroMemory( &tr, sizeof( tr ) );
    tr.chrg = penlIn->chrg;
    tr.lpstrText = pszLink;

    cch = (ULONG) SendDlgItemMessage(
                      m_hwnd
                    , (int) idCtrlIn
                    , EM_GETTEXTRANGE
                    , 0
                    , (LPARAM) &tr
                    );
    Assert( cch > 0 );

    //
    // Pass the URL straight through to ShellExecute.
    //
    // Note that ShellExecute returns an HINSTANCE for historical reasons,
    // but actually only returns integers.  Any value greater than 32
    // indicates success.
    //

    TraceFlow1( "Calling ShellExecute on %hs", pszLink );
    sc = HandleToULong( ShellExecute( NULL, NULL, pszLink, NULL, NULL, SW_NORMAL ) );
    if ( sc <= 32 )
    {
        TW32( sc );
        THR( HrMessageBoxWithStatus(
                          m_hwnd
                        , IDS_ERR_INVOKING_LINK_TITLE
                        , IDS_ERR_INVOKING_LINK_TEXT
                        , sc
                        , 0         // idsSubStatusIn
                        , ( MB_OK
                          | MB_ICONEXCLAMATION )
                        , NULL      // pidReturnOut
                        , pszLink
                        ) );
    } // if: error from ShellExecute

Cleanup:
    delete [] pszLink;

} //*** CDetailsDlg::HandleLinkClick()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::UpdateButtons
//
//  Description:
//      Update the buttons based on whether there is a previous or next
//      item or not.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CDetailsDlg::UpdateButtons( void )
{
    TraceFunc( "" );

    Assert( m_pttv != NULL );

    HTREEITEM   hti = NULL;
    HRESULT     hr;
    BOOL        fEnablePrev;
    BOOL        fEnableNext;

    STHR( m_pttv->HrFindPrevItem( &hti ) );
    // ignore error
    fEnablePrev = ( hti != NULL );

    STHR( m_pttv->HrFindNextItem( &hti ) );
    // ignore error
    fEnableNext = ( hti != NULL );

    EnableWindow( GetDlgItem( m_hwnd, IDC_DETAILS_PB_PREV ), fEnablePrev );
    EnableWindow( GetDlgItem( m_hwnd, IDC_DETAILS_PB_NEXT ), fEnableNext );

} //*** CDetailsDlg::UpdateButtons()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::HrDisplayItem
//
//  Description:
//      Display an item in the details dialog.
//
//  Arguments:
//      htiIn   - Handle to the item to display.
//
//  Return Values:
//      S_OK    - Operation completed successfully.
//      S_FALSE - Item not displayed.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CDetailsDlg::HrDisplayItem(
    HTREEITEM   htiIn
    )
{
    TraceFunc( "" );

    Assert( htiIn != NULL );

    HRESULT                 hr = S_FALSE;
    DWORD                   sc = ERROR_SUCCESS;
    BOOL                    fRet;
    BOOL                    fDisplayIcon;
    STreeItemLParamData *   ptipd;
    BSTR                    bstr = NULL;
    BSTR                    bstrAdditionalInfo = NULL;
    WCHAR                   wszText[ 64 ];
    FILETIME                filetime;
    SYSTEMTIME              systemtime;
    int                     cch;
    HICON                   hicon;

    //
    // Get information about the selected item to see if it has details.
    //

    fRet = m_pttv->FGetItem( htiIn, &ptipd );
    if ( ! fRet )
    {
        goto Cleanup;
    }

    //
    // Set the date and time information from the structure into
    // the dialog box.
    //

    if (    ( ptipd->ftTime.dwHighDateTime == 0 )
        &&  ( ptipd->ftTime.dwLowDateTime == 0 )
        )
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_DATE, L"" );
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_TIME, L"" );
    } // if: no date time specified
    else
    {
        //
        // Convert the date time to local time, then to something we can
        // use to display it.
        //

        if ( ! FileTimeToLocalFileTime( &ptipd->ftTime, &filetime ) )
        {
            sc = TW32( GetLastError() );
        }
        else if ( ! FileTimeToSystemTime( &filetime, &systemtime ) )
        {
            sc = TW32( GetLastError() );
        }
        if ( sc == ERROR_SUCCESS )
        {
            //
            // Get the date string and display it.
            //

            cch = GetDateFormat(
                          LOCALE_USER_DEFAULT
                        , DATE_SHORTDATE
                        , &systemtime
                        , NULL          // lpFormat
                        , wszText
                        , ARRAYSIZE( wszText )
                        );
            if ( cch == 0 )
            {
                sc = TW32( GetLastError() );
            }
            SetDlgItemText( m_hwnd, IDC_DETAILS_E_DATE, wszText );

            //
            // Get the time string and display it.
            //

            cch = GetTimeFormat(
                          LOCALE_USER_DEFAULT
                        , 0
                        , &systemtime
                        , NULL      // lpFormat
                        , wszText
                        , ARRAYSIZE( wszText )
                        );
            if ( cch == 0 )
            {
                sc = TW32( GetLastError() );
            }
            SetDlgItemText( m_hwnd, IDC_DETAILS_E_TIME, wszText );
        } // if: time converted successfully
        else
        {
            SetDlgItemText( m_hwnd, IDC_DETAILS_E_DATE, L"" );
            SetDlgItemText( m_hwnd, IDC_DETAILS_E_TIME, L"" );
        }
    } // else: date time specified

    //
    // Set the task IDs.
    //

    THR( HrFormatGuidIntoBSTR( &ptipd->clsidMajorTaskId, &bstr ) );
    if ( SUCCEEDED( hr ) )
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_MAJOR_ID, bstr );
    }

    hr = THR( HrFormatGuidIntoBSTR( &ptipd->clsidMinorTaskId, &bstr ) );
    if ( SUCCEEDED( hr ) )
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_MINOR_ID, bstr );
    }

    //
    // Set the text information.
    //

    // Node name.
    if ( ptipd->bstrNodeName == NULL )
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_COMPUTER, L"" );
    }
    else
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_E_COMPUTER, ptipd->bstrNodeName );
    }

    // Description.
    if ( ptipd->bstrDescription == NULL )
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_RE_DESCRIPTION, L"" );
    }
    else
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_RE_DESCRIPTION, ptipd->bstrDescription );
    }

    // Reference.
    hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_DEFAULT_DETAILS_REFERENCE, &bstrAdditionalInfo ) );
    if ( SUCCEEDED( hr ) )
    {
        if (    ( ptipd->bstrReference == NULL )
            ||  ( *ptipd->bstrReference == L'\0' )
            )
        {
            bstr = bstrAdditionalInfo;
            bstrAdditionalInfo = NULL;
        } // if: no reference specified
        else
        {
            hr = THR( HrFormatStringIntoBSTR( L"%s\n\n%s", &bstr, ptipd->bstrReference, bstrAdditionalInfo ) );
        } // else: reference specified
    }

    SetDlgItemText( m_hwnd, IDC_DETAILS_RE_REFERENCE, bstr );

    //
    // Set the status information.
    //

    _snwprintf( wszText, ARRAYSIZE( wszText ), L"0x%08x", ptipd->hr );
    SetDlgItemText( m_hwnd, IDC_DETAILS_E_STATUS, wszText );

    hr = ptipd->hr;
    if ( hr == S_FALSE )
    {
        hr = THR( HrFormatStringIntoBSTR( L"S_FALSE", &bstr ) );
    }
    else
    {
        // If not S_OK, this is a warning, so set the high bit before
        // translating to text, since the text string will not be found
        // without doing this.
        if ( hr != S_OK )
        {
            hr |= 0x80000000;
        }
        hr = THR( HrFormatErrorIntoBSTR( hr, &bstr ) );
    } // else: hr not S_FALSE
    if ( SUCCEEDED( hr ) )
    {
        SetDlgItemText( m_hwnd, IDC_DETAILS_RE_STATUS, bstr );
        if ( ptipd->hr == S_OK )
        {
            fDisplayIcon = FALSE;
        }
        else
        {
            fDisplayIcon = TRUE;
            if ( FAILED( ptipd->hr ) )
            {
                hicon = m_hiconError;
            }
            else
            {
                hicon = m_hiconWarn;
            }
            SendDlgItemMessage( m_hwnd, IDC_DETAILS_I_STATUS, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hicon );
        } // else: status not informational
    }
    ShowWindow( GetDlgItem( m_hwnd, IDC_DETAILS_I_STATUS ), fDisplayIcon ? SW_SHOW : SW_HIDE );

    hr = S_OK;

Cleanup:
    TraceSysFreeString( bstr );
    TraceSysFreeString( bstrAdditionalInfo );

    HRETURN( hr );

} //*** CDetailsDlg::HrDisplayItem()


//****************************************************************************
//
//  Private Functions
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ButtonFaceColorIsDark
//
//  Description:
//      Return TRUE if the button face color is dark (implying that
//      the light colored button icons should be used).
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        - Button face color is dark.
//      FALSE       - Button face color is light.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
ButtonFaceColorIsDark( void )
{
    TraceFunc( "" );

    COLORREF    rgbBtnFace = GetSysColor( COLOR_BTNFACE );

    ULONG   ulColors = GetRValue( rgbBtnFace ) +
                       GetGValue( rgbBtnFace ) +
                       GetBValue( rgbBtnFace );

    RETURN( ulColors < 300 );  // arbitrary threshold

} //*** ButtonFaceColorIsDark()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  SetButtonImage
//
//  Description:
//      Set an image on a button.
//
//  Arguments:
//      hwndBtnIn   - Handle to the button window.
//      idIconIn    - ID for the icon resource.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
SetButtonImage(
      HWND  hwndBtnIn
    , ULONG idIconIn
    )
{
    TraceFunc( "" );

    HICON hIcon = (HICON) LoadImage( g_hInstance,
                                     MAKEINTRESOURCE( idIconIn ),
                                     IMAGE_ICON,
                                     16,
                                     16,
                                     LR_DEFAULTCOLOR
                                     );
    if ( hIcon != NULL )
    {
        HICON hIconPrev = (HICON) SendMessage( hwndBtnIn,
                                               BM_SETIMAGE,
                                               (WPARAM) IMAGE_ICON,
                                               (LPARAM) hIcon
                                               );

        if ( hIconPrev )
        {
            DestroyIcon( hIconPrev );
        }
    }

    TraceFuncExit();

} //*** SetButtonImage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  FreeButtonImage
//
//  Description:
//      Free an image used by button.
//
//  Arguments:
//      hwndBtnIn   - Handle to the button window.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
FreeButtonImage(
    HWND hwndBtnIn
    )
{
    HANDLE hIcon = (HANDLE) SendMessage( hwndBtnIn, BM_GETIMAGE, IMAGE_ICON, 0 );

    if ( hIcon != NULL )
    {
        SendMessage( hwndBtnIn, BM_SETIMAGE, IMAGE_ICON, 0 );
        DestroyIcon( (HICON) hIcon );
    }

} //*** FreeButtonImage()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\ipaddresspage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      IPAddressPage.h
//
//  Maintained By:
//      David Potter    (DavidP)    14-MAR-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CIPAddressPage
    : public INotifyUI
{
friend class CClusCfgWizard;

private: // data
    HWND                m_hwnd;             // Our HWND
    IServiceProvider *  m_psp;              // Service Manager
    ULONG *             m_pulIPAddress;     // External storage of IPAddress
    ULONG *             m_pulIPSubnet;      // Subnet mask
    BSTR *              m_pbstrNetworkName; // Network name for address
    BSTR *              m_pbstrClusterName; // Cluster name
    OBJECTCOOKIE        m_cookieCompletion; // Completion cookie
    HANDLE              m_event;            // Event when verify IP address task is completed

    //  IUnknown
    LONG                m_cRef;             // Reference count

private: // methods
    CIPAddressPage(
          IServiceProvider *    pspIn
        , ECreateAddMode        ecamCreateAddModeIn
        , ULONG *               pulIPAddressInout
        , ULONG *               pulIPSubnetInout
        , BSTR *                pbstrNetworkNameInout
        , BSTR *                pbstrClusterNameIn
        );
    virtual ~CIPAddressPage( void );

    LRESULT
        OnInitDialog( void );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT
        OnNotifyQueryCancel( void );
    LRESULT
        OnNotifySetActive( void );
    LRESULT
        OnNotifyWizNext( void );
    LRESULT
        OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT
        HrUpdateWizardButtons( void );

    HRESULT
        HrFindNetworkForIPAddress(
            IClusCfgNetworkInfo **  ppccniOut
            );
    HRESULT
        HrMatchNetwork(
            IClusCfgNetworkInfo *   pccniIn,
            BSTR                    bstrNetworkNameIn
            );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

    //  IUnknown
    STDMETHOD( QueryInterface )( REFIID riidIn, LPVOID * ppvOut );
    STDMETHOD_( ULONG, AddRef )( void );
    STDMETHOD_( ULONG, Release )( void );

    //  INotifyUI
    STDMETHOD( ObjectChanged )( OBJECTCOOKIE cookieIn);

}; // class CIPAddressPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\ipaddresspage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      IPAddressPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    31-JAN-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "IPAddressPage.h"

DEFINE_THISCLASS("CIPAddressPage");

#define CONVERT_ADDRESS( _addrOut, _addrIn ) \
    _addrOut = ( FIRST_IPADDRESS( _addrIn ) ) | ( SECOND_IPADDRESS( _addrIn ) << 8 ) | ( THIRD_IPADDRESS( _addrIn ) << 16 ) | ( FOURTH_IPADDRESS( _addrIn ) << 24 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::CIPAddressPage
//
//  Descriptor:
//      Constructor.
//
//  Arguments:
//      pspIn                   -- IServiceProvider
//      ecamCreateAddModeIn     -- Creating cluster or adding nodes to cluster.
//      pulIPAddressInout       -- Pointer to IP address fill in.
//      pulIPSubnetInout        -- Pointer to subnet mask to fill in.
//      pbstrNetworkNameInout   -- Pointer to network name string to fill in.
//      pbstrClusterNameIn      -- Name of the cluster
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
CIPAddressPage::CIPAddressPage(
    IServiceProvider *  pspIn,
    ECreateAddMode      ecamCreateAddModeIn,
    ULONG *             pulIPAddressInout,
    ULONG *             pulIPSubnetInout,
    BSTR *              pbstrNetworkNameInout,
    BSTR *              pbstrClusterNameIn
    )
{
    TraceFunc( "" );

    Assert( pspIn != NULL );
    Assert( pulIPAddressInout != NULL );
    Assert( pulIPSubnetInout != NULL );
    Assert( pbstrNetworkNameInout != NULL );
    Assert( pbstrClusterNameIn != NULL );

    //  m_hwnd
    THR( pspIn->TypeSafeQI( IServiceProvider, &m_psp ) );
    m_pulIPAddress     = pulIPAddressInout;
    m_pulIPSubnet      = pulIPSubnetInout;
    m_pbstrNetworkName = pbstrNetworkNameInout;
    m_pbstrClusterName = pbstrClusterNameIn;

    m_cookieCompletion = NULL;
    m_event = NULL;

    m_cRef = 0;

    TraceFuncExit();

} //*** CIPAddressPage::CIPAddressPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::~CIPAddressPage
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
CIPAddressPage::~CIPAddressPage( void )
{
    TraceFunc( "" );

    if ( m_psp != NULL )
    {
        m_psp->Release();
    }

    if ( m_event != NULL )
    {
        CloseHandle( m_event );
    }

    Assert( m_cRef == 0 );

    TraceFuncExit();

} //*** CIPAddressPage::~CIPAddressPage()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::OnInitDialog
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      FALSE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPAddressPage::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    if ( *m_pulIPAddress != 0 )
    {
        ULONG   ulIPAddress;
        CONVERT_ADDRESS( ulIPAddress, *m_pulIPAddress );
        SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, IPM_SETADDRESS, 0, ulIPAddress );
    }

    m_event = CreateEvent( NULL, TRUE, FALSE, NULL );
    Assert( m_event != NULL );

    RETURN( lr );

} //*** CIPAddressPage::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::OnCommand
//
//  Description:
//
//  Arguments:
//      idNotificationIn
//      idControlIn
//      hwndSenderIn
//
//  Return Values:
//      TRUE
//      FALSE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPAddressPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_IPADDRESS_IP_ADDRESS:
            if ( idNotificationIn == IPN_FIELDCHANGED
              || idNotificationIn == EN_CHANGE
               )
            {
                THR( HrUpdateWizardButtons() );
                lr = TRUE;
            }
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CIPAddressPage::OnCommand()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::HrUpdateWizardButtons
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      Other HRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPAddressPage::HrUpdateWizardButtons( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    DWORD   dwFlags = PSWIZB_BACK | PSWIZB_NEXT;
    LRESULT lr;
    ULONG   ulIPAddress;

    lr = SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, IPM_ISBLANK, 0, 0 );
    if ( lr != 0 )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }

    SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, IPM_GETADDRESS, 0, (LPARAM) &ulIPAddress );
    if (    ( ulIPAddress == 0)                                     // Bad IP
        ||  ( ulIPAddress == MAKEIPADDRESS( 255, 255, 255, 255 ) )  // Bad IP
        )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }

    PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );

    HRETURN( hr );

} //*** CIPAddressPage::HrUpdateWizardButtons()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::OnNotifyQueryCancel
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPAddressPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CIPAddressPage::OnNotifyQueryCancel()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::OnNotifySetActive
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPAddressPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    // Enable controls on the page.
    SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, WM_ENABLE, TRUE, 0 );

    THR( HrUpdateWizardButtons() );

    RETURN( lr );

} //*** CIPAddressPage::OnNotifySetActive()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::OnNotifyWizNext
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPAddressPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    HRESULT hr;
    HRESULT hrStatus;
    BOOL    fRet;
    DWORD   ulAddress;

    OBJECTCOOKIE    cookieDummy;

    LRESULT lr             = TRUE;
    DWORD   dwCookieNotify = 0;

    IUnknown *                  punk    = NULL;
    IObjectManager *            pom     = NULL;
    ITaskManager *              ptm     = NULL;
    IClusCfgClusterInfo *       pccci   = NULL;
    IClusCfgNetworkInfo *       pccni   = NULL;
    ITaskVerifyIPAddress *      ptvipa  = NULL;
    IStandardInfo *             psi     = NULL;
    IConnectionPointContainer * pcpc    = NULL;
    IConnectionPoint *          pcp     = NULL;

    CWaitCursor WaitCursor;

    // Disable controls on the page.
    SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, WM_ENABLE, FALSE, 0 );

    //
    //  Get the IP address from the UI.
    //

    SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, IPM_GETADDRESS, 0, (LPARAM) &ulAddress );
    CONVERT_ADDRESS( *m_pulIPAddress, ulAddress );

    //
    //  See if this IP address can be matched to a network.

    hr = THR( HrFindNetworkForIPAddress( &pccni ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }
    if ( hr == S_FALSE )
    {
        MessageBoxFromStrings(
              m_hwnd
            , IDS_CANNOT_FIND_MATCHING_NETWORK_TITLE
            , IDS_CANNOT_FIND_MATCHING_NETWORK_TEXT
            , MB_OK
            );
        goto Error;
    }

    //
    //  Grab some managers we will need.
    //

    hr = THR( m_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( m_psp->TypeSafeQS( CLSID_TaskManager,
                                 ITaskManager,
                                 &ptm
                                 ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( m_psp->TypeSafeQS( CLSID_NotificationManager,
                                 IConnectionPointContainer,
                                 &pcpc
                                 ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( pcpc->FindConnectionPoint( IID_INotifyUI, &pcp ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Get the cluster configuration info.
    //

    hr = THR( pom->FindObject( CLSID_ClusterConfigurationType,
                               NULL,
                               *m_pbstrClusterName,
                               DFGUID_ClusterConfigurationInfo,
                               &cookieDummy,
                               &punk
                               ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &pccci ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    punk->Release();
    punk = NULL;

    //
    //  Set the IP adddress.
    //

    hr = THR( pccci->SetIPAddress( *m_pulIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Set the IP subnet mask.
    //

    hr = THR( pccci->SetSubnetMask( *m_pulIPSubnet ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    // Set the network.
    //

    hr = THR( pccci->SetNetworkInfo( pccni ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Register to get UI notification (if needed)
    //

    hr = THR( pcp->Advise( static_cast< INotifyUI * >( this ), &dwCookieNotify ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  See the IP address is already present on the network.
    //

    hr = THR( ptm->CreateTask( TASK_VerifyIPAddress,
                               &punk
                               ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    hr = THR( punk->TypeSafeQI( ITaskVerifyIPAddress, &ptvipa ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    punk->Release();
    punk = NULL;

    hr = THR( ptvipa->SetIPAddress( *m_pulIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    // Don't wrap - this can fail with E_PENDING
    hr = pom->FindObject( CLSID_TaskVerifyIPAddressCompletionCookieType,
                          NULL,
                          *m_pbstrClusterName,
                          IID_NULL,
                          &m_cookieCompletion,
                          &punk // dummy
                          );
    Assert( punk == NULL );
    if ( hr == E_PENDING )
    {
        // no-op.
    }
    else if ( FAILED( hr ) )
    {
        THR( hr );
        goto Error;
    }

    hr = THR( ptvipa->SetCookie( m_cookieCompletion ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    // reset the event before submitting.
    if ( m_event != NULL )
    {
        fRet = ResetEvent( m_event );
        Assert( fRet );
    }

    hr = THR( ptm->SubmitTask( ptvipa ) );
    if ( FAILED( hr ) )
    {
        goto Error;
    }

    //
    //  Now wait for the work to be done.
    //

    if ( m_event != NULL )
    {
        MSG     msg;
        DWORD   dwErr;

        for( dwErr = -1; dwErr != WAIT_OBJECT_0; )
        {
            while ( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
            {
                TranslateMessage( &msg );
                DispatchMessage( &msg );
            } // while: PeekMessage

            CWaitCursor Wait2;

            dwErr = MsgWaitForMultipleObjects( 1,
                                               &m_event,
                                               FALSE,
                                               10000, // wait at most 10 seconds
                                               QS_ALLEVENTS | QS_ALLINPUT | QS_ALLPOSTMESSAGE
                                               );
            AssertMsg( dwErr != WAIT_TIMEOUT, "Need to bump up the timeout period." );
            if ( dwErr == WAIT_TIMEOUT )
            {
                break;  // give up and continue
            }

        } // for: dwErr
    }

    hr = THR( pom->GetObject( DFGUID_StandardInfo,
                              m_cookieCompletion,
                              &punk
                              ) );
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( punk->TypeSafeQI( IStandardInfo, &psi ) );
        if ( FAILED( hr ) )
        {
            goto Error;
        }

        punk->Release();
        punk = NULL;

        hr = THR( psi->GetStatus( &hrStatus ) );
        if ( hrStatus == S_FALSE )
        {
            int iAnswer;

            //
            //  We detected a duplicate IP address on the network. Ask the user if
            //  they want to go back and change the IP or continue on.
            //

            iAnswer = MessageBoxFromStrings( m_hwnd,
                                             IDS_ERR_IPADDRESS_ALREADY_PRESENT_TITLE,
                                             IDS_ERR_IPADDRESS_ALREADY_PRESENT_TEXT,
                                             MB_YESNO
                                             );
            if ( iAnswer == IDYES )
            {
                goto Error;
            }
        }
    }

    goto Cleanup;

Error:
    // Enable controls on the page again.
    SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, WM_ENABLE, TRUE, 0 );
    SendDlgItemMessage( m_hwnd, IDC_IPADDRESS_IP_ADDRESS, WM_SETFOCUS, 0, 0 );

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );

    goto Cleanup;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( psi != NULL )
    {
        psi->Release();
    }
    if ( ptm != NULL )
    {
        ptm->Release();
    }
    if ( ptvipa != NULL )
    {
        ptvipa->Release();
    }
    if ( pccci != NULL )
    {
        pccci->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pcpc != NULL )
    {
        pcpc->Release();
    }
    if ( pcp != NULL )
    {
        if ( dwCookieNotify != 0 )
        {
            THR( pcp->Unadvise( dwCookieNotify ) );
        }

        Assert( m_cRef == 0 );

        pcp->Release();
    }
    if ( pom != NULL )
    {
        pom->Release();
    }

    RETURN( lr );

} //*** CIPAddressPage::OnNotifyWizNext()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::OnNotify
//
//  Description:
//      Handle the WM_NOTIFY windows message.
//
//  Arguments:
//      idCtrlIn
//      pnmhdrIn
//
//  Return Values:
//      TRUE
//      Other LRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPAddressPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_WIZNEXT:
            lr = OnNotifyWizNext();
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;
    }

    RETURN( lr );

} //*** CIPAddressPage::OnNotify()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CALLBACK
//  CIPAddressPage::S_DlgProc
//
//  Description:
//      Dialog proc for this page.
//
//  Arguments:
//      hDlgIn
//      MsgIn
//      wParam
//      lParam
//
//  Return Values:
//      FALSE
//      Other LRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CIPAddressPage::S_DlgProc(
    HWND hDlgIn,
    UINT MsgIn,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CIPAddressPage * pPage = reinterpret_cast< CIPAddressPage *> ( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CIPAddressPage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr= pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), (HWND) lParam );
                break;

            // no default clause needed
        } // switch: message
    } // if: there is a page associated with the window

    return lr;

} //*** CIPAddressPage::S_DlgProc()

// ************************************************************************
//
// IUnknown
//
// ************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CIPAddressPage::QueryInterface
//
//  Description:
//
//  Arguments:
//      riidIn
//      ppvOut
//
//  Return Values:
//      S_OK
//      E_NOINTERFACE
//      Other HRESULT values.
//
//  Remarks:
//      Supports IUnknown and INotifyUI.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressPage::QueryInterface(
    REFIID      riidIn,
    LPVOID *    ppvOut
    )
{
    TraceQIFunc( riidIn, ppvOut );

    HRESULT hr = E_NOINTERFACE;

    if ( IsEqualIID( riidIn, IID_IUnknown ) )
    {
        *ppvOut = static_cast< INotifyUI * >( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riidIn, IID_INotifyUI ) )
    {
        *ppvOut = TraceInterface( __THISCLASS__, INotifyUI, this, 0 );
        hr = S_OK;
    } // else if: INotifyUI

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppvOut)->AddRef();
    } // if: success

    QIRETURN_IGNORESTDMARSHALLING( hr, riidIn );

} //*** CIPAddressPage::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CIPAddressPage::AddRef
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CIPAddressPage::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CIPAddressPage::AddRef()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IUnknown]
//  CIPAddressPage::Release
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      New reference count.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CIPAddressPage::Release( void )
{
    TraceFunc( "[IUnknown]" );

    LONG    cRef;

    InterlockedDecrement( &m_cRef );
    cRef = m_cRef;

    if ( cRef == 0 )
    {
        // TraceDo( delete this );
    }

    RETURN( cRef );

} //*** CIPAddressPage::Release()


//****************************************************************************
//
//  INotifyUI
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [INotifyUI]
//  CIPAddressPage::ObjectChanged
//
//  Description:
//
//  Arguments:
//      cookieIn
//
//  Return Values:
//      S_OK
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CIPAddressPage::ObjectChanged(
    OBJECTCOOKIE cookieIn
    )
{
    TraceFunc( "[INotifyUI]" );

    BOOL    fRet;
    HRESULT hr = S_OK;

    if ( cookieIn == m_cookieCompletion
      && m_event != NULL
       )
    {
        fRet = SetEvent( m_event );
        Assert( fRet );
    }

    HRETURN( hr );

} //*** CIPAddressPage::ObjectChanged()


//****************************************************************************
//
//  Private Functions
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::HrFindNetworkForIPAddress
//
//  Description:
//      Find the network for the saved IP address.
//
//  Arguments:
//      ppccniOut   -- Network info to return.
//
//  Return Values:
//      S_OK
//      S_FALSE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPAddressPage::HrFindNetworkForIPAddress(
    IClusCfgNetworkInfo **  ppccniOut
    )
{
    TraceFunc( "" );

    HRESULT                 hr          = S_OK;
    IUnknown *              punk        = NULL;
    IObjectManager *        pom         = NULL;
    IEnumCookies *          pec         = NULL;
    IEnumClusCfgNetworks *  peccn       = NULL;
    IClusCfgNetworkInfo *   pccni       = NULL;
    BSTR                    bstrNetName = NULL;
    OBJECTCOOKIE            cookieCluster;
    OBJECTCOOKIE            cookieNode;
    OBJECTCOOKIE            cookieDummy;
    ULONG                   celtDummy;
    bool                    fFoundNetwork = false;

    Assert( ppccniOut != NULL );

    //
    //  Grab the object manager.
    //

    hr = THR( m_psp->TypeSafeQS(
                    CLSID_ObjectManager,
                    IObjectManager,
                    &pom
                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    //  Get the cluster configuration info cookie.
    //

    hr = THR( pom->FindObject(
                        CLSID_ClusterConfigurationType,
                        NULL,
                        *m_pbstrClusterName,
                        IID_NULL,
                        &cookieCluster,
                        &punk
                        ) );
    Assert( punk == NULL );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the enumeration of nodes whose parent is this cluster.
    // We want the enumeration of cookies (indicated by using
    // DFGUID_EnumCookies) because we want to use the cookie of the
    // node to search for all networks on that node.
    //

    hr = THR( pom->FindObject(
                        CLSID_NodeType,
                        cookieCluster,
                        NULL,
                        DFGUID_EnumCookies,
                        &cookieDummy,
                        &punk
                        ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pec ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pec = TraceInterface( L"CIPAddressPage!IEnumCookies", IEnumCookies, pec, 1 );

    punk->Release( );
    punk = NULL;

    //
    // Get the cookie for the first node in the node enumeration.
    //

    hr = THR( pec->Next( 1, &cookieNode, &celtDummy ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the network enumerator.
    //

    hr = THR( pom->FindObject(
                        CLSID_NetworkType,
                        cookieNode,
                        NULL,
                        DFGUID_EnumManageableNetworks,
                        &cookieDummy,
                        &punk
                        ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    punk->Release( );
    punk = NULL;

    //
    // Add each network to the combobox.
    //

    for ( ;; )
    {
        // Get the next network.
        hr = STHR( peccn->Next( 1, &pccni, &celtDummy ) );
        if ( hr == S_FALSE )
        {
            break;
        }
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        // Skip this network if it isn't public.
        hr = STHR( pccni->IsPublic() );
        if ( hr == S_OK )
        {
            // Get the name of the network.
            hr = THR( pccni->GetName( &bstrNetName ) );
            if ( SUCCEEDED( hr ) )
            {
                TraceMemoryAddBSTR( bstrNetName );

                // Determine if this network matches the user's IP address.
                // If it is, select it in the combobox.
                if ( ! fFoundNetwork )
                {
                    hr = STHR( HrMatchNetwork( pccni, bstrNetName ) );
                    if ( hr == S_OK )
                    {
                        fFoundNetwork = true;
                        *ppccniOut = pccni;
                        (*ppccniOut)->AddRef();
                        break;
                    }
                }

                // Cleanup.
                TraceSysFreeString( bstrNetName );
                bstrNetName = NULL;

            } // if: name retrieved successfully
        } // if: network is public

        pccni->Release();
        pccni = NULL;
    } // forever

    if ( fFoundNetwork )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release( );
    }
    TraceSysFreeString( bstrNetName );
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( peccn != NULL )
    {
        peccn->Release();
    }
    if ( pec != NULL )
    {
        pec->Release();
    }
    if ( pom != NULL )
    {
        pom->Release();
    }

    HRETURN( hr );

} //*** CIPAddressPage::HrFindNetworkForIPAddress()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddressPage::HrMatchNetwork
//
//  Description:
//      Match a network to the saved IP address.
//
//  Arguments:
//      pccniIn
//      bstrNetworkNameIn
//
//  Return Values:
//      S_OK
//      S_FALSE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPAddressPage::HrMatchNetwork(
    IClusCfgNetworkInfo *   pccniIn,
    BSTR                    bstrNetworkNameIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr      = S_OK;
    IClusCfgIPAddressInfo * pccipai = NULL;
    ULONG                   ulIPAddress;
    ULONG                   ulIPSubnet;

    Assert( pccniIn != NULL );
    Assert( bstrNetworkNameIn != NULL );

    //
    // Get the IP Address Info for the network.
    //

    hr = THR( pccniIn->GetPrimaryNetworkAddress( &pccipai ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Get the address and subnet of the network.
    //

    hr = THR( pccipai->GetIPAddress( &ulIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccipai->GetSubnetMask( &ulIPSubnet ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Determine if these match.
    //

    if ( ClRtlAreTcpipAddressesOnSameSubnet( *m_pulIPAddress, ulIPAddress, ulIPSubnet) )
    {
        // Save the subnet mask.
        *m_pulIPSubnet = ulIPSubnet;

        // Save the name of the network.
        if ( *m_pbstrNetworkName == NULL )
        {
            *m_pbstrNetworkName = TraceSysAllocString( bstrNetworkNameIn );
            if ( *m_pbstrNetworkName == NULL )
            {
                goto OutOfMemory;
            }
        }
        else
        {
            INT iRet = TraceSysReAllocString( m_pbstrNetworkName, bstrNetworkNameIn );
            if ( ! iRet )
            {
                goto OutOfMemory;
            }
        }
    } // if: match found
    else
    {
        hr = S_FALSE;
    }

    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

Cleanup:
    if ( pccipai != NULL )
    {
        pccipai->Release();
    }

    HRETURN( hr );

} //*** CIPAddressPage::HrMatchNetwork()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\messagebox.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      MessageBox.h
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    15-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

int
MessageBoxFromStrings( HWND hParent, UINT idsCaption, UINT idsText, UINT uType );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//      Include file for standard system include files, or project specific
//      include files that are used frequently, but are changed infrequently.
//
//  Maintained By:
//      Galen Barbee  (GalenB)    14-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING
#endif // DBG==1 || _DEBUG

//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#pragma warning (disable: 4514) // Unreferenced inline function removed
#pragma warning (disable: 4201) // Nameless union/struct
#pragma warning (disable: 4706) // Assignment within conditional expression

#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include <objbase.h>
#include <objidl.h>
#include <ocidl.h>
#include <ComCat.h>
#include <tchar.h>
#include <commctrl.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <wbemcli.h>
#include <windns.h>
#include <ObjSel.h>
#include <richedit.h>
#include <clusrtl.h>
#include <wincred.h>

#include <Guids.h>
#include <Common.h>
#include <CFactory.h>
#include <Dll.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>

#include <ObjectCookie.h>
#include <ClusCfgGuids.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>
#include <LoadString.h>
#include <ClusCfg.h>

#include "resource.h"
#include "MessageBox.h"
#include "WaitCursor.h"


//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constants
//////////////////////////////////////////////////////////////////////////////

#define HR_S_RPC_S_SERVER_UNAVAILABLE  MAKE_HRESULT( 0, FACILITY_WIN32, RPC_S_SERVER_UNAVAILABLE )

// (jfranco, bug #377545)
// Limiting user name lengths according to "Naming Properties" and "Example Code for Creating a User"
// topics under Active Directory in MSDN
#define MAX_USERNAME_LENGTH 20
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\quorumdlg.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      QuorumDlg.h
//
//  Maintained By:
//      David Potter    (DavidP)    03-APR-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CQuorumDlg
//
//  Description:
//      Display the Quorum dialog box.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CQuorumDlg
{
private: // data
    HWND                m_hwnd;             //  Our HWND
    BSTR                m_bstrClusterName;   //  Name of the cluster
    IServiceProvider *  m_psp;              //  Service Manager
    HWND                m_hComboBox;        // combo box handle

    IClusCfgManagedResourceInfo **  m_rgpResources; // quorum capable and joinable resources
    size_t                          m_cValidResources;    // number of items in m_rgpResources array
    size_t                          m_idxQuorumResource;    // resource to set as quorum on return
    bool                            m_fQuorumAlreadySet; // one of the resources was already marked on entry

private: // methods
    CQuorumDlg(
          IServiceProvider *    pspIn
        , BSTR                  bstrClusterNameIn
        );
    ~CQuorumDlg( void );

    static INT_PTR CALLBACK
        S_DlgProc( HWND hwndDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );

    LRESULT OnInitDialog( void );
    LRESULT OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );

    HRESULT HrCreateResourceList( void );
    

    void UpdateButtons( void );

public: // methods
    static HRESULT
        S_HrDisplayModalDialog(
              HWND                  hwndParentIn
            , IServiceProvider *    pspIn
            , BSTR                  bstrClusterNameIn
            );

}; //*** class CQuorumDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\ipsubnetpage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      IPSubnetPage.h
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CIPSubnetPage
{
friend class CClusCfgWizard;

private: // data
    HWND                m_hwnd;             // Our HWND
    IServiceProvider *  m_psp;              // Service Manager
    ULONG *             m_pulIPSubnet;      // Subnet mask
    BSTR *              m_pbstrNetworkName; // Network name for address
    ULONG *             m_pulIPAddress;     // IP Address
    BSTR *              m_pbstrClusterName; // Cluster Name

private: // methods
    CIPSubnetPage( IServiceProvider *   pspIn,
                   ECreateAddMode       ecamCreateAddModeIn,
                   ULONG *              pulIPSubnetInout,
                   BSTR *               pbstrNetworkNameInout,
                   ULONG *              pulIPAddressIn,
                   BSTR *               pbstrClusterNameIn
                   );
    virtual ~CIPSubnetPage();

    LRESULT
        OnInitDialog( void );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT
        OnNotifyQueryCancel( void );
    LRESULT
        OnNotifySetActive( void );
    LRESULT
        OnNotifyKillActive( void );
    LRESULT
        OnNotifyWizNext( void );
    LRESULT
        OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT
        HrUpdateWizardButtons( void );

    HRESULT
        HrAddNetworksToComboBox( HWND hwndCBIn );
    HRESULT
        HrMatchNetwork( IClusCfgNetworkInfo * pccniIn, BSTR bstrNetworkNameIn );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

}; //*** class CIPSubnetPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\messagebox.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      MessageBox.cpp
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    15-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  int
//  MessageBoxFromStrings(
//      HWND    hParentIn,
//      UINT    idsCaptionIn,
//      UINT    idsTextIn,
//      UINT    uTypeIn 
//      )
//
//  Description:
//      Create a message box from resource strings.
//
//  Parameters:
//      hParentIn
//          HWND of the parent window.
//
//      idsCaptionIn
//          Resource ID of the caption for the message box.
//
//      idsTextIn
//          Resource ID of the text for the message box.
//
//      uTypeIn
//          Flags for the message box style.
//
//  Return Values:
//      Whatever ::MessageBox( ) can return.
//
//--
//////////////////////////////////////////////////////////////////////////////
int
MessageBoxFromStrings(
    HWND hParentIn,
    UINT idsCaptionIn,
    UINT idsTextIn,
    UINT uTypeIn 
    )
{
    TraceFunc4( "hParentIn = 0x%p, idsCaptionIn = %u, idsTextIn = %u, uTypeIn = 0x%p",
                hParentIn, idsCaptionIn, idsTextIn, uTypeIn );

    DWORD dw;
    int   iRet;

    TCHAR szText[ 256 ];
    TCHAR szCaption[ 2048 ];

    dw = LoadString( g_hInstance, idsCaptionIn, szCaption, ARRAYSIZE(szCaption) );
    Assert( dw != 0 );
    dw = LoadString( g_hInstance, idsTextIn, szText, ARRAYSIZE(szText) );
    Assert( dw != 0 );

    iRet = MessageBox( hParentIn, szText, szCaption, uTypeIn );

    RETURN( iRet );

} //*** MessageBoxFromStrings( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\ipsubnetpage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      IPSubnetPage.cpp
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "IPSubnetPage.h"

DEFINE_THISCLASS("CIPSubnetPage");

#define CONVERT_ADDRESS( _addrOut, _addrIn ) \
    _addrOut = ( FIRST_IPADDRESS( _addrIn ) ) | ( SECOND_IPADDRESS( _addrIn ) << 8 ) | ( THIRD_IPADDRESS( _addrIn ) << 16 ) | ( FOURTH_IPADDRESS( _addrIn ) << 24 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPSubnetPage::CIPSubnetPage(
//      IServiceProvider *  pspIn,
//      ECreateAddMode      ecamCreateAddModeIn
//      LONG *              pulIPSubnetInout,
//      BSTR *              pbstrNetworkNameInout,
//      ULONG *             pulIPAddressIn,
//      BSTR *              pbstrClusterNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
CIPSubnetPage::CIPSubnetPage(
    IServiceProvider *  pspIn,
    ECreateAddMode      ecamCreateAddModeIn,
    ULONG *             pulIPSubnetInout,
    BSTR *              pbstrNetworkNameInout,
    ULONG *             pulIPAddressIn,
    BSTR *              pbstrClusterNameIn
    )
{
    TraceFunc( "" );

    Assert( pspIn != NULL );
    Assert( pulIPSubnetInout != NULL );
    Assert( pbstrNetworkNameInout != NULL );
    Assert( pulIPAddressIn != NULL );
    Assert( pbstrClusterNameIn != NULL );

    // m_hwnd = NULL;
    THR( pspIn->TypeSafeQI( IServiceProvider, &m_psp ) );
    m_pulIPSubnet = pulIPSubnetInout;
    m_pbstrNetworkName = pbstrNetworkNameInout;
    m_pulIPAddress = pulIPAddressIn;
    m_pbstrClusterName = pbstrClusterNameIn;

    TraceFuncExit( );

} //*** CIPSubnetPage::CIPSubnetPage( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPSubnetPage::~CIPSubnetPage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////

CIPSubnetPage::~CIPSubnetPage( void )
{
    TraceFunc( "" );

    if ( m_psp != NULL )
    {
        m_psp->Release( );
    }

    TraceFuncExit( );

} //*** CIPSubnetPage::~CIPSubnetPage( )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnInitDialog( void )
{
    TraceFunc( "" );

    BOOL bRet;

    LRESULT lr = FALSE; // Didn't set focus

    if ( *m_pulIPSubnet != 0 )
    {
        ULONG   ulIPSubnet;
        CONVERT_ADDRESS( ulIPSubnet, *m_pulIPSubnet );
        SendDlgItemMessage( m_hwnd, IDC_IP_SUBNETMASK, IPM_SETADDRESS, 0, ulIPSubnet );
    }

    RETURN( lr );

} //*** CIPSubnetPage::OnInitDialog( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnCommand(
//      UINT    idNotificationIn,
//      UINT    idControlIn,
//      HWND    hwndSenderIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
    case IDC_IP_SUBNETMASK:
        if ( idNotificationIn == IPN_FIELDCHANGED 
          || idNotificationIn == EN_CHANGE
           )
        {
            THR( HrUpdateWizardButtons( ) );
            lr = TRUE;
        }
        break;

    case IDC_CB_NETWORKS:
        if ( idNotificationIn == CBN_SELCHANGE )
        {
            THR( HrUpdateWizardButtons( ) );
            lr = TRUE;
        }
        break;

    }

    RETURN( lr );

} //*** CIPSubnetPage::OnCommand( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CIPSubnetPage::HrUpdateWizardButtons( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPSubnetPage::HrUpdateWizardButtons( void )
{
    TraceFunc( "" );

    LRESULT lr;
    ULONG   ulIPSubnet;

    HRESULT hr = S_OK;
    DWORD   dwFlags = PSWIZB_BACK | PSWIZB_NEXT;

    lr = SendDlgItemMessage( m_hwnd, IDC_IP_SUBNETMASK, IPM_ISBLANK, 0, 0 );
    if ( lr != 0 )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }

    lr = ComboBox_GetCurSel( GetDlgItem( m_hwnd, IDC_CB_NETWORKS ) );
    if ( lr == CB_ERR )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }
    
    PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );

    HRETURN( hr );

} //*** CIPSubnetPage::HrUpdateWizardButtons( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
    case PSN_SETACTIVE:
        lr = OnNotifySetActive( );
        break;

    case PSN_KILLACTIVE:
        lr = OnNotifyKillActive( );
        break;

    case PSN_WIZNEXT:
        lr = OnNotifyWizNext( );
        break;

    case PSN_QUERYCANCEL:
        lr = OnNotifyQueryCancel( );
        break;
    }

    RETURN( lr );

} //*** CIPSubnetPage::OnNotify( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnNotifyQueryCancel( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CIPSubnetPage::OnNotifyQueryCancel( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    LRESULT lr      = TRUE;
    HWND    hwndIP  = GetDlgItem( m_hwnd, IDC_IP_SUBNETMASK );
    HWND    hwndCB  = GetDlgItem( m_hwnd, IDC_CB_NETWORKS );
    WCHAR   szIPAddress[ ARRAYSIZE( "255 . 255 . 255 . 255" ) ];
    LRESULT lrCB;
    HRESULT hr;

    THR( HrUpdateWizardButtons( ) );

    //
    // Set the IP address string.
    //

    wnsprintf( szIPAddress, 
               ARRAYSIZE( szIPAddress ),
               L"%u . %u . %u . %u",
               FOURTH_IPADDRESS( *m_pulIPAddress ),
               THIRD_IPADDRESS( *m_pulIPAddress ),
               SECOND_IPADDRESS( *m_pulIPAddress ),
               FIRST_IPADDRESS( *m_pulIPAddress )
               );

    SetDlgItemText( m_hwnd, IDC_E_IPADDRESS, szIPAddress );

    //
    // Add networks to the combobox.
    //

    hr = STHR( HrAddNetworksToComboBox( hwndCB ) );

    //
    // Set the subnet mask based on what was found from
    // the networks added to the combobox.
    //

    if ( *m_pulIPSubnet != 0 )
    {
        ULONG ulIPSubnet;
        CONVERT_ADDRESS( ulIPSubnet, *m_pulIPSubnet );
        SendMessage( hwndIP, IPM_SETADDRESS, 0, ulIPSubnet );
    }

    //
    // If there isn't a selected network, select the first one.
    //

    lrCB = ComboBox_GetCurSel( hwndCB );
    if ( lrCB == CB_ERR )
    {
        ComboBox_SetCurSel( hwndCB, 0 );
    }

    //
    // Determine if we need to show this page.
    //

    if ( hr == S_OK )
    {
        OnNotifyWizNext();
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CIPSubnetPage::OnNotifySetActive( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnNotifyKillActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnNotifyKillActive( void )
{
    TraceFunc( "" );

    LRESULT lr      = TRUE;
    HWND    hwndCB  = GetDlgItem( m_hwnd, IDC_CB_NETWORKS );
    LRESULT citems;

    //
    // Release all the network info interfaces stored in the combobox.
    //

    citems = ComboBox_GetCount( hwndCB );
    Assert( citems != CB_ERR );

    if ( ( citems != CB_ERR )
      && ( citems > 0 ) )
    {
        LRESULT                 idx;
        LRESULT                 lrItemData;
        IClusCfgNetworkInfo *   pccni;

        for ( idx = 0 ; idx < citems ; idx++ )
        {
            lrItemData = ComboBox_GetItemData( hwndCB, idx );
            Assert( lrItemData != CB_ERR );

            pccni = reinterpret_cast< IClusCfgNetworkInfo * >( lrItemData );
            pccni->Release();
        } // for: each item in the combobox
    } // if: retrieved combobox count and combobox not empty

    ComboBox_ResetContent( hwndCB );

    RETURN( lr );

} //*** CIPSubnetPage::OnNotifyKillActive( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CIPSubnetPage::OnNotifyWizNext( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CIPSubnetPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    OBJECTCOOKIE    cookieDummy;

    LRESULT lr = TRUE;
    LRESULT lrCB;
    HRESULT hr;
    ULONG   ulIPSubnet;
    HWND    hwndCB = GetDlgItem( m_hwnd, IDC_CB_NETWORKS );

    IUnknown *              punk  = NULL;
    IObjectManager *        pom   = NULL;
    IClusCfgClusterInfo *   pccci = NULL;
    IClusCfgNetworkInfo *   pccni = NULL;

    SendDlgItemMessage( m_hwnd, IDC_IP_SUBNETMASK, IPM_GETADDRESS, 0, (LPARAM) &ulIPSubnet );
    CONVERT_ADDRESS( *m_pulIPSubnet, ulIPSubnet );

    //
    //  Grab the object manager.
    //

    hr = THR( m_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    //  Get the cluster configuration info.
    //

    hr = THR( pom->FindObject( CLSID_ClusterConfigurationType,
                               NULL,
                               *m_pbstrClusterName,
                               DFGUID_ClusterConfigurationInfo,
                               &cookieDummy,
                               &punk
                               ) );
    if ( FAILED( hr ) )
        goto Error;

    hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &pccci ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Set the IP subnet mask.
    //

    hr = THR( pccci->SetSubnetMask( *m_pulIPSubnet ) );
    if ( FAILED( hr ) )
        goto Error;

    //
    // Get the selected network.
    //

    //
    // Set the network.
    //

    lrCB = ComboBox_GetCurSel( hwndCB );
    Assert( lrCB != CB_ERR );

    lrCB = ComboBox_GetItemData( hwndCB, lrCB );
    Assert( lrCB != CB_ERR );

    pccni = reinterpret_cast< IClusCfgNetworkInfo * >( lrCB );

    hr = THR( pccci->SetNetworkInfo( pccni ) );
    if ( FAILED( hr ) )
        goto Error;

Cleanup:
    if ( punk != NULL )
    {
        punk->Release( );
    }

    if ( pccci != NULL )
    {
        pccci->Release( );
    }

    if ( pom != NULL )
    {
        pom->Release( );
    }

    RETURN( lr );

Error:
    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    goto Cleanup;

} //*** CIPSubnetPage::OnNotifyWizNext( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CIPSubnetPage::HrAddNetworksToComboBox( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPSubnetPage::HrAddNetworksToComboBox(
    HWND hwndCBIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr          = S_OK;
    IUnknown *              punk        = NULL;
    IObjectManager *        pom         = NULL;
    IEnumCookies *          pec         = NULL;
    IEnumClusCfgNetworks *  peccn       = NULL;
    IClusCfgNetworkInfo *   pccni       = NULL;
    BSTR                    bstrNetName = NULL;
    OBJECTCOOKIE            cookieCluster;
    OBJECTCOOKIE            cookieNode;
    OBJECTCOOKIE            cookieDummy;
    ULONG                   celtDummy;
    bool                    fFoundNetwork = false;
    LRESULT                 lr;
    LRESULT                 lrIndex;

    Assert( hwndCBIn != NULL );

    ComboBox_ResetContent( hwndCBIn );

    //
    //  Grab the object manager.
    //

    hr = THR( m_psp->TypeSafeQS(
                    CLSID_ObjectManager,
                    IObjectManager,
                    &pom
                    ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    //  Get the cluster configuration info cookie.
    //

    hr = THR( pom->FindObject(
                        CLSID_ClusterConfigurationType,
                        NULL,
                        *m_pbstrClusterName,
                        IID_NULL,
                        &cookieCluster,
                        &punk
                        ) );
    Assert( punk == NULL );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get the enumeration of nodes whose parent is this cluster.
    // We want the enumeration of cookies (indicated by using
    // DFGUID_EnumCookies) because we want to use the cookie of the
    // node to search for all networks on that node.
    //

    hr = THR( pom->FindObject(
                        CLSID_NodeType,
                        cookieCluster,
                        NULL,
                        DFGUID_EnumCookies,
                        &cookieDummy,
                        &punk
                        ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( IEnumCookies, &pec ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    pec = TraceInterface( L"CIPSubnetPage!IEnumCookies", IEnumCookies, pec, 1 );

    punk->Release( );
    punk = NULL;

    //
    // Get the cookie for the first node in the node enumeration.
    //

    hr = THR( pec->Next( 1, &cookieNode, &celtDummy ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get the network enumerator.
    //

    hr = THR( pom->FindObject(
                        CLSID_NetworkType,
                        cookieNode,
                        NULL,
                        DFGUID_EnumManageableNetworks,
                        &cookieDummy,
                        &punk
                        ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    punk->Release( );
    punk = NULL;

    //
    // Add each network to the combobox.
    //

    for ( ;; )
    {
        // Get the next network.
        hr = STHR( peccn->Next( 1, &pccni, &celtDummy ) );
        if ( hr == S_FALSE )
            break;
        if ( FAILED( hr ) )
            goto Cleanup;

        // Skip this network if it isn't public.
        hr = STHR( pccni->IsPublic() );
        if ( hr == S_OK )
        {
            // Get the name of the network.
            hr = THR( pccni->GetName( &bstrNetName ) );
            if ( SUCCEEDED( hr ) )
            {
                TraceMemoryAddBSTR( bstrNetName );

                // Add the network to the combobox.
                lrIndex = ComboBox_AddString( hwndCBIn, bstrNetName );
                Assert( ( lrIndex != CB_ERR )
                     && ( lrIndex != CB_ERRSPACE )
                     );

                // Add the netinfo interface to the combobox as well.
                if ( ( lrIndex != CB_ERR )
                  && ( lrIndex != CB_ERRSPACE ) )
                {
                    pccni->AddRef();
                    lr = ComboBox_SetItemData( hwndCBIn, lrIndex, pccni );
                    Assert( lr != CB_ERR );
                }

                // Determine if this network matches the user's IP address.
                // If it is, select it in the combobox.
                if ( ! fFoundNetwork )
                {
                    hr = STHR( HrMatchNetwork( pccni, bstrNetName ) );
                    if ( hr == S_OK )
                    {
                        fFoundNetwork = true;
                        lr = ComboBox_SetCurSel( hwndCBIn, lrIndex );
                        Assert( lr != CB_ERR );
                    }
                }

                // Cleanup.
                TraceSysFreeString( bstrNetName );
                bstrNetName = NULL;

            } // if: name retrieved successfully
        } // if: network is public

        pccni->Release();
        pccni = NULL;
    } // forever

    if ( fFoundNetwork )
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    if ( punk != NULL )
    {
        punk->Release( );
    }
    if ( bstrNetName != NULL )
    {
        SysFreeString( bstrNetName );
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( peccn != NULL )
    {
        peccn->Release();
    }
    if ( pec != NULL )
    {
        pec->Release();
    }
    if ( pom != NULL )
    {
        pom->Release();
    }

    HRETURN( hr );

} //*** CIPSubnetPage::HrAddNetworksToComboBox( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CIPSubnetPage::HrMatchNetwork(
//      IClusCfgNetworkInfo *   pccniIn,
//      BSTR                    bstrNetworkNameIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CIPSubnetPage::HrMatchNetwork(
    IClusCfgNetworkInfo *   pccniIn,
    BSTR                    bstrNetworkNameIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr      = S_OK;
    IClusCfgIPAddressInfo * pccipai = NULL;
    ULONG                   ulIPAddress;
    ULONG                   ulIPSubnet;

    Assert( pccniIn != NULL );
    Assert( bstrNetworkNameIn != NULL );

    //
    // Get the IP Address Info for the network.
    //

    hr = THR( pccniIn->GetPrimaryNetworkAddress( &pccipai ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Get the address and subnet of the network.
    //

    hr = THR( pccipai->GetIPAddress( &ulIPAddress ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( pccipai->GetSubnetMask( &ulIPSubnet ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Determine if these match.
    //

    if ( ClRtlAreTcpipAddressesOnSameSubnet( *m_pulIPAddress, ulIPAddress, ulIPSubnet) )
    {
        // Save the subnet mask.
        *m_pulIPSubnet = ulIPSubnet;

        // Save the name of the network.
        if ( *m_pbstrNetworkName == NULL )
        {
            *m_pbstrNetworkName = TraceSysAllocString( bstrNetworkNameIn );
            if ( *m_pbstrNetworkName == NULL )
                goto OutOfMemory;
        }
        else
        {
            INT iRet = TraceSysReAllocString( m_pbstrNetworkName, bstrNetworkNameIn );
            if ( ! iRet )
                goto OutOfMemory;
        }
    } // if: match found
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    if ( pccipai != NULL )
    {
        pccipai->Release();
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** CIPSubnetPage::HrMatchNetwork( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  [static]
//  INT_PTR 
//  CALLBACK
//  CIPSubnetPage::S_DlgProc( 
//      HWND hDlgIn, 
//      UINT MsgIn, 
//      WPARAM wParam, 
//      LPARAM lParam 
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR 
CALLBACK
CIPSubnetPage::S_DlgProc( 
    HWND hDlgIn, 
    UINT MsgIn, 
    WPARAM wParam, 
    LPARAM lParam 
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CIPSubnetPage * pPage = reinterpret_cast< CIPSubnetPage *> ( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CIPSubnetPage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
        case WM_INITDIALOG:
            lr = pPage->OnInitDialog( );
            break;

        case WM_NOTIFY:
            lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
            break;

        case WM_COMMAND:
            lr= pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), (HWND) lParam );
            break;

        // no default clause needed
        }
    }

    return lr;

} //*** CIPSubnetPage::S_DlgProc( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\quorumdlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      QuorumDlg.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    03-APR-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "QuorumDlg.h"
#include "WizardUtils.h"


// provisional constant declaration until we figure out something better
#define UNKNOWN_QUORUM_UID L"Unknown Quorum"

DEFINE_THISCLASS("QuorumDlg");

//////////////////////////////////////////////////////////////////////////////
//  Static Function Prototypes
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::S_HrDisplayModalDialog
//
//  Description:
//      Display the dialog box.
//
//  Arguments:
//      hwndParentIn    - Parent window for the dialog box.
//      pspIn           - Service provider for talking to the middle tier.
//      pszClusterNameIn - Name of the cluster.
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CQuorumDlg::S_HrDisplayModalDialog(
      HWND                  hwndParentIn
    , IServiceProvider *    pspIn
    , BSTR                  bstrClusterNameIn
    )
{
    TraceFunc( "" );

    Assert( pspIn != NULL );
    Assert( bstrClusterNameIn != NULL );
    Assert( SysStringLen( bstrClusterNameIn ) > 0 );

    HRESULT hr = S_OK;
    INT_PTR dlgResult = IDOK;

    // Display the dialog.
    {
        CQuorumDlg  dlg( pspIn, bstrClusterNameIn );

        dlgResult = DialogBoxParam(
              g_hInstance
            , MAKEINTRESOURCE( IDD_QUORUM )
            , hwndParentIn
            , CQuorumDlg::S_DlgProc
            , (LPARAM) &dlg
            );

        if ( dlgResult == IDOK )
            hr = S_OK;
        else
            hr = S_FALSE;
    }

    HRETURN( hr );

} //*** CQuorumDlg::S_HrDisplayModalDialog()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  IsValidResource
//
//  Description:
//      Determines whether the resource is a valid selection as a quorum device.
//
//  Arguments:
//      pResourceIn    - the resource in question.
//
//  Return Values:
//      true        - the resource is valid.
//      false       - the resource is not valid.
//
//  Remarks:
//      A resource is valid if it is quorum capable and it is not an "unknown" quorum.
//
//--
//////////////////////////////////////////////////////////////////////////////

static bool IsValidResource( IClusCfgManagedResourceInfo * pResourceIn )
{
    TraceFunc( "" );
    
    bool    fValid = false;
    
    bool    fQuorumCapable = false;
    bool    fUnknownQuorum = false;

    BSTR    bstrDeviceID = NULL;
    
    HRESULT hr = S_OK;

    hr = STHR( pResourceIn->IsQuorumCapable() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    else
    {
        fQuorumCapable = ( hr == S_OK );
    }

    hr = THR( pResourceIn->GetUID( &bstrDeviceID ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    fUnknownQuorum = ( wcscmp( UNKNOWN_QUORUM_UID, bstrDeviceID ) == 0 );

    fValid = fQuorumCapable && ( !fUnknownQuorum );

Cleanup:

    if ( bstrDeviceID != NULL )
        SysFreeString( bstrDeviceID );

    RETURN( fValid );
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::CQuorumDlg
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pspIn           - Service provider for talking to the middle tier.
//      pszClusterNameIn - Name of the cluster.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CQuorumDlg::CQuorumDlg(
      IServiceProvider *    pspIn
    , BSTR                  bstrClusterNameIn
    ):
    m_rgpResources( NULL )
    , m_cValidResources( 0 )
    , m_idxQuorumResource( 0 )
    , m_hComboBox( NULL )
    , m_fQuorumAlreadySet( false )
{
    TraceFunc( "" );

    Assert( pspIn != NULL );
    Assert( bstrClusterNameIn != NULL );
    Assert( SysStringLen( bstrClusterNameIn ) > 0 );

    // m_hwnd
    m_psp = pspIn;
    m_psp->AddRef();
    m_bstrClusterName = bstrClusterNameIn;

    TraceFuncExit();

} //*** CQuorumDlg::CQuorumDlg()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::~CQuorumDlg
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
CQuorumDlg::~CQuorumDlg( void )
{
    TraceFunc( "" );

    size_t idxResource = 0;

    for ( idxResource = 0; idxResource < m_cValidResources; idxResource += 1 )
        m_rgpResources[ idxResource ]->Release();

    delete [] m_rgpResources;

    if ( m_psp != NULL )
    {
        m_psp->Release();
    }

    TraceFuncExit();

} //*** CQuorumDlg::~CQuorumDlg()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::S_DlgProc
//
//  Description:
//      Dialog proc for the Quorum dialog box.
//
//  Arguments:
//      hwndDlgIn   - Dialog box window handle.
//      nMsgIn      - Message ID.
//      wParam      - Message-specific parameter.
//      lParam      - Message-specific parameter.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//  Remarks:
//      It is expected that this dialog box is invoked by a call to
//      DialogBoxParam() with the lParam argument set to the address of the
//      instance of this class.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CQuorumDlg::S_DlgProc(
      HWND      hwndDlgIn
    , UINT      nMsgIn
    , WPARAM    wParam
    , LPARAM    lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT         lr = FALSE;
    CQuorumDlg *    pdlg;

    //
    // Get a pointer to the class.
    //

    if ( nMsgIn == WM_INITDIALOG )
    {
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, lParam );
        pdlg = reinterpret_cast< CQuorumDlg * >( lParam );
        pdlg->m_hwnd = hwndDlgIn;
    }
    else
    {
        pdlg = reinterpret_cast< CQuorumDlg * >( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );
    }

    if ( pdlg != NULL )
    {
        Assert( hwndDlgIn == pdlg->m_hwnd );

        switch( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pdlg->OnInitDialog();
                break;

            case WM_COMMAND:
                lr = pdlg->OnCommand( HIWORD( wParam ), LOWORD( wParam ), reinterpret_cast< HWND >( lParam ) );
                break;

            // no default clause needed
        } // switch: nMsgIn
    } // if: page is specified

    return lr;

} //*** CQuorumDlg::S_DlgProc()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::OnInitDialog
//
//  Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        Focus has been set.
//      FALSE       Focus has not been set.
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CQuorumDlg::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE; // did set focus
    HWND    hComboBox = NULL;

    HRESULT hr = S_OK;
    DWORD   sc;
    size_t  idxResource = 0;
    BSTR    bstrResourceName = NULL;

    // create resource list
    hr = THR( HrCreateResourceList() );
    if ( FAILED( hr ) )
        goto Error;

    // get combo box handle
    m_hComboBox = GetDlgItem( m_hwnd, IDC_QUORUM_CB_QUORUM );
    if ( m_hComboBox == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Error;
    }
    
    // fill combo box
    for ( idxResource = 0 ; idxResource < m_cValidResources ; idxResource++ )
    {
        hr = THR( m_rgpResources[ idxResource ]->GetName( &bstrResourceName ) );
        if ( FAILED( hr ) )
        {
            goto Error;
        }
        TraceMemoryAddBSTR( bstrResourceName );
        
        sc = (DWORD) SendMessage( m_hComboBox, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>( bstrResourceName ) );
        if ( ( sc == CB_ERR ) || ( sc == CB_ERRSPACE ) )
        {
            hr = HRESULT_FROM_WIN32( TW32( sc ) );
            goto Error;
        }
        TraceSysFreeString( bstrResourceName );
        bstrResourceName = NULL;
        
        //  - remember which is quorum resource
        hr = STHR( m_rgpResources[ idxResource ]->IsQuorumDevice() );
        if ( FAILED( hr ) )
        {
            goto Error;
        }
        else if ( hr == S_OK )
        {
            m_idxQuorumResource = idxResource;
            m_fQuorumAlreadySet = true;
        }
    } // for: each resource
    
    // set combo box selection to current quorum resource
    sc = (DWORD) SendMessage( m_hComboBox, CB_SETCURSEL, m_idxQuorumResource, 0 );
    if ( sc == CB_ERR )
    {
        hr = HRESULT_FROM_WIN32( TW32( sc ) );
        goto Error;
    }
    
    //
    // Update the buttons based on what is selected.
    //

    UpdateButtons();

    //
    // Set focus to the combo box.
    //

    SetFocus( m_hComboBox );

    goto Cleanup;

Error:

    HrMessageBoxWithStatus(
          m_hwnd
        , IDS_ERR_RESOURCE_GATHER_FAILURE_TITLE
        , IDS_ERR_RESOURCE_GATHER_FAILURE_TEXT
        , hr
        , 0
        , MB_OK | MB_ICONERROR
        , 0
        );
        
    EndDialog( m_hwnd, IDCANCEL ); // show message box?
    lr = FALSE;
    goto Cleanup;

Cleanup:

    TraceSysFreeString( bstrResourceName );
        
    RETURN( lr );

} //*** CQuorumDlg::OnInitDialog()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::OnCommand
//
//  Description:
//      Handler for the WM_COMMAND message.
//
//  Arguments:
//      idNotificationIn    - Notification code.
//      idControlIn         - Control ID.
//      hwndSenderIn        - Handle for the window that sent the message.
//
//  Return Values:
//      TRUE        - Message has been handled.
//      FALSE       - Message has not been handled yet.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CQuorumDlg::OnCommand(
      UINT  idNotificationIn
    , UINT  idControlIn
    , HWND  hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;
    size_t  idxCurrentSelection = 0;
    HRESULT hr = S_OK;

    switch ( idControlIn )
    {
        case IDOK:
        
            // get selection from combo box
            idxCurrentSelection = SendMessage( m_hComboBox, CB_GETCURSEL, 0, 0 );
            if ( idxCurrentSelection == CB_ERR )
            {
                hr = HRESULT_FROM_WIN32( TW32( CB_ERR ) );
                goto Error;
            }
            
            // if original quorum resource is different, or had not been set,
            if ( ( idxCurrentSelection != m_idxQuorumResource ) || !m_fQuorumAlreadySet )
            {
                //  - clear original quorum resource
                hr = THR( m_rgpResources[ m_idxQuorumResource ]->SetQuorumedDevice( FALSE ) );
                if ( FAILED( hr ) )
                {
                    goto Error;
                }
                
                //  - set new quorum resource
                hr = THR( m_rgpResources[ idxCurrentSelection ]->SetQuorumedDevice( TRUE ) );
                if ( FAILED( hr ) )
                {
                    // try to restore previous state
                    THR( m_rgpResources[ m_idxQuorumResource ]->SetQuorumedDevice( TRUE ) );
                    goto Error;
                }
                
                hr = THR( m_rgpResources[ idxCurrentSelection ]->SetManaged( TRUE ) );
                if ( FAILED( hr ) )
                {
                    // try to restore previous state
                    THR( m_rgpResources[ idxCurrentSelection ]->SetQuorumedDevice( FALSE ) );
                    THR( m_rgpResources[ m_idxQuorumResource ]->SetQuorumedDevice( TRUE ) );
                    goto Error;
                }
                
                //  - end with IDOK
                EndDialog( m_hwnd, IDOK );
            }
            else // (combo box selection is same as original)
            {
                //  - end with IDCANCEL
                EndDialog( m_hwnd, IDCANCEL );
            }
            break;
            
        case IDCANCEL:
            EndDialog( m_hwnd, IDCANCEL );
            break;

    } // switch: idControlIn

    goto Cleanup;

Error:

    HrMessageBoxWithStatus(
          m_hwnd
        , IDS_ERR_QUORUM_COMMIT_FAILURE_TITLE
        , IDS_ERR_QUORUM_COMMIT_FAILURE_TEXT
        , hr
        , 0
        , MB_OK | MB_ICONERROR
        , 0
        );

    goto Cleanup;

Cleanup:

    RETURN( lr );

} //*** CQuorumDlg::OnCommand()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CQuorumDlg::HrCreateResourceList
//
//  Description:
//      Allocates and fills m_rgpResources array with quorum capable and
//      joinable resources, and sets m_idxQuorumResource to the index of the
//      resource that's currently the quorum resource.
//
//      Supposedly at least one quorum capable and joinable resource always
//      exists, and exactly one is marked as the quorum resource.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK            - Success.
//      S_FALSE         - Didn't find current quorum resource.
//      E_OUTOFMEMORY   - Couldn't allocate memory for the list.
//      
//      Other possible error values from called methods.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CQuorumDlg::HrCreateResourceList( void )
{
    TraceFunc( "" );
    
    HRESULT hr = S_OK;

    IObjectManager * pom    = NULL;
    IUnknown * punkEnum     = NULL;
    IUnknown * punkCluster  = NULL;
    
    IEnumClusCfgManagedResources * peccmr    = NULL;
    
    OBJECTCOOKIE    cookieDummy;
    OBJECTCOOKIE    cookieCluster;
    size_t          idxResCurrent = 0;
    ULONG           cFetchedResources = 0;
    DWORD           cTotalResources = 0;

    
    //
    // get object manager from service provider
    //
    Assert( m_psp != NULL );
    hr = THR( m_psp->TypeSafeQS( CLSID_ObjectManager, IObjectManager, &pom ) );

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // get resource enumerator from object manager
    //
    hr = THR( pom->FindObject( CLSID_ClusterConfigurationType,
                               NULL,
                               m_bstrClusterName,
                               DFGUID_ClusterConfigurationInfo,
                               &cookieCluster,
                               &punkCluster
                               ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pom->FindObject( CLSID_ManagedResourceType,
                               cookieCluster,
                               NULL,
                               DFGUID_EnumManageableResources,
                               &cookieDummy,
                               &punkEnum
                               ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punkEnum->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // find out how many resources exist
    //
    hr = THR( peccmr->Count( &cTotalResources ) );    
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // allocate memory for resources
    //
    m_rgpResources = new IClusCfgManagedResourceInfo*[ cTotalResources ];
    if ( m_rgpResources == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }
    for ( idxResCurrent = 0 ; idxResCurrent < cTotalResources ; idxResCurrent++ )
    {
        m_rgpResources[ idxResCurrent ] = NULL;
    }

    //
    // copy resources into array
    //
    hr = THR( peccmr->Next( cTotalResources, m_rgpResources, &cFetchedResources ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    Assert( cFetchedResources == cTotalResources ); // if not, something's wrong with the enum
    cTotalResources = min( cTotalResources, cFetchedResources ); // playing it safe
    
    //
    // filter out invalid resources
    //
    for ( idxResCurrent = 0 ; idxResCurrent < cTotalResources ; idxResCurrent++ )
    {
        if ( !IsValidResource( m_rgpResources[ idxResCurrent ] ) )
        {        
            m_rgpResources[ idxResCurrent ]->Release();
            m_rgpResources[ idxResCurrent ] = NULL;
        }
    }

    //
    // compact array; might leave some non-null pointers after end,
    //  so always use m_cValidResources to determine length hereafter
    //
    for ( idxResCurrent = 0 ; idxResCurrent < cTotalResources ; idxResCurrent++ )
    {
        if ( m_rgpResources[ idxResCurrent ] != NULL )
        {
            m_rgpResources[ m_cValidResources++ ] = m_rgpResources[ idxResCurrent ];
        }
    }

Cleanup:

    if ( pom != NULL )
    {
        pom->Release();
    }

    if ( punkCluster != NULL )
    {
        punkCluster->Release();
    }

    if ( punkEnum != NULL )
    {
        punkEnum->Release();
    }

    if ( peccmr != NULL )
    {
        peccmr->Release();
    }

    HRETURN( hr );

} //*** CQuorumDlg::HrCreateResourceList()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CDetailsDlg::UpdateButtons
//
//  Description:
//      Update the OK and Cancel buttons.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CQuorumDlg::UpdateButtons( void )
{
    TraceFunc( "" );

    BOOL    fEnableOK;
    LRESULT lrCurSel;

    lrCurSel = SendMessage( GetDlgItem( m_hwnd, IDC_QUORUM_CB_QUORUM ),  CB_GETCURSEL, 0, 0 );

    fEnableOK = ( lrCurSel != CB_ERR );

    EnableWindow( GetDlgItem( m_hwnd, IDOK ), fEnableOK );

} //*** CQuorumDlg::UpdateButtons()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ClusCfgWizard.rc
//
#define IDD_WELCOME_CREATE              1001
#define IDD_WELCOME_ADD                 1002
#define IDD_CLUSDOMAIN                  1003
#define IDD_CHECKINGACCESS              1004
#define IDD_CREDLOGIN                   1005
#define IDD_SELNODE                     1006
#define IDD_SELNODES                    1007
#define IDD_ANALYZE                     1008
#define IDD_IPADDRESS                   1009
#define IDD_IPSUBNET                    1010
#define IDD_CSACCOUNT                   1011
#define IDD_SUMMARY                     1012
#define IDD_COMMIT                      1013
#define IDD_COMPLETION                  1014

#define IDD_DETAILS                     1020
#define IDD_QUORUM                      1021

#define IDI_PENDING                     1101
#define IDI_SEL                         1102
#define IDI_CHECK                       1103
#define IDI_QUEST                       1104
#define IDI_INFO                        1105
#define IDI_FAIL                        1106
#define IDI_WARN                        1107
#define IDI_PREVIOUS                    1108
#define IDI_NEXT                        1109
#define IDI_PREVIOUS_HC                 1110
#define IDI_NEXT_HC                     1111
#define IDI_COPY                        1112
#define IDB_BANNER                      1201
#define IDB_WATERMARK                   1202

#define IDC_WELCOME_S_TITLE                 1500
#define IDC_WELCOME_S_DESC_1                1501
#define IDC_WELCOME_S_DESC_2                1502
#define IDC_WELCOME_S_REQ_TITLE             1503
#define IDC_WELCOME_S_REQUIREMENTS          1504
#define IDC_WELCOME_S_CLICK_NEXT            1509

#define IDC_CLUSDOMAIN_S_DOMAIN_DESC        1520
#define IDC_CLUSDOMAIN_S_DOMAIN             1521
#define IDC_CLUSDOMAIN_CB_DOMAIN            1522
#define IDC_CLUSDOMAIN_S_CLUSTERNAME_DESC   1523
#define IDC_CLUSDOMAIN_S_CLUSTERNAME        1524
#define IDC_CLUSDOMAIN_E_CLUSTERNAME        1525

#define IDC_CHECKINGACCESS_S_DESC           1530
#define IDC_CHECKINGACCESS_PRG_STATUS       1531

#define IDC_CREDLOGIN_S_DESC                1540
#define IDC_CREDLOGIN_S_USERNAME            1541
#define IDC_CREDLOGIN_E_USERNAME            1542
#define IDC_CREDLOGIN_S_PASSWORD            1543
#define IDC_CREDLOGIN_E_PASSWORD            1544
#define IDC_CREDLOGIN_S_DOMAIN              1545
#define IDC_CREDLOGIN_CB_DOMAIN              1546

#define IDC_SELNODE_S_DESC                  1550
#define IDC_SELNODE_S_COMPUTERNAME          1551
#define IDC_SELNODE_E_COMPUTERNAME          1552
#define IDC_SELNODE_PB_BROWSE               1553
#define IDC_SELNODE_S_NODES                 1554
#define IDC_SELNODE_LB_NODES                1555
#define IDC_SELNODE_PB_ADD                  1556
#define IDC_SELNODE_PB_REMOVE               1557

#define IDC_ANALYZE_TV_TASKS                1560
#define IDC_ANALYZE_S_STATUS                1561
#define IDC_ANALYZE_PRG_STATUS              1562
#define IDC_ANALYZE_S_RESULTS               1563
#define IDC_ANALYZE_PB_VIEW_LOG             1564
#define IDC_ANALYZE_PB_DETAILS              1565
#define IDC_ANALYZE_PB_REANALYZE            1566

#define IDC_IPADDRESS_S_ADDRESS             1570
#define IDC_IPADDRESS_IP_ADDRESS            1571

#define IDC_CSACCOUNT_S_DESC                1580
#define IDC_CSACCOUNT_S_USERNAME            1581
#define IDC_CSACCOUNT_E_USERNAME            1582
#define IDC_CSACCOUNT_S_PASSWORD            1583
#define IDC_CSACCOUNT_E_PASSWORD            1584
#define IDC_CSACCOUNT_S_DOMAIN              1585
#define IDC_CSACCOUNT_CB_DOMAIN             1586
#define IDC_CSACCOUNT_I_LAWARN              1588
#define IDC_CSACCOUNT_S_LAWARN              1587

#define IDC_SUMMARY_RE_SUMMARY              1590
#define IDC_SUMMARY_S_NEXT                  1591
#define IDC_SUMMARY_PB_VIEW_LOG             1592
#define IDC_SUMMARY_PB_QUORUM               1593

#define IDC_COMMIT_TV_TASKS                 1600
#define IDC_COMMIT_S_STATUS                 1601
#define IDC_COMMIT_PRG_STATUS               1602
#define IDC_COMMIT_S_RESULTS                1603
#define IDC_COMMIT_PB_VIEW_LOG              1604
#define IDC_COMMIT_PB_DETAILS               1605
#define IDC_COMMIT_PB_RETRY                 1606

#define IDC_COMPLETION_S_TITLE              1610
#define IDC_COMPLETION_S_DESC               1611
#define IDC_COMPLETION_PB_VIEW_LOG          1612
#define IDC_COMPLETION_S_NEXT               1613

#define IDC_DETAILS_S_DATE                  1620
#define IDC_DETAILS_E_DATE                  1621
#define IDC_DETAILS_S_TIME                  1622
#define IDC_DETAILS_E_TIME                  1623
#define IDC_DETAILS_S_COMPUTER              1624
#define IDC_DETAILS_E_COMPUTER              1625
#define IDC_DETAILS_S_MAJOR_ID              1626
#define IDC_DETAILS_E_MAJOR_ID              1627
#define IDC_DETAILS_S_MINOR_ID              1628
#define IDC_DETAILS_E_MINOR_ID              1629
#define IDC_DETAILS_PB_PREV                 1630
#define IDC_DETAILS_PB_NEXT                 1631
#define IDC_DETAILS_PB_COPY                 1632
#define IDC_DETAILS_S_DESCRIPTION           1633
#define IDC_DETAILS_RE_DESCRIPTION          1634
#define IDC_DETAILS_S_STATUS                1635
#define IDC_DETAILS_E_STATUS                1636
#define IDC_DETAILS_I_STATUS                1637
#define IDC_DETAILS_RE_STATUS               1638
#define IDC_DETAILS_S_REFERENCE             1639
#define IDC_DETAILS_RE_REFERENCE            1640

#define IDC_QUORUM_S_QUORUM                 1650
#define IDC_QUORUM_CB_QUORUM                1651

#define IDS_LARGEFONTNAME               2000
#define IDS_LARGEFONTSIZE               2001

#define IDS_TITLE_FORM                  2002
#define IDS_TITLE_JOIN                  2003
#define IDS_TCLUSTER                    2004
#define IDS_STCLUSTER_CREATE            2005
#define IDS_STCLUSTER_ADD               2006
#define IDS_TCHECKINGACCESS             2007
#define IDS_STCHECKINGACCESS            2008
#define IDS_TCREDLOGIN                  2009
#define IDS_STCREDLOGIN                 2010
#define IDS_TSELNODE                    2011
#define IDS_STSELNODE                   2012
#define IDS_TSELNODES                   2013
#define IDS_STSELNODES                  2014
#define IDS_TANALYZE                    2015
#define IDS_STANALYZE                   2016
#define IDS_TIPADDRESS                  2017
#define IDS_STIPADDRESS                 2018
#define IDS_TIPADDRESS2                 2019
#define IDS_STIPADDRESS2                2020
#define IDS_TCSACCOUNT                  2021
#define IDS_STCSACCOUNT                 2022
#define IDS_TSUMMARY                    2023
#define IDS_STSUMMARY_CREATE            2024
#define IDS_STSUMMARY_ADD               2025
#define IDS_TCOMMIT_CREATE              2026
#define IDS_TCOMMIT_ADD                 2027
#define IDS_STCOMMIT                    2028
#define IDS_QUERY_CANCEL_TITLE          2029
#define IDS_QUERY_CANCEL_TEXT           2030
#define IDS_TASKS_COMPLETED             2031

#define IDS_DOMAIN_DESC_CREATE          2040
#define IDS_DOMAIN_DESC_ADD             2041
#define IDS_SUMMARY_NEXT_CREATE         2042
#define IDS_SUMMARY_NEXT_ADD            2043
#define IDS_COMPLETION_TITLE_CREATE     2044
#define IDS_COMPLETION_TITLE_ADD        2045
#define IDS_COMPLETION_DESC_CREATE      2046
#define IDS_COMPLETION_DESC_ADD         2047

#define IDS_WELCOME_CREATE_REQ_1                            2050
#define IDS_WELCOME_CREATE_REQ_2                            2051
#define IDS_WELCOME_CREATE_REQ_3                            2052
#define IDS_WELCOME_CREATE_REQ_4                            2053
#define IDS_WELCOME_CREATE_REQ_5                            2054
#define IDS_WELCOME_ADD_REQ_1                               2055
#define IDS_WELCOME_ADD_REQ_2                               2056

#define IDS_ANALYSIS_SUCCESSFUL_INSTRUCTIONS                2060
#define IDS_ANALYSIS_FAILED_INSTRUCTIONS                    2061
#define IDS_ANALYSIS_STARTING_INSTRUCTIONS                  2062
#define IDS_COMMIT_SUCCESSFUL_INSTRUCTIONS                  2063
#define IDS_COMMIT_FAILED_INSTRUCTIONS_BACK_ENABLED         2064
#define IDS_COMMIT_FAILED_INSTRUCTIONS                      2065
#define IDS_COMMIT_SUCCESSFUL_INSTRUCTIONS_BACK_DISABLED    2066

#define IDS_DEFAULT_DETAILS_REFERENCE                       2067

#define IDS_DETAILS_CLP_DATE                                2070
#define IDS_DETAILS_CLP_TIME                                2071
#define IDS_DETAILS_CLP_COMPUTER                            2072
#define IDS_DETAILS_CLP_MAJOR                               2073
#define IDS_DETAILS_CLP_MINOR                               2074
#define IDS_DETAILS_CLP_DESC                                2075
#define IDS_DETAILS_CLP_STATUS                              2076
#define IDS_DETAILS_CLP_INFO                                2077

#define IDS_CANNOT_FIND_MATCHING_NETWORK_TITLE              2080
#define IDS_CANNOT_FIND_MATCHING_NETWORK_TEXT               2081

#define IDS_UNKNOWN_TASK                                    2100

#define IDS_TASKID_MAJOR_CHECKING_FOR_EXISTING_CLUSTER      2101
#define IDS_TASKID_MAJOR_ESTABLISH_CONNECTION               2102
#define IDS_TASKID_MAJOR_CHECK_NODE_FEASIBILITY             2103
#define IDS_TASKID_MAJOR_FIND_DEVICES                       2104
#define IDS_TASKID_MAJOR_CHECK_CLUSTER_FEASIBILITY          2105
#define IDS_TASKID_MAJOR_REANALYZE                          2106
#define IDS_TASKID_MAJOR_CONFIGURE_CLUSTER_SERVICES         2107
#define IDS_TASKID_MAJOR_CONFIGURE_RESOURCE_TYPES           2108
#define IDS_TASKID_MAJOR_CONFIGURE_RESOURCES                2109

#define IDS_TASKID_MINOR_CONNECTING_TO_NODES                2120
#define IDS_TASKID_MINOR_CHECKING_NODE_CLUSTER_FEASIBILITY  2121
#define IDS_TASKID_MINOR_GATHERING_MANAGED_DEVICES          2122
#define IDS_TASKID_MINOR_FORMING_NODE                       2125
#define IDS_TASKID_MINOR_JOINING_NODE                       2126
#define IDS_TASKID_MINOR_FOUND_DEVICE                       2127
#define IDS_TASKID_MINOR_NO_QUORUM_CAPABLE_DEVICE_FOUND     2128
#define IDS_TASKID_MINOR_CLUSTER_NAME_MISMATCH              2129
#define IDS_TASKID_MINOR_FOUND_QUORUM_CAPABLE_DEVICE        2130
#define IDS_TASKID_MINOR_INCONSISTANT_MIDDLETIER_DATABASE   2131
#define IDS_TASKID_MINOR_CLUSTER_NOT_FOUND                  2132
#define IDS_TASKID_MINOR_EXISTING_CLUSTER_FOUND             2133
#define IDS_TASKID_MINOR_ERROR_CONTACTING_CLUSTER           2134
#define IDS_TASKID_MINOR_CLUSTER_MEMBERSHIP_VERIFIED        2135
#define IDS_TASKID_MINOR_FORCED_LOCAL_QUORUM                2136
#define IDS_TASKID_MINOR_MISSING_COMMON_QUORUM_RESOURCE     2137
#define IDS_TASKID_MINOR_FOUND_COMMON_QUORUM_RESOURCE       2138
#define IDS_TASKID_MINOR_RESOURCE_CAPABILITIES_DONT_MATCH   2139
#define IDS_TASKID_MINOR_SELECTED_QUORUM_RESOURCE           2140
#define IDS_TASKID_MINOR_NO_MANAGED_RESOURCES_FOUND         2141
#define IDS_TASKID_MINOR_NO_MANAGED_NETWORKS_FOUND          2142
#define IDS_TASKID_MINOR_POLLING_CONNECTION_FAILURE         2143
#define IDS_TASKID_MINOR_FOUND_QUORUM_CAPABLE_RESOURCE      2144
#define IDS_TASKID_MINOR_DUPLICATE_NETWORKS_FOUND           2145
#define IDS_TASKID_MINOR_BAD_CREDENTIALS                    2146
#define IDS_TASKID_MINOR_NODES_VERSION_MISMATCH             2147
#define IDS_TASKID_MINOR_CHECKINTEROPERABILITY              2148
#define IDS_TASKID_MINOR_NO_JOINING_NODES_FOUND_FOR_VERSION_CHECK 2149
#define IDS_TASKID_MINOR_FAILED_TO_CONNECT_TO_NODE          2150
#define IDS_TASKID_MINOR_FQDN_DNS_BINDING_FAILED            2151
#define IDS_TASKID_MINOR_NETBIOS_NAME_CONVERSION_FAILED     2152
#define IDS_TASKID_MINOR_NETBIOS_RESET_FAILED               2153
#define IDS_TASKID_MINOR_NETBIOS_BINDING_SUCCEEDED          2154
#define IDS_TASKID_MINOR_NETBIOS_BINDING_FAILED             2155
#define IDS_TASKID_MINOR_NETBIOS_NAME_CONVERSION_SUCCEEDED  2156
#define IDS_TASKID_MINOR_MULTIPLE_DNS_RECORDS_FOUND         2157
#define IDS_TASKID_MINOR_FQDN_DNS_BINDING_SUCCEEDED         2158
#define IDS_TASKID_MINOR_MARKING_QUORUM_CAPABLE_RESOURCE    2159
#define IDS_TASKID_MINOR_MISSING_JOINABLE_QUORUM_RESOURCE   2160
#define IDS_TASKID_MINOR_NETBIOS_LANAENUM_FAILED            2161
#define IDS_TASKID_MINOR_REMOTE_CONNECTION_REQUESTS         2162
#define IDS_TASKID_MINOR_REQUESTING_REMOTE_CONNECTION       2163
#define IDS_TASKID_MINOR_NODE_ALREADY_IS_MEMBER             2164
#define IDS_TASKID_MINOR_ONLY_ONE_NETWORK                   2165
#define IDS_TASKID_MINOR_FINDING_COMMON_QUORUM_DEVICE       2166
#define IDS_TASKID_MINOR_NODE_CANNOT_ACCESS_QUORUM          2167
#define IDS_TASKID_MINOR_NO_NODES_TO_PROCESS                2168

#define IDS_ERR_NO_SUCH_DOMAIN_TITLE                        2201
#define IDS_ERR_NO_SUCH_DOMAIN_TEXT                         2202
#define IDS_ERR_INVALID_DNS_DOMAIN_NAME_TITLE               2203
#define IDS_ERR_INVALID_DNS_DOMAIN_NAME_TEXT                2204
#define IDS_ERR_VALIDATING_NAME_TITLE                       2205
#define IDS_ERR_VALIDATING_NAME_TEXT                        2206
#define IDS_ERR_INVOKING_LINK_TITLE                         2207
#define IDS_ERR_INVOKING_LINK_TEXT                          2208
#define IDS_ERR_IPADDRESS_ALREADY_PRESENT_TEXT              2209
#define IDS_ERR_IPADDRESS_ALREADY_PRESENT_TITLE             2210
#define IDS_ERR_VIEW_LOG_TITLE                              2211
#define IDS_ERR_VIEW_LOG_TEXT                               2212
#define IDS_ERR_WRITE_CREDENTIAL_TITLE                      2213
#define IDS_ERR_WRITE_CREDENTIAL_TEXT                       2214

#define IDS_ERR_INVALID_DNS_NAME_TEXT                       2220
#define IDS_ERR_FULL_DNS_NAME_INFO_TEXT                     2221
#define IDS_ERR_DNS_HOSTNAME_LABEL_INFO_TEXT                2222
#define IDS_ERR_NON_RFC_NAME_QUERY                          2223
#define IDS_ERR_DNS_NAME_INVALID_CHAR                       2224
#define IDS_ERR_DNS_HOSTNAME_LABEL_NUMERIC                  2225
#define IDS_ERR_FULL_DNS_NAME_NUMERIC                       2226
#define IDS_ERR_TGI_FAILED_TRY_TO_REANALYZE                 2227
#define IDS_ERR_ANALYSIS_FAILED_TRY_TO_REANALYZE            2228
#define IDS_TASK_RETURNED_ERROR                             2229
#define IDS_ERR_HOST_DOMAIN_DOESNT_MATCH_CLUSTER            2230

#define IDS_CLUSTERIPADDRESS                                2300
#define IDS_GROUP_X                                         2301
#define IDS_QUORUMRESOURCE                                  2302
#define IDS_LOCALQUORUM                                     2303
#define IDS_NETNAMEFORMAT                                   2304
#define IDS_IPADDRESSFORMAT                                 2305

#define IDS_SUMMARY_CLUSTER_NAME                            2350
#define IDS_SUMMARY_IPADDRESS                               2351
#define IDS_SUMMARY_CREDENTIALS                             2352
#define IDS_SUMMARY_MEMBERSHIP_BEGIN                        2353
#define IDS_SUMMARY_RESOURCES_BEGIN                         2354
#define IDS_SUMMARY_RESOURCE_QUORUM_DEVICE                  2355
#define IDS_SUMMARY_RESOURCE_MANAGED                        2356
#define IDS_SUMMARY_RESOURCE_NOT_MANAGED                    2357
#define IDS_SUMMARY_RESOURCES_END                           2358
#define IDS_SUMMARY_NETWORKS_BEGIN                          2359
#define IDS_SUMMARY_NETWORKS_END                            2360
#define IDS_SUMMARY_NETWORK_INFO                            2361
#define IDS_SUMMARY_NETWORK_PRIVATE                         2362
#define IDS_SUMMARY_NETWORK_BOTH                            2363
#define IDS_SUMMARY_NETWORK_NOTUSED                         2364
#define IDS_SUMMARY_NETWORK_PUBLIC                          2365
#define IDS_SUMMARY_MEMBERSHIP_SEPARATOR                    2366
#define IDS_SUMMARY_MEMBERSHIP_END                          2367
#define IDS_SUMMARY_CLUSTER_NETWORK                         2368
#define IDS_ERR_RESOURCE_GATHER_FAILURE_TITLE               2369
#define IDS_ERR_RESOURCE_GATHER_FAILURE_TEXT                2370
#define IDS_ERR_QUORUM_COMMIT_FAILURE_TITLE                 2371
#define IDS_ERR_QUORUM_COMMIT_FAILURE_TEXT                  2372

#define IDS_FORMAT_STATUS                                   2400
#define IDS_FORMAT_LOG_MESSAGE                              2401

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2103
#define _APS_NEXT_COMMAND_VALUE         2600
#define _APS_NEXT_CONTROL_VALUE         1535
#define _APS_NEXT_SYMED_VALUE           2800
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\selnodebasepage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      WizardUtils.h
//
//  Maintained By:
//      David Potter    (DavidP)    30-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// Options for HrValidateDnsHostname()
enum EValidateDnsHostnameOptions
{
      mvdhoALLOW_FULL_NAME           = 1
    , mvdhoALLOW_ONLY_HOSTNAME_LABEL = 0
};

HRESULT
HrValidateDnsHostname(
      HWND                          hwndParentIn
    , LPCWSTR                       pcwszHostnameIn
    , EValidateDnsHostnameOptions   emvdhoOptions
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\selnodepage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      SelNodePage.h
//
//  Maintained By:
//      David Potter    (DavidP)    31-JAN-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSelNodePage
//
//  Description:
//
//--
//////////////////////////////////////////////////////////////////////////////
class CSelNodePage
{
friend class CClusCfgWizard;

private: // data
    HWND                m_hwnd;                 // Our HWND
    IServiceProvider *  m_psp;                  // Service Manager
    ULONG *             m_pcCount;              // Count of computers in list
    BSTR **             m_prgbstrComputerName;  // List of computer names
    BSTR *              m_pbstrClusterName;     // Cluster name
    UINT                m_cfDsObjectPicker;     // Object picker clipboard format

private: // methods
    CSelNodePage( IServiceProvider *    pspIn,
                  ECreateAddMode        ecamCreateAddModeIn,
                  ULONG *               pcCountInout,
                  BSTR **               prgbstrComputersInout,
                  BSTR *                pbstrClusterNameIn
                  );
    virtual ~CSelNodePage();

    LRESULT
        OnInitDialog( HWND hDlgIn );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT
        OnNotifyQueryCancel( void );
    LRESULT
        OnNotifyWizNext( void );
    LRESULT
        OnNotifySetActive( void );
    LRESULT
        OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT
        HrUpdateWizardButtons( void );
    HRESULT
        HrBrowse( void );
    HRESULT
        HrInitObjectPicker( IDsObjectPicker * piopIn );
    HRESULT
        HrGetSelection( IDataObject * pidoIn );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

};  // class CSelNodePage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\selnodepage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      SelNodePage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    31-JAN-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "SelNodePage.h"
#include "WizardUtils.h"

DEFINE_THISCLASS("CSelNodePage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::CSelNodePage
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pspIn                   -- IServiceProvider
//      ecamCreateAddModeIn     -- Creating cluster or adding nodes to cluster.
//      pcCountInout            -- Count of computers in prgbstrComputersInout
//      prgbstrComputersInout   -- Array of computers
//      pbstrClusterNameIn      -- Name of the cluster
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
CSelNodePage::CSelNodePage(
    IServiceProvider *  pspIn,
    ECreateAddMode      ecamCreateAddModeIn,
    ULONG *             pcCountInout,
    BSTR **             prgbstrComputersInout,
    BSTR *              pbstrClusterNameIn
    )
{
    TraceFunc( "" );

    Assert( pspIn != NULL );
    Assert( pcCountInout != NULL );
    Assert( prgbstrComputersInout != NULL );
    Assert( pbstrClusterNameIn != NULL );

    //  m_hwnd
    THR( pspIn->TypeSafeQI( IServiceProvider, &m_psp ) );
    m_pcCount             = pcCountInout;
    m_prgbstrComputerName = prgbstrComputersInout;
    m_pbstrClusterName    = pbstrClusterNameIn;
    m_cfDsObjectPicker    = 0;

    TraceFuncExit();

} //*** CSelNodePage::CSelNodePage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::~CSelNodePage
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
CSelNodePage::~CSelNodePage( void )
{
    TraceFunc( "" );

    if ( m_psp != NULL )
    {
        m_psp->Release();
    }

    TraceFuncExit();

} //*** CSelNodePage::~CSelNodePage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::OnInitDialog
//
//  Description:
//      Handle the WM_INITDIALOG window message.
//
//  Arguments:
//      hDlgIn
//
//  Return Values:
//      FALSE   - Didn't set the focus.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodePage::OnInitDialog(
    HWND hDlgIn
    )
{
    TraceFunc( "" );

    BSTR    bstrComputerName = NULL;

    LRESULT lr = FALSE; // Didn't set the focus.

    HRESULT hr;

    if (    ( *m_prgbstrComputerName != NULL )
        &&  ( *m_pcCount == 1 )
        &&  ( (*m_prgbstrComputerName)[ 0 ] != NULL )
        )
    {
        SetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, (*m_prgbstrComputerName)[ 0 ] );
    }
    else
    {
        DWORD dwStatus;
        DWORD dwClusterState;

        //
        //  If the node is already in a cluster, don't have it default in the edit box.
        //  If there is an error getting the "NodeClusterState", then default the node
        //  name (it could be in the middle of cleaning up the node).
        //

        dwStatus = TW32( GetNodeClusterState( NULL, &dwClusterState ) );
        if (    ( dwStatus != ERROR_SUCCESS )
            ||  ( dwClusterState == ClusterStateNotConfigured ) )
        {
            hr = THR( HrGetComputerName( ComputerNameDnsHostname, &bstrComputerName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }

        SetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, bstrComputerName );
    } // else: no computer was specified

    m_cfDsObjectPicker = RegisterClipboardFormat( CFSTR_DSOP_DS_SELECTION_LIST );
    if ( m_cfDsObjectPicker == 0 )
    {
        DWORD   sc;

        //
        //  TODO:   5-JUL-2000  GalenB
        //
        //  Need to log this?
        //
        sc = TW32( GetLastError() );

        EnableWindow( GetDlgItem( hDlgIn, IDC_SELNODE_PB_BROWSE ), FALSE );
    } // if:

Cleanup:
    TraceSysFreeString( bstrComputerName );

    RETURN( lr );

} //*** CSelNodePage::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::OnCommand
//
//  Description:
//
//  Arguments:
//      idNotificationIn
//      idControlIn
//      hwndSenderIn
//
//  Return Values:
//      TRUE
//      FALSE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodePage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_SELNODE_E_COMPUTERNAME:
            if ( idNotificationIn == EN_CHANGE )
            {
                THR( HrUpdateWizardButtons() );
                lr = TRUE;
            }
            break;

        case IDC_SELNODE_PB_BROWSE:
            if ( idNotificationIn == BN_CLICKED )
            {
                //
                //  TODO:   26-JUN-2000 GalenB
                //
                //  Need to set lr properly.
                //
                THR( HrBrowse() );
                lr = TRUE;
            }
            break;
    } // switch: idControlIn

    RETURN( lr );

} //*** CSelNodePage::OnCommand()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::HrUpdateWizardButtons
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodePage::HrUpdateWizardButtons( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    DWORD   dwFlags = PSWIZB_BACK | PSWIZB_NEXT;
    DWORD   dwLen;

    dwLen = GetWindowTextLength( GetDlgItem( m_hwnd, IDC_SELNODE_E_COMPUTERNAME ) );
    if ( dwLen == 0 )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }

    PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );

    HRETURN( hr );

} //*** CSelNodePage::HrUpdateWizardButtons()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::OnNotifySetActive
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodePage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    THR( HrUpdateWizardButtons() );

    //
    //  TODO:   gpease  23-MAY-2000
    //          Figure out: If the user clicks back and changes the computer
    //          name, how do we update the middle tier?
    //

    RETURN( lr );

} //*** CSelNodePage::OnNotifySetActive()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::OnNotifyQueryCancel
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodePage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CSelNodePage::OnNotifyQueryCancel()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::OnNotifyWizNext
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//      Other LRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodePage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    HRESULT     hr;
    LPWSTR      pszDomain;
    DWORD       dwLen;
    DNS_STATUS  dnsStatus;
    BSTR        bstrComputerName;
    int         idcFocus = 0;

    OBJECTCOOKIE    cookieDummy;
    OBJECTCOOKIE    cookieCluster;

    WCHAR   szComputerName[ DNS_MAX_NAME_BUFFER_LENGTH ] = { 0 };

    LRESULT lr = TRUE;

    dwLen = GetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, szComputerName, ARRAYSIZE( szComputerName ) );
    AssertMsg( dwLen != 0, "How did I get here?" );

    hr = THR( HrValidateDnsHostname( m_hwnd, szComputerName, mvdhoALLOW_ONLY_HOSTNAME_LABEL ) );
    if ( FAILED( hr ) )
    {
        idcFocus = IDC_SELNODE_E_COMPUTERNAME;
        goto Error;
    }

    //
    //  Build the FQDN DNS hostname to the computer.
    //

    pszDomain = wcschr( *m_pbstrClusterName, L'.' );
    Assert( pszDomain != NULL );
    if ( pszDomain == NULL )
    {
        // BUGBUG 31-JAN-2001 DavidP  What can the user do here?  We need a better way to handle this.
        goto Cleanup;
    }

    wcsncpy( &szComputerName[ dwLen ], pszDomain, ARRAYSIZE( szComputerName ) - dwLen - 1 /* NULL */ );

    bstrComputerName = TraceSysAllocString( szComputerName );
    if ( bstrComputerName == NULL )
    {
        goto OutOfMemory;
    }

    //
    //  Free old list (if any)
    //

    while ( *m_pcCount != 0 )
    {
        (*m_pcCount) --;
        TraceSysFreeString( (*m_prgbstrComputerName)[ *m_pcCount ] );
    }

    //
    //  Make a new list (if needed).
    //

    if ( *m_prgbstrComputerName == NULL )
    {
        *m_prgbstrComputerName = (BSTR *) TraceAlloc( 0, sizeof(BSTR) );
        if ( *m_prgbstrComputerName == NULL )
        {
            goto OutOfMemory;
        }
    }

    //
    //  Take ownership of bstrComputerName.
    //

    *m_pcCount = 1;
    (*m_prgbstrComputerName)[ 0 ] = bstrComputerName;

Cleanup:
    RETURN( lr );

Error:
    if ( idcFocus != 0 )
    {
        SetFocus( GetDlgItem( m_hwnd, idcFocus ) );
    }
    // Don't go to the next page.
    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    goto Cleanup;

OutOfMemory:
    goto Error;

} //*** CSelNodePage::OnNotifyWizNext()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::OnNotify
//
//  Description:
//
//  Arguments:
//      idCtrlIn
//      pnmhdrIn
//
//  Return Values:
//      TRUE
//      Other LRESULT values
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodePage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_WIZNEXT:
            lr = OnNotifyWizNext();
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;
    } // switch: notify code

    RETURN( lr );

} //*** CSelNodePage::OnNotify()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::HrBrowse
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      Other HRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodePage::HrBrowse( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    IDsObjectPicker *   piop = NULL;
    IDataObject *       pido = NULL;
    HCURSOR             hOldCursor = NULL;

    hOldCursor = SetCursor( LoadCursor( g_hInstance, IDC_WAIT ) );

    // Create an instance of the object picker.
    hr = THR( CoCreateInstance( CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER, IID_IDsObjectPicker, (void **) &piop ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    // Initialize the object picker instance.
    hr = THR( HrInitObjectPicker( piop ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    SetCursor( hOldCursor );

    // Invoke the modal dialog.
    hr = THR( piop->InvokeDialog( m_hwnd, &pido ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    if ( hr == S_OK )
    {
        hr = THR( HrGetSelection( pido ) );
    } // if:
    else if ( hr == S_FALSE )
    {
        hr = S_OK;                  // don't want to squawk in the caller...
    } // else if:

CleanUp:

    if ( pido != NULL )
    {
        pido->Release();
    } // if:

    if ( piop != NULL )
    {
        piop->Release();
    } // if:

    HRETURN( hr );

} //*** CSelNodePage::HrBrowse()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::HrInitObjectPicker
//
//  Description:
//
//  Arguments:
//      piopIn  -- IDsObjectPicker
//
//  Return Values:
//      HRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodePage::HrInitObjectPicker( IDsObjectPicker * piopIn )
{
    TraceFunc( "" );

    DSOP_SCOPE_INIT_INFO    rgScopeInit[ 1 ];
    DSOP_INIT_INFO          iiInfo;

    ZeroMemory( rgScopeInit, sizeof( DSOP_SCOPE_INIT_INFO ) * (sizeof( rgScopeInit ) / sizeof( rgScopeInit[ 0 ] ) ) );

    rgScopeInit[ 0 ].cbSize  = sizeof( DSOP_SCOPE_INIT_INFO );
    rgScopeInit[ 0 ].flType  = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    rgScopeInit[ 0 ].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

    rgScopeInit[ 0 ].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    rgScopeInit[ 0 ].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    ZeroMemory( &iiInfo, sizeof( iiInfo ) );

    iiInfo.cbSize            = sizeof( iiInfo );
    iiInfo.pwzTargetComputer = NULL;
    iiInfo.cDsScopeInfos     = 1;
    iiInfo.aDsScopeInfos     = rgScopeInit;
    iiInfo.flOptions         = 0;               //DSOP_FLAG_MULTISELECT;

    HRETURN( piopIn->Initialize( &iiInfo) );

} //*** CSelNodePage::HrInitObjectPicker

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::HrGetSelection
//
//  Description:
//
//  Arguments:
//      pidoIn  -- IDataObject
//
//  Return Values:
//      HRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodePage::HrGetSelection(
    IDataObject * pidoIn
    )
{
    TraceFunc( "" );
    Assert( pidoIn != NULL );

    HRESULT             hr;
    STGMEDIUM           stgmedium = { TYMED_HGLOBAL, NULL, NULL };
    FORMATETC           formatetc = { (CLIPFORMAT) m_cfDsObjectPicker, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    PDS_SELECTION_LIST  pds = NULL;
    DWORD               sc;

    hr = THR( pidoIn->GetData( &formatetc, &stgmedium ) );
    if ( FAILED( hr ) )
    {
        goto CleanUp;
    } // if:

    pds = (PDS_SELECTION_LIST) GlobalLock( stgmedium.hGlobal );
    if ( pds == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto CleanUp;
    } // if:

    if ( pds->cItems == 1 )
    {
        SetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, pds->aDsSelection[ 0 ].pwzName );
    } // if:

CleanUp:

    if ( pds != NULL )
    {
        GlobalUnlock( stgmedium.hGlobal );
    } // if:

    if ( stgmedium.hGlobal != NULL )
    {
        ReleaseStgMedium( &stgmedium );
    } // if:

    HRETURN( hr );

} //*** CSelNodePage::HrGetSelection()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CALLBACK
//  CSelNodePage::S_DlgProc
//
//  Description:
//      Dialog proc for this page.
//
//  Arguments:
//      hDlgIn
//      MsgIn
//      wParam
//      lParam
//
//  Return Values:
//      FALSE
//      Other LRESULT values
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CSelNodePage::S_DlgProc(
    HWND hDlgIn,
    UINT MsgIn,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CSelNodePage * pPage = reinterpret_cast< CSelNodePage *> ( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        Assert( lParam != NULL );

        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CSelNodePage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog( hDlgIn );
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr= pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), (HWND) lParam );
                break;

            // no default clause needed
        } // switch: message
    } // if: there is a page associated with the window

    return lr;

} //*** CSelNodePage::S_DlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\selnodebasepage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      SelNodeBasePage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    30-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "SelNodeBasePage.h"

DEFINE_THISCLASS("CSelNodeBasePage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CSelNodeBasePage::S_HrValidateDnsHostname
//
//  Description:
//      Validate a hostname with DNS.  If the name contains a period (.)
//      it will be validated as a full DNS hostname.  Otherwise it will be
//      validated as a hostname label.
//
//  Arguments:
//      hwndParentIn
//      pcwszHostnameIn
//
//  Return Values:
//      S_OK    - Operation completed successfully
//      Other return values from DnsValidateName()
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
CSelNodeBasePage::S_HrValidateDnsHostname(
      HWND      hwndParentIn
    , LPCWSTR   pcwszHostnameIn
    )
{
    TraceFunc1( "pcwszHostnameIn = '%1!ws!", pcwszHostnameIn );

    HRESULT     hr              = S_OK;
    DNS_STATUS  dnsStatus;
    BSTR        bstrTitle       = NULL;
    BSTR        bstrOperation   = NULL;
    BSTR        bstrText        = NULL;
    BSTR        bstrFullText    = NULL;
    UINT        nMsgBoxType;

    Assert( pcwszHostnameIn != NULL );

    //
    // If the name contains a dot, validate it as a full DNS name.
    // Otherwise validate it as a hostname label.
    //

    if ( wcschr( pcwszHostnameIn, L'.' ) == NULL )
    {
        dnsStatus = TW32( DnsValidateName( pcwszHostnameIn, DnsNameHostnameLabel ) );
    }
    else
    {
        dnsStatus = TW32( DnsValidateName( pcwszHostnameIn, DnsNameHostnameFull ) );
    }

    if ( dnsStatus != ERROR_SUCCESS )
    {
        // Load the title string for the message box.
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_ERR_VALIDATING_COMPUTER_NAME_TITLE, &bstrTitle ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        // Format the operation string for the message box.
        hr = THR( HrFormatStringIntoBSTR( g_hInstance, IDS_ERR_VALIDATING_COMPUTER_NAME_TEXT, &bstrOperation, pcwszHostnameIn ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        // Format the error message string for the message box.
        if ( dnsStatus == ERROR_INVALID_NAME )
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance, IDS_ERR_INVALID_DNS_COMPUTER_NAME_TEXT, &bstrText ) );
            nMsgBoxType = MB_ICONSTOP;
        }
        else
        {
            hr = THR( HrFormatErrorIntoBSTR( dnsStatus, &bstrText ) );
            if ( dnsStatus == DNS_ERROR_NON_RFC_NAME )
            {
                nMsgBoxType = MB_ICONEXCLAMATION;
            }
            else
            {
                nMsgBoxType = MB_ICONSTOP;
            }
        }
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        // Construct the message box text.
        hr = THR( HrFormatStringIntoBSTR( L"%1!ws!\n\n%2!ws!", &bstrFullText, bstrOperation, bstrText ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        // Display the error message box.
        MessageBox( hwndParentIn, bstrFullText, bstrTitle, nMsgBoxType | MB_OK );

    } // if: error in validation

Cleanup:
    //
    // Ignore a non RFC name error.
    // This error should be teated as a warning.
    //

    if (    ( dnsStatus != ERROR_SUCCESS )
        &&  ( dnsStatus != DNS_ERROR_NON_RFC_NAME ) )
    {
        hr = HRESULT_FROM_WIN32( dnsStatus );
    }

    TraceSysFreeString( bstrTitle );
    TraceSysFreeString( bstrOperation );
    TraceSysFreeString( bstrText );
    TraceSysFreeString( bstrFullText );

    HRETURN( hr );

} //*** CSelNodeBasePage::S_HrValidateDnsHostname()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\selnodespage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      SelNodesPage.h
//
//  Maintained By:
//      David Potter    (DavidP)    31-JAN-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSelNodesPage
//
//  Description:
//
//--
//////////////////////////////////////////////////////////////////////////////
class CSelNodesPage
{
friend class CClusCfgWizard;

private: // data
    HWND                m_hwnd;             // Our HWND
    IServiceProvider *  m_psp;              // Service Manager
    ULONG *             m_pcComputers;      // Count of the list of computers in the default list
    BSTR **             m_prgbstrComputers; // List of default computers
    BSTR *              m_pbstrClusterName; // Cluster name
    UINT                m_cfDsObjectPicker; // Object picker clipboard format

private: // methods
    CSelNodesPage( IServiceProvider *   pspIn,
                   ECreateAddMode       ecamCreateAddModeIn,
                   ULONG *              pcCountInout,
                   BSTR **              prgbstrComputersInout,
                   BSTR *               pbstrClusterNameIn
                   );
    virtual ~CSelNodesPage();

    LRESULT
        OnInitDialog( HWND hDlgIn );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT
        OnNotifyQueryCancel( void );
    LRESULT
        OnNotifyWizNext( void );
    LRESULT
        OnNotifySetActive( void );
    LRESULT
        OnCommand( UINT idNotificationIn, UINT idControlIn, HWND hwndSenderIn );
    HRESULT
        HrUpdateWizardButtons( bool fSetActiveIn = false );
    HRESULT
        HrAddNodeToList( void );
    HRESULT
        HrRemoveNodeFromList( void );
    HRESULT
        HrBrowse( void );
    HRESULT
        HrInitObjectPicker( IDsObjectPicker * piopIn );
    HRESULT
        HrGetSelections( IDataObject * pidoIn );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );

}; //*** class CSelNodesPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\summarypage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      SummaryPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    22-MAR-2001
//      Geoffrey Pease  (GPease)    06-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "SummaryPage.h"
#include "QuorumDlg.h"
#include "WizardUtils.h"

DEFINE_THISCLASS("CSummaryPage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSummaryPage::CSummaryPage
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pspIn               -- IServiceProvider
//      ecamCreateAddModeIn -- Creating cluster or adding nodes to cluster
//      pbstrClusterNameIn  -- Name of the cluster
//      idsNextIn           -- Resource ID for the Click Next string.
//
//--
//////////////////////////////////////////////////////////////////////////////
CSummaryPage::CSummaryPage(
    IServiceProvider *  pspIn,
    ECreateAddMode      ecamCreateAddModeIn,
    BSTR *              pbstrClusterNameIn,
    UINT                idsNextIn
    )
{
    TraceFunc( "" );

    Assert( pspIn != NULL );
    Assert( pbstrClusterNameIn != NULL );
    Assert( idsNextIn != 0 );

    m_psp               = pspIn;
    m_ecamCreateAddMode = ecamCreateAddModeIn;
    m_pbstrClusterName  = pbstrClusterNameIn;
    m_idsNext           = idsNextIn;

    TraceFuncExit();

} //*** CSummaryPage::CSummaryPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSummaryPage::~CSummaryPage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CSummaryPage::~CSummaryPage( void )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CSummaryPage::~CSummaryPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CSummaryPage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSummaryPage::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr = FALSE; // don't have Windows set default focus
    HRESULT hr;
    BSTR    bstrNext = NULL;
    BOOL    fShowQuorumButton;

    //
    //  Set the background color.
    //

    SendDlgItemMessage(
          m_hwnd
        , IDC_SUMMARY_RE_SUMMARY
        , EM_SETBKGNDCOLOR
        , 0
        , GetSysColor( COLOR_3DFACE )
        );

    //
    // Set the text of the Click Next control.
    //

    hr = HrLoadStringIntoBSTR( g_hInstance, m_idsNext, &bstrNext );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SetDlgItemText( m_hwnd, IDC_SUMMARY_S_NEXT, bstrNext );

    //
    // Hide the Quorum button if not creating a cluster.
    //

    fShowQuorumButton = ( m_ecamCreateAddMode == camCREATING );
    ShowWindow( GetDlgItem( m_hwnd, IDC_SUMMARY_PB_QUORUM ), fShowQuorumButton ? SW_SHOW : SW_HIDE );

Cleanup:
    TraceSysFreeString( bstrNext );

    RETURN( lr );

} //*** CSummaryPage::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CSummaryPage::OnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSummaryPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    HWND    hwnd;
    HRESULT hr;

    DWORD   dwClusterIPAddress;
    DWORD   dwClusterSubnetMask;
    ULONG   celtDummy;

    OBJECTCOOKIE    cookieDummy;
    OBJECTCOOKIE    cookieCluster;
    SETTEXTEX       stex;
    CHARRANGE       charrange;

    LRESULT lr = TRUE;

    BSTR    bstr             = NULL;
    BSTR    bstrUsername     = NULL;
    BSTR    bstrPassword     = NULL;
    BSTR    bstrDomain       = NULL;
    BSTR    bstrNodeName     = NULL;
    BSTR    bstrResourceName = NULL;
    BSTR    bstrNetworkName  = NULL;

    IUnknown *                     punk    = NULL;
    IObjectManager *               pom     = NULL;
    IClusCfgClusterInfo *          pcci    = NULL;
    IClusCfgNetworkInfo *          pccni   = NULL;
    IClusCfgCredentials *          pccc    = NULL;
    IEnumNodes *                   pen     = NULL;
    IClusCfgNodeInfo *             pccNode = NULL;
    IEnumClusCfgManagedResources * peccmr  = NULL;
    IClusCfgManagedResourceInfo *  pccmri  = NULL;
    IEnumClusCfgNetworks *         peccn   = NULL;

    //
    //  We're going to be using the control a lot. Grab the HWND to use.
    //

    hwnd = GetDlgItem( m_hwnd, IDC_SUMMARY_RE_SUMMARY );

    //
    //  Empty the window
    //

    SetWindowText( hwnd, L"" );

    //
    //  Initilize some stuff.
    //

    stex.flags = ST_SELECTION;
    stex.codepage = 1200;   // no translation/unicode

    //
    //  Find the cluster configuration information.
    //

    hr = THR( m_psp->TypeSafeQS( CLSID_ObjectManager,
                                 IObjectManager,
                                 &pom
                                 ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pom->FindObject( CLSID_ClusterConfigurationType,
                               NULL,
                               *m_pbstrClusterName,
                               DFGUID_ClusterConfigurationInfo,
                               &cookieCluster,
                               &punk
                               ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    Assert( ( *m_pbstrClusterName != NULL ) && ( **m_pbstrClusterName != L'\0' ) );

    hr = THR( punk->TypeSafeQI( IClusCfgClusterInfo, &pcci ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    punk->Release();
    punk = NULL;

    //
    //  Name
    //

    hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                       IDS_SUMMARY_CLUSTER_NAME,
                                       &bstr,
                                       *m_pbstrClusterName
                                       ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr);

    //
    //  IPAddress
    //

    hr = THR( pcci->GetIPAddress( &dwClusterIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pcci->GetSubnetMask( &dwClusterSubnetMask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    Assert( dwClusterIPAddress != 0 );
    Assert( dwClusterSubnetMask != 0 );

    hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                       IDS_SUMMARY_IPADDRESS,
                                       &bstr,
                                       FOURTH_IPADDRESS( dwClusterIPAddress ),
                                       THIRD_IPADDRESS( dwClusterIPAddress ),
                                       SECOND_IPADDRESS( dwClusterIPAddress ),
                                       FIRST_IPADDRESS( dwClusterIPAddress ),
                                       FOURTH_IPADDRESS( dwClusterSubnetMask ),
                                       THIRD_IPADDRESS( dwClusterSubnetMask ),
                                       SECOND_IPADDRESS( dwClusterSubnetMask ),
                                       FIRST_IPADDRESS( dwClusterSubnetMask )
                                       ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );

    //
    //  Network
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_SUMMARY_CLUSTER_NETWORK,
                                    &bstr
                                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );

    hr = THR( pcci->GetNetworkInfo( &pccni ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrFormatNetworkInfo( pccni, &bstr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );

    //
    //  Credentials
    //

    hr = THR( pcci->GetClusterServiceAccountCredentials( &pccc ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccc->GetCredentials( &bstrUsername, &bstrDomain, &bstrPassword ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    Assert( ( bstrUsername != NULL ) && ( *bstrUsername != L'\0' ) );
    Assert( ( bstrDomain != NULL ) && ( *bstrDomain != L'\0' ) );
    Assert( ( bstrPassword != NULL ) && ( *bstrPassword != L'\0' ) );

    //
    //  We don't want this!
    //
    ZeroMemory( bstrPassword, SysStringLen( bstrPassword ) * sizeof( bstrPassword[0] ) );
    TraceSysFreeString( bstrPassword );
    bstrPassword = NULL;

    hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                       IDS_SUMMARY_CREDENTIALS,
                                       &bstr,
                                       bstrUsername,
                                       bstrDomain
                                       ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );

    //
    //  Members of cluster
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_SUMMARY_MEMBERSHIP_BEGIN,
                                    &bstr
                                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );

    hr = THR( pom->FindObject( CLSID_NodeType,
                               cookieCluster,
                               NULL,
                               DFGUID_EnumNodes,
                               &cookieDummy,
                               &punk
                               ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumNodes, &pen ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    punk->Release();
    punk = NULL;

    for ( ;; )
    {
        TraceSysFreeString( bstrNodeName );
        bstrNodeName = NULL;
        if ( pccNode != NULL )
        {
            pccNode->Release();
            pccNode = NULL;
        }

        hr = STHR( pen->Next( 1, &pccNode, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        hr = THR( pccNode->GetName( &bstrNodeName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        Assert( ( bstrNodeName != NULL ) && ( *bstrNodeName != L'\0' ) );
        TraceMemoryAddBSTR( bstrNodeName );

        hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                           IDS_SUMMARY_MEMBERSHIP_SEPARATOR,
                                           &bstr,
                                           bstrNodeName
                                           ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );
    } // forever (loop exits when Next() returns S_FALSE)

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_SUMMARY_MEMBERSHIP_END,
                                    &bstr
                                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );

    //
    //  Resources
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_SUMMARY_RESOURCES_BEGIN,
                                    &bstr
                                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );

    hr = THR( pom->FindObject( CLSID_ManagedResourceType,
                               cookieCluster,
                               NULL,
                               DFGUID_EnumManageableResources,
                               &cookieDummy,
                               &punk
                               ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumClusCfgManagedResources, &peccmr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    punk->Release();
    punk = NULL;

    while( hr == S_OK )
    {
        if ( pccmri != NULL )
        {
            pccmri->Release();
            pccmri = NULL;
        }
        TraceSysFreeString( bstrResourceName );
        bstrResourceName = NULL;

        hr = STHR( peccmr->Next( 1, &pccmri, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        hr = THR( pccmri->GetName( &bstrResourceName ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        Assert( ( bstrResourceName != NULL ) && ( *bstrResourceName != L'\0' ) );
        TraceMemoryAddBSTR( bstrResourceName );

        hr = STHR( pccmri->IsManaged() );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( hr == S_OK )
        {

            hr = STHR( pccmri->IsQuorumDevice() );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }

            if ( hr == S_OK )
            {
                hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                                   IDS_SUMMARY_RESOURCE_QUORUM_DEVICE,
                                                   &bstr,
                                                   bstrResourceName
                                                   ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            } // if: quorum resource
            else
            {
                hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                                   IDS_SUMMARY_RESOURCE_MANAGED,
                                                   &bstr,
                                                   bstrResourceName
                                                   ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            } // else: not quorum resource
        } // if: resource is managed
        else
        {
            hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                               IDS_SUMMARY_RESOURCE_NOT_MANAGED,
                                               &bstr,
                                               bstrResourceName
                                               ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }

        SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );
    }

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_SUMMARY_RESOURCES_END,
                                    &bstr
                                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );

    //
    //  Networks
    //

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_SUMMARY_NETWORKS_BEGIN,
                                    &bstr
                                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );

    hr = THR( pom->FindObject( CLSID_NetworkType,
                               cookieCluster,
                               NULL,
                               DFGUID_EnumManageableNetworks,
                               &cookieDummy,
                               &punk
                               ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( punk->TypeSafeQI( IEnumClusCfgNetworks, &peccn ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    punk->Release();
    punk = NULL;

    while( hr == S_OK )
    {
        if ( pccni != NULL )
        {
            pccni->Release();
            pccni = NULL;
        }

        hr = STHR( peccn->Next( 1, &pccni, &celtDummy ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        if ( hr == S_FALSE )
        {
            break;  // exit condition
        }

        hr = THR( HrFormatNetworkInfo( pccni, &bstr ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );
    }

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_SUMMARY_NETWORKS_END,
                                    &bstr
                                    ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    SendMessage( hwnd, EM_SETTEXTEX, (WPARAM) &stex, (LPARAM) bstr );

    //
    //  Done.
    //

    charrange.cpMax = 0;
    charrange.cpMin = 0;
    SendMessage( hwnd, EM_EXSETSEL, 0, (LPARAM) &charrange );

    PropSheet_SetWizButtons( GetParent( m_hwnd ), PSWIZB_BACK | PSWIZB_NEXT );

    hr = S_OK;

Cleanup:
    TraceSysFreeString( bstrResourceName );
    TraceSysFreeString( bstrNodeName );
    TraceSysFreeString( bstrUsername );
    TraceSysFreeString( bstrDomain );
    TraceSysFreeString( bstr );
    if ( punk != NULL )
    {
        punk->Release();
    }
    if ( peccn != NULL )
    {
        peccn->Release();
    }
    if ( pccmri != NULL )
    {
        pccmri->Release();
    }
    if ( peccmr != NULL )
    {
        peccmr->Release();
    }
    if ( pccNode != NULL )
    {
        pccNode->Release();
    }
    if ( pen != NULL )
    {
        pen->Release();
    }
    if ( pccni != NULL )
    {
        pccni->Release();
    }
    if ( pcci != NULL )
    {
        pcci->Release();
    }
    if ( pom != NULL )
    {
        pom->Release();
    }

    RETURN( lr );

} //*** CSummaryPage::OnNotifySetActive()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CSummaryPage::OnNotifyQueryCancel( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSummaryPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CSummaryPage::OnNotifyQueryCancel()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CSummaryPage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSummaryPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch ( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;
    } // switch: notification code

    RETURN( lr );

} //*** CSummaryPage::OnNotify()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CSummaryPage::OnCommand(
//      UINT    idNotificationIn,
//      UINT    idControlIn,
//      HWND    hwndSenderIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSummaryPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;
    HRESULT hr = S_OK;

    switch ( idControlIn )
    {
        case IDC_SUMMARY_PB_VIEW_LOG:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrViewLogFile( m_hwnd ) );
                lr = TRUE;
            } // if: button click
            break;

        case IDC_SUMMARY_PB_QUORUM:
            if ( idNotificationIn == BN_CLICKED )
            {
                hr = STHR( CQuorumDlg::S_HrDisplayModalDialog( m_hwnd, m_psp, *m_pbstrClusterName ) );
                if ( hr == S_OK )
                {
                    OnNotifySetActive();
                }
                lr = TRUE;
            }
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CSummaryPage::OnCommand()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT_PTR
//  CALLBACK
//  CSummaryPage::S_DlgProc(
//      HWND    hwndDlgIn,
//      UINT    nMsgIn,
//      WPARAM  wParam,
//      LPARAM  lParam
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CSummaryPage::S_DlgProc(
    HWND    hwndDlgIn,
    UINT    nMsgIn,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT         lr = FALSE;
    CSummaryPage *  pPage;

    if ( nMsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CSummaryPage * >( ppage->lParam );
        pPage->m_hwnd = hwndDlgIn;
    }
    else
    {
        pPage = reinterpret_cast< CSummaryPage *> ( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );
    }

    if ( pPage != NULL )
    {
        Assert( hwndDlgIn == pPage->m_hwnd );

        switch ( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr = pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), reinterpret_cast< HWND >( lParam ) );
                break;

            // no default clause needed
        } // switch: nMsgIn
    } // if: page is available

    return lr;

} //*** CSummaryPage::S_DlgProc()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CSummaryPage::HrFormatNetworkInfo(
//      IClusCfgNetworkInfo * pccniIn,
//      BSTR * pbstrOut
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSummaryPage::HrFormatNetworkInfo(
    IClusCfgNetworkInfo * pccniIn,
    BSTR * pbstrOut
    )
{
    TraceFunc( "" );

    HRESULT hr;

    DWORD   dwNetworkIPAddress;
    DWORD   dwNetworkSubnetMask;

    BSTR    bstrNetworkName = NULL;
    BSTR    bstrNetworkDescription = NULL;
    BSTR    bstrNetworkUsage = NULL;

    IClusCfgIPAddressInfo * pccipai = NULL;

    hr = THR( pccniIn->GetName( &bstrNetworkName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    Assert( ( bstrNetworkName != NULL ) && ( *bstrNetworkName != L'\0' ) );
    TraceMemoryAddBSTR( bstrNetworkName );

    hr = THR( pccniIn->GetDescription( &bstrNetworkDescription ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    TraceMemoryAddBSTR( bstrNetworkDescription );

    hr = STHR( pccniIn->IsPublic() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( hr == S_OK )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                        IDS_SUMMARY_NETWORK_PUBLIC,
                                        &bstrNetworkUsage
                                        ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // if: public network

    hr = STHR( pccniIn->IsPrivate() );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( hr == S_OK )
    {
        if ( bstrNetworkUsage == NULL )
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                            IDS_SUMMARY_NETWORK_PRIVATE,
                                            &bstrNetworkUsage
                                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        } // if: not public network
        else
        {
            hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                            IDS_SUMMARY_NETWORK_BOTH,
                                            &bstrNetworkUsage
                                            ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        } // else: public network

    } // if: private network
    else if ( bstrNetworkUsage == NULL )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                        IDS_SUMMARY_NETWORK_NOTUSED,
                                        &bstrNetworkUsage
                                        ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    } // else: not private or public network

    hr = THR( pccniIn->GetPrimaryNetworkAddress( &pccipai ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccipai->GetIPAddress( &dwNetworkIPAddress ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( pccipai->GetSubnetMask( &dwNetworkSubnetMask ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    Assert( dwNetworkIPAddress != 0 );
    Assert( dwNetworkSubnetMask != 0 );

    hr = THR( HrFormatMessageIntoBSTR( g_hInstance,
                                       IDS_SUMMARY_NETWORK_INFO,
                                       pbstrOut,
                                       bstrNetworkName,
                                       bstrNetworkDescription,
                                       bstrNetworkUsage,
                                       FOURTH_IPADDRESS( dwNetworkIPAddress ),
                                       THIRD_IPADDRESS( dwNetworkIPAddress ),
                                       SECOND_IPADDRESS( dwNetworkIPAddress ),
                                       FIRST_IPADDRESS( dwNetworkIPAddress ),
                                       FOURTH_IPADDRESS( dwNetworkSubnetMask ),
                                       THIRD_IPADDRESS( dwNetworkSubnetMask ),
                                       SECOND_IPADDRESS( dwNetworkSubnetMask ),
                                       FIRST_IPADDRESS( dwNetworkSubnetMask )
                                       ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

Cleanup:
    if ( pccipai != NULL )
    {
        pccipai->Release();
    }
    TraceSysFreeString( bstrNetworkUsage );
    TraceSysFreeString( bstrNetworkName );
    TraceSysFreeString( bstrNetworkDescription );

    HRETURN( hr );

} //*** CSummaryPage::HrEditStreamCallback()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\summarypage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      SummaryPage.h
//
//  Maintained By:
//      David Potter    (DavidP)    22-MAR-2001
//      Geoffrey Pease  (GPease)    06-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSummaryPage
//
//  Description:
//      Display the Summary page.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CSummaryPage
{
friend class CClusCfgWizard;

private: // data
    HWND                m_hwnd;             //  Our HWND
    BSTR *              m_pbstrClusterName; //  Pointer the cluster name BSTR
    IServiceProvider *  m_psp;              //  Service Manager
    ECreateAddMode      m_ecamCreateAddMode;//  Creating? Adding?
    UINT                m_idsNext;          // Resource ID for Click Next string.

private: // methods
    CSummaryPage( IServiceProvider *    pspIn,
                  ECreateAddMode        ecamCreateAddModeIn,
                  BSTR *                pbstrClusterNameIn,
                  UINT                  idsNextIn
                  );
    virtual ~CSummaryPage( void );

    LRESULT
        OnInitDialog( void );
    LRESULT
        OnNotifyQueryCancel( void );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );
    LRESULT
        OnNotifySetActive( void );
    LRESULT
        OnCommand(
            UINT    idNotificationIn,
            UINT    idControlIn,
            HWND    hwndSenderIn
            );
    HRESULT
        HrFormatNetworkInfo( IClusCfgNetworkInfo * pccniIn, BSTR * pbstrOut );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hwndDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );

}; //*** class CSummaryPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\selnodespage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      SelNodesPage.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    31-JAN-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "SelNodesPage.h"
#include "WizardUtils.h"

DEFINE_THISCLASS("CSelNodesPage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::CSelNodesPage
//
//  Description:
//      Constructor.
//
//  Arguments:
//      pspIn                   -- IServiceProvider
//      ecamCreateAddModeIn     -- Creating cluster or adding nodes to cluster
//      pcCountInout            -- Count of computers in prgbstrComputersInout
//      prgbstrComputersInout   -- Array of computers
//      pbstrClusterNameIn      -- Name of the cluster
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
CSelNodesPage::CSelNodesPage(
    IServiceProvider *  pspIn,
    ECreateAddMode      ecamCreateAddModeIn,
    ULONG *             pcCountInout,
    BSTR **             prgbstrComputersInout,
    BSTR *              pbstrClusterNameIn
    )
{
    TraceFunc( "" );

    Assert( pspIn != NULL );
    Assert( pcCountInout != NULL );
    Assert( prgbstrComputersInout != NULL );
    Assert( pbstrClusterNameIn != NULL );

    //  m_hwnd
    THR( pspIn->TypeSafeQI( IServiceProvider, &m_psp ) );
    m_pcComputers      = pcCountInout;
    m_prgbstrComputers = prgbstrComputersInout;
    m_pbstrClusterName = pbstrClusterNameIn;
    m_cfDsObjectPicker = 0;

    TraceFuncExit();

} //*** CSelNodesPage::CSelNodesPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::~CSelNodesPage
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
CSelNodesPage::~CSelNodesPage( void )
{
    TraceFunc( "" );

    if ( m_psp != NULL )
    {
        m_psp->Release();
    }

    TraceFuncExit();

} //*** CSelNodesPage::~CSelNodesPage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnInitDialog
//
//  Description:
//      Handle the WM_INITDIALOG window message.
//
//  Arguments:
//      hDlgIn
//
//  Return Values:
//      FALSE   - Didn't set the focus.
//
//  Remarks:
//
//-
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodesPage::OnInitDialog(
    HWND hDlgIn
    )
{
    TraceFunc( "" );

    HRESULT hr;

    BSTR    bstrComputerName = NULL;

    LRESULT lr = FALSE; // Didn't set the focus.

    //
    // If a list of computers was already specified, validate them.
    //

    if (    ( *m_prgbstrComputers != NULL )
        &&  ( *m_pcComputers >= 1 )
        &&  ( (*m_prgbstrComputers)[ 0 ] != NULL )
        )
    {
        ULONG       idxComputers;

        //
        //  If a script pre-entered the machine names, make sure they end up in the UI.
        //

        for ( idxComputers = 0 ; idxComputers < *m_pcComputers ; idxComputers ++ )
        {
            hr = THR( HrValidateDnsHostname(
                              hDlgIn
                            , (*m_prgbstrComputers)[ idxComputers ]
                            , mvdhoALLOW_FULL_NAME
                            ) );
            if ( ! FAILED( hr ) )
            {
                //
                // Make sure the node is in the same domain as the cluster.
                //

                LPWSTR  pszClusterDomain;
                LPWSTR  pszComputerDomain;

                pszClusterDomain = wcschr( (*m_pbstrClusterName), L'.' );
                Assert( pszClusterDomain != NULL );
                pszComputerDomain = wcschr( (*m_prgbstrComputers)[ idxComputers ], L'.' );
                if ( pszComputerDomain != NULL )
                {
                    if ( _wcsicmp( &pszClusterDomain[ 1 ], &pszComputerDomain[ 1 ] ) != 0 )
                    {
                        hr = THR( HRESULT_FROM_WIN32( ERROR_INVALID_COMPUTERNAME ) );
                        THR( HrMessageBoxWithStatusString(
                                          m_hwnd
                                        , IDS_ERR_VALIDATING_NAME_TITLE
                                        , IDS_ERR_VALIDATING_NAME_TEXT
                                        , IDS_ERR_HOST_DOMAIN_DOESNT_MATCH_CLUSTER
                                        , 0
                                        , MB_OK | MB_ICONSTOP
                                        , NULL
                                        , *m_pbstrClusterName
                                        ) );
                    } // if: computer not in same domain
                    else
                    {
                        // Don't add the computer to the list with its domain name.
                        *pszComputerDomain = L'\0';
                    }
                } // if: computer domain specified
            } // if: DNS validation was successful

            if ( FAILED( hr ) )
            {
                //
                // Construct a comma-separated list of invalid computer names.
                // This list will be written to the edit control so the user
                // can correct mistakes.
                //

                if ( bstrComputerName == NULL )
                {
                    //
                    // First invalid computer name.
                    //

                    bstrComputerName = TraceSysAllocString( (*m_prgbstrComputers)[ idxComputers ] );
                    if ( bstrComputerName == NULL )
                    {
                        THR( E_OUTOFMEMORY );
                    }
                } // if: first invalid computer name
                else
                {
                    BSTR bstr = NULL;

                    //
                    // Subsequent invalid computer name.
                    //

                    hr = THR( HrFormatStringIntoBSTR(
                                          L"%1!ws!,%2!ws!"
                                        , &bstr
                                        , bstrComputerName
                                        , (*m_prgbstrComputers)[ idxComputers ]
                                        ) );
                    if ( FAILED( hr ) )
                    {
                        // Ignore error. What can we do?
                    }
                    else
                    {
                        TraceSysFreeString( bstrComputerName );
                        bstrComputerName = bstr;
                    }
                } // else: more than one invalid computer name
            } // if: error validating computer name
            else
            {
                ListBox_AddString( GetDlgItem( m_hwnd, IDC_SELNODE_LB_NODES ), (*m_prgbstrComputers)[ idxComputers ] );
            }
        } // for: each computer

        //
        // Set the edit control to the list of invalid computer names.
        //
        if ( bstrComputerName != NULL )
        {
            SetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, bstrComputerName );
        } // if: invalid computer names found
    } // if: computers were specified by the caller of the wizard
    else
    {
        DWORD dwStatus;
        DWORD dwClusterState;

        //
        //  If the node is already in a cluster, don't have it default in the edit box.
        //  If there is an error getting the "NodeClusterState", then default the node
        //  name (it could be in the middle of cleaning up the node).
        //

        dwStatus = TW32( GetNodeClusterState( NULL, &dwClusterState ) );
        if (    ( dwStatus != ERROR_SUCCESS )
            ||  ( dwClusterState == ClusterStateNotConfigured ) )
        {
            hr = THR( HrGetComputerName( ComputerNameDnsHostname, &bstrComputerName ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            }
        }

        SetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, bstrComputerName );
    } // else: no list of computers was specified

    m_cfDsObjectPicker = RegisterClipboardFormat( CFSTR_DSOP_DS_SELECTION_LIST );
    if ( m_cfDsObjectPicker == 0 )
    {
        TW32( GetLastError() );
        //
        //  If registering the clipboard format fails, then disable the Browse
        //  button.
        //
        EnableWindow( GetDlgItem( hDlgIn, IDC_SELNODE_PB_BROWSE ), FALSE );

    } // if:

Cleanup:
    TraceSysFreeString( bstrComputerName );

    RETURN( lr );

} //*** CSelNodesPage::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnCommand
//
//  Description:
//
//  Arguments:
//      idNotificationIn
//      idControlIn
//      hwndSenderIn
//
//  Return Values:
//      TRUE
//      FALSE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodesPage::OnCommand(
    UINT    idNotificationIn,
    UINT    idControlIn,
    HWND    hwndSenderIn
    )
{
    TraceFunc( "" );

    LRESULT lr = FALSE;

    switch ( idControlIn )
    {
        case IDC_SELNODE_E_COMPUTERNAME:
            if ( idNotificationIn == EN_CHANGE )
            {
                THR( HrUpdateWizardButtons() );
                lr = TRUE;
            }
            break;

        case IDC_SELNODE_LB_NODES:
            if ( idNotificationIn == LBN_SELCHANGE )
            {
                THR( HrUpdateWizardButtons() );
                lr = TRUE;
            }
            break;

        case IDC_SELNODE_PB_BROWSE:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrBrowse() );
                lr = TRUE;
            }
            break;

        case IDC_SELNODE_PB_ADD:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrAddNodeToList() );
                lr = TRUE;
            }
            break;

        case IDC_SELNODE_PB_REMOVE:
            if ( idNotificationIn == BN_CLICKED )
            {
                THR( HrRemoveNodeFromList() );
                lr = TRUE;
            }
            break;

    } // switch: idControlIn

    RETURN( lr );

} //*** CSelNodesPage::OnCommand()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::HrUpdateWizardButtons
//
//  Description:
//
//  Arguments:
//      fSetActiveIn    - TRUE = called while handling PSN_SETACTIVE.
//
//  Return Values:
//      S_OK
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPage::HrUpdateWizardButtons(
    bool    fSetActiveIn    // = false
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    HWND    hwndList = GetDlgItem( m_hwnd, IDC_SELNODE_LB_NODES );

    DWORD   dwFlags = PSWIZB_BACK | PSWIZB_NEXT;
    DWORD   dwLen;
    LRESULT lr;

    // Disable the Next button if there are no entries in the list box
    // or if the edit control is not empty.
    lr = ListBox_GetCount( hwndList );
    dwLen = GetWindowTextLength( GetDlgItem( m_hwnd, IDC_SELNODE_E_COMPUTERNAME ) );
    if (    ( lr == 0 )
        ||  ( dwLen != 0 ) )
    {
        dwFlags &= ~PSWIZB_NEXT;
    }

    // This cannot be done synchronously if called while handling
    // PSN_SETACTIVE.  Otherwise, do it synchronously.
    if ( fSetActiveIn )
    {
        PropSheet_SetWizButtons( GetParent( m_hwnd ), dwFlags );
    }
    else
    {
        SendMessage( GetParent( m_hwnd ), PSM_SETWIZBUTTONS, 0, (LPARAM) dwFlags );
    }

    // Enable or disable the Add button based on whether there is text
    // in the edit control or not.
    if ( dwLen == 0 )
    {
        EnableWindow( GetDlgItem( m_hwnd, IDC_SELNODE_PB_ADD ), FALSE );
    }
    else
    {
        EnableWindow( GetDlgItem( m_hwnd, IDC_SELNODE_PB_ADD ), TRUE );
        SendMessage( m_hwnd, DM_SETDEFID, IDC_SELNODE_PB_ADD, 0 );
    }

    // Enable or disable the Remove button based whether an item is
    // selected in the list box or not.
    lr = ListBox_GetCurSel( hwndList );
    if ( lr == LB_ERR )
    {
        EnableWindow( GetDlgItem( m_hwnd, IDC_SELNODE_PB_REMOVE ), FALSE );
    }
    else
    {
        EnableWindow( GetDlgItem( m_hwnd, IDC_SELNODE_PB_REMOVE ), TRUE );
    }

    HRETURN( hr );

} //*** CSelNodesPage::HrUpdateWizardButtons()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::HrAddNodeToList
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      E_OUTOFMEMORY
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPage::HrAddNodeToList( void )
{
    TraceFunc( "" );

    HRESULT     hr;
    DNS_STATUS  dnsStatus;

    DWORD   dwLen;
    int     idcFocus = 0;

    LPWSTR  psz;
    LPWSTR  pszComputerName;
    LPWSTR  pszFreeBuffer = NULL;

    HWND    hwndList = GetDlgItem( m_hwnd, IDC_SELNODE_LB_NODES );
    HWND    hwndEdit = GetDlgItem( m_hwnd, IDC_SELNODE_E_COMPUTERNAME );

    dwLen = GetWindowTextLength( hwndEdit );
    if ( dwLen == 0 )
    {
        hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
        if ( hr == HRESULT_FROM_WIN32( ERROR_SUCCESS ) )
        {
            AssertMsg( dwLen != 0, "How did we get here?!" );
        }
        goto Error;
    }

    pszComputerName = (LPWSTR) TraceAlloc( 0, ( dwLen + 1 ) * sizeof(WCHAR) );
    if ( pszComputerName == NULL )
    {
        goto OutOfMemory;
    }

    pszFreeBuffer = pszComputerName;

    dwLen = GetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, pszComputerName, dwLen + 1 );
    AssertMsg( dwLen != 0, "How did we get here?!" );

    for ( ; pszComputerName != NULL ; pszComputerName = psz )
    {
        // Allow comma, semi-colon, and space delimiters.
        psz = wcspbrk( pszComputerName, L",; " );
        if ( psz != NULL )
        {
            *psz = L'\0';
            psz++;
        }

        hr = THR( HrValidateDnsHostname(
                              m_hwnd
                            , pszComputerName
                            , mvdhoALLOW_ONLY_HOSTNAME_LABEL
                            ) );
        if ( FAILED( hr ) )
        {
            idcFocus = IDC_SELNODE_E_COMPUTERNAME;
            goto Error;
        }

        ListBox_AddString( GetDlgItem( m_hwnd, IDC_SELNODE_LB_NODES ), pszComputerName );

    } // for: pszComputerName;

    SetDlgItemText( m_hwnd, IDC_SELNODE_E_COMPUTERNAME, L"" );

    hr = THR( HrUpdateWizardButtons() );

Error:
    TraceFree( pszFreeBuffer );

    if ( idcFocus != 0 )
    {
        SetFocus( GetDlgItem( m_hwnd, idcFocus ) );
    }

    HRETURN( hr );

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;

} //*** CSelNodesPage::HrAddNodeToList()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::HrRemoveNodeFromList
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPage::HrRemoveNodeFromList( void )
{
    TraceFunc( "" );

    HRESULT hr;
    LRESULT lr;

    HWND    hwndList = GetDlgItem( m_hwnd, IDC_SELNODE_LB_NODES );

    lr = ListBox_GetCurSel( hwndList );
    if ( lr != LB_ERR )
    {
        ListBox_DeleteString( hwndList, lr );
    }

    hr = THR( HrUpdateWizardButtons() );

    HRETURN( hr );

} //*** CSelNodesPage::HrRemoveNodeFromList()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnNotifySetActive
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodesPage::OnNotifySetActive( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    THR( HrUpdateWizardButtons( true /* fSetActiveIn */ ) );

    RETURN( lr );

} //*** CSelNodesPage::OnNotifySetActive()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnNotifyQueryCancel
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodesPage::OnNotifyQueryCancel( void )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    int iRet;

    iRet = MessageBoxFromStrings( m_hwnd,
                                  IDS_QUERY_CANCEL_TITLE,
                                  IDS_QUERY_CANCEL_TEXT,
                                  MB_YESNO
                                  );

    if ( iRet == IDNO )
    {
        SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    }

    RETURN( lr );

} //*** CSelNodesPage::OnNotifyQueryCancel()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnNotifyWizNext
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE
//      LB_ERR
//      Other LRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodesPage::OnNotifyWizNext( void )
{
    TraceFunc( "" );

    LPWSTR  pszDomain;
    DWORD   dwLen;

    WCHAR   szComputerName[ DNS_MAX_NAME_BUFFER_LENGTH ];

    LRESULT lr = TRUE;

    HWND    hwndList = GetDlgItem( m_hwnd, IDC_SELNODE_LB_NODES );

    //
    //  Free old list (if any)
    //

    while ( *m_pcComputers != 0 )
    {
        (*m_pcComputers) --;
        TraceSysFreeString( (*m_prgbstrComputers)[ *m_pcComputers ] );
    }

    //
    //  Find out how many are in the new list.
    //

    lr = ListBox_GetCount( hwndList );
    if ( lr == LB_ERR )
    {
        goto Error;
    }

    //  Check to see if we have a FQDN cluster name
    pszDomain = wcschr( *m_pbstrClusterName, L'.' );

    //
    //  Loop thru adding the FQDN node names to the list of nodes.
    //

    Assert( lr >= 0 );

    TraceFree( *m_prgbstrComputers );

    //
    //  Need to make a new list.
    //

    *m_prgbstrComputers = (BSTR *) TraceAlloc( HEAP_ZERO_MEMORY, (size_t) lr * sizeof(BSTR) );
    if ( *m_prgbstrComputers == NULL )
    {
        goto OutOfMemory;
    }

    for ( *m_pcComputers = 0; *m_pcComputers < (ULONG) lr; (*m_pcComputers) ++ )
    {
        dwLen = ListBox_GetText( hwndList, *m_pcComputers, szComputerName );
        Assert( dwLen < ARRAYSIZE( szComputerName ) );

        //  Append domain name to node if present.
        if ( pszDomain != NULL )
        {
            wcsncpy( &szComputerName[ dwLen ], pszDomain, ARRAYSIZE( szComputerName ) - dwLen - 1 /* NULL */ );
        }

        //  Add a new entry
        (*m_prgbstrComputers)[ *m_pcComputers ] = TraceSysAllocString( szComputerName );
        if ( (*m_prgbstrComputers)[ *m_pcComputers ] == NULL )
        {
            goto OutOfMemory;
        }

    } // for: *m_pcComputers

Cleanup:
    RETURN( lr );

OutOfMemory:
    LogMsg( "Out of memory." );
    // fall thru

Error:
    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, -1 );
    goto Cleanup;

} //*** CSelNodesPage::OnNotifyWizNext()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::OnNotify
//
//  Description:
//
//  Arguments:
//      idCtrlIn
//      pnmhdrIn
//
//  Return Values:
//      TRUE
//      Other LRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CSelNodesPage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            lr = OnNotifySetActive();
            break;

        case PSN_WIZNEXT:
            lr = OnNotifyWizNext();
            break;

        case PSN_QUERYCANCEL:
            lr = OnNotifyQueryCancel();
            break;
    } // switch: notification code

    RETURN( lr );

} //*** CSelNodesPage::OnNotify()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::HrBrowse
//
//  Description:
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//      Other HRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPage::HrBrowse( void )
{
    TraceFunc( "" );

    HRESULT             hr = S_OK;
    IDsObjectPicker *   piop = NULL;
    IDataObject *       pido = NULL;
    HCURSOR             hOldCursor = NULL;

    hOldCursor = SetCursor( LoadCursor( g_hInstance, IDC_WAIT ) );

    // Create an instance of the object picker.
    hr = THR( CoCreateInstance( CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER, IID_IDsObjectPicker, (void **) &piop ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    // Initialize the object picker instance.
    hr = THR( HrInitObjectPicker( piop ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    SetCursor( hOldCursor );

    // Invoke the modal dialog.
    hr = THR( piop->InvokeDialog( m_hwnd, &pido ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    if ( hr == S_OK )
    {
        hr = THR( HrGetSelections( pido ) );
    } // if:
    else if ( hr == S_FALSE )
    {
        hr = S_OK;                  // don't want to squawk in the caller...
    } // else if:

Cleanup:

    if ( pido != NULL )
    {
        pido->Release();
    } // if:

    if ( piop != NULL )
    {
        piop->Release();
    } // if:

    HRETURN( hr );

} //*** CSelNodesPage::HrBrowse()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodesPage::HrInitObjectPicker
//
//  Description:
//      Initialize the Object Picker dialog.
//
//  Arguments:
//      piopIn  -- IDsObjectPicker
//
//  Return Values:
//      HRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPage::HrInitObjectPicker( IDsObjectPicker * piopIn )
{
    TraceFunc( "" );

    DSOP_SCOPE_INIT_INFO    rgScopeInit[ 1 ];
    DSOP_INIT_INFO          iiInfo;

    ZeroMemory( rgScopeInit, sizeof( DSOP_SCOPE_INIT_INFO ) * (sizeof( rgScopeInit ) / sizeof( rgScopeInit[ 0 ] ) ) );

    rgScopeInit[0].cbSize  = sizeof( DSOP_SCOPE_INIT_INFO );
    rgScopeInit[0].flType  = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    rgScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

    rgScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    rgScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    ZeroMemory( &iiInfo, sizeof( iiInfo ) );

    iiInfo.cbSize            = sizeof( iiInfo );
    iiInfo.pwzTargetComputer = NULL;
    iiInfo.cDsScopeInfos     = 1;
    iiInfo.aDsScopeInfos     = rgScopeInit;
    iiInfo.flOptions         = DSOP_FLAG_MULTISELECT;

    HRETURN( piopIn->Initialize( &iiInfo) );

} //*** CSelNodesPage::HrInitObjectPicker

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CSelNodePage::HrGetSelections
//
//  Description:
//      Get selections from the Object Picker dialog.
//
//  Arguments:
//      pidoIn  -- IDataObject
//
//  Return Values:
//      S_OK
//      E_OUTOFMEMORY
//      Other HRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CSelNodesPage::HrGetSelections(
    IDataObject * pidoIn
    )
{
    TraceFunc( "" );
    Assert( pidoIn != NULL );

    HRESULT             hr;
    STGMEDIUM           stgmedium = { TYMED_HGLOBAL, NULL, NULL };
    FORMATETC           formatetc = { (CLIPFORMAT) m_cfDsObjectPicker, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    PDS_SELECTION_LIST  pds = NULL;
    DWORD               sc;
    ULONG               idx;
    HWND                hwndEdit = GetDlgItem( m_hwnd, IDC_SELNODE_E_COMPUTERNAME );
    WCHAR *             psz = NULL;
    ULONG               cch = 0;

    hr = THR( pidoIn->GetData( &formatetc, &stgmedium ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    pds = (PDS_SELECTION_LIST) GlobalLock( stgmedium.hGlobal );
    if ( pds == NULL )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    for ( idx = 0 ; idx < pds->cItems; idx++ )
    {
        cch += wcslen( pds->aDsSelection[ idx ].pwzName ) + 2;                // EOS plus the ';'
        psz = (WCHAR *) TraceReAlloc( psz, cch * sizeof( WCHAR ), HEAP_ZERO_MEMORY );
        if ( psz == NULL )
        {
            goto OutOfMemory;
        } // if:

        wcscat( psz, pds->aDsSelection[ idx ].pwzName );
        wcscat( psz, L"," );
    } // for:

    //
    //  Remove the last trailing comma ','
    //
    cch = wcslen( psz );
    psz[ cch - 1 ] = L'\0';
    Edit_SetText( hwndEdit, psz );

    goto Cleanup;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );

Cleanup:

    if ( pds != NULL )
    {
        GlobalUnlock( stgmedium.hGlobal );
    } // if:

    if ( stgmedium.hGlobal != NULL )
    {
        ReleaseStgMedium( &stgmedium );
    } // if:

    TraceFree( psz );

    HRETURN( hr );

} //*** CSelNodesPage::HrGetSelections()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CALLBACK
//  CSelNodesPage::S_DlgProc
//
//  Description:
//      Dialog proc for this page.
//
//  Arguments:
//      hDlgIn
//      MsgIn
//      wParam
//      lParam
//
//  Return Values:
//      FALSE
//      Other LRESULT values.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CSelNodesPage::S_DlgProc(
    HWND hDlgIn,
    UINT MsgIn,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hDlgIn, MsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CSelNodesPage * pPage = reinterpret_cast< CSelNodesPage *> ( GetWindowLongPtr( hDlgIn, GWLP_USERDATA ) );

    if ( MsgIn == WM_INITDIALOG )
    {
        Assert( lParam != NULL );

        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CSelNodesPage * >( ppage->lParam );
        pPage->m_hwnd = hDlgIn;
    }

    if ( pPage != NULL )
    {
        Assert( hDlgIn == pPage->m_hwnd );

        switch( MsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog( hDlgIn );
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            case WM_COMMAND:
                lr= pPage->OnCommand( HIWORD( wParam ), LOWORD( wParam ), (HWND) lParam );
                break;

            // no default clause needed
        } // switch: message
    } // if: there is a page associated with the window

    return lr;

} //*** CSelNodesPage::S_DlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\test\citracker.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.cpp
//
//  Description:
//      Sucks in the CITracker library.
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "CITrackerSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\waitcursor.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      WaitCursor.h
//
//  Description:
//      Wait Cursor stack class.
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    14-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CWaitCursor
{
private:
    HCURSOR m_hOldCursor;

public:
    explicit CWaitCursor( ) { m_hOldCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) ); };
    ~CWaitCursor( ) { SetCursor( m_hOldCursor ); };

}; // class CWaitCursor
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\test\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\welcomepage.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      WizPageWelcome.h
//
//  Maintained By:
//      David Potter    (DavidP)    26-MAR-2001
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CWelcomePage
{
friend class CClusCfgWizard;

private: // data
    HWND            m_hwnd;                 // Our HWND
    HFONT           m_hFont;                // Title font
    ECreateAddMode  m_ecamCreateAddMode;    // Creating? Adding?

private: // methods
    CWelcomePage(
        ECreateAddMode ecamCreateAddModeIn
        );
    virtual ~CWelcomePage( void );

    LRESULT
        OnInitDialog( void );
    LRESULT
        OnNotify( WPARAM idCtrlIn, LPNMHDR pnmhdrIn );

public: // methods
    static INT_PTR CALLBACK
        S_DlgProc( HWND hwndDlg, UINT nMsg, WPARAM wParam, LPARAM lParam );

}; //*** class CWelcomePage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\tasktreeview.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskTreeView.h
//
//  Maintained By:
//      David Potter    (DavidP)    27-MAR-2001
//      Geoffrey Pease  (GPease)    22-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

class CAnalyzePage;
class CCommitPage;

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////

//
//  This structure is on the lParam of all tree view items.
//
typedef struct _STreeItemLParamData
{
    CLSID       clsidMajorTaskId;
    CLSID       clsidMinorTaskId;
    BSTR        bstrNodeName;
    ULONG       ulMin;
    ULONG       ulMax;
    ULONG       ulCurrent;
    HRESULT     hr;
    BSTR        bstrDescription;
    FILETIME    ftTime;
    BSTR        bstrReference;
} STreeItemLParamData;

typedef enum _ETASKSTATUS
{
    tsUNKNOWN = 0,
    tsPENDING,      // E_PENDING
    tsDONE,         // S_OK
    tsWARNING,      // S_FALSE
    tsFAILED,       // FAILED( hr )
    tsMAX
} ETaskStatus;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskTreeView
//
//  Description:
//      Handles the tree view control that displays tasks.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskTreeView
{
friend class CAnalyzePage;
friend class CCommitPage;

private: // data
    HWND        m_hwndParent;
    HWND        m_hwndTV;
    HWND        m_hwndProg;
    HWND        m_hwndStatus;
    HIMAGELIST  m_hImgList;             //  Image list of icons for tree view
    ULONG       m_ulHighNibble;         //  Progress bar high nibble count
    ULONG       m_ulLowNibble;          //  Progress bar low nibble count
    HTREEITEM   m_htiSelected;          //  Selected item in the tree

private: // methods
    CTaskTreeView(
          HWND hwndParentIn
        , UINT uIDTVIn
        , UINT uIDProgressIn
        , UINT uIDStatusIn
        );
    virtual ~CTaskTreeView( void );

    void
        OnNotifyDeleteItem( LPNMHDR pnmhdrIn );
    void
        OnNotifySelChanged( LPNMHDR pnmhdrIn );
    HRESULT
        HrInsertTaskIntoTree(
              HTREEITEM             htiFirstIn
            , STreeItemLParamData * ptipdIn
            , int                   nImageIn
            , BSTR                  bstrDescriptionIn
            );
    HRESULT
        HrUpdateProgressBar(
              const STreeItemLParamData * ptipdPrevIn
            , const STreeItemLParamData * ptipdNewIn
            );
    HRESULT
        HrPropagateChildStateToParents(
              HTREEITEM htiChildIn
            , int       nImageIn
            , BOOL      fOnlyUpdateProgressIn
            );

public:  // methods
    HRESULT
        HrOnInitDialog( void );
    HRESULT
        HrOnSendStatusReport(
              LPCWSTR       pcszNodeNameIn
            , CLSID         clsidTaskMajorIn
            , CLSID         clsidTaskMinorIn
            , ULONG         ulMinIn
            , ULONG         ulMaxIn
            , ULONG         ulCurrentIn
            , HRESULT       hrStatusIn
            , LPCWSTR       pcszDescriptionIn
            , FILETIME *    pftTimeIn
            , LPCWSTR       pcszReferenceIn
            );
    HRESULT
        HrAddTreeViewRootItem( UINT idsIn, REFCLSID rclsidTaskIDIn )
    {
        return THR( HrAddTreeViewItem(
                              NULL      // phtiOut
                            , idsIn
                            , rclsidTaskIDIn
                            , IID_NULL
                            , TVI_ROOT
                            ) );

    } //*** CTaskTreeView::HrAddTreeViewRootItem()
    HRESULT
        HrAddTreeViewItem(
              HTREEITEM *   phtiOut
            , UINT          idsIn
            , REFCLSID      rclsidMinorTaskIDIn
            , REFCLSID      rclsidMajorTaskIDIn = IID_NULL
            , HTREEITEM     htiParentIn         = TVI_ROOT
            );
    HRESULT
        HrOnNotifySetActive( void );

    LRESULT
        OnNotify( LPNMHDR pnmhdrIn );

    HRESULT
        HrShowStatusAsDone( void );
    HRESULT
        HrDisplayDetails( void );
    BOOL
        FGetItem( HTREEITEM htiIn, STreeItemLParamData ** pptipdOut );
    HRESULT
        HrFindPrevItem( HTREEITEM * phtiOut );
    HRESULT
        HrFindNextItem( HTREEITEM * phtiOut );
    HRESULT
        HrSelectItem( HTREEITEM htiIn );

}; //*** class CTaskTreeView
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\test\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "LogSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\test\interfacetable.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      InterfaceTable.cpp
//
//  Description:
//      Sucks in the Interface Table.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 08-FEB-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "InterfaceTableSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\welcomepage.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      WelcomePage.cpp
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "WelcomePage.h"

DEFINE_THISCLASS("CWelcomePage");

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWelcomePage::CWelcomePage
//
//  Description:
//      Constructor.
//
//  Arguments:
//      ecamCreateAddModeIn     -- Creating cluster or adding nodes to cluster.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////

CWelcomePage::CWelcomePage(
    ECreateAddMode      ecamCreateAddModeIn
    )
{
    TraceFunc( "" );

    //  m_hwnd
    m_hFont = NULL;
    m_ecamCreateAddMode = ecamCreateAddModeIn;

    TraceFuncExit();

} //*** CWelcomePage::CWelcomePage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CWelcomePage::~CWelcomePage( void )
//
//--
//////////////////////////////////////////////////////////////////////////////

CWelcomePage::~CWelcomePage( void )
{
    TraceFunc( "" );

    if ( m_hFont != NULL )
    {
        DeleteObject( m_hFont );
    }

    TraceFuncExit();

} //*** CWelcomePage::~CWelcomePage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CWelcomePage::OnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CWelcomePage::OnInitDialog( void )
{
    TraceFunc( "" );

    LRESULT lr      = TRUE;
    HDC     hdc     = NULL;
    HRESULT hr;

    NONCLIENTMETRICS ncm;

    LOGFONT LogFont;
    INT     iSize;

    DWORD   dw;
    BOOL    fRet;

    WCHAR   szFontSize[ 3 ];    // shouldn't be bigger than 2 digits!!

    BSTR        bstrRequirement  = NULL;
    BSTR        bstrFormattedReq = NULL;
    BSTR        bstrRequirements = NULL;
    int         idxids;
    int         cidsRequirements;
    UINT *      pidsRequirements;
    static UINT rgidsCreateRequirements[] =
    {
          IDS_WELCOME_CREATE_REQ_1
        , IDS_WELCOME_CREATE_REQ_2
        , IDS_WELCOME_CREATE_REQ_3
        , IDS_WELCOME_CREATE_REQ_4
        , IDS_WELCOME_CREATE_REQ_5
    };
    static UINT rgidsAddRequirements[] =
    {
          IDS_WELCOME_ADD_REQ_1
        , IDS_WELCOME_ADD_REQ_2
    };

    //
    //  Make the Title static BIG and BOLD. Why the wizard control itself can't
    //  do this is beyond me!
    //

    ZeroMemory( &ncm, sizeof( ncm ) );
    ZeroMemory( &LogFont, sizeof( LOGFONT ) );

    //
    //  Find out the system default font metrics.
    //
    ncm.cbSize = sizeof( ncm );
    fRet = SystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );
    if ( ! fRet )
    {
        goto Win32Error;
    }

    //
    //  Copy it.
    //
    LogFont = ncm.lfMessageFont;

    //
    //  Make it BOLD.
    //
    LogFont.lfWeight = FW_BOLD;

    //
    //  Find out what we want it to look like.
    //
    dw = LoadString( g_hInstance, IDS_LARGEFONTNAME, LogFont.lfFaceName, ARRAYSIZE( LogFont.lfFaceName ) );
    AssertMsg( dw != 0, "String missing!" );

    dw = LoadString( g_hInstance, IDS_LARGEFONTSIZE, szFontSize, ARRAYSIZE( szFontSize ) );
    AssertMsg( dw != 0, "String missing!" );

    iSize = wcstoul( szFontSize, NULL, 10 );

    //
    //  Grab the DC.
    //
    hdc = GetDC( m_hwnd );
    if ( hdc == NULL )
    {
        goto Win32Error;
    }

    //
    //  Use the magic equation....
    //
    LogFont.lfHeight = 0 - ( GetDeviceCaps( hdc, LOGPIXELSY ) * iSize / 72 );

    //
    //  Create the font.
    //
    m_hFont = CreateFontIndirect( &LogFont );
    if ( m_hFont == NULL )
    {
        goto Win32Error;
    }

    //
    //  Apply the font.
    //
    SetWindowFont( GetDlgItem( m_hwnd, IDC_WELCOME_S_TITLE ), m_hFont, TRUE );

    //
    // Load the requirement text.
    //

    if ( m_ecamCreateAddMode == camCREATING )
    {
        pidsRequirements = rgidsCreateRequirements;
        cidsRequirements = ARRAYSIZE( rgidsCreateRequirements );
    } // if: creating a new cluster
    else
    {
        pidsRequirements = rgidsAddRequirements;
        cidsRequirements = ARRAYSIZE( rgidsAddRequirements );
    } // else: adding nodes to an existing cluster

    for ( idxids = 0 ; idxids < cidsRequirements ; idxids++ )
    {
        hr = HrLoadStringIntoBSTR( g_hInstance, pidsRequirements[ idxids ], &bstrRequirement );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        hr = HrFormatStringIntoBSTR( L"  - %1!ws!\n", &bstrFormattedReq, bstrRequirement );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        hr = HrConcatenateBSTRs( &bstrRequirements, bstrFormattedReq );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }

        TraceSysFreeString( bstrRequirement );
        bstrRequirement = NULL;
    } // for: each requirement string

    SetDlgItemText( m_hwnd, IDC_WELCOME_S_REQUIREMENTS, bstrRequirements );

    goto Cleanup;

Win32Error:
    TW32( GetLastError() );

Cleanup:
    if ( hdc != NULL )
    {
        ReleaseDC( m_hwnd, hdc );
    }

    TraceSysFreeString( bstrRequirement );
    TraceSysFreeString( bstrFormattedReq );
    TraceSysFreeString( bstrRequirements );

    RETURN( lr );

} //*** CWelcomePage::OnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  LRESULT
//  CWelcomePage::OnNotify(
//      WPARAM  idCtrlIn,
//      LPNMHDR pnmhdrIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CWelcomePage::OnNotify(
    WPARAM  idCtrlIn,
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, 0 );

    switch( pnmhdrIn->code )
    {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons( GetParent( m_hwnd ), PSWIZB_NEXT );
            break;
    }

    RETURN( lr );

} //*** CWelcomePage::OnNotify()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT_PTR
//  CALLBACK
//  CWelcomePage::S_DlgProc(
//      HWND    hwhndDlgIn,
//      UINT    nMsgIn,
//      WPARAM  wParam,
//      LPARAM  lParam
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
INT_PTR
CALLBACK
CWelcomePage::S_DlgProc(
    HWND    hwndDlgIn,
    UINT    nMsgIn,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    // Don't do TraceFunc because every mouse movement
    // will cause this function to be called.

    WndMsg( hwndDlgIn, nMsgIn, wParam, lParam );

    LRESULT lr = FALSE;

    CWelcomePage * pPage;

    if ( nMsgIn == WM_INITDIALOG )
    {
        PROPSHEETPAGE * ppage = reinterpret_cast< PROPSHEETPAGE * >( lParam );
        SetWindowLongPtr( hwndDlgIn, GWLP_USERDATA, (LPARAM) ppage->lParam );
        pPage = reinterpret_cast< CWelcomePage * >( ppage->lParam );
        pPage->m_hwnd = hwndDlgIn;
    }
    else
    {
        pPage = reinterpret_cast< CWelcomePage *> ( GetWindowLongPtr( hwndDlgIn, GWLP_USERDATA ) );
    }

    if ( pPage != NULL )
    {
        Assert( hwndDlgIn == pPage->m_hwnd );

        switch ( nMsgIn )
        {
            case WM_INITDIALOG:
                lr = pPage->OnInitDialog();
                break;

            case WM_NOTIFY:
                lr = pPage->OnNotify( wParam, reinterpret_cast< LPNMHDR >( lParam ) );
                break;

            // no default clause needed
        } // switch: nMsgIn
    } // if: page is specified

    return lr;

} //*** CWelcomePage::S_DlgProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\wizardutils.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      WizardUtils.h
//
//  Maintained By:
//      David Potter    (DavidP)    30-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

// Options for HrValidateDnsHostname()
enum EValidateDnsHostnameOptions
{
      mvdhoALLOW_FULL_NAME           = 1
    , mvdhoALLOW_ONLY_HOSTNAME_LABEL = 0
};

HRESULT
HrValidateDnsHostname(
      HWND                          hwndParentIn
    , LPCWSTR                       pcwszHostnameIn
    , EValidateDnsHostnameOptions   emvdhoOptions
    );

HRESULT
HrMessageBoxWithStatus(
      HWND      hwndParentIn
    , UINT      idsTitleIn
    , UINT      idsOperationIn
    , HRESULT   hrStatusIn
    , UINT      idsSubStatusIn
    , UINT      uTypeIn
    , int *     pidReturnOut
    , ...
    );

HRESULT
HrMessageBoxWithStatusString(
      HWND      hwndParentIn
    , UINT      idsTitleIn
    , UINT      idsOperationIn
    , UINT      idsStatusIn
    , UINT      idsSubStatusIn
    , UINT      uTypeIn
    , int *     pidReturnOut
    , ...
    );

HRESULT
HrViewLogFile(
    HWND hwndParentIn
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\tasktreeview.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      TaskTreeView.cpp
//
//  Maintained By:
//      Galen Barbee  (GalenB)    22-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "TaskTreeView.h"
#include "DetailsDlg.h"

DEFINE_THISCLASS( "CTaskTreeView" )


//****************************************************************************
//
//  Constants
//
//****************************************************************************
#define HIGH_TICK_COUNT 400

//****************************************************************************
//
//  Static Function Prototypes
//
//****************************************************************************
static
HRESULT
HrCreateTreeItem(
      TVINSERTSTRUCT *          ptvisOut
    , STreeItemLParamData *     ptipdIn
    , HTREEITEM                 htiParentIn
    , int                       nImageIn
    , BSTR                      bstrTextIn
    );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::CTaskTreeView(
//      HWND hwndParentIn,
//      UINT uIDTVIn,
//      UINT uIDProgressIn,
//      UINT uIDStatusIn
//      )
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskTreeView::CTaskTreeView(
    HWND hwndParentIn,
    UINT uIDTVIn,
    UINT uIDProgressIn,
    UINT uIDStatusIn
    )
{
    TraceFunc( "" );

    Assert( m_htiSelected == NULL );

    m_hwndParent = hwndParentIn;

    m_hwndTV = GetDlgItem( hwndParentIn, uIDTVIn );
    Assert( m_hwndTV != NULL );

    m_hwndProg = GetDlgItem( hwndParentIn, uIDProgressIn );
    Assert( m_hwndProg != NULL );

    m_hwndStatus = GetDlgItem( hwndParentIn, uIDStatusIn );
    Assert( m_hwndStatus != NULL );

    m_hImgList = NULL;

    TraceFuncExit();

} //*** CTaskTreeView::CTaskTreeView()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::~CTaskTreeView( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
CTaskTreeView::~CTaskTreeView( void )
{
    TraceFunc( "" );

    TreeView_DeleteAllItems( m_hwndTV );

    if ( m_hImgList != NULL )
    {
        ImageList_Destroy( m_hImgList );
    }

    TraceFuncExit();

} //*** CTaskTreeView::CTaskTreeView()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CTaskTreeView::HrOnInitDialog( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrOnInitDialog( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    DWORD   sc;
    HICON   hIcon;
    int     idx;

    //
    //  Build image list for icons in tree view.
    //

    m_hImgList = ImageList_Create( 16, 16, ILC_MASK, tsMAX, 0);
    if ( m_hImgList == NULL )
    {
        sc = TW32( GetLastError() );
        goto Win32Error;
    }

    //
    //  Unknown Icon - Task Unknown.
    //

    hIcon = (HICON) LoadImage( g_hInstance,
                               MAKEINTRESOURCE( IDI_SEL ),
                               IMAGE_ICON,
                               16,
                               16,
                               LR_SHARED
                               );
    if ( hIcon == NULL )
    {
        sc = TW32( GetLastError() );
        goto Win32Error;
    }

    idx = ImageList_AddIcon( m_hImgList, hIcon );
    Assert( idx == tsUNKNOWN );

    //
    //  Pending Icon - Task Pending.
    //

    hIcon = (HICON) LoadImage( g_hInstance,
                               MAKEINTRESOURCE( IDI_PENDING ),
                               IMAGE_ICON,
                               16,
                               16,
                               LR_SHARED
                               );
    if ( hIcon == NULL )
    {
        sc = TW32( GetLastError() );
        goto Win32Error;
    }

    idx = ImageList_AddIcon( m_hImgList, hIcon );
    Assert( idx == tsPENDING );

    //
    //  Checkmark Icon - Task Done.
    //

    hIcon = (HICON) LoadImage( g_hInstance,
                               MAKEINTRESOURCE( IDI_CHECK ),
                               IMAGE_ICON,
                               16,
                               16,
                               LR_SHARED
                               );
    if ( hIcon == NULL )
    {
        sc = TW32( GetLastError() );
        goto Win32Error;
    }

    idx = ImageList_AddIcon( m_hImgList, hIcon );
    Assert( idx == tsDONE );

    //
    //  Warning Icon - Task Warning.
    //

    hIcon = (HICON) LoadImage( g_hInstance,
                               MAKEINTRESOURCE( IDI_WARN ),
                               IMAGE_ICON,
                               16,
                               16,
                               LR_SHARED
                               );
    if ( hIcon == NULL )
    {
        sc = TW32( GetLastError() );
        goto Win32Error;
    }

    idx = ImageList_AddIcon( m_hImgList, hIcon );
    Assert( idx == tsWARNING );

    //
    //  Fail Icon - Task Failed.
    //

    hIcon = (HICON) LoadImage( g_hInstance,
                               MAKEINTRESOURCE( IDI_FAIL ),
                               IMAGE_ICON,
                               16,
                               16,
                               LR_SHARED
                               );
    if ( hIcon == NULL )
    {
        sc = TW32( GetLastError() );
        goto Win32Error;
    }

    idx = ImageList_AddIcon( m_hImgList, hIcon );
    Assert( idx == tsFAILED );

    Assert( ImageList_GetImageCount( m_hImgList ) == tsMAX );

    //
    //  Set the image list and background color.
    //

    TreeView_SetImageList( m_hwndTV, m_hImgList, TVSIL_NORMAL );
    TreeView_SetBkColor( m_hwndTV, GetSysColor( COLOR_3DFACE ) );

    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( sc );
    goto Cleanup;

Cleanup:
    HRETURN( hr );

} //*** CTaskTreeView::HrOnInitDialog()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrAddTreeViewItem
//
//  Description:
//      Add a tree view item.  This method will return the item handle and
//      allows the caller to specify the parent item.
//
//  Arguments:
//      phtiOut             - Handle to the item being added (optional).
//      idsIn               - String resource ID for description of the new item.
//      rclsidMinorTaskIDIn - Minor task ID for the item.
//      rclsidMajorTaskIDIn - Major task ID for the item.  Defaults to IID_NULL.
//      htiParentIn         - Parent item.  Defaults to the root.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrAddTreeViewItem(
      HTREEITEM *   phtiOut
    , UINT          idsIn
    , REFCLSID      rclsidMinorTaskIDIn
    , REFCLSID      rclsidMajorTaskIDIn // = IID_NULL
    , HTREEITEM     htiParentIn         // = TVI_ROOT
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    STreeItemLParamData *   ptipd;
    SYSTEMTIME              systemtime;
    TVINSERTSTRUCT          tvis;
    HTREEITEM               hti = NULL;

    //
    // Allocate an item data structure and initialize it.
    //

    ptipd = new STreeItemLParamData;
    if ( ptipd == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    hr = THR( HrGetComputerName( ComputerNamePhysicalDnsFullyQualified, &ptipd->bstrNodeName ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsIn, &ptipd->bstrDescription ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    GetSystemTime( &systemtime );
    if ( ! SystemTimeToFileTime( &systemtime, &ptipd->ftTime ) )
    {
        DWORD sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    }

    CopyMemory( &ptipd->clsidMajorTaskId, &rclsidMajorTaskIDIn, sizeof( ptipd->clsidMajorTaskId ) );
    CopyMemory( &ptipd->clsidMinorTaskId, &rclsidMinorTaskIDIn, sizeof( ptipd->clsidMinorTaskId ) );

    //
    // Initialize the insert structure and insert the item into the tree.
    //

    tvis.hParent               = htiParentIn;
    tvis.hInsertAfter          = TVI_LAST;
    tvis.itemex.mask           = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvis.itemex.cchTextMax     = SysStringLen( ptipd->bstrDescription );
    tvis.itemex.pszText        = ptipd->bstrDescription;
    tvis.itemex.iImage         = tsUNKNOWN;
    tvis.itemex.iSelectedImage = tsUNKNOWN;
    tvis.itemex.lParam         = reinterpret_cast< LPARAM >( ptipd );

    hti = TreeView_InsertItem( m_hwndTV, &tvis );
    Assert( hti != NULL );

    ptipd = NULL;

    if ( phtiOut != NULL )
    {
        *phtiOut = hti;
    }

    goto Cleanup;

Cleanup:

    if ( ptipd != NULL )
    {
        TraceSysFreeString( ptipd->bstrNodeName );
        TraceSysFreeString( ptipd->bstrDescription );
        delete ptipd;
    }

    HRETURN( hr );

} //*** CTaskTreeView::HrAddTreeViewRootItem()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::OnNotify
//
//  Description:
//      Handler for the WM_NOTIFY message.
//
//  Arguments:
//      pnmhdrIn    - Notification structure.
//
//  Return Values:
//      Notification-specific return code.
//
//--
//////////////////////////////////////////////////////////////////////////////
LRESULT
CTaskTreeView::OnNotify(
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LRESULT lr = TRUE;

    switch( pnmhdrIn->code )
    {
        case TVN_DELETEITEM:
            OnNotifyDeleteItem( pnmhdrIn );
            break;

        case TVN_SELCHANGED:
            OnNotifySelChanged( pnmhdrIn );
            break;

    } // switch: notify code

    RETURN( lr );

} //*** CTaskTreeView::OnNotify()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::OnNotifyDeleteItem
//
//  Description:
//      Handler for the TVN_DELETEITEM notification message.
//
//  Arguments:
//      pnmhdrIn    - Notification structure for the item being deleted.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CTaskTreeView::OnNotifyDeleteItem(
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LPNMTREEVIEW pnmtv = reinterpret_cast< LPNMTREEVIEW >( pnmhdrIn );

    if ( pnmtv->itemOld.lParam != NULL )
    {
        STreeItemLParamData * ptipd = reinterpret_cast< STreeItemLParamData * >( pnmtv->itemOld.lParam );
        TraceSysFreeString( ptipd->bstrNodeName );
        TraceSysFreeString( ptipd->bstrDescription );
        TraceSysFreeString( ptipd->bstrReference );
        delete ptipd;
    }

    TraceFuncExit();

} //*** CTaskTreeView::OnNotifyDeleteItem()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::OnNotifySelChanged
//
//  Description:
//      Handler for the TVN_SELCHANGED notification message.
//
//  Arguments:
//      pnmhdrIn    - Notification structure for the item being deleted.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
CTaskTreeView::OnNotifySelChanged(
    LPNMHDR pnmhdrIn
    )
{
    TraceFunc( "" );

    LPNMTREEVIEW pnmtv = reinterpret_cast< LPNMTREEVIEW >( pnmhdrIn );

    Assert( pnmtv->itemNew.mask & TVIF_HANDLE );

    m_htiSelected = pnmtv->itemNew.hItem;

    TraceFuncExit();

} //*** CTaskTreeView::OnNotifySelChanged()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CTaskTreeView::HrShowStatusAsDone( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrShowStatusAsDone( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstrDescription = NULL;

    PBRANGE pbrange;

#if defined( DEBUG )
    ULONG_PTR   ulCurrent;
    ulCurrent = SendMessage( m_hwndProg, PBM_GETPOS, 0, 0 );
    AssertMsg( ulCurrent + 100 <= HIGH_TICK_COUNT, "Need to adjust HIGH_TICK_COUNT higher!" );
#endif

    SendMessage( m_hwndProg, PBM_GETRANGE, FALSE, (LPARAM) &pbrange );
    SendMessage( m_hwndProg, PBM_SETPOS, pbrange.iHigh, 0 );

    hr = THR( HrLoadStringIntoBSTR( g_hInstance,
                                    IDS_TASKS_COMPLETED,
                                    &bstrDescription
                                    ) );
    if ( FAILED( hr ) )
    {
        SetWindowText( m_hwndStatus, L"" );
        goto Cleanup;
    }

    SetWindowText( m_hwndStatus, bstrDescription );

Cleanup:

    TraceSysFreeString( bstrDescription );

    HRETURN( hr );

} //*** CTaskTreeView::HrShowStatusAsDone()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CTaskTreeView::HrOnNotifySetActive( void )
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrOnNotifySetActive( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    TreeView_DeleteAllItems( m_hwndTV );
    SetWindowText( m_hwndStatus, L"" );

    m_ulLowNibble = 0;
    m_ulHighNibble = HIGH_TICK_COUNT;

    SendMessage( m_hwndProg, PBM_SETRANGE, 0, MAKELPARAM( m_ulLowNibble, m_ulHighNibble ) );
    SendMessage( m_hwndProg, PBM_SETPOS, m_ulLowNibble, 0 );

    HRETURN( hr );

} //*** CTaskTreeView::HrOnNotifySetActive()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrOnSendStatusReport
//
//  Description:
//      Handle a status report call.
//
//  Arguments:
//      pcszNodeNameIn      -
//      clsidTaskMajorIn    -
//      clsidTaskMinorIn    -
//      ulMinIn             -
//      ulMaxIn             -
//      ulCurrentIn         -
//      hrStatusIn          -
//      pcszDescriptionIn   -
//      pftTimeIn           -
//      pcszReferenceIn     -
//
//  Return Values:
//      S_OK        - Operation completed successfully.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrOnSendStatusReport(
      LPCWSTR       pcszNodeNameIn
    , CLSID         clsidTaskMajorIn
    , CLSID         clsidTaskMinorIn
    , ULONG         ulMinIn
    , ULONG         ulMaxIn
    , ULONG         ulCurrentIn
    , HRESULT       hrStatusIn
    , LPCWSTR       pcszDescriptionIn
    , FILETIME *    pftTimeIn
    , LPCWSTR       pcszReferenceIn
    )
{
    TraceFunc( "" );

    HRESULT                 hr = S_OK;
    DWORD                   sc;
    int                     nImageChild;
    STreeItemLParamData     tipd;
    HTREEITEM               htiRoot;
    BSTR                    bstrStatus = NULL;

    //////////////////////////////////////////////////////////////////////////
    //
    //  Update status text.
    //  Don't do this if it is a log-only message.
    //
    //////////////////////////////////////////////////////////////////////////

    if (    ( pcszDescriptionIn != NULL )
        &&  ! IsEqualIID( clsidTaskMajorIn, TASKID_Major_Client_Log )
        &&  ! IsEqualIID( clsidTaskMajorIn, TASKID_Major_Server_Log )
        &&  ! IsEqualIID( clsidTaskMajorIn, TASKID_Major_Client_And_Server_Log )
        )
    {
        BOOL    fReturn;

        if ( pcszNodeNameIn != NULL )
        {
            LPWSTR  psz;

            //
            //  Shorten the FDQN DNS name to only the hostname.
            //

            psz = wcschr( pcszNodeNameIn, L'.' );
            if ( psz != NULL )
            {
                *psz = L'\0';
            }

            hr = THR( HrFormatMessageIntoBSTR(
                              g_hInstance
                            , IDS_FORMAT_STATUS
                            , &bstrStatus
                            , pcszNodeNameIn
                            , pcszDescriptionIn
                            ) );
            //
            //  Restore the FQDN DNS name.
            //

            if ( psz != NULL )
            {
                *psz = L'.';
            }

            //
            // Handle the formatting error if there was one.
            //

            if ( FAILED( hr ) )
            {
                // TODO: Display default description instead of exiting this function
                goto Error;
            }
        } // if: node name was specified
        else
        {
            bstrStatus = TraceSysAllocString( pcszDescriptionIn );
            if ( bstrStatus == NULL )
            {
                hr = THR( E_OUTOFMEMORY );
                goto Error;
            }
        }

        Assert( bstrStatus!= NULL );
        Assert( *bstrStatus!= L'\0' );
        fReturn = SetWindowText( m_hwndStatus, bstrStatus );
        Assert( fReturn );
    } // if: description specified, not log-only

    //////////////////////////////////////////////////////////////////////////
    //
    //  Select the right icon.
    //
    //////////////////////////////////////////////////////////////////////////

    switch ( hrStatusIn )
    {
        case S_OK:
            if ( ulCurrentIn == ulMaxIn )
            {
                nImageChild = tsDONE;
            }
            else
            {
                nImageChild = tsPENDING;
            }
            break;

        case S_FALSE:
            nImageChild = tsWARNING;
            break;

        case E_PENDING:
            nImageChild = tsPENDING;
            break;

        default:
            if ( FAILED( hrStatusIn ) )
            {
                nImageChild = tsFAILED;
            }
            else
            {
                nImageChild = tsWARNING;
            }
            break;
    } // switch: hrStatusIn

    //////////////////////////////////////////////////////////////////////////
    //
    //  Loop through each item at the top of the tree looking for an item
    //  whose minor ID matches this report's major ID.
    //
    //////////////////////////////////////////////////////////////////////////

    //
    // Fill in the param data structure.
    //

    tipd.hr         = hrStatusIn;
    tipd.ulMin      = ulMinIn;
    tipd.ulMax      = ulMaxIn;
    tipd.ulCurrent  = ulCurrentIn;

    CopyMemory( &tipd.clsidMajorTaskId, &clsidTaskMajorIn, sizeof( tipd.clsidMajorTaskId ) );
    CopyMemory( &tipd.clsidMinorTaskId, &clsidTaskMinorIn, sizeof( tipd.clsidMinorTaskId ) );
    CopyMemory( &tipd.ftTime, pftTimeIn, sizeof( tipd.ftTime ) );

    // tipd.bstrDescription is set above.
    if ( pcszNodeNameIn == NULL )
    {
        tipd.bstrNodeName = NULL;
    }
    else
    {
        tipd.bstrNodeName = TraceSysAllocString( pcszNodeNameIn );
        if ( tipd.bstrNodeName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Error;
        }
    }
    if ( pcszDescriptionIn == NULL )
    {
        tipd.bstrDescription = NULL;
    }
    else
    {
        tipd.bstrDescription = TraceSysAllocString( pcszDescriptionIn );
        if ( tipd.bstrDescription == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Error;
        }
    }
    if ( pcszReferenceIn == NULL )
    {
        tipd.bstrReference = NULL;
    }
    else
    {
        tipd.bstrReference = TraceSysAllocString( pcszReferenceIn );
        if ( tipd.bstrReference == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Error;
        }
    }

    // Start with the first item in the tree view.
    htiRoot = TreeView_GetRoot( m_hwndTV );
    if ( htiRoot == NULL )
    {
        sc = TW32( ERROR_NOT_FOUND );
        goto Win32Error;
    }

    // Insert the status report into the tree view.
    hr = STHR( HrInsertTaskIntoTree( htiRoot, &tipd, nImageChild, bstrStatus ) );
    if ( FAILED( hr ) )
    {
        LogMsg( "[WIZ] Error inserting status report into the tree control. hr=%.08x, %ws", tipd.hr, pcszDescriptionIn );
        goto Error;
    }

    if ( hr == S_FALSE )
    {
        // Don't return S_FALSE to the caller since it won't mean anything there.
        hr = S_OK;
        // TODO: Should this be written to the log?

#if defined( DEBUG )
        //
        // Check to make sure that if the major task ID wasn't recognized
        // that it is one of the known exceptions.
        //

        if (    ! IsEqualIID( clsidTaskMajorIn, TASKID_Major_Client_Log )
            &&  ! IsEqualIID( clsidTaskMajorIn, TASKID_Major_Server_Log )
            &&  ! IsEqualIID( clsidTaskMajorIn, TASKID_Major_Client_And_Server_Log ) )
        {
            BSTR    bstrMsg = NULL;

            THR( HrFormatStringIntoBSTR(
                              g_hInstance
                            , IDS_UNKNOWN_TASK
                            , &bstrMsg
                            , clsidTaskMajorIn.Data1        // 1
                            , clsidTaskMajorIn.Data2        // 2
                            , clsidTaskMajorIn.Data3        // 3
                            , clsidTaskMajorIn.Data4[ 0 ]   // 4
                            , clsidTaskMajorIn.Data4[ 1 ]   // 5
                            , clsidTaskMajorIn.Data4[ 2 ]   // 6
                            , clsidTaskMajorIn.Data4[ 3 ]   // 7
                            , clsidTaskMajorIn.Data4[ 4 ]   // 8
                            , clsidTaskMajorIn.Data4[ 5 ]   // 9
                            , clsidTaskMajorIn.Data4[ 6 ]   // 10
                            , clsidTaskMajorIn.Data4[ 7 ]   // 11
                            ) );
            AssertString( 0, bstrMsg );

            TraceSysFreeString( bstrMsg );
        }
#endif // DEBUG
    } // if: S_FALSE returned from HrInsertTaskIntoTree

    goto Cleanup;

Win32Error:
    // Don't return an error result since doing so will prevent the report
    // from being propagated to other subscribers.
    // hr = HRESULT_FROM_WIN32( sc );
    hr = S_OK;
    goto Cleanup;

Error:
    // Don't return an error result since doing so will prevent the report
    // from being propagated to other subscribers.
    hr = S_OK;
    goto Cleanup;

Cleanup:

    TraceSysFreeString( bstrStatus );
    TraceSysFreeString( tipd.bstrNodeName );
    TraceSysFreeString( tipd.bstrDescription );
    TraceSysFreeString( tipd.bstrReference );

    HRETURN( hr );

} //*** CTaskTreeView::HrOnSendStatusReport()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrInsertTaskIntoTree
//
//  Description:
//      Insert the specified task into the tree based on the node, major
//      task, and minor task.
//
//  Arguments:
//      htiFirstIn          - First tree item to examine.
//      ptipdIn             - Tree item parameter data for the task to be inserted.
//      nImageIn            - Image identifier for the child item.
//      bstrDescriptionIn   - Description string to display.
//
//  Return Values:
//      S_OK        - Task inserted successfully.
//      S_FALSE     - Task not inserted.
//      hr          - The operation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrInsertTaskIntoTree(
      HTREEITEM             htiFirstIn
    , STreeItemLParamData * ptipdIn
    , int                   nImageIn
    , BSTR                  bstrDescriptionIn
    )
{
    TraceFunc( "" );

    Assert( htiFirstIn != NULL );
    Assert( ptipdIn != NULL );

    //
    //  LOCAL VARIABLES
    //

    HRESULT                 hr;
    DWORD                   sc;
    HTREEITEM               htiParent;
    HTREEITEM               htiChild  = NULL;
    TVITEMEX                tviParent;
    TVITEMEX                tviChild;
    BOOL                    fReturn;
    BOOL                    fOnlyUpdateProgress;
    STreeItemLParamData *   ptipdParent = NULL;
    STreeItemLParamData *   ptipdChild = NULL;

    //
    // Determine if this report is only for updating progress.
    //

    fOnlyUpdateProgress = IsEqualIID( ptipdIn->clsidMinorTaskId, TASKID_Minor_Update_Progress );

    //
    // Loop through each item to determine if the task should be added below
    // that item.  If not, attempt to traverse its children.
    //

    for ( htiParent = htiFirstIn, hr = S_FALSE
        ; ( htiParent != NULL ) && ( hr == S_FALSE )
        ; )
    {
        //
        // Get the information about this item in the tree.
        //

        tviParent.mask  = TVIF_PARAM | TVIF_IMAGE;
        tviParent.hItem = htiParent;

        fReturn = TreeView_GetItem( m_hwndTV, &tviParent );
        if ( ! fReturn )
        {
            sc = TW32( ERROR_NOT_FOUND );
            goto Win32Error;
        }

        ptipdParent = reinterpret_cast< STreeItemLParamData * >( tviParent.lParam );
        Assert( ptipdParent != NULL );

        //
        // See if this item could be the parent.
        // If not, recurse through child items.
        //

        if ( IsEqualIID( ptipdIn->clsidMajorTaskId, ptipdParent->clsidMinorTaskId ) )
        {
            //
            //  FOUND THE PARENT ITEM
            //
            //  Is this report intended only for updating progress?
            //

            if ( fOnlyUpdateProgress )
            {
                //
                //  REPORT ONLY TO UPDATE PROGRESS
                //

                Assert( ptipdIn->hr == S_OK );
                Assert( ptipdIn->bstrReference == NULL );

                //
                //  Update the progress bar.
                //

                THR( HrUpdateProgressBar( ptipdIn, ptipdParent ) );
                // ignore failure.

                //
                //  Copy data from the report to the tree view item.
                //  Since this is a progress update, only progress fields
                //  are allowed to be specified.
                //

                ptipdParent->ulMin      = ptipdIn->ulMin;
                ptipdParent->ulMax      = ptipdIn->ulMax;
                ptipdParent->ulCurrent  = ptipdIn->ulCurrent;
                CopyMemory( &ptipdParent->ftTime, &ptipdIn->ftTime, sizeof( ptipdParent->ftTime ) );

            } // if: only updating progress
            else
            {
                BOOL    fMinorTaskIdMatches;
                BOOL    fBothNodeNamesPresent;
                BOOL    fBothNodeNamesEmpty;
                BOOL    fNodeNamesEqual;

                //
                //  REPORT NOT JUST TO UPDATE PROGRESS
                //

                //////////////////////////////////////////////////////////////
                //
                //  Loop through the child items looking for an item with
                //  the same minor ID.
                //
                //////////////////////////////////////////////////////////////

                htiChild = TreeView_GetChild( m_hwndTV, htiParent );
                while ( htiChild != NULL )
                {
                    //
                    // Get the child item details.
                    //

                    tviChild.mask  = TVIF_PARAM | TVIF_IMAGE;
                    tviChild.hItem = htiChild;

                    fReturn = TreeView_GetItem( m_hwndTV, &tviChild );
                    if ( ! fReturn )
                    {
                        sc = TW32( ERROR_NOT_FOUND );
                        goto Win32Error;
                    }

                    ptipdChild = reinterpret_cast< STreeItemLParamData * >( tviChild.lParam );
                    Assert( ptipdChild != NULL );

                    //
                    // Does this child item match the minor ID and node name?
                    //

                    fMinorTaskIdMatches   = IsEqualIID( ptipdIn->clsidMinorTaskId, ptipdChild->clsidMinorTaskId );
                    fBothNodeNamesPresent = ( ptipdIn->bstrNodeName != NULL ) && ( ptipdChild->bstrNodeName != NULL );
                    fBothNodeNamesEmpty   = ( ptipdIn->bstrNodeName == NULL ) && ( ptipdChild->bstrNodeName == NULL );

                    if ( fBothNodeNamesPresent )
                    {
                        fNodeNamesEqual = ( _wcsicmp( ptipdIn->bstrNodeName, ptipdChild->bstrNodeName ) == 0 );
                    }
                    else if ( fBothNodeNamesEmpty )
                    {
                        fNodeNamesEqual = TRUE;
                    }
                    else
                    {
                        fNodeNamesEqual = FALSE;
                    }

                    if ( fMinorTaskIdMatches && fNodeNamesEqual )
                    {
                        //
                        //  CHILD ITEM MATCHES.
                        //  Update the child item.
                        //

                        //
                        //  Update the progress bar.
                        //

                        THR( HrUpdateProgressBar( ptipdIn, ptipdChild ) );
                        // ignore failure.

                        //
                        //  Copy data from the report.
                        //  This must be done after the call to
                        //  HrUpdateProgressBar so that the previous values
                        //  can be compared to the new values.
                        //

                        ptipdChild->ulMin       = ptipdIn->ulMin;
                        ptipdChild->ulMax       = ptipdIn->ulMax;
                        ptipdChild->ulCurrent   = ptipdIn->ulCurrent;
                        CopyMemory( &ptipdChild->ftTime, &ptipdIn->ftTime, sizeof( ptipdChild->ftTime ) );

                        // Update the error code if needed.
                        if ( ptipdChild->hr == S_OK )
                        {
                            ptipdChild->hr = ptipdIn->hr;
                        }

                        //
                        // If the new state is worse than the last state,
                        // update the state of the item.
                        //

                        if ( tviChild.iImage < nImageIn )
                        {
                            tviChild.mask           = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                            tviChild.iImage         = nImageIn;
                            tviChild.iSelectedImage = nImageIn;
                            TreeView_SetItem( m_hwndTV, &tviChild );
                        } // if: new state is worse than the last state

                        //
                        // Update the text of the child item if needed.
                        //

                        if (    ( ptipdIn->bstrDescription != NULL )
                            &&  (    ( ptipdChild->bstrDescription == NULL )
                                ||  ( wcscmp( ptipdIn->bstrDescription, ptipdChild->bstrDescription ) != 0 )
                                )
                            )
                        {
                            fReturn = TraceSysReAllocString( &ptipdChild->bstrDescription, ptipdIn->bstrDescription );
                            if ( ! fReturn )
                            {
                                hr = THR( E_OUTOFMEMORY );
                                goto Cleanup;
                            }
                            tviChild.mask       = TVIF_TEXT;
                            tviChild.pszText    = bstrDescriptionIn;
                            tviChild.cchTextMax = SysStringLen( tviChild.pszText );
                            TreeView_SetItem( m_hwndTV, &tviChild );
                        } // if: description was specified and is different

                        //
                        // Copy the reference if it is different.
                        //

                        if (    ( ptipdIn->bstrReference != NULL )
                            &&  (   ( ptipdChild->bstrReference == NULL )
                                ||  ( wcscmp( ptipdChild->bstrReference, ptipdIn->bstrReference ) != 0 )
                                )
                            )
                        {
                            fReturn = TraceSysReAllocString( &ptipdChild->bstrReference, ptipdIn->bstrReference );
                            if ( ! fReturn )
                            {
                                hr = THR( E_OUTOFMEMORY );
                                goto Cleanup;
                            }
                        } // if: reference is different

                        break; // exit loop

                    } // if: found a matching child item

                    //
                    //  Get the next item.
                    //

                    htiChild = TreeView_GetNextSibling( m_hwndTV, htiChild );

                } // while: more child items

                //////////////////////////////////////////////////////////////
                //
                //  If the tree item was not found and the description was
                //  specified, then we need to create the child item.
                //
                //////////////////////////////////////////////////////////////

                if (    ( htiChild == NULL )
                    &&  ( ptipdIn->bstrDescription != NULL )
                    )
                {
                    //
                    //  ITEM NOT FOUND AND DESCRIPTION WAS SPECIFIED
                    //
                    //  Insert a new item in the tree under the major's task.
                    //

                    TVINSERTSTRUCT  tvis;

                    // Create the item.
                    hr = THR( HrCreateTreeItem(
                                      &tvis
                                    , ptipdIn
                                    , htiParent
                                    , nImageIn
                                    , bstrDescriptionIn
                                    ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    }

                    // Insert the item in the tree.
                    htiChild = TreeView_InsertItem( m_hwndTV, &tvis );
                    Assert( htiChild != NULL );

                    //
                    //  Update the progress bar.
                    //

                    ptipdChild = reinterpret_cast< STreeItemLParamData * >( tvis.itemex.lParam );
                    Assert( ptipdChild != NULL );
                    THR( HrUpdateProgressBar( ptipdIn, ptipdChild ) );
                    // ignore failure.

                } // if: need to add new child

                //////////////////////////////////////////////////////////////
                //
                //  If the child item was created and the child has an error
                //  condition, then create a child of the child item
                //  indicating the error code and system string.
                //
                //////////////////////////////////////////////////////////////

                if (    ( ptipdChild != NULL )
                    &&  FAILED( ptipdIn->hr )
                    )
                {
                    //
                    //  CHILD ITEM FOUND OR CREATED FOR ERROR REPORT
                    //  CREATE ERROR ITEM IN THE TREE
                    //

                    BSTR            bstrError = NULL;
                    BSTR            bstrErrorDescription = NULL;
                    HRESULT         hrFormat;
                    TVINSERTSTRUCT  tvis;
                    HTREEITEM       htiChildStatus;

                    THR( HrFormatErrorIntoBSTR( ptipdIn->hr, &bstrError ) );

                    hrFormat = THR( HrFormatMessageIntoBSTR(
                                          g_hInstance
                                        , IDS_TASK_RETURNED_ERROR
                                        , &bstrErrorDescription
                                        , ptipdIn->hr
                                        , ( bstrError == NULL ? L"" : bstrError )
                                        ) );
                    if ( SUCCEEDED( hrFormat ) )
                    {
                        //
                        //  Insert a new item in the tree under the minor's
                        //  task explaining the ptipdIn->hr.
                        //

                        // Create the item.
                        hr = THR( HrCreateTreeItem(
                                          &tvis
                                        , ptipdIn
                                        , htiChild
                                        , nImageIn
                                        , bstrErrorDescription
                                        ) );
                        if ( SUCCEEDED( hr ) )
                        {
                            //
                            // Failures are handled below to make sure we free
                            // all the strings allocated by this section of
                            // the code.
                            //

                            // Insert the item.
                            htiChildStatus = TreeView_InsertItem( m_hwndTV, &tvis );
                            Assert( htiChildStatus != NULL );
                        } // if: tree item created successfully

                        TraceSysFreeString( bstrErrorDescription );

                    } // if: message formatted successfully

                    TraceSysFreeString( bstrError );

                    //
                    // This error handling is for the return value from
                    // HrCreateTreeItem above.  It is here so that all the strings
                    // can be cleaned up without having to resort to hokey
                    // boolean variables or move the bstrs to a more global scope.
                    //

                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    }

                } // if: child and error

                //////////////////////////////////////////////////////////////
                //
                //  If a child was found or created, propagate its state to
                //  the parent items.
                //
                //////////////////////////////////////////////////////////////

                if ( htiChild != NULL )
                {
                    hr = STHR( HrPropagateChildStateToParents(
                                              htiChild
                                            , nImageIn
                                            , fOnlyUpdateProgress
                                            ) );
                    if ( FAILED( hr ) )
                    {
                        goto Cleanup;
                    }
                } // if: found or created a child

            } // else: not just updating progress

            //
            // Return success since we found the parent for this report.
            //

            hr = S_OK;
            break;

        } // if: found an item to be the parent
        else
        {
            //
            //  PARENT ITEM NOT FOUND
            //
            //  Recurse through all the child items.
            //

            htiChild = TreeView_GetChild( m_hwndTV, htiParent );
            while ( htiChild != NULL )
            {
                hr = STHR( HrInsertTaskIntoTree( htiChild, ptipdIn, nImageIn, bstrDescriptionIn ) );
                if ( hr == S_OK )
                {
                    // Found a match, so exit the loop.
                    break;
                }

                htiChild = TreeView_GetNextSibling( m_hwndTV, htiChild );
            } // while: more child items
        } // else: item not the parent

        //
        // Get the next sibling of the parent.
        //

        htiParent = TreeView_GetNextSibling( m_hwndTV, htiParent );

    } // for: each item at this level in the tree

    goto Cleanup;

Win32Error:

    hr = HRESULT_FROM_WIN32( sc );
    goto Cleanup;

Cleanup:

    RETURN( hr );
    
} //*** CTaskTreeView::HrInsertTaskIntoTree()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrUpdateProgressBar
//
//  Description:
//      Update the progress bar based on new tree item data.
//
//  Arguments:
//      ptipdNewIn      - New values of the tree item data.
//      ptipdPrevIn     - Previous values of the tree item data.
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrUpdateProgressBar(
      const STreeItemLParamData * ptipdNewIn
    , const STreeItemLParamData * ptipdPrevIn
    )
{
    TraceFunc( "" );

    Assert( ptipdNewIn != NULL );
    Assert( ptipdPrevIn != NULL );

    HRESULT     hr = S_OK;
    LRESULT     lr;
    ULONG       ulCurrent;
    PBRANGE     pbrange;

    //
    // Evaluate max value.
    //

    if ( m_ulHighNibble < ( ptipdPrevIn->ulMax - ptipdNewIn->ulMax ) )
    {
        //
        //  Out of space and need to expand range.
        //

        m_ulHighNibble = 0;
        SendMessage( m_hwndProg, PBM_GETRANGE, 0, (LPARAM) &pbrange );

        pbrange.iHigh += ( ptipdPrevIn->ulMax - ptipdNewIn->ulMax );

        SendMessage( m_hwndProg, PBM_SETRANGE, 0, (LPARAM) MAKELPARAM( pbrange.iLow, pbrange.iHigh ) );
    }
    else
    {
        //
        //  Keep nibbling away.
        //
        m_ulHighNibble -= ( ptipdPrevIn->ulMax - ptipdNewIn->ulMax );
    }

    //
    // Evaluate min value.
    //

    if ( m_ulLowNibble < ( ptipdPrevIn->ulMin - ptipdNewIn->ulMin ) )
    {
        //
        //  Out of space and need to expand range.
        //

        m_ulLowNibble = 0;
        SendMessage( m_hwndProg, PBM_GETRANGE, 0, (LPARAM) &pbrange );

        pbrange.iLow += ( ptipdPrevIn->ulMin - ptipdNewIn->ulMin );

        SendMessage( m_hwndProg, PBM_SETRANGE, 0, (LPARAM) MAKELPARAM( pbrange.iLow, pbrange.iHigh ) );
    }
    else
    {
        //
        //  Keep nibbling away.
        //
        m_ulLowNibble -= ( ptipdPrevIn->ulMin - ptipdNewIn->ulMin );
    }

    //
    // Update the progress bar.
    //

    lr = SendMessage( m_hwndProg, PBM_GETPOS, 0, 0 );
    ulCurrent = static_cast< ULONG >( lr );
    ulCurrent += ( ptipdPrevIn->ulCurrent - ptipdNewIn->ulCurrent );
    SendMessage( m_hwndProg, PBM_SETPOS, ulCurrent, 0 );

    HRETURN( hr );

} //*** CTaskTreeView::HrUpdateProgressBar()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrPropagateChildStateToParents
//
//  Description:
//      Extend the state of a child item to its parent items.
//      If the state of the child is worse (higher priority) than the
//      parent's, update the state of the parent.
//
//  Arguments:
//      htiChildIn      - Child item whose state is to be extended.
//      nImageIn        - Image of the child item.
//      fOnlyUpdateProgressIn - TRUE = only updating progress.
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//      S_FALSE         - No parent item.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrPropagateChildStateToParents(
      HTREEITEM htiChildIn
    , int       nImageIn
    , BOOL      fOnlyUpdateProgressIn
    )
{
    TraceFunc( "" );

    Assert( htiChildIn != NULL );

    HRESULT     hr = S_OK;
    DWORD       sc;
    BOOL        fReturn;
    TVITEMEX    tviParent;
    TVITEMEX    tviChild;
    HTREEITEM   htiParent;
    HTREEITEM   htiChild;

    //
    // Get the parent item.
    //

    htiParent = TreeView_GetParent( m_hwndTV, htiChildIn );
    if ( htiParent == NULL )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    tviParent.mask = TVIF_PARAM | TVIF_IMAGE;
    tviParent.hItem = htiParent;

    fReturn = TreeView_GetItem( m_hwndTV, &tviParent );
    if ( ! fReturn )
    {
        sc = TW32( ERROR_NOT_FOUND );
        goto Win32Error;
    }

    //
    //  If the state of the child is worse (higher priority) than the
    //  parent's, update the state of the parent.
    //

    if (    ( tviParent.iImage < nImageIn )
        ||  (   ( tviParent.iImage == tsDONE )
            &&  ( nImageIn == tsPENDING )
            )
        )
    {
        //
        //  Special Case:   For the parent to be set to tsDONE, all
        //                  the children must be set to tsDONE as well.
        //
        if (    ( nImageIn == tsDONE )
            &&  ! fOnlyUpdateProgressIn
            )
        {
            //
            //  Enum the children to see if they all have tsDONE as their images.
            //

            htiChild = TreeView_GetChild( m_hwndTV, tviParent.hItem );
            while ( htiChild != NULL )
            {
                tviChild.mask   = TVIF_IMAGE;
                tviChild.hItem  = htiChild;

                fReturn = TreeView_GetItem( m_hwndTV, &tviChild );
                if ( ! fReturn )
                {
                    sc = TW32( ERROR_NOT_FOUND );
                    goto Win32Error;
                }

                if ( tviChild.iImage != tsDONE )
                {
                    //
                    //  Not all tsDONE! Skip setting parent's image!
                    //  This can occur if the child is displaying a warning
                    //  or error state image.
                    //
                    goto Cleanup;
                }

                //  Get next child
                htiChild = TreeView_GetNextSibling( m_hwndTV, htiChild );
            } // while: more children

        } // if: special case (see above)

        //
        //  Set the parent's icon.
        //

        tviParent.mask           = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tviParent.iImage         = nImageIn;
        tviParent.iSelectedImage = nImageIn;
        TreeView_SetItem( m_hwndTV, &tviParent );

    } // if: need to update parent's image

    //
    // Traverse up the tree.
    //

    hr = STHR( HrPropagateChildStateToParents( htiParent, nImageIn, fOnlyUpdateProgressIn ) );
    if ( hr == S_FALSE )
    {
        // S_FALSE means that there wasn't a parent.
        hr = S_OK;
    }

    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( sc );
    goto Cleanup;

Cleanup:
    HRETURN( hr );

} //*** CTaskTreeView::HrPropagateChildStateToParents()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrDisplayDetails
//
//  Description:
//      Display the Details dialog box.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrDisplayDetails( void )
{
    TraceFunc( "" );

    HRESULT         hr = S_OK;
    HTREEITEM       hti;
    HWND            hwndPropertyPage;

    //
    // If no item is selected, select the first item.
    //

    if ( m_htiSelected == NULL )
    {
        hti = TreeView_GetRoot( m_hwndTV );
        Assert( hti != NULL );
        hr = THR( HrSelectItem( hti ) );
        if ( FAILED( hr ) )
        {
            // TODO: Display message box
            goto Cleanup;
        }
    } // if: no items are selected

    //
    // Display the dialog box.
    //

    hwndPropertyPage = GetParent( m_hwndTV );
    Assert( hwndPropertyPage != NULL );
    hr = THR( CDetailsDlg::S_HrDisplayModalDialog( hwndPropertyPage, this, m_htiSelected ) );

    SetFocus( m_hwndTV );

Cleanup:
    HRETURN( hr );

} //*** CTaskTreeView::HrDisplayDetails()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::FGetItem
//
//  Description:
//      Get the data for an item.
//
//  Arguments:
//      htiIn       - Handle for the item to get.
//      pptipdOut   - Pointer in which to return the data structure.
//
//  Return Values:
//      TRUE        - Item returned successfully.
//      FALSE       - Item not returned.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
CTaskTreeView::FGetItem(
      HTREEITEM                 htiIn
    , STreeItemLParamData **    pptipd
    )
{
    TraceFunc( "" );

    Assert( htiIn != NULL );
    Assert( pptipd != NULL );

    BOOL        fRet;
    TVITEMEX    tvi;

    ZeroMemory( &tvi, sizeof( tvi ) );

    tvi.mask    = TVIF_PARAM;
    tvi.hItem   = htiIn;

    fRet = TreeView_GetItem( m_hwndTV, &tvi );
    if ( fRet == FALSE )
    {
        goto Cleanup;
    }

    Assert( tvi.lParam != NULL );
    *pptipd = reinterpret_cast< STreeItemLParamData * >( tvi.lParam );

Cleanup:
    RETURN( fRet );

} //*** CTaskTreeView::FGetItem()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrFindPrevItem
//
//  Description:
//      Find the previous item.  The previous item could be at a deeper
//      level than this item.
//
//  Arguments:
//      phtiOut     - Handle to previous item (optional).
//
//  Return Values:
//      S_OK        - Previous item found successfully.
//      S_FALSE     - No previous item found.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrFindPrevItem(
    HTREEITEM *     phtiOut
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_FALSE;
    HTREEITEM   htiCur;
    HTREEITEM   htiPrev;

    htiCur = m_htiSelected;

    if ( phtiOut != NULL )
    {
        *phtiOut = NULL;
    }

    //
    // Find the previous sibling item.
    //

    htiPrev = TreeView_GetPrevSibling( m_hwndTV, htiCur );
    if ( htiPrev == NULL )
    {
        //
        // NO PREVIOUS SIBLING ITEM FOUND.
        //
        // Find the parent item.
        // If there isn't a parent, then there isn't a previous item.
        //

        htiPrev = TreeView_GetParent( m_hwndTV, htiCur );
        if ( htiPrev == NULL )
        {
            goto Cleanup;
        } // if: no parent item

        //
        // The parent is the previous item.
        //

    } // if: no previous sibling
    else
    {
        //
        // PREVIOUS SIBLING ITEM FOUND.
        //
        // Find the deepest child of the last child item.
        //

        for ( ;; )
        {
            //
            // Find the first child item.
            //

            htiCur = TreeView_GetChild( m_hwndTV, htiPrev );
            if ( htiCur == NULL )
            {
                //
                // NO CHILD ITEM FOUND.
                //
                // This is the previous item.
                //

                break;

            } // if: no children

            //
            // CHILD ITEM FOUND.
            //
            // Find the last sibling of this child item.
            //

            for ( ;; )
            {
                //
                // Find the next sibling item.
                //

                htiPrev = TreeView_GetNextSibling( m_hwndTV, htiCur );
                if ( htiPrev == NULL )
                {
                    //
                    // No next sibling item found.
                    // Exit this loop and continue the outer loop
                    // to find this item's children.
                    //

                    htiPrev = htiCur;
                    break;
                } // if: no next sibling item found

                //
                // Found a next sibling item.
                //

                htiCur = htiPrev;
            } // forever: find the last child item
        } // forever: find the deepest child item
    } // else: previous sibling item found

    //
    // Return the item we found.
    //

    Assert( htiPrev != NULL );

    if ( phtiOut != NULL )
    {
        *phtiOut = htiPrev;
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

} //*** CTaskTreeView::HrFindPrevItem()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrFindNextItem
//
//  Description:
//      Find the next item.  The next item could be at a different level than
//      this item.
//
//  Arguments:
//      phtiOut     - Handle to next item (optional).
//
//  Return Values:
//      S_OK        - Next item found successfully.
//      S_FALSE     - No next item found.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrFindNextItem(
    HTREEITEM *     phtiOut
    )
{
    TraceFunc( "" );

    HRESULT     hr = S_FALSE;
    HTREEITEM   htiCur;
    HTREEITEM   htiNext;

    htiCur = m_htiSelected;

    if ( phtiOut != NULL )
    {
        *phtiOut = NULL;
    }

    //
    // Find the first child item.
    //

    htiNext = TreeView_GetChild( m_hwndTV, htiCur );
    if ( htiNext == NULL )
    {
        //
        // NO CHILD ITEM FOUND.
        //

        for ( ;; )
        {
            //
            // Get the next sibling item.
            //

            htiNext = TreeView_GetNextSibling( m_hwndTV, htiCur );
            if ( htiNext == NULL )
            {
                //
                // NO SIBLING ITEM FOUND.
                //
                // Find the parent item so we can find its next sibling.
                //

                htiNext = TreeView_GetParent( m_hwndTV, htiCur );
                if ( htiNext == NULL )
                {
                    //
                    // NO PARENT ITEM FOUND.
                    //
                    // At the end of the tree.
                    //

                    goto Cleanup;
                } // if: no parent found

                //
                // PARENT ITEM FOUND.
                //
                // Find the parent item's next sibling.
                //

                htiCur = htiNext;
                continue;
            } // if: no next sibling item

            //
            // SIBLING ITEM FOUND.
            //
            // Found the next item.
            //

            break;
        } // forever: find the next sibling or parent's sibling
    } // if: no child item found
    else
    {
        //
        // CHILD ITEM FOUND.
        //
        // Found the next item.
        //
    } // else: child item found

    //
    // Return the item we found.
    //

    Assert( htiNext != NULL );

    if ( phtiOut != NULL )
    {
        *phtiOut = htiNext;
    }

    hr = S_OK;

Cleanup:
    HRETURN( hr );

} //*** CTaskTreeView::HrFindNextItem()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskTreeView::HrSelectItem
//
//  Description:
//      Select the specified item.
//
//  Arguments:
//      htiIn       - Handle to item to select.
//
//  Return Values:
//      S_OK        - Item selected successfully.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskTreeView::HrSelectItem(
    HTREEITEM   htiIn
    )
{
    TraceFunc( "" );

    Assert( htiIn != NULL );

    HRESULT     hr = S_OK;

    TreeView_SelectItem( m_hwndTV, htiIn );

    HRETURN( hr );

} //*** CTaskTreeView::HrSelectItem()

//****************************************************************************
//
//  Static Functions
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCreateTreeItem
//
//  Description:
//      Create a tree item.
//
//  Arguments:
//      ptvisOut        - Tree view insert structure to fill in.
//      ptipdIn         - Input tree item LParam data to create this item from.
//      htiParentIn     - Parent tree view item.
//      nImageIn        - Image index.
//      bstrTextIn      - Text to display.
//
//  Return Values:
//      S_OK            - Operation was successful.
//      E_OUTOFMEMORY   - Error allocating memory.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCreateTreeItem(
      TVINSERTSTRUCT *          ptvisOut
    , STreeItemLParamData *     ptipdIn
    , HTREEITEM                 htiParentIn
    , int                       nImageIn
    , BSTR                      bstrTextIn
    )
{
    TraceFunc( "" );

    Assert( ptvisOut != NULL );
    Assert( ptipdIn != NULL );
    Assert( htiParentIn != NULL );
    Assert( bstrTextIn != NULL );

    // LOCAL VARIABLES
    HRESULT                 hr = S_OK;
    STreeItemLParamData *   ptipdNew = NULL;

    //
    // Allocate the tree view LParam data and initialize it.
    //

    ptipdNew = new STreeItemLParamData;
    if ( ptipdNew == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    }

    CopyMemory( &ptipdNew->clsidMajorTaskId, &ptipdIn->clsidMajorTaskId, sizeof( ptipdNew->clsidMajorTaskId ) );
    CopyMemory( &ptipdNew->clsidMinorTaskId, &ptipdIn->clsidMinorTaskId, sizeof( ptipdNew->clsidMinorTaskId ) );
    CopyMemory( &ptipdNew->ftTime, &ptipdIn->ftTime, sizeof( ptipdNew->ftTime ) );
    ptipdNew->ulMin     = ptipdIn->ulMin;
    ptipdNew->ulMax     = ptipdIn->ulMax;
    ptipdNew->ulCurrent = ptipdIn->ulCurrent;
    ptipdNew->hr        = ptipdIn->hr;

    if ( ptipdIn->bstrNodeName != NULL )
    {
        ptipdNew->bstrNodeName = TraceSysAllocString( ptipdIn->bstrNodeName );
        if ( ptipdNew->bstrNodeName == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    }

    if ( ptipdIn->bstrDescription != NULL )
    {
        ptipdNew->bstrDescription = TraceSysAllocString( ptipdIn->bstrDescription );
        if ( ptipdNew->bstrDescription == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    }

    if ( ptipdIn->bstrReference != NULL )
    {
        ptipdNew->bstrReference = TraceSysAllocString( ptipdIn->bstrReference );
        if ( ptipdNew->bstrReference == NULL )
        {
            hr = THR( E_OUTOFMEMORY );
            goto Cleanup;
        }
    }

    //
    // Initialize the tree view insert structure.
    //

    ptvisOut->hParent                = htiParentIn;
    ptvisOut->hInsertAfter           = TVI_LAST;
    ptvisOut->itemex.mask            = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    ptvisOut->itemex.cchTextMax      = SysStringLen( bstrTextIn );
    ptvisOut->itemex.pszText         = bstrTextIn;
    ptvisOut->itemex.iImage          = nImageIn;
    ptvisOut->itemex.iSelectedImage  = nImageIn;
    ptvisOut->itemex.lParam          = reinterpret_cast< LPARAM >( ptipdNew );

    Assert( ptvisOut->itemex.cchTextMax > 0 );

    // Release ownership to the tree view insert structure.
    ptipdNew = NULL;

    goto Cleanup;

Cleanup:

    if ( ptipdNew != NULL )
    {
        TraceSysFreeString( ptipdNew->bstrNodeName );
        TraceSysFreeString( ptipdNew->bstrDescription );
        TraceSysFreeString( ptipdNew->bstrReference );
        delete ptipdNew;
    }
    HRETURN( hr );
    
} //*** HrCreateTreeItem()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\wizardutils.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      WizardUtils.cpp
//
//  Maintained By:
//      David Potter    (DavidP)    30-JAN-2001
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "WizardUtils.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrValidateDnsHostname
//
//  Description:
//      Validate a hostname with DNS.  If the name contains a period (.)
//      it will be validated as a full DNS hostname.  Otherwise it will be
//      validated as a hostname label.
//
//  Arguments:
//      hwndParentIn
//      pcwszHostnameIn
//      emvdhoOptionsIn -- mvdhoALLOW_FULL_NAME
//
//  Return Values:
//      S_OK    - Operation completed successfully
//      Other HRESULT values from DnsValidateName().
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrValidateDnsHostname(
      HWND                          hwndParentIn
    , LPCWSTR                       pcwszHostnameIn
    , EValidateDnsHostnameOptions   emvdhoOptionsIn
    )
{
    TraceFunc1( "pcwszHostnameIn = '%1!ws!", pcwszHostnameIn );

    HRESULT     hr              = S_OK;
    DNS_STATUS  dnsStatus;
    int         iRet;
    UINT        idsStatus       = 0;
    UINT        idsSubStatus    = 0;
    UINT        nMsgBoxType;
    bool        fAllowFullName = ( ( emvdhoOptionsIn & mvdhoALLOW_FULL_NAME ) == mvdhoALLOW_FULL_NAME );

    Assert( pcwszHostnameIn != NULL );

    if ( fAllowFullName )
    {
        dnsStatus = TW32( DnsValidateName( pcwszHostnameIn, DnsNameHostnameFull ) );
    }
    else
    {
        dnsStatus = TW32( DnsValidateName( pcwszHostnameIn, DnsNameHostnameLabel ) );
    }

    if ( dnsStatus != ERROR_SUCCESS )
    {
        // Format the error message string for the message box.
        switch ( dnsStatus )
        {
            case ERROR_INVALID_NAME:
                idsStatus = IDS_ERR_INVALID_DNS_NAME_TEXT;
                if ( fAllowFullName )
                {
                    idsSubStatus = IDS_ERR_FULL_DNS_NAME_INFO_TEXT;
                }
                else
                {
                    idsSubStatus = IDS_ERR_DNS_HOSTNAME_LABEL_INFO_TEXT;
                }
                nMsgBoxType = MB_OK | MB_ICONSTOP;
                break;

            case DNS_ERROR_NON_RFC_NAME:
                idsStatus = 0;
                idsSubStatus = IDS_ERR_NON_RFC_NAME_QUERY;
                nMsgBoxType = MB_YESNO | MB_ICONQUESTION;
                break;

            case DNS_ERROR_NUMERIC_NAME:
                idsStatus = IDS_ERR_INVALID_DNS_NAME_TEXT;
                if ( fAllowFullName )
                {
                    idsSubStatus = IDS_ERR_FULL_DNS_NAME_NUMERIC;
                }
                else
                {
                    idsSubStatus = IDS_ERR_DNS_HOSTNAME_LABEL_NUMERIC;
                }
                nMsgBoxType = MB_OK | MB_ICONSTOP;
                break;

            case DNS_ERROR_INVALID_NAME_CHAR:
            default:
                idsStatus = 0;
                idsSubStatus = IDS_ERR_DNS_NAME_INVALID_CHAR;
                nMsgBoxType = MB_OK | MB_ICONSTOP;
                break;
        }

        // Display the error message box.
        if ( idsStatus == 0 )
        {
            hr = THR( HrMessageBoxWithStatus(
                                  hwndParentIn
                                , IDS_ERR_VALIDATING_NAME_TITLE
                                , IDS_ERR_VALIDATING_NAME_TEXT
                                , dnsStatus
                                , idsSubStatus
                                , nMsgBoxType
                                , &iRet
                                , pcwszHostnameIn
                                ) );
        }
        else
        {
            hr = THR( HrMessageBoxWithStatusString(
                                  hwndParentIn
                                , IDS_ERR_VALIDATING_NAME_TITLE
                                , IDS_ERR_VALIDATING_NAME_TEXT
                                , idsStatus
                                , idsSubStatus
                                , nMsgBoxType
                                , &iRet
                                , pcwszHostnameIn
                                ) );
        }
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
        if ( iRet == IDYES )
        {
            dnsStatus = ERROR_SUCCESS;
        }

    } // if: error in validation

Cleanup:
    if ( dnsStatus != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dnsStatus );
    }

    HRETURN( hr );

} //*** HrValidateDnsHostname()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrMessageBoxWithStatus
//
//  Description:
//      Display an error message box.
//
//  Arguments:
//      hwndParentIn
//      idsTitleIn
//      idsOperationIn
//      hrStatusIn
//      idsSubStatusIn
//      uTypeIn
//      pidReturnOut        -- IDABORT on error or any return value from MessageBox()
//      ...
//
//  Return Values:
//      Any return values from the MessageBox() Win32 API.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrMessageBoxWithStatus(
      HWND      hwndParentIn
    , UINT      idsTitleIn
    , UINT      idsOperationIn
    , HRESULT   hrStatusIn
    , UINT      idsSubStatusIn
    , UINT      uTypeIn
    , int *     pidReturnOut
    , ...
    )
{
    TraceFunc( "" );

    HRESULT     hr                  = S_OK;
    int         idReturn            = IDABORT; // Default in case of error.
    BSTR        bstrTitle           = NULL;
    BSTR        bstrOperation       = NULL;
    BSTR        bstrStatus          = NULL;
    BSTR        bstrSubStatus       = NULL;
    BSTR        bstrFullText        = NULL;
    va_list     valist;

    va_start( valist, pidReturnOut );

    // Load the title string if one is specified.
    if ( idsTitleIn != 0 )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsTitleIn, &bstrTitle ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    // Load the text string.
    hr = THR( HrFormatStringWithVAListIntoBSTR( g_hInstance, idsOperationIn, &bstrOperation, valist ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Format the status.
    hr = THR( HrFormatErrorIntoBSTR( hrStatusIn, &bstrStatus ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Load the substatus string if specified.
    if ( idsSubStatusIn != 0 )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsSubStatusIn, &bstrSubStatus ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    // Format all the strings into a single string.
    if ( bstrSubStatus == NULL )
    {
        hr = THR( HrFormatStringIntoBSTR(
                              L"%1!ws!\n\n%2!ws!"
                            , &bstrFullText
                            , bstrOperation
                            , bstrStatus
                            ) );
    }
    else
    {
        hr = THR( HrFormatStringIntoBSTR( 
                              L"%1!ws!\n\n%2!ws!\n\n%3!ws!"
                            , &bstrFullText
                            , bstrOperation
                            , bstrStatus
                            , bstrSubStatus
                            ) );
    }
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Display the status.
    idReturn = MessageBox( hwndParentIn, bstrFullText, bstrTitle, uTypeIn );

Cleanup:
    TraceSysFreeString( bstrTitle );
    TraceSysFreeString( bstrOperation );
    TraceSysFreeString( bstrStatus );
    TraceSysFreeString( bstrSubStatus );
    TraceSysFreeString( bstrFullText );
    va_end( valist );

    if ( pidReturnOut != NULL )
    {
        *pidReturnOut = idReturn;
    }

    HRETURN( hr );

} //*** HrMessageBoxWithStatus( hrStatusIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrMessageBoxWithStatusString
//
//  Description:
//      Display an error message box.
//
//  Arguments:
//      hwndParentIn
//      idsTitleIn
//      idsOperationIn
//      idsStatusIn
//      idsSubStatusIn
//      uTypeIn
//      pidReturnOut        -- IDABORT on error or any return value from MessageBox()
//      ...
//
//  Return Values:
//      Any return values from the MessageBox() Win32 API.
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrMessageBoxWithStatusString(
      HWND      hwndParentIn
    , UINT      idsTitleIn
    , UINT      idsOperationIn
    , UINT      idsStatusIn
    , UINT      idsSubStatusIn
    , UINT      uTypeIn
    , int *     pidReturnOut
    , ...
    )
{
    TraceFunc( "" );

    HRESULT     hr                  = S_OK;
    int         idReturn            = IDABORT; // Default in case of error.
    BSTR        bstrTitle           = NULL;
    BSTR        bstrOperation       = NULL;
    BSTR        bstrStatus          = NULL;
    BSTR        bstrSubStatus       = NULL;
    BSTR        bstrFullText        = NULL;
    va_list     valist;

    va_start( valist, pidReturnOut );

    // Load the title string if one is specified.
    if ( idsTitleIn != 0 )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsTitleIn, &bstrTitle ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    // Load the text string.
    hr = THR( HrFormatStringWithVAListIntoBSTR( g_hInstance, idsOperationIn, &bstrOperation, valist ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Format the status.
    hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsStatusIn, &bstrStatus ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Load the substatus string if specified.
    if ( idsSubStatusIn != 0 )
    {
        hr = THR( HrLoadStringIntoBSTR( g_hInstance, idsSubStatusIn, &bstrSubStatus ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

    // Format all the strings into a single string.
    if ( bstrSubStatus == NULL )
    {
        hr = THR( HrFormatStringIntoBSTR(
                              L"%1!ws!\n\n%2!ws!"
                            , &bstrFullText
                            , bstrOperation
                            , bstrStatus
                            ) );
    }
    else
    {
        hr = THR( HrFormatStringIntoBSTR( 
                              L"%1!ws!\n\n%2!ws!\n\n%3!ws!"
                            , &bstrFullText
                            , bstrOperation
                            , bstrStatus
                            , bstrSubStatus
                            ) );
    }
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    // Display the status.
    idReturn = MessageBox( hwndParentIn, bstrFullText, bstrTitle, uTypeIn );

Cleanup:
    TraceSysFreeString( bstrTitle );
    TraceSysFreeString( bstrOperation );
    TraceSysFreeString( bstrStatus );
    TraceSysFreeString( bstrSubStatus );
    TraceSysFreeString( bstrFullText );
    va_end( valist );

    if ( pidReturnOut != NULL )
    {
        *pidReturnOut = idReturn;
    }

    HRETURN( hr );

} //*** HrMessageBoxWithStatusString( idsStatusTextIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrViewLogFile
//
//  Description:
//      View the log file.
//
//  Arguments:
//      hwndParentIn
//
//  Return Values:
//      S_OK    - Operation completed successfully
//      Other HRESULT values from ShellExecute().
//
//  Remarks:
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrViewLogFile(
    HWND hwndParentIn
    )
{
    TraceFunc( "" );

    static const WCHAR  s_szVerb[]          = L"open";
    static const WCHAR  s_szLogFileName[]   = L"%windir%\\system32\\LogFiles\\Cluster\\ClCfgSrv.log";

    HRESULT     hr = S_OK;
    DWORD       sc;
    DWORD       cch;
    DWORD       cchRet;
    LPWSTR      pszFile = NULL;

    //
    // Expand environment variables in the file to open.
    //

    // Get the size of the output buffer.
    cch = 0;
    cchRet = ExpandEnvironmentStrings( s_szLogFileName, NULL, cch );
    if ( cchRet == 0 )
    {
        sc = TW32( GetLastError() );
        goto Win32Error;
    } // if: error getting length of the expansion string

    // Allocate the output buffer.
    cch = cchRet;
    pszFile = new WCHAR[ cch ];
    if ( pszFile == NULL )
    {
        sc = TW32( ERROR_OUTOFMEMORY );
        goto Win32Error;
    }

    // Expand the string into the output buffer.
    cchRet = ExpandEnvironmentStrings( s_szLogFileName, pszFile, cch );
    if ( cchRet == 0 )
    {
        sc = TW32( GetLastError() );
        goto Win32Error;
    }
    Assert( cchRet == cch );

    //
    // Execute the file.
    //

    sc = HandleToULong( ShellExecute(
                              hwndParentIn      // hwnd
                            , s_szVerb          // lpVerb
                            , pszFile           // lpFile
                            , NULL              // lpParameters
                            , NULL              // lpDirectory
                            , SW_SHOWNORMAL     // nShowCommand
                            ) );
    if ( sc < 32 )
    {
        // Values less than 32 indicate an error occurred.
        TW32( sc );
        goto Win32Error;
    } // if: error executing the file

    goto Cleanup;

Win32Error:
    THR( HrMessageBoxWithStatus(
                      hwndParentIn
                    , IDS_ERR_VIEW_LOG_TITLE
                    , IDS_ERR_VIEW_LOG_TEXT
                    , sc
                    , 0         // idsSubStatusIn
                    , ( MB_OK
                      | MB_ICONEXCLAMATION )
                    , NULL      // pidReturnOut
                    , s_szLogFileName
                    ) );
    hr = HRESULT_FROM_WIN32( sc );
    goto Cleanup;

Cleanup:
    HRETURN( hr );

} //*** HrViewLogFile()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscomp\cluscompresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ClusCompResources.h
//
//  Description:
//      Contains the definition of the string ids used by this DLL.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 25-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

// The starting ID for these strings.
#define ID_COMP_START    0

#define IDS_ERROR_UPGRADE_OTHER_NODES         ( ID_COMP_START + 0 )

// The ending ID for these strings.
#define ID_COMP_END      1999
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscomp\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Debugging utilities.
//
//  Documentation:
//      Spec\Admin\Debugging.ppt
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//          Original version.
//
//      Vij Vasu (VVasu) 29-AUG-2000
//          Modified this file to remove dependency on Shell API since they
//          may not be present on the OS that this DLL runs in.
//          Removed WMI related functions for the same reason.
//
//      David Potter (DavidP) 12-OCT-2000
//          Reverted back to use the standard DebugSrc.cpp and modified
//          it to support NT4.
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <DebugSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\test\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      main.cpp
//
//  Maintained By:
//      Geoffrey Pease  (GPease)    12-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <initguid.h>
#include <guids.h>

DEFINE_MODULE("WizardTest")

#define CCS_LIB         L"..\\..\\..\\..\\dll\\obj\\i386\\ClusCfgServer.dll"

// Typedefs
typedef HRESULT (*PDLLREGISTERSERVER)( void );

HINSTANCE               g_hInstance = NULL;
LONG                    g_cObjects  = 0;

BOOL    g_fCreate   = FALSE;

LPCWSTR g_pszCluster = NULL;
LPCWSTR g_pszDomain = NULL;
LPCWSTR g_pszCSUser = NULL;
LPCWSTR g_pszCSPassword = NULL;
LPCWSTR g_pszCSDomain = NULL;
LPCWSTR g_pszNode = NULL;

//////////////////////////////////////////////////////////////////////////////
//  Forward Declarations:
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrRegisterTheDll( void );

HRESULT
HrParseCommandLine(
    int     argc,
    WCHAR * argv[]
    );

void
Usage( void );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrRegisterTheDll( void )
//
//  Description:
//      Register the DLL.
//
//  Arguments:
//      None.
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrRegisterTheDll( void )
{
    HRESULT             hr;
    PDLLREGISTERSERVER  pDllRegisterServer;
    HMODULE             hLib = NULL;

    TraceFunc( "" );

    //  Make sure the DLL is properly registered.
    hLib = LoadLibrary( CCS_LIB );
    if ( hLib == NULL )
        goto Win32Error;

    pDllRegisterServer =
        reinterpret_cast< PDLLREGISTERSERVER >(
            GetProcAddress( hLib, "DllRegisterServer" )
            );

    if ( pDllRegisterServer == NULL )
        goto Win32Error;

    hr = THR( pDllRegisterServer() );
    if ( FAILED( hr ) )
        goto Cleanup;

Cleanup:
    if ( hLib != NULL )
    {
        FreeLibrary( hLib );
    }

    HRETURN( hr );

Win32Error:
    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
    goto Cleanup;

} //*** HrRegisterTheDll()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrParseCommandLine(
//      int     argc,
//      WCHAR * argv[]
//      )
//
//  Description:
//      Parse the command line.
//
//  Arguments:
//      None.
//
//  Return Values:
//      HRESULT
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrParseCommandLine(
    int     argc,
    WCHAR * argv[]
    )
{
    HRESULT     hr = NOERROR;
    int         idx;
    WCHAR       wch;
    WCHAR *     pwsz;
    WCHAR       szMsg[ 2048 ];
    int         cchMsg = ARRAYSIZE( szMsg );

    for ( idx = 1 ; idx < argc ; idx++ )
    {
        wch = *argv[ idx ];
        pwsz = &argv[ idx ][ 1 ];
        if ( wch == L'/' || wch == L'-' )
        {
            if ( _wcsicmp( pwsz, L"Create" ) == 0 )
            {
                g_fCreate = TRUE;
                continue;
            }
            else if ( _wcsicmp( pwsz, L"Cluster" ) == 0 )
            {
                g_pszCluster = argv[ idx + 1 ];
                idx += 2;
            } // if: create switch
            else if ( _wcsicmp( pwsz, L"CSUser" ) == 0 )
            {
                g_pszCSUser = argv[ idx + 1 ];
                idx += 2;
            }
            else if ( _wcsicmp( pwsz, L"CSPassword" ) == 0 )
            {
                g_pszCSPassword = argv[ idx + 1 ];
                idx += 2;
            }
            else if ( _wcsicmp( pwsz, L"CSDomain" ) == 0 )
            {
                g_pszCSDomain = argv[ idx + 1 ];
                idx += 2;
            }
            else if ( _wcsicmp( pwsz, L"?" ) == 0 )
            {
                Usage();
                goto Cleanup;
            }
        } // if: '/' or '-'
        else
        {
            wnsprintf( szMsg, cchMsg, L"Unknown command line option '%ls'.", argv[ idx ] );
            MessageBox( NULL, szMsg, __MODULE__, MB_OK );
            hr = E_FAIL;
            goto Cleanup;

        } // else: not a switch

    } // for: each character in the command line

Cleanup:
    return hr;

} //*** HrParseCommandLine()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  Usage( void )
//
//  Description:
//      Show usage information.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
Usage( void )
{
    WCHAR   szMsg[ 2048 ] =
        L"WizardTest [/Create ]\n"
        L"           [/Cluster name]\n"
        L"           [/CSUser user]\n"
        L"           [/CSPassword password]\n"
        L"           [/CSDomain domain]\n";

    MessageBoxW( NULL, szMsg, __MODULE__, MB_OK );

} //*** Usage()

//////////////////////////////////////////////////////////////////////////////
//
//  int
//  _cdecl
//  wmain( void )
//
//  Description:
//      Program entrance.
//
//  Arguments:
//      argc    -- Count of arguments on the command line.
//      argv    -- Argument string array.
//
//  Return Value:
//      S_OK (0)        - Success.
//      other HRESULTs  - Error.
//
//////////////////////////////////////////////////////////////////////////////
int
_cdecl
wmain( int argc, WCHAR * argv[] )
{
    HRESULT             hr;
    BOOL                fDone;
    BOOL                fRet;
    IClusCfgWizard *    pClusCfgWizard = NULL;
    BSTR                bstrTmp = NULL;

    TraceInitializeProcess();

#if 0
    // Register the DLL
    hr = THR( HrRegisterTheDll() );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif

    // Parse the command line.
    hr = THR( HrParseCommandLine( argc, argv ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Start up the wizard
    hr = THR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    hr = THR( CoInitializeSecurity(
                    NULL,
                    -1,
                    NULL,
                    NULL,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_NONE,
                    0
                    ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Create instance of the wizard
    hr = THR( CoCreateInstance( CLSID_ClusCfgWizard,
                                NULL,
                                CLSCTX_SERVER,
                                TypeSafeParams( IClusCfgWizard, &pClusCfgWizard )
                                ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //  Create empty buffer so SysReAllocString doesn't bitch at us.
    bstrTmp = TraceSysAllocString( L" " );
    if ( bstrTmp == NULL )
        goto OutOfMemory;

    if ( g_pszCluster != NULL )
    {
        DebugMsg( "Entering %s for cluster name.", g_pszCluster );

        fRet = TraceSysReAllocString( &bstrTmp, g_pszCluster );
        if ( !fRet )
            goto OutOfMemory;

        hr = THR( pClusCfgWizard->put_ClusterName( bstrTmp ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if ( g_pszCSUser != NULL )
    {
        DebugMsg( "Entering %s for cluster account username.", g_pszCSUser );

        fRet = TraceSysReAllocString( &bstrTmp, g_pszCSUser );
        if ( !fRet )
            goto OutOfMemory;

        hr = THR( pClusCfgWizard->put_ServiceAccountUserName( bstrTmp ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if ( g_pszCSPassword != NULL )
    {
        DebugMsg( "Entering %s for cluster account password.", g_pszCSPassword );

        fRet = TraceSysReAllocString( &bstrTmp, g_pszCSPassword );
        if ( !fRet )
            goto OutOfMemory;

        hr = THR( pClusCfgWizard->put_ServiceAccountPassword( bstrTmp ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if ( g_pszCSDomain != NULL )
    {
        DebugMsg( "Entering %s for cluster account domain.", g_pszCSDomain );

        fRet = TraceSysReAllocString( &bstrTmp, g_pszCSDomain );
        if ( !fRet )
            goto OutOfMemory;

        hr = THR( pClusCfgWizard->put_ServiceAccountDomainName( bstrTmp ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    if ( g_fCreate )
    {
        DebugMsg( "Creating cluster..." );

        hr = THR( pClusCfgWizard->CreateCluster( NULL, &fDone ) );
        if ( FAILED( hr ) )
            goto Cleanup;

    } // if: creating a new cluster
    else
    {
        DebugMsg( "Add to cluster..." );

        hr = THR( pClusCfgWizard->AddClusterNodes( NULL, &fDone ) );
        if ( FAILED( hr ) )
            goto Cleanup;
    }

    // check returned indicator
    DebugMsg( "Return status: %s", BOOLTOSTRING( fDone ) );

Cleanup:
    if ( bstrTmp != NULL )
    {
        TraceSysFreeString( bstrTmp );
    }

    if ( pClusCfgWizard != NULL )
    {
        pClusCfgWizard->Release();
    }

    CoUninitialize();

    TraceTerminateProcess();

    ExitProcess( 0 );

OutOfMemory:
    hr = THR( E_OUTOFMEMORY );
    goto Cleanup;

} //*** main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscfg\wizard\test\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      David Potter        (DavidP)    20-JUL-2000
//      Cristian Scutaru    (CScutaru)  28-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE
#define _UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
// Define these to change Interface Tracking
//#define NO_TRACE_INTERFACES
//#define NOISY_TRACE_INTERFACES
#define USES_SYSALLOCSTRING
#endif // DBG==1

//////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <objbase.h>
#include <ocidl.h>
#include <shlwapi.h>
#include <wchar.h>

#include <common.h>
#include <debug.h>
#include <log.h>
#include <CITracker.h>
#include <guids.h>
#include <ClusCfgWizard.h>
#include <ClusCfgClient.h>
#include <ClusCfgServer.h>

//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// Global Definitions
//////////////////////////////////////////////////////////////////////////////

extern HINSTANCE g_hInstance;
extern LONG g_cObjects;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscomp\dll.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Dll.h
//
//  Description:
//      DLL globals definitions and macros.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// DLL Globals
//
extern HINSTANCE g_hInstance;
extern LONG      g_cObjects;
extern LONG      g_cLock;
extern TCHAR     g_szDllFilename[ MAX_PATH ];

extern LPVOID    g_GlobalMemoryList;            // Global memory tracking list
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscomp\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <LogSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscomp\cluscomp.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ClusComp.cpp
//
//  Description:
//      This file implements that function that is called by WinNT32.exe before
//      an upgrade to ensure that no incompatibilities occur as a result of the
//      upgrade. For example, in a cluster of two NT4 nodes, one node cannot
//      be upgraded to Whistler while the other is still at NT4. The user is
//      warned about such problems by this function.
//
//      NOTE: This function is called by WinNT32.exe on the OS *before* an
//      upgrade. If OS version X is being upgraded to OS version X+1, then
//      the X+1 verion of this DLL is loaded on OS version X. To make sure
//      that this DLL can function properly in an downlevel OS, it is linked
//      against only the indispensible libraries.
//
//  Header File:
//      There is no header file for this source file.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 25-JUL-2000
//          Created the original version.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL
#include "pch.h"

// For the compatibility check function and types
#include <comp.h>

// For the cluster API
#include <clusapi.h>

// For the names of several cluster service related registry keys and values
#include "clusudef.h"


//////////////////////////////////////////////////////////////////////////////
// Forward declarations
//////////////////////////////////////////////////////////////////////////////

DWORD DwIsClusterServiceRegistered( bool & rfIsRegisteredOut );
DWORD DwLoadString( UINT nStringIdIn, WCHAR *& rpszDestOut );
DWORD DwWriteOSVersionInfo( const OSVERSIONINFO & rcosviOSVersionInfoIn );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  extern "C"
//  BOOL
//  ClusterUpgradeCompatibilityCheck()
//
//  Description:
//      This function is called by WinNT32.exe before an upgrade to ensure that
//      no incompatibilities occur as a result of the upgrade. For example,
//      in a cluster of two NT4 nodes, one node cannot be upgraded to Whistler
//      while the other is still at NT4.
//
//  Arguments:
//      PCOMPAIBILITYCALLBACK pfnCompatibilityCallbackIn
//          Points to the callback function used to supply compatibility
//          information to WinNT32.exe
//
//      LPVOID pvContextIn
//          Pointer to the context buffer supplied by WinNT32.exe
//
//  Return Value:
//      TRUE if there were no errors or no compatibility problems.
//      FALSE otherwise.
//
//--
//////////////////////////////////////////////////////////////////////////////
extern "C"
BOOL ClusterUpgradeCompatibilityCheck(
      PCOMPAIBILITYCALLBACK pfnCompatibilityCallbackIn
    , LPVOID pvContextIn
    )
{
    TraceFunc( "" );
    LogMsg( "Entering function " __FUNCTION__ "()" );

    BOOL    fReturnValue = TRUE;
    bool    fWarningRequired = true;
    DWORD   dwError = ERROR_SUCCESS;

    do
    {
        typedef CSmartResource< CHandleTrait< HCLUSTER, BOOL, CloseCluster > > SmartClusterHandle;

        OSVERSIONINFO       osviOSVersionInfo;
        SmartClusterHandle  schClusterHandle;
        DWORD               cchBufferSize = 256;

        osviOSVersionInfo.dwOSVersionInfoSize = sizeof( osviOSVersionInfo );

        //
        // First of all, get and store the OS version info into the registry.
        //

        // Cannot call VerifyVerionInfo as this requires Win2k.
        if ( GetVersionEx( &osviOSVersionInfo ) == FALSE )
        {
            // We could not get OS version info.
            // Show the warning, just in case.
            dwError = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying to get the OS version info.", dwError );
            LogMsg( "Error %#x occurred trying to get the OS version info.", dwError );
            break;
        } // if: GetVersionEx() failed

        // Write the OS version info to the registry. This data will be used later by ClusOCM
        // to figure out which OS version we are upgrading from.
        dwError = TW32( DwWriteOSVersionInfo( osviOSVersionInfo ) );
        if ( dwError != ERROR_SUCCESS )
        {
            TraceFlow1( "Error %#x occurred trying to store the OS version info. This is not a fatal error.", dwError );
            LogMsg( "Error %#x occurred trying to store the OS version info. This is not a fatal error.", dwError );

            // This is not a fatal error. So reset the error code.
            dwError = ERROR_SUCCESS;
        } // if: there was an error writing the OS version info
        else
        {
            TraceFlow( "The OS version info was successfully written to the registry." );
        } // else: the OS version info was successfully written to the registry


        // Check if the cluster service is registered.
        dwError = TW32( DwIsClusterServiceRegistered( fWarningRequired ) );
        if ( dwError != ERROR_SUCCESS )
        {
            // We could not get the state of the cluster service
            // Show the warning, just in case.
            TraceFlow1( "Error %#x occurred trying to check if the cluster service is registered.", dwError );
            LogMsg( "Error %#x occurred trying to check if the cluster service is registered.", dwError );
            break;
        } // if: DwIsClusterServiceRegistered() returned an error

        if ( !fWarningRequired )
        {
            // If the cluster service was not registered, no warning is needed.
            TraceFlow( "The cluster service is not registered." );
            LogMsg( "The cluster service is not registered." );
            break;
        } // if: no warning is required

        TraceFlow( "The cluster service is registered. Checking the node versions." );
        LogMsg( "The cluster service is registered. Checking the node versions." );

        // Check if this is an NT4 node
        if ( osviOSVersionInfo.dwMajorVersion < 5 )
        {
            TraceFlow( "This is an NT4 node." );
            LogMsg( "This is an NT4 node." );
            fWarningRequired = true;
            break;
        } // if: this is an NT4 node

        TraceFlow( "This is not an NT4 node." );

        // Check if the OS version is Whistler or if it is a non-NT OS
        if (    ( osviOSVersionInfo.dwPlatformId != VER_PLATFORM_WIN32_NT )
             || (    ( osviOSVersionInfo.dwMajorVersion >= 5 )
                  && ( osviOSVersionInfo.dwMinorVersion >= 1 )
                )
           )
        {
            // If the OS not of the NT family or if the OS version of this
            // node is Whistler or greater, no warning is required.
            TraceFlow2(
                  "The version of the OS on this node is %d.%d. So, this is Windows Whister or later (or is not running NT)."
                , osviOSVersionInfo.dwMajorVersion
                , osviOSVersionInfo.dwMinorVersion
                );
            TraceFlow( "No NT4 nodes can exist in this cluster." );
            LogMsg( "The version of the OS on this node is Windows Whister or later (or is not running NT)." );
            LogMsg( "No NT4 nodes can exist in this cluster." );
            fWarningRequired = false;
            break;
        } // if: the OS is not NT or if it is Win2k or greater

        TraceFlow( "This is not a Whistler node - this has to be a Windows 2000 node." );
        TraceFlow( "Trying to check if there are any NT4 nodes in the cluster." );

        //
        // Get the cluster version information
        //

        // Open a handle to the local cluster
        schClusterHandle.Assign( OpenCluster( NULL ) );
        if ( schClusterHandle.HHandle() == NULL )
        {
            // Show the warning, just to be safe.
            dwError = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying to get a handle to the cluster.", dwError );
            LogMsg( "Error %#x occurred trying to get information about the cluster.", dwError );
            break;
        } // if: we could not get the cluster handle

        TraceFlow( "OpenCluster() was successful." );

        // Get the cluster version info
        do
        {
            // Allocate the buffer - this memory is automatically freed when this object
            // goes out of scope ( or during the next iteration ).
            SmartSz             sszClusterName( new WCHAR[ cchBufferSize ] );

            CLUSTERVERSIONINFO  cviClusterVersionInfo;
            
            if ( sszClusterName.FIsEmpty() )
            {
                dwError = TW32( ERROR_NOT_ENOUGH_MEMORY );
                TraceFlow1( "Error %#x occurred while allocating a buffer for the cluster name.", dwError );
                LogMsg( "Error %#x occurred while allocating a buffer for the cluster name.", dwError );
                break;
            } // if: memory allocation failed

            TraceFlow( "Memory for the cluster name has been allocated." );

            cviClusterVersionInfo.dwVersionInfoSize = sizeof( cviClusterVersionInfo );
            dwError = GetClusterInformation( 
                  schClusterHandle.HHandle()
                , sszClusterName.PMem()
                , &cchBufferSize
                , &cviClusterVersionInfo
                );

            if ( dwError == ERROR_SUCCESS )
            {
                // A warning is required if this node version is less than Win2k or
                // if there is a node in the cluster whose version is less than Win2k
                // NOTE: cviClusterVersionInfo.MajorVersion is the OS version
                //       while cviClusterVersionInfo.dwClusterHighestVersion is the cluster version.
                fWarningRequired = 
                    (    ( cviClusterVersionInfo.MajorVersion < 5 )
                      || ( CLUSTER_GET_MAJOR_VERSION( cviClusterVersionInfo.dwClusterHighestVersion ) < NT5_MAJOR_VERSION )
                    );

                if ( fWarningRequired )
                {
                    TraceFlow( "There is at least one node in the cluster whose OS version is earlier than Windows 2000." );
                    LogMsg( "There is at least one node in the cluster whose OS version is earlier than Windows 2000." );
                } // if: a warning will be shown
                else
                {
                    TraceFlow( "The OS versions of all the nodes in the cluster are Windows 2000 or later." );
                    LogMsg( "The OS versions of all the nodes in the cluster are Windows 2000 or later." );
                } // else: a warning will not be shown

                break;
            } // if: we got the cluster version info
            else
            {
                if ( dwError == ERROR_MORE_DATA )
                {
                    // Insufficient buffer - try again
                    ++cchBufferSize;
                    dwError = ERROR_SUCCESS;
                    TraceFlow1( "The buffer size is insufficient. Need %d bytes. Reallocating.", cchBufferSize );
                    continue;
                } // if: the size of the buffer was insufficient

                // If we are here, something has gone wrong - show the warning
                TW32( dwError );
                TraceFlow1( "Error %#x occurred trying to get cluster information.", dwError );
                LogMsg( "Error %#x occurred trying to get cluster information.", dwError );
               break;
            } // else: we could not get the cluster version info
        }
        while( true ); // loop infinitely

        // We are done.
        break;
    }
    while( false ); // Dummy do-while loop to avoid gotos

    while ( fWarningRequired ) 
    {
        SmartSz                 sszWarningTitle;
        COMPATIBILITY_ENTRY     ceCompatibilityEntry;

        TraceFlow( "The compatibility warning is required." );
        LogMsg( "The compatibility warning is required." );

        {
            WCHAR * pszWarningTitle = NULL;

            dwError = TW32( DwLoadString( IDS_ERROR_UPGRADE_OTHER_NODES, pszWarningTitle ) );
            if ( dwError != ERROR_SUCCESS )
            {
                // We cannot show the warning
                TraceFlow1( "Error %#x occurred trying to load the warning string.", dwError );
                LogMsg( "Error %#x occurred trying to show the warning.", dwError );
                break;
            } // if: the load string failed

            sszWarningTitle.Assign( pszWarningTitle );
        }

        //
        // Call the callback function
        //

        ceCompatibilityEntry.Description = sszWarningTitle.PMem();
        ceCompatibilityEntry.HtmlName = L"CompData\\ClusComp.htm";
        ceCompatibilityEntry.TextName = L"CompData\\ClusComp.txt";
        ceCompatibilityEntry.RegKeyName = NULL;
        ceCompatibilityEntry.RegValName = NULL ;
        ceCompatibilityEntry.RegValDataSize = 0;
        ceCompatibilityEntry.RegValData = NULL;
        ceCompatibilityEntry.SaveValue =  NULL;
        ceCompatibilityEntry.Flags = 0;
        ceCompatibilityEntry.InfName = NULL;
        ceCompatibilityEntry.InfSection = NULL;

        TraceFlow( "About to call the compatibility callback function." );

        // This function returns TRUE if the compatibility warning data was successfully set.
        fReturnValue = pfnCompatibilityCallbackIn( &ceCompatibilityEntry, pvContextIn );

        TraceFlow1( "The compatibility callback function returned %d.", fReturnValue );

        break;
    } // while: we need to show the warning

    if ( !fWarningRequired )
    {
        TraceFlow( "The compatibility warning need not be shown." );
        LogMsg( "The compatibility warning need not be shown." );
    } // if: we did not need to show the warning

    LogMsg( "Exiting function ClusterUpgradeCompatibilityCheck(). Return value is %d.", fReturnValue );
    RETURN( fReturnValue );

} //*** ClusterUpgradeCompatibilityCheck()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  DwIsClusterServiceRegistered()
//
//  Description:
//      This function determines whether the Cluster Service has been registered
//      with the Service Control Manager or not. It is not possible to use the 
//      GetNodeClusterState() API to see if this node is a member of a cluster
//      or not, since this API was not available on NT4 SP3.
//
//  Arguments:
//      bool & rfIsRegisteredOut
//          If true, Cluster Service (ClusSvc) is registered with the Service 
//          Control Manager (SCM). Else, Cluster Service (ClusSvc) is not 
//          registered with SCM
//
//  Return Value:
//      ERROR_SUCCESS if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
DwIsClusterServiceRegistered( bool & rfIsRegisteredOut )
{
    TraceFunc( "" );

    DWORD   dwError = ERROR_SUCCESS;

    // Initialize the output
    rfIsRegisteredOut = false;

    // dummy do-while loop to avoid gotos
    do
    {
        // Instantiate the SmartServiceHandle smart handle class.
        typedef CSmartResource< CHandleTrait< SC_HANDLE, BOOL, CloseServiceHandle, NULL > > SmartServiceHandle;


        // Connect to the Service Control Manager
        SmartServiceHandle shServiceMgr( OpenSCManager( NULL, NULL, GENERIC_READ ) );

        // Was the service control manager database opened successfully?
        if ( shServiceMgr.HHandle() == NULL )
        {
            dwError = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying open a handle to the service control manager.", dwError );
            LogMsg( "Error %#x occurred trying open a handle to the service control manager.", dwError );
            break;
        } // if: opening the SCM was unsuccessful


        // Open a handle to the Cluster Service.
        SmartServiceHandle shService( OpenService( shServiceMgr, L"ClusSvc", GENERIC_READ ) );

        // Was the handle to the service opened?
        if ( shService.HHandle() != NULL )
        {
            TraceFlow( "Successfully opened a handle to the cluster service. Therefore, it is registered." );
            rfIsRegisteredOut = true;
            break;
        } // if: handle to clussvc could be opened


        dwError = GetLastError();
        if ( dwError == ERROR_SERVICE_DOES_NOT_EXIST )
        {
            TraceFlow( "The cluster service is not registered." );
            dwError = ERROR_SUCCESS;
            break;
        } // if: the handle could not be opened because the service did not exist.

        // If we are here, then some error occurred.
        TW32( dwError );
        TraceFlow1( "Error %#x occurred trying open a handle to the cluster service.", dwError );
        LogMsg( "Error %#x occurred trying open a handle to the cluster service.", dwError );

        // Handles are closed by the CSmartHandle destructor.
    }
    while ( false ); // dummy do-while loop to avoid gotos

    RETURN( dwError );

} //*** DwIsClusterServiceRegistered()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DwLoadString()
//
//  Description:
//      Allocate memory for and load a string from the string table.
//
//  Arguments:
//      uiStringIdIn
//          Id of the string to look up
//
//      rpszDestOut
//          Reference to the pointer that will hold the address of the
//          loaded string. The memory will have to be freed by the caller
//          by using the delete operator.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other Win32 error codes
//          If the call failed.
//
//  Remarks:
//      This function cannot load a zero length string.
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
DwLoadString(
      UINT      nStringIdIn
    , WCHAR *&  rpszDestOut
    )
{
    TraceFunc( "" );

    DWORD     dwError = ERROR_SUCCESS;

    UINT        uiCurrentSize = 0;
    SmartSz     sszCurrentString;
    UINT        uiReturnedStringLen = 0;

    // Initialize the output.
    rpszDestOut = NULL;

    do
    {
        // Grow the current string by an arbitrary amount.
        uiCurrentSize += 256;

        sszCurrentString.Assign( new WCHAR[ uiCurrentSize ] );
        if ( sszCurrentString.FIsEmpty() )
        {
            dwError = TW32( ERROR_NOT_ENOUGH_MEMORY );
            TraceFlow2( "Error %#x occurred trying allocate memory for string (string id is %d).", dwError, nStringIdIn );
            LogMsg( "Error %#x occurred trying allocate memory for string (string id is %d).", dwError, nStringIdIn );
            break;
        } // if: the memory allocation has failed

        uiReturnedStringLen = ::LoadString(
                                  g_hInstance
                                , nStringIdIn
                                , sszCurrentString.PMem()
                                , uiCurrentSize
                                );

        if ( uiReturnedStringLen == 0 )
        {
            dwError = TW32( GetLastError() );
            TraceFlow2( "Error %#x occurred trying load string (string id is %d).", dwError, nStringIdIn );
            LogMsg( "Error %#x occurred trying load string (string id is %d).", dwError, nStringIdIn );
            break;
        } // if: LoadString() had an error

        ++uiReturnedStringLen;
    }
    while( uiCurrentSize <= uiReturnedStringLen );

    if ( dwError == ERROR_SUCCESS )
    {
        // Detach the smart pointer from the string, so that it is not freed by this function.
        // Store the string pointer in the output.
        rpszDestOut = sszCurrentString.PRelease();

    } // if: there were no errors in this function
    else
    {
        rpszDestOut = NULL;
    } // else: something went wrong

    RETURN( dwError );

} //*** DwLoadString()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  DwWriteOSVersionInfo()
//
//  Description:
//      This function writes the OS major and minor version information into the
//      registry. This information will be used later by ClusOCM to determine the
//      OS version before the upgrade.
//
//  Arguments:
//      const OSVERSIONINFO & rcosviOSVersionInfoIn
//          Reference to the OSVERSIONINFO structure that has information about the
//          OS version of this node.
//
//  Return Value:
//      ERROR_SUCCESS if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
DwWriteOSVersionInfo( const OSVERSIONINFO & rcosviOSVersionInfoIn )
{
    TraceFunc( "" );

    DWORD   dwError = ERROR_SUCCESS;

    // dummy do-while loop to avoid gotos
    do
    {
        // Instantiate the SmartRegistryKey smart handle class.
        typedef CSmartResource< CHandleTrait< HKEY, LONG, RegCloseKey, NULL > > SmartRegistryKey;
        SmartRegistryKey srkOSInfoKey;

        {
            HKEY hTempKey = NULL;

            // Open the node version info registry key
            dwError = TW32(
                RegCreateKeyEx(
                      HKEY_LOCAL_MACHINE
                    , CLUSREG_KEYNAME_NODE_DATA L"\\" CLUSREG_KEYNAME_PREV_OS_INFO
                    , 0
                    , L""
                    , REG_OPTION_NON_VOLATILE
                    , KEY_ALL_ACCESS
                    , NULL
                    , &hTempKey
                    , NULL
                    )
                );

            if ( dwError != ERROR_SUCCESS )
            {
                TraceFlow1( "Error %#x occurred trying create the registry key where the node OS info is stored.", dwError );
                LogMsg( "Error %#x occurred trying create the registry key where the node OS info is stored.", dwError );
                break;
            } // if: RegCreateKeyEx() failed

            srkOSInfoKey.Assign( hTempKey );
        }

        // Write the OS major version
        dwError = TW32(
            RegSetValueEx(
                  srkOSInfoKey.HHandle()
                , CLUSREG_NAME_NODE_MAJOR_VERSION
                , 0
                , REG_DWORD
                , reinterpret_cast< const BYTE * >( &rcosviOSVersionInfoIn.dwMajorVersion )
                , sizeof( rcosviOSVersionInfoIn.dwMajorVersion )
                )
            );

        if ( dwError != ERROR_SUCCESS )
        {
            TraceFlow1( "Error %#x occurred trying to store the OS major version info.", dwError );
            LogMsg( "Error %#x occurred trying to store the OS major version info.", dwError );
            break;
        } // if: RegSetValueEx() failed while writing rcosviOSVersionInfoIn.dwMajorVersion

        // Write the OS minor version
        dwError = TW32(
            RegSetValueEx(
                  srkOSInfoKey.HHandle()
                , CLUSREG_NAME_NODE_MINOR_VERSION
                , 0
                , REG_DWORD
                , reinterpret_cast< const BYTE * >( &rcosviOSVersionInfoIn.dwMinorVersion )
                , sizeof( rcosviOSVersionInfoIn.dwMinorVersion )
                )
            );

        if ( dwError != ERROR_SUCCESS )
        {
            TraceFlow1( "Error %#x occurred trying to store the OS minor version info.", dwError );
            LogMsg( "Error %#x occurred trying to store the OS minor version info.", dwError );
            break;
        } // if: RegSetValueEx() failed while writing rcosviOSVersionInfoIn.dwMinorVersion

        TraceFlow( "OS version information successfully stored in the registry." );
        LogMsg( "OS version information successfully stored in the registry." );
    }
    while ( false ); // dummy do-while loop to avoid gotos

    RETURN( dwError );

} //*** DwWriteOSVersionInfo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscomp\dll.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  Module Name:
//      Dll.cpp
//
//  Description:
//      DLL services/entry points.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//          Original version.
//
//      Vij Vasu (VVasu) 29-AUG-2000
//          Modified this file to remove dependency on Shell API since they
//          may not be present on the OS that this DLL runs in.
//          Removed unnecessary functions for the same reason.
//
//////////////////////////////////////////////////////////////////////////////

#include "pch.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// For tracing
DEFINE_MODULE("CLUSCOMP")

//
// DLL Globals
//
HINSTANCE g_hInstance = NULL;
LONG      g_cObjects  = 0;
LONG      g_cLock     = 0;
TCHAR     g_szDllFilename[ MAX_PATH ] = { 0 };

LPVOID    g_GlobalMemoryList = NULL;    // Global memory tracking list

#if !defined(NO_DLL_MAIN) || defined(DEBUG)
//////////////////////////////////////////////////////////////////////////////
//
// BOOL
// WINAPI
// DLLMain(
//      HANDLE  hInstIn,
//      ULONG   ulReasonIn,
//      LPVOID  lpReservedIn
//      )
//
// Description:
//      Dll entry point.
//
// Arguments:
//      hInstIn      - DLL instance handle.
//      ulReasonIn   - DLL reason code for entrance.
//      lpReservedIn - Not used.
//
//////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
DllMain(
    HANDLE  hInstIn,
    ULONG   ulReasonIn,
    LPVOID  // lpReservedIn
    )
{
    //
    // KB: NO_THREAD_OPTIMIZATIONS gpease 19-OCT-1999
    //
    // By not defining this you can prvent the linker
    // from calling you DllEntry for every new thread.
    // This makes creating new thread significantly
    // faster if every DLL in a process does it.
    // Unfortunately, not all DLLs do this.
    //
    // In CHKed/DEBUG, we keep this on for memory
    // tracking.
    //
#if defined( DEBUG )
    #define NO_THREAD_OPTIMIZATIONS
#endif // DEBUG

#if defined(NO_THREAD_OPTIMIZATIONS)
    switch( ulReasonIn )
    {
        case DLL_PROCESS_ATTACH:
        {
            TraceInitializeProcess( TRUE );
            TraceCreateMemoryList( g_GlobalMemoryList );

#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_PROCESS_ATTACH - ThreadID = %#x"),
                          GetCurrentThreadId( )
                          );
            FRETURN( TRUE );
#endif // DEBUG
            g_hInstance = (HINSTANCE) hInstIn;


            GetModuleFileName( g_hInstance, g_szDllFilename, MAX_PATH );
            break;
        }

        case DLL_PROCESS_DETACH:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_PROCESS_DETACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId( ),
                          g_cLock,
                          g_cObjects
                          );
            FRETURN( TRUE );
#endif // DEBUG
            TraceTerminateMemoryList( g_GlobalMemoryList );
            TraceTerminateProcess();
            break;
        }

        case DLL_THREAD_ATTACH:
        {
            TraceInitializeThread( NULL );
#if defined( DEBUG )
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("The thread 0x%x has started."),
                          GetCurrentThreadId( ) );
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_THREAD_ATTACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId( ),
                          g_cLock,
                          g_cObjects
                          );
            FRETURN( TRUE );
#endif // DEBUG
            break;
        }

        case DLL_THREAD_DETACH:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_THREAD_DETACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId( ),
                          g_cLock,
                          g_cObjects
                          );
            FRETURN( TRUE );
#endif // DEBUG
            TraceThreadRundown( );;
            break;
        }

        default:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: UNKNOWN ENTRANCE REASON - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId( ),
                          g_cLock,
                          g_cObjects
                          );
            FRETURN( TRUE );
#endif // DEBUG
            break;
        }
    }

    return TRUE;

#else // !NO_THREAD_OPTIMIZATIONS
    BOOL fResult;
    Assert( ulReasonIn == DLL_PROCESS_ATTACH || ulReasonIn == DLL_PROCESS_DETACH );
#if defined(DEBUG)
    TraceInitializeProcess( TRUE );
#endif // DEBUG
    g_hInstance = (HINSTANCE) hInstIn;
    GetModuleFileName( g_hInstance, g_szDllFilename, MAX_PATH );
    fResult = DisableThreadLibraryCalls( g_hInstance );
    AssertMsg( fResult, "*ERROR* DisableThreadLibraryCalls( ) failed." );
    return TRUE;
#endif // NO_THREAD_OPTIMIZATIONS

} //*** DllMain()
#endif // !defined(NO_DLL_MAIN) && !defined(DEBUG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\cclusocm.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ClusOCM.cpp
//
//  Description:
//      This file contains the implementation of the entry point used by OC
//      Manager.
//
//  Documentation:
//      [1] 2001 Setup - Architecture.doc
//          Architecture of the DLL for Whistler (Windows 2001)
//
//      [2] 2000 Setup - FuncImpl.doc
//          Contains description of the previous version of this DLL (Windows 2000)
//
//      [3] http://winweb/setup/ocmanager/OcMgr1.doc
//          Documentation about the OC Manager API
//
//  Header File:
//      There is no header file for this source file.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//          Created the original version.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL
#include "pch.h"


//////////////////////////////////////////////////////////////////////////////
// Global variables
//////////////////////////////////////////////////////////////////////////////

// The global application object.
CClusOCMApp g_coaTheApp;


/////////////////////////////////////////////////////////////////////////////
//++
//
//  extern "C"
//  DWORD
//  ClusOcmSetupProc
//
//  Description:
//      This is an exported function that the OC Manager uses to communicate
//      with ClusOCM. See document [3] in the header of this file for details.
//
//      This function is just a stub for CClusOCMApp::DwClusOcmSetupProc.
//
//  Arguments:
//      LPCVOID pvComponentIdIn
//          Pointer to a string that uniquely identifies the component.
//
//      LPCVOID pvSubComponentIdIn
//          Pointer to a string that uniquely identifies a sub-component in
//          the component's hiearchy.
//
//      UINT uiFunctionCodeIn
//          A numeric value indicating which function is to be perfomed.
//          See ocmanage.h for the macro definitions.
//
//      UINT uiParam1In
//          Supplies a function specific parameter.
//
//      PVOID pvParam2Inout
//          Pointer to a function specific parameter (either input or
//          output).
//
//  Return Value:
//      A function specific value is returned to OC Manager.
//
//--
/////////////////////////////////////////////////////////////////////////////
extern "C"
DWORD
ClusOcmSetupProc(
      IN        LPCVOID    pvComponentIdIn
    , IN        LPCVOID    pvSubComponentIdIn
    , IN        UINT       uiFunctionCodeIn
    , IN        UINT       uiParam1In
    , IN OUT    PVOID      pvParam2Inout
    )
{
    return g_coaTheApp.DwClusOcmSetupProc(
          pvComponentIdIn
        , pvSubComponentIdIn
        , uiFunctionCodeIn
        , uiParam1In
        , pvParam2Inout
        );
} //*** ClusOcmSetupProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\cluscomp\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file for the ClusComp DLL.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once


//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#if DBG==1 || defined( _DEBUG )
#define DEBUG
#endif

//
// KB: DEBUG_SUPPORT_NT4 DavidP 05-OCT-2000
//      Defining this to make sure that the debug macros don't do something
//      that won't work for NT4.
#define DEBUG_SUPPORT_NT4

////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>

// For a few global variables
#include "Dll.h"

// For tracing and debugging functions
#include "Debug.h"

// For logging functions
#include <Log.h>

// For the definition of smart pointer and handle templates
#include "SmartClasses.h"

// For the string ids
#include "ClusCompResources.h"


//////////////////////////////////////////////////////////////////////////////
// Type definitions
//////////////////////////////////////////////////////////////////////////////

// Smart pointer to a character string.
typedef CSmartGenericPtr< CPtrTrait< WCHAR > >  SmartSz;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\cclusocmapp.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusOCMApp.cpp
//
//  Description:
//      ClusOCM.DLL is an Optional Components Manager DLL for installation of
//      Microsoft Cluster Server. This file contains the definition of the
//      class ClusOCMApp, which is the main class of the ClusOCM DLL.
//
//  Documentation:
//      [1] 2001 Setup - Architecture.doc
//          Architecture of the DLL for Whistler (Windows 2001)
//
//      [2] 2000 Setup - FuncImpl.doc
//          Contains description of the previous version of this DLL (Windows 2000)
//
//      [3] http://winweb/setup/ocmanager/OcMgr1.doc
//          Documentation about the OC Manager API
//
//  Header File:
//      CClusOCMApp.h
//
//  Maintained By:
//      C. Brent Thomas (a-brentt) 01-JAN-1998
//          Created the original version.
//
//      Vij Vasu (Vvasu) 03-MAR-2000
//          Adapted for Whistler (Windows 2001). See documentation for more 
//          complete details. Major changes are:
//
//          - This DLL no longer uses MFC. Class structure has changed.
//
//          - Cluster binaries are always installed. So, uninstall functionality
//            has been removed from this DLL.
//
//          - Upgrade on a computer that does not have the cluster binaries
//            should now install the binaries.
//
//          - CluAdmin completely functional by the end of install of binaries.
//
//          - Time Service no longer installed.
//
//          - Complete change in coding and commenting style.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "pch.h"

// The header file for this module.
#include "CClusOCMApp.h"

// For the CTaskCleanInstall class
#include "CTaskCleanInstall.h"

// For the CTaskUpgradeNT4 class
#include "CTaskUpgradeNT4.h"

// For the CTaskUpgradeWin2k class
#include "CTaskUpgradeWin2k.h"

// For the CTaskUpgradeWhistler class
#include "CTaskUpgradeWhistler.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CClusOCMApp" )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusOCMApp::CClusOCMApp
//
//  Description:
//      Constructor of the CClusOCMApp class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusOCMApp::CClusOCMApp( void )
    : m_fIsUnattendedSetup( false )
    , m_fIsUpgrade( false )
    , m_fIsGUIModeSetup( false )
    , m_fAttemptedTaskCreation( false )
    , m_cisCurrentInstallState( eClusterInstallStateUnknown )
    , m_dwFirstError( NO_ERROR )
{
    TraceFunc( "" );

    memset( &m_sicSetupInitComponent, 0, sizeof( m_sicSetupInitComponent ) );
    TraceFuncExit();

} //*** CClusOCMApp::CClusOCMApp()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusOCMApp::~CClusOCMApp
//
//  Description:
//      Destructor of the CClusOCMApp class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusOCMApp::~CClusOCMApp( void )
{
    TraceFunc( "" );

    TraceFuncExit();

} //*** CClusOCMApp::CClusOCMApp()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMApp::DwClusOcmSetupProc
//
//  Description:
//      This function is called by the entry point of this DLL, DwClusOcmSetupProc.
//      See document [3] in the header of this file for details.
//
//      This function determines what actions need to be taken (upgrade, clean
//      install, etc., and pass control accordingly to the correct routines.
//
//  Arguments:
//      LPCVOID pvComponentIdIn
//          Pointer to a string that uniquely identifies the component.
//
//      LPCVOID pvSubComponentIdIn
//          Pointer to a string that uniquely identifies a sub-component in 
//          the component's hiearchy.
//
//      UINT uiFunctionCodeIn
//          A numeric value indicating which function is to be perfomed.
//          See ocmanage.h for the macro definitions.
//
//      UINT uiParam1In
//          Supplies a function specific parameter.
//
//      PVOID pvParam2Inout
//          Pointer to a function specific parameter (either input or output).
//
//  Return Value:
//      A function specific value is returned to OC Manager.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMApp::DwClusOcmSetupProc(
      LPCVOID    pvComponentIdIn
    , LPCVOID    pvSubComponentIdIn
    , UINT       uiFunctionCodeIn
    , UINT       uiParam1In
    , PVOID      pvParam2Inout 
    )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Switch based on the function code passed in by OC Manager.
    switch ( uiFunctionCodeIn )
    {
        // This is the first function that OC Manager calls.
        case OC_PREINITIALIZE:
        {
            TraceFlow( "OC Manager called OC_PREINITIALIZE." );
            LogMsg( "OC Manager called OC_PREINITIALIZE." );

            // Return OCFLAG_UNICODE to indicate that only UNICODE is to be used.
            dwReturnValue = OCFLAG_UNICODE;

        } // case OC_PREINITIALIZE
        break;


        //
        // This function is called soon after the component's setup dll is
        // loaded. This function provides initialization information to the
        // dll, instructs the dll to initialize itself, and provides a
        // mechanism for the dll to return information to OC Manager.
        //
        case OC_INIT_COMPONENT:
        {
            TraceFlow1( 
                  "OC Manager called OC_INIT_COMPONENT for the component '%s'."
                , reinterpret_cast< LPCWSTR >( pvComponentIdIn )
                );

            LogMsg( 
                  "OC Manager called OC_INIT_COMPONENT for the component '%s'."
                , reinterpret_cast< LPCWSTR >( pvComponentIdIn )
                );

            dwReturnValue = TW32( DwOcInitComponentHandler( reinterpret_cast< PSETUP_INIT_COMPONENT >( pvParam2Inout ) ) );

        } // case OC_INIT_COMPONENT
        break;


        // Get the initial, current and final state of the component.
        case OC_QUERY_STATE:
        {
            TraceFlow( "OC Manager called OC_QUERY_STATE." );
            LogMsg( "OC Manager called OC_QUERY_STATE." );

            dwReturnValue = DwOcQueryStateHandler( uiParam1In );

        } // case OC_QUERY_STATE
        break;


        // OC Manager is asking approval for a user selection of installation state.
        case OC_QUERY_CHANGE_SEL_STATE:
        {
            TraceFlow( "OC Manager called OC_QUERY_CHANGE_SEL_STATE." );
            LogMsg( "OC Manager called OC_QUERY_CHANGE_SEL_STATE." );

            //
            // The cluster service has to be always installed. So, disallow any state
            // change that deselects the cluster service (by returning FALSE).
            //

            // The component has been deselected if uiParam1In is 0.
            if ( uiParam1In == 0 )
            {
                TraceFlow( "Disallowing deselection of the Cluster Service." );
                LogMsg( "Disallowing deselection of the Cluster Service." );
                dwReturnValue = FALSE;
            }
            else
            {
                TraceFlow( "Allowing selection of the Cluster Service." );
                LogMsg( "Allowing selection of the Cluster Service." );
                dwReturnValue = TRUE;
            }

        } // case OC_QUERY_CHANGE_SEL_STATE
        break;


        // Instructs the component to change to a given language if it can.
        case OC_SET_LANGUAGE:
        {
            TraceFlow( "OC Manager called OC_SET_LANGUAGE." );
            LogMsg( "OC Manager called OC_SET_LANGUAGE." );

            dwReturnValue = SetThreadLocale( MAKELCID( PRIMARYLANGID( uiParam1In ), SORT_DEFAULT ) );

        } // case OC_SET_LANGUAGE
        break;


        //
        // Directs the component to manipulate a Setup API Disk Space List, 
        // placing files on it or removing files from it, to mirror what will be 
        // actually installed later via a Setup API file queue.
        //
        case OC_CALC_DISK_SPACE:
        {
            CClusOCMTask * pCurrentTask = NULL;

            TraceFlow( "OC Manager called OC_CALC_DISK_SPACE." );
            LogMsg( "OC Manager called OC_CALC_DISK_SPACE." );

            dwReturnValue = TW32( DwGetCurrentTask( pCurrentTask ) );
            if ( dwReturnValue != NO_ERROR )
            {
                DwSetError( dwReturnValue );
                TraceFlow1( "Error %#x occurred trying to get a pointer to the current task.", dwReturnValue );
                LogMsg( "Error %#x occurred trying to get a pointer to the current task.", dwReturnValue );
                break;
            } // if: we could not get the current task pointer

            if ( pCurrentTask != NULL )
            {
                dwReturnValue = TW32(
                    pCurrentTask->DwOcCalcDiskSpace(
                          ( uiParam1In != 0 )         // non-zero uiParam1In means "add to disk space requirements"
                        , reinterpret_cast< HDSKSPC >( pvParam2Inout )
                        )
                    );

                // Note: Do not call DwSetError() here if the above function failed. Failure to calculate disk space
                // is to be expected if the binaries are not accessible at this time (for example, they are on a
                // network share and the credentials for this share have not been entered yet). This is not fatal and
                // hence should not trigger a cleanup.

            } // if: there is something to do
            else
            {
                TraceFlow( "There is no task to be performed." );
                LogMsg( "There is no task to be performed." );
            } // else: there is nothing to do.
        } // case OC_CALC_DISK_SPACE
        break;


        //
        // Directs the component to queue file operations for installation, based on
        // user interaction with the wizard pages and other component-specific factors.
        // 
        case OC_QUEUE_FILE_OPS:
        {
            CClusOCMTask * pCurrentTask = NULL;

            TraceFlow( "OC Manager called OC_QUEUE_FILE_OPS." );
            LogMsg( "OC Manager called OC_QUEUE_FILE_OPS." );

            if ( DwGetError() != NO_ERROR )
            {
                // If an error has occurred previously, do not do this operation.
                TraceFlow( "An error has occurred earlier in this task. Nothing will be done here." );
                LogMsg( "An error has occurred earlier in this task. Nothing will be done here." );
                break;
            } // if: an error has occurred previously

            dwReturnValue = TW32( DwGetCurrentTask( pCurrentTask ) );
            if ( dwReturnValue != NO_ERROR )
            {
                DwSetError( dwReturnValue );
                TraceFlow1( "Error %#x occurred trying to get a pointer to the current task.", dwReturnValue );
                LogMsg( "Error %#x occurred trying to get a pointer to the current task.", dwReturnValue );
                break;
            } // if: we could not get the current task pointer

            if ( pCurrentTask != NULL )
            {
                dwReturnValue = TW32( 
                    DwSetError( 
                        pCurrentTask->DwOcQueueFileOps( 
                            reinterpret_cast< HSPFILEQ >( pvParam2Inout )
                            )
                        )
                    );
            } // if: there is something to do
            else
            {
                TraceFlow( "There is no task to be performed." );
                LogMsg( "There is no task to be performed." );
            } // else: there is nothing to do.
        } // case OC_QUEUE_FILE_OPS
        break;


        //
        // Allows the component to perform any additional operations needed
        // to complete installation, for example registry manipulations, and
        // so forth.
        //
        case OC_COMPLETE_INSTALLATION:
        {
            CClusOCMTask * pCurrentTask = NULL;

            TraceFlow( "OC Manager called OC_COMPLETE_INSTALLATION." );
            LogMsg( "OC Manager called OC_COMPLETE_INSTALLATION." );

            if ( DwGetError() != NO_ERROR )
            {
                // If an error has occurred previously, do not do this operation.
                TraceFlow( "An error has occurred earlier in this task. Nothing will be done here." );
                LogMsg( "An error has occurred earlier in this task. Nothing will be done here." );
                break;
            } // if: an error has occurred previously

            dwReturnValue = TW32( DwGetCurrentTask( pCurrentTask ) );
            if ( dwReturnValue != NO_ERROR )
            {
                DwSetError( dwReturnValue );
                TraceFlow1( "Error %#x occurred trying to get a pointer to the current task.", dwReturnValue );
                LogMsg( "Error %#x occurred trying to get a pointer to the current task.", dwReturnValue );
                break;
            } // if: we could not get the current task pointer

            if ( pCurrentTask != NULL )
            {
                dwReturnValue = TW32( DwSetError( pCurrentTask->DwOcCompleteInstallation() ) );
            } // if: there is something to do
            else
            {
                TraceFlow( "There is no task to be performed." );
                LogMsg( "There is no task to be performed." );
            } // else: there is nothing to do.
        } // case OC_COMPLETE_INSTALLATION
        break;


        //
        // Informs the component that it is about to be unloaded.
        //
        case OC_CLEANUP:
        {
            CClusOCMTask * pCurrentTask = NULL;

            TraceFlow( "OC Manager called OC_CLEANUP." );
            LogMsg( "OC Manager called OC_CLEANUP." );

            dwReturnValue = TW32( DwGetCurrentTask( pCurrentTask ) );
            if ( dwReturnValue != NO_ERROR )
            {
                DwSetError( dwReturnValue );
                TraceFlow1( "Error %#x occurred trying to get a pointer to the current task.", dwReturnValue );
                LogMsg( "Error %#x occurred trying to get a pointer to the current task.", dwReturnValue );
                break;
            } // if: we could not get the current task pointer

            if ( pCurrentTask != NULL )
            {
                dwReturnValue = TW32( DwSetError( pCurrentTask->DwOcCleanup() ) );

                // Once the cleanup is done, we have nothing else to do. Free the task object.
                ResetCurrentTask();
            } // if: there is something to do
            else
            {
                TraceFlow( "There is no task to be performed." );
                LogMsg( "There is no task to be performed." );
            } // else: there is nothing to do.
        } // case OC_CLEANUP
        break;


        default:
        {
            TraceFlow1( "OC Manager called unknown function. Function code is %#x.", uiFunctionCodeIn );
            LogMsg( "OC Manager called unknown function. Function code is %#x.", uiFunctionCodeIn );
        } // case: default
    } // switch( uiFunctionCodeIn )


    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMApp::DwClusOcmSetupProc()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMApp::DwOcInitComponentHandler
//
//  Description:
//      This function handles the OC_INIT_COMPONENT messages from the Optional
//      Components Manager.
//
//      This function is called soon after the component's setup dll is
//      loaded. This checks OS and OC Manager versions, initializes CClusOCMApp
//      data members, determines the cluster service installation state, etc.
//
//  Arguments:
//      PSETUP_INIT_COMPONENT pSetupInitComponentInout
//          Pointer to a SETUP_INIT_COMPONENT structure.
//
//  Return Value:
//      NO_ERROR
//          Call was successful.
//
//      ERROR_CALL_NOT_IMPLEMENTED
//          The OC Manager and this DLLs versions are not compatible.
//
//      ERROR_CANCELLED
//          Any other error occurred. No other error codes are returned.
//          The actual error is logged.
//
//  Remarks:
//      The SETUP_INIT_COMPONENT structure pointed to by pSetupInitComponentInout
//      is not persistent. It is therefore necessary to save a copy locally.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMApp::DwOcInitComponentHandler(
    PSETUP_INIT_COMPONENT pSetupInitComponentInout
    )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD                   dwReturnValue = NO_ERROR;
    UINT                    uiStatus;
    eClusterInstallState    cisTempState = eClusterInstallStateUnknown;


    // Dummy do-while loop to avoid gotos.
    do
    {
        if ( pSetupInitComponentInout == NULL )
        {
            TraceFlow( "Error: Pointer to the SETUP_INIT_COMPONENT structure is NULL." );
            LogMsg( "Error: Pointer to the SETUP_INIT_COMPONENT structure is NULL." );
            dwReturnValue = TW32( ERROR_CANCELLED );
            break;
        } // if: pSetupInitComponentInout is NULL


        // Indicate to OC Manager which version of OC Manager this dll expects.
        pSetupInitComponentInout->ComponentVersion = OCMANAGER_VERSION;

        // Save the SETUP_INIT_COMPONENT structure.
        SetSetupState( *pSetupInitComponentInout );


        //
        // Determine if the OC Manager version is correct.
        //
        if ( OCMANAGER_VERSION > RsicGetSetupInitComponent().OCManagerVersion )
        {
            // Indicate failure.

            TraceFlow2( 
                "Error: OC Manager version mismatch. Version %d is required, Version %d was reported.",
                OCMANAGER_VERSION, 
                RsicGetSetupInitComponent().OCManagerVersion 
                );

            LogMsg( 
                "Error: OC Manager version mismatch. Version %d is required, Version %d was reported.",
                OCMANAGER_VERSION, 
                RsicGetSetupInitComponent().OCManagerVersion 
                );

            dwReturnValue = TW32( ERROR_CALL_NOT_IMPLEMENTED );
            break;
        } // if: the OC Manager version is incorrect.


        TraceFlow( "The OC Manager version matches with the version of this component." );
        LogMsg( "The OC Manager version matches with the version of this component." );

#if 0
/*
        // KB: 06-DEC-2000 DavidP
        //      Since ClusOCM only copies files and registers some COM objects,
        //      there is no longer any reason to perform an OS check.  We now
        //      depend on this happening in the service when the node is added
        //      to a cluster.

        //
        // Check OS version and suite information.
        //
        TraceFlow( "Checking if OS version and Product Suite are compatible..." );
        LogMsg( "Checking if OS version and Product Suite are compatible..." );
        if ( ClRtlIsOSValid() == FALSE )
        {
            // The OS version and/or Product Suite are not compatible

            DWORD dwErrorCode = TW32( GetLastError() );

            TraceFlow( "Cluster Service cannot be installed on this computer. The version or product suite of the operating system is incorrect." );
            LogMsg( "Cluster Service cannot be installed on this computer. The version or product suite of the operating system is incorrect." );
            TraceFlow1( "ClRtlIsOSValid failed with error code %#x.", dwErrorCode );
            LogMsg( "ClRtlIsOSValid failed with error code %#x.", dwErrorCode );
            dwReturnValue = ERROR_CANCELLED;
            break;
        } // if: OS version and/or Product Suite are not compatible

        TraceFlow( "OS version and product suite are correct." );
        LogMsg( "OS version and product suite are correct." );
*/
#endif


        // Is the handle to the component INF valid?
        if (    ( RsicGetSetupInitComponent().ComponentInfHandle == INVALID_HANDLE_VALUE ) 
             || ( RsicGetSetupInitComponent().ComponentInfHandle == NULL ) 
           )
        {
            // Indicate failure.
            LogMsg( "Error: ComponentInfHandle is invalid." );
            TraceFlow( "Error: ComponentInfHandle is invalid." );
            dwReturnValue = TW32( ERROR_CANCELLED );
            break;
        } // if: the INF file handle is not valid.


        //
        // The following call to SetupOpenAppendInfFile ensures that layout.inf
        // gets appended to ClusOCM.inf. This is required for several reasons
        // dictated by the Setup API. In theory OC Manager should do this, but
        // as per Andrew Ritz, 8/24/98, OC manager neglects to do it and it is
        // harmless to do it here after OC Manager is revised.
        //
        // Note that passing NULL as the first parameter causes SetupOpenAppendInfFile
        // to append the file(s) listed on the LayoutFile entry in clusocm.inf.
        //
        // The above comment was written by Brent.
        // TODO: Check if this is still needed. (Vij Vasu, 05-MAR-2000)
        //
        SetupOpenAppendInfFile(
            NULL, 
            RsicGetSetupInitComponent().ComponentInfHandle,
            &uiStatus 
            );


        //
        // Determine the current installation state of the cluster service. This can
        // be done by calling the function ClRtlGetClusterInstallState.
        // However, on machines that are upgrading from NT4, this will not work and
        // the correct installation state can be found out only by checking if the 
        // cluster service is registered (ClRtlGetClusterInstallState will return
        // eClusterInstallStateUnknown in this case)
        //
        dwReturnValue = ClRtlGetClusterInstallState( NULL, &cisTempState );
        if ( dwReturnValue != ERROR_SUCCESS )
        {
            TraceFlow1( "Error %#x occurred calling ClRtlGetClusterInstallState(). Cluster Service installation state cannot be determined.", dwReturnValue );
            LogMsg( "Error %#x occurred calling ClRtlGetClusterInstallState(). Cluster Service installation state cannot be determined.", dwReturnValue );
            dwReturnValue = TW32( ERROR_CANCELLED );
            break;
        } // if: ClRtlGetClusterInstallState failed

        if ( cisTempState == eClusterInstallStateUnknown )
        {
            bool fRegistered = false;

            dwReturnValue = TW32( DwIsClusterServiceRegistered( &fRegistered ) );
            if ( dwReturnValue != ERROR_SUCCESS )
            {
                TraceFlow1( "Error %#x: Could not check if the cluster service was registered or not.", dwReturnValue );
                LogMsg( "Error %#x: Could not check if the cluster service was registered or not.", dwReturnValue );
                dwReturnValue = ERROR_CANCELLED;
                break;
            }

            TraceFlow( "ClRtlGetClusterInstallState() returned eClusterInstallStateUnknown. Trying to see if the service is registered." );
            LogMsg( "ClRtlGetClusterInstallState() returned eClusterInstallStateUnknown. Trying to see if the service is registered." );
            if ( fRegistered )
            {
                TraceFlow( "The Cluster Service is registered. Setting current installation state to eClusterInstallStateConfigured." );
                LogMsg( "The Cluster Service is registered. Setting current installation state to eClusterInstallStateConfigured." );
                cisTempState = eClusterInstallStateConfigured;
            }
            else
            {
                TraceFlow( "The Cluster Service is not registered." );
                LogMsg( "The Cluster Service is not registered." );
            } // else: Cluster Service is not registered.
        } // if: ClRtlGetClusterInstallState returned eClusterInstallStateUnknown

        TraceFlow1( "The current installation state of the cluster service is %#x.", cisTempState );
        LogMsg( "The current installation state of the cluster service is %#x.", cisTempState );

        // Store the current cluster installation state.
        CisStoreClusterInstallState( cisTempState );

    }
    while ( false ); // dummy do-while loop to avoid gotos

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );
    
    RETURN( dwReturnValue );

} //*** CClusOCMApp::DwOcInitComponentHandler()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMApp::DwOcQueryStateHandler
//
//  Description:
//      This function handles the OC_QUERY_STATE messages from the Optional
//      Components Manager.
//
//      This function is called called at least thrice, once each to get the 
//      initial, current and the final installation states.
//
//      The initial state is the state before ClusOCM was called.
//
//      The current state is the current selection state. This is always
//      'On' because the cluster binaries are always installed.
//
//      The final state is the state after ClusOCM has done its tasks.
//
//  Arguments:
//      UINT uiSelStateQueryTypeIn
//          The type of query - OCSELSTATETYPE_ORIGINAL, OCSELSTATETYPE_CURRENT
//          or OCSELSTATETYPE_FINAL.
//
//  Return Value:
//      SubcompOn
//          Indicates that the checkbox next to the component in the OC
//          Manager UI should be set.
//
//      SubcompOff
//          Indicates that the checkbox should be cleared.
//
//      SubcompUseOcManagerDefault
//          OC Manager should set the state of the checkbox.
//
//  Remarks:
//      This function has to be called after DwOcInitComponentHandler, otherwise
//      the initial installation state may not be set correctly.
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMApp::DwOcQueryStateHandler( UINT uiSelStateQueryTypeIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = SubcompUseOcManagerDefault;

    switch( uiSelStateQueryTypeIn )
    {
        case OCSELSTATETYPE_ORIGINAL:
        {
            TraceFlow( "OC Manager is querying for the original state." );
            LogMsg( "OC Manager is querying for the original state." );

            //
            // If the cluster binaries have been installed or if cluster service
            // has been configured, then the original installation state is on.
            //
            dwReturnValue =   ( CisGetClusterInstallState() == eClusterInstallStateUnknown )
                            ? SubcompOff
                            : SubcompOn;
        } // case: OCSELSTATETYPE_ORIGINAL
        break;

        case OCSELSTATETYPE_CURRENT:
        {
            // The current state is always on.
            TraceFlow( "OC Manager is querying for the current state." );
            LogMsg( "OC Manager is querying for the current state." );

            dwReturnValue = SubcompOn;
        } // case: OCSELSTATETYPE_CURRENT
        break;

        case OCSELSTATETYPE_FINAL:
        {
            TraceFlow( "OC Manager is querying for the final state." );
            LogMsg( "OC Manager is querying for the final state." );

            //
            // If we are here, then the OC_COMPLETE_INSTALLATION has already
            // been called. At this stage CisStoreClusterInstallState() reflects
            // the state after ClusOCM has done its tasks.
            //
            dwReturnValue =   ( CisGetClusterInstallState() == eClusterInstallStateUnknown )
                            ? SubcompOff
                            : SubcompOn;
        } // case: OCSELSTATETYPE_FINAL
        break;

    }; // switch: based on uiSelStateQueryTypeIn

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMApp::DwOcQueryStateHandler()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  CClusOCMApp::SetSetupState
//
//  Description:
//      Set the SETUP_INIT_COMPONENT structure. Use this structure and set
//      various setup state variables.
//
//  Arguments:
//      const SETUP_INIT_COMPONENT & sicSourceIn
//          The source SETUP_INIT_COMPONENT structure, usually passed in by
//          the OC Manager.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CClusOCMApp::SetSetupState( const SETUP_INIT_COMPONENT & sicSourceIn )
{
    TraceFunc( "" );

    m_sicSetupInitComponent = sicSourceIn;

    m_fIsUnattendedSetup = ( 
                             (   m_sicSetupInitComponent.SetupData.OperationFlags 
                               & (DWORDLONG) SETUPOP_BATCH
                             ) 
                             !=
                             (DWORDLONG) 0L
                           );

    m_fIsUpgrade = (
                     (   m_sicSetupInitComponent.SetupData.OperationFlags
                       & (DWORDLONG) SETUPOP_NTUPGRADE
                     ) 
                     !=
                     (DWORDLONG) 0L
                   );

    m_fIsGUIModeSetup = ( 
                          (   m_sicSetupInitComponent.SetupData.OperationFlags 
                            & (DWORDLONG) SETUPOP_STANDALONE
                          ) 
                          ==
                          (DWORDLONG) 0L
                        );

    // Log setup state.
    TraceFlow3( 
          "This is an %s, %s setup session. This is%s an upgrade."
        , FIsUnattendedSetup() ? L"unattended" : L"attended"
        , FIsGUIModeSetup() ? L"GUI mode" : L"standalone"
        , FIsUpgrade() ? L"" : L" not"
        );

    LogMsg( 
          "This is an %s, %s setup session. This is%s an upgrade."
        , FIsUnattendedSetup() ? L"unattended" : L"attended"
        , FIsGUIModeSetup() ? L"GUI mode" : L"standalone"
        , FIsUpgrade() ? L"" : L" not"
        );

    TraceFuncExit();

} //*** CClusOCMApp::SetSetupState()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMApp::DwIsClusterServiceRegistered
//
//  Description:
//      This function determines whether the Cluster Service has been registered
//      with the Service Control Manager. If it is, it means that it has already
//      been configured. This check is required in nodes being upgraded from NT4
//      where ClRtlGetClusterInstallState() will not work.
//
//  Arguments:
//      bool * pfIsRegisteredOut
//          If true, Cluster Service (ClusSvc) is registered with the Service 
//          Control Manager (SCM). Else, Cluster Service (ClusSvc) is not 
//          registered with SCM
//
//  Return Value:
//      ERROR_SUCCESS if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMApp::DwIsClusterServiceRegistered( bool * pfIsRegisteredOut ) const
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    bool    fIsRegistered = false;
    DWORD   dwReturnValue = ERROR_SUCCESS;

    // dummy do-while loop to avoid gotos
    do
    {
        // Connect to the Service Control Manager
        SmartServiceHandle shServiceMgr( OpenSCManager( NULL, NULL, GENERIC_READ ) );

        // Was the service control manager database opened successfully?
        if ( shServiceMgr.HHandle() == NULL )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying to open a connection to the local service control manager.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to open a connection to the local service control manager.", dwReturnValue );
            break;
        } // if: opening the SCM was unsuccessful


        // Open a handle to the Cluster Service.
        SmartServiceHandle shService( OpenService( shServiceMgr, L"ClusSvc", GENERIC_READ ) );


        // Was the handle to the service opened?
        if ( shService.HHandle() != NULL )
        {
            TraceFlow( "The cluster service is registered." );
            LogMsg( "The cluster service is registered." );
            fIsRegistered = true;
            break;
        } // if: handle to clussvc could be opened


        dwReturnValue = GetLastError();
        if ( dwReturnValue == ERROR_SERVICE_DOES_NOT_EXIST )
        {
            dwReturnValue = ERROR_SUCCESS;
            TraceFlow( "ClusSvc does not exist as a service." );
            LogMsg( "ClusSvc does not exist as a service." );
            break;
        } // if: the handle could not be opened because the service did not exist.


        // Some error occurred.
        TW32( dwReturnValue);
        TraceFlow1( "Error %#x occurred trying to open a handle to the cluster service.", dwReturnValue );
        LogMsg( "Error %#x occurred trying to open a handle to the cluster service.", dwReturnValue );

        // Handles are closed by the CSmartHandle destructor.
    }
    while ( false ); // dummy do-while loop to avoid gotos

    if ( pfIsRegisteredOut != NULL )
    {
        *pfIsRegisteredOut = fIsRegistered;
    }

    TraceFlow2( "fIsRegistered is %d. Return Value is %#x.", fIsRegistered, dwReturnValue );
    LogMsg( "fIsRegistered is %d. Return Value is %#x.", fIsRegistered, dwReturnValue );
    
    RETURN( dwReturnValue );

} //*** CClusOCMApp::DwIsClusterServiceRegistered()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMApp::DwGetCurrentTask
//
//  Description:
//      This function returns a pointer to the current task object. If a task
//      object has not been created yet, it creates the appropriate task.
//
//  Arguments:
//      CClusOCMTask *& rpTaskOut
//          Reference to the pointer to the current task. Do not try to 
//          free this memory.
//
//          If no task needs to be performed, a NULL pointer is returned.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//
//  Remarks:
//      This function will work properly only after the member variables which
//      indicate which task will be performed have been initialized correctly.
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMApp::DwGetCurrentTask( CClusOCMTask *& rpTaskOut )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD           dwReturnValue = NO_ERROR;

    // Initialize the output.
    rpTaskOut = NULL;

    do
    {
        eClusterInstallState ecisCurrentState;

        if ( m_fAttemptedTaskCreation )
        {
            // A task object already exists - just return it.
            TraceFlow( "A task object already exists. Returning it." );
            LogMsg( "A task object already exists. Returning it." );

            rpTaskOut = m_sptaskCurrentTask.PMem();
            break;
        } // if: the task object has already been created.

        TraceFlow( "Creating a new task object." );
        LogMsg( "Creating a new task object." );

        // Make note of the fact that we have started our attempt to create a task object.
        m_fAttemptedTaskCreation = true;

        // Reset the task pointer.
        m_sptaskCurrentTask.Assign( NULL );

        // Get the current installation state to deduce what operation to perform.
        ecisCurrentState = CisGetClusterInstallState();

        // The task object has not been created yet - create one now.
        if ( ecisCurrentState == eClusterInstallStateUnknown )
        {
            TraceFlow( "The cluster installation state is not known. Assuming that a clean install is required." );
            LogMsg( "The cluster installation state is not known. Assuming that a clean install is required." );

            // If the installation state is unknown, assume that the cluster binaries
            // are not installed.
            rpTaskOut = new CTaskCleanInstall( *this );
            if ( rpTaskOut == NULL )
            {
                TraceFlow( "Error: There was not enough memory to create a clean install task." );
                LogMsg( "Error: There was not enough memory to start a clean install." );
                dwReturnValue = TW32( ERROR_NOT_ENOUGH_MEMORY );
                break;
            } // if: memory allocation failed
        } // if: the cluster installation state is eClusterInstallStateUnknown
        else if ( m_fIsUpgrade )
        {
            //
            // If we are here, it means that an upgrade is in progress and the cluster binaries
            // have already been installed on the OS being upgraded. Additionally, this node may
            // already be part of a cluster.
            //

            DWORD dwNodeClusterMajorVersion = 0;

            // Find out which version of the cluster service we are upgrading.
            dwReturnValue = TW32( DwGetNodeClusterMajorVersion( dwNodeClusterMajorVersion ) );
            if ( dwReturnValue != NO_ERROR )
            {
                TraceFlow1( "Error %#x occurred trying to determine the version of the cluster service that we are upgrading.", dwReturnValue );
                LogMsg( "Error %#x occurred trying to determine the version of the cluster service that we are upgrading.", dwReturnValue );
                break;
            } // if: an error occurred trying to determine the version of the cluster service that we are upgrading

            // Check if the returned cluster version is valid
            if (    ( dwNodeClusterMajorVersion != NT51_MAJOR_VERSION )
                 && ( dwNodeClusterMajorVersion != NT5_MAJOR_VERSION )
                 && ( dwNodeClusterMajorVersion != NT4SP4_MAJOR_VERSION )
                 && ( dwNodeClusterMajorVersion != NT4_MAJOR_VERSION )
               )
            {
                TraceFlow1( "The version of the cluster service before the upgrade (%d) is invalid.", dwNodeClusterMajorVersion ); 
                LogMsg( "The version of the cluster service before the upgrade (%d) is invalid.", dwNodeClusterMajorVersion ); 
                break;
            } // if: the cluster version is not valid

            // Based on the previous version of the cluster service, create the correct task object.
            if ( dwNodeClusterMajorVersion == NT5_MAJOR_VERSION )
            {
                TraceFlow( "We are upgrading a Windows 2000 node." );
                LogMsg( "We are upgrading a Windows 2000 node." );
                rpTaskOut = new CTaskUpgradeWin2k( *this );
            } // if: we are upgrading from Windows 2000
            else if ( dwNodeClusterMajorVersion == NT51_MAJOR_VERSION )
            {
                TraceFlow( "We are upgrading a Whistler node." );
                LogMsg( "We are upgrading a Whistler node." );
                rpTaskOut = new CTaskUpgradeWhistler( *this );
            } // else if: we are upgrading from Whistler
            else
            {
                TraceFlow( "We are upgrading an NT4 node." );
                LogMsg( "We are upgrading an NT4 node." );
                rpTaskOut = new CTaskUpgradeNT4( *this );
            } // else: we are upgrading from NT4 (either SP3 or SP4)

            if ( rpTaskOut == NULL )
            {
                TraceFlow( "Error: There was not enough memory to create the required task object." );
                LogMsg( "Error: There was not enough memory to create the required task." );
                dwReturnValue = TW32( ERROR_NOT_ENOUGH_MEMORY );
                break;
            } // if: memory allocation failed
        } // else if: an upgrade is in progress

        if ( rpTaskOut != NULL )
        {
            TraceFlow( "A task object was successfully created." );
            LogMsg( "A task object was successfully created." );

            // Store the pointer to the newly created task in the member variable.
            m_sptaskCurrentTask.Assign( rpTaskOut );
        } // if: the task object was successfully created
        else
        {
            TraceFlow( "No task object was created." );
            LogMsg( "No task object was created." );
        } // else: no task object was created
    }
    while( false ); // dummy do-while loop to avoid gotos

    LogMsg( "Return Value is %#x.", dwReturnValue );
    TraceFlow1( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMApp::DwGetCurrentTask()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMApp::DwGetNodeClusterMajorVersion
//
//  Description:
//      This function returns the major version of the cluster service that
//      we are upgrading. The version that this function returns is the version
//      of the service before the upgrade. If there was a problem reading this
//      information, this function lies and says that the previous version was
//      NT4, since this is the safest thing to say and is better than aborting
//      the upgrade.
//
//      Note: This function can only be called during an upgrade.
//
//  Arguments:
//      DWORD & rdwNodeClusterMajorVersionOut
//          Reference to DWORD that will hold the major version of the cluster
//          service that we are upgrading.
//
//  Return Value:
//      NO_ERROR if all went well.
//      E_UNEXPECTED if an upgrade is not in progress.
//      Other Win32 error codes on failure.
//
//
//  Remarks:
//      This function will work properly only after the member variables which
//      indicate which task will be performed have been initialized correctly.
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMApp::DwGetNodeClusterMajorVersion( DWORD & rdwNodeClusterMajorVersionOut )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD   dwReturnValue = NO_ERROR;
    DWORD   dwPrevOSMajorVersion = 0;
    DWORD   dwPrevOSMinorVersion = 0;

    do
    {
        SmartRegistryKey    srkOSInfoKey;
        DWORD               dwRegValueType = 0;
        DWORD               cbBufferSize = 0;

        // Initialize the output.
        rdwNodeClusterMajorVersionOut = 0;

        if ( !m_fIsUpgrade )
        {
            TraceFlow( "Error: This function cannot be called when an upgrade is not in progress." );
            LogMsg( "Error: This function cannot be called when an upgrade is not in progress." );
            dwReturnValue = THR( E_UNEXPECTED );
            break;
        } // if: an upgrade is not in progress

        //
        // Read the registry to get what the OS version was before the upgrade.
        // This information was written here by ClusComp.dll. From the OS version information,
        // try and deduce the cluster version info.
        // NOTE: At this point, it is not possible to differentiate between NT4_MAJOR_VERSION 
        // and NT4SP4_MAJOR_VERSION, and, for the purposes of the upgrade, I don't think we need
        // to either - so, just treat all NT4 cluster nodes the same.
        //
        {
            HKEY hTempKey = NULL;

            // Open the node version info registry key
            dwReturnValue = TW32(
                RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE
                    , CLUSREG_KEYNAME_NODE_DATA L"\\" CLUSREG_KEYNAME_PREV_OS_INFO
                    , 0
                    , KEY_READ
                    , &hTempKey
                    )
                );

            if ( dwReturnValue != ERROR_SUCCESS )
            {
                TraceFlow1( "Error %#x occurred trying open the registry key where info about the previous OS is stored.", dwReturnValue );
                LogMsg( "Error %#x occurred trying open the registry key where where info about the previous OS is stored.", dwReturnValue );
                break;
            } // if: RegOpenKeyEx() failed

            // Store the opened key in a smart pointer for automatic close.
            srkOSInfoKey.Assign( hTempKey );
        }

        // Read the OS major version
        cbBufferSize = sizeof( dwPrevOSMajorVersion );
        dwReturnValue = TW32(
            RegQueryValueEx(
                  srkOSInfoKey.HHandle()
                , CLUSREG_NAME_NODE_MAJOR_VERSION
                , 0
                , &dwRegValueType
                , reinterpret_cast< LPBYTE >( &dwPrevOSMajorVersion )
                , &cbBufferSize
                )
            );

        if ( dwReturnValue != ERROR_SUCCESS )
        {
            TraceFlow1( "Error %#x occurred trying to read the previous major version info.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to read the previous OS major version info.", dwReturnValue );
            break;
        } // if: RegQueryValueEx() failed while reading dwPrevOSMajorVersion

        // Read the OS minor version
        cbBufferSize = sizeof( dwPrevOSMinorVersion );
        dwReturnValue = TW32(
            RegQueryValueEx(
                  srkOSInfoKey.HHandle()
                , CLUSREG_NAME_NODE_MINOR_VERSION
                , 0
                , &dwRegValueType
                , reinterpret_cast< LPBYTE >( &dwPrevOSMinorVersion )
                , &cbBufferSize
                )
            );

        if ( dwReturnValue != ERROR_SUCCESS )
        {
            TraceFlow1( "Error %#x occurred trying to read the previous minor version info.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to read the previous OS minor version info.", dwReturnValue );
            break;
        } // if: RegQueryValueEx() failed while reading dwPrevOSMinorVersion

        TraceFlow2( "Previous OS major and minor versions were %d and %d respectively.", dwPrevOSMajorVersion, dwPrevOSMinorVersion );
        LogMsg( "Previous OS major and minor versions were %d and %d respectively.", dwPrevOSMajorVersion, dwPrevOSMinorVersion );
    }
    while( false ); // dummy do-while loop to avoid gotos

    if ( dwReturnValue != NO_ERROR )
    {
        TraceFlow( "An error occurred trying to read the version information of the previous OS. Proceeding assuming that it was NT4." );
        LogMsg( "An error occurred trying to read the version information of the previous OS. Proceeding assuming that it was NT4." );
        dwReturnValue = NO_ERROR;
        rdwNodeClusterMajorVersionOut = NT4_MAJOR_VERSION;
    } // if: an error occurred trying to determine the previous OS version
    else
    {
        if ( dwPrevOSMajorVersion == 4 )
        {
            // The previous OS version was NT4 (it does not matter if it was SP3 or SP4 - we will treat
            // both the same way.

            TraceFlow( "The previous OS was NT4. We are going to treat NT4SP3 and NT4SP4 nodes the same way for upgrades." );
            LogMsg( "The previous OS was NT4. We are going to treat NT4SP3 and NT4SP4 nodes the same way for upgrades." );
            rdwNodeClusterMajorVersionOut = NT4_MAJOR_VERSION;
        } // if: the previous OS version was NT4
        else if ( dwPrevOSMajorVersion == 5 )
        {
            if ( dwPrevOSMinorVersion == 0 )
            {
                TraceFlow( "The previous OS was Windows 2000." );
                LogMsg( "The previous OS was Windows 2000." );
                rdwNodeClusterMajorVersionOut = NT5_MAJOR_VERSION;
            } // if: this was a Windows 2000 node
            else if ( dwPrevOSMinorVersion == 1 )
            {
                TraceFlow( "The previous OS was Whistler." );
                LogMsg( "The previous OS was Whistler." );
                rdwNodeClusterMajorVersionOut = NT51_MAJOR_VERSION;
            } // else if: this was a Whistler node
            else
            {
                TraceFlow( "The previous OS was neither NT4, Windows 2000 nor Whistler. An error must have occurred." );
                LogMsg( "The previous OS was neither NT4, Windows 2000 nor Whistler. An error must have occurred." );
                dwReturnValue = THR( E_UNEXPECTED );
            } // else: the previous OS was neither NT4, Windows 2000 nor Whistler
        } // else if: the previous OS major version is 5
        else
        {
            TraceFlow( "The previous OS was neither NT4, Windows 2000 nor Whistler. An error must have occurred." );
            LogMsg( "The previous OS was neither NT4, Windows 2000 nor Whistler. An error must have occurred." );
            dwReturnValue = THR( E_UNEXPECTED );
        } // else: the previous OS was neither NT4, Windows 2000 nor Whistler
    } // if; we read the previous OS version info

    LogMsg( "Return Value is %#x.", dwReturnValue );
    TraceFlow1( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMApp::DwGetNodeClusterMajorVersion()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\cclusocmapp.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusOCMApp.h
//
//  Description:
//      ClusOCM.DLL is an Optional Components Manager DLL for installation of
//      Microsoft Cluster Server. This file contains the declaration of the
//      class ClusOCMApp, which is the main class of the ClusOCM DLL.
//
//  Implementation Files:
//      CClusOCMApp.cpp
//      CClusOCMApp.inl
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Contains setup API function declarations
#include <setupapi.h>
 
// For OC Manager definitions, macros, etc.
#include <ocmanage.h>

// For the class CClusOCMTask
#include "CClusOCMTask.h"

// For the smart classes
#include "SmartClasses.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusOCMApp
//
//  Description:
//      This is the main class of the ClusOCM DLL. This class receives messages
//      from the OC Manager, takes high level decisions about the installation
//      and passes control appropriately to subobjects.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusOCMApp
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and Destructors
    //////////////////////////////////////////////////////////////////////////

    CClusOCMApp( void );
    ~CClusOCMApp( void );


    // Receives messages from the OC Manager and dispatches them.
    DWORD
        DwClusOcmSetupProc(
            IN        LPCVOID    pvComponentId
          , IN        LPCVOID    pvSubComponentId
          , IN        UINT       uiFunctionCode
          , IN        UINT       uiParam1
          , IN OUT    PVOID      pvParam2 
          );


    //////////////////////////////////////////////////////////////////////////
    // Public Accessors
    //////////////////////////////////////////////////////////////////////////

    // Get the SETUP_INIT_COMPONENT passed in by OC Manager
    const SETUP_INIT_COMPONENT &
        RsicGetSetupInitComponent( void ) const { return m_sicSetupInitComponent; }

    //
    // Setup state functions
    //

    // Is this an unattended setup?
    bool
        FIsUnattendedSetup( void )  const { return m_fIsUnattendedSetup; }

    // Is this an upgrade?
    bool
        FIsUpgrade( void )  const { return m_fIsUpgrade; }

    // Is this GUI mode setup?
    bool
        FIsGUIModeSetup( void )  const { return m_fIsGUIModeSetup; }

    // Get the current installation state.
    eClusterInstallState
        CisGetClusterInstallState( void )  const { return m_cisCurrentInstallState; }

    // Get the error code of the first error that occurred
    DWORD
        DwGetError( void ) const
    {
        return m_dwFirstError;
    }

    // Report that an error occurred. If an error had already occurred, the new error code is not stored.
    DWORD
        DwSetError( DWORD dwError )
    {
        if ( m_dwFirstError == NO_ERROR )
        {
            m_dwFirstError = dwError;
        }

        return m_dwFirstError;
    }


private:
    //////////////////////////////////////////////////////////////////////////
    // Forbidden methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Copying an object of this class is not allowed.
    //

    // Private copy constructor.
    CClusOCMApp( const CClusOCMApp & );

    // Private assignment operator.
    const CClusOCMApp & operator =(  const CClusOCMApp & );


    //////////////////////////////////////////////////////////////////////////
    // Private Utility Functions.
    //////////////////////////////////////////////////////////////////////////

    // Check if the cluster service exists as a registered service.
    DWORD
        DwIsClusterServiceRegistered( bool * pfIsRegisteredOut ) const;


    // Set the setup init component data and other setup state variables
    void
        SetSetupState( const SETUP_INIT_COMPONENT & sicSourceIn );

    // Store the current installation state.
    eClusterInstallState
        CisStoreClusterInstallState( eClusterInstallState cisNewStateIn );


    // Get a pointer to the current task object. Create it if necessary.
    DWORD
        DwGetCurrentTask( CClusOCMTask *& rpTaskOut );

    // Free the current task object.
    void
        ResetCurrentTask( void )
    {
        m_sptaskCurrentTask.Assign( NULL );
    }

    // Get the major version of the cluster service that we are upgrading.
    // This function call only be called during an upgrade.
    DWORD
        DwGetNodeClusterMajorVersion( DWORD & rdwNodeClusterMajorVersionOut );


    //////////////////////////////////////////////////////////////////////////
    // Private Message Handlers
    //////////////////////////////////////////////////////////////////////////

    // Handler for the OC_INIT_COMPONENT message.
    DWORD
        DwOcInitComponentHandler(
            PSETUP_INIT_COMPONENT pSetupInitComponentInout
            );

    // Handler for the OC_QUERY_STATE message.
    DWORD
        DwOcQueryStateHandler( UINT uiSelStateQueryTypeIn );


    //////////////////////////////////////////////////////////////////////////
    // Private Data
    //////////////////////////////////////////////////////////////////////////
private:

    // Contains information about this setup session.
    SETUP_INIT_COMPONENT                             m_sicSetupInitComponent;

    // Setup state variables.
    bool                                             m_fIsUnattendedSetup;
    bool                                             m_fIsUpgrade;
    bool                                             m_fIsGUIModeSetup;

    // The current installation state of the cluster service
    eClusterInstallState                             m_cisCurrentInstallState;

    // This variable stores the error code of the first error that occurred.
    DWORD               m_dwFirstError;

    // A smart pointer holding a pointer to the current task being performed.
    CSmartGenericPtr< CPtrTrait< CClusOCMTask > >   m_sptaskCurrentTask;

    // Indicates if the task object has been created or not.
    bool                                             m_fAttemptedTaskCreation;

}; //*** class CClusOCMApp


//////////////////////////////////////////////////////////////////////////////
// Inline Files
//////////////////////////////////////////////////////////////////////////////

#include "CClusOCMApp.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\cclusocmapp.inl ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ClusOCMApp.inl
//
//  Description:
//      This file contains the definition of the inline functions of the 
//      ClusOCMApp class.
//
//  Header File:
//      ClusOCMApp.h
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//++
//
//  inline
//  eClusterInstallState
//  CClusOCMApp::CisSetClusterInstallState
//
//  Description:
//      Set the current cluster installation state.
//
//  Arguments:
//      cisNewStateIn
//          The new installation state.
//
//  Return Value:
//      The previous installation state.
//
//--
/////////////////////////////////////////////////////////////////////////////
inline
eClusterInstallState
CClusOCMApp::CisStoreClusterInstallState( eClusterInstallState cisNewStateIn )
{
    eClusterInstallState cisOldState = m_cisCurrentInstallState;

    m_cisCurrentInstallState = cisNewStateIn;

    return cisOldState;
} //*** CClusOCMApp::CisSetClusterInstallState()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\cclusocmtask.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusOCMTask.cpp
//
//  Description:
//      Implementation file for the CClusOCMTask class.
//
//  Header File:
//      CClusOCMTask.h
//
//  Maintained By:
//      Vij Vasu (Vvasu) 18-APR-2000
//          Created this file.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "pch.h"

// The header file for this module.
#include "CClusOCMTask.h"

// For CClusOCMApp
#include "CClusOCMApp.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CClusOCMTask" )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusOCMTask::CClusOCMTask
//
//  Description:
//      Constructor of the CClusOCMTask class.
//
//  Arguments:
//      const CClusOCMApp & rAppIn
//          Reference to the CClusOCMApp object that is hosting this task.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusOCMTask::CClusOCMTask( const CClusOCMApp & rAppIn )
    : m_rApp( rAppIn )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusOCMTask::CClusOCMTask()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusOCMTask::~CClusOCMTask
//
//  Description:
//      Destructor of the CClusOCMTask class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusOCMTask::~CClusOCMTask( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CClusOCMTask::CClusOCMTask()



/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMTask::DwOcCalcDiskSpace
//
//  Description:
//      This funcion handles the OC_CALC_DISK_SPACE messages from the Optional
//      Components Manager. It either adds or removes disk space requirements
//      from the disk space list maintained by the OC Manager. 
//
//      Note that it is important that components should report disk space
//      consistently, and they should not report disk space differently if the
//      component is being installed or uninstalled. As a result, the clean
//      install section of the INF file is always used by this function to
//      calculate disk space.
//
//  Arguments:
//      bool fAddFilesIn
//          If true space requirements are added to the OC Manager disk space
//          list. Requirements are removed from the list otherwise.
//
//      HDSKSPC hDiskSpaceListIn
//          Handle to the OC Manager disk space list.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMTask::DwOcCalcDiskSpace(
      bool          fAddFilesIn
    , HDSKSPC       hDiskSpaceListIn
    )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    if ( fAddFilesIn )
    {
        TraceFlow( "Adding space requirements to disk space list." );
        LogMsg( "Adding space requirements to disk space list." );

        if ( SetupAddInstallSectionToDiskSpaceList(
              hDiskSpaceListIn
            , RGetApp().RsicGetSetupInitComponent().ComponentInfHandle
            , NULL
            , INF_SECTION_CLEAN_INSTALL
            , 0
            , 0
            ) == FALSE )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to add to disk space requirements list.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to add to disk space requirements list.", dwReturnValue );
        } // if: SetupAddInstallSectionToDiskSpaceList failed
    } // if: the space requirements are to be added
    else
    {
        TraceFlow( "Removing space requirements from disk space list." );
        LogMsg( "Removing space requirements from disk space list." );

        if ( SetupRemoveInstallSectionFromDiskSpaceList(
              hDiskSpaceListIn
            , RGetApp().RsicGetSetupInitComponent().ComponentInfHandle
            , NULL
            , INF_SECTION_CLEAN_INSTALL
            , 0
            , 0
            ) == FALSE )
        {
            // See Note: above
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to remove disk space requirements from list.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to remove disk space requirements from list.", dwReturnValue );
        } // if: SetupRemoveInstallSectionFromDiskSpaceList failed
    } // else: the space requirements are to be deleted.

    TraceFlow1( "Return Value is 0x%X.", dwReturnValue );
    LogMsg( "Return Value is 0x%X.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMTask::DwOcCalcDiskSpace()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMTask::DwOcQueueFileOps
//
//  Description:
//      This is a helper function that performs some of the more common 
//      operations done by handlers of the OC_QUEUE_FILE_OPS message.
//
//      This function calls the DwSetDirectoryIds() function to set the
//      directory ids and processes the files listed in the input section.
//      It is meant to be called by derived classes only.
//
//  Arguments:
//      HSPFILEQ hSetupFileQueueIn
//          Handle to the file queue to operate upon.
//
//      const WCHAR * pcszInstallSectionNameIn
//          Name of the section which contains details of the files to be
//          set up.
//
//  Return Value:
//      NO_ERROR if all went well.
//      E_POINTER if the input section name is NULL.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMTask::DwOcQueueFileOps(
      HSPFILEQ hSetupFileQueueIn
    , const WCHAR * pcszInstallSectionNameIn
    )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    do
    {
        // Validate the parameters
        if ( pcszInstallSectionNameIn == NULL )
        {
            TraceFlow( "Error: The input section name cannot be NULL." );
            LogMsg( "Error: The input section name cannot be NULL." );
            dwReturnValue = TW32( ERROR_INVALID_PARAMETER );
            break;
        } // if: the input section name is NULL

        dwReturnValue = TW32( DwSetDirectoryIds() );
        if ( dwReturnValue != NO_ERROR )
        {
            TraceFlow1( "Error %#x occurred while trying to set the directory ids.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to set the directory ids.", dwReturnValue );
            break;
        } // if: DwSetDirectoryIds() failed

        TraceFlow1( "Attempting to queue file operations using section '%ws'.", pcszInstallSectionNameIn );
        LogMsg( "Attempting to queue file operations using section '%ws'.", pcszInstallSectionNameIn );

        if ( SetupInstallFilesFromInfSection(
              RGetApp().RsicGetSetupInitComponent().ComponentInfHandle  // handle to the INF file
            , NULL                                                      // optional, layout INF handle
            , hSetupFileQueueIn                                         // handle to the file queue
            , pcszInstallSectionNameIn                                  // name of the Install section
            , NULL                                                      // optional, root path to source files
            , SP_COPY_NEWER                                             // optional, specifies copy behavior
            ) == FALSE )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to install files.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to install files.", dwReturnValue );
            break;
        } // if: SetupInstallFilesFromInfSection() failed

        TraceFlow( "File ops successfully queued." );
        LogMsg( "File ops successfully queued." );
    }
    while( false ); // dummy do-while loop to avoid gotos

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMTask::DwOcQueueFileOps()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMTask::DwOcCompleteInstallation
//
//  Description:
//      This is a helper function that performs some of the more common 
//      operations done by handlers of the OC_COMPLETE_INSTALLATION message.
//
//      Registry operations, COM component registrations, creation of servies
//      etc. listed in the input section are processed by this function.
//      This function is meant to be called by derived classes only.
//
//  Arguments:
//      const WCHAR * pcszInstallSectionNameIn
//          Name of the section which contains details registry entries,
//          COM components, etc., that need to be set up.
//
//  Return Value:
//      NO_ERROR if all went well.
//      E_POINTER if the input section name is NULL.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMTask::DwOcCompleteInstallation( const WCHAR * pcszInstallSectionNameIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    do
    {
        // Validate the parameters
        if ( pcszInstallSectionNameIn == NULL )
        {
            TraceFlow( "Error: The input section name cannot be NULL." );
            LogMsg( "Error: The input section name cannot be NULL." );
            dwReturnValue = TW32( ERROR_INVALID_PARAMETER );
            break;
        } // if: the input section name is NULL

        TraceFlow1( "Attempting to setup using the section '%ws'.", pcszInstallSectionNameIn );
        LogMsg( "Attempting to setup using the section '%ws'.", pcszInstallSectionNameIn );

        // Create the required registry entries, register the COM components and
        // create the profile items.
        if ( SetupInstallFromInfSection(
              NULL                                                      // optional, handle of a parent window
            , RGetApp().RsicGetSetupInitComponent().ComponentInfHandle  // handle to the INF file
            , pcszInstallSectionNameIn                                  // name of the Install section
            , SPINST_REGISTRY | SPINST_REGSVR | SPINST_PROFILEITEMS     // which lines to install from section
            , NULL                                                      // optional, key for registry installs
            , NULL                                                      // optional, path for source files
            , NULL                                                      // optional, specifies copy behavior
            , NULL                                                      // optional, specifies callback routine
            , NULL                                                      // optional, callback routine context
            , NULL                                                      // optional, device information set
            , NULL                                                      // optional, device info structure
            ) == FALSE )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to create registry entries.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to create registry entries.", dwReturnValue );
            break;
        } // if: SetupInstallFromInfSection() failed
        
        // Create the required services.
        if ( SetupInstallServicesFromInfSection(
              RGetApp().RsicGetSetupInitComponent().ComponentInfHandle  // handle to the open INF file
            , pcszInstallSectionNameIn                                  // name of the Service section
            , 0                                                         // controls installation procedure
            ) == FALSE )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to create the required services.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to create the required services.", dwReturnValue );
            break;
        } // if: SetupInstallServicesFromInfSection() failed

        TraceFlow( "Registry entries and services successfully configured." );
        LogMsg( "Registry entries and services successfully configured." );
    }
    while( false ); // dummy do-while loop to avoid gotos

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMTask::DwOcCompleteInstallation()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMTask::DwOcCleanup
//
//  Description:
//      This is a helper function that performs some of the more common 
//      operations done by handlers of the OC_CLEANUP message.
//
//      This function processes the registry, COM and profile registration and
//      service entries in the input section. It is meant to be used by derived
//      classes only.
//
//  Arguments:
//      const WCHAR * pcszInstallSectionNameIn
//          Name of the section which contains the entries to be processed
//          during cleanup.
//
//  Return Value:
//      NO_ERROR if all went well.
//      E_POINTER if the input section name is NULL.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMTask::DwOcCleanup( const WCHAR * pcszInstallSectionNameIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    do
    {
        // Validate the parameters
        if ( pcszInstallSectionNameIn == NULL )
        {
            TraceFlow( "Error: The input section name cannot be NULL." );
            LogMsg( "Error: The input section name cannot be NULL." );
            dwReturnValue = TW32( ERROR_INVALID_PARAMETER );
            break;
        } // if: the input section name is NULL

        if ( RGetApp().DwGetError() == NO_ERROR )
        {
            TraceFlow( "No errors have occurred during this task. There is nothing to do during cleanup." );
            LogMsg( "No errors have occurred during this task. There is nothing to do during cleanup." );
            break;
        } // if: this task was error-free

        TraceFlow1( "Attempting to cleanup using section '%ws'.", pcszInstallSectionNameIn );
        LogMsg( "Attempting to cleanup using section '%ws'.", pcszInstallSectionNameIn );

        // Create the required registry entries, register the COM components and
        // create the profile items.
        if ( SetupInstallFromInfSection(
              NULL                                                      // optional, handle of a parent window
            , RGetApp().RsicGetSetupInitComponent().ComponentInfHandle  // handle to the INF file
            , pcszInstallSectionNameIn                                  // name of the Install section
            , SPINST_REGISTRY | SPINST_REGSVR | SPINST_PROFILEITEMS     // which lines to install from section
            , NULL                                                      // optional, key for registry installs
            , NULL                                                      // optional, path for source files
            , NULL                                                      // optional, specifies copy behavior
            , NULL                                                      // optional, specifies callback routine
            , NULL                                                      // optional, callback routine context
            , NULL                                                      // optional, device information set
            , NULL                                                      // optional, device info structure
            ) == FALSE )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to setup registry entries.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to setup registry entries.", dwReturnValue );
            break;
        } // if: SetupInstallFromInfSection() failed

        // Delete the created services.
        if ( SetupInstallServicesFromInfSection(
              RGetApp().RsicGetSetupInitComponent().ComponentInfHandle  // handle to the open INF file
            , pcszInstallSectionNameIn                                  // name of the Service section
            , 0                                                         // controls installation procedure
            ) == FALSE )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred while trying to setup the services.", dwReturnValue );
            LogMsg( "Error %#x occurred while trying to setup the services.", dwReturnValue );
            break;
        } // if: SetupInstallServicesFromInfSection() failed

        TraceFlow( "Cleanup was successful." );
        LogMsg( "Cleanup was successful." );
    }
    while( false ); // dummy do-while loop to avoid gotos

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMTask::DwOcCleanup()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CClusOCMTask::DwSetDirectoryIds
//
//  Description:
//      This is a helper function that maps the directory id 
//      CLUSTER_DEFAULT_INSTALL_DIRID to the default cluster installation 
//      directory CLUSTER_DEFAULT_INSTALL_DIR.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CClusOCMTask::DwSetDirectoryIds( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    do
    {
        DWORD dwRequiredSize = 0;

        // Determine the size of the buffer needed to hold the cluster directory name.
        dwRequiredSize = ExpandEnvironmentStrings(
              CLUSTER_DEFAULT_INSTALL_DIR
            , NULL
            , 0
            );

        // Did we get the required size?
        if ( dwRequiredSize == 0 )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying to determine the required size of the expanded environment string.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to determine the required size of the expanded environment string.", dwReturnValue );
            break;
        } // if: we could not determine the required size of the buffer

        // Allocate memory for the buffer.
        SmartSz sszDirName( new WCHAR[ dwRequiredSize ] );

        if ( sszDirName.FIsEmpty() )
        {
            dwReturnValue = TW32( ERROR_NOT_ENOUGH_MEMORY );
            TraceFlow1( "Error: Could not allocate %d bytes for the directory name.", dwRequiredSize );
            LogMsg( "Error: Could not allocate %d bytes for the directory name.", dwRequiredSize );
            break;
        } // if: memory allocation failed

        // Expand any variables in the cluster directory name string.
        dwRequiredSize = ExpandEnvironmentStrings(
              CLUSTER_DEFAULT_INSTALL_DIR
            , sszDirName.PMem()
            , dwRequiredSize
            );

        // Did we get the required size?
        if ( dwRequiredSize == 0 )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying expand environment variables in the cluster directory name.", dwReturnValue );
            LogMsg( "Error %#x occurred trying expand environment variables in the cluster directory name.", dwReturnValue );
            break;
        } // if: we could not determine the required size of the buffer

        if ( SetupSetDirectoryId(
                  RGetApp().RsicGetSetupInitComponent().ComponentInfHandle
                , CLUSTER_DEFAULT_INSTALL_DIRID
                , sszDirName.PMem()
                )
             == FALSE
           )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying set the default cluster install directory id.", dwReturnValue );
            LogMsg( "Error %#x occurred trying set the default cluster install directory id.", dwReturnValue );
            break;
        } // if: SetupSetDirectoryId() failed

        TraceFlow2( "The id %d maps to '%ws'.", CLUSTER_DEFAULT_INSTALL_DIRID, sszDirName.PMem() );
        LogMsg( "The id %d maps to '%ws'.", CLUSTER_DEFAULT_INSTALL_DIRID, sszDirName.PMem() );
    }
    while ( false ); // dummy do-while loop to avoid gotos

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CClusOCMTask::DwSetDirectoryIds()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\cclusocmtask.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CClusOCMTask.h
//
//  Description:
//      This file contains the declaration of the class CClusOCMTask.
//      This class represents a task performed by ClusOCM. For example, an
//      upgrade of the cluster binaries is a task performed by ClusOCM. It is
//      intended to be used as a base class for other task related classes.
//
//  Implementation Files:
//      CClusOCMTask.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the definition of a few basic types
#include <windows.h>

// Contains setup API function and type declarations
#include <setupapi.h>
 

//////////////////////////////////////////////////////////////////////////////
// Forward Declarations
//////////////////////////////////////////////////////////////////////////////
class CClusOCMApp;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusOCMTask
//
//  Description:
//      This class represents a task performed by ClusOCM. For example, an
//      upgrade of the cluster binaries is a task performed by ClusOCM. It is
//      intended to be used as a base class for other task related classes.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusOCMTask
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CClusOCMTask( const CClusOCMApp & rAppIn );

    // Destructor.
    virtual ~CClusOCMTask( void );


    //////////////////////////////////////////////////////////////////////////
    // Virtual message handlers
    //////////////////////////////////////////////////////////////////////////

    // Handler for the OC_CALC_DISK_SPACE message.
    // Note: this handler is not a pure virutal function since its functionality
    // has to remain the same regardless of whether an upgrade or a clean install
    // is in progress. As a result an implementation is provided in this class.
    DWORD
        DwOcCalcDiskSpace(
          bool          fAddFilesIn
        , HDSKSPC       hDiskSpaceListIn
        );

    // Handler for the OC_QUEUE_FILE_OPS message.
    virtual DWORD
        DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn ) = 0;

    // Handler for the OC_COMPLETE_INSTALLATION message.
    virtual DWORD
        DwOcCompleteInstallation( void ) = 0;

    // Handler for the OC_CLEANUP message.
    virtual DWORD
        DwOcCleanup( void ) = 0;


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected accessor functions
    //////////////////////////////////////////////////////////////////////////

    // Get a pointer to the main application object.
    const CClusOCMApp &
        RGetApp( void ) const
    {
        return m_rApp;
    }


    //////////////////////////////////////////////////////////////////////////
    // Other protected virtual methods
    //////////////////////////////////////////////////////////////////////////

    // A helper function that calls the DwSetDirectoryIds() function to set the
    // directory ids and processes the files listed in the input section.
    virtual DWORD
        DwOcQueueFileOps(
          HSPFILEQ hSetupFileQueueIn
        , const WCHAR * pcszInstallSectionNameIn
        );

    // A helper function that performs some of the more common operations
    // done by handlers of the OC_CLEANUP message.
    virtual DWORD
        DwOcCleanup( const WCHAR * pcszInstallSectionNameIn );

    // A helper function that processes registry operations, COM component
    // registrations, creation of servies, etc., listed in the input section.
    DWORD
    DwOcCompleteInstallation( const WCHAR * pcszInstallSectionNameIn );

    // A helper function that maps the directory id CLUSTER_DEFAULT_INSTALL_DIRID
    // to the  default cluster installation directory CLUSTER_DEFAULT_INSTALL_DIR.
    virtual DWORD
        DwSetDirectoryIds( void );


private:
    //////////////////////////////////////////////////////////////////////////
    // Forbidden methods
    //////////////////////////////////////////////////////////////////////////

    //
    // Copying an object of this class is not allowed.
    //

    // Private copy constructor.
    CClusOCMTask( const CClusOCMTask & );

    // Private assignment operator.
    const CClusOCMTask & operator =(  const CClusOCMTask & );


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////

    // The app object
    const CClusOCMApp & m_rApp;

}; //*** class CClusOCMTask
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\commondefs.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CommonDefs.h
//
//  Description:
//      This file contains a few definitions common to many classes and files.
//
//  Implementation Files:
//      None
//
//  Maintained By:
//      Vij Vasu (Vvasu) 12-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////

// For some basic types
#include <windows.h>

// For smart classes
#include "SmartClasses.h"

// For DIRID_USER
#include <setupapi.h>


//////////////////////////////////////////////////////////////////////////
// Macros definitions
//////////////////////////////////////////////////////////////////////////

// The INF section for the clean install of cluster binaries.
#define INF_SECTION_CLEAN_INSTALL L"Clean_Install"

// The INF section for cleaning upon an error during a clean install.
#define INF_SECTION_CLEAN_INSTALL_CLEANUP L"Clean_Install_Cleanup"

// The INF section for the upgrade of cluster binaries from Whistler when
// the node is already part of a cluster.
#define INF_SECTION_WHISTLER_UPGRADE L"Whistler_Upgrade"

// The INF section for cleaning upon an error during an upgrade from Whistler when
// the node is already part of a cluster.
#define INF_SECTION_WHISTLER_UPGRADE_CLEANUP L"Whistler_Upgrade_Cleanup"

// The INF section for the upgrade of cluster binaries from Whistler when
// the node is not part of a cluster.
#define INF_SECTION_WHISTLER_UPGRADE_UNCLUSTERED_NODE L"Whistler_Upgrade_Unclustered"

// The INF section for cleaning upon an error during an upgrade from Whistler when
// the node is not part of a cluster.
#define INF_SECTION_WHISTLER_UPGRADE_UNCLUSTERED_NODE_CLEANUP L"Whistler_Upgrade_Unclustered_Cleanup"

// The INF section for the upgrade of cluster binaries from Win2k when
// the node is already part of a cluster.
#define INF_SECTION_WIN2K_UPGRADE L"Win2k_Upgrade"

// The INF section for cleaning upon an error during an upgrade from Win2k
// when the node is already partof a cluster.
#define INF_SECTION_WIN2K_UPGRADE_CLEANUP L"Win2k_Upgrade_Cleanup"

// The INF section for the upgrade of cluster binaries from Win2k when
// the node is not part of a cluster.
#define INF_SECTION_WIN2K_UPGRADE_UNCLUSTERED_NODE L"Win2k_Upgrade_Unclustered"

// The INF section for cleaning upon an error during an upgrade from Win2k
// when the node is not part of a cluster.
#define INF_SECTION_WIN2K_UPGRADE_UNCLUSTERED_NODE_CLEANUP L"Win2k_Upgrade_Unclustered_Cleanup"

// The INF section for the upgrade of cluster binaries from NT4.
#define INF_SECTION_NT4_UPGRADE L"NT4_Upgrade"

// The INF section for cleaning upon an error during an upgrade from NT4.
#define INF_SECTION_NT4_UPGRADE_CLEANUP L"NT4_Upgrade_Cleanup"

// Directory where the cluster files are intalled by default.
#define CLUSTER_DEFAULT_INSTALL_DIR     L"%SystemRoot%\\Cluster"

// Directory id of the above directory.
#define CLUSTER_DEFAULT_INSTALL_DIRID   ( DIRID_USER + 0 )


//////////////////////////////////////////////////////////////////////////
// Type definitions
//////////////////////////////////////////////////////////////////////////

//
// Smart classes
//

// Smart WCHAR array
typedef CSmartGenericPtr< CPtrTrait< WCHAR > >  SmartSz;

// Smart registry handle
typedef CSmartResource< CHandleTrait< HKEY, LONG, RegCloseKey, NULL > > SmartRegistryKey;

// Smart service handle.
typedef CSmartResource< CHandleTrait< SC_HANDLE, BOOL, CloseServiceHandle > > SmartServiceHandle;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\clusocmresources.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      ClusOCMResources.h
//
//  Description:
//      Contains the definition of the string ids used by this DLL.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once

// The starting ID for these strings.
#define IDS_OCM_START       0

//
// NOTE: Do not change the string ids of the next two strings.
// ClusOCM.inf relies on them being 1 and 2.
//

// Cluster Administrator
#define IDS_CLUADMIN_SHORTCUT                   ( IDS_OCM_START + 1 )

// Configures and manages server clusters
#define IDS_CLUADMIN_INFO_TIP                   ( IDS_OCM_START + 2 )

// Cluster Service
#define IDS_CLUSSVC_DISPLAY_NAME                ( IDS_OCM_START + 3 )

// Enables servers to work together as a cluster to keep server-based applications highly available, regardless of individual component failures.
#define IDS_CLUSSVC_SERVICE_DESC                ( IDS_OCM_START + 4 )

// The ending ID for these strings.
#define IDS_OCM_END         1999
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\ctaskcleaninstall.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CTaskCleanInstall.h
//
//  Description:
//      This file contains the declaration of the class CTaskCleanInstall.
//      which encapsulates a clean installation of cluster binaries.
//
//  Implementation Files:
//      CTaskCleanInstall.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class
#include "CClusOCMTask.h"


//////////////////////////////////////////////////////////////////////////////
// Forward Declarations
//////////////////////////////////////////////////////////////////////////////
class CClusOCMApp;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskCleanInstall
//
//  Description:
//      This class encapsulates a clean installation of cluster binaries.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskCleanInstall : public CClusOCMTask
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CTaskCleanInstall( const CClusOCMApp & rAppIn );

    // Destructor
    virtual ~CTaskCleanInstall( void );


    //////////////////////////////////////////////////////////////////////////
    // Message handlers
    //////////////////////////////////////////////////////////////////////////

    // Handler for the OC_QUEUE_FILE_OPS message.
    virtual DWORD
        DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn );

    // Handler for the OC_COMPLETE_INSTALLATION message.
    virtual DWORD
        DwOcCompleteInstallation( void );

    // Handler for the OC_CLEANUP message.
    virtual DWORD
        DwOcCleanup( void );


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusOCMTask BaseClass;

}; //*** class CTaskCleanInstall
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\ctaskcleaninstall.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CTaskCleanInstall.cpp
//
//  Description:
//      Implementation file for the CTaskCleanInstall class.
//
//  Header File:
//      CTaskCleanInstall.h
//
//  Maintained By:
//      Vij Vasu (Vvasu) 18-APR-2000
//          Created this file.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "pch.h"

// The header file for this module.
#include "CTaskCleanInstall.h"



//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CTaskCleanInstall" )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCleanInstall::CTaskCleanInstall
//
//  Description:
//      Constructor of the CTaskCleanInstall class.
//
//  Arguments:
//      const CClusOCMApp & rAppIn
//          Reference to the CClusOCMApp object that is hosting this task.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskCleanInstall::CTaskCleanInstall( const CClusOCMApp & rAppIn )
    : BaseClass( rAppIn )
{
    TraceFunc( "" );

    //
    // Make sure that this object is being instatiated only when required.
    //

    // Assert that we will install binaries only when none were installed
    // previously.
    Assert( rAppIn.CisGetClusterInstallState() == eClusterInstallStateUnknown );


    TraceFuncExit();

} //*** CTaskCleanInstall::CTaskCleanInstall()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskCleanInstall::~CTaskCleanInstall
//
//  Description:
//      Destructor of the CTaskCleanInstall class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskCleanInstall::~CTaskCleanInstall( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskCleanInstall::~CTaskCleanInstall()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskCleanInstall::DwOcQueueFileOps
//
//  Description:
//      This function handles the OC_QUEUE_FILE_OPS messages from the Optional
//      Components Manager. It installs the files needed for a clean install.
//
//  Arguments:
//      HSPFILEQ hSetupFileQueueIn
//          Handle to the file queue to operate upon.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskCleanInstall::DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    // The base class helper function does everything that we need to do here.
    // So, just call it.
    DWORD dwReturnValue = TW32( BaseClass::DwOcQueueFileOps( hSetupFileQueueIn, INF_SECTION_CLEAN_INSTALL ) );

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskCleanInstall::DwOcQueueFileOps()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskCleanInstall::DwOcCompleteInstallation
//
//  Description:
//      This function handles the OC_COMPLETE_INSTALLATION messages from the
//      Optional Components Manager during a clean install.
//
//      Registry operations, COM component registrations, creation of servies
//      etc. are performed in this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskCleanInstall::DwOcCompleteInstallation( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    // The base class helper function does everything that we need to do here.
    // So, just call it.
    DWORD dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( INF_SECTION_CLEAN_INSTALL ) );

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskCleanInstall::DwOcCompleteInstallation()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskCleanInstall::DwOcCleanup
//
//  Description:
//      This function handles the OC_CLEANUP messages from the
//      Optional Components Manager during a clean install.
//
//      If an error has previously occurred during this task, cleanup operations
//      are performed. Otherwise nothing is done by this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskCleanInstall::DwOcCleanup( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    // The base class helper function does everything that we need to do here.
    // So, just call it.
    DWORD dwReturnValue = TW32( BaseClass::DwOcCleanup( INF_SECTION_CLEAN_INSTALL_CLEANUP ) );

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskCleanInstall::DwOcCleanup()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\ctaskupgrade.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgrade.h
//
//  Description:
//      This file contains the declaration of the class CTaskUpgrade.
//      This class encapsulates an upgrade of cluster binaries and is
//      meant to be used as a base class by other classes that handle
//      upgrades from a particular OS version.
//
//  Implementation Files:
//      CTaskUpgrade.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class
#include "CClusOCMTask.h"


//////////////////////////////////////////////////////////////////////////////
// Forward Declarations
//////////////////////////////////////////////////////////////////////////////
class CClusOCMApp;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskUpgrade
//
//  Description:
//      This class encapsulates an upgrade of cluster binaries and is
//      meant to be used as a base class by other classes that handle
//      upgrades from a particular OS version.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskUpgrade : public CClusOCMTask
{
public:

protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CTaskUpgrade( const CClusOCMApp & rAppIn );

    // Destructor
    virtual ~CTaskUpgrade( void );


    //////////////////////////////////////////////////////////////////////////
    // Other protected members
    //////////////////////////////////////////////////////////////////////////

    // Get the directory in which the cluster service binary resides from the
    // Service Control Manager
    DWORD
        DwGetClusterServiceDirectory( const WCHAR *& rpcszDirNamePtrIn );

    // A helper function that processes registry operations, COM component
    // registrations, creation of servies, etc., listed in the input section.
    DWORD
        DwOcCompleteInstallation( const WCHAR * pcszInstallSectionNameIn );

    // Registers a COM component for receiving cluster startup notifications
    HRESULT
        HrRegisterForStartupNotifications( const CLSID & rclsidComponentIn );


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CClusOCMTask BaseClass;


    //////////////////////////////////////////////////////////////////////////
    // Private data
    //////////////////////////////////////////////////////////////////////////
    
    // Pointer to the cluster service directory.
    SmartSz     m_sszClusterServiceDir;

    // Flag that indicates if the we know the cluster service directory or not.
    bool        m_fClusDirFound;

}; //*** class CTaskUpgrade
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\ctaskupgradent4.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgradeNT4.h
//
//  Description:
//      This file contains the declaration of the class CTaskUpgradeNT4.
//      This class represents the task of upgrading the cluster service on
//      a node that had Windows 2000 installed on it.
//
//  Implementation Files:
//      CTaskUpgradeNT4.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 26-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class
#include "CTaskUpgrade.h"


//////////////////////////////////////////////////////////////////////////////
// Forward Declarations
//////////////////////////////////////////////////////////////////////////////
class CClusOCMApp;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskUpgradeNT4
//
//  Description:
//      This class represents the task of upgrading the cluster service on
//      a node that had Windows 2000 installed on it.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskUpgradeNT4 : public CTaskUpgrade
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CTaskUpgradeNT4( const CClusOCMApp & rAppIn );

    // Destructor
    virtual ~CTaskUpgradeNT4( void );


    //////////////////////////////////////////////////////////////////////////
    // Message handlers
    //////////////////////////////////////////////////////////////////////////

    // Handler for the OC_QUEUE_FILE_OPS message.
    virtual DWORD
        DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn );

    // Handler for the OC_COMPLETE_INSTALLATION message.
    virtual DWORD
        DwOcCompleteInstallation( void );

    // Handler for the OC_CLEANUP message.
    virtual DWORD
        DwOcCleanup( void );


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Map ids specified in the INF file to actual directories.
    DWORD DwSetDirectoryIds( void );


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CTaskUpgrade BaseClass;

}; //*** class CTaskUpgradeNT4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\debug.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the debug library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 27-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "DebugSrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\ctaskupgrade.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgrade.cpp
//
//  Description:
//      Implementation file for the CTaskUpgrade class.
//
//  Header File:
//      CTaskUpgrade.h
//
//  Maintained By:
//      Vij Vasu (Vvasu) 18-APR-2000
//          Created this file.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "pch.h"

// The header file for this module.
#include "CTaskUpgrade.h"

// For COM category operations
#include <comcat.h>

// For CLSID_ClusCfgResTypeGenScript and CLSID_ClusCfgResTypeNodeQuorum
#include <ClusCfgGuids.h>


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CTaskUpgrade" )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgrade::CTaskUpgrade
//
//  Description:
//      Constructor of the CTaskUpgrade class.
//
//  Arguments:
//      const CClusOCMApp & rAppIn
//          Reference to the CClusOCMApp object that is hosting this task.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgrade::CTaskUpgrade( const CClusOCMApp & rAppIn )
    : BaseClass( rAppIn )
    , m_fClusDirFound( false )
{
    TraceFunc( "" );

    //
    // Make sure that this object is being instatiated only when required.
    //

    // Assert that this is an upgrade.
    Assert( rAppIn.FIsUpgrade() != false );

    // Assert that we will upgrade binaries only if they were previously
    // installed
    Assert( rAppIn.CisGetClusterInstallState() != eClusterInstallStateUnknown );

    TraceFuncExit();

} //*** CTaskUpgrade::CTaskUpgrade()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgrade::~CTaskUpgrade
//
//  Description:
//      Destructor of the CTaskUpgrade class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgrade::~CTaskUpgrade( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgrade::~CTaskUpgrade()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgrade::DwOcCompleteInstallation
//
//  Description:
//      This is a helper function that performs some of the more common 
//      operations done by handlers of the OC_COMPLETE_INSTALLATION message.
//
//      Registry operations, COM component registrations, creation of servies
//      etc. listed in the input section are processed by this function.
//      This function is meant to be called by derived classes only.
//
//  Arguments:
//      const WCHAR * pcszInstallSectionNameIn
//          Name of the section which contains details registry entries,
//          COM components, etc., that need to be set up.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgrade::DwOcCompleteInstallation( const WCHAR * pcszInstallSectionNameIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Call the base class helper function to perform some registry and service
    // related configuration from the INF file.
    dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( pcszInstallSectionNameIn ) );

    //
    // Register the Generic Script resource type extension for cluster startup notifications
    //

    if ( dwReturnValue == NO_ERROR )
    {
        HRESULT hrTemp;

        TraceFlow( "Attempting to register the Generic Script resource type extension for cluster startup notifications." );
        LogMsg( "Attempting to register the Generic Script resource type extension for cluster startup notifications." );

        hrTemp = THR( HrRegisterForStartupNotifications( CLSID_ClusCfgResTypeGenScript ) );
        if ( FAILED( hrTemp ) )
        {
            // This is not a fatal error. So, log it and continue.
            TraceFlow1( "Non-fatal error %#x occurred registering the Generic Script resource type extension for cluster startup notifications." , hrTemp );
            LogMsg( "Non-fatal error %#x occurred registering the Generic Script resource type extension for cluster startup notifications." , hrTemp );

        } // if: we could not register the Generic Script resource type extension for cluster startup notifications
        else
        {
            TraceFlow( "Successfully registered the Generic Script resource type extension for cluster startup notifications." );
            LogMsg( "Successfully registered the Generic Script resource type extension for cluster startup notifications." );
        } // else: the registration was successful
    } // if: the call to the base class function succeeded

    //
    // Register the Node Quorum resource type extension for cluster startup notifications
    //

    if ( dwReturnValue == NO_ERROR )
    {
        HRESULT hrTemp;

        TraceFlow( "Attempting to register the Node Quorum resource type extension for cluster startup notifications." );
        LogMsg( "Attempting to register the Node Quorum resource type extension for cluster startup notifications." );

        hrTemp = THR( HrRegisterForStartupNotifications( CLSID_ClusCfgResTypeMajorityNodeSet ) );
        if ( FAILED( hrTemp ) )
        {
            // This is not a fatal error. So, log it and continue.
            TraceFlow1( "Non-fatal error %#x occurred registering the Node Quorum resource type extension for cluster startup notifications." , hrTemp );
            LogMsg( "Non-fatal error %#x occurred registering the Node Quorum resource type extension for cluster startup notifications." , hrTemp );

        } // if: we could not register the Node Quorum resource type extension for cluster startup notifications
        else
        {
            TraceFlow( "Successfully registered the Node Quorum resource type extension for cluster startup notifications." );
            LogMsg( "Successfully registered the Node Quorum resource type extension for cluster startup notifications." );
        } // else: the registration was successful
    } // if: the call to the base class function succeeded

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgrade::DwOcCompleteInstallation()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgrade::DwGetClusterServiceDirectory
//
//  Description:
//      This function returns a pointer to the directory in which the cluster
//      service binaries are installed. This memory pointed to by this pointer
//      should not be freed by the caller.
//
//  Arguments:
//      const WCHAR *& rpcszDirNamePtrIn
//          Reference to the pointer to install directory. The caller should not
//          free this memory.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgrade::DwGetClusterServiceDirectory( const WCHAR *& rpcszDirNamePtrIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD           dwReturnValue = NO_ERROR;

    // Check if we have already got the cluster service directory. If we already have,
    // then return this value.
    while( !m_fClusDirFound )
    {
        // Instantiate a smart pointer to the QUERY_SERVICE_CONFIG structure.
        typedef CSmartGenericPtr< CPtrTrait< QUERY_SERVICE_CONFIG > > SmartServiceConfig;

        // Connect to the Service Control Manager
        SmartServiceHandle      shServiceMgr( OpenSCManager( NULL, NULL, GENERIC_READ ) );

        // Some arbitrary value.
        DWORD                   cbServiceConfigBufSize = 256;

        // Was the service control manager database opened successfully?
        if ( shServiceMgr.HHandle() == NULL )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying to open a connection to the local service control manager.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to open a connection to the local service control manager.", dwReturnValue );
            break;
        } // if: opening the SCM was unsuccessful


        // Open a handle to the Cluster Service.
        SmartServiceHandle shService( OpenService( shServiceMgr, L"ClusSvc", GENERIC_READ ) );

        // Was the handle to the service opened?
        if ( shService.HHandle() == NULL )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying to open a handle to the cluster service.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to open a handle to the cluster service.", dwReturnValue );
            break;
        } // if: the handle could not be opened

        do
        {
            DWORD               cbRequiredSize = 0;

            // Allocate memory for the service configuration info buffer. The memory is automatically freed when the
            // object is destroyed.
            SmartServiceConfig  spscServiceConfig( reinterpret_cast< QUERY_SERVICE_CONFIG * >( new BYTE[ cbServiceConfigBufSize ] ) );

            // Did the memory allocation succeed
            if ( spscServiceConfig.FIsEmpty() )
            {
                dwReturnValue = TW32( ERROR_NOT_ENOUGH_MEMORY );
                TraceFlow( "Error: There was not enough memory to get the cluster service configuration information." );
                LogMsg( "Error: There was not enough memory to get the cluster service configuration information." );
                break;
            } // if: memory allocation failed

            // Get the configuration information.
            if (    QueryServiceConfig(
                          shService.HHandle()
                        , spscServiceConfig.PMem()
                        , cbServiceConfigBufSize
                        , &cbRequiredSize
                        )
                 == FALSE
               )
            {
                dwReturnValue = GetLastError();
                if ( dwReturnValue != ERROR_INSUFFICIENT_BUFFER )
                {
                    TW32( dwReturnValue );
                    TraceFlow1( "Error %#x occurred trying to get the cluster service configuration information.", dwReturnValue );
                    LogMsg( "Error %#x occurred trying to get the cluster service configuration information.", dwReturnValue );
                    break;
                } // if: something has really gone wrong

                // We need to allocate more memory - try again
                dwReturnValue = NO_ERROR;
                cbServiceConfigBufSize = cbRequiredSize;
            } // if: QueryServiceConfig() failed
            else
            {
                // Find the last backslash character in the service binary path.
                WCHAR * pszPathName = spscServiceConfig.PMem()->lpBinaryPathName;
                WCHAR * pszLastBackslash = wcsrchr( pszPathName, L'\\' );

                if ( pszLastBackslash != NULL )
                {
                    // Terminate the string here.
                    *pszLastBackslash = L'\0';
                } // if: we found the last backslash

                // Move the service binary path to the beginning of the buffer.
                MoveMemory( spscServiceConfig.PMem(), pszPathName, ( wcslen( pszPathName ) + 1 ) * sizeof( pszPathName ) );

                // Store the pointer to the buffer in the member variable and 
                // detach this memory from the smart pointer (this will not delete the memory).
                m_sszClusterServiceDir.Assign( reinterpret_cast< WCHAR * >( spscServiceConfig.PRelease() ) );

                // Indicate the we have successfully found the cluster service directory.
                m_fClusDirFound = true;

                break;
            } // else: QueryServiceConfig() has succeeded
        }
        while( true ); // while: loop infinitely

        // We are done
        break;
    }

    // Initialize the output.
    rpcszDirNamePtrIn = m_sszClusterServiceDir.PMem();


    LogMsg( "Return Value is %#x.", dwReturnValue );
    TraceFlow1( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgrade::DwGetClusterServiceDirectory()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  CTaskUpgrade::HrRegisterForStartupNotifications
//
//  Description:
//      This function registers a COM component for receiving cluster startup
//      notifications.
//
//  Arguments:
//      const CLSID & rclsidComponentIn
//          Reference to the CLSID of the component that is to receive cluster
//          startup notifications.
//
//  Return Value:
//      S_OK if all went well.
//      Other HRESULTS failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CTaskUpgrade::HrRegisterForStartupNotifications( const CLSID & rclsidComponentIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    HRESULT hr = S_OK;

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    do
    {
        CSmartIfacePtr< ICatRegister > spcrCatReg;

        {
            ICatRegister * pcrCatReg = NULL;

            hr = THR(
                CoCreateInstance(
                      CLSID_StdComponentCategoriesMgr
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , __uuidof( pcrCatReg )
                    , reinterpret_cast< void ** >( &pcrCatReg )
                    )
                );

            if ( FAILED( hr ) )
            {
                LogMsg( "Error %#x occurred trying to create the StdComponentCategoriesMgr component.", hr );
                TraceFlow1( "Error %#x occurred trying to create the StdComponentCategoriesMgr component.", hr );
                break;
            } // if: we could not create the StdComponentCategoriesMgr component

            // Assign to a smart pointer for automatic release.
            spcrCatReg.Attach( pcrCatReg );
        }

        {
            CATID   rgCatId[ 1 ];

            rgCatId[ 0 ] = CATID_ClusCfgStartupListeners;

            hr = THR(
                spcrCatReg->RegisterClassImplCategories(
                      rclsidComponentIn
                    , sizeof( rgCatId ) / sizeof( rgCatId[ 0 ] )
                    , rgCatId
                    )
                );

            if ( FAILED( hr ) )
            {
                LogMsg( "Error %#x occurred trying to register the component for cluster startup notifications.", hr );
                TraceFlow1( "Error %#x occurred during the call to ICatRegister::UnRegisterClassImplCategories().", hr );
                break;
            } // if: we could not register the component for startup notifications
        }

        LogMsg( "Successfully registered for startup notifications." );
        TraceFlow( "Successfully registered for startup notifications." );
    }
    while( false ); // dummy do-while loop to avoid gotos

    CoUninitialize();

    LogMsg( "Return Value is %#x.", hr );
    TraceFlow1( "Return Value is %#x.", hr );

    HRETURN( hr );

} //*** CTaskUpgrade::HrRegisterForStartupNotifications()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\ctaskupgradent4.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgradeNT4.cpp
//
//  Description:
//      Implementation file for the CTaskUpgradeNT4 class.
//
//  Header File:
//      CTaskUpgradeNT4.h
//
//  Maintained By:
//      Vij Vasu (Vvasu) 18-APR-2000
//          Created this file.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "pch.h"

// The header file for this module.
#include "CTaskUpgradeNT4.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CTaskUpgradeNT4" )

// Name of the cluster service executable
#define CLUSSVC_EXECUTABLE_NAME             L"ClusSvc.exe"

// Multi-sz string of cluster service dependencies
#define CLUSSVC_DEPENDENCY_MULTISZ          L"ClusNet\0RpcSs\0W32Time\0NetMan"


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeNT4::CTaskUpgradeNT4
//
//  Description:
//      Constructor of the CTaskUpgradeNT4 class.
//
//  Arguments:
//      const CClusOCMApp & rAppIn
//          Reference to the CClusOCMApp object that is hosting this task.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgradeNT4::CTaskUpgradeNT4( const CClusOCMApp & rAppIn )
    : BaseClass( rAppIn )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgradeNT4::CTaskUpgradeNT4()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeNT4::~CTaskUpgradeNT4
//
//  Description:
//      Destructor of the CTaskUpgradeNT4 class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgradeNT4::~CTaskUpgradeNT4( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgradeNT4::~CTaskUpgradeNT4()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeNT4::DwOcQueueFileOps
//
//  Description:
//      This function handles the OC_QUEUE_FILE_OPS messages from the Optional
//      Components Manager. It installs the files needed for an upgrade from
//      Windows 2000.
//
//  Arguments:
//      HSPFILEQ hSetupFileQueueIn
//          Handle to the file queue to operate upon.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeNT4::DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // The base class helper function does everything that we need to do here.
    // So, just call it.
    dwReturnValue = TW32( BaseClass::DwOcQueueFileOps( hSetupFileQueueIn, INF_SECTION_NT4_UPGRADE ) );

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeNT4::DwOcQueueFileOps()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeNT4::DwOcCompleteInstallation
//
//  Description:
//      This function handles the OC_COMPLETE_INSTALLATION messages from the
//      Optional Components Manager during an upgrade from Windows 2000.
//
//      Registry operations, COM component registrations, creation of servies
//      etc. are performed in this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeNT4::DwOcCompleteInstallation( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Call the base class helper function to perform some registry and service
    // related configuration from the INF file.
    dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( INF_SECTION_NT4_UPGRADE ) );

    //
    // Change the cluster service display name, description, dependencies, failure actions
    // and executable name.
    //
    while( dwReturnValue == NO_ERROR )
    {
        // Pointer the the cluster service directory.
        const WCHAR *           pcszInstallDir = NULL;

        // Smart pointer to the cluster service display name string.
        SmartSz                 sszClusSvcDispName;

        // Smart pointer to the cluster service description string.
        SmartSz                 sszClusSvcDesc;

        // Smart pointer to the cluster service binary path string.
        SmartSz                 sszClusSvcBinPath;

        // Smart pointer to the cluster service.
        SmartServiceHandle      shClusSvc;

        // Connect to the Service Control Manager
        SmartServiceHandle      shServiceMgr( OpenSCManager( NULL, NULL, GENERIC_READ | GENERIC_WRITE ) );
        if ( shServiceMgr.HHandle() == NULL )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying to open a connection to the local service control manager.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to open a connection to the local service control manager.", dwReturnValue );
            break;
        } // if: opening the SCM was unsuccessful
        TraceFlow( "Opened a handle to the service control manager." );

        // Open a handle to the Cluster Service.
        shClusSvc.Assign( OpenService( shServiceMgr, L"ClusSvc", SERVICE_ALL_ACCESS ) );
        if ( shClusSvc.HHandle() == NULL )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying to open a handle to the cluster service.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to open a handle to the cluster service.", dwReturnValue );
            break;
        } // if: the handle could not be opened
        TraceFlow( "Opened a handle to the cluster service." );

        // Load the cluster service name string.
        dwReturnValue = DwLoadString( IDS_CLUSSVC_DISPLAY_NAME, sszClusSvcDispName );
        if ( dwReturnValue != ERROR_SUCCESS )
        {
            TraceFlow1( "Error %#x occurred trying load the display name of the cluster service.", dwReturnValue );
            LogMsg( "Error %#x occurred trying load the display name of the cluster service.", dwReturnValue );
            break;
        } // if: we could not load the cluster service display name string
        TraceFlow1( "The new cluster service display name is '%s'.", sszClusSvcDispName.PMem() );

        // Load the cluster service description string.
        dwReturnValue = DwLoadString( IDS_CLUSSVC_SERVICE_DESC, sszClusSvcDesc );
        if ( dwReturnValue != ERROR_SUCCESS )
        {
            TraceFlow1( "Error %#x occurred trying load the description of the cluster service.", dwReturnValue );
            LogMsg( "Error %#x occurred trying load the description of the cluster service.", dwReturnValue );
            break;
        } // if: we could not load the cluster service description string
        TraceFlow1( "The new cluster service description is '%s'.", sszClusSvcDesc.PMem() );

        //
        // Form the service binary path by appending the name of the cluster service executable to
        // the cluster service directory.
        //

        // Do not free the pointer returned by this call.
        dwReturnValue = TW32( DwGetClusterServiceDirectory( pcszInstallDir ) );
        if ( dwReturnValue != NO_ERROR )
        {
            TraceFlow1( "Error %#x occurred trying to determine the directory in which the cluster binaries are installed.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to determine the directory in which the cluster binaries are installed.", dwReturnValue );
            break;
        } // if: we could not get the cluster service installation directory
        TraceFlow1( "The cluster service directory is '%ws'.", pcszInstallDir );


        {
            WCHAR *     pszTempPtr;

            // Length of the the install directory string, not including the terminating L'\0'
            size_t      cchInstallDirLen = wcslen( pcszInstallDir );
            
            // Length of the cluster service executable name, including the terminating L'\0'
            size_t      cchClusSvcExeLen = sizeof( CLUSSVC_EXECUTABLE_NAME ) / sizeof( WCHAR );

            // Allocate memory for the cluster service binary path (the extra character is for the intervening L'\\'.
            sszClusSvcBinPath.Assign( new WCHAR[ cchInstallDirLen + 1 + cchClusSvcExeLen ] );
            if ( sszClusSvcBinPath.FIsEmpty() )
            {
                dwReturnValue = TW32( ERROR_NOT_ENOUGH_MEMORY );
                TraceFlow( "An error occurred trying to allocate memory for the cluster service binary path." );
                LogMsg( "An error occurred trying to allocate memory for the cluster service binary path." );
                break;
            } // if: an error occurred trying to allocate memory for the cluster service binary path

            pszTempPtr = sszClusSvcBinPath.PMem();

            // Copy the install directory string to the newly allocated buffer.
            wcsncpy( pszTempPtr, pcszInstallDir, cchInstallDirLen );
            pszTempPtr += cchInstallDirLen;

            // Copy the trailing L'\\' character
            *pszTempPtr = L'\\';
            ++pszTempPtr;

            // Copy the cluster service executable name.
            wcsncpy( pszTempPtr, CLUSSVC_EXECUTABLE_NAME, cchClusSvcExeLen );

            TraceFlow1( "The new cluster service binary path is '%s'.", sszClusSvcBinPath.PMem() );
        }

        // Change the binary path, dependency list and display name.
        if (    ChangeServiceConfig(
                      shClusSvc.HHandle()           // handle to service
                    , SERVICE_NO_CHANGE             // type of service
                    , SERVICE_NO_CHANGE             // when to start service
                    , SERVICE_NO_CHANGE             // severity of start failure
                    , sszClusSvcBinPath.PMem()      // service binary file name
                    , NULL                          // load ordering group name
                    , NULL                          // tag identifier
                    , CLUSSVC_DEPENDENCY_MULTISZ    // array of dependency names
                    , NULL                          // account name
                    , NULL                          // account password
                    , sszClusSvcDispName.PMem()     // display name
                    )
             == FALSE
           )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying to change the cluster service configuration.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to change the cluster service configuration.", dwReturnValue );
            break;
        } // if: ChangeServiceConfig() failed
        TraceFlow( "The cluster service binary path, dependency list and display name have been changed." );

        // Change the service description
        {
            SERVICE_DESCRIPTION sdServiceDescription;

            sdServiceDescription.lpDescription = sszClusSvcDesc.PMem();
            if (    ChangeServiceConfig2(
                          shClusSvc.HHandle()           // handle to service
                        , SERVICE_CONFIG_DESCRIPTION    // information level
                        , &sdServiceDescription         // new data
                        )
                 == FALSE
               )
            {
                dwReturnValue = TW32( GetLastError() );
                TraceFlow1( "Error %#x occurred trying to change the cluster service description.", dwReturnValue );
                LogMsg( "Error %#x occurred trying to change the cluster service description.", dwReturnValue );
                break;
            } // if: ChangeServiceConfig2() failed
        }

        TraceFlow( "The cluster service description has been changed." );

        // Change the cluster service failure actions.
        dwReturnValue = TW32( ClRtlSetSCMFailureActions( NULL ) );
        if ( dwReturnValue != ERROR_SUCCESS )
        {
            TraceFlow1( "Error %#x occurred trying to set the cluster service failure actions.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to set the cluster service failure actions.", dwReturnValue );
            break;
        } // if: ClRtlSetSCMFailureActions() failed
        TraceFlow( "The cluster service failure actions have been changed." );

        LogMsg( "The cluster service configuration has been changed." );
        break;
    } // while: the call to the base class function has succeeded

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeNT4::DwOcCompleteInstallation()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeNT4::DwOcCleanup
//
//  Description:
//      This function handles the OC_CLEANUP messages from the
//      Optional Components Manager during an upgrade from Windows 2000.
//
//      If an error has previously occurred during this task, cleanup operations
//      are performed. Otherwise nothing is done by this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeNT4::DwOcCleanup( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // The base class helper function does everything that we need to do here.
    // So, just call it.
    dwReturnValue = TW32( BaseClass::DwOcCleanup( INF_SECTION_NT4_UPGRADE_CLEANUP ) );

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeNT4::DwOcCleanup()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeNT4::DwSetDirectoryIds
//
//  Description:
//      This function maps ids specified in the INF file to directories.
//      The cluster installation directory is got from the service control
//      manager, since it is possible the the cluster binaries are installed
//      in a non-default location.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeNT4::DwSetDirectoryIds()
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    do
    {
        const WCHAR * pcszInstallDir = NULL;

        // If we are here, the this node is already a part of a cluster. So, get the
        // installation directory from SCM.

        TraceFlow( "This node is part of a cluster. Trying to determine the installation directory." );
        LogMsg( "This node is part of a cluster. Trying to determine the installation directory." );

        // Do not free the pointer returned by this call.
        dwReturnValue = TW32( DwGetClusterServiceDirectory( pcszInstallDir ) );
        if ( dwReturnValue != NO_ERROR )
        {
            TraceFlow1( "Error %#x occurred trying to determine the directory in which the cluster binaries are installed.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to determine the directory in which the cluster binaries are installed.", dwReturnValue );
            break;
        } // if: we could not get the cluster service installation directory


        TraceFlow1( "The cluster binaries are installed in the directory '%ws'.", pcszInstallDir );
        LogMsg( "The cluster binaries are installed in the directory '%ws'.", pcszInstallDir );

        // Create the mapping between the directory id and the path
        if ( SetupSetDirectoryId(
                  RGetApp().RsicGetSetupInitComponent().ComponentInfHandle
                , CLUSTER_DEFAULT_INSTALL_DIRID
                , pcszInstallDir
                )
             == FALSE
           )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying set the cluster install directory id.", dwReturnValue );
            LogMsg( "Error %#x occurred trying set the cluster install directory id.", dwReturnValue );
            break;
        } // if: SetupSetDirectoryId() failed

        TraceFlow2( "The id %d maps to '%ws'.", CLUSTER_DEFAULT_INSTALL_DIRID, pcszInstallDir );
        LogMsg( "The id %d maps to '%ws'.", CLUSTER_DEFAULT_INSTALL_DIRID, pcszInstallDir );

    }
    while ( false ); // dummy do-while loop to avoid gotos

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeNT4::DwSetDirectoryIds()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\ctaskupgradewhistler.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgradeWhistler.h
//
//  Description:
//      This file contains the declaration of the class CTaskUpgradeWhistler.
//      This class represents the task of upgrading the cluster service on
//      a node that had Windows 2000 installed on it.
//
//  Implementation Files:
//      CTaskUpgradeWhistler.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 26-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class
#include "CTaskUpgrade.h"


//////////////////////////////////////////////////////////////////////////////
// Forward Declarations
//////////////////////////////////////////////////////////////////////////////
class CClusOCMApp;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskUpgradeWhistler
//
//  Description:
//      This class represents the task of upgrading the cluster service on
//      a node that had Windows 2000 installed on it.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskUpgradeWhistler : public CTaskUpgrade
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CTaskUpgradeWhistler( const CClusOCMApp & rAppIn );

    // Destructor
    virtual ~CTaskUpgradeWhistler( void );


    //////////////////////////////////////////////////////////////////////////
    // Message handlers
    //////////////////////////////////////////////////////////////////////////

    // Handler for the OC_QUEUE_FILE_OPS message.
    virtual DWORD
        DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn );

    // Handler for the OC_COMPLETE_INSTALLATION message.
    virtual DWORD
        DwOcCompleteInstallation( void );

    // Handler for the OC_CLEANUP message.
    virtual DWORD
        DwOcCleanup( void );


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Map ids specified in the INF file to actual directories.
    DWORD DwSetDirectoryIds( void );


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CTaskUpgrade BaseClass;

}; //*** class CTaskUpgradeWhistler
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\ctaskupgradewhistler.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgradeWhistler.cpp
//
//  Description:
//      Implementation file for the CTaskUpgradeWhistler class.
//
//  Header File:
//      CTaskUpgradeWhistler.h
//
//  Maintained By:
//      Vij Vasu (Vvasu) 18-APR-2000
//          Created this file.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "pch.h"

// The header file for this module.
#include "CTaskUpgradeWhistler.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CTaskUpgradeWhistler" )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWhistler::CTaskUpgradeWhistler
//
//  Description:
//      Constructor of the CTaskUpgradeWhistler class.
//
//  Arguments:
//      const CClusOCMApp & rAppIn
//          Reference to the CClusOCMApp object that is hosting this task.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgradeWhistler::CTaskUpgradeWhistler( const CClusOCMApp & rAppIn )
    : BaseClass( rAppIn )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgradeWhistler::CTaskUpgradeWhistler()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWhistler::~CTaskUpgradeWhistler
//
//  Description:
//      Destructor of the CTaskUpgradeWhistler class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgradeWhistler::~CTaskUpgradeWhistler( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgradeWhistler::~CTaskUpgradeWhistler()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeWhistler::DwOcQueueFileOps
//
//  Description:
//      This function handles the OC_QUEUE_FILE_OPS messages from the Optional
//      Components Manager. It installs the files needed for an upgrade from
//      Windows 2000.
//
//  Arguments:
//      HSPFILEQ hSetupFileQueueIn
//          Handle to the file queue to operate upon.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWhistler::DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Do different things based on whether this node is already part of a cluster or not.
    if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
    {
        TraceFlow( "The cluster binaries are installed, but this node is not part of a cluster." );
        LogMsg( "The cluster binaries are installed, but this node is not part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcQueueFileOps( hSetupFileQueueIn, INF_SECTION_WHISTLER_UPGRADE_UNCLUSTERED_NODE ) );
    } // if: the node is not part of a cluster
    else
    {
        TraceFlow( "This node is part of a cluster." );
        LogMsg( "This node is part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcQueueFileOps( hSetupFileQueueIn, INF_SECTION_WHISTLER_UPGRADE ) );
    } // else: the node is part of a cluster

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWhistler::DwOcQueueFileOps()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeWhistler::DwOcCompleteInstallation
//
//  Description:
//      This function handles the OC_COMPLETE_INSTALLATION messages from the
//      Optional Components Manager during an upgrade from Windows 2000.
//
//      Registry operations, COM component registrations, creation of servies
//      etc. are performed in this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWhistler::DwOcCompleteInstallation( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Do different things based on whether this node is already part of a cluster or not.
    if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
    {
        TraceFlow( "The cluster binaries are installed, but this node is not part of a cluster." );
        LogMsg( "The cluster binaries are installed, but this node is not part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( INF_SECTION_WHISTLER_UPGRADE_UNCLUSTERED_NODE ) );
    } // if: the node is not part of a cluster
    else
    {
        TraceFlow( "This node is part of a cluster." );
        LogMsg( "This node is part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( INF_SECTION_WHISTLER_UPGRADE ) );
    } // else: the node is part of a cluster

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWhistler::DwOcCompleteInstallation()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeWhistler::DwOcCleanup
//
//  Description:
//      This function handles the OC_CLEANUP messages from the
//      Optional Components Manager during an upgrade from Windows 2000.
//
//      If an error has previously occurred during this task, cleanup operations
//      are performed. Otherwise nothing is done by this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWhistler::DwOcCleanup( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Do different things based on whether this node is already part of a cluster or not.
    if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
    {
        TraceFlow( "The cluster binaries are installed, but this node is not part of a cluster." );
        LogMsg( "The cluster binaries are installed, but this node is not part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCleanup( INF_SECTION_WHISTLER_UPGRADE_UNCLUSTERED_NODE_CLEANUP ) );
    } // if: the node is not part of a cluster
    else
    {
        TraceFlow( "This node is part of a cluster." );
        LogMsg( "This node is part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCleanup( INF_SECTION_WHISTLER_UPGRADE_CLEANUP ) );
    } // else: the node is part of a cluster

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWhistler::DwOcCleanup()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeWhistler::DwSetDirectoryIds
//
//  Description:
//      This function maps ids specified in the INF file to directories.
//      The location of the cluster binaries is read from the registry
//      and the cluster installation directory is mapped to this value.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWhistler::DwSetDirectoryIds()
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    do
    {
        SmartRegistryKey    srkNodeDataKey;
        SmartSz             sszInstallDir;
        DWORD               cbBufferSize    = 0;
        DWORD               dwType          = REG_SZ;

        {
            HKEY hTempKey = NULL;

            // Open the node data registry key
            dwReturnValue = TW32(
                RegOpenKeyEx(
                      HKEY_LOCAL_MACHINE
                    , CLUSREG_KEYNAME_NODE_DATA
                    , 0
                    , KEY_READ
                    , &hTempKey
                    )
                );

            if ( dwReturnValue != NO_ERROR )
            {
                TraceFlow1( "Error %#x occurred trying open the registry key where the cluster install path is stored.", dwReturnValue );
                LogMsg( "Error %#x occurred trying open the registry key where the cluster install path is stored.", dwReturnValue );
                break;
            } // if: RegOpenKeyEx() failed

            // Store the opened key in a smart pointer for automatic close.
            srkNodeDataKey.Assign( hTempKey );
        }

        // Get the required size of the buffer.
        dwReturnValue = TW32(
            RegQueryValueEx(
                  srkNodeDataKey.HHandle()          // handle to key to query
                , CLUSREG_INSTALL_DIR_VALUE_NAME    // name of value to query
                , 0                                 // reserved
                , NULL                              // address of buffer for value type
                , NULL                              // address of data buffer
                , &cbBufferSize                     // address of data buffer size
                )
            );

        if ( dwReturnValue != NO_ERROR )
        {
            TraceFlow2( "Error %#x occurred trying to read the registry value '%s'.", dwReturnValue, CLUSREG_INSTALL_DIR_VALUE_NAME );
            LogMsg( "Error %#x occurred trying to read the registry value '%s'.", dwReturnValue, CLUSREG_INSTALL_DIR_VALUE_NAME );
            break;
        } // if: an error occurred trying to read the CLUSREG_INSTALL_DIR_VALUE_NAME registry value

        // Allocate the required buffer.
        sszInstallDir.Assign( reinterpret_cast< WCHAR * >( new BYTE[ cbBufferSize ] ) );
        if ( sszInstallDir.FIsEmpty() )
        {
            TraceFlow1( "An error occurred trying to allocate %d bytes of memory.", cbBufferSize );
            LogMsg( "An error occurred trying to allocate %d bytes of memory.", cbBufferSize );
            dwReturnValue = TW32( ERROR_NOT_ENOUGH_MEMORY );
            break;
        } // if: a memory allocation failure occurred

        // Read the value.
        dwReturnValue = TW32( 
            RegQueryValueEx(
                  srkNodeDataKey.HHandle()                              // handle to key to query
                , CLUSREG_INSTALL_DIR_VALUE_NAME                        // name of value to query
                , 0                                                     // reserved
                , &dwType                                               // address of buffer for value type
                , reinterpret_cast< LPBYTE >( sszInstallDir.PMem() )    // address of data buffer
                , &cbBufferSize                                         // address of data buffer size
                )
            );

        // Was the key read properly?
        if ( dwReturnValue != NO_ERROR )
        {
            TraceFlow2( "Error %#x occurred trying to read the registry value '%s'.", dwReturnValue, CLUSREG_INSTALL_DIR_VALUE_NAME );
            LogMsg( "Error %#x occurred trying to read the registry value '%s'.", dwReturnValue, CLUSREG_INSTALL_DIR_VALUE_NAME );
            break;
        } // if: RegQueryValueEx failed.

        // Create the mapping between the directory id and the path
        if ( SetupSetDirectoryId(
                  RGetApp().RsicGetSetupInitComponent().ComponentInfHandle
                , CLUSTER_DEFAULT_INSTALL_DIRID
                , sszInstallDir.PMem()
                )
             == FALSE
           )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying set the cluster install directory id.", dwReturnValue );
            LogMsg( "Error %#x occurred trying set the cluster install directory id.", dwReturnValue );
            break;
        } // if: SetupSetDirectoryId() failed

        TraceFlow2( "The id %d maps to '%s'.", CLUSTER_DEFAULT_INSTALL_DIRID, sszInstallDir.PMem() );
        LogMsg( "The id %d maps to '%s'.", CLUSTER_DEFAULT_INSTALL_DIRID, sszInstallDir.PMem() );

    }
    while ( false ); // dummy do-while loop to avoid gotos

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWhistler::DwSetDirectoryIds()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\log.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Sucks in the logging library
//
//  Documentation:
//      Yes. I don't know where yet.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include <LogSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\ctaskupgradewin2k.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgradeWin2k.h
//
//  Description:
//      This file contains the declaration of the class CTaskUpgradeWin2k.
//      This class represents the task of upgrading the cluster service on
//      a node that had Windows 2000 installed on it.
//
//  Implementation Files:
//      CTaskUpgradeWin2k.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 26-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the base class
#include "CTaskUpgrade.h"


//////////////////////////////////////////////////////////////////////////////
// Forward Declarations
//////////////////////////////////////////////////////////////////////////////
class CClusOCMApp;


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CTaskUpgradeWin2k
//
//  Description:
//      This class represents the task of upgrading the cluster service on
//      a node that had Windows 2000 installed on it.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CTaskUpgradeWin2k : public CTaskUpgrade
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public constructors and destructors
    //////////////////////////////////////////////////////////////////////////

    // Constructor.
    CTaskUpgradeWin2k( const CClusOCMApp & rAppIn );

    // Destructor
    virtual ~CTaskUpgradeWin2k( void );


    //////////////////////////////////////////////////////////////////////////
    // Message handlers
    //////////////////////////////////////////////////////////////////////////

    // Handler for the OC_QUEUE_FILE_OPS message.
    virtual DWORD
        DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn );

    // Handler for the OC_COMPLETE_INSTALLATION message.
    virtual DWORD
        DwOcCompleteInstallation( void );

    // Handler for the OC_CLEANUP message.
    virtual DWORD
        DwOcCleanup( void );


protected:
    //////////////////////////////////////////////////////////////////////////
    // Protected methods
    //////////////////////////////////////////////////////////////////////////

    // Map ids specified in the INF file to actual directories.
    DWORD DwSetDirectoryIds( void );


private:
    //////////////////////////////////////////////////////////////////////////
    // Private types
    //////////////////////////////////////////////////////////////////////////
    typedef CTaskUpgrade BaseClass;

}; //*** class CTaskUpgradeWin2k
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\ctaskupgradewin2k.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      CTaskUpgradeWin2k.cpp
//
//  Description:
//      Implementation file for the CTaskUpgradeWin2k class.
//
//  Header File:
//      CTaskUpgradeWin2k.h
//
//  Maintained By:
//      Vij Vasu (Vvasu) 18-APR-2000
//          Created this file.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL.
#include "pch.h"

// The header file for this module.
#include "CTaskUpgradeWin2k.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// Needed for tracing.
DEFINE_THISCLASS( "CTaskUpgradeWin2k" )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWin2k::CTaskUpgradeWin2k
//
//  Description:
//      Constructor of the CTaskUpgradeWin2k class.
//
//  Arguments:
//      const CClusOCMApp & rAppIn
//          Reference to the CClusOCMApp object that is hosting this task.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgradeWin2k::CTaskUpgradeWin2k( const CClusOCMApp & rAppIn )
    : BaseClass( rAppIn )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgradeWin2k::CTaskUpgradeWin2k()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTaskUpgradeWin2k::~CTaskUpgradeWin2k
//
//  Description:
//      Destructor of the CTaskUpgradeWin2k class.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTaskUpgradeWin2k::~CTaskUpgradeWin2k( void )
{
    TraceFunc( "" );
    TraceFuncExit();

} //*** CTaskUpgradeWin2k::~CTaskUpgradeWin2k()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeWin2k::DwOcQueueFileOps
//
//  Description:
//      This function handles the OC_QUEUE_FILE_OPS messages from the Optional
//      Components Manager. It installs the files needed for an upgrade from
//      Windows 2000.
//
//  Arguments:
//      HSPFILEQ hSetupFileQueueIn
//          Handle to the file queue to operate upon.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWin2k::DwOcQueueFileOps( HSPFILEQ hSetupFileQueueIn )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Do different things based on whether this node is already part of a cluster or not.
    if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
    {
        TraceFlow( "The cluster binaries are installed, but this node is not part of a cluster." );
        LogMsg( "The cluster binaries are installed, but this node is not part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcQueueFileOps( hSetupFileQueueIn, INF_SECTION_WIN2K_UPGRADE_UNCLUSTERED_NODE ) );
    } // if: the node is not part of a cluster
    else
    {
        TraceFlow( "This node is part of a cluster." );
        LogMsg( "This node is part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcQueueFileOps( hSetupFileQueueIn, INF_SECTION_WIN2K_UPGRADE ) );
    } // else: the node is part of a cluster

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWin2k::DwOcQueueFileOps()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeWin2k::DwOcCompleteInstallation
//
//  Description:
//      This function handles the OC_COMPLETE_INSTALLATION messages from the
//      Optional Components Manager during an upgrade from Windows 2000.
//
//      Registry operations, COM component registrations, creation of servies
//      etc. are performed in this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWin2k::DwOcCompleteInstallation( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Do different things based on whether this node is already part of a cluster or not.
    if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
    {
        TraceFlow( "The cluster binaries are installed, but this node is not part of a cluster." );
        LogMsg( "The cluster binaries are installed, but this node is not part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( INF_SECTION_WIN2K_UPGRADE_UNCLUSTERED_NODE ) );
    } // if: the node is not part of a cluster
    else
    {
        TraceFlow( "This node is part of a cluster." );
        LogMsg( "This node is part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCompleteInstallation( INF_SECTION_WIN2K_UPGRADE ) );
    } // else: the node is part of a cluster

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWin2k::DwOcCompleteInstallation()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeWin2k::DwOcCleanup
//
//  Description:
//      This function handles the OC_CLEANUP messages from the
//      Optional Components Manager during an upgrade from Windows 2000.
//
//      If an error has previously occurred during this task, cleanup operations
//      are performed. Otherwise nothing is done by this function.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWin2k::DwOcCleanup( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    // Do different things based on whether this node is already part of a cluster or not.
    if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
    {
        TraceFlow( "The cluster binaries are installed, but this node is not part of a cluster." );
        LogMsg( "The cluster binaries are installed, but this node is not part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCleanup( INF_SECTION_WIN2K_UPGRADE_UNCLUSTERED_NODE_CLEANUP ) );
    } // if: the node is not part of a cluster
    else
    {
        TraceFlow( "This node is part of a cluster." );
        LogMsg( "This node is part of a cluster." );

        // The base class helper function does everything that we need to do here.
        // So, just call it.
        dwReturnValue = TW32( BaseClass::DwOcCleanup( INF_SECTION_WIN2K_UPGRADE_CLEANUP ) );
    } // else: the node is part of a cluster

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWin2k::DwOcCleanup()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  CTaskUpgradeWin2k::DwSetDirectoryIds
//
//  Description:
//      This function maps ids specified in the INF file to directories.
//      The behavior of this function is different for different cluster
//      installation states.
//      
//      If the cluster binaries are installed, but the node is not part
//      of a cluster, the cluster installation directory is set to the
//      default value.
//
//      If the node is already a part of a cluster, the cluster installation
//      directory is got from the service control manager, since it is possible
//      the the cluster binaries are installed in a non-default location if
//      this node was upgraded from NT4 previously.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NO_ERROR if all went well.
//      Other Win32 error codes on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CTaskUpgradeWin2k::DwSetDirectoryIds( void )
{
    TraceFunc( "" );
    LogMsg( "Entering " __FUNCTION__ "()" );

    DWORD dwReturnValue = NO_ERROR;

    do
    {
        const WCHAR * pcszInstallDir = NULL;

        if ( RGetApp().CisGetClusterInstallState() == eClusterInstallStateFilesCopied )
        {
            // If the cluster binaries have been install previously, and the node is
            // not part of a cluster, the binaries have to be installed in the default
            // location. This is because the binaries were always installed in the 
            // default location in Win2k and it is not possible to be in this state
            // on a Win2k node by upgrading from NT4.

            // The base class helper function does everything that we need to do here.
            // So, just call it.


            TraceFlow( "This node is not part of a cluster. Upgrading files in the default directory." );
            LogMsg( "This node is not part of a cluster. Upgrading files in the default directory." );

            dwReturnValue = TW32( BaseClass::DwSetDirectoryIds() );

            // We are done.
            break;
        } // if: the node is not part of a cluster

        // If we are here, the this node is already a part of a cluster. So, get the
        // installation directory from SCM.

        TraceFlow( "This node is part of a cluster. Trying to determine the installation directory." );
        LogMsg( "This node is part of a cluster. Trying to determine the installation directory." );

        // Do not free the pointer returned by this call.
        dwReturnValue = TW32( DwGetClusterServiceDirectory( pcszInstallDir ) );
        if ( dwReturnValue != NO_ERROR )
        {
            TraceFlow1( "Error %#x occurred trying to determine the directory in which the cluster binaries are installed.", dwReturnValue );
            LogMsg( "Error %#x occurred trying to determine the directory in which the cluster binaries are installed.", dwReturnValue );
            break;
        } // if: we could not get the cluster service installation directory

        TraceFlow1( "The cluster binaries are installed in the directory '%ws'.", pcszInstallDir );
        LogMsg( "The cluster binaries are installed in the directory '%ws'.", pcszInstallDir );

        // Create the mapping between the directory id and the path
        if ( SetupSetDirectoryId(
                  RGetApp().RsicGetSetupInitComponent().ComponentInfHandle
                , CLUSTER_DEFAULT_INSTALL_DIRID
                , pcszInstallDir
                )
             == FALSE
           )
        {
            dwReturnValue = TW32( GetLastError() );
            TraceFlow1( "Error %#x occurred trying set the cluster install directory id.", dwReturnValue );
            LogMsg( "Error %#x occurred trying set the cluster install directory id.", dwReturnValue );
            break;
        } // if: SetupSetDirectoryId() failed

        TraceFlow2( "The id %d maps to '%ws'.", CLUSTER_DEFAULT_INSTALL_DIRID, pcszInstallDir );
        LogMsg( "The id %d maps to '%ws'.", CLUSTER_DEFAULT_INSTALL_DIRID, pcszInstallDir );

    }
    while ( false ); // dummy do-while loop to avoid gotos

    TraceFlow1( "Return Value is %#x.", dwReturnValue );
    LogMsg( "Return Value is %#x.", dwReturnValue );

    RETURN( dwReturnValue );

} //*** CTaskUpgradeWin2k::DwSetDirectoryIds()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\globalfuncs.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      GlobalFuncs.h
//
//  Description:
//      Contains the declarations of a few unrelated global functions
//      and variables
//
//  Implementation Files:
//      GlobalFuncs.cpp
//
//  Maintained By:
//      Vij Vasu (Vvasu) 06-SEP-2000
//
//////////////////////////////////////////////////////////////////////////////


// Make sure that this file is included only once per compile path.
#pragma once


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// For the SmartSz type
#include "CommonDefs.h"


//////////////////////////////////////////////////////////////////////////
// Global variable declarations.
//////////////////////////////////////////////////////////////////////////

// Handle to the instance of this DLL.
extern HINSTANCE g_hInstance;


//////////////////////////////////////////////////////////////////////////
// Global function declarations.
//////////////////////////////////////////////////////////////////////////

// Allocate memory for and load a string from the string table.
DWORD
DwLoadString(
      UINT      nStringIdIn
    , SmartSz & rsszDestOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\dll.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 Microsoft Corporation
//
//  Module Name:
//      Dll.cpp
//
//  Description:
//      DLL services/entry points.
//
//  Maintained By:
//      Geoff Pease (GPease)            18-OCT-1999
//      Vij Vasu (Vvasu)                25-JAN-2001
//
//  Notes:
//      The file Mgmt\Inc\DllSrc.cpp is not included in this file
//      because the inclusion of that file requires that the library
//      Mgmt\ClusCfg\Common\$(O)\Common.lib be linked with this DLL. Also,
//      the header file Guids.h from Mgmt\ClusCfg\Inc will be needed.
//      (DllSrc.cpp requires CFactorySrc.cpp which requires CITrackerSrc.cpp
//      which requires InterfaceTableSrc.cpp which needs Guids.h)
//
//      Since I didn't wan't to "reach across" to the ClusCfg directory (and
//      since this DLL does not need class factories, interface tracking, etc.)
//      ClusOCM has it's own Dll.cpp.
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// Precompiled header for this DLL
#include "pch.h"


//////////////////////////////////////////////////////////////////////////////
// Macro Definitions
//////////////////////////////////////////////////////////////////////////////

// For tracing
DEFINE_MODULE("CLUSOCM")


//////////////////////////////////////////////////////////////////////////////
// Global Variables
//////////////////////////////////////////////////////////////////////////////

// Handle to the instance of this DLL.
HINSTANCE g_hInstance = NULL;

LPVOID g_GlobalMemoryList = NULL;

// Name of the DLL
WCHAR     g_szDllFilename[ MAX_PATH ] = { 0 };


#if !defined(NO_DLL_MAIN) || defined(ENTRY_PREFIX) || defined(DEBUG)
//////////////////////////////////////////////////////////////////////////////
//
// __declspec( dllexport )
// BOOL
// WINAPI
// DLLMain(
//      HANDLE  hInstIn,
//      ULONG   ulReasonIn,
//      LPVOID  lpReservedIn
//      )
//
// Description:
//      Dll entry point.
//
// Arguments:
//      hInstIn      - DLL instance handle.
//      ulReasonIn   - DLL reason code for entrance.
//      lpReservedIn - Not used.
//
//////////////////////////////////////////////////////////////////////////////
__declspec( dllexport ) BOOL WINAPI
DllMain(
    HANDLE  hInstIn,
    ULONG   ulReasonIn,
    LPVOID  // lpReservedIn
    )
{
     BOOL fReturnValue = TRUE;
    //
    // KB: NO_THREAD_OPTIMIZATIONS gpease 19-OCT-1999
    //
    // By not defining this you can prvent the linker
    // from calling you DllEntry for every new thread.
    // This makes creating new thread significantly
    // faster if every DLL in a process does it.
    // Unfortunately, not all DLLs do this.
    //
    // In CHKed/DEBUG, we keep this on for memory
    // tracking.
    //
#if defined( DEBUG )
    #define NO_THREAD_OPTIMIZATIONS
#endif // DEBUG

#if defined(NO_THREAD_OPTIMIZATIONS)
    switch( ulReasonIn )
    {
        case DLL_PROCESS_ATTACH:
        {
#if defined(USE_WMI_TRACING)
            TraceInitializeProcess( g_rgTraceControlGuidList, ARRAYSIZE( g_rgTraceControlGuidList ), TRUE );
#else
            TraceInitializeProcess( TRUE );
#endif

#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_PROCESS_ATTACH - ThreadID = %#x"),
                          GetCurrentThreadId( )
                          );
            FRETURN( fReturnValue );
#endif // DEBUG
            g_hInstance = (HINSTANCE) hInstIn;

#if defined( ENTRY_PREFIX )
             hProxyDll = g_hInstance;
#endif

            GetModuleFileName( g_hInstance, g_szDllFilename, MAX_PATH );

            //
            // Create a global memory list so that memory allocated by one
            // thread and handed to another can be tracked without causing
            // unnecessary trace messages.
            //
            TraceCreateMemoryList( g_GlobalMemoryList );

        } // case: DLL_PROCESS_ATTACH
        break;


        case DLL_PROCESS_DETACH:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_PROCESS_DETACH - ThreadID = %#x"),
                          GetCurrentThreadId( )
                          );
            FRETURN( fReturnValue );
#endif // DEBUG

            //
            // Cleanup the global memory list used to track memory allocated
            // in one thread and then handed to another.
            //
            TraceTerminateMemoryList( g_GlobalMemoryList );

#if defined(USE_WMI_TRACING)
            TraceTerminateProcess( g_rgTraceControlGuidList, ARRAYSIZE( g_rgTraceControlGuidList ) );
#else
            TraceTerminateProcess();
#endif

        } // case: DLL_PROCESS_DETACH
        break;


        case DLL_THREAD_ATTACH:
        {
            TraceInitializeThread( NULL );
#if defined( DEBUG )
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("The thread %#x has started."),
                          GetCurrentThreadId( ) );
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_THREAD_ATTACH - ThreadID = %#x"),
                          GetCurrentThreadId( )
                          );
            FRETURN( fReturnValue );
#endif // DEBUG
        } // case: DLL_THREAD_ATTACH
        break;


        case DLL_THREAD_DETACH:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_THREAD_DETACH - ThreadID = %#x"),
                          GetCurrentThreadId( )
                          );
            FRETURN( fReturnValue );
#endif // DEBUG
            TraceThreadRundown( );
        } // case: DLL_THREAD_DETACH
        break;


        default:
        {
#if defined( DEBUG )
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: UNKNOWN ENTRANCE REASON - ThreadID = %#x"),
                          GetCurrentThreadId( )
                          );
            FRETURN( fReturnValue );
#endif // DEBUG
        } // case: default
        break;
    }

    return fReturnValue;

#else // !NO_THREAD_OPTIMIZATIONS

    Assert( ulReasonIn == DLL_PROCESS_ATTACH || ulReasonIn == DLL_PROCESS_DETACH );
#if defined(DEBUG)
#if defined(USE_WMI_TRACING)
    TraceInitializeProcess( g_rgTraceControlGuidList,
                            ARRAYSIZE( g_rgTraceControlGuidList )
                            );
#else
    TraceInitializeProcess();
#endif
#endif // DEBUG

    g_hInstance = (HINSTANCE) hInstIn;

#if defined( ENTRY_PREFIX )
     hProxyDll = g_hInstance;
#endif

    GetModuleFileName( g_hInstance, g_szDllFilename, MAX_PATH );
    fReturnValue = DisableThreadLibraryCalls( g_hInstance );
    AssertMsg( fReturnValue, "*ERROR* DisableThreadLibraryCalls( ) failed."  );

    return fReturnValue;

#endif // NO_THREAD_OPTIMIZATIONS

} //*** DllMain()
#endif // !defined(NO_DLL_MAIN) && !defined(ENTRY_PREFIX) && !defined(DEBUG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\globalfuncs.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      GlobalFuncs.cpp
//
//  Description:
//      Contains the definitions of a few unrelated global functions
//
//  Maintained By:
//      Vij Vasu (Vvasu) 06-SEP-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

// The precompiled header.
#include "pch.h"


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DwLoadString()
//
//  Description:
//      Allocate memory for and load a string from the string table.
//
//  Arguments:
//      uiStringIdIn
//          Id of the string to look up
//
//      rsszDestOut
//          Reference to the smart pointer to the loaded string.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other Win32 error codes
//          If the call failed.
//
//  Remarks:
//      This function cannot load a zero length string.
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
DwLoadString(
      UINT      nStringIdIn
    , SmartSz & rsszDestOut
    )
{
    TraceFunc( "" );

    DWORD     dwError = ERROR_SUCCESS;

    UINT        uiCurrentSize = 0;
    SmartSz     sszCurrentString;
    UINT        uiReturnedStringLen = 0;

    do
    {
        // Grow the current string by an arbitrary amount.
        uiCurrentSize += 256;

        sszCurrentString.Assign( new WCHAR[ uiCurrentSize ] );
        if ( sszCurrentString.FIsEmpty() )
        {
            dwError = TW32( ERROR_NOT_ENOUGH_MEMORY );
            TraceFlow2( "Error %#x occurred trying allocate memory for string (string id is %d).", dwError, nStringIdIn );
            LogMsg( "Error %#x occurred trying allocate memory for string (string id is %d).", dwError, nStringIdIn );
            break;
        } // if: the memory allocation has failed

        uiReturnedStringLen = ::LoadString(
                                  g_hInstance
                                , nStringIdIn
                                , sszCurrentString.PMem()
                                , uiCurrentSize
                                );

        if ( uiReturnedStringLen == 0 )
        {
            dwError = TW32( GetLastError() );
            TraceFlow2( "Error %#x occurred trying load string (string id is %d).", dwError, nStringIdIn );
            LogMsg( "Error %#x occurred trying load string (string id is %d).", dwError, nStringIdIn );
            break;
        } // if: LoadString() had an error

        ++uiReturnedStringLen;
    }
    while( uiCurrentSize <= uiReturnedStringLen );

    if ( dwError == ERROR_SUCCESS )
    {
        rsszDestOut = sszCurrentString;
    } // if: there were no errors in this function
    else
    {
        rsszDestOut.PRelease();
    } // else: something went wrong

    RETURN( dwError );

} //*** DwLoadString()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\clusocm\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      pch.h
//
//  Description:
//      Precompiled header file for the ClusOCM DLL.
//
//  Maintained By:
//      Vij Vasu (Vvasu) 03-MAR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once


//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#if DBG==1 || defined( _DEBUG )

#define DEBUG
#endif


////////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>

// Contains setup API function declarations
#include <setupapi.h>

// For OC Manager definitions, macros, etc.
#include <ocmanage.h>

// For tracing and debugging functions
#include <Debug.h>

// For Logging functions
#include <Log.h>

// A few common definitions, macros, etc.
#include "CommonDefs.h"

// For resource ids
#include "ClusOCMResources.h"

// For ClusRtl functions
#include "ClusRTL.h"

// For the names of several cluster service related registry keys and values
#include "clusudef.h"

// For CClusOCMApp
#include "CClusOCMApp.h"

// For the declarations of a few unrelated global functions and variables
#include "GlobalFuncs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\common\directoryutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      DirectoryUtils.cpp
//
//  Description:
//      Useful functions for manipulating directies.
//
//  Maintained By:
//      Galen Barbee (GalenB)   05-DEC-2000
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "SmartClasses.h"


//////////////////////////////////////////////////////////////////////////////
// Type Definitions
//////////////////////////////////////////////////////////////////////////////

//
// Structure used to pass parameters between recursive calls to the
// gs_RecursiveEmptyDirectory() function.
//
struct SDirRemoveParams
{
    WCHAR *     m_pszDirName;       // Pointer to the directory name buffer.
    UINT        m_uiDirNameLen;     // Length of string currently in buffer (does not include '\0')
    UINT        m_uiDirNameMax;     // Max length of string in buffer (does not include '\0')
    signed int  m_iMaxDepth;        // Maximum recursion depth.
};


//////////////////////////////////////////////////////////////////////////////
// Forward Declarations.
//////////////////////////////////////////////////////////////////////////////

DWORD
DwRecursiveEmptyDirectory( SDirRemoveParams * pdrpParamsInOut );


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrCreateDirectoryPath(
//      LPWSTR pszDirectoryPathInOut
//      )
//
//  Descriptions:
//      Creates the directory tree as required.
//
//  Arguments:
//      pszDirectoryPathOut
//          Must be MAX_PATH big. It will contain the trace log file path to
//          create.
//
//  Return Values:
//      S_OK - Success
//      other HRESULTs for failures
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCreateDirectoryPath( LPWSTR pszDirectoryPath )
{
    LPTSTR  psz;
    BOOL    fReturn;
    DWORD   dwAttr;
    HRESULT hr = S_OK;

    //
    // Find the \ that indicates the root directory. There should be at least
    // one \, but if there isn't, we just fall through.
    //

    // skip X:\ part
    psz = wcschr( pszDirectoryPath, L'\\' );
    Assert( psz != NULL );
    if ( psz != NULL )
    {
        //
        // Find the \ that indicates the end of the first level directory. It's
        // probable that there won't be another \, in which case we just fall
        // through to creating the entire path.
        //
        psz = wcschr( psz + 1, L'\\' );
        while ( psz != NULL )
        {
            // Terminate the directory path at the current level.
            *psz = 0;

            //
            // Create a directory at the current level.
            //
            dwAttr = GetFileAttributes( pszDirectoryPath );
            if ( 0xFFFFffff == dwAttr )
            {
                DebugMsg( TEXT("DEBUG: Creating %s"), pszDirectoryPath );
                fReturn = CreateDirectory( pszDirectoryPath, NULL );
                if ( ! fReturn )
                {
                    hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );
                    goto Error;
                } // if: creation failed

            }  // if: directory not found
            else if ( ( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) == 0 )
            {
                hr = THR( E_FAIL );
                goto Error;
            } // else: file found

            //
            // Restore the \ and find the next one.
            //
            *psz = L'\\';
            psz = wcschr( psz + 1, L'\\' );

        } // while: found slash

    } // if: found slash

    //
    // Create the target directory.
    //
    dwAttr = GetFileAttributes( pszDirectoryPath );
    if ( 0xFFFFffff == dwAttr )
    {
        fReturn = CreateDirectory( pszDirectoryPath, NULL );
        if ( ! fReturn )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError( ) ) );

        } // if: creation failed

    } // if: path not found

Error:

    return hr;

} //*** HrCreateDirectoryPath()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  DwRecursiveEmptyDirectory
//
//  Description:
//      Recursively removes the target directory and everything underneath it.
//      This is a recursive function.
//
//  Arguments:
//      pdrpParamsInOut
//          Pointer to the object that contains the parameters for this recursive call.
//
//  Return Value:
//      ERROR_SUCCESS
//          The directory was deleted
//
//      Other Win32 error codes
//          If something went wrong
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
DwRecursiveEmptyDirectory( SDirRemoveParams * pdrpParamsInOut )
{
    DWORD dwError = ERROR_SUCCESS;

    do
    {
        typedef CSmartResource<
            CHandleTrait<
                  HANDLE
                , BOOL
                , FindClose
                , INVALID_HANDLE_VALUE
                >
            > SmartFindFileHandle;

        WIN32_FIND_DATA     wfdCurFile;
        UINT                uiCurDirNameLen = pdrpParamsInOut->m_uiDirNameLen;

        ZeroMemory( &wfdCurFile, sizeof( wfdCurFile ) );

        if ( pdrpParamsInOut->m_iMaxDepth < 0 )
        {
            dwError = TW32( ERROR_DIR_NOT_EMPTY );
            break;
        } // if: the recursion is too deep.

        //
        // Check if the target directory name is too long. The two extra characters
        // being checked for are '\\' and '*'.
        //
        if ( uiCurDirNameLen > ( pdrpParamsInOut->m_uiDirNameMax - 2 ) )
        {
            dwError = TW32( ERROR_BUFFER_OVERFLOW );
            break;
        } // if: the target directory name is too long.

        // Append "\*" to the end of the directory name
        pdrpParamsInOut->m_pszDirName[ uiCurDirNameLen ] = '\\';
        pdrpParamsInOut->m_pszDirName[ uiCurDirNameLen + 1 ] = '*';
        pdrpParamsInOut->m_pszDirName[ uiCurDirNameLen + 2 ] = '\0';

        ++uiCurDirNameLen;

        SmartFindFileHandle sffhFindFileHandle( FindFirstFile( pdrpParamsInOut->m_pszDirName, &wfdCurFile ) );

        if ( sffhFindFileHandle.FIsInvalid() )
        {
            dwError = TW32( GetLastError() );
            break;
        }

        do
        {
            size_t stFileNameLen;

            // If the current file is a directory, make a recursive call to delete it.
            if ( ( wfdCurFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) != 0 )
            {
                if (    ( wcscmp( wfdCurFile.cFileName, L"." ) != 0 )
                     && ( wcscmp( wfdCurFile.cFileName, L".." ) != 0 )
                   )
                {
                    stFileNameLen = wcslen( wfdCurFile.cFileName );

                    // Append the subdirectory name past the last '\\' character.
                    wcsncpy(
                          pdrpParamsInOut->m_pszDirName + uiCurDirNameLen
                        , wfdCurFile.cFileName
                        , pdrpParamsInOut->m_uiDirNameMax - uiCurDirNameLen + 1
                        );

                    // Update the parameter object.
                    --pdrpParamsInOut->m_iMaxDepth;
                    pdrpParamsInOut->m_uiDirNameLen = uiCurDirNameLen + static_cast<UINT>( stFileNameLen );

                    // Delete the subdirectory.
                    dwError = TW32( DwRecursiveEmptyDirectory( pdrpParamsInOut ) );
                    if ( dwError != ERROR_SUCCESS )
                    {
                        break;
                    } // if: an error occurred trying to empty this directory.

                    // Restore the parameter object. There is no need to restore m_uiDirNameLen
                    // since it is never used again in the RHS in this function.
                    ++pdrpParamsInOut->m_iMaxDepth;

                    if ( RemoveDirectory( pdrpParamsInOut->m_pszDirName ) == FALSE )
                    {
                        dwError = TW32( GetLastError() );
                        break;
                    } // if: the current directory could not be removed.
                } // if: the current directory is not "." or ".."
            } // if: current file is a directory.
            else
            {
                //
                // This file is not a directory. Delete it.
                //

                stFileNameLen = wcslen( wfdCurFile.cFileName );

                if ( stFileNameLen > ( pdrpParamsInOut->m_uiDirNameMax - uiCurDirNameLen ) )
                {
                    dwError = TW32( ERROR_BUFFER_OVERFLOW );
                    break;
                }

                // Append the file name to the directory name.
                wcsncpy(
                      pdrpParamsInOut->m_pszDirName + uiCurDirNameLen
                    , wfdCurFile.cFileName
                    , pdrpParamsInOut->m_uiDirNameMax - uiCurDirNameLen + 1
                    );

                if ( DeleteFile( pdrpParamsInOut->m_pszDirName ) == FALSE )
                {
                    dwError = TW32( GetLastError() );
                    break;
                } // if: DeleteFile failed.
            } // else: current file is not a directory.

            if ( FindNextFile( sffhFindFileHandle.HHandle(), &wfdCurFile ) == FALSE )
            {
                dwError = GetLastError();

                if ( dwError == ERROR_NO_MORE_FILES )
                {
                    // We have deleted all the files in this directory.
                    dwError = ERROR_SUCCESS;
                }
                else
                {
                    TW32( dwError );
                }

                // If FindNextFile has failed, we are done.
                break;
            } // if: FindNextFile fails.
        }
        while( true ); // loop infinitely.

        if ( dwError != ERROR_SUCCESS )
        {
            break;
        } // if: something went wrong.

        //
        // If we are here, then all the files in this directory have been deleted.
        //

        // Truncate the directory name at the last '\'
        pdrpParamsInOut->m_pszDirName[ uiCurDirNameLen - 1 ] = L'\0';
    }
    while( false ); // dummy do while loop to avoid gotos.

    return dwError;
} //*** DwRecursiveEmptyDirectory()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DWORD
//  DwRemoveDirectory
//
//  Description:
//      Remove the target directory and everything underneath it.
//      Calls DwRecursiveEmptyDirectory to do the actual work.
//
//  Arguments:
//      pcszTargetDirIn
//          The directory to be removed. Note, this name cannot have trailing
//          backslash '\' characters.
//
//      iMaxDepthIn
//          The maximum depth of the subdirectories that will be removed.
//          Default value is 32. If this depth is exceeded, an exception
//          is thrown.
//
//  Return Value:
//      ERROR_SUCCESS
//          The directory was deleted
//
//      Other Win32 error codes
//          If something went wrong
//
//  Remarks:
//      If the length of the name of any of the files under pcszTargetDirIn
//      exceeds MAX_PATH - 1, an error is returned.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
DwRemoveDirectory( const WCHAR * pcszTargetDirIn, signed int iMaxDepthIn )
{
    WCHAR                       szDirBuffer[ MAX_PATH ];
    SDirRemoveParams            drpParams;
    DWORD                       dwError = ERROR_SUCCESS;
    WIN32_FILE_ATTRIBUTE_DATA   wfadDirAttributes;

    if ( pcszTargetDirIn == NULL )
    {
        goto Cleanup;
    } // if: the directory name is NULL

    ZeroMemory( &wfadDirAttributes, sizeof( wfadDirAttributes ) );

    //
    // Check if the directory exists.
    //
    if ( GetFileAttributesEx( pcszTargetDirIn, GetFileExInfoStandard, &wfadDirAttributes ) == FALSE )
    {
        dwError = GetLastError();
        if ( dwError == ERROR_FILE_NOT_FOUND )
        {
            dwError = ERROR_SUCCESS;
        } // if: the directory does not exist, this is not an error
        else
        {
            TW32( dwError );
        }

        goto Cleanup;
    } // if: we could not get the file attributes

    if ( ( wfadDirAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) == 0 )
    {
        // We are not going to delete files
        goto Cleanup;
    } // if: the path does not point to a directory

    // Copy the input string to our buffer.
    wcsncpy( szDirBuffer, pcszTargetDirIn, MAX_PATH );
    szDirBuffer[ MAX_PATH - 1 ] = L'\0';

    // Initialize the object that holds the parameters for the recursive call.
    drpParams.m_pszDirName = szDirBuffer;
    drpParams.m_uiDirNameLen = static_cast< UINT >( wcslen( szDirBuffer ) );
    drpParams.m_uiDirNameMax = ( sizeof( szDirBuffer ) / sizeof( szDirBuffer[0] ) ) - 1;
    drpParams.m_iMaxDepth = iMaxDepthIn;

    // Call the actual recursive function to empty the directory.
    dwError = TW32( DwRecursiveEmptyDirectory( &drpParams ) );

    // If the directory was emptied, delete it.
    if ( ( dwError == ERROR_SUCCESS ) && ( RemoveDirectory( pcszTargetDirIn ) == FALSE ) )
    {
        dwError = TW32( GetLastError() );
        goto Cleanup;
    } // if: the current directory could not be removed.

Cleanup:
    return dwError;

} //*** DwRemoveDirectory()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\common\formaterrormessage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      FormatErrorMessage.cpp
//
//  Description:
//      Error message formatting routines.
//
//  Maintained By:
//      David Potter (davidp)   31-MAR-2000
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "pch.h"
#include <wchar.h>

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  WINAPI
//  HrFormatErrorMessage(
//      LPWSTR  pszErrorOut,
//      UINT    nMxErrorIn,
//      DWORD   scIn
//      )
//
//  Routine Description:
//      Format the error message represented by the status code.  Works for
//      HRESULTS as well.
//
//  Arguments:
//      pszErrorOut -- Unicode string in which to return the error message.
//      nMxErrorIn  -- Maximum length of the output string.
//      scIn        -- Status code.
//
//  Return Value:
//      S_OK        Status code formatted successfully.
//      Other HRESULTs from FormatMessageW().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
WINAPI
HrFormatErrorMessage(
    LPWSTR  pszErrorOut,
    UINT    nMxErrorIn,
    DWORD   scIn
    )
{
    HRESULT     hr = S_OK;
    DWORD       cch;

    TraceFunc( "" );

    // Format the NT status code from the system.
    cch = FormatMessageW(
                    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    scIn,
                    MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
                    pszErrorOut,
                    nMxErrorIn,
                    0
                    );
    if ( cch == 0 )
    {
        hr = GetLastError();
        hr = THR( HRESULT_FROM_WIN32( hr ) );
        //Trace( g_tagError, _T("Error %d getting message from system for error code %d"), GetLastError(), sc );

        // Format the NT status code from NTDLL since this hasn't been
        // integrated into the system yet.
        cch = FormatMessageW(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                        GetModuleHandleW( L"NTDLL.DLL" ),
                        scIn,
                        MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
                        pszErrorOut,
                        nMxErrorIn,
                        0
                        );
        if ( cch == 0 )
        {
            hr = GetLastError();
            hr = THR( HRESULT_FROM_WIN32( hr ) );
#ifdef _DEBUG

            //DWORD   _sc = GetLastError();
            //Trace( g_tagError, _T("Error %d getting message from NTDLL.DLL for error code %d"), _sc, sc );

#endif

            pszErrorOut[ 0 ] = L'\0';

        } // if: error formatting status code from NTDLL
        else
        {
            hr = S_OK;
        } // else: successfully formatted the status code
    } // if: error formatting status code from system

    HRETURN( hr );

} //*** HrFormatErrorMessage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  __cdecl
//  HrFormatErrorMessageBoxText(
//      LPWSTR  pszMessageOut,
//      UINT    nMxMessageIn,
//      HRESULT hrIn,
//      LPCWSTR pszOperationIn,
//      ...
//      )
//
//  Routine Description:
//      Format the error message represented by the status code.  Works for
//      HRESULTS as well.
//
//  Arguments:
//      pszMessageOut   -- Unicode string in which to return the message.
//      nMxMessageIn    -- Size of the output buffer.
//      hrIn            -- Status code.
//      pszOperationIn  -- Operational format message
//      ...             -- Arguments for the operational format string.
//
//  Return Value:
//      S_OK        Text formatted successfully.
//      Other HRESULTs from FormatErrorMessage().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
__cdecl
HrFormatErrorMessageBoxText(
    LPWSTR  pszMessageOut,
    UINT    nMxMessageIn,
    HRESULT hrIn,
    LPCWSTR pszOperationIn,
    ...
    )
{
    HRESULT     hr = S_OK;
    va_list     valMarker;

    TraceFunc( "" );

    WCHAR   szErrorMsg[ 1024 ];
    WCHAR   szOperation[ 2048 ];

    hr = HrFormatErrorMessage( szErrorMsg, ARRAYSIZE( szErrorMsg ), hrIn );

    va_start( valMarker, pszOperationIn );  // Initialize variable arguments.
    _vsnwprintf(
        szOperation,
        ARRAYSIZE( szOperation ),
        pszOperationIn,
        valMarker
        );
    _snwprintf(
        pszMessageOut,
        nMxMessageIn,
        L"%ls:\r\n\r\n%ls\r\nError ID %d (%#x)", // BUGBUG needs to be a string resource
        szOperation,
        szErrorMsg,
        hrIn,
        hrIn
        );

    HRETURN( hr );

} //*** HrFormatErrorMessageBoxText()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\cfactory.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CFactory.h
//
//  Description:
//      Class Factory implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

typedef HRESULT (*LPCREATEINST)( IUnknown ** ppunkOut );
typedef HRESULT (*CATIDREGISTER)( ICatRegister *, BOOL );

typedef struct _ClassTable {
    LPCREATEINST    pfnCreateInstance;  // creation function for class
    const CLSID *   rclsid;             // classes in this DLL
    LPCTSTR         pszName;            // Class name for debugging
    LPCTSTR         pszComModel;        // String indicating COM threading model
    CATIDREGISTER   pfnCatIDRegister;   // catagory/component ID support registration
    const CLSID *   rclsidAppId;        // the App ID for this component
    LPCTSTR         pszSurrogate;       // the surrogate for the component - "" or NULL indicates use the COM default.
} CLASSTABLE[], *LPCLASSTABLE;

typedef struct _CategoryIdTable {
    const CATID *   rcatid;             // CATID GUID
    LPCTSTR         pszName;            // CATID name
} CATIDTABLE[], *LPCATIDTABLE;

// CFactory
class
CFactory:
    public IClassFactory
{
private:
    // IUnknown
    LONG        m_cRef;

    // IClassFactory data
    LPCREATEINST m_pfnCreateInstance;

private: // Methods
    CFactory( );
    ~CFactory();
    STDMETHOD( HrInit )( LPCREATEINST lpfn );

public: // Methods
    friend HRESULT CALLBACK
        DllGetClassObject( REFCLSID rclsid, REFIID riid, void** ppv );

    // IUnknown
    STDMETHOD( QueryInterface )( REFIID riid, LPVOID *ppv );
    STDMETHOD_( ULONG, AddRef )(void);
    STDMETHOD_( ULONG, Release )(void);

    // IClassFactory
    STDMETHOD( CreateInstance )( IUnknown *punkOuter, REFIID riid, LPVOID *ppv );
    STDMETHOD( LockServer )( BOOL fLock );
};

typedef CFactory* LPCFACTORY ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\cfactorysrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      CFactory.cpp
//
//  Description:
//      Class Factory implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

DEFINE_THISCLASS("CFactory")
#define THISCLASS CFactory

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// Constructor
//
//////////////////////////////////////////////////////////////////////////////
CFactory::CFactory( void )
{
    TraceFunc( "" );

    InterlockedIncrement( &g_cObjects );

    TraceFuncExit();

} //*** CFactory::CFactory()

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CFactory::HrInit( )
//      LPCREATEINST lpfnCreateIn
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CFactory::HrInit(
    LPCREATEINST lpfnCreateIn
    )
{
    TraceFunc( "" );

    // IUnknown stuff
    Assert( m_cRef == 0 );
    AddRef( );  // Add one count

    // IClassFactory
    m_pfnCreateInstance = lpfnCreateIn; 

    HRETURN( S_OK );

} //*** CFactory::HrInit()

//////////////////////////////////////////////////////////////////////////////
//
// Destructor
//
//////////////////////////////////////////////////////////////////////////////
CFactory::~CFactory( void )
{
    TraceFunc( "" );

    InterlockedDecrement( &g_cObjects );

    TraceFuncExit();

} //*** CFactory::~CFactory()

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CFactory::[IUnknown] QueryInterface(
//      REFIID riid,
//      LPVOID *ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CFactory::QueryInterface(
    REFIID riid,
    LPVOID *ppv
    )
{
    TraceQIFunc( riid, ppv );

    HRESULT hr = E_NOINTERFACE;

    if (    IsEqualIID( riid, IID_IUnknown ) )
    {
        //
        // Can't track IUnknown as they must be equal the same address
        // for every QI.
        //
        *ppv = static_cast<IClassFactory*>( this );
        hr = S_OK;
    } // if: IUnknown
    else if ( IsEqualIID( riid, IID_IClassFactory ) )
    {
        *ppv = TraceInterface( __THISCLASS__, IClassFactory, this, 0 );
        hr = S_OK;
    } // else if: IClassFactory

    if ( SUCCEEDED( hr ) )
    {
        ((IUnknown*) *ppv)->AddRef( );
    } // if: success

    QIRETURN( hr, riid );

} //*** CFactory::QueryInterface()

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(ULONG)
// CFactory::[IUnknown] AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CFactory::AddRef( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedIncrement( &m_cRef );

    RETURN( m_cRef );

} //*** CFactory::AddRef()

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(ULONG)
// CFactory::[IUnknown] Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG)
CFactory::Release( void )
{
    TraceFunc( "[IUnknown]" );

    InterlockedDecrement( &m_cRef );

    if ( m_cRef )
        RETURN( m_cRef );

    TraceDo( delete this );

    RETURN(0);

} //*** CFactory::Release()

// ************************************************************************
//
// IClassFactory
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CFactory::[IClassFactory] CreateInstance(
//      IUnknown *pUnkOuter,
//      REFIID riid,
//      void **ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CFactory::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppv
    )
{
    TraceFunc( "[IClassFactory]" );

    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;

    HRESULT     hr  = E_NOINTERFACE;
    IUnknown *  pUnk = NULL; 

    if ( NULL != pUnkOuter )
    {
        hr = THR(CLASS_E_NOAGGREGATION);
        goto Cleanup;
    }

    Assert( m_pfnCreateInstance != NULL );
    hr = THR( m_pfnCreateInstance( &pUnk ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    // Can't safe type.
    TraceMsgDo( hr = pUnk->QueryInterface( riid, ppv ), "0x%08x" );

Cleanup:
    if ( pUnk != NULL )
    {
        ULONG cRef;
        //
        // Release the created instance, not the punk
        //
        TraceMsgDo( cRef = ((IUnknown*) pUnk)->Release( ), "%u" );
    }

    HRETURN( hr );

} //*** CFactory::CreateInstance()

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CFactory::[IClassFactory] LockServer(
//      BOOL fLock
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CFactory::LockServer(
    BOOL fLock
    )
{
    TraceFunc( "[IClassFactory]" );

    if ( fLock )
    {
        InterlockedIncrement( &g_cLock );
    }
    else
    {
        InterlockedDecrement( &g_cLock );
    }

    HRETURN( S_OK );

} //*** CFactory::LockServer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\common\loadstring.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      LoadString.cpp
//
//  Description:
//      LoadStringIntoBSTR implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    01-FEB-2001
//      Geoffrey Pease  (GPease)    22-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "Pch.h"
#include "LoadString.h"

//////////////////////////////////////////////////////////////////////////////
//  Global Variables
//////////////////////////////////////////////////////////////////////////////

const WCHAR g_szWbemClientDLL[] = L"\\WBEM\\WMIUTILS.DLL";

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrLoadStringIntoBSTR
//
//  Description:
//      Retrieves the string resource idsIn from the string table and makes it
//      into a BSTR. If the BSTR is not NULL coming it, it will assume that
//      you are trying reuse an existing BSTR.
//
//  Arguments:
//      hInstanceIn
//          Handle to an instance of the module whose executable file
//          contains the string resource.  If not specified, defaults to
//          g_hInstance.
//
//      langidIn
//          Language ID of string table resource.
//
//      idsIn
//          Specifies the integer identifier of the string to be loaded.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrInout is NULL.
//
//      Other HRESULTs
//          The call failed.
//
//  Remarks:
//      This routine uses LoadResource so that it can get the actual length
//      of the string resource.  If we didn't do this, we would need to call
//      LoadString and allocate memory in a loop.  Very inefficient!
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLoadStringIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    )

{
    TraceFunc1( "idsIn = %d", idsIn );

    HRESULT hr              = S_OK;
    HRSRC   hrsrc           = NULL;
    HGLOBAL hgbl            = NULL;
    PBYTE   pbStringData;
    PBYTE   pbStringDataMax;
    PBYTE   pbStringTable;
    int     cbStringTable;
    int     nTable;
    int     nOffset;
    int     idxString;
    int     iRet;
    int     cch             = 0;

    Assert( idsIn != 0 );
    Assert( pbstrInout != NULL );

    if ( pbstrInout == NULL )
    {
        goto InvalidPointer;
    }
    if ( hInstanceIn == NULL )
    {
        hInstanceIn = g_hInstance;
    }

    // The resource Id specified must be converted to an index into
    // a Windows StringTable.
    nTable = idsIn / 16;
    nOffset = idsIn - (nTable * 16);

    // Internal Table Id's start at 1 not 0.
    nTable++;

    //
    // Find the part of the string table where the string resides.
    //

    // Find the table containing the string.
    // First try to load the language specified.  If we can't find it we
    // try the "neutral" language.
    hrsrc = FindResourceEx( hInstanceIn, RT_STRING, MAKEINTRESOURCE( nTable ), langidIn );
    if ( ( hrsrc == NULL ) && ( GetLastError() == ERROR_RESOURCE_LANG_NOT_FOUND ) )
    {
        hrsrc = FindResourceEx(
                      hInstanceIn
                    , RT_STRING
                    , MAKEINTRESOURCE( nTable )
                    , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                    );
    }
    if ( hrsrc == NULL )
    {
        goto Win32Error;
    }

    // Load the table.
    hgbl = LoadResource( hInstanceIn, hrsrc );
    if ( hgbl == NULL )
    {
        goto Win32Error;
    }

    // Lock the table so we access its data.
    pbStringTable = reinterpret_cast< PBYTE >( LockResource( hgbl ) );
    if ( pbStringTable == NULL )
    {
        goto Win32Error;
    }

    cbStringTable = SizeofResource( hInstanceIn, hrsrc );
    Assert( cbStringTable != 0 );

    TraceFlow3( "HrLoadStringIntoBSTR() - Table = %#.08x, cb = %d, offset = %d", pbStringTable, cbStringTable, nOffset );

    // Set the data pointer to the beginning of the table.
    pbStringData = pbStringTable;
    pbStringDataMax = pbStringTable + cbStringTable;

    //
    // Skip strings in the block of 16 which are before the desired string.
    //

    for ( idxString = 0 ; idxString <= nOffset ; idxString++ )
    {
        Assert( pbStringData != NULL );
        Assert( pbStringData < pbStringDataMax );

        // Get the number of characters excluding the '\0'.
        cch = * ( (USHORT *) pbStringData );

        TraceFlow3( "HrLoadStringIntoBSTR() - pbStringData[ %d ] = %#.08x, cch = %d", idxString, pbStringData, cch );

        // Found the string.
        if ( idxString == nOffset )
        {
            if ( cch == 0 )
            {
                goto NotFound;
            }

            // Skip over the string length to get the string.
            pbStringData += sizeof( WCHAR );

            break;
        } // if: found the string

        // Add one to account for the string length.
        // A string length of 0 still takes 1 WCHAR for the length portion.
        cch++;

        // Skip over this string to get to the next string.
        pbStringData += ( cch * sizeof( WCHAR ) );

    } // for: each string in the block of 16 strings in the table

    // Note: nStringLen is the number of characters in the string not including the '\0'.
    AssertMsg( cch > 0, "Length of string in resource file cannot be zero." );

    //
    // Allocate a BSTR for the string.
    //

    if ( *pbstrInout == NULL )
    {
        //
        //  BUGBUG: 23-FEB-2001 GalenB
        //
        //  The memory tracking is complaining bitterly, and often, about this allocation leaking.
        //
        *pbstrInout = TraceSysAllocStringLen( (OLECHAR *) pbStringData, cch );
        if ( *pbstrInout == NULL )
        {
            goto OutOfMemory;
        }
    } // if: no string allocated previously
    else
    {
        iRet = TraceSysReAllocStringLen( pbstrInout, (OLECHAR *) pbStringData, cch );
        if ( ! iRet )
        {
            goto OutOfMemory;
        }
    } // else: string was allocated previously

    TraceFlow1( "HrLoadStringIntoBSTR() - Loaded string = '%ws'", *pbstrInout );

    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
    goto Cleanup;

NotFound:
    hr = HRESULT_FROM_WIN32( TW32( ERROR_RESOURCE_NAME_NOT_FOUND ) );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

Cleanup:
    HRETURN( hr );

} //*** HrLoadStringIntoBSTR( langidIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatStringIntoBSTR
//
//  Description:
//      Format a string (specified by idsIn, a string resource ID) and
//      variable arguments into a BSTR using the FormatMessage() Win32 API.
//      If the BSTR is not NULL on entry, the BSTR will be reused.
//
//      Calls HrFormatStringWithVAListIntoBSTR to perform the actual work.
//
//  Arguments:
//      hInstanceIn
//          Handle to an instance of the module whose executable file
//          contains the string resource.
//
//      langidIn
//          Language ID of string table resource.
//
//      idsIn
//          Specifies the integer identifier of the string to be loaded.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      ...
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatStringIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , ...
    )
{
    TraceFunc1( "ids = %d", idsIn );

    HRESULT hr;
    va_list valist;

    va_start( valist, pbstrInout );

    hr = HrFormatStringWithVAListIntoBSTR(
                          hInstanceIn
                        , langidIn
                        , idsIn
                        , pbstrInout
                        , valist
                        );

    va_end( valist );

    HRETURN( hr );

} //*** HrFormatStringIntoBSTR( langidIn, idsIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatStringWithVAListIntoBSTR
//
//  Description:
//      Format a string (specified by idsIn, a string resource ID) and
//      variable arguments into a BSTR using the FormatMessage() Win32 API.
//      If the BSTR is not NULL on entry, the BSTR will be reused.
//
//  Arguments:
//      hInstanceIn
//          Handle to an instance of the module whose executable file
//          contains the string resource.
//
//      langidIn
//          Language ID of string table resource.
//
//      idsIn
//          Specifies the integer identifier of the string to be loaded.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      valistIn
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrInout is NULL.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatStringWithVAListIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    )
{
    TraceFunc1( "ids = %d", idsIn );

    HRESULT hr = S_OK;
    BSTR    bstrStringResource = NULL;
    DWORD   cch;
    INT     iRet;
    LPWSTR  psz = NULL;

    Assert( pbstrInout != NULL );

    if ( pbstrInout == NULL )
    {
        goto InvalidPointer;
    }

    //
    // Load the string resource.
    //

    hr = HrLoadStringIntoBSTR( hInstanceIn, langidIn, idsIn, &bstrStringResource );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Format the message with the arguments.
    //

    cch = FormatMessage(
                      ( FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_STRING )
                    , bstrStringResource
                    , 0
                    , 0
                    , (LPWSTR) &psz
                    , 0
                    , &valistIn
                    );
    AssertMsg( cch != 0, "Missing string??" );
    if ( cch == 0 )
    {
        goto Win32Error;
    }

    //
    // Copy the string to a BSTR.
    //

    if ( *pbstrInout == NULL )
    {
        *pbstrInout = TraceSysAllocStringLen( psz, cch );
        if ( *pbstrInout == NULL )
        {
            goto OutOfMemory;
        }
    }
    else
    {
        iRet = TraceSysReAllocStringLen( pbstrInout, psz, cch );
        if ( ! iRet )
        {
            goto OutOfMemory;
        }
    }

    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

Cleanup:
    TraceSysFreeString( bstrStringResource );
    LocalFree( psz );

    HRETURN( hr );

} //*** HrFormatStringWithVAListIntoBSTR( langidIn, idsIn, valistIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatStringIntoBSTR
//
//  Description:
//      Format a string (specified by pcwszFmtIn) and variable arguments into
//      a BSTR using the FormatMessage() Win32 API.  If the BSTR is not NULL
//      on entry, the BSTR will be reused.
//
//      Calls HrFormatStringWithVAListIntoBSTR to perform the actual work.
//
//  Arguments:
//      pcwszFmtIn
//          Specifies the format string.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      ...
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatStringIntoBSTR(
      LPCWSTR   pcwszFmtIn
    , BSTR *    pbstrInout
    , ...
    )
{
    TraceFunc1( "pcwszFmtIn = %ws", pcwszFmtIn );

    HRESULT hr;
    va_list valist;

    va_start( valist, pbstrInout );

    hr = HrFormatStringWithVAListIntoBSTR( pcwszFmtIn, pbstrInout, valist );

    va_end( valist );

    HRETURN( hr );

} //*** HrFormatStringIntoBSTR( pcwszFmtIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatStringWithVAListIntoBSTR
//
//  Description:
//      Format a string (specified by pcwszFmtIn) and variable arguments into
//      a BSTR using the FormatMessage() Win32 API.  If the BSTR is not NULL
//      on entry, the BSTR will be reused.
//
//  Arguments:
//      pcwszFmtIn
//          Specifies the format string.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      valistIn
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pcwszFmtIn or pbstrInout is NULL.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatStringWithVAListIntoBSTR(
      LPCWSTR   pcwszFmtIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    )
{
    TraceFunc1( "pcwszFmtIn = %ws", pcwszFmtIn );

    HRESULT hr = S_OK;
    DWORD   cch;
    INT     iRet;
    LPWSTR  psz = NULL;

    if (    ( pbstrInout == NULL )
        ||  ( pcwszFmtIn == NULL ) )
    {
        goto InvalidPointer;
    }

    //
    // Format the message with the arguments.
    //

    cch = FormatMessage(
                      ( FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_STRING )
                    , pcwszFmtIn
                    , 0
                    , 0
                    , (LPWSTR) &psz
                    , 0
                    , &valistIn
                    );
    AssertMsg( cch != 0, "Missing string??" );
    if ( cch == 0 )
    {
        goto Win32Error;
    }

    if ( *pbstrInout == NULL )
    {
        *pbstrInout = TraceSysAllocStringLen( psz, cch );
        if ( *pbstrInout == NULL )
        {
            goto OutOfMemory;
        }
    }
    else
    {
        iRet = TraceSysReAllocStringLen( pbstrInout, psz, cch );
        if ( ! iRet )
        {
            goto OutOfMemory;
        }
    }

    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

Cleanup:
    LocalFree( psz );

    HRETURN( hr );

} //*** HrFormatStringWithVAListIntoBSTR( pcwszFmtIn, valistIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrFormatMessageIntoBSTR(
//      HINSTANCE   hInstanceIn,
//      UINT        uIDIn,
//      BSTR *      pbstrInout,
//      ...
//      )
//
//  Description:
//      Retrieves the format string from the string resource uIDIn using
//      FormatMessage.
//
//  Arguments:
//      hInstanceIn
//          Handle to an instance of the module whose executable file
//          contains the string resource.
//
//      uIDIn
//          Specifies the integer identifier of the string to be loaded.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrInout is NULL.
//
//      other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatMessageIntoBSTR(
    HINSTANCE   hInstanceIn,
    UINT        uIDIn,
    BSTR *      pbstrInout,
    ...
    )
{
    TraceFunc( "" );

    va_list valist;

    DWORD   cch;
    INT     iRet;

    LPWSTR  psz = NULL;
    HRESULT hr  = S_OK;

    DWORD   dw;
    WCHAR   szBuf[ 255 ];

    if ( pbstrInout == NULL )
        goto InvalidPointer;

    va_start( valist, pbstrInout );

    dw = LoadString( g_hInstance, uIDIn, szBuf, ARRAYSIZE( szBuf ) );
    AssertMsg( dw != 0, "Missing string??" );

    cch = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER
                         | FORMAT_MESSAGE_FROM_STRING,
                         szBuf,
                         0,
                         0,
                         (LPWSTR) &psz,
                         0,
                         &valist
                         );
    va_end( valist );

    AssertMsg( cch != 0, "Missing string??" );
    if ( cch == 0 )
        goto Win32Error;

    if ( *pbstrInout == NULL )
    {
        *pbstrInout = TraceSysAllocStringLen( psz, cch );
        if ( *pbstrInout == NULL )
            goto OutOfMemory;
    }
    else
    {
        iRet = TraceSysReAllocStringLen( pbstrInout, psz, cch );
        if ( !iRet )
            goto OutOfMemory;
    }

Cleanup:
    LocalFree( psz );

    HRETURN( hr );

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( TW32( GetLastError() ) );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

} //*** HrFormatMessageIntoBSTR()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatErrorIntoBSTR
//
//  Description:
//      Retrieves the system error message associated with the HRESULT. If
//      additional arguments are specified, it will use them in the formatting
//      of the error string.
//
//  Arguments:
//      hrIn
//          Error code to lookup the message for.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      ...
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrInout is NULL.
//
//      other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatErrorIntoBSTR(
      HRESULT   hrIn
    , BSTR *    pbstrInout
    , ...
    )
{
    TraceFunc1( "hrIn = 0x%08x", hrIn );

    HRESULT hr  = S_OK;
    va_list valist;

    va_start( valist, pbstrInout );

    hr = HrFormatErrorWithVAListIntoBSTR( hrIn, pbstrInout, valist );

    va_end( valist );

    HRETURN( hr );

} //*** HrFormatErrorIntoBSTR()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatErrorWithVAListIntoBSTR
//
//  Description:
//      Retrieves the system error message associated with the HRESULT. If
//      additional arguments are specified, it will use them in the formatting
//      of the error string.
//
//  Arguments:
//      hrIn
//          Error code to lookup the message for.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//      valistIn
//          Arguments for substitution points in the status text message.
//          The FormatMessage() API is used for formatting the string, so
//          substitution points must of the form %1!ws! and not %ws.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrInout is NULL.
//
//      other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatErrorWithVAListIntoBSTR(
      HRESULT   hrIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    )
{
    TraceFunc1( "hrIn = 0x%08x", hrIn );

    HRESULT hr  = S_OK;
    DWORD   sc = 0;
    DWORD   cch;
    INT     iRet;
    LPWSTR  psz = NULL;

    HMODULE hModule = NULL;
    LPWSTR  pszSysDir = NULL;
    UINT    cchSysDir = MAX_PATH + 1;

    LPWSTR  pszModule = NULL;
    size_t  cchModule = 0;

    Assert( pbstrInout != NULL );

    if ( pbstrInout == NULL )
    {
        goto InvalidPointer;
    } // if:

    cch = FormatMessageW(
                      ( FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_FROM_SYSTEM
                      /*| FORMAT_MESSAGE_IGNORE_INSERTS*/ )
                    , NULL
                    , hrIn
                    , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                    , (LPWSTR) &psz
                    , 0
                    , &valistIn
                    );

    //
    // If the error message was not found then try WMIUtils since we know
    // that their error messages are not propertly located for a system lookup.
    //
    if ( cch == 0 )
    {
        pszSysDir = new WCHAR[ cchSysDir ];
        if ( pszSysDir == NULL )
        {
            goto OutOfMemory;
        } // if:

        sc = GetSystemDirectoryW( pszSysDir, cchSysDir );
        if ( sc > ( cchSysDir - 1 ) )
        {
            delete [] pszSysDir;
            pszSysDir = NULL;

            cchSysDir = sc + 1;

            pszSysDir = new WCHAR[ cchSysDir ];
            if ( pszSysDir == NULL )
            {
                goto OutOfMemory;
            } // if:

            sc = GetSystemDirectoryW( pszSysDir, cchSysDir );
        } // if:

        if ( sc == 0 )
        {
            sc = TW32( GetLastError() );
            goto Win32Error;
        } // if:

        cchModule = wcslen( pszSysDir ) + wcslen( g_szWbemClientDLL ) + 1;

        pszModule = new WCHAR[ cchModule ];
        if ( pszModule == NULL )
        {
            goto OutOfMemory;
        } // if:

        wcscpy( pszModule, pszSysDir );
        wcscat( pszModule, g_szWbemClientDLL );

        hModule = LoadLibraryExW( pszModule, NULL, DONT_RESOLVE_DLL_REFERENCES );
        if ( hModule == NULL )
        {
            sc = TW32( GetLastError() );
            goto Win32Error;
        } // if:

        cch = FormatMessageW(
                          ( FORMAT_MESSAGE_FROM_HMODULE
                          | FORMAT_MESSAGE_ALLOCATE_BUFFER
                          /*| FORMAT_MESSAGE_IGNORE_INSERTS*/ )
                        , hModule
                        , hrIn
                        , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                        , (LPWSTR) &psz
                        , 0
                        , &valistIn
                        );
        if ( cch == 0 )
        {
            sc = TW32( GetLastError() );
        } // if:
    } // if:

    AssertMsg( cch != 0, "Missing string??" );
    if ( cch == 0 )
    {
        goto Win32Error;
    }

    if ( *pbstrInout == NULL )
    {
        *pbstrInout = TraceSysAllocStringLen( psz, cch );
        if ( *pbstrInout == NULL )
        {
            goto OutOfMemory;
        }
    }
    else
    {
        iRet = TraceSysReAllocStringLen( pbstrInout, psz, cch );
        if ( ! iRet )
        {
            goto OutOfMemory;
        }
    }

    //
    // Remove CR's and LF's since they aren't printable and usually mess up
    // the text when displayed.
    //
    for( cch = 0 ; cch < SysStringLen( *pbstrInout ) ; cch ++ )
    {
        if (    ( (*pbstrInout)[ cch ] == L'\n' )
            ||  ( (*pbstrInout)[ cch ] == L'\r' ) )
        {
            (*pbstrInout)[ cch ] = L' ';
        } // if:
    } // for:

    goto Cleanup;

Win32Error:
    hr = HRESULT_FROM_WIN32( sc );
    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

Cleanup:

    if ( psz != NULL )
    {
        LocalFree( psz );
    }

    delete [] pszModule;
    delete [] pszSysDir;

    if ( hModule != NULL )
    {
        FreeLibrary( hModule );
    } // if:

    HRETURN( hr );

} //*** HrFormatErrorWithVAListIntoBSTR( valistIn )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrAnsiStringToBSTR
//
//  Description:
//      Convert and ANSI string into a BSTR.
//
//  Arguments:
//      pcszAnsiIn
//          Pointer to the ANSI string to convert.
//
//      pbstrOut
//          Pointer to the BSTR to receive the string.HrAnsiStringToBSTR
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      S_FALSE
//          The input string was NULL.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      E_POINTER
//          pbstrOut is NULL.
//
//      other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrAnsiStringToBSTR( LPCSTR pcszAnsiIn, BSTR * pbstrOut )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    BSTR    bstr = NULL;
    DWORD   cch;
    DWORD   sc;
    int     nRet;

    if ( pbstrOut == NULL )
    {
        hr = THR( E_POINTER );
        goto Cleanup;
    } // if:

    if ( pcszAnsiIn == NULL )
    {
        *pbstrOut = NULL;
        hr = S_FALSE;
        goto Cleanup;
    } // if:

    //
    //  Determine number of wide characters to be allocated for the
    //  Unicode string.
    //
    cch = (DWORD) strlen( pcszAnsiIn ) + 1;

    bstr = TraceSysAllocStringLen( NULL, cch );
    if ( bstr == NULL )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Cleanup;
    } // if:

    nRet = MultiByteToWideChar( CP_ACP, 0, pcszAnsiIn, cch, bstr, cch );
    if ( nRet == 0 )
    {
        sc = TW32( GetLastError() );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    *pbstrOut = bstr;

Cleanup:

    HRETURN( hr );

} //*** HrAnsiStringToBSTR()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrConcatenateBSTRs
//
//  Description:
//      Concatenate one BSTR onto another one.
//
//  Arguments:
//      pbstrDstInout
//          Specifies the destination BSTR.
//
//      bstrSrcIn
//          Specifies the source BSTR whose contents will be concatenated
//          onto pbstrDstInout.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrConcatenateBSTRs(
      BSTR *    pbstrDstInout
    , BSTR      bstrSrcIn
    )
{
    TraceFunc1( "bstrSrcIn = %ws", bstrSrcIn );

    HRESULT hr = S_OK;

    Assert( pbstrDstInout != NULL );
    Assert( bstrSrcIn != NULL );

    if ( *pbstrDstInout == NULL )
    {
        *pbstrDstInout = TraceSysAllocString( bstrSrcIn );
        if ( pbstrDstInout == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    } // if: no destination string specified
    else
    {
        UINT    cchSrc;
        UINT    cchDst;
        BSTR    bstr = NULL;

        cchSrc = SysStringLen( bstrSrcIn );
        cchDst = SysStringLen( *pbstrDstInout );

        bstr = TraceSysAllocStringLen( NULL, cchSrc + cchDst + 1 );
        if ( bstr == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        wcscpy( bstr, *pbstrDstInout );
        wcscat( bstr, bstrSrcIn );

        SysFreeString( *pbstrDstInout );
        *pbstrDstInout = bstr;
    } // else: destination string was specified

Cleanup:
    HRETURN( hr );

} //*** HrConcatenateBSTRs()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrFormatGuidIntoBSTR
//
//  Description:
//      Format a GUID into a BSTR.  If the BSTR is not NULL on entry,
//      the BSTR will be reused.
//
//  Arguments:
//      pguidIn
//          Specifies the GUID to format into a string.
//
//      pbstrInout
//          Pointer to the BSTR to receive the string. On a failure, the BSTR
//          may be the same or NULL.
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      Other HRESULTs
//          The call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrFormatGuidIntoBSTR(
      GUID *    pguidIn
    , BSTR *    pbstrInout
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    WCHAR   wszGuid[ 64 ];
    DWORD   cch;
    INT     iRet;

    if (    ( pbstrInout == NULL )
        ||  ( pguidIn == NULL ) )
    {
        goto InvalidPointer;
    }

    cch = _snwprintf(
              wszGuid
            , ARRAYSIZE( wszGuid )
            , L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"
            , pguidIn->Data1
            , pguidIn->Data2
            , pguidIn->Data3
            , pguidIn->Data4[ 0 ]
            , pguidIn->Data4[ 1 ]
            , pguidIn->Data4[ 2 ]
            , pguidIn->Data4[ 3 ]
            , pguidIn->Data4[ 4 ]
            , pguidIn->Data4[ 5 ]
            , pguidIn->Data4[ 6 ]
            , pguidIn->Data4[ 7 ]
            );

    if ( *pbstrInout == NULL )
    {
        *pbstrInout = TraceSysAllocStringLen( wszGuid, cch );
        if ( *pbstrInout == NULL )
        {
            goto OutOfMemory;
        }
    }
    else
    {
        iRet = TraceSysReAllocStringLen( pbstrInout, wszGuid, cch );
        if ( ! iRet )
        {
            goto OutOfMemory;
        }
    }

    goto Cleanup;

OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;

InvalidPointer:
    hr = THR( E_POINTER );
    goto Cleanup;

Cleanup:

    HRETURN( hr );

} //*** HrFormatGuidIntoBSTR()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\common\pch.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Pch.h
//
//  Description:
//      Precompiled header file.
//
//  Maintained By:
//      Galen Barbee (GalenB) 01-JUN-2000
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Constant Definitions
//////////////////////////////////////////////////////////////////////////////
#define UNICODE

#if DBG==1 || defined( _DEBUG )
#define DEBUG
//
//  Define this to change Interface Tracking
//
//#define NO_TRACE_INTERFACES
//
//  Define this to pull in the SysAllocXXX functions. Requires linking to
//  OLEAUT32.DLL
//
#define USES_SYSALLOCSTRING
#endif // DBG==1 || _DEBUG

const   int     TIMEOUT = -1;
const   int     PUNKCHUNK = 10;

#define CELEMENTS(x)     ( sizeof( x ) / sizeof( x[ 0 ] ) )


//////////////////////////////////////////////////////////////////////////////
//  Forward Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  External Class Declarations
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////
#include <Pragmas.h>
#include <windows.h>
#include <objbase.h>
#include <shlwapi.h>
#include <ComCat.h>
#include <wchar.h>

#include <Common.h>
#include <Debug.h>
#include <Log.h>
#include <CITracker.h>
#include <CFactory.h>
#include <Dll.h>
#include <Dsgetdc.h>
#include <Lm.h>

//////////////////////////////////////////////////////////////////////////////
//  Type Definitions
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\common\getcomputername.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      GetComputerName.cpp
//
//  Description:
//      Getting and setting the computer name.
//
//  Maintained By:
//      Galen Barbee (GalenB)   31-MAR-2000
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "pch.h"

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrGetComputerName()
//
//  Description:
//      Get name of the computer on which this object is present.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          Success.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
WINAPI
HrGetComputerName(
    COMPUTER_NAME_FORMAT    cnfIn,
    BSTR *                  pbstrComputerNameOut
    )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;
    PWCHAR  pszCompName = NULL;
    DWORD   cchCompName = 0;
    DWORD   sc;
    DWORD   dwErr;
    BOOL    fAppendDomain = FALSE;
    PDOMAIN_CONTROLLER_INFO pdci = NULL;
    int     idx;

    if ( pbstrComputerNameOut == NULL )
    {
        hr = THR( E_POINTER );
        goto CleanUp;
    } // if:

    //
    // DsGetDcName will give us access to a usable domain name, regardless of whether we are
    // currently in a W2k or a NT4 domain. On W2k and above, it will return a DNS domain name,
    // on NT4 it will return a NetBIOS name.
    //
    dwErr = TW32( DsGetDcName(
                      NULL
                    , NULL
                    , NULL
                    , NULL
                    , DS_DIRECTORY_SERVICE_PREFERRED
                    , &pdci
                    ) );
    if ( dwErr != ERROR_SUCCESS )
    {
        goto CleanUp;
    } // if: DsGetDcName failed

    // 
    // This handles the case when we are a member of a legacy (pre-W2k) Domain.
    // In this case, both FQDN and DnsDomain will not receive useful data from GetComputerNameEx.
    // What we actually want to get is <computername>.<DomainName> in every case
    //
    switch( cnfIn )
    {
        case ComputerNameDnsFullyQualified:
            fAppendDomain = TRUE;
            cnfIn = ComputerNameDnsHostname;
            break;

        case ComputerNamePhysicalDnsFullyQualified:
            fAppendDomain = TRUE;
            cnfIn = ComputerNamePhysicalDnsHostname;
            break;

        case ComputerNameDnsDomain:
        case ComputerNamePhysicalDnsDomain:
            *pbstrComputerNameOut = TraceSysAllocString( pdci->DomainName );
            if ( *pbstrComputerNameOut == NULL )
            {
                goto OutOfMemory;
            } // if:
            goto CleanUp;
    }

    pszCompName = NULL;

    for ( idx = 0; ; idx++ )
    {
        Assert( idx < 2 );

        if ( !GetComputerNameEx( cnfIn, pszCompName, &cchCompName ) )
        {
            sc = GetLastError();
            if ( sc == ERROR_MORE_DATA )
            {
                if ( fAppendDomain )
                {
                    cchCompName += (DWORD)( wcslen( pdci->DomainName ) + 1 );
                } // if:

                pszCompName = new WCHAR[ cchCompName ];
                if ( pszCompName == NULL )
                {
                    goto OutOfMemory;
                } // if: new failed

                continue;
            } // if: more data...

            TW32( sc );
            hr = HRESULT_FROM_WIN32( sc );
            LogMsg( "GetComputerNameEx failed. hr = 0x%08x", hr );
            goto CleanUp;
        } // if: GetComputerNameEx() failed

        if ( fAppendDomain )
        {
            wcscat( pszCompName, L"." );
            wcscat( pszCompName, pdci->DomainName );
        }

        *pbstrComputerNameOut = TraceSysAllocString( pszCompName );
        if ( *pbstrComputerNameOut == NULL )
        {
            goto OutOfMemory;
        } // if:

        hr = S_OK;
        break;
    } // for: loop to retry the operation.

    goto CleanUp;

OutOfMemory:

    hr = THR( E_OUTOFMEMORY );
    LogMsg( "HrGetComputerName: out of memory." );

CleanUp:

    delete [] pszCompName;

    if ( pdci != NULL )
    {
        NetApiBufferFree( pdci );
    }

    HRETURN( hr );

} //*** HrGetComputerName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\citrackersrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 - 2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.CPP
//
//  Description:
//      Implementation of a COM interface tracker.
//
//  [Documentation:]
//      Debugging.PPT - A power-point presentation of the debug utilities.
//
//  Maintained By:
//      Geoffrey Pease (gpease) 19-NOV-1999
//
//  Notes:
//      Define NO_TRACE_INTERFACES to disable interface tracking in DEBUG
//      builds.
//
//      Define TRACE_INTERFACES_ENABLED to enable interface tracking in RETAIL
//      builds.
//
//      Define FULL_TRACE_INTERFACES_ENABLED to enable full interface
//      tracking in RETAIL builds.  Full interface tracking is enabled if
//      interface tracking is enabled and building for X86.
//      Full interface tracking is X86 specific for now. It can be adapted for
//      other platforms as required. Since today, most of our developement is
//      done on the X86 platform, there is not a need to do this (yet).
//
//////////////////////////////////////////////////////////////////////////////

//#include "pch.h"
#include <shlwapi.h>

#if defined( TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN TRACE_INTERFACES_ENABLED
//

#if defined( DEBUG )

//////////////////////////////////////////////////////////////////////////////
//
// LPCTSTR
// PszDebugFindInterface(
//      REFIID      riidIn,
//      LPTSTR      pszBufOut
//      )
//
// Description:
//      Uses the Interface Tracking Table (g_itTable) to lookup a human
//      readable name for the riidIn. If no matching interface is found. it
//      will use the pszBufOut to format a GUID string and return it.
//
// Arguments:
//      riidIn      - The interface ID to lookup.
//      pszBufOut   - Buffer to use if interface not found to format GUID.
//
// Return Value:
//      Never NULL. It will always a valid string pointer to either the
//      interface name or to pszBufOut.
//
// Notes:
//      pszBufOut must be at least cchGUID_STRING_SIZE in size.
//
//////////////////////////////////////////////////////////////////////////////
LPCTSTR
PszDebugFindInterface(
    REFIID      riidIn,
    LPTSTR      pszBufOut
    )
{
    if ( IsTraceFlagSet( mtfQUERYINTERFACE ) )
    {
        int idx;

        for ( idx = 0; g_itTable[ idx ].riid != NULL; idx++ )
        {
            if ( riidIn == *g_itTable[ idx ].riid )
            {
                return g_itTable[ idx ].pszName;

            } // if: found interface

        } // for: searching for interface

        wnsprintf( pszBufOut,
                   cchGUID_STRING_SIZE,
                   TEXT("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                   riidIn.Data1,
                   riidIn.Data2,
                   riidIn.Data3,
                   riidIn.Data4[0],
                   riidIn.Data4[1],
                   riidIn.Data4[2],
                   riidIn.Data4[3],
                   riidIn.Data4[4],
                   riidIn.Data4[5],
                   riidIn.Data4[6],
                   riidIn.Data4[7]
                   );
    } // if: query interface is on
    else
    {
        return TEXT("riid");
    } // else: just print riid

    return pszBufOut;

} //*** PszDebugFindInterface( )
#endif // DEBUG

//
// END TRACE_INTERFACES_ENABLED
//
///////////////////////////////////////
#endif // TRACE_INTERFACES_ENABLED


// ************************************************************************


#if defined( FULL_TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN FULL_TRACE_INTERFACES_ENABLED
//

//
// Globals
//
static IDeadObjTracker * g_pidoTracker = NULL;  // dead object - there is only one.

#ifndef NOISY_TRACE_INTERFACES
///////////////////////////////////////
//
// DEBUG !NOISY_TRACE_INTERFACES
//

//
// Undefining these macros to make the CITracker quiet.
//
#undef  TraceFunc
#define TraceFunc       1 ? (void)0 : (void)
#undef  TraceFunc1
#define TraceFunc1      1 ? (void)0 : (void)
#undef  TraceFunc2
#define TraceFunc2      1 ? (void)0 : (void)
#undef  TraceFunc3
#define TraceFunc3      1 ? (void)0 : (void)
#undef  TraceFunc4
#define TraceFunc4      1 ? (void)0 : (void)
#undef  TraceFunc5
#define TraceFunc5      1 ? (void)0 : (void)
#undef  TraceFunc6
#define TraceFunc6      1 ? (void)0 : (void)
#undef  TraceQIFunc
#define TraceQIFunc     1 ? (void)0 : (void)
#undef  TraceFuncExit
#define TraceFuncExit()
#undef  FRETURN
#define FRETURN( _u )
#undef  HRETURN
#define HRETURN(_hr)    return(_hr)
#undef  RETURN
#define RETURN(_fn)     return(_fn)
#undef  RRETURN
#define RRETURN( _fn )  return(_fn)

//
// END !NOISY_TRACE_INTERFACES
//
///////////////////////////////////////
#endif // NOISY_TRACE_INTERFACES

#if defined( DEBUG )

//
// These are internal to debug.cpp but not published in debug.h.
//
BOOL
IsDebugFlagSet(
    TRACEFLAG   tfIn
    );

void
DebugInitializeBuffer(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPTSTR      pszBufIn,
    INT *       pcchInout,
    LPTSTR *    ppszBufOut
    );
#endif // DEBUG

///////////////////////////////////////
//
// CITracker Definition
//
//

DEFINE_THISCLASS("CITracker");
#define THISCLASS CITracker
#define LPTHISCLASS CITracker*

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// Special new( ) for CITracker
//
// Description:
//      Creates an object the size of the object plus nExtraIn bytes. This
//      allows the Vtable that the CITracker object is tracking to be
//      appended to the end of the CITracker object.
//
//////////////////////////////////////////////////////////////////////////////
#ifdef new
#undef new
#endif
void*
__cdecl
operator new(
    unsigned int    nSizeIn,
    LPCTSTR         pszFileIn,
    const int       nLineIn,
    LPCTSTR         pszModuleIn,
    UINT            nExtraIn,
    LPCTSTR         pszNameIn
    )
{
    void * pv = HeapAlloc( GetProcessHeap(), 0, nSizeIn + nExtraIn );

    return TraceMemoryAdd( mmbtOBJECT, pv, pszFileIn, nLineIn, pszModuleIn, nSizeIn + nExtraIn, TEXT("CITracker") );

} //*** operator new( )

//////////////////////////////////////////////////////////////////////////////
//
// LPUNKNOWN
// DebugTrackInterface(
//      LPCTSTR     pszNameIn,
//      REFIID      riidIn,
//      LPUNKNOWN   punkIn,
//      LONG        cRefIn
//      )
//
// Description:
//      Create an interface tracker for the given interface.
//
// Arguments:
//      pszNameIn   - Name to associate with object that the punk references.
//      riidIn      - Interface IID of the interface to be tracked.
//      punkIn      - Interface pointer to track.
//      cRefIn      - Initialize ref count on the interface.
//
// Return Type:
//      On failure, this will be punkIn.
//      On success, pointer to an object that implements the interface to
//          be tracked.
//
//////////////////////////////////////////////////////////////////////////////
LPUNKNOWN
DebugTrackInterface(
    LPCTSTR   pszFileIn,
    const int nLineIn,
    LPCTSTR   pszModuleIn,
    LPCTSTR   pszNameIn,
    REFIID    riidIn,
    LPUNKNOWN punkIn,
    LONG      cRefIn
    )
{
    TraceFunc3( "pszNameIn = '%s', riidIn, punkIn = 0x%08x, cRefIn = %u",
                pszNameIn,
                punkIn,
                cRefIn
                );

    UINT      nEntry  = 0;
    LPUNKNOWN punkOut = punkIn;

    //
    // Scan the table looking for the matching interface definition.
    //
    for( nEntry = 0; g_itTable[ nEntry ].riid != NULL; nEntry++ )
    {
        if ( riidIn == *g_itTable[ nEntry ].riid )
        {
            //
            // Figure out how much "extra" to allocate onto the CITracker.
            //
            UINT nExtra = ( 3 + g_itTable[ nEntry ].cFunctions ) * sizeof(LPVOID);

            //
            // Create a name for the tracker.
            //
            // TODO:    gpease  19-NOV-1999
            //          Maybe merge this in with the nExtra(??).
            //
            LPTSTR psz;
            LPTSTR pszName =
                (LPTSTR) HeapAlloc( GetProcessHeap(), 0,
                                     ( lstrlen( g_itTable[ nEntry ].pszName ) + lstrlen( pszNameIn ) + 3 + 2 ) * sizeof(TCHAR) );

            psz = StrCpy( pszName, pszNameIn );                 // object name
            psz = StrCat( psz, TEXT("::[") );                   // + 3
            psz = StrCat( psz, g_itTable[ nEntry ].pszName );   // + interface name
            psz = StrCat( psz, TEXT("]") );                     // + 2

            //
            // Create the tracker.
            //
            LPTHISCLASS pc = new( pszFileIn, nLineIn, pszModuleIn, nExtra, pszName ) THISCLASS( );
            if ( pc != NULL )
            {
                HRESULT hr;

                //
                // Initialize the tracker.
                //
                hr = THR( pc->Init( &punkOut, punkIn, &g_itTable[ nEntry ], pszName, cRefIn ) );
                if ( FAILED( hr ) )
                {
                    //
                    // If it failed, delete it.
                    //
                    delete pc;

                } // if: failed to initialize

            } // if: got memory

            break; // exit loop

        } // if: matched interface

    } // for: more entries in table

    AssertMsg( g_itTable[ nEntry ].riid != NULL, "There has been a request to track an interface that is not in the interface table." );

    RETURN( punkOut );

} //*** DebugTrackInterface( )

//////////////////////////////////////////////////////////////////////////////
//
// CITracker::CITracker( void )
//
//////////////////////////////////////////////////////////////////////////////
CITracker::CITracker( void )
{
    TraceFunc( "" );

    //
    // KB: gpease 10-OCT-1998
    // This class will leak objects to help catch bad components
    // that call back into released interfaces therefore this
    // DLL will not be able to be released.
    //
    if ( g_tfModule & mtfCITRACKERS )
    {
        //
        //  Only count CITrackers if tracking is enabled.
        //
        InterlockedIncrement( &g_cObjects );
    }

    TraceFuncExit();

} //*** CITracker::ctor( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CITracker::Init(
//      LPUNKNOWN *                     ppunkOut,
//      LPUNKNOWN                       punkIn,
//      const INTERFACE_TABLE_ENTRY *   piteIn,
//      LPCTSTR                         pszNameIn,
//      BOOL                            fAddRefIn
//      )
//
// Description:
//      Initializes the CITracker object. It creates a copy of the VTable
//      of the interface to be tracked replacing the QI, AddRef and Release
//      methods with its own IUnknown. This allows CITracker to be "in the
//      loop" for those calls.
//
// Arguments:
//      ppunkOut    - The "punk" to be passed around.
//      punkIn      - The interface to be copied and tracked.
//      piteIn      - The interface table entry for the interface.
//      pszNameIn   - The name to be given to this CITracker.
//      fAddRefIn   - TRUE is the CITracker should start with a Ref Count of 1.
//
// Return Value:
//      S_OK        - Success.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CITracker::Init(
    LPUNKNOWN *                     ppunkOut,
    LPUNKNOWN                       punkIn,
    const INTERFACE_TABLE_ENTRY *   piteIn,
    LPCTSTR                         pszNameIn,
    LONG                            cRefIn
    )
{
    HRESULT hr = S_OK;

    TraceFunc5( "ppunkOut = 0x%08x, punkIn = 0x%08x, iteIn = %s, pszNameIn = '%s', cRefIn = %u",
                ppunkOut,
                punkIn,
                piteIn->pszName,
                pszNameIn,
                cRefIn
                );

    //
    // Generate new Vtbls for each interface
    //
    LPVOID * pthisVtbl  = (LPVOID*) (IUnknownTracker *) this;
    LPVOID * ppthatVtbl = (LPVOID*) punkIn;
    DWORD    dwSize     = ( 3 + piteIn->cFunctions ) * sizeof(LPVOID);

    AssertMsg( dwSize < 30 * sizeof(LPVOID), "Need to make Dead Obj and IUnknownTracker larger!" );

    //
    // Interface tracking information initialization
    //
    m_vtbl.cRef         = cRefIn;
    m_vtbl.pszInterface = pszNameIn;
    m_vtbl.dwSize       = dwSize;

    //
    // Copy our IUnknownTracker vtbl to our "fix-up-able" vtbl
    //
    CopyMemory( &m_vtbl.lpfnQueryInterface, *pthisVtbl, dwSize );

    //
    // Remember the "punk" pointer so we can pass it back in when
    // we jump to the orginal objects IUnknown functions.
    //
    m_vtbl.punk = (LPUNKNOWN) punkIn;

    //
    // And finally, point the objects vtbl for this interface to
    // our newly created vtbl.
    //
    m_vtbl.pNewVtbl = (VTBL *) &m_vtbl.lpfnQueryInterface;
    *pthisVtbl      = m_vtbl.pNewVtbl;
    *ppunkOut       = (LPUNKNOWN) (IUnknownTracker *) this;

    TraceMsg( mtfCITRACKERS, L"TRACK: Tracking %s Interface (%#x)", m_vtbl.pszInterface, punkIn );

    HRETURN( hr );

} //*** CITracker::Init( )

//////////////////////////////////////////////////////////////////////////////
//
// CITracker::~CITracker( void )
//
//////////////////////////////////////////////////////////////////////////////
CITracker::~CITracker( void )
{
    TraceFunc1( "for %s", m_vtbl.pszInterface );

    if ( m_vtbl.pszInterface != NULL )
    {
        HeapFree( GetProcessHeap(), 0, (LPVOID) m_vtbl.pszInterface );
    } // if: have interface pointer

    if ( g_tfModule & mtfCITRACKERS )
    {
        //
        //  Only count CITrackers if tracking is enabled.
        //
        InterlockedDecrement( &g_cObjects );
    }

    TraceFuncExit();

} //*** CITracker::dtor( )

// ************************************************************************
//
// IUnknownTracker
//
// ************************************************************************

///////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// CITracker::QueryInterface(
//      REFIID      riid,
//      LPVOID *    ppv
//      )
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CITracker::QueryInterface(
    REFIID      riid,
    LPVOID *    ppv
    )
{
    TraceFunc1( "{%s}", m_vtbl.pszInterface );
    TraceMsg( mtfCITRACKERS, "TRACK: + %s::QueryInterface( )", m_vtbl.pszInterface );

    //
    // Call the punk's QueryInterface( ).
    //
    HRESULT hr = m_vtbl.punk->QueryInterface( riid, ppv );

    //
    // KB:  TRACK_ALL_QIED_INTERFACES   gpease 25-NOV-1999
    //      Thinking out loud, should we track all interfaces QI'ed from
    //      a tracked interface auto-magically? If so, turn this #define
    //      on.
    //
    // #define TRACK_ALL_QIED_INTERFACES
#if defined( TRACK_ALL_QIED_INTERFACES )
    if ( !IsEqualIID( riid, IID_IUnknown )
       )
    {
        *ppv = DebugTrackInterface( TEXT("<Unknown>"),
                                    0,
                                    __MODULE__,
                                    m_vtbl.pszInterface,
                                    riid,
                                    (IUnknown*) *ppv,
                                    TRUE
                                    );
    } // if: not the IUnknown
#endif

    TraceMsg( mtfCITRACKERS,
              "TRACK: V %s::QueryInterface( ) [ *ppv = %#x ]",
              m_vtbl.pszInterface,
              *ppv
              );

    HRETURN( hr );

} //*** CITracker::QueryInterface( )

///////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_( ULONG )
// CITracker::AddRef( void )
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CITracker::AddRef( void )
{
    TraceFunc1( "{%s}", m_vtbl.pszInterface );
    TraceMsg( mtfCITRACKERS, "TRACK: + %s AddRef( ) [ CITracker = %#08x ]", m_vtbl.pszInterface, this );

    //
    // Call the punk's AddRef( ).
    //
    ULONG ul = m_vtbl.punk->AddRef( );

    //
    // Increment our counter.
    //
    ULONG ulvtbl = InterlockedIncrement( (LONG *) &m_vtbl.cRef );

    TraceMsg( mtfCITRACKERS,
              "TRACK: V %s AddRef( ) [ I = %u, O = %u, CITracker = %#08x ]",
              m_vtbl.pszInterface,
              ulvtbl,
              ul,
              this
              );

    AssertMsg( ul >= ulvtbl, "The objects ref should be higher than the interfaces." );

    RETURN( ul );

} //*** CITracker::AddRef( )

///////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_( ULONG )
// CITracker::Release( void )
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
CITracker::Release( void )
{
    TraceFunc1( "{%s}", m_vtbl.pszInterface );
    TraceMsg( mtfCITRACKERS, "TRACK: + %s Release( ) [ CITracker = %#08x ]", m_vtbl.pszInterface, this );

    //
    // Call the punk's Release( ).
    //
    ULONG ul = m_vtbl.punk->Release( );

    //
    // Decrement our counter.
    //
    ULONG ulvtbl = InterlockedDecrement( (LONG *) &m_vtbl.cRef );

    TraceMsg( mtfCITRACKERS,
              "TRACK: V %s Release( ) [ I = %u, O = %u, CITracker = %#08x ]",
              m_vtbl.pszInterface,
              ulvtbl,
              ul,
              this
              );

    //
    // Our ref count should always be less than the punk's ref count.
    //
    AssertMsg( ul >= ulvtbl, "The objects ref should be higher than the interfaces." );

    if ( ulvtbl )
    {
        RETURN( ulvtbl );
    } // if: we still have a ref

    if ( g_pidoTracker == NULL )
    {
        //
        // Create a dead object - if more than one is created at a time, we might leak it.
        //
        // TODO:    gpease 19-NOV-1999
        //          Work on not leaking "extra" dead objects.
        //
        g_pidoTracker = new( TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT("Dead Object") ) IDeadObjTracker( );

        // Don't track this object
        TraceMemoryDelete( g_pidoTracker, FALSE );

    } // if: no dead object

    Assert( g_pidoTracker != NULL );
    if ( g_pidoTracker != NULL )
    {
        LPVOID * pthisVtbl  = (LPVOID *) (IUnknownTracker *) this;
        LPVOID * ppthatVtbl = (LPVOID *) (IDeadObjTracker *) g_pidoTracker;

        // Copy the DeadObj vtbl.
        CopyMemory( &m_vtbl.lpfnQueryInterface, *ppthatVtbl, m_vtbl.dwSize );

        //
        // Don't really delete it, but fake the debug output as if we did.
        //
        TraceFunc1( "for %s", m_vtbl.pszInterface );
        TraceMsg( mtfCITRACKERS, "TRACK: # %s set to dead object [ punk = %#08x ]", m_vtbl.pszInterface, pthisVtbl );
        FRETURN( 0 );

        // Stop tracking this object.
        TraceMemoryDelete( this, FALSE );

    } // if: dead object created
    else
    {
        //
        // No dead object; nuke ourselves. This will at least cause an AV if
        // the program tries to call on our interface alerting the programmer
        // that somethings wrong.
        //
        delete this;

    } // else: no dead object

    RETURN(0);

} //*** CITracker::Release( )

//****************************************************************************
//
// IDeadObjTracker - The dead interface object tracker.
//
// This object is shunted into release interfaces that were being tracked by
// the CITracker class. Any calls to a released interface will end up causing
// an Assert and if execution continues it will return E_FAIL.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// IDeadObjTracker:Stub(x)
//
//////////////////////////////////////////////////////////////////////////////
#define IDeadObjTrackerStub( _iStubNum ) \
STDMETHODIMP \
IDeadObjTracker::Stub##_iStubNum( LPVOID* punk ) \
{ \
    const int   cchDebugMessageSize = 255; \
    TCHAR       szMessage[ cchDebugMessageSize ]; \
    LRESULT     lResult;\
    \
    DebugMsg( "*ERROR* %s: Entered %s (%#08x) after it was released. Returning E_FAIL.", \
              __MODULE__, \
              m_vtbl.pszInterface, \
              this \
              ); \
\
    wnsprintf( szMessage, \
               cchDebugMessageSize, \
               TEXT("Entered %s (%#08x) after it was released.\n\nDo you want to break here?\n\n(If you do not break, E_FAIL will be returned.)"), \
               m_vtbl.pszInterface, \
               this \
               );\
\
    lResult = MessageBox( NULL, szMessage, TEXT("Dead Interface"), MB_YESNO | MB_ICONWARNING );\
    if ( lResult == IDYES \
       ) \
    { \
        DEBUG_BREAK; \
    } \
\
    return E_FAIL; \
}

IDeadObjTrackerStub(0);
IDeadObjTrackerStub(1);
IDeadObjTrackerStub(2);
IDeadObjTrackerStub(3);
IDeadObjTrackerStub(4);
IDeadObjTrackerStub(5);
IDeadObjTrackerStub(6);
IDeadObjTrackerStub(7);
IDeadObjTrackerStub(8);
IDeadObjTrackerStub(9);
IDeadObjTrackerStub(10);
IDeadObjTrackerStub(11);
IDeadObjTrackerStub(12);
IDeadObjTrackerStub(13);
IDeadObjTrackerStub(14);
IDeadObjTrackerStub(15);
IDeadObjTrackerStub(16);
IDeadObjTrackerStub(17);
IDeadObjTrackerStub(18);
IDeadObjTrackerStub(19);
IDeadObjTrackerStub(20);
IDeadObjTrackerStub(21);
IDeadObjTrackerStub(22);
IDeadObjTrackerStub(23);
IDeadObjTrackerStub(24);
IDeadObjTrackerStub(25);
IDeadObjTrackerStub(26);
IDeadObjTrackerStub(27);
IDeadObjTrackerStub(28);
IDeadObjTrackerStub(29);
IDeadObjTrackerStub(30);

//****************************************************************************
//
// IUnknownTracker stub
//
// This merely directs the incoming call back to the orginal object. The
// IUnknown methods will be remapped the the CITracker methods.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP
// IUnknownTracker::QueryInterface(
//      REFIID      riid,
//      LPVOID *    ppv
//      )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
IUnknownTracker::QueryInterface(
    REFIID      riid,
    LPVOID *    ppv
    )
{
    ErrorMsg( "How did you get here?", 0 );
    AssertMsg( 0, "You shouldn't be here!" );
    return E_FAIL;

} //*** IUnknownTracker::QueryInterface( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_( ULONG )
// IUnknownTracker::AddRef( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
IUnknownTracker::AddRef( void )
{
    ErrorMsg( "How did you get here?", 0 );
    AssertMsg( 0, "You shouldn't be here!" );
    return -1;

} //*** IUnknownTracker::AddRef( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_( ULONG )
// IUnknownTracker::Release( void )
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG )
IUnknownTracker::Release( void )
{
    ErrorMsg( "How did you get here?", 0 );
    AssertMsg( 0, "You shouldn't be here!" );
    return -1;

} //*** IUnknownTracker::Release( )

//////////////////////////////////////////////////////////////////////////////
//
// STDMETHODIMP_(void)
// IUnknownTracker::Stub(x)
//
// These are just stubs to redirect the call to the "real" method on the punk.
// We actually dissappear from the call stack.
//
//////////////////////////////////////////////////////////////////////////////
#define IUnknownTrackerStub( i ) \
void \
_declspec(naked) \
IUnknownTracker::Stub##i() \
{ \
    _asm mov eax, ss:4[esp]          \
    _asm mov ecx, 8[eax]             \
    _asm mov eax, [ecx]              \
    _asm mov ss:4[esp], ecx          \
    _asm jmp dword ptr cs:(4*i)[eax] \
}

IUnknownTrackerStub(3);
IUnknownTrackerStub(4);
IUnknownTrackerStub(5);
IUnknownTrackerStub(6);
IUnknownTrackerStub(7);
IUnknownTrackerStub(8);
IUnknownTrackerStub(9);
IUnknownTrackerStub(10);
IUnknownTrackerStub(11);
IUnknownTrackerStub(12);
IUnknownTrackerStub(13);
IUnknownTrackerStub(14);
IUnknownTrackerStub(15);
IUnknownTrackerStub(16);
IUnknownTrackerStub(17);
IUnknownTrackerStub(18);
IUnknownTrackerStub(19);
IUnknownTrackerStub(20);
IUnknownTrackerStub(21);
IUnknownTrackerStub(22);
IUnknownTrackerStub(23);
IUnknownTrackerStub(24);
IUnknownTrackerStub(25);
IUnknownTrackerStub(26);
IUnknownTrackerStub(27);
IUnknownTrackerStub(28);
IUnknownTrackerStub(29);
IUnknownTrackerStub(30);


//
// END FULL_TRACE_INTERFACES_ENABLED
//
///////////////////////////////////////
#endif // FULL_TRACE_INTERFACES_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\common.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Common.h
//
//  Description:
//      Common definitions.
//
//  Maintained By:
//      David Potter (DavidP) 14-DEC-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//  Macro Definitions
//////////////////////////////////////////////////////////////////////////////

#if ! defined( StrLen )
#define StrLen( _sz ) lstrlen( _sz )    // why isn't this in SHLWAPI?
#define StrLenA( _sz ) lstrlenA( _sz )  // why isn't this in SHLWAPI?
#define StrLenW( _sz ) lstrlenW( _sz )  // why isn't this in SHLWAPI?
#endif // ! defined( StrLen )

#if !defined( ARRAYSIZE )
#define ARRAYSIZE( _x ) ((UINT) ( sizeof( _x ) / sizeof( _x[ 0 ] ) ))
#endif // ! defined( ARRAYSIZE )

#if !defined( PtrToByteOffset )
#define PtrToByteOffset(base, offset)   (((LPBYTE)base)+offset)
#endif // !defined( PtrToByteOffset )

//
// COM Macros to gain type checking.
//
#if !defined( TypeSafeParams )
#define TypeSafeParams( _interface, _ppunk ) \
    IID_##_interface, reinterpret_cast< void ** >( static_cast< _interface ** >( _ppunk ) )
#endif // !defined( TypeSafeParams )

#if !defined( TypeSafeQI )
#define TypeSafeQI( _interface, _ppunk ) \
    QueryInterface( TypeSafeParams( _interface, _ppunk ) )
#endif // !defined( TypeSafeQI )

#if !defined( TypeSafeQS )
#define TypeSafeQS( _clsid, _interface, _ppunk ) \
    QueryService( _clsid, TypeSafeParams( _interface, _ppunk ) )
#endif // !defined( TypeSafeQS )

/////////////////////////////////////////////////////////////////////////////
//  Global Functions from FormatErrorMessage.cpp
/////////////////////////////////////////////////////////////////////////////

HRESULT
WINAPI
HrFormatErrorMessage(
    LPWSTR  pszErrorOut,
    UINT    nMxErrorIn,
    DWORD   scIn
    );

HRESULT
__cdecl
HrFormatErrorMessageBoxText(
    LPWSTR  pszMessageOut,
    UINT    nMxMessageIn,
    HRESULT hrIn,
    LPCWSTR pszOperationIn,
    ...
    );

HRESULT
WINAPI
HrGetComputerName(
    COMPUTER_NAME_FORMAT    cnfIn,
    BSTR *                  pbstrComputerNameOut
    );

/////////////////////////////////////////////////////////////////////////////
//  Global Functions from DirectoryUtils.cpp
/////////////////////////////////////////////////////////////////////////////

HRESULT
HrCreateDirectoryPath( LPWSTR pszDirectoryPath );

DWORD
DwRemoveDirectory( const WCHAR * pcszTargetDirIn, signed int iMaxDepthIn = 32 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\citracker.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999 - 2000 Microsoft Corporation
//
//  Module Name:
//      CITracker.H
//
//  Description:
//      Implementation of a COM interface tracker.
//
//  [Documentation:]
//      Debugging.PPT - A power-point presentation of the debug utilities.
//
//  Maintained By:
//      Geoffrey Pease (gpease) 19-NOV-1999
//
//  Notes:
//      This is X86 specific for now. It can be adapted for other platforms
//      as required. Since today, most of our developement is done on the
//      X86 platform, there is not a need to do this (yet).
//
//      Define NO_TRACE_INTERFACES to disable interface tracking in DEBUG
//      builds.
//
//      Define TRACE_INTERFACES_ENABLED to enable interface tracking in RETAIL
//      builds.
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// Combine this complex expression in to one simple #define.
//
#if ( DBG==1 || defined( _DEBUG ) ) && !defined( NO_TRACE_INTERFACES )
#define TRACE_INTERFACES_ENABLED
#endif

#if defined( _X86_ ) && defined( TRACE_INTERFACES_ENABLED )
#define FULL_TRACE_INTERFACES_ENABLED
#endif

#if defined( TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN DEBUG INTERFACE TRACKING
//

#pragma message("BUILD: Interface Tracking Enabled")

//
// DLL Interface Table Macros
//
#define BEGIN_INTERFACETABLE const INTERFACE_TABLE g_itTable = {
#define DEFINE_INTERFACE( _iid, _name, _count ) { &_iid, TEXT(_name), _count },
#define END_INTERFACETABLE { NULL, NULL, NULL } };

///////////////////////////////////////
//
// TraceInterface definitions
//
typedef struct {
    const struct _GUID *    riid;
    LPCTSTR                 pszName;
    ULONG                   cFunctions;
} INTERFACE_TABLE[], INTERFACE_TABLE_ENTRY, * LPINTERFACE_TABLE_ENTRY;

//
// Interface Table
//
// This table is used in builds in which interface tracking was turned on. It
// is used to map an name with a particular IID. It also helps the CITracker
// determine the size of the interfaces Vtable to mimic (haven't figured out
// a runtime or compile time way to do this).
//
extern const INTERFACE_TABLE g_itTable;

///////////////////////////////////////
//
// IID --> Name lookup stuff
//
#if defined( DEBUG )
static const cchGUID_STRING_SIZE = sizeof("{12345678-1234-1234-1234-123456789012}");

#define PszTraceFindInterface( _riid, _szguid ) \
    ( g_tfModule ? PszDebugFindInterface( _riid, _szguid ) : TEXT("riid") )

LPCTSTR
PszDebugFindInterface(
    REFIID      riidIn,
    LPTSTR      pszGuidBufOut
    );
#endif // DEBUG

//
// END DEBUG INTERFACE TRACKING
//
///////////////////////////////////////
#else // !TRACE_INTERFACES_ENABLED
///////////////////////////////////////
//
// BEGIN DEBUG WITHOUT INTERFACE TRACKING
//

#define BEGIN_INTERFACETABLE
#define DEFINE_INTERFACE( _iid, _name, _count )
#define END_INTERFACETABLE

//
// END DEBUG WITHOUT INTERFACE TRACKING
//
///////////////////////////////////////
#endif // TRACE_INTERFACES_ENABLED






#if defined( FULL_TRACE_INTERFACES_ENABLED )
///////////////////////////////////////
//
// BEGIN DEBUG INTERFACE TRACKING
//
#pragma message("BUILD: Full Interface Tracking Enabled")

//////////////////////////////////////////////////////////////////////////////
//
// MACRO
// _interface *
// TraceInterface(
//      _nameIn,
//      _interface,
//      _punkIn,
//      _addrefIn
//      )
//
// Description:
//      This is the macro wrapper for DebugTrackInterface( ) which is only
//      defined in DEBUG builds. Using the TraceInterface( ) macro eliminates
//      the need for specifying compile time parameters as well as the
//      #ifdef/#endif definitions around the call.
//
//      This "routine" creates a CITracker for the interface specified by
//      _interface and returns a new punk to the interface. You specify the
//      initial ref count on the interface using the _addrefIn parameter. You
//      can assign a name to the object that the interface refereneces in the
//      _nameIn parameter. The returned punk will be cast to the _interface
//      parameter.
//
//      If there is insufficent memory to create the CITracker, the _punkIn
//      will be returned instead. There is no need to check the output for
//      failures as they are all handle internally to provide worry-free use.
//
//      If you are getting an AV after adding tracing to the interface, this
//      usually indicates that the Interface Table entry for that interface
//      is incorrect. Double check the number of methods on the interface
//      against the tables.
//
// Arguments:
//      _nameIn     - Name of the object this interface references (string).
//      _interface  - Name of the interface (typedef).
//      _punkIn     - Pointer to interface to track
//      _addrefIn   - Initial reference count on the interface.
//
// Return Values:
//      a VALID _interface pointer
//          Points to the CITracker that can be used as if it were the
//          orginal _punkIn. If there was insufficent memory, the orginal
//          _punkIn will be returned.
//
//  NOTES:
//      _addrefIn should be 0 if your going to be giving out the interface
//      from your QueryInterface routine if you AddRef( ) before giving it
//      out (typical QueryInterface( ) routines do this ).
//
//////////////////////////////////////////////////////////////////////////////
#define  TraceInterface( _nameIn, _interface, _punkIn, _addrefIn ) \
    reinterpret_cast<_interface*>( \
        DebugTrackInterface( TEXT(__FILE__), \
                             __LINE__, \
                             __MODULE__, \
                             _nameIn, \
                             IID_##_interface, \
                             static_cast<_interface*>( _punkIn), \
                             _addrefIn \
                             ) )

///////////////////////////////////////
//
// CITracker Structures
//
typedef HRESULT (CALLBACK *LPFNQUERYINTERFACE)(
    LPUNKNOWN punk,
    REFIID    riid,
    LPVOID*   ppv );

typedef ULONG (CALLBACK *LPFNADDREF)(
    LPUNKNOWN punk );

typedef ULONG (CALLBACK *LPFNRELEASE)(
    LPUNKNOWN punk );

typedef struct __vtbl {
    LPFNQUERYINTERFACE lpfnQueryInterface;
    LPFNADDREF         lpfnAddRef;
    LPFNRELEASE        lpfnRelease;
} VTBL, *LPVTBL;

typedef struct __vtbl2 {
    ULONG              cRef;
    LPUNKNOWN          punk;
    LPCTSTR            pszInterface;
    DWORD              dwSize;
    LPVTBL             pNewVtbl;
    // These must be last and in this order: QI, AddRef, Release.
    LPFNQUERYINTERFACE lpfnQueryInterface;
    LPFNADDREF         lpfnAddRef;
    LPFNRELEASE        lpfnRelease;
    // additional vtbl entries hang off the end
} VTBL2, *LPVTBL2;

#define VTBL2OFFSET ( sizeof( VTBL2 ) - ( 3 * sizeof(LPVOID) ) )

///////////////////////////////////////
//
// CITracker Functions
//
LPUNKNOWN
DebugTrackInterface(
    LPCTSTR   pszFileIn,
    const int nLineIn,
    LPCTSTR   pszModuleIn,
    LPCTSTR   pszNameIn,
    REFIID    riidIn,
    LPUNKNOWN pvtblIn,
    LONG      cRefIn
    );

///////////////////////////////////////
//
// interface IUnknownTracker
//
//
class
IUnknownTracker :
    public IUnknown
{
public:
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)( void );
    STDMETHOD_(ULONG, Release)( void );
    STDMETHOD_(void, Stub3 )( void );
    STDMETHOD_(void, Stub4 )( void );
    STDMETHOD_(void, Stub5 )( void );
    STDMETHOD_(void, Stub6 )( void );
    STDMETHOD_(void, Stub7 )( void );
    STDMETHOD_(void, Stub8 )( void );
    STDMETHOD_(void, Stub9 )( void );
    STDMETHOD_(void, Stub10 )( void );
    STDMETHOD_(void, Stub11 )( void );
    STDMETHOD_(void, Stub12 )( void );
    STDMETHOD_(void, Stub13 )( void );
    STDMETHOD_(void, Stub14 )( void );
    STDMETHOD_(void, Stub15 )( void );
    STDMETHOD_(void, Stub16 )( void );
    STDMETHOD_(void, Stub17 )( void );
    STDMETHOD_(void, Stub18 )( void );
    STDMETHOD_(void, Stub19 )( void );
    STDMETHOD_(void, Stub20 )( void );
    STDMETHOD_(void, Stub21 )( void );
    STDMETHOD_(void, Stub22 )( void );
    STDMETHOD_(void, Stub23 )( void );
    STDMETHOD_(void, Stub24 )( void );
    STDMETHOD_(void, Stub25 )( void );
    STDMETHOD_(void, Stub26 )( void );
    STDMETHOD_(void, Stub27 )( void );
    STDMETHOD_(void, Stub28 )( void );
    STDMETHOD_(void, Stub29 )( void );
    STDMETHOD_(void, Stub30 )( void );

}; //*** interface IUnknownTracker

///////////////////////////////////////
//
// interface IDeadObjTracker
//
class
IDeadObjTracker
{
private: // Members
    VTBL2 m_vtbl;

public:
    STDMETHOD( Stub0 )( LPVOID* punk );
    STDMETHOD( Stub1 )( LPVOID* punk );
    STDMETHOD( Stub2 )( LPVOID* punk );
    STDMETHOD( Stub3 )( LPVOID* punk );
    STDMETHOD( Stub4 )( LPVOID* punk );
    STDMETHOD( Stub5 )( LPVOID* punk );
    STDMETHOD( Stub6 )( LPVOID* punk );
    STDMETHOD( Stub7 )( LPVOID* punk );
    STDMETHOD( Stub8 )( LPVOID* punk );
    STDMETHOD( Stub9 )( LPVOID* punk );
    STDMETHOD( Stub10 )( LPVOID* punk );
    STDMETHOD( Stub11 )( LPVOID* punk );
    STDMETHOD( Stub12 )( LPVOID* punk );
    STDMETHOD( Stub13 )( LPVOID* punk );
    STDMETHOD( Stub14 )( LPVOID* punk );
    STDMETHOD( Stub15 )( LPVOID* punk );
    STDMETHOD( Stub16 )( LPVOID* punk );
    STDMETHOD( Stub17 )( LPVOID* punk );
    STDMETHOD( Stub18 )( LPVOID* punk );
    STDMETHOD( Stub19 )( LPVOID* punk );
    STDMETHOD( Stub20 )( LPVOID* punk );
    STDMETHOD( Stub21 )( LPVOID* punk );
    STDMETHOD( Stub22 )( LPVOID* punk );
    STDMETHOD( Stub23 )( LPVOID* punk );
    STDMETHOD( Stub24 )( LPVOID* punk );
    STDMETHOD( Stub25 )( LPVOID* punk );
    STDMETHOD( Stub26 )( LPVOID* punk );
    STDMETHOD( Stub27 )( LPVOID* punk );
    STDMETHOD( Stub28 )( LPVOID* punk );
    STDMETHOD( Stub29 )( LPVOID* punk );
    STDMETHOD( Stub30 )( LPVOID* punk );

}; //*** interface IDeadObject


///////////////////////////////////////
//
// CITracker Class
//
class
CITracker:
    public IUnknownTracker
{
private: // Members
    VTBL2 m_vtbl;

private: // Methods
    CITracker( );
    ~CITracker( );
    STDMETHOD(Init)( LPUNKNOWN * ppunkOut,
                     LPUNKNOWN punkIn,
                     const INTERFACE_TABLE_ENTRY * piteIn,
                     LPCTSTR pszNameIn,
                     LONG cRefIn
                     );

public: // Methods
    friend LPUNKNOWN DebugTrackInterface( LPCTSTR    pszFileIn,
                                          const int  nLineIn,
                                          LPCTSTR    pszModuleIn,
                                          LPCTSTR    pszNameIn,
                                          REFIID     riidIn,
                                          LPUNKNOWN  pvtblIn,
                                          LONG      cRefIn
                                          );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

}; //*** class CITracker

//
// END DEBUG WITH FULL INTERFACE TRACKING
//
///////////////////////////////////////
#else // !FULL_TRACE_INTERFACES_ENABLED
///////////////////////////////////////
//
// BEGIN DEBUG WITHOUT FULL INTERFACE TRACKING
//

#ifdef _X86_
#define  TraceInterface( _nameIn, _interface, _punkIn, _faddrefIn ) static_cast<##_interface *>( _punkIn )
#else
#define  TraceInterface( _nameIn, _interface, _punkIn, _faddrefIn ) static_cast<##_interface *>( _punkIn )
#endif

//
// END DEBUG WITHOUT FULL INTERFACE TRACKING
//
///////////////////////////////////////
#endif // FULL_TRACE_INTERFACES_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\dll.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Dll.h
//
//  Description:
//      DLL globals definitions and macros.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// DLL Globals
//
extern HINSTANCE g_hInstance;
extern LONG      g_cObjects;
extern LONG      g_cLock;
extern TCHAR     g_szDllFilename[ MAX_PATH ];

extern LPVOID    g_GlobalMemoryList;            // Global memory tracking list

//
// Class Table Macros
//
#define BEGIN_CLASSTABLE const CLASSTABLE g_DllClasses = {
#define DEFINE_CLASS( _pfn, _riid, _name, _model ) { _pfn, &_riid, TEXT(_name), TEXT(_model), NULL, &IID_NULL, NULL },
#define DEFINE_CLASS_CATIDREG( _pfn, _riid, _name, _model, _pfnCat ) { _pfn, &_riid, TEXT(_name), TEXT(_model), _pfnCat, &IID_NULL, NULL },
#define DEFINE_CLASS_WITH_APPID( _pfn, _riid, _name, _model, _appid, _surrogate ) { _pfn, &_riid, TEXT(_name), TEXT(_model), NULL, &_appid, TEXT(_surrogate) },
#define END_CLASSTABLE  { NULL } };

extern const CLASSTABLE  g_DllClasses;

//
// Category ID (CATID) Macros
//
#define BEGIN_CATIDTABLE const CATIDTABLE g_DllCatIds = {
#define DEFINE_CATID( _rcatid, _name ) { &_rcatid, TEXT(_name) },
#define END_CATIDTABLE { NULL } };

extern const CATIDTABLE g_DllCatIds;

//
// DLL Global Function Prototypes
//
HRESULT
HrCoCreateInternalInstance(
    REFCLSID rclsidIn,
    LPUNKNOWN pUnkOuterIn,
    DWORD dwClsContextIn,
    REFIID riidIn,
    LPVOID * ppvOut
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\interfacetablesrc.cpp ===
#include "pch.h"
#include <comdef.h>

//
// Interface Table
//
// This table is used in builds in which interface tracking was turned on. It
// is used to map a name with a particular IID. It also helps the CITracker
// determine the size of the interfaces Vtable to mimic (haven't figured out
// a runtime or compile time way to do this). To improve speed, put the most
// used interfaces first such as IUnknown (the search routine is a simple
// linear search).
//
// Format: IID, Name, Number of methods

BEGIN_INTERFACETABLE
    // most used interfaces
DEFINE_INTERFACE( IID_IUnknown,                             "IUnknown",                             0   )   // unknwn.idl
    // internally used interfaces
DEFINE_INTERFACE( IID_IServiceProvider,                     "IServiceProvider",                     1   )   // serprov.idl
DEFINE_INTERFACE( IID_INotificationManager,                 "INotificationManager",                 1   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IObjectManager,                       "IObjectManager",                       4   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IExtendObjectManager,                 "IExtendObjectManager",                 1   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_ITaskManager,                         "ITaskManager",                         2   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ILogManager,                          "ILogManager",                          2   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IDoTask,                              "IDoTask",                              2   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IConnectionManager,                   "IConnectionManager",                   1   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IConnectionPoint,                     "IConnectionPoint",                     5   )   // objidl.idl
DEFINE_INTERFACE( IID_IConnectionPointContainer,            "IConnectionPointContainer",            2   )   // objidl.idl
DEFINE_INTERFACE( IID_IConnectionInfo,                      "IConnectionInfo",                      3   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IStandardInfo,                        "IStandardInfo",                        6   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IGatherData,                          "IGatherData",                          1   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskGatherNodeInfo,                  "ITaskGatherNodeInfo",                  4   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IConfigurationConnection,             "IConfigurationConnection",             2   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IEnumNodes,                           "IEnumNodes",                           5   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_INotifyUI,                            "INotifyUI",                            1   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskAnalyzeCluster,                  "ITaskAnalyzeCluster",                  5   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskCommitClusterChanges,            "ITaskCommitClusterChanges",            5   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskCompareAndPushInformation,       "ITaskCompareAndPushInformation",       4   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskGatherInformation,               "ITaskGatherInformation",               5   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IClusCfgWbemServices,                 "IClusCfgWbemServices",                 1   )   // Guids.h
DEFINE_INTERFACE( IID_IEnumClusCfgPartitions,               "IEnumClusCfgPartitions",               5   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgPartitionInfo,                "IClusCfgPartitionInfo",                8   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgSetWbemObject,                "IClusCfgSetWbemObject",                1   )   // Guids.h
DEFINE_INTERFACE( IID_IClusCfgIPAddressInfo,                "IClusCfgIPAddressInfo",                5   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgSetClusterNodeInfo,           "IClusCfgSetClusterNodeInfo",           1   )   // Guids.h
DEFINE_INTERFACE( IID_ITaskGatherClusterInfo,               "ITaskGatherClusterInfo",               4   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IClusCfgSetClusterHandles,            "IClusCfgSetClusterHandles",            2   )   // Guids.h
DEFINE_INTERFACE( IID_ITaskGetDomains,                      "ITaskGetDomains",                      4   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IDispatch,                            "IDispatch",                            4   )   // oaidl.idl
DEFINE_INTERFACE( IID_IClusCfgWizard,                       "IClusCfgWizard",                       23  )   // ClusCfgWizard.idl -- 19 + IDispatch
DEFINE_INTERFACE( IID_IClusCfgPhysicalDiskProperties,       "IClusCfgPhysicalDiskProperties",       7   )   // Guids.h
DEFINE_INTERFACE( IID_IClusCfgPartitionProperties,          "IClusCfgPartitionProperties",          3   )   // Guids.h
DEFINE_INTERFACE( IID_IClusCfgSetCredentials,               "IClusCfgSetCredentials",               1   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_IClusCfgLoadResource,                 "IClusCfgLoadResource",                 1   )   // Guids.h
DEFINE_INTERFACE( IID_IClusCfgSetPollingCallback,           "IClusCfgSetPollingCallback",           1   )   // Guids.h
DEFINE_INTERFACE( IID_IEnumCookies,                         "IEnumCookies",                         5   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskLoginDomain,                     "ITaskLoginDomain",                     4   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskLoginDomainCallback,             "ITaskLoginDomainCallback",             1   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskGetDomains,                      "ITaskGetDomains",                      3   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskGetDomainsCallback,              "ITaskGetDomainsCallback",              2   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IPrivatePostCfgResource,              "IPrivatePostCfgResource",              1   )   // Guids.h
DEFINE_INTERFACE( IID_IPostCfgManager,                      "IPostCfgManager",                      1   )   // Guids.h
DEFINE_INTERFACE( IID_ITaskPollingCallback,                 "ITaskPollingCallback",                 3   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_ITaskVerifyIPAddress,                 "ITaskVerifyIPAddress",                 4   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IClusCfgEvictCleanup,                 "IClusCfgEvictCleanup",                 2   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_AsyncIClusCfgEvictCleanup,            "AsyncIClusCfgEvictCleanup",            2   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgAsyncEvictCleanup,            "IClusCfgAsyncEvictCleanup",            1   )   // ClusCfgClient.idl
DEFINE_INTERFACE( IID_IClusCfgStartupListener,              "IClusCfgStartupListener",              1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_AsyncIClusCfgStartupListener,         "AsyncIClusCfgStartupListener",         1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgStartupNotify,                "IClusCfgStartupNotify",                1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_AsyncIClusCfgStartupNotify,           "AsyncIClusCfgStartupNotify",           1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgResTypeServicesInitialize,    "IClusCfgResTypeServicesInitialize",    1   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_IClusCfgClusterNetworkInfo,           "IClusCfgClusterNetworkInfo",           1   )   // Guids.h

    // mixed use interfaces
DEFINE_INTERFACE( IID_IClusCfgServer,                       "IClusCfgServer",                       6   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgNodeInfo,                     "IClusCfgNodeInfo",                     8   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IEnumClusCfgManagedResources,         "IEnumClusCfgManagedResources",         5   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgManagedResourceInfo,          "IClusCfgManagedResourceInfo",          13  )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IEnumClusCfgNetworks,                 "IEnumClusCfgNetworks",                 5   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgNetworkInfo,                  "IClusCfgNetworkInfo",                  12  )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgCallback,                     "IClusCfgCallback",                     1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgInitialize,                   "IClusCfgInitialize",                   1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgClusterInfo,                  "IClusCfgClusterInfo",                  17  )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgBaseCluster,                  "IClusCfgBaseCluster",                  5   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IEnumClusCfgIPAddresses,              "IEnumClusCfgIPAddresses",              5   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgCredentials,                  "IClusCfgCredentials",                  2   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgManagedResourceCfg,           "IClusCfgManagedResourceCfg",           4   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgResourcePreCreate,            "IClusCfgResourcePreCreate",            3   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgResourceCreate,               "IClusCfgResourceCreate",               11  )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgResourcePostCreate,           "IClusCfgResourcePostCreate",           1   )   // ClusCfgServer.idl
// DEFINE_INTERFACE( IID_IClusCfgResourceEvict,                "IClusCfgResourceEvict",                1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgResourceTypeInfo,             "IClusCfgResourceTypeInfo",             3   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgResourceTypeCreate,           "IClusCfgResourceTypeCreate",           2   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgMemberSetChangeListener,      "IClusCfgMemberSetChangeListener",      1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgPollingCallback,              "IClusCfgPollingCallback",              2   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_IClusCfgPollingCallbackInfo,          "IClusCfgPollingCallbackInfo",          2   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_IClusCfgCapabilities,                 "IClusCfgCapabilities",                 1   )   // ClusCfgServer.idl
DEFINE_INTERFACE( IID_IClusCfgVerify,                       "IClusCfgVerify",                       3   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_IClusCfgClusterConnection,            "IClusCfgClusterConnection",            1   )   // ClusCfgPrivate.idl
DEFINE_INTERFACE( IID_ILogger,                              "ILogger",                              1   )   // ClusCfgClient.idl

    // rarely used interfaces
DEFINE_INTERFACE( IID_IClassFactory,                        "IClassFactory",                        2   )   // unknwn.idl
DEFINE_INTERFACE( IID_ICallFactory,                         "ICallFactory",                         2   )   // objidl.idl
DEFINE_INTERFACE( IID_IPersist,                             "IPersist",                             1   )   // objidl.idl
DEFINE_INTERFACE( IID_IPersistStream,                       "IPersistStream",                       5   )   // objidl.idl -- 4 + IPersist
DEFINE_INTERFACE( IID_IPersistStreamInit,                   "IPersistStreamInit",                   6   )   // ocidl.idl -- 5 + IPersist
DEFINE_INTERFACE( IID_IPersistStorage,                      "IPersistStorage",                      7   )   // objidl.idl -- 6 + IPersist
DEFINE_INTERFACE( IID_ISequentialStream,                    "ISequentialStream",                    4   )   // objidl.idl
DEFINE_INTERFACE( IID_IStream,                              "IStream",                              15  )   // objidl.idl -- 11 + ISequentialStream
DEFINE_INTERFACE( IID_IMarshal,                             "IMarshal",                             6   )   // objidl.idl
DEFINE_INTERFACE( IID_IStdMarshalInfo,                      "IStdMarshalInfo",                      1   )   // objidl.idl
DEFINE_INTERFACE( IID_IExternalConnection,                  "IExternalConnection",                  2   )   // objidl.idl
DEFINE_INTERFACE( __uuidof( IdentityUnmarshal ),            "IdentityUnmarshal",                    0   )   // comdef.h (CoClass - no known methods)

// New interfaces.
DEFINE_INTERFACE( IID_IClusCfgSetHandle,                    "IClusCfgSetHandle",                    1   )   // Guids.h
DEFINE_INTERFACE( IID_IClusterHandleProvider,               "IClusterHandleProvider",               2   )   // Guids.h

END_INTERFACETABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\debug.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      Debug.h
//
//  Description:
//      Debugging utilities header.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// KB: USES_SYSALLOCSTRING gpease 8-NOV-1999
//      Turn this on if you are going to use the OLE automation
//      functions: SysAllocString, SysFreeString, etc..
//
// #define USES_SYSALLOCSTRING

//
// Trace Flags
//
typedef enum _TRACEFLAGS
{
    mtfALWAYS           = 0xFFFFFFFF,
    mtfNEVER            = 0x00000000,
    // function entry/exits, call, scoping
    mtfASSERT_HR        = 0x00000001,   // Halt if HRESULT is an error
    mtfQUERYINTERFACE   = 0x00000002,   // Query Interface details and halt on error
    // Asserts
    mtfSHOWASSERTS      = 0x00000004,   // Show assert message box
    //                  = 0x00000008,
    // other
    mtfCALLS            = 0x00000010,   // Function calls that use the TraceMsgDo macro
    mtfFUNC             = 0x00000020,   // Functions entrances w/parameters
    mtfSTACKSCOPE       = 0x00000040,   // if set, debug spew will generate bar/space for level each of the call stack
    mtfPERTHREADTRACE   = 0x00000080,   // Enables per thread tracing, excludes memory tracking.
    // specific
    mtfDLL              = 0x00000100,   // DLL specific
    mtfWM               = 0x00000200,   // Window Messages
    mtfFLOW             = 0x00000400,   // Control flow
    //                  = 0x00000800
    // citracker spew
    mtfCITRACKERS       = 0x00001000,   // CITrackers will spew entrances and exits
    //                  = 0x00002000,
    //                  = 0x00004000,
    //                  = 0x00008000,
    //                  = 0x00010000,
    //                  = 0x00020000,
    //                  = 0x00040000,
    //                  = 0x00080000,
    //                  = 0x00100000,
    //                  = 0x00200000,
    //                  = 0x00400000,
    //                  = 0x00800000,
    // memory
    mtfMEMORYLEAKS      = 0x01000000,   // Halts when a memory leak is detected on thread exit
    mtfMEMORYINIT       = 0x02000000,   // Initializes new memory allocations to non-zero value
    mtfMEMORYALLOCS     = 0x04000000,   // Turns on spew to display each de/allocation.
    //                  = 0x08000000,
    // output prefixes
    mtfADDTIMEDATE      = 0x10000000,   // Replaces Filepath(Line) with Date/Time
    mtfBYMODULENAME     = 0x20000000,   // Puts the module name at the beginning of the line
    //                  = 0x40000000,
    mtfOUTPUTTODISK     = 0x80000000,   // Writes output to disk
} TRACEFLAGS;

typedef DWORD TRACEFLAG;

#define ASZ_NEWLINE         "\r\n"
#define SZ_NEWLINE          TEXT( ASZ_NEWLINE )
#define SIZEOF_ASZ_NEWLINE  ( sizeof( ASZ_NEWLINE ) - sizeof( CHAR ) )
#define SIZEOF_SZ_NEWLINE   ( sizeof( SZ_NEWLINE ) - sizeof( TCHAR ) )
#define FREE_ADDRESS        0xFA
#define FREE_BLOCK          0xFB
#define AVAILABLE_ADDRESS   0xAA

#ifdef DEBUG

#pragma message( "BUILD: DEBUG macros being built" )

//
// Globals
//
extern DWORD         g_TraceMemoryIndex;    // TLS index for the memory tracking link list
extern DWORD         g_dwCounter;           // Stack depth counter
extern TRACEFLAG     g_tfModule;            // Global tracing flags
extern const LPCTSTR g_pszModuleIn;         // Local module name - use DEFINE_MODULE
extern const TCHAR   g_szTrue[];            // Array "TRUE"
extern const TCHAR   g_szFalse[];           // Array "FALSE"

//
// Definition Macros
//
#define DEFINE_MODULE( _module )    const LPCTSTR g_pszModuleIn = TEXT(_module);
#define __MODULE__                  g_pszModuleIn
#define DEFINE_THISCLASS( _class )  static const TCHAR g_szClass[] = TEXT(_class);
#define __THISCLASS__               g_szClass

//
// ImageHlp Stuff - not ready for prime time yet.
//
#if defined( IMAGEHLP_ENABLED )
#include <imagehlp.h>
typedef BOOL ( * PFNSYMGETSYMFROMADDR )( HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL );
typedef BOOL ( * PFNSYMGETLINEFROMADDR )( HANDLE, DWORD, PDWORD, PIMAGEHLP_LINE );
typedef BOOL ( * PFNSYMGETMODULEINFO )( HANDLE, DWORD, PIMAGEHLP_MODULE );

extern HINSTANCE                g_hImageHlp;                // IMAGEHLP.DLL instance handle
extern PFNSYMGETSYMFROMADDR     g_pfnSymGetSymFromAddr;
extern PFNSYMGETLINEFROMADDR    g_pfnSymGetLineFromAddr;
extern PFNSYMGETMODULEINFO      g_pfnSymGetModuleInfo;
#endif // IMAGEHLP_ENABLED

void
DebugIncrementStackDepthCounter( void );

void
DebugDecrementStackDepthCounter( void );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceInitializeProcess(
//      _rgControl
//      _sizeofControl
//      _fGlobalMemoryTackingIn
//      )
//
//  Description:
//      Should be called in the DLL main on process attach or in the entry
//      routine of an EXE. Initializes debugging globals and TLS. Registers
//      the WMI tracing facilities (if WMI support is enabled).
//
//  Arguments:
//      _rgControl      WMI control block (see DEBUG_WMI_CONTROL_GUIDS)
//      _sizeofControl  The sizeof( _rgControl )
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#if defined( DEBUG_SW_TRACING_ENABLED )
#define TraceInitializeProcess( _rgControl, _sizeofControl, _fGlobalMemoryTackingIn ) \
    do \
    { \
        DebugInitializeTraceFlags( _fGlobalMemoryTackingIn ); \
        WMIInitializeTracing( _rgControl, _sizeofControl ); \
    } while ( 0 )
#else // ! DEBUG_SW_TRACING_ENABLED
#define TraceInitializeProcess( _fGlobalMemoryTackingIn ) \
    do \
    { \
        DebugInitializeTraceFlags( _fGlobalMemoryTackingIn ); \
} while ( 0 )
#endif // DEBUG_SW_TRACING_ENABLED

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceInitializeThread(
//      _name
//      )
//
//  Description:
//      Should be called in the DLL thread attach or when a new thread is
//      created. Sets up the memory tracing for that thread as well as
//      establishing the tfThread for each thread (if mtfPERTHREADTRACE
//      is set in g_tfModule).
//
//  Arguments:
//      _name       NULL or the name of the thread.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceInitializeThread( _name ) \
    do \
    { \
        TlsSetValue( g_TraceMemoryIndex, NULL ); \
        DebugInitializeThreadTraceFlags( _name ); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceThreadRundown( void )
//
//  Description:
//      Should be called before a thread terminates. It will check to make
//      sure all memory allocated by the thread was released properly. It
//      will also cleanup any per thread structures.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceThreadRundown() \
    do \
    { \
        DebugMemoryCheck( NULL, NULL ); \
        DebugThreadRundownTraceFlags(); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceCreateMemoryList(
//      _pmbIn
//      )
//
//  Description:
//      Creates a thread-independent list to track objects.
//
//      _pmbIn should be an LPVOID.
//
//  Arguments:
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceCreateMemoryList( _pmbIn ) \
    DebugCreateMemoryList( TEXT(__FILE__), __LINE__, __MODULE__, &_pmbIn, TEXT(#_pmbIn) );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceTerminateMemoryList(
//      _pmbIn
//      )
//
//  Description:
//      Checks to make sure the list is empty before destroying the list.
//
//      _pmbIn should be an LPVOID.
//
//  Arguments:
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
// BUGBUG:  DavidP 09-DEC-1999
//          _pmbIn is evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceTerminateMemoryList( _pmbIn ) \
    do \
    { \
        DebugMemoryCheck( _pmbIn, TEXT(#_pmbIn) ); \
        HeapFree( GetProcessHeap(), 0, _pmbIn ); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMoveToMemoryList(
//      _addr
//      _pmbIn
//      )
//
//  Description:
//      Moves an object from the thread tracking list to a thread independent
//      memory list (_pmbIn).
//
//      _pmbIn should be castable to an LPVOID.
//
//  Arguments:
//      _addr  - Address of object to move.
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
//#define TraceMoveToMemoryList( _addr, _pmbIn ) \
//    DebugMoveToMemoryList( TEXT(__FILE__), __LINE__, __MODULE__, _addr, _pmbIn, TEXT(#_pmbIn) );
#define TraceMoveToMemoryList( _addr, _pmbIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMoveFromMemoryList(
//      _addr
//      _pmbIn
//      )
//
//  Description:
//      Moves an object from a thread independent memory list (_pmbIn) to the
//      per thread tracking list.
//
//      _pmbIn should be castable to an LPVOID.
//
//  Arguments:
//      _addr  - Address of object to move.
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
//#define TraceMoveFromMemoryList( _addr, _pmbIn ) \
//    DebugMoveFromMemoryList( TEXT(__FILE__), __LINE__, __MODULE__, _addr, _pmbIn, TEXT(#_pmbIn) );
#define TraceMoveFromMemoryList( _addr, _pmbIn )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMemoryListDelete(
//      _addr
//      _pmbIn
//      )
//
//  Description:
//      Moves and object from the thread tracking list to a thread independent
//      memory list (_pmbIn).
//
//      _pmbIn should be an LPVOID.
//
//  Arguments:
//      _addr  - Address of object to delete.
//      _pmbIn - Pointer to store the head of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
//#define TraceMemoryListDelete( _addr, _pmbIn, _fClobberIn ) \
//    DebugMemoryListDelete( TEXT(__FILE__), __LINE__, __MODULE__, _addr, _pmbIn, TEXT(#_pmbIn), _fClobberIn );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceTerminateProcess
//
//  Description:
//      Should be called before a process terminates. It cleans up anything
//      that the Debug APIs created. It will check to make sure all memory
//      allocated by the main thread was released properly. It will also
//      terminate WMI tracing (if WMI support is enabled). It also closes
//      the logging handle.
//
//  Arguments:
//      _rgControl     - WMI control block (see DEBUG_WMI_CONTROL_GUIDS)
//      _sizeofControl - the sizeof( _rgControl )
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#if defined( DEBUG_SW_TRACING_ENABLED )
#define TraceTerminateProcess( _rgControl, _sizeofControl ) \
    do \
    { \
        LogTerminateProcess(); \
        WMITerminateTracing( _rgControl, _sizeofControl ); \
        DebugMemoryCheck( NULL, NULL ); \
        DebugTerminateProcess(); \
    } while ( 0 )
#else // ! DEBUG_SW_TRACING_ENABLED
//
//  TODO:   11 DEC 2000 GalenB
//
//  LogTerminateProcess() needs to be available for retail builds.
//  Since it doesn't yet do anything this isn't a problem, but that
//  of course can change...
//
#define TraceTerminateProcess() \
    do \
    { \
        LogTerminateProcess(); \
        DebugMemoryCheck( NULL, NULL ); \
        DebugTerminateProcess(); \
    } while ( 0 )
#endif // DEBUG_SW_TRACING_ENABLED

//****************************************************************************
//
// Debug initialization routines
//
// Uses should use the TraceInitializeXXX and TraceTerminateXXX macros, not
// these routines.
//
//****************************************************************************
void
DebugInitializeTraceFlags( BOOL fGlobalMemoryTackingIn = TRUE );

void
DebugInitializeThreadTraceFlags(
    LPCTSTR pszThreadNameIn
    );

void
DebugTerminateProcess( void );

void
DebugThreadRundownTraceFlags( void );

void
DebugCreateMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPVOID *    ppvListOut,
    LPCTSTR     pszListNameIn
    );

void
DebugMemoryListDelete(
    LPCTSTR pszFileIn,
    const int nLineIn,
    LPCTSTR pszModuleIn,
    void *  pvMemIn,
    LPVOID  pvListIn,
    LPCTSTR pszListNameIn,
    BOOL    fClobberIn
    );

void
DebugMoveToMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    void *      pvMemIn,
    LPVOID      pmbListIn,
    LPCTSTR     pszListNameIn
    );

void
DebugMoveFromMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    HGLOBAL     hGlobal,
    LPVOID      pmbListIn,
    LPCTSTR     pszListNameIn
    );

//****************************************************************************
//
// Memmory Allocation Subsitution Macros
//
// Replaces LocalAlloc/LocalFree, GlobalAlloc/GlobalFree, and malloc/free
//
//****************************************************************************
#define TraceAlloc( _flags, _size )             DebugAlloc( TEXT(__FILE__), __LINE__, __MODULE__, _flags, _size, TEXT(#_size) )
#define TraceReAlloc( _pvmem, _size, _flags )   DebugReAlloc( TEXT(__FILE__), __LINE__, __MODULE__, _pvmem, _flags, _size, TEXT(#_size) )
#define TraceFree( _hmem )                      DebugFree( _hmem, TEXT(__FILE__), __LINE__, __MODULE__ )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceAllocString(
//      _flags,
//      _size
//      )
//
//  Description:
//      Quick way to allocation a string that is the proper size and that will
//      be tracked by memory tracking.
//
//  Arguments:
//      _flags  - Allocation attributes.
//      _size   - Number of characters in the string to be allocated.
//
//  Return Values:
//      Handle/pointer to memory to be used as a string.
//
//////////////////////////////////////////////////////////////////////////////
#define TraceAllocString( _flags, _size ) \
    (LPTSTR) DebugAlloc( TEXT(__FILE__), \
                         __LINE__, \
                         __MODULE__, \
                         _flags, \
                         (_size) * sizeof( TCHAR ), \
                         TEXT(#_size) \
                         )

//****************************************************************************
//
// Code Tracing Macros
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceFunc(
//      _szArgs
//      )
//
//  Description:
//      Displays file, line number, module and "_szArgs" only if the mtfFUNC is
//      set in g_tfModule. "_szArgs" is the name of the function just
//      entered. It also increments the stack counter.
//
//  Arguments:
//      _szArgs     - Arguments for the function just entered.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceFunc( _szArgs ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )")  ); \
    }

//
// These next macros are just like TraceFunc except they take additional
// arguments to display the values passed into the function call. "_szArgs"
// should contain a printf string on how to display the arguments.
//
#define TraceFunc1( _szArgs, _arg1 ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1 ); \
    }

#define TraceFunc2( _szArgs, _arg1, _arg2 ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2 ); \
    }

#define TraceFunc3( _szArgs, _arg1, _arg2, _arg3 ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2, _arg3 ); \
    }

#define TraceFunc4( _szArgs, _arg1, _arg2, _arg3, _arg4 ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2, _arg3, _arg4 ); \
    }

#define TraceFunc5( _szArgs, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2, _arg3, _arg4, arg5 ); \
    }

#define TraceFunc6( _szArgs, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("+ ") TEXT(__FUNCTION__) TEXT("( ") TEXT(_szArgs) TEXT(" )"), _arg1, _arg2, _arg3, _arg4, arg5, arg6 ); \
    }


//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceQIFunc(
//      _szArgs,
//      riid,
//      ppv
//      )
//
//  Description:
//      Just like TraceFunc but customized for QueryInterface.  Specifically,
//      displays the name of the interface and the value of the return pointer.
//
//  Arguments:
//      _riid       - Interface ID.
//      _ppv        - Return pointer.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceQIFunc( _riid, _ppv ) \
    HRESULT __MissingTraceFunc; \
    if ( g_tfModule != 0 ) \
    { \
        TCHAR szGuid[ cchGUID_STRING_SIZE ]; \
        DebugIncrementStackDepthCounter(); \
        TraceMessage( TEXT(__FILE__), \
                      __LINE__, \
                      __MODULE__, \
                      mtfFUNC, \
                      TEXT("+ ") TEXT(__FUNCTION__) TEXT("( [IUnknown] %s, ppv = %#x )"), \
                      PszTraceFindInterface( _riid, szGuid ), \
                      _ppv \
                      ); \
    }


//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceFlow(
//      _pszFormat
//      )
//
//  Description:
//      This macro outputs a string that is indented to the current depth.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceFlow( _pszFormat ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat) ); \
        } \
    } while ( 0 )

//
// These next macros are just like TraceFunc except they take additional
// arguments to display the values passed into the function call. "_pszFormat"
// should contain a printf string on how to display the arguments.
//

#define TraceFlow1( _pszFormat, _arg1 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat), _arg1 ); \
        } \
    } while ( 0 )

#define TraceFlow2( _pszFormat, _arg1, _arg2 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat), _arg1, _arg2 ); \
        } \
    } while ( 0 )
#define TraceFlow3( _pszFormat, _arg1, _arg2, _arg3 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat), _arg1, _arg2, _arg3 ); \
        } \
    } while ( 0 )
#define TraceFlow4( _pszFormat, _arg1, _arg2, _arg3, _arg4 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat), _arg1, _arg2, _arg3, _arg4 ); \
        } \
    } while ( 0 )
#define TraceFlow5( _pszFormat, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat), _arg1, _arg2, _arg3, _arg4, _arg5 ); \
        } \
    } while ( 0 )

#define TraceFlow6( _pszFormat, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFLOW, TEXT("| ") TEXT(_pszFormat), _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
        } \
    } while ( 0 )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceFuncExit( void )
//
//  Description:
//      Return macro for TraceFunc() if the return type is void.  It also
//      decrements the stack counter.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceFuncExit() \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            DebugDecrementStackDepthCounter(); \
        } \
        return; \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  RETURN(
//      _rval
//      )
//
//  Description:
//      Return macro for TraceFunc(). The _rval will be returned as the
//      result of the function. It also decrements the stack counter.
//
//  Arguments:
//      _rval   - Result of the function.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define RETURN( _rval ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            DebugDecrementStackDepthCounter(); \
        } \
        return _rval; \
    } while ( 0 )


/*
    return ( ( g_tfModule != 0 ) \
                ? ( TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ) \
                    , DebugDecrementStackDepthCounter() \
                    , _rval ) \
                : _rval )
*/

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  FRETURN(
//      _rval
//      )
//
//  Description:
//      This is a fake version of the return macro for TraceFunc().
//      *** This doesn't return. *** It also decrements the stack counter.
//
//  Arguments:
//      _rval   - Result of the function.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define FRETURN( _rval ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            DebugDecrementStackDepthCounter(); \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  HRETURN(
//      _hr
//      )
//
//  Description:
//      Return macro for TraceFunc(). The _hr will be returned as the result
//      of the function. If the value is not S_OK, it will be displayed in
//      the debugger. It also decrements the stack counter.
//
//  Arguments:
//      _hr - Result of the function.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define HRETURN( _hr ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( _hr != S_OK ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V hr = 0x%08x (%s)"), _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            } \
            DebugDecrementStackDepthCounter(); \
        } \
        return _hr; \
    } while ( 0 )

//
// These next macros are just like HRETURN except they allow other
// exceptable values to be passed.back without causing extra spew.
//
#define HRETURN1( _hr, _arg1 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( ( _hr != S_OK ) && ( _hr != _arg1 ) ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V hr = 0x%08x (%s)"), _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            } \
            DebugDecrementStackDepthCounter(); \
        } \
        return _hr; \
    } while ( 0 )

#define HRETURN2( _hr, _arg1, _arg2 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( ( _hr != S_OK ) && ( _hr != _arg1 ) && ( _hr != _arg2 ) ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V hr = 0x%08x (%s)"), _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            } \
            DebugDecrementStackDepthCounter(); \
        } \
        return _hr; \
    } while ( 0 )

#define HRETURN3( _hr, _arg1, _arg2, _arg3 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( ( _hr != S_OK ) && ( _hr != _arg1 ) && ( _hr != _arg2 ) && ( _hr != _arg3 ) ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V hr = 0x%08x (%s)"), _hr ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            } \
            DebugDecrementStackDepthCounter(); \
        } \
        return _hr; \
    } while ( 0 )


//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceDo(
//      _szExp
//      )
//
//  Description:
//      Displays the file, line number, module and function call and return
//      from the function call (no return value displayed) for "_szExp" only
//      if the mtfCALLS is set in g_tfModule. Note return value is not
//      displayed. _szExp will be in RETAIL version of the product.
//
//  Arguments:
//      _szExp
//          The expression to be traced including assigment to the return
//          variable.
//
//  Return Values:
//      None. The return value should be defined within _szExp.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceDo( _szExp ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_szExp ) ); \
            _szExp; \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("V") ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _szExp; \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMsgDo(
//      _pszExp,
//      _pszReturnMsg
//      )
//
//  Description:
//      Displays the file, line number, module and function call and return
//      value which is formatted in "_pszReturnMsg" for "_pszExp" only if the
//      mtfCALLS is set in g_tfModule. _pszExp will be in the RETAIL version
//      of the product.
//
//  Arguments:
//      _pszExp
//          The expression to be traced including assigment to the return
//          variable.
//      _pszReturnMsg
//          A format string for displaying the return value.
//
//  Return Values:
//      None. The return value should be defined within _szExp.
//
//  Example:
//      TraceMsgDo( hr = HrDoSomething(), "0x%08.8x" );
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceMsgDo( _pszExp, _pszReturnMsg ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

//
// These next macros are just like TraceMsgDo except they take additional
// arguments to display the values passed into the function call. "_pszReturnMsg"
// should contain a printf format string describing how to display the
// arguments.
//
#define TraceMsgDo1( _pszExp, _pszReturnMsg, _arg1 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgDo2( _pszExp, _pszReturnMsg, _arg1, _arg2 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgDo3( _pszExp, _pszReturnMsg, _arg1, _arg2, _arg3 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgDo4( _pszExp, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgDo5( _pszExp, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4, _arg5 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgDo6( _pszExp, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMsgPreDo(
//      _pszExp,
//      _pszPreMsg
//      _pszReturnMsg,
//      )
//
//  Description:
//      Displays the file, line number, module and function call and return
//      value which is formatted in "_pszReturnMsg" for "_pszExp" only if the
//      mtfCALLS is set in g_tfModule. _pszExp will be in the RETAIL version
//      of the product.
//
//      Same as TraceMsgDo except it displays the formatted message before
//      executing the expression.  Arguments for TraceMsgPreDo1, etc. are
//      applied to both _pszPreMsg and _pszReturnMsg.  The first substitution
//      string in _pszReturnMsg is for the return value from the function.
//
//  Arguments:
//      _pszExp
//          The expression to be traced including assigment to the return
//          variable.
//      _pszPreMsg
//          A format string for displaying a message before the expression
//          is evaluated.
//      _pszReturnMsg
//          A format string for displaying the return value.
//
//  Return Values:
//      None. The return value should be defined within _szExp.
//
//  Example:
//      TraceMsgPreDo1( hr = HrDoSomething( bstrName ),
//                      "Name = '%ls'",
//                      "0x%08.8x, Name = '%ls'",
//                      bstrName
//                      );
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TraceMsgPreDo( _pszExp, _pszPreMsg, _pszReturnMsg ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg) ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

//
// These next macros are just like TraceMsgPreDo except they take additional
// arguments to display the values passed into the function call. "_pszPreMsg"
// should contain a printf format string describing how to display the
// arguments.
//
#define TraceMsgPreDo1( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg), _arg1 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgPreDo2( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg), _arg1, _arg2 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgPreDo3( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2, _arg3 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg), _arg1, _arg2, _arg3 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgPreDo4( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg), _arg1, _arg2, _arg3, _arg4 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgPreDo5( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4, _arg5 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg), _arg1, _arg2, _arg3, _arg4, _arg5 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4, _arg5 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

#define TraceMsgPreDo6( _pszExp, _pszPreMsg, _pszReturnMsg, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            DebugIncrementStackDepthCounter(); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("+ ") TEXT(#_pszExp) ); \
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT("| ") TEXT(_pszPreMsg), _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
            TraceMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, mtfCALLS, TEXT(_pszReturnMsg), TEXT(#_pszExp), _pszExp, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 ); \
            DebugDecrementStackDepthCounter(); \
        } \
        else \
        { \
            _pszExp; \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TraceMsgGUID(
//      _flags,
//      _msg
//      _guid
//      )
//
//  Description:
//      Dumps a GUID to the debugger only if one of the flags in _flags is
//      set in g_tfModule.
//
//  Arguments:
//      _flags   - Flags to check
//      _msg     - msg to print before GUID
//      _guid    - GUID to dump
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
// BUGBUG:  DavidP 09-DEC-1999
//          _guid is evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceMsgGUID( _flags, _msg, _guid ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            TraceMessage( TEXT(__FILE__), \
                          __LINE__, \
                          __MODULE__, \
                          _flags, \
                          TEXT("%s {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"), \
                          TEXT(_msg), \
                          _guid.Data1, _guid.Data2, _guid.Data3,  \
                          _guid.Data4[ 0 ], _guid.Data4[ 1 ], _guid.Data4[ 2 ], _guid.Data4[ 3 ], \
                          _guid.Data4[ 4 ], _guid.Data4[ 5 ], _guid.Data4[ 6 ], _guid.Data4[ 7 ] ); \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  ErrorMsg(
//      _szMsg,
//      _err
//      )
//
//  Description:
//      Print an error out. Can be used to write errors to a file. Note that
//      it will also print the source filename, line number and module name.
//
//  Arguments:
//      _szMsg  - Format string to be displayed.
//      _err    - Error code of the error.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define ErrorMsg( _szMsg, _err ) \
    TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfALWAYS, TEXT(__FUNCTION__) TEXT(": ") TEXT(_szMsg), _err );

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  WndMsg(
//      _hwnd,
//      _umsg,
//      _wparam,
//      _lparam
//      )
//
//  Description:
//      Prints out a message to trace windows messages.
//
//  Arguments:
//      _hwnd   - The HWND
//      _umsg   - The uMsg
//      _wparam - The WPARAM
//      _lparam _ The LPARAM
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
// BUGBUG:  DavidP 09-DEC-1999
//          _wparam and _lparam are evaluated multiple times but the name
//          of the macro is mixed case.
#define WndMsg( _hwnd, _umsg, _wparam, _lparam ) \
    do \
    { \
        if ( g_tfModule & mtfWM ) \
        { \
            DebugMsg( TEXT("%s: WM   : hWnd = 0x%08x, uMsg = %u, wParam = 0x%08x (%u), lParam = 0x%08x (%u)"), __MODULE__, _hwnd, _umsg, _wparam, _wparam, _lparam, _lparam ); \
        } \
    } while ( 0 )

//****************************************************************************
//
//  Debug Macros
//
//  These calls are only compiled in DEBUG. They are a NOP in RETAIL
//  (not even compiled in).
//
//****************************************************************************

//
// Same as TraceDo() but only compiled in DEBUG.
//
#define DebugDo( _fn ) \
    do \
    { \
        DebugIncrementStackDepthCounter(); \
        DebugMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT("+ ") TEXT(#_fn ) ); \
        _fn; \
        DebugMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT("V") ); \
        DebugDecrementStackDepthCounter(); \
    } while ( 0 )


//
// Same as TraceMsgDo() but only compiled in DEBUG.
//
#define DebugMsgDo( _fn, _msg ) \
    do \
    { \
        DebugIncrementStackDepthCounter(); \
        DebugMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT("+ ") TEXT(#_fn) ); \
        DebugMessageDo( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), TEXT(#_fn), _fn ); \
        DebugDecrementStackDepthCounter(); \
    } while ( 0 )

//****************************************************************************
//
//  HRESULT testing macros
//
//  These functions check HRESULT return values and display UI if conditions
//  warrant only in DEBUG.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  IsTraceFlagSet(
//      _flag
//      )
//
//  Description:
//      Checks to see of the flag is set in the global flags or in the per
//      thread flags. If you specify more than one flag and if any of them are
//      set, it will return TRUE.
//
//      In RETAIL this always return FALSE thereby effectively deleting the
//      block of the if statement. Example:
//
//          if ( IsTraceFlagSet( mtfPERTHREADTRACE ) )
//          {
//              //
//              // This code only exists in DEBUG.
//              .
//              .
//              .
//          }
//
//  Arguments:
//      _flags  - Flag to check for.
//
//  Return Values:
//      TRUE    - If DEBUG and flag set.
//      FLASE   - If RETAIL or flag not set.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define IsTraceFlagSet( _flag )    ( g_tfModule && IsDebugFlagSet( _flag ) )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  THR(
//      _hr
//      )
//
//  Description:
//      Warning is display if HRESULT is anything but S_OK (0). This can be
//      use in an expression. Example:
//
//      hr = THR( pSomething->DoSomething( arg ) );
//
//  Arguments:
//      _hr - Function expression to check.
//
//  Return Values:
//      Result of the "_hr" expression.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define THR( _hr ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, FALSE, S_OK )

#define THRMSG( _hr, _msg ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, FALSE, S_OK )
#define THRMSG1( _hr, _msg, _arg1 ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, FALSE, S_OK, _arg1 )

#define THRE( _hr, _hrIgnore ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, FALSE, _hrIgnore )

#define THREMSG( _hr, _hrIgnore, _msg ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, FALSE, _hrIgnore )
#define THREMSG1( _hr, _hrIgnore, _msg, _arg1 ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, FALSE, _hrIgnore, _arg1 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  STHR(
//      _hr
//      )
//
//  Description:
//      Warning is display if FAILED( _hr ) is TRUE. This can be use in an
//      expression. Example:
//
//      hr = STHR( pSomething->DoSomething( arg ) );
//
//  Arguments:
//      _hr - Function expression to check.
//
//  Return Values:
//      Result of the "_hr" expression.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define STHR( _hr ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, TRUE, S_OK )

#define STHRMSG( _hr, _msg ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, TRUE, S_OK )
#define STHRMSG1( _hr, _msg, _arg1 ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, TRUE, S_OK, _arg1 )

#define STHRE( _hr, _hrIgnore ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, TRUE, _hrIgnore )

#define STHREMSG( _hr, _hrIgnore, _msg ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, TRUE, _hrIgnore )
#define STHREMSG1( _hr, _hrIgnore, _msg, _arg1 ) \
    TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _hr, TRUE, _hrIgnore, _arg1 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  TW32(
//      _fn
//      )
//
//  Description:
//      Warning is display if result is anything but ERROR_SUCCESS (0). This
//      can be use in an expression. Example:
//
//      dwErr = TW32( RegOpenKey( HKLM, "foobar", &hkey ) );
//
//  Arguments:
//      _fn - Function expression to check.
//
//  Return Values:
//      Result of the "_fn" expression.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define TW32( _fn ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_fn), _fn, ERROR_SUCCESS )

#define TW32MSG( _fn, _msg ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _fn, ERROR_SUCCESS )
#define TW32MSG1( _fn, _msg, _arg1 ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _fn, ERROR_SUCCESS, _arg1 )

#define TW32E( _fn, _errIgnore ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_fn), _fn, _errIgnore )

#define TW32EMSG( _fn, _errIgnore, _msg ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _fn, _errIgnore )
#define TW32EMSG1( _fn, _errIgnore, _msg, _arg1 ) \
    TraceWin32( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), _fn, _errIgnore, _arg1 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  RRETURN(
//      _fn
//      )
//
//  Description:
//      Warning is display if return value is anything but ERROR_SUCCESS (0).
//
//  Argument:
//      _fn - Value to return.
//
//  Return Values:
//      _fn always.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define RRETURN( _fn ) \
    do \
    { \
        if ( g_tfModule != 0 ) \
        { \
            __MissingTraceFunc = 0; \
            if ( _fn != ERROR_SUCCESS ) \
            { \
                DebugReturnMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT( "V ") TEXT(#_fn) TEXT(" = 0x%08x (%s)"), _fn ); \
            } \
            else \
            { \
                TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, TEXT("V") ); \
            } \
            DebugDecrementStackDepthCounter(); \
        } \
        return _fn; \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  QIRETURN(
//      _hr,
//      _riid
//      )
//
//  Description:
//      Warning is display if HRESULT is anything but S_OK (0) only if
//      mtfQUERYINTERFACE is set in g_tfModule, otherwise only a debug
//      message will be printed. Note that TraceFunc() must have been called
//      on the call stack counter must be incremented prior to using.
//
//      QIRETURNx will ignore E_NOINTERFACE errors for the interfaces
//      specified.
//
//  Arguments:
//      _hr     - Result of the query interface call.
//      _riid   - The reference ID of the interfaced queried for.
//
//  Return Values:
//      None - calls RETURN macro.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define QIRETURN( _hr, _riid ) \
    do \
    { \
        if ( _hr ) \
        { \
            TCHAR szGuid[ 40 ]; \
            TCHAR szSymbolicName[ 64 ]; \
            DWORD cchSymbolicName = 64; \
            DebugFindWinerrorSymbolicName( _hr, szSymbolicName, &cchSymbolicName ); \
            Assert( cchSymbolicName != 64 ); \
            DebugMessage( TEXT(__FILE__), \
                          __LINE__, \
                          __MODULE__, \
                          TEXT("*HRESULT* QueryInterface( %s, ppv ) failed(), hr = 0x%08x (%s)"), \
                          PszDebugFindInterface( _riid, szGuid ), \
                          _hr, \
                          szSymbolicName \
                          ); \
        } \
        if ( g_tfModule & mtfQUERYINTERFACE ) \
        { \
            __MissingTraceFunc = 0; \
            TraceHR( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_hr), _hr, FALSE, S_OK ); \
        } \
        HRETURN( _hr ); \
    } while ( 0 )

#define QIRETURN1( _hr, _riid, _riidIgnored1 ) \
    do \
    { \
        if ( _hr == E_NOINTERFACE \
          && IsEqualIID( _riid, _riidIgnored1 ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    } while ( 0 )

#define QIRETURN2( _hr, _riid, _riidIgnored1, _riidIgnored2 ) \
    do \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    } while ( 0 )

#define QIRETURN3( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3 ) \
    do \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    } while ( 0 )

#define QIRETURN4( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3, _riidIgnored4 ) \
    do \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
               || IsEqualIID( _riid, _riidIgnored4 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    } while ( 0 )

#define QIRETURN5( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3, _riidIgnored4, _riidIgnored5 ) \
    do \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
               || IsEqualIID( _riid, _riidIgnored4 ) \
               || IsEqualIID( _riid, _riidIgnored5 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    } while ( 0 )

#define QIRETURN6( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3, _riidIgnored4, _riidIgnored5, _riidIgnored6 ) \
    do \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
               || IsEqualIID( _riid, _riidIgnored4 ) \
               || IsEqualIID( _riid, _riidIgnored5 ) \
               || IsEqualIID( _riid, _riidIgnored6 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    } while ( 0 )

#define QIRETURN7( _hr, _riid, _riidIgnored1, _riidIgnored2, _riidIgnored3, _riidIgnored4, _riidIgnored5, _riidIgnored6, _riidIgnored7 ) \
    do \
    { \
        if ( _hr == E_NOINTERFACE \
          &&    ( IsEqualIID( _riid, _riidIgnored1 ) \
               || IsEqualIID( _riid, _riidIgnored2 ) \
               || IsEqualIID( _riid, _riidIgnored3 ) \
               || IsEqualIID( _riid, _riidIgnored4 ) \
               || IsEqualIID( _riid, _riidIgnored5 ) \
               || IsEqualIID( _riid, _riidIgnored6 ) \
               || IsEqualIID( _riid, _riidIgnored7 ) \
                ) \
           ) \
        { \
            FRETURN( S_OK ); \
            return( _hr ); \
        } \
        QIRETURN( _hr, _riid ); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  QIRETURN_IGNORESTDMARSHALLING(
//      _hr,
//      _riid
//      )
//
//  Description:
//      Works like QIRETURN (see QIRETURN above), but ignores E_NOINTERFACE for
//      the standard marshalling interfaces.
//
//  Arguments:
//      _hr     - Result of the query interface call.
//      _riid   - The reference ID of the interfaced queried for.
//
//  Return Values:
//      None - calls QIRETURN5 macro.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define QIRETURN_IGNORESTDMARSHALLING( _hr, _riid ) \
    do \
    { \
        const GUID _COCLASS_IdentityUnmarshall = { 0x0000001b, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }; \
        const GUID _IID_IMarshalOptions_ =       { 0x4c1e39e1, 0xe3e3, 0x4296, 0xaa, 0x86, 0xec, 0x93, 0x8d, 0x89, 0x6e, 0x92 }; \
        QIRETURN6( _hr, _riid, IID_IMarshal, _COCLASS_IdentityUnmarshall, IID_IStdMarshalInfo, IID_IExternalConnection, IID_ICallFactory, _IID_IMarshalOptions_ ); \
    } while ( 0 )

#define QIRETURN_IGNORESTDMARSHALLING1( _hr, _riid, _riid1 ) \
    do \
    { \
        const GUID _COCLASS_IdentityUnmarshall = { 0x0000001b, 0x0000, 0x0000, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 }; \
        const GUID _IID_IMarshalOptions_ =       { 0x4c1e39e1, 0xe3e3, 0x4296, 0xaa, 0x86, 0xec, 0x93, 0x8d, 0x89, 0x6e, 0x92 }; \
        QIRETURN7( _hr, _riid, IID_IMarshal, _COCLASS_IdentityUnmarshall, IID_IStdMarshalInfo, IID_IExternalConnection, IID_ICallFactory, _riid1, _IID_IMarshalOptions_ ); \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  BOOLTOSTRING(
//      _fBool
//      )
//
//  Desfription:
//      If _fBool is true, returns address of "TRUE" else returns address of
//      "FALSE".
//
//  Argument:
//      _fBool  - Expression to evaluate.
//
//  Return Values:
//      address of "TRUE" if _fBool is true.
//      address of "FALSE" if _fBool is false.
//
//--
//////////////////////////////////////////////////////////////////////////////
#define BOOLTOSTRING( _fBool ) ( (_fBool) ? g_szTrue : g_szFalse )

//****************************************************************************
//
// Trace/Debug Functions - these do not exist in RETAIL.
//
//****************************************************************************

BOOL
IsDebugFlagSet(
    TRACEFLAG   tfIn
    );

void
__cdecl
TraceMsg(
    TRACEFLAG   tfIn,
    LPCSTR      pszFormatIn,
    ...
    );

void
__cdecl
TraceMsg(
    TRACEFLAG   tfIn,
    LPCWSTR     pszFormatIn,
    ...
    );

void
__cdecl
DebugMsg(
    LPCSTR      pszFormatIn,
    ...
    );

void
__cdecl
DebugMsg(
    LPCWSTR     pszFormatIn,
    ...
    );

void
__cdecl
DebugMsgNoNewline(
    LPCSTR      pszFormatIn,
    ...
    );

void
__cdecl
DebugMsgNoNewline(
    LPCWSTR     pszFormatIn,
    ...
    );

void
__cdecl
TraceMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCTSTR     pszFormatIn,
    ...
    );

void
__cdecl
TraceMessageDo(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCTSTR     pszFormatIn,
    LPCTSTR     pszFuncIn,
    ...
    );

void
__cdecl
DebugMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszFormatIn,
    ...
    );

void
__cdecl
DebugMessageDo(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszFormatIn,
    LPCTSTR     pszFuncIn,
    ...
    );

BOOL
AssertMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    BOOL        fTrueIn,
    ...
    );

HRESULT
TraceHR(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    HRESULT     hrIn,
    BOOL        fSuccessIn,
    HRESULT     hrIgnoreIn,
    ...
    );

ULONG
TraceWin32(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    ULONG       ulErrIn,
    ULONG       ulErrIgnoreIn,
    ...
    );

void
__cdecl
TraceLogMsgNoNewline(
    LPCSTR  pszFormatIn,
    ...
    );

void
__cdecl
TraceLogMsgNoNewline(
    LPCWSTR pszFormatIn,
    ...
    );

#if 0
//
// Trying to get the NTSTATUS stuff to play in "user world"
// is just about impossible. This is here in case it is needed
// and one could find the right combination of headers to
// make it work. Inflicting such pain on others is the reason
// why this function is #ifdef'fed.
//
void
DebugFindNTStatusSymbolicName(
    NTSTATUS dwStatusIn,
    LPTSTR   pszNameOut,
    LPDWORD  pcchNameInout
    );
#endif

void
DebugFindWinerrorSymbolicName(
    DWORD dwErrIn,
    LPTSTR  pszNameOut,
    LPDWORD pcchNameInout
    );

void
DebugReturnMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszMessageIn,
    DWORD       dwErrIn
    );

//****************************************************************************
//
//  Use the TraceMemoryXXX wrappers, not the DebugMemoryXXX functions.
//  The memory tracking functions do not exist in RETAIL (converted to NOP).
//
//****************************************************************************

typedef enum EMEMORYBLOCKTYPE
{
    mmbtUNKNOWN = 0,           // Never used
    mmbtMEMORYALLOCATION,      // GlobalAlloc/LocalAlloc/malloc
    mmbtOBJECT,                // Object pointer
    mmbtHANDLE,                // Object handle
    mmbtPUNK,                  // IUnknown pointer
    mmbtSYSALLOCSTRING         // SysAllocString
} EMEMORYBLOCKTYPE;

#define TraceMemoryAdd( _mbtType, _hGlobalIn, _pszFileIn, _nLineIn, _pszModuleIn, _dwBytesIn, _pszCommentIn ) \
    DebugMemoryAdd( _mbtType, _hGlobalIn, _pszFileIn, _nLineIn, _pszModuleIn, _dwBytesIn, _pszCommentIn )

#define TraceMemoryAddAddress( _pv ) \
    DebugMemoryAdd( mmbtMEMORYALLOCATION, _pv, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_pv) )

#define TraceMemoryAddHandle( _handle ) \
    DebugMemoryAdd( mmbtHANDLE, _handle, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_handle) )

#define TraceMemoryAddObject( _pv ) \
    DebugMemoryAdd( mmbtOBJECT, _pv, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_pv) )

#define TraceMemoryAddPunk( _punk ) \
    DebugMemoryAdd( mmbtPUNK, _punk, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_punk) )

#define TraceMemoryAddBSTR( _pv ) \
    DebugMemoryAdd( mmbtSYSALLOCSTRING, _pv, TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT(#_pv) )

#define TraceMemoryDelete( _hGlobalIn, _fClobberIn ) \
    DebugMemoryDelete( mmbtUNKNOWN, _hGlobalIn, TEXT(__FILE__), __LINE__, __MODULE__, _fClobberIn )

#define TraceStrDup( _sz ) \
    (LPTSTR) DebugMemoryAdd( mmbtMEMORYALLOCATION, StrDup( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, 0, TEXT("StrDup( ") TEXT(#_sz) TEXT(" )") )

#if defined( USES_SYSALLOCSTRING )
// BUGBUG:  DavidP 09-DEC-1999
//          _sz is evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceSysAllocString( _sz ) \
(BSTR) DebugMemoryAdd( mmbtSYSALLOCSTRING, SysAllocString( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, ((DWORD)( *(&_sz) == NULL ? 0 : wcslen( _sz ) + 1 )), TEXT("SysAllocString( ") TEXT(#_sz) TEXT(")") )

// BUGBUG:  DavidP 09-DEC-1999
//          _sz and _len are evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceSysAllocStringByteLen( _sz, _len ) \
    (BSTR) DebugMemoryAdd( mmbtSYSALLOCSTRING, SysAllocStringByteLen( _sz, _len ), TEXT(__FILE__), __LINE__, __MODULE__, _len, TEXT("SysAllocStringByteLen( ") TEXT(#_sz) TEXT(")") )

// BUGBUG:  DavidP 09-DEC-1999
//          _sz and _len are evaluated multiple times but the name of the
//          macro is mixed case.
#define TraceSysAllocStringLen( _sz, _len ) \
    (BSTR) DebugMemoryAdd( mmbtSYSALLOCSTRING, SysAllocStringLen( _sz, _len ), TEXT(__FILE__), __LINE__, __MODULE__, _len + 1, TEXT("SysAllocStringLen( ") TEXT(#_sz) TEXT(")") )

#define TraceSysReAllocString( _bstrOrg, _bstrNew ) \
    DebugSysReAllocString( TEXT(__FILE__), __LINE__, __MODULE__, _bstrOrg, _bstrNew, TEXT("TraceSysReAllocString(") TEXT(#_bstrOrg) TEXT(", ") TEXT(#_bstrNew) TEXT(" )") )

#define TraceSysReAllocStringLen( _bstrOrg, _bstrNew, _cch ) \
    DebugSysReAllocStringLen( TEXT(__FILE__), __LINE__, __MODULE__, _bstrOrg, _bstrNew, _cch, TEXT("TraceSysReAllocString(") TEXT(#_bstrOrg) TEXT(", ") TEXT(#_bstrNew) TEXT(", ") TEXT(#_cch) TEXT(" )") )

#define TraceSysFreeString( _bstr ) \
    DebugMemoryDelete( mmbtSYSALLOCSTRING, _bstr, TEXT(__FILE__), __LINE__, __MODULE__, TRUE ); \
    SysFreeString( _bstr )
#endif // USES_SYSALLOCSTRING

//****************************************************************************
//
//  Memory tracing functions - these are remapped to the GlobalAlloc/GlobalFree
//  heap functions when in RETAIL. Use the TraceMemoryXXX wrappers, not the
//  DebugMemoryXXX functions.
//
//****************************************************************************
void *
DebugAlloc(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    UINT        uFlagsIn,
    DWORD       dwBytesIn,
    LPCTSTR     pszCommentIn
    );

void *
DebugReAlloc(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    void *      pvMemIn,
    UINT        uFlagsIn,
    DWORD       dwBytesIn,
    LPCTSTR     pszCommentIn
    );

BOOL
DebugFree(
    void *      pvMemIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    );

void *
DebugMemoryAdd(
      EMEMORYBLOCKTYPE  mbtType
    , void *            pvMemIn
    , LPCTSTR           pszFileIn
    , const int         nLineIn
    , LPCTSTR           pszModuleIn
    , DWORD             dwBytesIn
    , LPCTSTR           pszCommentIn
    );

void
DebugMemoryDelete(
      EMEMORYBLOCKTYPE  mbtTypeIn
    , void *            pvMemIn
    , LPCTSTR           pszFileIn
    , const int         nLineIn
    , LPCTSTR           pszModuleIn
    , BOOL              fClobberIn
    );

#if defined( USES_SYSALLOCSTRING )

INT
DebugSysReAllocString(
    LPCTSTR         pszFileIn,
    const int       nLineIn,
    LPCTSTR         pszModuleIn,
    BSTR *          pbstrIn,
    const OLECHAR * pszIn,
    LPCTSTR         pszCommentIn
    );

INT
DebugSysReAllocStringLen(
    LPCTSTR         pszFileIn,
    const int       nLineIn,
    LPCTSTR         pszModuleIn,
    BSTR *          pbstrIn,
    const OLECHAR * pszIn,
    unsigned int    ucchIn,
    LPCTSTR         pszCommentIn
    );

#endif // USES_SYSALLOCSTRING

void
DebugMemoryCheck(
    LPVOID  pvListIn,
    LPCTSTR pszListNameIn
    );

//****************************************************************************
//
//  operator new() for C++
//
//****************************************************************************
#ifdef __cplusplus
extern
void *
__cdecl
operator new(
    size_t      nSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    );
/*
//****************************************************************************
//
//  operator new []() for C++
//
//****************************************************************************
extern
void *
__cdecl
operator new [](
    size_t      nSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    );
*/
//****************************************************************************
//
//  operator delete() for C++
//
//****************************************************************************
extern
void
__cdecl
operator delete(
    void *      pMem,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    );
/*
//****************************************************************************
//
//  operator delete []() for C++
//
//****************************************************************************
extern
void
__cdecl
operator delete [](
    void *      pMemIn,
    size_t      stSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    );
*/
//
// Remap "new" to our macro so "we" don't have to type anything extra and
// so it magically dissappears in RETAIL.
//
#define new new( TEXT(__FILE__), __LINE__, __MODULE__ )
#endif

//****************************************************************************
//
//
#else // it's RETAIL    ******************************************************
//
//
//****************************************************************************

#pragma message("BUILD: RETAIL macros being built")

//
// Debugging -> NOPs
//
#define DEFINE_MODULE( _module )
#define __MODULE__                                  NULL
#define DEFINE_THISCLASS( _class )
#define __THISCLASS__                               NULL
//#define DEFINE_SUPER( _super )
//#define __SUPERCLASS__                              NULL
#define BOOLTOSTRING( _fBool )                      NULL

#define DebugDo( _fn )
#define DebugMsgDo( _fn, _msg )
#define TraceMsgGUID( _f, _m, _g )

#define AssertMessage               TRUE


//
// TODO: gpease 08-NOV-1999
//  We probably want to do something special for ErrorMsg()
//
#define ErrorMsg                    1 ? (void)0 : (void)__noop

#define TraceMsg                    1 ? (void)0 : (void)__noop
#define WndMsg                      1 ? (void)0 : (void)__noop
#define DebugMsg                    1 ? (void)0 : (void)__noop
#define DebugMsgNoNewline           1 ? (void)0 : (void)__noop
#define TraceMessage                1 ? (void)0 : (void)__noop
#define DebugMessage                1 ? (void)0 : (void)__noop
#define TraceHR                     1 ? (void)0 : (void)__noop
#define TraceFunc                   1 ? (void)0 : (void)__noop
#define TraceFunc1                  1 ? (void)0 : (void)__noop
#define TraceFunc2                  1 ? (void)0 : (void)__noop
#define TraceFunc3                  1 ? (void)0 : (void)__noop
#define TraceFunc4                  1 ? (void)0 : (void)__noop
#define TraceFunc5                  1 ? (void)0 : (void)__noop
#define TraceFunc6                  1 ? (void)0 : (void)__noop
#define TraceQIFunc                 1 ? (void)0 : (void)__noop
#define TraceFlow                   1 ? (void)0 : (void)__noop
#define TraceFlow1                  1 ? (void)0 : (void)__noop
#define TraceFlow2                  1 ? (void)0 : (void)__noop
#define TraceFlow3                  1 ? (void)0 : (void)__noop
#define TraceFlow4                  1 ? (void)0 : (void)__noop
#define TraceFlow5                  1 ? (void)0 : (void)__noop
#define TraceFlow6                  1 ? (void)0 : (void)__noop
#define TraceFuncExit()             return
#if defined( DEBUG_SW_TRACING_ENABLED )
#define TraceInitializeProcess( _rgControl, _sizeofControl, _fGlobalMemoryTackingIn )
#define TraceTerminateProcess( _rgControl, _sizeofControl )
#else // ! DEBUG_SW_TRACING_ENABLED
#define TraceInitializeProcess( _fGlobalMemoryTackingIn )
#define TraceTerminateProcess()
#endif // DEBUG_SW_TRACING_ENABLED
#define TraceInitializeThread( _name )
#define TraceThreadRundown()
#define TraceMemoryAdd( _mbtType, _hGlobalIn, _pszFileIn, _nLineIn, _pszModuleIn, _uFlagsIn, _dwBytesIn, _pszCommentIn ) _hGlobalIn
#define TraceMemoryAddHandle( _handle ) _handle
#define TraceMemoryAddBSTR( _bstr ) _bstr
#define TraceMemoryAddAddress( _pv )    _pv
#define TraceMemoryAddHandle( _obj )    _obj
#define TraceMemoryAddPunk( _punk )     _punk
#define TraceMemoryDelete( _h, _b )     _h
#define TraceMemoryAddObject( _pv )     _pv
#define IsTraceFlagSet( _flag )         FALSE

//
// Tracing -> just do operation
//
#define TraceDo( _fn )  _fn

#define TraceMsgDo( _fn, _msg )                                             _fn
#define TraceMsgDo1( _fn, _msg, _arg1 )                                     _fn
#define TraceMsgDo2( _fn, _msg, _arg1, _arg2 )                              _fn
#define TraceMsgDo3( _fn, _msg, _arg1, _arg2, _arg3 )                       _fn
#define TraceMsgDo4( _fn, _msg, _arg1, _arg2, _arg3, _arg4 )                _fn
#define TraceMsgDo5( _fn, _msg, _arg1, _arg2, _arg3, _arg4, _arg5 )         _fn
#define TraceMsgDo6( _fn, _msg, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 )  _fn

#define TraceMsgPreDo( _fn, _msg1, _msg2 )                                              _fn
#define TraceMsgPreDo1( _fn, _msg1, _msg2, _arg1 )                                      _fn
#define TraceMsgPreDo2( _fn, _msg1, _msg2, _arg1, _arg2 )                               _fn
#define TraceMsgPreDo3( _fn, _msg1, _msg2, _arg1, _arg2, _arg3 )                        _fn
#define TraceMsgPreDo4( _fn, _msg1, _msg2, _arg1, _arg2, _arg3, _arg4 )                 _fn
#define TraceMsgPreDo5( _fn, _msg1, _msg2, _arg1, _arg2, _arg3, _arg4, _arg5 )          _fn
#define TraceMsgPreDo6( _fn, _msg1, _msg2, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6 )   _fn

#define TraceAssertIfZero( _fn )    _fn

//
// RETURN testing -> do retail
//
#define THR( _hr )                                  _hr
#define THRMSG( _hr, _msg )                         _hr
#define THRMSG1( _hr, _msg, _arg1 )                 _hr
#define THRE( _hr, _hrIgnore )                      _hr
#define THREMSG( _hr, _hrIgnore, _msg )             _hr
#define THREMSG1( _hr, _hrIgnore, _msg, _arg1 )     _hr
#define STHR( _hr )                                 _hr
#define STHRMSG( _hr, _msg )                        _hr
#define STHRMSG1( _hr, _msg, _arg1 )                _hr
#define STHRE( _hr, _hrIgnore )                     _hr
#define STHREMSG( _hr, _hrIgnore, _msg )            _hr
#define STHREMSG1( _hr, _hrIgnore, _msg, _arg1 )    _hr
#define TW32( _fn )                                 _fn
#define TW32MSG( _fn, _msg )                        _fn
#define TW32MSG1( _fn, _msg, _arg1 )                _fn
#define TW32E( _fn, _errIgnore )                    _fn
#define TW32EMSG( _fn, _errIgnore, _msg )           _fn
#define TW32EMSG1( _fn, _errIgnore, _msg, _arg1 )   _fn
#define RETURN( _fn )               return _fn
#define FRETURN( _fn )
#define RRETURN( _fn )              return _fn
#define HRETURN( _hr )              return _hr
#define QIRETURN( _qi, _riid )      return _qi
#define QIRETURN1( _qi, _riid, _riid1 )      return _qi
#define QIRETURN2( _qi, _riid, _riid1, _riid2 )      return _qi
#define QIRETURN3( _qi, _riid, _riid1, _riid2, _riid3 )      return _qi
#define QIRETURN4( _qi, _riid, _riid1, _riid2, _riid3, _riid4 )      return _qi
#define QIRETURN5( _qi, _riid, _riid1, _riid2, _riid3, _riid4, _riid5 )      return _qi
#define QIRETURN6( _qi, _riid, _riid1, _riid2, _riid3, _riid4, _riid5, _riid6 )      return _qi
#define QIRETURN7( _qi, _riid, _riid1, _riid2, _riid3, _riid4, _riid5, _riid6, _riid7 )      return _qi
#define QIRETURN_IGNORESTDMARSHALLING( _qi, _riid ) return _qi
#define QIRETURN_IGNORESTDMARSHALLING1( _qi, _riid, _riid1 ) return _qi

//
// Memory Functions -> do retail
//
#define TraceAlloc( _flags, _size )                             HeapAlloc( GetProcessHeap(), _flags, _size )
#define TraceAllocString( _flags, _size )                       (LPTSTR) HeapAlloc( GetProcessHeap(), flags, (_size) * sizeof( TCHAR ) )
#define TraceReAlloc( _pvMem, _uBytes, _uFlags )                ( ( _pvMem == NULL ) \
                                                                ? HeapAlloc( GetProcessHeap(), _uFlags, _uBytes ) \
                                                                : HeapReAlloc( GetProcessHeap(), _uFlags, _pvMem, _uBytes ) )
#define TraceFree( _pv )                                        HeapFree( GetProcessHeap(), 0, _pv )
#define TraceStrDup( _sz )                                      StrDup( _sz )
#define TraceSysAllocString( _sz )                              SysAllocString( _sz )
#define TraceSysAllocStringByteLen( _sz, _len )                 SysAllocStringByteLen( _sz, _len )
#define TraceSysAllocStringLen( _sz, _len )                     SysAllocStringLen( _sz, _len )
#define TraceSysReAllocString( _bstrOrg, _bstrNew )             SysReAllocString( _bstrOrg, _bstrNew )
#define TraceSysReAllocStringLen( _bstrOrg, _bstrNew, _cch )    SysReAllocStringLen( _bstrOrg, _bstrNew, _cch )
#define TraceSysFreeString( _bstr )                             SysFreeString( _bstr )
#define TraceCreateMemoryList( _pvIn )
#define TraceMoveToMemoryList( _addr, _pvIn )
//#define TraceMemoryListDelete( _addr, _pvIn, _fClobber )
#define TraceTerminateMemoryList( _pvIn )
#define TraceMoveFromMemoryList( _addr, _pmbIn )

#endif // DEBUG

#if DBG==1 || defined( _DEBUG )
//////////////////////////////////////////////////////////////////////////////
//
// MACRO
// DEBUG_BREAK
//
// Description:
//      Because the system expection handler can hick-up over INT 3s and
//      DebugBreak()s, This x86 only macro causes the program to break in the
//      right spot.
//
//////////////////////////////////////////////////////////////////////////////
#if defined( _X86_ )
#define DEBUG_BREAK         do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while ( 0 )
#else
#define DEBUG_BREAK         DebugBreak()
#endif

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  Assert(
//      _fn
//      )
//
//  Description:
//      Checks to see if the Expression is TRUE. If not, a message will be
//      displayed to the user on wether the program should break or continue.
//
//  Arguments:
//      _fn     - Expression being asserted.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#ifdef Assert
#undef Assert
#endif
// BUGBUG:  DavidP 09-DEC-1999
//          __fn is evaluated multiple times but the name of the
//          macro is mixed case.
#define Assert( _fn ) \
    do \
    { \
        if ( ! (_fn) && AssertMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(#_fn), !!(_fn) ) ) \
        { \
            DEBUG_BREAK; \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  AssertMsg(
//      _fn,
//      _msg
//      )
//
//  Descrption:
//      Just like an Assert but has an (hopefully) informative message
//      associated with it.
//
//  Arguments:
//      _fn     - Expression to be evaluated.
//      _msg    - Message to be display if assertion fails.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#ifdef AssertMsg
#undef AssertMsg
#undef AssertMsg1
#endif
// BUGBUG:  DavidP 09-DEC-1999
//          _fn is evaluated multiple times but the name of the
//          macro is mixed case.
#define AssertMsg( _fn, _msg ) \
    do \
    { \
        if ( ! (_fn) && AssertMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), !!(_fn) ) ) \
        { \
            DEBUG_BREAK; \
        } \
    } while ( 0 )
#define AssertMsg1( _fn, _msg, _arg1 ) \
    do \
    { \
        if ( ! (_fn) && AssertMessage( TEXT(__FILE__), __LINE__, __MODULE__, TEXT(_msg), !!(_fn), _arg1 ) ) \
        { \
            DEBUG_BREAK; \
        } \
    } while ( 0 )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  MACRO
//  AssertString(
//      _fn,
//      _msg
//      )
//
//  Descrption:
//      Just like an Assert but has a (hopefully) informative string
//      associated with it.
//
//  Arguments:
//      _fn     - Expression to be evaluated.
//      _msg    - String to be display if assertion fails.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
#ifdef AssertString
#undef AssertString
#endif
// BUGBUG:  DavidP 09-DEC-1999
//          _fn is evaluated multiple times but the name of the
//          macro is mixed case.
#define AssertString( _fn, _str ) \
    do \
    { \
        if ( ! (_fn) && AssertMessage( TEXT(__FILE__), __LINE__, __MODULE__, _str, !!(_fn) ) ) \
        { \
            DEBUG_BREAK; \
        } \
    } while ( 0 )

#undef VERIFY
#undef VERIFYMSG
#undef VERIFYMSG1
#undef VERIFYSTRING

#define VERIFY( _fn )                   Assert( _fn )
#define VERIFYMSG( _fn, _msg )          AssertMsg( _fn, _msg )
#define VERIFYMSG1( _fn, _msg, _arg1 )  AssertMsg1( _fn, _msg, _arg1 )
#define VERIFYSTRING( _fn, _str )       AssertString( _fn, _str )

#else // DBG!=1 && !_DEBUG

#define DEBUG_BREAK DebugBreak()

#ifndef Assert
#define Assert( _fn )
#endif

#ifndef AssertMsg
#define AssertMsg( _fn, _msg )
#endif

#ifndef AssertMsg1
#define AssertMsg1( _fn, _msg, _arg1 )
#endif

#ifndef AssertString
#define AssertString( _fn, _msg )
#endif

#ifndef VERIFY
#define VERIFY( _fn ) _fn
#endif

#ifndef VERIFYMSG
#define VERIFYMSG( _fn, _msg ) _fn
#endif

#ifndef VERIFYMSG1
#define VERIFYMSG1( _fn, _msg, _arg1 ) _fn
#endif

#ifndef VERIFYSTRING
#define VERIFYSTRING( _fn, _str ) _fn
#endif

#endif // DBG==1 || _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\dllsrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      DllSrc.cpp
//
//  Description:
//      DLL services/entry points.
//
//  Maintained By:
//      David Potter    (DavidP)    19-MAR-2001
//      Geoffrey Pease  (GPease)    18-OCT-1999
//
//  Notes:
//      Switches:
//      - ENTRY_PREFIX
//          If defined, include proxy/stub code into the DLL that is
//          generated by the MIDL compiler.
//      - USE_FUSION
//          If defined, initialize and uninitialize Fusion on process
//          attach and detach respectively.  The constant IDR_MANIFEST
//          must be defined with a value that represents the resource ID
//          for the manifest resource.
//      - NO_DLL_MAIN
//          If defined, don't implement DllMain.
//      - DEBUG_SW_TRACING_ENABLED
//          If defined, initialize and uninitialize software tracing on
//          process attach and detach respectively.
//      -- NO_THREAD_OPTIMIZATIONS
//          If defined, disable the thread notification calls when a thread
//          starts up or goes away.
//
//////////////////////////////////////////////////////////////////////////////

//
// DLL Globals
//
HINSTANCE g_hInstance = NULL;
LONG      g_cObjects  = 0;
LONG      g_cLock     = 0;
TCHAR     g_szDllFilename[ MAX_PATH ] = { 0 };

LPVOID    g_GlobalMemoryList = NULL;    // Global memory tracking list

#if defined( ENTRY_PREFIX )
extern "C"
{
    extern HINSTANCE hProxyDll;
}
#endif

//
//  Macros to generate RPC entry points
//
#define __rpc_macro_expand2( a, b ) a##b
#define __rpc_macro_expand( a, b ) __rpc_macro_expand2( a, b )

#if ! defined( NO_DLL_MAIN ) || defined( ENTRY_PREFIX ) || defined( DEBUG )
//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllMain
//
//  Description:
//      Dll entry point.
//
//  Arguments:
//      hInstIn      - DLL instance handle.
//      ulReasonIn   - DLL reason code for entrance.
//      lpReservedIn - Not used.
//
//  Return Values:
//      TRUE
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
DllMain(
    HINSTANCE   hInstIn,
    ULONG       ulReasonIn,
    LPVOID      // lpReservedIn
    )
{
    //
    // KB: THREAD_OPTIMIZATIONS gpease 19-OCT-1999
    //
    // By defining this you can prevent the linker
    // from calling your DllEntry for every new thread.
    // This makes creating new threads significantly
    // faster if every DLL in a process does it.
    // Unfortunately, not all DLLs do this.
    //
    // In CHKed/DEBUG, we keep this on for memory
    // tracking.
    //
#if ! defined( DEBUG )
    #define THREAD_OPTIMIZATIONS
#endif // DEBUG

    switch( ulReasonIn )
    {
        //////////////////////////////////////////////////////////////////////
        // DLL_PROCESS_ATTACH
        //////////////////////////////////////////////////////////////////////
        case DLL_PROCESS_ATTACH:
        {
#if defined( DEBUG_SW_TRACING_ENABLED )
            TraceInitializeProcess( g_rgTraceControlGuidList, ARRAYSIZE( g_rgTraceControlGuidList ), TRUE );
#else // ! DEBUG_SW_TRACING_ENABLED
            TraceInitializeProcess( TRUE );
#endif // DEBUG_SW_TRACING_ENABLED

            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_PROCESS_ATTACH - ThreadID = %#x"),
                          GetCurrentThreadId()
                          );

            g_hInstance = hInstIn;

#if defined( ENTRY_PREFIX )
             hProxyDll = g_hInstance;
#endif // ENTRY_PREFIX

            GetModuleFileName( g_hInstance, g_szDllFilename, ARRAYSIZE( g_szDllFilename ) );

            //
            // Create a global memory list so that memory allocated by one
            // thread and handed to another can be tracked without causing
            // unnecessary trace messages.
            //
            TraceCreateMemoryList( g_GlobalMemoryList );

#if defined( THREAD_OPTIMIZATIONS )
            {
                //
                // Disable thread library calls so that we don't get called
                // on thread attach and detach.
                //
                BOOL fResult = DisableThreadLibraryCalls( g_hInstance );
                if ( ! fResult )
                {
                    TW32MSG( GetLastError(), "DisableThreadLibraryCalls()" );
                }
            }
#endif // THREAD_OPTIMIZATIONS

#if defined( USE_FUSION )
            //
            // Initialize Fusion.
            //
            // The value of IDR_MANIFEST in the call to
            // SHFusionInitializeFromModuleID() must match the value specified in the
            // sources file for SXS_MANIFEST_RESOURCE_ID.
            //
            BOOL fResult = SHFusionInitializeFromModuleID( hInstIn, IDR_MANIFEST );
            if ( ! fResult )
            {
                TW32MSG( GetLastError(), "SHFusionInitializeFromModuleID()" );
            }
#endif // USE_FUSION

            //
            // This is necessary here because TraceFunc() defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after
            // TraceFunc().
            //
            FRETURN( TRUE );

            break;
        } // case: DLL_PROCESS_ATTACH

        //////////////////////////////////////////////////////////////////////
        // DLL_PROCESS_DETACH
        //////////////////////////////////////////////////////////////////////
        case DLL_PROCESS_DETACH:
        {
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_PROCESS_DETACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId(),
                          g_cLock,
                          g_cObjects
                          );

            //
            // Cleanup the global memory list used to track memory allocated
            // in one thread and then handed to another.
            //
            TraceTerminateMemoryList( g_GlobalMemoryList );

            //
            // This is necessary here because TraceFunc() defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after
            // TraceFunc().
            //
            FRETURN( TRUE );

#if defined( DEBUG_SW_TRACING_ENABLED )
            TraceTerminateProcess( g_rgTraceControlGuidList, ARRAYSIZE( g_rgTraceControlGuidList )
                                   );
#else // ! DEBUG_SW_TRACING_ENABLED
            TraceTerminateProcess();
#endif // DEBUG_SW_TRACING_ENABLED

#if defined( USE_FUSION )
            SHFusionUninitialize();
#endif // USE_FUSION

            break;
        } // case: DLL_PROCESS_DETACH

#if ! defined( THREAD_OPTIMIZATIONS )
        //////////////////////////////////////////////////////////////////////
        // DLL_THREAD_ATTACH
        //////////////////////////////////////////////////////////////////////
        case DLL_THREAD_ATTACH:
        {
            TraceInitializeThread( NULL );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("Thread %#x has started."),
                          GetCurrentThreadId()
                          );
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_THREAD_ATTACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId(),
                          g_cLock,
                          g_cObjects
                          );

            //
            // This is necessary here because TraceFunc() defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after
            // TraceFunc().
            //
            FRETURN( TRUE );

            break;
        } // case: DLL_THREAD_ATTACH

        //////////////////////////////////////////////////////////////////////
        // DLL_THREAD_DETACH
        //////////////////////////////////////////////////////////////////////
        case DLL_THREAD_DETACH:
        {
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: DLL_THREAD_DETACH - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId(),
                          g_cLock,
                          g_cObjects
                          );

            //
            // This is necessary here because TraceFunc() defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after
            // TraceFunc().
            //
            FRETURN( TRUE );

            TraceThreadRundown();

            break;
        } // case: DLL_THREAD_DETACH
#endif // ! THREAD_OPTIMIZATIONS

        default:
        {
            TraceFunc( "" );
            TraceMessage( TEXT(__FILE__),
                          __LINE__,
                          __MODULE__,
                          mtfDLL,
                          TEXT("DLL: UNKNOWN ENTRANCE REASON - ThreadID = %#x [ g_cLock=%u, g_cObjects=%u ]"),
                          GetCurrentThreadId(),
                          g_cLock,
                          g_cObjects
                          );

#if defined( THREAD_OPTIMIZATIONS )
            Assert( ( ulReasonIn != DLL_THREAD_ATTACH )
                &&  ( ulReasonIn != DLL_THREAD_DETACH ) );
#endif // THREAD_OPTIMIZATIONS

            //
            // This is necessary here because TraceFunc defines a variable
            // on the stack which isn't available outside the scope of this
            // block.
            // This function doesn't do anything but clean up after TraceFunc.
            //
            FRETURN( TRUE );

            break;
        } // default case
    } // switch on reason code

    return TRUE;

} //*** DllMain()
#endif // ! defined( NO_DLL_MAIN ) && ! defined( ENTRY_PREFIX ) && ! defined( DEBUG )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllGetClassObject
//
//  Description:
//      OLE calls this to get the class factory from the DLL.
//
//  Arguments:
//      rclsidIn
//          - Class ID of the object that the class factory should create.
//      riidIn
//          - Interface of the class factory
//      ppvOut
//          - The interface pointer to the class factory.
//
//  Return Values:
//      S_OK            - Operation completed successfully.
//      E_POINTER       - Required output parameter was specified as NULL.
//      CLASS_E_CLASSNOTAVAILABLE
//                      - Class ID not supported by this DLL.
//      E_OUTOFMEMORY   - Error allocating memory.
//      Other HRESULTs to indicate failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllGetClassObject(
    REFCLSID    rclsidIn,
    REFIID      riidIn,
    void **     ppvOut
    )
{
    TraceFunc( "rclsidIn, riidIn, ppvOut" );

    LPCFACTORY  lpClassFactory;
    HRESULT     hr;
    int         idx;

    if ( ppvOut == NULL )
    {
        hr = E_POINTER;
        goto Cleanup;
    } // if: bad argument

    hr = CLASS_E_CLASSNOTAVAILABLE;
    idx = 0;
    while( g_DllClasses[ idx ].rclsid )
    {
        if ( *g_DllClasses[ idx ].rclsid == rclsidIn )
        {
            TraceMessage( TEXT(__FILE__), __LINE__, __MODULE__, mtfFUNC, L"rclsidIn = %s", g_DllClasses[ idx ].pszName );
            hr = S_OK;
            break;

        } // if: class found

        idx++;

    } // while: finding class

    // Didn't find the class ID.
    if ( hr == CLASS_E_CLASSNOTAVAILABLE )
    {
        TraceMsgGUID( mtfFUNC, "rclsidIn = ", rclsidIn );
#if defined( ENTRY_PREFIX )
        //
        //  See if the MIDL generated code can create it.
        //
        hr = STHR( __rpc_macro_expand( ENTRY_PREFIX, DllGetClassObject )( rclsidIn, riidIn, ppvOut ) );
#endif // defined( ENTRY_PREFIX )
        goto Cleanup;
    } // if: class not found

    Assert( g_DllClasses[ idx ].pfnCreateInstance != NULL );

    lpClassFactory = new CFactory;
    if ( lpClassFactory == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;

    } // if: memory failure

    hr = THR( lpClassFactory->HrInit( g_DllClasses[ idx ].pfnCreateInstance ) );
    if ( FAILED( hr ) )
    {
        TraceDo( lpClassFactory->Release() );
        goto Cleanup;

    } // if: initialization failed

    // Can't safe type.
    hr = lpClassFactory->QueryInterface( riidIn, ppvOut );
    //
    // Release the created instance to counter the AddRef() in Init().
    //
    ((IUnknown *) lpClassFactory )->Release();

Cleanup:
    HRETURN( hr );

} //*** DllGetClassObject()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllRegisterServer
//
//  Description:
//      OLE's register entry point.
//
//  Argument:
//      None.
//
//  Return Values:
//      S_OK    - Operation completed successfully.
//      Other HRESULTs to indicate failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllRegisterServer( void )
{
    HRESULT hr;

    TraceFunc( "" );

    hr = THR( HrRegisterDll( TRUE ) );

#if defined( ENTRY_PREFIX )
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( __rpc_macro_expand( ENTRY_PREFIX, DllRegisterServer )() );
    } // if: register proxy/stub
#endif // defined( ENTRY_PREFIX )

    HRETURN( hr );

} //*** DllRegisterServer()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllUnregisterServer
//
//  Description:
//      OLE's unregister entry point.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK    - Operation completed successful.
//      Other HRESULTs to indicate failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllUnregisterServer( void )
{
    TraceFunc( "" );

    HRESULT hr;

    hr = THR( HrRegisterDll( FALSE ) );

#if defined( ENTRY_PREFIX )
    if ( SUCCEEDED( hr ) )
    {
        hr = THR( __rpc_macro_expand( ENTRY_PREFIX, DllUnregisterServer )() );
    } // if: unregister proxy/stub
#endif // defined( ENTRY_PREFIX )

    HRETURN( hr );

} //*** DllUnregisterServer()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllCanUnloadNow
//
//  Description:
//      OLE calls this entry point to see if it can unload the DLL.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK    - Can unload the DLL.
//      S_FALSE - Can not unload the DLL.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDAPI
DllCanUnloadNow( void )
{
    TraceFunc( "" );

    HRESULT hr = S_OK;

    if ( g_cLock || g_cObjects )
    {
        TraceMsg( mtfDLL, "DLL: Can't unload - g_cLock=%u, g_cObjects=%u", g_cLock, g_cObjects );
        hr = S_FALSE;

    } // if: any object or locks
#if defined( ENTRY_PREFIX )
    else
    {
        //
        //  Check with the MIDL generated proxy/stubs.
        //
        hr = STHR( __rpc_macro_expand( ENTRY_PREFIX, DllCanUnloadNow )() );
    }
#endif

    HRETURN( hr );

} //*** DLlCanUnloadNow()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HrCoCreateInternalInstance
//
//  Description:
//      Mimic CoCreateInstance() except that it looks into the DLL table
//      to see if we can shortcut the CoCreate with a simple CreateInstance
//      call.
//
//  Arguments: (matches CoCreateInstance)
//      rclsidIn        -   Class identifier (CLSID) of the object
//      pUnkOuterIn     -   Pointer to controlling IUnknown
//      dwClsContext    -   Context for running executable code
//      riidIn          -   Reference to the identifier of the interface
//      ppvOut          -   Address of output variable that receives
//
//  Return Values:
//      S_OK            - Success.
//      E_OUTOFMEMORY   - Out of memory.
//      other HRESULT values
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrCoCreateInternalInstance(
    REFCLSID rclsidIn,
    LPUNKNOWN pUnkOuterIn,
    DWORD dwClsContextIn,
    REFIID riidIn,
    LPVOID * ppvOut
    )
{
    TraceFunc( "" );

    Assert( ppvOut != NULL );

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;

    //
    // Limit simple CoCreate() only works to INPROC and non-aggregatable objects.
    //

    if (    ( dwClsContextIn & CLSCTX_INPROC_HANDLER )  // inproc only
        &&  ( pUnkOuterIn == NULL )                     // no aggregation
       )
    {
        int idx;

        //
        // Try to find the class in our DLL table.
        //
        for( idx = 0; g_DllClasses[ idx ].rclsid != NULL; idx++ )
        {
            if ( *g_DllClasses[ idx ].rclsid == rclsidIn )
            {
                LPUNKNOWN punk;
                Assert( g_DllClasses[ idx ].pfnCreateInstance != NULL );

                hr = THR( g_DllClasses[ idx ].pfnCreateInstance( &punk ) );
                if ( SUCCEEDED( hr ) )
                {
                    // Can't safe type.
                    hr = THR( punk->QueryInterface( riidIn, ppvOut ) );
                    punk->Release();
                } // if: got object

                break;  // bail loop

            } // if: class found

        } // for: finding class

    } // if: simple CoCreate()

    //
    // If not found or asking for something we do not support,
    // use the COM version.
    //

    if ( hr == CLASS_E_CLASSNOTAVAILABLE )
    {
        //
        // Try it the old fashion way...
        //
        hr = THR( CoCreateInstance( rclsidIn, pUnkOuterIn, dwClsContextIn, riidIn, ppvOut ) );

    } // if: class not found

    HRETURN( hr );

} //*** HrClusCoCreateInstance()


//
// TODO:    gpease 27-NOV-1999
//          While perusing around the MIDL SDK, I foud that
//          RPC creates the same type of class table we do. Maybe
//          we can leverage the MIDL code to create our objects(??).
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\loadstring.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      LoadString.h
//
//  Description:
//      LoadStringIntoBSTR implementation.
//
//  Maintained By:
//      David Potter    (DavidP)    01-FEB-2001
//      Galen Barbee    (GalenB)    22-MAY-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
// Load string routines
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrLoadStringIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    );

inline
HRESULT
HrLoadStringIntoBSTR(
      HINSTANCE hInstanceIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    )

{
    return HrLoadStringIntoBSTR(
                          hInstanceIn
                        , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                        , idsIn
                        , pbstrInout
                        );

} //*** HrLoadStringIntoBSTR()

//////////////////////////////////////////////////////////////////////////////
// Format string ID routines
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrFormatStringIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , ...
    );

HRESULT
HrFormatStringWithVAListIntoBSTR(
      HINSTANCE hInstanceIn
    , LANGID    langidIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    );

inline
HRESULT
HrFormatStringIntoBSTR(
      HINSTANCE hInstanceIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , ...
    )
{
    HRESULT hr;
    va_list valist;

    va_start( valist, pbstrInout );

    hr = HrFormatStringWithVAListIntoBSTR(
                  hInstanceIn
                , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                , idsIn
                , pbstrInout
                , valist
                );

    va_end( valist );

    return hr;

} //*** HrFormatStringIntoBSTR( idsIn )

inline
HRESULT
HrFormatStringWithVAListIntoBSTR(
      HINSTANCE hInstanceIn
    , UINT      idsIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    )
{
    return HrFormatStringWithVAListIntoBSTR(
                  hInstanceIn
                , MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL )
                , idsIn
                , pbstrInout
                , valistIn
                );

} //*** HrFormatStringWithVAListIntoBSTR( idsIn )

//////////////////////////////////////////////////////////////////////////////
// Format string routines
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrFormatStringIntoBSTR(
      LPCWSTR   pcwszFmtIn
    , BSTR *    pbstrInout
    , ...
    );

HRESULT
HrFormatStringWithVAListIntoBSTR(
      LPCWSTR   pcwszFmtIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    );

// This is obsolete.  Use HrFormatStringIntoBSTR intead.
HRESULT
HrFormatMessageIntoBSTR(
      HINSTANCE hInstanceIn
    , UINT      uIDIn
    , BSTR *    pbstrInout
    , ...
    );

//////////////////////////////////////////////////////////////////////////////
// Format error routines
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrFormatErrorIntoBSTR(
      HRESULT   hrIn
    , BSTR *    pbstrInout
    , ...
    );

HRESULT
HrFormatErrorWithVAListIntoBSTR(
      HRESULT   hrIn
    , BSTR *    pbstrInout
    , va_list   valistIn
    );

//////////////////////////////////////////////////////////////////////////////
// String conversion routines
//////////////////////////////////////////////////////////////////////////////

HRESULT
HrAnsiStringToBSTR(
      LPCSTR    pcszAnsiIn
    , BSTR *    pbstrOut
    );

HRESULT
HrConcatenateBSTRs(
      BSTR *    pbstrDstInout
    , BSTR      bstrSrcIn
    );

HRESULT
HrFormatGuidIntoBSTR(
      GUID *    pguidIn
    , BSTR *    pbstrInout
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\debugsrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      Debug.cpp
//
//  Description:
//      Debugging utilities.
//
//  Documentation:
//      Spec\Admin\Debugging.ppt
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <tchar.h>

#if defined( DEBUG )
//
// Include the WINERROR, HRESULT and NTSTATUS codes
//
#include <winerror.dbg>

#include "Common.h"

//
// Constants
//
static const int cchDEBUG_OUTPUT_BUFFER_SIZE = 512;
static const int cchFILEPATHLINESIZE         = 85;
static const int TRACE_OUTPUT_BUFFER_SIZE    = 512;

//
// Globals
//
DWORD       g_TraceMemoryIndex = -1;
DWORD       g_TraceFlagsIndex  = -1;
DWORD       g_ThreadCounter    = 0;
DWORD       g_dwCounter        = 0;
TRACEFLAG   g_tfModule         = mtfNEVER;
LONG        g_lDebugSpinLock   = FALSE;

static CRITICAL_SECTION *   g_pcsTraceLog = NULL;
static HANDLE               g_hTraceLogFile = INVALID_HANDLE_VALUE;
static BOOL                 g_fGlobalMemoryTacking = TRUE;

//
// Strings
//
static const TCHAR g_szNULL[]       = TEXT( "" );
static const TCHAR g_szTrue[]       = TEXT( "True" );
static const TCHAR g_szFalse[]      = TEXT( "False" );
static const TCHAR g_szFileLine[]   = TEXT( "%s(%u):" );
static const TCHAR g_szFormat[]     = TEXT( "%-60s  %-10.10s " );
static const TCHAR g_szUnknown[]    = TEXT( "<unknown>" );


//
// ImageHlp Stuff - not ready for prime time yet.
//
#if defined(IMAGEHLP_ENABLED)
//
// ImageHelp
//
typedef VOID (*PFNRTLGETCALLERSADDRESS)(PVOID*,PVOID*);

HINSTANCE                g_hImageHlp                = NULL;
PFNSYMGETSYMFROMADDR     g_pfnSymGetSymFromAddr     = NULL;
PFNSYMGETLINEFROMADDR    g_pfnSymGetLineFromAddr    = NULL;
PFNSYMGETMODULEINFO      g_pfnSymGetModuleInfo      = NULL;
PFNRTLGETCALLERSADDRESS  g_pfnRtlGetCallersAddress  = NULL;
#endif // IMAGEHLP_ENABLED

//
// Per thread structure.
//
typedef struct _SPERTHREADDEBUG {
    DWORD   dwFlags;
    DWORD   dwStackCounter;
    LPCTSTR pcszName;
} SPerThreadDebug;

//
//  Externs
//
extern LPVOID g_GlobalMemoryList;

//****************************************************************************
//
//  Debugging and Tracing Routines
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//
// void
// DebugIncrementStackDepthCounter( void )
//
// Description:
//      Increases the stack scope depth counter. If "per thread" tracking is
//      on it will increment the "per thread" counter. Otherwise, it will
//      increment the "global" counter.
//
// Arguments:
//      None.
//
// Return Values:
//      None.
//
//////////////////////////////////////////////////////////////////////////////
void
DebugIncrementStackDepthCounter( void )
{
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL )
        {
            ptd->dwStackCounter++;
        } // if: ptd
    } // if: per thread
    else
    {
        InterlockedIncrement( (LONG*) &g_dwCounter );
    } // else: global

} // DebugIncrementStackDepthCounter()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugDecrementStackDepthCounter( void )
//
//  Description:
//      Decreases the stack scope depth counter. If "per thread" tracking is
//      on it will decrement the "per thread" counter. Otherwise, it will
//      decrement the "global" counter.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugDecrementStackDepthCounter( void )
{
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL )
        {
            ptd->dwStackCounter--;
        } // if: ptd
    } // if: per thread
    else
    {
        InterlockedDecrement( (LONG*) &g_dwCounter );
    } // else: global

} // DebugDecrementStackDepthCounter()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugAcquireSpinLock(
//      LONG * pLock
//      )
//
//  Description:
//      Acquires the spin lock pointed to by pLock.
//
//  Arguments:
//      pLock   - Pointer to the spin lock.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugAcquireSpinLock(
    LONG * pLock
    )
{
    for(;;)
    {
        LONG lInitialValue;

        lInitialValue = InterlockedCompareExchange( pLock, TRUE, FALSE );
        if ( lInitialValue == FALSE )
        {
            //
            // Lock acquired.
            //
            break;
        } // if: got lock
        else
        {
            //
            // Sleep to give other thread a chance to give up the lock.
            //
            Sleep( 1 );
        } // if: lock not acquired

    } // for: forever

} // DebugAcquireSpinLock()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugReleaseSpinLock(
//      LONG * pLock
//      )
//
//  Description:
//      Releases the spin lock pointer to by pLock.
//
//  Arguments:
//      pLock       - Pointer to the spin lock.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugReleaseSpinLock(
    LONG * pLock
    )
{
    *pLock = FALSE;

} // DebugReleaseSpinLock()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  IsDebugFlagSet(
//      TRACEFLAG   tfIn
//      )
//
//  Description:
//      Checks the global g_tfModule and the "per thread" Trace Flags to
//      determine if the flag (any of the flags) are turned on.
//
//  Arguments:
//      tfIn        - Trace flags to compare.
//
//  Return Values:
//      TRUE        At least of one of the flags are present.
//      FALSE       None of the flags match.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
IsDebugFlagSet(
    TRACEFLAG   tfIn
    )
{
    if ( g_tfModule & tfIn )
    {
        return TRUE;
    } // if: global flag set

    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL
          && ptd->dwFlags & tfIn
           )
        {
            return TRUE;
        }   // if: per thread flag set

    } // if: per thread settings

    return FALSE;

} //*** IsDebugFlagSet()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugOutputString(
//      LPCTSTR pszIn
//      )
//
//  Description:
//      Dumps the spew to the appropriate orafice.
//
//  Arguments:
//      pszIn       Message to dump.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugOutputString(
    LPCTSTR pszIn
    )
{
    if ( IsTraceFlagSet( mtfOUTPUTTODISK ) )
    {
        TraceLogMsgNoNewline( pszIn );
    } // if: trace to file
    else
    {
        DebugAcquireSpinLock( &g_lDebugSpinLock );
        OutputDebugString( pszIn );
        DebugReleaseSpinLock( &g_lDebugSpinLock );
        Sleep( 1 );
    } // else: debugger

} //*** DebugOutputString()

#if 0
/*
//////////////////////////////////////////////////////////////////////////////
//++
//  void
//  DebugFindNTStatusSymbolicName(
//      DWORD   dwStatusIn,
//      LPTSTR  pszNameOut,
//      LPDWORD pcchNameInout
//  )
//
//  Description:
//      Uses the NTBUILD generated ntstatusSymbolicNames table to lookup
//      the symbolic name for the status code. The name will be returned in
//      pszNameOut. pcchNameInout should indicate the size of the buffer that
//      pszNameOut points too. pcchNameInout will return the number of
//      characters copied out.
//
//  Arguments:
//      dwStatusIn    - Status code to lookup.
//      pszNameOut    - Buffer to store the string name
//      pcchNameInout - The length of the buffer in and the size out.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugFindNTStatusSymbolicName(
    NTSTATUS dwStatusIn,
    LPTSTR   pszNameOut,
    LPDWORD  pcchNameInout
    )
{
    Assert( pszNameOut != NULL );
    Assert( pcchNameInout != NULL );
    int idx = 0;

    while ( ntstatusSymbolicNames[ idx ].SymbolicName
          )
    {
        if ( ntstatusSymbolicNames[ idx ].MessageId == dwStatusIn
           )
        {
#if defined ( UNICODE )
            *pcchNameInout = mbstowcs( pszNameOut, ntstatusSymbolicNames[ idx ].SymbolicName, *pcchNameInout );
            Assert( *pcchNameInout != -1 );
#else // ASCII
            _tcsncpy( pszNameOut, ntstatusSymbolicNames[ idx ].SymbolicName, *pcchNameInout );
            *pcchNameInout = _tcslen( pszNameOut );
#endif // UNICODE
            return;

        } // if: matched

        idx++;

    } // while: entries in list

    //
    // If we made it here, we did not find an entry.
    //
    _tcsncpy( pszNameOut, g_szUnknown, *pcchNameInout );
    *pcchNameInout = StrLen( pszNameOut );
    return;

} //*** DebugFindNTStatusSymbolicName()
*/
#endif

//////////////////////////////////////////////////////////////////////////////
//++
//  void
//  DebugFindWinerrorSymbolicName(
//      DWORD   dwErrIn,
//      LPTSTR  pszNameOut,
//      LPDWORD pcchNameInout
//  )
//
//  Description:
//      Uses the NTBUILD generated winerrorSymbolicNames table to lookup
//      the symbolic name for the error code. The name will be returned in
//      pszNameOut. pcchNameInout should indicate the size of the buffer that
//      pszNameOut points too. pcchNameInout will return the number of
//      characters copied out.
//
//  Arguments:
//      dwErrIn       - Error code to lookup.
//      pszNameOut    - Buffer to store the string name
//      pcchNameInout - The length of the buffer in and the size out.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugFindWinerrorSymbolicName(
    DWORD dwErrIn,
    LPTSTR  pszNameOut,
    LPDWORD pcchNameInout
    )
{
    Assert( pszNameOut != NULL );
    Assert( pcchNameInout != NULL );
    int idx = 0;
    DWORD scode;
    static LPCTSTR s_pszS_FALSE = TEXT("S_FALSE / ERROR_INVALID_FUNCTION");

    //
    // If this is a Win32 wrapped in HRESULT stuff, remove the
    // HRESULT stuff so that the code will be found in the table.
    //
    if ( SCODE_FACILITY( dwErrIn ) == FACILITY_WIN32 )
    {
        scode = SCODE_CODE( dwErrIn );
    } // if: Win32 error code
    else
    {
        scode = dwErrIn;
    } // else: not Win32 error code

    if ( scode == S_FALSE )
    {
        _tcsncpy( pszNameOut, s_pszS_FALSE, *pcchNameInout );
        *pcchNameInout = _tcslen( pszNameOut );
        return;
    }

    while ( winerrorSymbolicNames[ idx ].SymbolicName )
    {
        if ( winerrorSymbolicNames[ idx ].MessageId == scode )
        {
#if defined ( UNICODE )
            *pcchNameInout = mbstowcs( pszNameOut, winerrorSymbolicNames[ idx ].SymbolicName, *pcchNameInout );
            Assert( *pcchNameInout != -1 );
#else // ASCII
            _tcsncpy( pszNameOut, winerrorSymbolicNames[ idx ].SymbolicName, *pcchNameInout );
            *pcchNameInout = _tcslen( pszNameOut );
#endif // UNICODE
            return;

        } // if: matched

        idx++;

    } // while: entries in list

    //
    // If we made it here, we did not find an entry.
    //
    _tcsncpy( pszNameOut, g_szUnknown, *pcchNameInout );
    *pcchNameInout = _tcslen( pszNameOut );
    return;

} //*** DebugFindWinerrorSymbolicName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugReturnMessage(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPTSTR      pszBufIn,
//      INT *       pcchInout,
//      LPTSTR *    ppszBufOut
//      )
//
//  Description:
//      Prints the spew for a function return with error code.
//
//      The primary reason for doing this is to isolate the stack from adding
//      the extra size of szSymbolicName to every function.
//
//  Argument:
//      pszFileIn   - File path to insert
//      nLineIn     - Line number to insert
//      pszModuleIn - Module name to insert
//      pszBufIn    - The buffer to initialize
//      pcchInout   - IN:  Size of the buffer in pszBufIn
//                  - OUT: Remaining characters in buffer not used.
//      ppszBufOut  - Next location to write to append more text
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugReturnMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszMessageIn,
    DWORD       dwErrIn
    )
{
    TCHAR szSymbolicName[ 64 ]; // random
    DWORD cchSymbolicName;

    cchSymbolicName = sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] );
    DebugFindWinerrorSymbolicName( dwErrIn, szSymbolicName, &cchSymbolicName );
    Assert( cchSymbolicName != sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] ) );
    TraceMessage( pszFileIn, nLineIn, pszModuleIn, mtfFUNC, pszMessageIn, dwErrIn, szSymbolicName );

} //*** DebugReturnMessage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugInitializeBuffer(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPTSTR      pszBufIn,
//      INT *       pcchInout,
//      LPTSTR *    ppszBufOut
//      )
//
//  Description:
//      Intializes the output buffer with "File(Line)  Module  ".
//
//  Argument:
//      pszFileIn   - File path to insert
//      nLineIn     - Line number to insert
//      pszModuleIn - Module name to insert
//      pszBufIn    - The buffer to initialize
//      pcchInout   - IN:  Size of the buffer in pszBufIn
//                  - OUT: Remaining characters in buffer not used.
//      ppszBufOut  - Next location to write to append more text
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugInitializeBuffer(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPTSTR      pszBufIn,
    INT *       pcchInout,
    LPTSTR *    ppszBufOut
    )
{
    INT cch = 0;

    static TCHAR szBarSpace[] =
        TEXT("| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | ");
        //                      1                   2                   3                   4                   5
        //    1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0

    //
    // Add date/time stamp
    //
    if ( IsTraceFlagSet( mtfADDTIMEDATE ) )
    {
        static TCHAR      szBuffer[ 25 ];
        static SYSTEMTIME OldSystemTime = { 0 };

        SYSTEMTIME SystemTime;
        int        iCmp;

        GetLocalTime( &SystemTime );

        //
        // Avoid expensive printf by comparing times
        //
        iCmp = memcmp( (PVOID)&SystemTime, (PVOID)&OldSystemTime, sizeof( SYSTEMTIME ) );
        if ( iCmp != 0 )
        {
            cch = _sntprintf( szBuffer,
                              25,
                              TEXT("%02u/%02u/%04u %02u:%02u:%02u.%03u "),
                              SystemTime.wMonth,
                              SystemTime.wDay,
                              SystemTime.wYear,
                              SystemTime.wHour,
                              SystemTime.wMinute,
                              SystemTime.wSecond,
                              SystemTime.wMilliseconds
                              );

            if ( cch != 24 )
            {
                DEBUG_BREAK;    // can't assert!
            } // if: cch != 24

        } // if: didn't match

        _tcscpy( pszBufIn, szBuffer );
        cch = 24;

    } // if: time/date
    else
    {
        //
        // Add the filepath and line number
        //
        if ( pszFileIn != NULL )
        {
            LPTSTR psz;

            cch = _sntprintf( pszBufIn, *pcchInout, g_szFileLine, pszFileIn, nLineIn );
            if ( cch < 0 )
            {
                cch = _tcslen( pszBufIn );
            } // if: error
        }

        if (    ( IsDebugFlagSet( mtfSTACKSCOPE )
               && IsDebugFlagSet( mtfFUNC )
                )
          || pszFileIn != NULL
           )
        {
            LPTSTR psz;

            for ( psz = pszBufIn + cch; cch < cchFILEPATHLINESIZE; cch++ )
            {
                *psz = 32;
                psz++;
            } // for: cch
            *psz = 0;

            if ( cch != cchFILEPATHLINESIZE )
            {
                DEBUG_BREAK;    // can't assert!
            } // if: cch != cchFILEPATHLINESIZE

        } // if: have a filepath or ( scoping and func is on )

    } // else: normal (no time/date)

    //
    // Add module name
    //
    if ( IsTraceFlagSet( mtfBYMODULENAME ) )
    {
        if ( pszModuleIn == NULL )
        {
            _tcscpy( pszBufIn + cch, g_szUnknown );
            cch += sizeof( g_szUnknown ) / sizeof( g_szUnknown[ 0 ] ) - 1;

        } // if:
        else
        {
            static LPCTSTR pszLastTime = NULL;
            static DWORD   cchLastTime = 0;

            _tcscpy( pszBufIn + cch, pszModuleIn );
            if ( pszLastTime != pszModuleIn )
            {
                pszLastTime = pszModuleIn;
                cchLastTime = _tcslen( pszModuleIn );
            } // if: not the same as last time

            cch += cchLastTime;

        } // else:

        _tcscat( pszBufIn + cch, TEXT(": ") );
        cch += 2;

    } // if: add module name

    //
    // Add the thread id if "per thread" tracing is on.
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        //
        // And check the "per thread" to see if this particular thread
        // is supposed to be displaying its ID.
        //
        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL
          && ptd->dwFlags & mtfPERTHREADTRACE
           )
        {
            int cchPlus;
            cchPlus = _sntprintf( pszBufIn + cch,
                                 *pcchInout - cch,
                                 TEXT("~%08x~ "),
                                 GetCurrentThreadId()
                                 );
            if ( cchPlus < 0 )
            {
                cch = _tcslen( pszBufIn );
            } // if: failure
            else
            {
                cch += cchPlus;
            } // else: success

        } // if: turned on in the thread

    } // if: tracing by thread

    *ppszBufOut = pszBufIn + cch;
    *pcchInout -= cch;

    //
    // Add the "Bar Space" for stack scoping
    //

    // Both flags must be set
    if ( IsDebugFlagSet( mtfSTACKSCOPE )
      && IsDebugFlagSet( mtfFUNC )
       )
    {
        DWORD dwCounter;

        //
        // Choose "per thread" or "global" counter.
        //
        if ( g_tfModule & mtfPERTHREADTRACE )
        {
            SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
            if ( ptd != NULL )
            {
                dwCounter = ptd->dwStackCounter;
            } // if: ptd
            else
            {
                dwCounter = 0;
            } // else: assume its not initialized yet

        } // if: per thread
        else
        {
            dwCounter = g_dwCounter;
        } // else: global counter

        if ( dwCounter >= 50 )
        {
            DEBUG_BREAK;    // can't assert!
        } // if: dwCounter not vaild

        if ( dwCounter > 1
          && dwCounter < 50
           )
        {
            INT nCount = ( dwCounter - 1 ) * 2;
            _tcsncpy( *ppszBufOut, szBarSpace, nCount + 1 ); // extra character for bug in StrNCpyNXW()
            *ppszBufOut += nCount;
            *pcchInout -= nCount;
        } // if: within range

    } // if: stack scoping on

} //*** DebugInitializeBuffer()

#if defined(IMAGEHLP_ENABLED)
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  FALSE
//  DebugNoOp( void )
//
//  Description:
//      Returns FALSE. Used to replace ImageHlp routines it they weren't
//      loaded or not found.
//
//  Arguments:
//      None.
//
//  Return Values:
//      FALSE, always.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
DebugNoOp( void )
{
    return FALSE;

} //*** DebugNoOp()
*/
#endif // IMAGEHLP_ENABLED

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugInitializeTraceFlags( void )
//
//  Description:
//      Retrieves the default tracing flags for this module from an INI file
//      that is named the same as the EXE file (e.g. MMC.EXE -> MMC.INI).
//      Typically, this is called from the TraceInitializeProcess() macro.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugInitializeTraceFlags( BOOL fGlobalMemoryTackingIn )
{
    TCHAR  szSection[ 64 ];
    TCHAR  szFiles[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    TCHAR  szPath[ MAX_PATH ];
    LPTSTR psz;
    DWORD  dwLen;

    g_fGlobalMemoryTacking = fGlobalMemoryTackingIn;

    //
    // Allocate TLS for memory tracking
    //
    if ( !g_fGlobalMemoryTacking )
    {
        Assert( g_TraceMemoryIndex == -1 );
        g_TraceMemoryIndex = TlsAlloc();
        TlsSetValue( g_TraceMemoryIndex, NULL);
    } // if:

    //
    // Initialize module trace flags
    //

    //
    // Get the EXEs filename and change the extension to INI.
    //
    dwLen = GetModuleFileName( NULL, szPath, MAX_PATH );
    Assert( dwLen != 0 ); // error in GetModuleFileName
    _tcscpy( &szPath[ dwLen - 3 ], TEXT("ini") );
    g_tfModule = (TRACEFLAG) GetPrivateProfileInt( __MODULE__, TEXT("TraceFlags"), 0, szPath );
    DebugMsg( TEXT("DEBUG: Reading %s") SZ_NEWLINE TEXT("%s: DEBUG: g_tfModule = 0x%08x"), szPath, __MODULE__, g_tfModule );

    //
    // Initialize thread trace flags
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        Assert( g_TraceFlagsIndex == -1 );
        g_TraceFlagsIndex = TlsAlloc();
        DebugInitializeThreadTraceFlags( NULL );
    } // if: per thread tracing

    //
    // Force the loading of certain modules
    //
    GetPrivateProfileString( __MODULE__, TEXT("ForcedDLLsSection"), g_szNULL, szSection, 64, szPath );
    ZeroMemory( szFiles, sizeof( szFiles ) );
    GetPrivateProfileSection( szSection, szFiles, sizeof( szFiles ), szPath );
    psz = szFiles;
    while ( *psz )
    {
        TCHAR szExpandedPath[ MAX_PATH ];
        ExpandEnvironmentStrings( psz, szExpandedPath, MAX_PATH );
        DebugMsg( TEXT("DEBUG: Forcing %s to be loaded."), szExpandedPath );
        LoadLibrary( szExpandedPath );
        psz += _tcslen( psz ) + 1;
    } // while: entry found

#if defined(IMAGEHLP_ENABLED)
    /*
    //
    // Load symbols for our module
    //
    g_hImageHlp = LoadLibraryEx( TEXT("imagehlp.dll"), NULL, 0 );
    if ( g_hImageHlp != NULL )
    {
        // Typedef this locally since it is only needed once.
        typedef BOOL (*PFNSYMINITIALIZE)(HANDLE, PSTR, BOOL);
        PFNSYMINITIALIZE pfnSymInitialize;
        pfnSymInitialize = (PFNSYMINITIALIZE) GetProcAddress( g_hImageHlp, "SymInitialize" );
        if ( pfnSymInitialize != NULL )
        {
            pfnSymInitialize( GetCurrentProcess(), NULL, TRUE );
        } // if: got address

        //
        // Grab the other addresses we need. Replace them with a "no op" if they are not found
        //
        g_pfnSymGetSymFromAddr  = (PFNSYMGETSYMFROMADDR)    GetProcAddress( g_hImageHlp, "SymGetSymFromAddr"    );
        g_pfnSymGetLineFromAddr = (PFNSYMGETLINEFROMADDR)   GetProcAddress( g_hImageHlp, "SymGetLineFromAddr"   );
        g_pfnSymGetModuleInfo   = (PFNSYMGETMODULEINFO)     GetProcAddress( g_hImageHlp, "SymGetModuleInfo"     );

    } // if: imagehlp loaded

    //
    // If loading IMAGEHLP failed, we need to point these to the "no op" routine.
    //
    if ( g_pfnSymGetSymFromAddr == NULL )
    {
        g_pfnSymGetSymFromAddr = (PFNSYMGETSYMFROMADDR) &DebugNoOp;
    } // if: failed
    if ( g_pfnSymGetLineFromAddr == NULL )
    {
        g_pfnSymGetLineFromAddr = (PFNSYMGETLINEFROMADDR) &DebugNoOp;
    } // if: failed
    if ( g_pfnSymGetModuleInfo == NULL )
    {
        g_pfnSymGetModuleInfo = (PFNSYMGETMODULEINFO) &DebugNoOp;
    } // if: failed

    HINSTANCE hMod = LoadLibrary( TEXT("NTDLL.DLL") );
    g_pfnRtlGetCallersAddress = (PFNRTLGETCALLERSADDRESS) GetProcAddress( hMod, "RtlGetCallersAddress" );
    if ( g_pfnRtlGetCallersAddress == NULL )
    {
        g_pfnRtlGetCallersAddress = (PFNRTLGETCALLERSADDRESS) &DebugNoOp;
    } // if: failed
    */
#endif // IMAGEHLP_ENABLED

} //*** DebugInitializeTraceFlags()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugTerminateProcess( void )
//
//  Description:
//      Cleans up anything that the debugging routines allocated or
//      initialized. Typically, you should call the TraceTerminateProcess()
//      macro just before your process exits.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugTerminateProcess( void )
{
#if defined(IMAGEHLP_ENABLED)
    /*
    //
    // ImageHlp Cleanup
    //
    if ( g_hImageHlp != NULL )
    {
        // Typedef this locally since it is only needed once.
        typedef BOOL (*PFNSYMCLEANUP)(HANDLE);
        PFNSYMCLEANUP pfnSymCleanup;
        pfnSymCleanup = (PFNSYMCLEANUP) GetProcAddress( g_hImageHlp, "SymCleanup" );
        if ( pfnSymCleanup != NULL )
        {
            pfnSymCleanup( GetCurrentProcess() );
        } // if: found proc

        FreeLibrary( g_hImageHlp );

    } // if: imagehlp loaded
    */
#endif // IMAGEHLP_ENABLED

    //
    // Free the TLS storage
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        TlsFree( g_TraceFlagsIndex );
    } // if: per thread tracing

    if ( !g_fGlobalMemoryTacking )
    {
        Assert( g_TraceMemoryIndex != -1 );

        TlsFree( g_TraceMemoryIndex );
    } // if:

} //*** DebugTerminateProcess()

#if defined(IMAGEHLP_ENABLED)
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugGetFunctionName(
//      LPSTR pszNameOut,
//      DWORD cchNameIn
//      )
//
//  Description:
//      Retrieves the calling functions name.
//
//  Arguments:
//      pszNameOut  - The buffer that will contain the functions name.
//      cchNameIn   - The size of the the out buffer.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugGetFunctionName(
    LPSTR pszNameOut,
    DWORD cchNameIn
    )
{
    PVOID CallersAddress;
    PVOID CallersCaller;
    BOOL  fSuccess;
    union
    {
        IMAGEHLP_SYMBOL sym;
        BYTE            buf[ 255 ];
    } SymBuf;

    SymBuf.sym.SizeOfStruct = sizeof( SymBuf );

    g_pfnRtlGetCallersAddress( &CallersAddress, &CallersCaller );

    fSuccess = g_pfnSymGetSymFromAddr( GetCurrentProcess(), (LONG) CallersAddress, 0, (PIMAGEHLP_SYMBOL) &SymBuf );
    if ( fSuccess )
    {
        StrCpyNA( pszNameOut, SymBuf.sym.Name, cchNameIn );
    } // if: success
    else
    {
        DWORD dwErr = GetLastError();
        StrCpyNA( pszNameOut, "<unknown>", cchNameIn );
    } // if: failed

} //*** DebugGetFunctionName()
*/
#endif // IMAGEHLP_ENABLED

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugInitializeThreadTraceFlags(
//      LPCTSTR pszThreadNameIn
//      )
//
//  Description:
//      If enabled (g_tfModule & mtfPERTHREADTRACE), retrieves the default
//      tracing flags for this thread from an INI file that is named the
//      same as the EXE file (e.g. MMC.EXE -> MMC.INI). The particular
//      TraceFlag level is determined by either the thread name (handed in
//      as a parameter) or by the thread counter ID which is incremented
//      every time a new thread is created and calls this routine. The
//      incremental name is "ThreadTraceFlags%u".
//
//      This routine is called from the TraceInitliazeThread() macro.
//
//  Arguments:
//      pszThreadNameIn
//          - If the thread has an assoc. name with it, use it instead of the
//          incremented version. NULL indicate no naming.
//
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugInitializeThreadTraceFlags(
    LPCTSTR pszThreadNameIn
    )
{
    //
    // Read per thread flags
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        TCHAR szPath[ MAX_PATH ];
        DWORD dwTraceFlags;
        DWORD dwLen;
        SPerThreadDebug * ptd;
        LPCTSTR pszThreadTraceFlags;

        //
        // Get the EXEs filename and change the extension to INI.
        //

        dwLen = GetModuleFileName( NULL, szPath, sizeof( szPath ) );
        Assert( dwLen != 0 ); // error in GetModuleFileName
        _tcscpy( &szPath[ dwLen - 3 ], TEXT("ini") );


        if ( pszThreadNameIn == NULL )
        {
            TCHAR szThreadTraceFlags[ 50 ];
            //
            // No name thread - use generic name
            //
            _sntprintf( szThreadTraceFlags, sizeof( szThreadTraceFlags ), TEXT("ThreadTraceFlags%u"), g_ThreadCounter );
            dwTraceFlags = GetPrivateProfileInt( __MODULE__, szThreadTraceFlags, 0, szPath );
            InterlockedIncrement( (LONG *) &g_ThreadCounter );
            pszThreadTraceFlags = szThreadTraceFlags;

        } // if: no thread name
        else
        {
            //
            // Named thread
            //
            dwTraceFlags = GetPrivateProfileInt( __MODULE__, pszThreadNameIn, 0, szPath );
            pszThreadTraceFlags = pszThreadNameIn;

        } // else: named thread

        Assert( g_TraceFlagsIndex != 0 );

        ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd == NULL )
        {
            // don't track this.
            ptd = (SPerThreadDebug *) HeapAlloc( GetProcessHeap(), 0, sizeof( SPerThreadDebug ) );
            ptd->dwStackCounter = 0;

            TlsSetValue( g_TraceFlagsIndex, ptd );
        } // if: ptd

        if ( ptd != NULL )
        {
            ptd->dwFlags = dwTraceFlags;
            if ( pszThreadNameIn == NULL )
            {
                ptd->pcszName = g_szUnknown;
            } // if: no name
            else
            {
                ptd->pcszName = pszThreadNameIn;
            } // else: give it a name

        } // if: ptd

        DebugMsg( TEXT("DEBUG: Starting ThreadId = 0x%08x - %s = 0x%08x"),
                  GetCurrentThreadId(),
                  pszThreadTraceFlags,
                  dwTraceFlags
                  );

    } // if: per thread tracing turned on

} //*** DebugInitializeThreadTraceFlags()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugThreadRundownTraceFlags( void )
//
//  Description:
//      Cleans up the mess create by DebugInitializeThreadTraceFlags(). One
//      should use the TraceThreadRundown() macro instead of calling this
//      directly.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugThreadRundownTraceFlags( void )
{
    //
    // If "per thread" is on, clean up the memory allocation.
    //
    if ( g_tfModule & mtfPERTHREADTRACE )
    {
        Assert( g_TraceFlagsIndex != -1 );

        SPerThreadDebug * ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
        if ( ptd != NULL )
        {
            HeapFree( GetProcessHeap(), 0, ptd );
            TlsSetValue( g_TraceFlagsIndex, NULL );
        } // if: ptd

    } // if: per thread

} // DebugThreadRundownTraceFlags()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII version
//
//  void
//  TraceMsg(
//      TRACEFLAG   tfIn,
//      LPCSTR      pszFormatIn,
//      ...
//      )
//
//  Description:
//      If any of the flags in trace flags match any of the flags set in
//      tfIn, the formatted string will be printed to the debugger.
//
//  Arguments:
//      tfIn        - Flags to be checked.
//      pszFormatIn - Formatted string to spewed to the debugger.
//      ...         - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceMsg(
    TRACEFLAG   tfIn,
    LPCSTR      pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR  pszBuf;
        int     cchSize = sizeof( szBuf );

        DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

#ifdef UNICODE
        //
        // Convert the format buffer to wide chars
        //
        WCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        mbstowcs( szFormat, pszFormatIn, strlen( pszFormatIn ) + 1 );

        va_start( valist, pszFormatIn );
        _vsntprintf( pszBuf, cchSize, szFormat, valist );
        va_end( valist );
        wcscat( pszBuf, SZ_NEWLINE );
#else
        va_start( valist, pszFormatIn );
        _vsntprintf( pszBuf, cchSize, pszFormatIn, valist );
        va_end( valist );
        strcat( pszBuf, ASZ_NEWLINE );
#endif // UNICODE

        DebugOutputString( szBuf );

    } // if: flags set

} //*** TraceMsg() - ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE version
//
//  void
//  TraceMsg(
//      TRACEFLAG   tfIn,
//      LPCWSTR     pszFormatIn,
//      ...
//      )
//
//  Description:
//      If any of the flags in trace flags match any of the flags set in
//      tfIn, the formatted string will be printed to the debugger.
//
//  Arguments:
//      tfIn            - Flags to be checked.
//      pszFormatIn     - Formatted string to spewed to the debugger.
//      ...             - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceMsg(
    TRACEFLAG   tfIn,
    LPCWSTR     pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR  pszBuf;
        int     cchSize = sizeof( szBuf );

        DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

#ifndef UNICODE
        //
        // Convert the format buffer to ascii chars
        //
        CHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

        va_start( valist, pszFormatIn );
        _vsntprintf( pszBuf, cchSize, szFormat, valist );
        va_end( valist );
        strcat( pszBuf, ASZ_NEWLINE );
#else
        va_start( valist, pszFormatIn );
        _vsntprintf( pszBuf, cchSize, pszFormatIn, valist );
        va_end( valist );
        wcscat( pszBuf, SZ_NEWLINE );
#endif // UNICODE

        DebugOutputString( szBuf );

    } // if: flags set

} //*** TraceMsg() - UNICODE

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  TraceMessage(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      TRACEFLAG   tfIn,
//      LPCTSTR     pszFormatIn,
//      ...
//      )
//
//  Description:
//      If any of the flags in trace flags match any of the flags set in
//      tfIn, the formatted string will be printed to the debugger
//      along with the filename, line number and module name supplied. This is
//      used by many of the debugging macros.
//
//  Arguments:
//      pszFileIn       - Source filename.
//      nLineIn         - Source line number.
//      pszModuleIn     - Source module.
//      tfIn            - Flags to be checked.
//      pszFormatIn     - Formatted message to be printed.
//      ...             - Message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCTSTR     pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        INT     cchSize = sizeof( szBuf );
        LPTSTR  psz;

        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &psz );

        va_start( valist, pszFormatIn );
        _vsntprintf( psz, cchSize, pszFormatIn, valist );
        va_end( valist );
        _tcscat( psz, SZ_NEWLINE );

        DebugOutputString( szBuf );
    } // if: flags set

} //*** TraceMessage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  TraceMessageDo(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      TRACEFLAG   tfIn,
//      LPCTSTR     pszFormatIn,
//      LPCTSTR     pszFuncIn,
//      ...
//      )
//
//  Description:
//      Works like TraceMessage() but takes has a function argument that is
//      broken into call/result in the debug spew. This is called from the
//      TraceMsgDo macro.
//
//  Arguments:
//      pszFileIn       - Source filename.
//      nLineIn         - Source line number.
//      pszModuleIn     - Source module.
//      tfIn            - Flags to be checked
//      pszFormatIn     - Formatted return value string
//      pszFuncIn       - The string version of the function call.
//      ...             - Return value from call.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceMessageDo(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    TRACEFLAG   tfIn,
    LPCTSTR     pszFormatIn,
    LPCTSTR     pszFuncIn,
    ...
    )
{
    va_list valist;

    if ( IsDebugFlagSet( tfIn ) )
    {
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        INT     cchSize = sizeof( szBuf );
        LPTSTR  pszBuf;
        int     nLen;
        LPCTSTR psz     = pszFuncIn;

        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );

        //
        // Prime the buffer
        //
        _tcscpy( pszBuf, TEXT("V ") );
        pszBuf += 2;

        //
        // Copy the l-var part of the expression
        //
        while ( *psz
             && *psz != TEXT('=')
              )
        {
            *pszBuf = *psz;
            psz++;
            pszBuf++;

        } // while:

        //
        // Add the " = "
        //
        _tcscpy( pszBuf, TEXT(" = ") );
        pszBuf += 3;

        //
        // Add the formatted result
        //
        va_start( valist, pszFuncIn );
        nLen = _vsntprintf( pszBuf, sizeof( szBuf ) - 2 - (pszBuf - &szBuf[0]), pszFormatIn, valist );
        va_end( valist );
        _tcscat( pszBuf, SZ_NEWLINE );

        DebugOutputString( szBuf );

    } // if: flags set

} //*** TraceMessageDo()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMessage(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszFormatIn,
//      ...
//      )
//
//  Description:
//      Displays a message only in CHKed/DEBUG builds. Also appends the source
//      filename, linenumber and module name to the ouput.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszFormatIn - Formatted message to be printed.
//      ...         - message arguments
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszFormatIn,
    ...
    )
{
    va_list valist;
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    INT     cchSize = sizeof( szBuf );
    LPTSTR  pszBuf;

    DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );

    va_start( valist, pszFormatIn );
    _vsntprintf( pszBuf, cchSize, pszFormatIn, valist );
    va_end( valist );
    _tcscat( pszBuf, SZ_NEWLINE );

    DebugOutputString( szBuf );

} //*** DebugMessage()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMessageDo(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszFormatIn,
//      LPCTSTR     pszFuncIn,
//      ...
//      )
//
//  Description:
//      Just like TraceMessageDo() except in CHKed/DEBUG version it will
//      always spew. The DebugMsgDo macros uses this function.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszFormatIn - Formatted result message.
//      pszFuncIn   - The string version of the function call.
//      ...         - The return value of the function call.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMessageDo(
    LPCTSTR pszFileIn,
    const int nLineIn,
    LPCTSTR pszModuleIn,
    LPCTSTR pszFormatIn,
    LPCTSTR pszFuncIn,
    ...
    )
{
    va_list valist;

    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    INT     cchSize = sizeof( szBuf );
    LPTSTR  pszBuf;
    int     nLen;
    LPCTSTR psz = pszFuncIn;

    DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );

    //
    // Prime the buffer
    //
    _tcscpy( pszBuf, TEXT("V ") );
    pszBuf += 2;

    //
    // Copy the l-var part of the expression
    //
    while ( *psz
         && *psz != TEXT('=')
          )
    {
        *pszBuf = *psz;
        psz++;
        pszBuf++;

    } // while:

    //
    // Add the " = "
    //
    _tcscpy( pszBuf, TEXT(" = ") );
    pszBuf += 3;

    //
    // Add the formatted result
    //
    va_start( valist, pszFuncIn );
    nLen = _vsntprintf( pszBuf, sizeof( szBuf ) - 2 - (pszBuf - &szBuf[ 0 ]), pszFormatIn, valist );
    va_end( valist );
    _tcscat( pszBuf, SZ_NEWLINE );

    DebugOutputString( szBuf );

} //*** DebugMessageDo()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII version
//
//  void
//  DebugMsg(
//      LPCSTR pszFormatIn,
//      ...
//      )
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments. Adds a newline.
//
//  Arguments:
//      pszFormatIn - Formatted message to be printed.
//      ...         - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMsg(
    LPCSTR pszFormatIn,
    ...
    )
{
    va_list valist;
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    int     cchSize = sizeof( szBuf );
    LPTSTR  pszBuf;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

    // CScutaru 25-APR-2000:
    // Added this assert. Maybe Geoff will figure out better what to do with this case.
    Assert( pszFormatIn != NULL );

#ifdef UNICODE
    //
    // Convert the format buffer to wide chars
    //
    WCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    mbstowcs( szFormat, pszFormatIn, strlen( pszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    _vsntprintf( pszBuf, cchSize, szFormat, valist );
    va_end( valist );
    wcscat( pszBuf, SZ_NEWLINE );
#else
    va_start( valist, pszFormatIn );
    _vsntprintf( pszBuf, cchSize, pszFormatIn, valist );
    va_end( valist );
    strcat( pszBuf, ASZ_NEWLINE );
#endif // UNICODE

    DebugOutputString( szBuf );

} //*** DebugMsg() - ASCII version

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE version
//
//  void
//  DebugMsg(
//      LPCWSTR pszFormatIn,
//      ...
//      )
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments. Adds a newline.
//
//  Arguments:
//      pszFormatIn - Formatted message to be printed.
//      ...         - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMsg(
    LPCWSTR pszFormatIn,
    ...
    )
{
    va_list valist;
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    int     cchSize = sizeof( szBuf );
    LPTSTR  pszBuf;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

    // CScutaru 25-APR-2000:
    // Added this assert. Maybe Geoff will figure out better what to do with this case.
    Assert( pszFormatIn != NULL );

#ifndef UNICODE
    //
    // Convert the format buffer to ascii chars
    //
    CHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    _vsntprintf( pszBuf, cchSize, szFormat, valist );
    va_end( valist );
    strcat( pszBuf, ASZ_NEWLINE );
#else
    va_start( valist, pszFormatIn );
    _vsntprintf( pszBuf, cchSize, pszFormatIn, valist );
    va_end( valist );
    wcscat( pszBuf, SZ_NEWLINE );
#endif // UNICODE

    DebugOutputString( szBuf );

} //*** DebugMsg() - UNICODE version

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII version
//
//  void
//  DebugMsgNoNewline(
//      LPCSTR pszFormatIn,
//      ...
//      )
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments. Does not add a newline.
//
//  Arguments:
//      pszFormatIn - Formatted message to be printed.
//      ...         - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMsgNoNewline(
    LPCSTR pszFormatIn,
    ...
    )
{
    va_list valist;
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    int     cchSize = sizeof( szBuf );
    LPTSTR  pszBuf;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

    // CScutaru 25-APR-2000:
    // Added this assert. Maybe Geoff will figure out better what to do with this case.
    Assert( pszFormatIn != NULL );

#ifdef UNICODE
    //
    // Convert the format buffer to wide chars
    //
    WCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    mbstowcs( szFormat, pszFormatIn, strlen( pszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    _vsntprintf( pszBuf, cchSize, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormatIn );
    _vsntprintf( pszBuf, cchSize, pszFormatIn, valist);
    va_end( valist );
#endif // UNICODE

    DebugOutputString( szBuf );

} //*** DebugMsgNoNewline() - ASCII version

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE version
//
//  void
//  DebugMsgNoNewline(
//      LPCWSTR pszFormatIn,
//      ...
//      )
//
//  Description:
//      In CHKed/DEBUG version, prints a formatted message to the debugger. This
//      is a NOP in REAIL version. Helpful for putting in quick debugging
//      comments. Does not add a newline.
//
//  Arguments:
//      pszFormatIn - Formatted message to be printed.
//      ...         - Arguments for the message.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
DebugMsgNoNewline(
    LPCWSTR pszFormatIn,
    ...
    )
{
    va_list valist;
    TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    int     cchSize = sizeof( szBuf );
    LPTSTR  pszBuf;

    DebugInitializeBuffer( NULL, 0, __MODULE__, szBuf, &cchSize, &pszBuf );

    // CScutaru 25-APR-2000:
    // Added this assert. Maybe Geoff will figure out better what to do with this case.
    Assert( pszFormatIn != NULL );

#ifndef UNICODE
    //
    // Convert the format buffer to ascii chars
    //
    CHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    _vsntprintf( pszBuf, cchSize, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormatIn );
    _vsntprintf( pszBuf, cchSize, pszFormatIn, valist);
    va_end( valist );
#endif // UNICODE

    DebugOutputString( szBuf );

} //*** DebugMsgNoNewline() - UNICODE version


//////////////////////////////////////////////////////////////////////////////
//++
//
//  BOOL
//  AssertMessage(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszfnIn,
//      BOOL        fTrueIn,
//      ...
//      )
//
//  Description:
//      Displays a dialog box with the failed assertion. User has the option of
//      breaking. The Assert macro calls this to display assertion failures.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszfnIn     - String version of the expression to assert.
//      fTrueIn     - Result of the evaluation of the expression.
//      ...         - Message arguments
//
//  Return Values:
//      TRUE    - Caller should call DEBUG_BREAK.
//      FALSE   - Caller should not call DEBUG_BREAK.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
AssertMessage(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    BOOL        fTrueIn,
    ...
    )
{
    BOOL fTrue = fTrueIn;

    if ( ! fTrueIn )
    {
        LRESULT lResult;
        TCHAR   szBufMsg[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        int     cchSize = sizeof( szBuf );
        TCHAR   szFileLine[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR  pszBuf;
        LPCTSTR pszfn = pszfnIn;
        va_list valist;

        //
        // Output a debug message.
        //
        va_start( valist, fTrueIn );
        _vsntprintf( szBufMsg, ARRAYSIZE( szBufMsg ), pszfnIn, valist );
        va_end( valist );
        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );
        _sntprintf( pszBuf, cchSize, TEXT("ASSERT: %s") SZ_NEWLINE, szBufMsg );
        DebugOutputString( szBuf );

        //
        // Display an assert message.
        //
        _sntprintf( szBuf,
                    sizeof( szBuf ),
                    TEXT("Module:\t%s\t\n")
                      TEXT("Line:\t%u\t\n")
                      TEXT("File:\t%s\t\n\n")
                      TEXT("Assertion:\t%s\t\n\n")
                      TEXT("Do you want to break here?"),
                    pszModuleIn,
                    nLineIn,
                    pszFileIn,
                    szBufMsg
                    );

        LogMsg( SZ_NEWLINE TEXT("Assertion Failed!") SZ_NEWLINE SZ_NEWLINE TEXT("%s") SZ_NEWLINE, szBuf );

        if ( g_tfModule & mtfSHOWASSERTS )
        {
            lResult = MessageBox( NULL, szBuf, TEXT("Assertion Failed!"), MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND );
            if ( lResult == IDNO )
            {
                fTrue = TRUE;   // don't break
            } // if:
        } // if:
        else
        {
            fTrue = TRUE;   // don't break
        } // else:

    } // if: assert false

    return ! fTrue;

} //*** AssertMessage()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  TraceHR(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszfnIn,
//      HRESULT     hrIn,
//      BOOL        fSuccessIn,
//      HRESULT     hrIgnoreIn,
//      ...
//      )
//
//  Description:
//      Traces HRESULT errors. A dialog will appear if the hrIn is not equal
//      to S_OK. The dialog will ask if the user wants to break-in or continue
//      execution. This is called from the THR macro.
//
//  Arguments:
//      pszFileIn   - Source filename.
//      nLineIn     - Source line number.
//      pszModuleIn - Source module name.
//      pszfnIn     - String version of the function call.
//      hrIn        - HRESULT of the function call.
//      fSuccessIn  - If TRUE, only if FAILED( hr ) is TRUE will it report.
//      hrIgnoreIn  - HRESULT to ignore.
//      ...         - Message arguments
//
//  Return Values:
//      Whatever hrIn is.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
TraceHR(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    HRESULT     hrIn,
    BOOL        fSuccessIn,
    HRESULT     hrIgnoreIn,
    ...
    )
{
    HRESULT         hr;
    static LPCTSTR  s_szS_FALSE = TEXT("S_FALSE");

    // If ignoring success statuses and no failure occurred, set hrIn to
    // something we always ignore (S_OK).  This simplifies the if condition
    // below.
    if ( fSuccessIn && ! FAILED( hrIn ) )
    {
        hr = S_OK;
    }
    else
    {
        hr = hrIn;
    }

    if ( ( hr != S_OK )
      && ( hr != hrIgnoreIn )
      )
    {
        TCHAR   szSymbolicName[ 64 ]; // random
        DWORD   cchSymbolicName;
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        int     cchSize = sizeof( szBuf );
        LPTSTR  pszBuf;
        LPTSTR  pszMsgBuf;
        LRESULT lResult;

        bool    fAllocatedMsg   = false;

        switch ( hr )
        {
        case S_FALSE:
            pszMsgBuf = (LPTSTR) s_szS_FALSE;

            //
            // Find the symbolic name for this error.
            //
            cchSymbolicName = sizeof( s_szS_FALSE ) / sizeof( s_szS_FALSE[ 0 ] );
            Assert( cchSymbolicName <= sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] ) );
            _tcscpy( szSymbolicName, s_szS_FALSE );
            break;

        default:
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
                (LPTSTR) &pszMsgBuf,
                0,
                NULL
                );

            //
            // Make sure everything is cool before we blow up somewhere else.
            //
            if ( pszMsgBuf == NULL )
            {
                pszMsgBuf = TEXT("<unknown error code returned>");
            } // if: status code not found
            else
            {
                fAllocatedMsg = true;
            } // else: found the status code

            //
            // Find the symbolic name for this error.
            //
            cchSymbolicName = sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] );
            DebugFindWinerrorSymbolicName( hr, szSymbolicName, &cchSymbolicName );
            Assert( cchSymbolicName != sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] ) );

            break;
        } // switch: hr

        Assert( pszFileIn != NULL );
        Assert( pszModuleIn != NULL );
        Assert( pszfnIn != NULL );

        //
        // Spew it to the debugger.
        //
        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );
        _sntprintf( pszBuf,
                    cchSize,
                    TEXT("*HRESULT* hr = 0x%08x (%s) - %s") SZ_NEWLINE,
                    hr,
                    szSymbolicName,
                    pszMsgBuf
                    );
        DebugOutputString( szBuf );

        //
        // If trace flag set, generate a pop-up.
        //
        if ( IsTraceFlagSet( mtfASSERT_HR ) )
        {
            TCHAR   szBufMsg[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
            va_list valist;

            va_start( valist, hrIgnoreIn );
            _vsntprintf( szBufMsg, ARRAYSIZE( szBufMsg ), pszfnIn, valist );
            va_end( valist );

            _sntprintf( szBuf,
                        sizeof( szBuf ),
                        TEXT("Module:\t%s\t\n")
                          TEXT("Line:\t%u\t\n")
                          TEXT("File:\t%s\t\n\n")
                          TEXT("Function:\t%s\t\n")
                          TEXT("hr =\t0x%08x (%s) - %s\t\n")
                          TEXT("Do you want to break here?"),
                        pszModuleIn,
                        nLineIn,
                        pszFileIn,
                        szBufMsg,
                        hr,
                        szSymbolicName,
                        pszMsgBuf
                        );

            lResult = MessageBox( NULL, szBuf, TEXT("Trace HRESULT"), MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND );
            if ( lResult == IDYES )
            {
                DEBUG_BREAK;

            } // if: break
        } // if: asserting on non-success HRESULTs

        if ( fAllocatedMsg )
        {
            HeapFree( GetProcessHeap(), 0, pszMsgBuf );
        } // if: message buffer was allocated by FormateMessage()

    } // if: hr != S_OK

    return hrIn;

} //*** TraceHR()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ULONG
//  TraceWin32(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPCTSTR     pszfnIn,
//      ULONG       ulErrIn,
//      ...
//      )
//
//  Description:
//      Traces WIN32 errors. A dialog will appear is the ulErrIn is not equal
//      to ERROR_SUCCESS. The dialog will ask if the user wants to break-in or
//      continue execution.
//
//  Arguments:
//      pszFileIn       - Source filename.
//      nLineIn         - Source line number.
//      pszModuleIn     - Source module name.
//      pszfnIn         - String version of the function call.
//      ulErrIn         - Error code to check.
//      ulErrIgnoreIn   - Error code to ignore.
//      ...             - Message arguments
//
//  Return Values:
//      Whatever ulErrIn is.
//
//--
//////////////////////////////////////////////////////////////////////////////
ULONG
TraceWin32(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPCTSTR     pszfnIn,
    ULONG       ulErrIn,
    ULONG       ulErrIgnoreIn,
    ...
    )
{
    if ( ( ulErrIn != ERROR_SUCCESS )
      && ( ulErrIn != ulErrIgnoreIn ) )
    {
        TCHAR   szSymbolicName[ 64 ]; // random
        DWORD   cchSymbolicName;
        TCHAR   szBuf[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        int     cchSize = sizeof( szBuf );
        LPTSTR  pszBuf;
        LPTSTR  pszMsgBuf;
        LRESULT lResult;

        bool    fAllocatedMsg   = false;

        //
        // Translate the error code to a text message.
        //
        FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER
            | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            ulErrIn,
            MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), // Default language
            (LPTSTR) &pszMsgBuf,
            0,
            NULL
            );

        //
        // Make sure everything is cool before we blow up somewhere else.
        //
        if ( pszMsgBuf == NULL )
        {
            pszMsgBuf = TEXT("<unknown error code returned>");
        } // if: status code not found
        else
        {
            fAllocatedMsg = true;
        } // else: found the status code

        Assert( pszFileIn != NULL );
        Assert( pszModuleIn != NULL );
        Assert( pszfnIn != NULL );

        //
        // Find the symbolic name for this error.
        //
        cchSymbolicName = sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] );
        DebugFindWinerrorSymbolicName( ulErrIn, szSymbolicName, &cchSymbolicName );
        Assert( cchSymbolicName != sizeof( szSymbolicName ) / sizeof( szSymbolicName[ 0 ] ) );

        //
        // Spew it to the debugger.
        //
        DebugInitializeBuffer( pszFileIn, nLineIn, pszModuleIn, szBuf, &cchSize, &pszBuf );
        _sntprintf( pszBuf,
                    cchSize,
                    TEXT("*WIN32Err* ulErr = %u (%s) - %s") SZ_NEWLINE,
                    ulErrIn,
                    szSymbolicName,
                    pszMsgBuf
                    );
        DebugOutputString( szBuf );

        //
        // If trace flag set, invoke a pop-up.
        //
        if ( IsTraceFlagSet( mtfASSERT_HR ) )
        {
            TCHAR   szBufMsg[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
            va_list valist;

            va_start( valist, ulErrIgnoreIn );
            _vsntprintf( szBufMsg, ARRAYSIZE( szBufMsg ), pszfnIn, valist );
            va_end( valist );

            _sntprintf( szBuf,
                        sizeof( szBuf ),
                        TEXT("Module:\t%s\t\n")
                          TEXT("Line:\t%u\t\n")
                          TEXT("File:\t%s\t\n\n")
                          TEXT("Function:\t%s\t\n")
                          TEXT("ulErr =\t%u (%s) - %s\t\n")
                          TEXT("Do you want to break here?"),
                        pszModuleIn,
                        nLineIn,
                        pszFileIn,
                        szBufMsg,
                        ulErrIn,
                        szSymbolicName,
                        pszMsgBuf
                        );

            lResult = MessageBox( NULL, szBuf, TEXT("Trace Win32"), MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND );
            if ( lResult == IDYES )
            {
                DEBUG_BREAK;

            } // if: break
        } // if: asserting on non-success status codes

        if ( fAllocatedMsg )
        {
            HeapFree( GetProcessHeap(), 0, pszMsgBuf );
        } // if: message buffer was allocated by FormateMessage()

    } // if: ulErrIn != ERROR_SUCCESS && != ulErrIgnoreIn

    return ulErrIn;

} //*** TraceWin32()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrTraceLogOpen( void )
//
//  Description:
//      This function:
//          - initializes the trace log critical section
//          - enters the trace log critical section assuring only one thread is
//            writing to the trace log at a time
//          - creates the directory tree to the trace log file (if needed)
//          - initializes the trace log file by:
//              - creating a new trace log file if one doesn't exist.
//              - opens an existing trace log file (for append)
//              - appends a time/date stamp that the trace log was (re)opened.
//
//      Use HrTraceLogClose() to exit the log critical section.
//
//      If there is a failure inside this function, the trace log critical
//      section will be released before returning.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK - log critical section held and trace log open successfully
//      Otherwize HRESULT error code.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrTraceLogOpen( void )
{
    TCHAR   szFilePath[ MAX_PATH ];
    TCHAR   szModulePath[ MAX_PATH ];
    CHAR    szBuffer[ TRACE_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HANDLE  hTemp;
    BOOL    fReturn;
    HRESULT hr;

    SYSTEMTIME SystemTime;

    //
    // Create a critical section to prevent lines from being fragmented.
    //
    if ( g_pcsTraceLog == NULL )
    {
        PCRITICAL_SECTION pNewCritSect =
            (PCRITICAL_SECTION) HeapAlloc( GetProcessHeap(), 0, sizeof( CRITICAL_SECTION ) );
        if ( pNewCritSect == NULL )
        {
            DebugMsg( "DEBUG: Out of Memory. Tracing disabled." );
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        } // if: creation failed

        InitializeCriticalSection( pNewCritSect );

        // Make sure we only have one trace log critical section
        InterlockedCompareExchangePointer( (PVOID *) &g_pcsTraceLog, pNewCritSect, 0 );
        if ( g_pcsTraceLog != pNewCritSect )
        {
            DebugMsg( "DEBUG: Another thread already created the CS. Deleting this one." );
            DeleteCriticalSection( pNewCritSect );
            HeapFree( GetProcessHeap(), 0, pNewCritSect );
        } // if: already have another critical section

    } // if: no critical section created yet

    Assert( g_pcsTraceLog != NULL );
    EnterCriticalSection( g_pcsTraceLog );

    //
    // Make sure the trace log file is open
    //
    if ( g_hTraceLogFile == INVALID_HANDLE_VALUE )
    {
        DWORD  dwLen;
        LPTSTR psz;
        //
        // Create the directory tree
        //
        ExpandEnvironmentStrings( TEXT("%windir%\\debug"), szFilePath, MAX_PATH );
        hr = HrCreateDirectoryPath( szFilePath );
        if ( FAILED( hr ) )
        {
            if ( !( g_tfModule & mtfOUTPUTTODISK ) )
            {
                DebugMsg( "*ERROR* Failed to create directory tree %s", szFilePath );
            } // if: not tracing to disk

            goto Error;
        } // if: failed

        //
        // Add filename
        //
        dwLen = GetModuleFileName( g_hInstance, szModulePath, sizeof( szModulePath ) / sizeof( szModulePath[ 0 ] ) );
        Assert( dwLen != 0 );
        _tcscpy( &szModulePath[ dwLen - 3 ], TEXT("log") );
        psz = _tcsrchr( szModulePath, TEXT('\\') );
        Assert( psz != NULL );
        if ( psz == NULL )
        {
            hr = E_POINTER;
            goto Error;
        }
        _tcscat( szFilePath, psz );

        //
        // Create it
        //
        g_hTraceLogFile = CreateFile( szFilePath,
                                 GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_ALWAYS,
                                 FILE_FLAG_WRITE_THROUGH,
                                 NULL
                                 );
        if ( g_hTraceLogFile == INVALID_HANDLE_VALUE )
        {
            if ( !( g_tfModule & mtfOUTPUTTODISK ) )
            {
                DebugMsg( "*ERROR* Failed to create trace log at %s", szFilePath );
            } // if: not tracing to disk

            hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
            goto Error;
        } // if: failed

        // Seek to the end
        SetFilePointer( g_hTraceLogFile, 0, NULL, FILE_END );

        //
        // Write the time/date the trace log was (re)openned.
        //
        GetLocalTime( &SystemTime );
        _snprintf( szBuffer,
                   sizeof( szBuffer ),
                   "*" ASZ_NEWLINE
                     "* %02u/%02u/%04u %02u:%02u:%02u.%03u" ASZ_NEWLINE
                     "*" ASZ_NEWLINE,
                   SystemTime.wMonth,
                   SystemTime.wDay,
                   SystemTime.wYear,
                   SystemTime.wHour,
                   SystemTime.wMinute,
                   SystemTime.wSecond,
                   SystemTime.wMilliseconds
                   );

        fReturn = WriteFile( g_hTraceLogFile, szBuffer, strlen(szBuffer), &dwWritten, NULL );
        if ( ! fReturn )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
            goto Error;
        } // if: failed

        DebugMsg( "DEBUG: Created trace log at %s", szFilePath );

    } // if: file not already openned

    hr = S_OK;

Cleanup:

    return hr;

Error:

    DebugMsg( "HrTaceLogOpen: Failed hr = 0x%08x", hr );

    if ( g_hTraceLogFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( g_hTraceLogFile );
        g_hTraceLogFile = INVALID_HANDLE_VALUE;
    } // if: handle was open

    LeaveCriticalSection( g_pcsTraceLog );

    goto Cleanup;

} //*** HrTraceLogOpen()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrTraceLogClose( void )
//
//  Description:
//      This actually just leaves the log critical section.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK always.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrTraceLogClose( void )
{
    Assert( g_pcsTraceLog != NULL );
    LeaveCriticalSection( g_pcsTraceLog );
    return S_OK;

} //*** HrTraceLogClose()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII
//
//  void
//  TraceLogMsgNoNewline(
//      LPCSTR pszFormat,
//      ...
//      )
//
//  Description:
//      Writes a message to the trace log file without adding a newline.
//
//  Arguments:
//      pszFormat - A printf format string to be printed.
//      ,,,       - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceLogMsgNoNewline(
    LPCSTR pszFormat,
    ...
    )
{
    va_list valist;

    CHAR    szBuf[ TRACE_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HRESULT hr;

#ifdef UNICODE
    WCHAR  szFormat[ TRACE_OUTPUT_BUFFER_SIZE ];
    WCHAR  szTmpBuf[ TRACE_OUTPUT_BUFFER_SIZE ];

    mbstowcs( szFormat, pszFormat, strlen( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szTmpBuf, szFormat, valist);
    va_end( valist );

    dwWritten = wcstombs( szBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
    if ( dwWritten == - 1 )
    {
        dwWritten = strlen( szBuf );
    } // if: bad character found
#else
    va_start( valist, pszFormat );
    dwWritten = wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );
#endif // UNICODE

    hr = HrTraceLogOpen();
    if ( hr != S_OK )
    {
        return;
    } // if: failed

    WriteFile( g_hTraceLogFile, szBuf, dwWritten, &dwWritten, NULL );

    HrTraceLogClose();

} //*** TraceLogMsgNoNewline() ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE
//
//  void
//  TraceLogMsgNoNewline(
//      LPCWSTR pszFormat,
//      ...
//      )
//
//  Description:
//      Writes a message to the trace log file without adding a newline.
//
//  Arguments:
//      pszFormat - A printf format string to be printed.
//      ,,,       - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
TraceLogMsgNoNewline(
    LPCWSTR pszFormat,
    ...
    )
{
    va_list valist;

    CHAR    szBuf[ TRACE_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HRESULT hr;

#ifdef UNICODE
    WCHAR  szTmpBuf[ TRACE_OUTPUT_BUFFER_SIZE ];

    va_start( valist, pszFormat );
    wvsprintf( szTmpBuf, pszFormat, valist);
    va_end( valist );

    dwWritten = wcstombs( szBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
    if ( dwWritten == -1 )
    {
        dwWritten = strlen( szBuf );
    } // if: bad character found
#else
    CHAR szFormat[ TRACE_OUTPUT_BUFFER_SIZE ];

    wcstombs( szFormat, pszFormat, wcslen( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    dwWritten = wvsprintf( szBuf, szFormat, valist);
    va_end( valist );

#endif // UNICODE

    hr = HrTraceLogOpen();
    if ( hr != S_OK )
    {
        return;
    } // if: failed

    WriteFile( g_hTraceLogFile, szBuf, dwWritten, &dwWritten, NULL );

    HrTraceLogClose();

} //*** TraceLogMsgNoNewline() UNICODE

//****************************************************************************
//****************************************************************************
//
//  Memory allocation and tracking
//
//****************************************************************************
//****************************************************************************


//
// This is a private structure and should not be known to the application.
//
typedef struct MEMORYBLOCK
{
    EMEMORYBLOCKTYPE    mbtType;    // What type of memory this is tracking
    union
    {
        void *          pvMem;      // pointer/object to allocated memory to track
        BSTR            bstr;       // BSTR to allocated memory
    };
    DWORD               dwBytes;    // size of the memory
    LPCTSTR             pszFile;    // source filename where memory was allocated
    int                 nLine;      // source line number where memory was allocated
    LPCTSTR             pszModule;  // source module name where memory was allocated
    LPCTSTR             pszComment; // optional comments about the memory
    MEMORYBLOCK *       pNext;      // pointer to next MEMORYBLOCK structure
} MEMORYBLOCK;

//
//  KB: 20-APR-2001 GalenB
//
//  Changing this struct to use a critical section instead of a spin lock.
//  Spin locks are not re-entrant on a thread the way critical sections
//  are.
//
typedef struct MEMORYBLOCKLIST
{
    CRITICAL_SECTION    csList;     // Critical section protecting the list
    MEMORYBLOCK *       pmbList;    // List of MEMORYBLOCKs.
    BOOL                fDeadList;  // The list is dead.
} MEMORYBLOCKLIST;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMemorySpew(
//      MEMORYBLOCK *   pmb,
//      LPTSTR          pszMessage
//      )
//
//  Description:
//      Displays a message about the memory block.
//
//  Arugments:
//      pmb         - pointer to MEMORYBLOCK desciptor.
//      pszMessage  - message to display
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemorySpew(
    MEMORYBLOCK *   pmb,
    LPTSTR          pszMessage
    )
{
    switch ( pmb->mbtType )
    {
        case mmbtMEMORYALLOCATION:
            DebugMessage(
                      pmb->pszFile
                    , pmb->nLine
                    , pmb->pszModule
                    , TEXT("%s 0x%08x (%u bytes) - %s")
                    , pszMessage
                    , pmb->pvMem
                    , pmb->dwBytes
                    , pmb->pszComment
                    );
            break;

        case mmbtSYSALLOCSTRING:
            DebugMessage(
                      pmb->pszFile
                    , pmb->nLine
                    , pmb->pszModule
                    , TEXT("%s 0x%08x - %s {%s}")
                    , pszMessage
                    , pmb->pvMem
                    , pmb->pszComment
                    , (LPTSTR) pmb->pvMem
                    );
            break;

        default:
            DebugMessage(
                      pmb->pszFile
                    , pmb->nLine
                    , pmb->pszModule
                    , TEXT("%s 0x%08x - %s")
                    , pszMessage
                    , pmb->pvMem
                    , pmb->pszComment
                    );
            break;

    } // switch: pmb->mbtType

} //*** DebugMemorySpew()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void *
//  DebugMemoryAddToList(
//        MEMORYBLOCK **    ppmbHeadInout
//      , EMEMORYBLOCKTYPE  mbtTypeIn
//      , void *            hMemIn
//      , LPCTSTR           pszFileIn
//      , const int         nLineIn,
//      , LPCTSTR           pszModuleIn
//      , DWORD             dwBytesIn
//      , LPCTSTR           pszCommentIn
//      )
//
//  Description:
//      Adds memory to be tracked to the thread local memory tracking list.
//
//  Arguments:
//      ppmbHeadInout   - The list to add the memory to.
//      mbtTypeIn       - Type of memory block of the memory to track.
//      hMemIn          - Pointer to memory to track.
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Whatever was in pvMemIn.
//
//--
//////////////////////////////////////////////////////////////////////////////
static void *
DebugMemoryAddToList(
      MEMORYBLOCK **    ppmbHeadInout
    , EMEMORYBLOCKTYPE  mbtTypeIn
    , void *            pvMemIn
    , LPCTSTR           pszFileIn
    , const int         nLineIn
    , LPCTSTR           pszModuleIn
    , DWORD             dwBytesIn
    , LPCTSTR           pszCommentIn
    )
{
    Assert( ppmbHeadInout != NULL );

    if ( pvMemIn != NULL )
    {
        MEMORYBLOCK * pmb = (MEMORYBLOCK *) HeapAlloc( GetProcessHeap(), 0, sizeof( MEMORYBLOCK ) );

        if ( pmb == NULL )
        {
            //
            //  TODO:   23-APR-2001 GalenB
            //
            //  Why are we doing this?  Should we free the tracked allocation simply because we cannot
            //  allocate a tracking object?
            //
            HeapFree( GetProcessHeap(), 0, pvMemIn );
            return NULL;
        } // if: memory block allocation failed

        pmb->mbtType    = mbtTypeIn;
        pmb->pvMem      = pvMemIn;
        pmb->dwBytes    = dwBytesIn;
        pmb->pszFile    = pszFileIn;
        pmb->nLine      = nLineIn;
        pmb->pszModule  = pszModuleIn;
        pmb->pszComment = pszCommentIn;
        pmb->pNext      = (MEMORYBLOCK *) *ppmbHeadInout;

        //
        // Spew if needed
        //
        if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
        {
            DebugMemorySpew( pmb, TEXT("Alloced") );
        } // if: tracing

        *ppmbHeadInout = pmb;
    } // if: something to trace

    return pvMemIn;

} //*** DebugMemoryAddToList()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void *
//  DebugMemoryAdd(
//      EMEMORYBLOCKTYPE    mbtTypeIn,
//      void *              hMemIn,
//      LPCTSTR             pszFileIn,
//      const int           nLineIn,
//      LPCTSTR             pszModuleIn,
//      DWORD               dwBytesIn,
//      LPCTSTR             pszCommentIn
//      )
//
//  Description:
//      Adds memory to be tracked to a memory tracking list.
//
//  Arguments:
//      mbtType         - Type of memory block of the memory to track.
//      hMemIn          - Pointer to memory to track.
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Whatever was in pvMemIn.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
DebugMemoryAdd(
    EMEMORYBLOCKTYPE    mbtTypeIn,
    void *              pvMemIn,
    LPCTSTR             pszFileIn,
    const int           nLineIn,
    LPCTSTR             pszModuleIn,
    DWORD               dwBytesIn,
    LPCTSTR             pszCommentIn
    )
{
    void *  pv = NULL;

    if ( g_fGlobalMemoryTacking )
    {
        EnterCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
        pv = DebugMemoryAddToList( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->pmbList), mbtTypeIn, pvMemIn, pszFileIn, nLineIn, pszModuleIn, dwBytesIn, pszCommentIn );
        LeaveCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
    } // if:
    else
    {
        Assert( g_TraceMemoryIndex != -1 );

        MEMORYBLOCK * pmbCurrent = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        pv = DebugMemoryAddToList( &pmbCurrent, mbtTypeIn, pvMemIn, pszFileIn, nLineIn, pszModuleIn, dwBytesIn, pszCommentIn );
        TlsSetValue( g_TraceMemoryIndex, pmbCurrent );
    } // else:

    return pv;

} //*** DebugMemoryAdd()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMemoryDeleteFromList(
//        MEMORYBLOCK **    ppmbHeadInout
//      , EMEMORYBLOCKTYPE  mbtTypeIn
//      , void *            pvMemIn
//      , LPCTSTR           pszFileIn
//      , const int         nLineIn
//      , LPCTSTR           pszModuleIn
//      , BOOL              fClobberIn
//      )
//
//  Description:
//      Removes a MEMORYBLOCK to the memory tracking list.
//
//  Arguments:
//      ppmbHeadInout   - The list to remove the memory from.
//      mbtTypeIn       - Memory block type.
//      pvMemIn         - Pointer to memory block to stop tracking.
//      pszFileIn       - Source file that is deleteing.
//      nLineIn         - Source line number that is deleteing.
//      pszModuleIn     - Source module name that is deleteing.
//      fClobberIn      - True is memory should be scrambled.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static void
DebugMemoryDeleteFromList(
      MEMORYBLOCK **    ppmbHeadInout
    , EMEMORYBLOCKTYPE  mbtTypeIn
    , void *            pvMemIn
    , LPCTSTR           pszFileIn
    , const int         nLineIn
    , LPCTSTR           pszModuleIn
    , BOOL              fClobberIn
    )
{
    Assert( ppmbHeadInout != NULL );

    if ( pvMemIn != NULL )
    {
        MEMORYBLOCK *   pmbCurrent = *ppmbHeadInout;
        MEMORYBLOCK *   pmbPrev = NULL;

        //
        // Find the memory in the memory block list
        //
        if ( mbtTypeIn == mmbtMEMORYALLOCATION )
        {
            while ( ( pmbCurrent != NULL ) && !( ( pmbCurrent->pvMem == pvMemIn ) && ( pmbCurrent->mbtType == mbtTypeIn ) ) )
            {
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->mbtType == mmbtSYSALLOCSTRING ), "Should be freed by SysAllocFreeString()." );
                pmbPrev = pmbCurrent;
                pmbCurrent = pmbPrev->pNext;
            } // while: finding the entry in the list
        } // if: memory allocation type
        else if ( mbtTypeIn == mmbtSYSALLOCSTRING )
        {
            while ( ( pmbCurrent != NULL ) && !( ( pmbCurrent->pvMem == pvMemIn ) && ( pmbCurrent->mbtType == mbtTypeIn ) ) )
            {
                AssertMsg( !( pmbCurrent->pvMem == pvMemIn && pmbCurrent->mbtType == mmbtMEMORYALLOCATION ), "Should be freed by TraceFree()." );
                pmbPrev = pmbCurrent;
                pmbCurrent = pmbPrev->pNext;
            } // while: finding the entry in the list
        } // if: SysAllocString type
        else if ( mbtTypeIn == mmbtUNKNOWN )
        {
            while ( ( pmbCurrent != NULL ) && ( pmbCurrent->pvMem != pvMemIn ) )
            {
                pmbPrev = pmbCurrent;
                pmbCurrent = pmbPrev->pNext;
            } // while: finding the entry in the list
        } // if: don't care what type
        else
        {
            while ( ( pmbCurrent != NULL ) && !( ( pmbCurrent->pvMem == pvMemIn ) && ( pmbCurrent->mbtType == mbtTypeIn ) ) )
            {
                pmbPrev = pmbCurrent;
                pmbCurrent = pmbPrev->pNext;
            } // while: finding the entry in the list
        } // else: other types, but they must match

        //
        //  Did we find the memory block in question?  pmbCurrent is the
        //  tracking record for the passed in address.
        //
        if ( pmbCurrent != NULL )
        {
            //
            // Remove the memory block from the tracking list
            //
            if ( pmbPrev != NULL )
            {
                pmbPrev->pNext = pmbCurrent->pNext;
            } // if: not first entry
            else
            {
                *ppmbHeadInout = pmbCurrent->pNext;
            } // else: first entry

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbCurrent, TEXT("Freeing") );
            } // if: tracing

            //
            // Nuke the memory
            //
            if ( fClobberIn && ( ( pmbCurrent->mbtType == mmbtMEMORYALLOCATION ) || ( pmbCurrent->mbtType == mmbtSYSALLOCSTRING ) ) )
            {
                memset( pmbCurrent->pvMem, FREE_ADDRESS, pmbCurrent->dwBytes );
            } // if: fixed memory

            //
            // Nuke the memory tracking block
            //
            memset( pmbCurrent, FREE_BLOCK, sizeof( MEMORYBLOCK ) );
            HeapFree( GetProcessHeap(), 0, pmbCurrent );
        } // if: found entry
        else
        {
            DebugMessage(
                          pszFileIn
                      , nLineIn
                      , pszModuleIn
                      , TEXT("***** Freeing memory at 0x%08x which was not found in list 0x%08x (ThreadID = 0x%08x) *****")
                      , pvMemIn
                      , *ppmbHeadInout
                      , GetCurrentThreadId()
                      );
        } // else: entry not found
    } // if: something to delete

} //*** DebugMemoryDeleteFromList()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMemoryDelete(
//      EMEMORYBLOCKTYPE    mbtTypeIn,
//      void *              pvMemIn
//      LPCTSTR             pszFileIn,
//      const int           nLineIn,
//      LPCTSTR             pszModuleIn,
//      BOOL                fClobberIn
//      )
//
//  Description:
//      Removes a MEMORYBLOCK to the memory tracking list.
//
//  Arguments:
//      mbtTypeIn   - Memory block type.
//      pvMemIn     - Pointer to memory block to stop tracking.
//      pszFileIn   - Source file that is deleteing.
//      nLineIn     - Source line number that is deleteing.
//      pszModuleIn - Source module name that is deleteing.
//      fClobberIn  - True is memory should be scrambled.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemoryDelete(
    EMEMORYBLOCKTYPE    mbtTypeIn,
    void *              pvMemIn,
    LPCTSTR             pszFileIn,
    const int           nLineIn,
    LPCTSTR             pszModuleIn,
    BOOL                fClobberIn
    )
{
    if ( g_fGlobalMemoryTacking )
    {
        EnterCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
        DebugMemoryDeleteFromList( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->pmbList), mbtTypeIn, pvMemIn, pszFileIn, nLineIn, pszModuleIn, fClobberIn );
        LeaveCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
    } // if:
    else
    {
        Assert( g_TraceMemoryIndex != -1 );

        MEMORYBLOCK * pmbCurrent = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        DebugMemoryDeleteFromList( &pmbCurrent, mbtTypeIn, pvMemIn, pszFileIn, nLineIn, pszModuleIn, fClobberIn );
        TlsSetValue( g_TraceMemoryIndex, pmbCurrent );
    } // else:

} //*** DebugMemoryDelete()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void *
//  DebugAlloc(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      UINT        uFlagsIn,
//      DWORD       dwBytesIn,
//      LPCTSTR     pszCommentIn
//      )
//
//  Description:
//      Replacement for LocalAlloc, GlobalAlloc, and malloc for CHKed/DEBUG
//      builds. Memoryallocations be tracked. Use the TraceAlloc macro to make
//      memoryallocations switch in RETAIL.
//
//  Arguments:
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      uFlagsIn        - Flags used to allocate the memory.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Pointer to the new allocation. NULL if allocation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
DebugAlloc(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    UINT        uFlagsIn,
    DWORD       dwBytesIn,
    LPCTSTR     pszCommentIn
    )
{
    Assert( ( uFlagsIn & LMEM_MOVEABLE ) == 0 );

    void *  pv = HeapAlloc( GetProcessHeap(), uFlagsIn, dwBytesIn );

    //
    // Initialize the memory if needed
    //
    if ( ( IsTraceFlagSet( mtfMEMORYINIT ) ) && !( uFlagsIn & HEAP_ZERO_MEMORY ) )
    {
        //
        // KB: gpease 8-NOV-1999
        //     Initialize to anything but ZERO. We will use AVAILABLE_ADDRESS to
        //     indicate "Available Address". Initializing to zero
        //     is bad because it usually has meaning.
        //
        memset( pv, AVAILABLE_ADDRESS, dwBytesIn );
    } // if: zero memory requested

    return DebugMemoryAdd( mmbtMEMORYALLOCATION, pv, pszFileIn, nLineIn, pszModuleIn, dwBytesIn, pszCommentIn );

} //*** DebugAlloc()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void *
//  DebugReAllocList(
//        MEMORYBLOCK **  ppmbHeadInout
//      , LPCTSTR         pszFileIn
//      , const int       nLineIn
//      , LPCTSTR         pszModuleIn
//      , void *          pvMemIn
//      , UINT            uFlagsIn
//      , DWORD           dwBytesIn
//      , LPCTSTR         pszCommentIn
//      )
//
//  Description:
//      Replacement for LocalReAlloc, GlobalReAlloc, and realloc for CHKed/DEBUG
//      builds. Memoryallocations be tracked. Use the TraceAlloc macro to make
//      memoryallocations switch in RETAIL.
//
//  Arguments:
//      ppmbHeadInout   - The memory tracking list to use.
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      pvMemIn         - Pointer to the source memory.
//      uFlagsIn        - Flags used to allocate the memory.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Pointer to the new allocation.
//      NULL if allocation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
static void *
DebugReAllocList(
      MEMORYBLOCK **    ppmbHeadInout
    , LPCTSTR           pszFileIn
    , const int         nLineIn
    , LPCTSTR           pszModuleIn
    , void *            pvMemIn
    , UINT              uFlagsIn
    , DWORD             dwBytesIn
    , LPCTSTR           pszCommentIn
    )
{
    Assert( ppmbHeadInout != NULL );

    MEMORYBLOCK *   pmbCurrent = NULL;
    void *          pvOld   = pvMemIn;
    MEMORYBLOCK *   pmbPrev = NULL;
    void *          pv;

    AssertMsg( !( uFlagsIn & GMEM_MODIFY ), "This doesn't handle modified memory blocks, yet." );

    //
    //  To duplicate the behavior of realloc we need to do an alloc when
    //  pvMemIn is NULL.
    //
    if ( pvMemIn == NULL )
    {
        //
        //  Cannot use DebugAlloc() since it will automically add this memory to the tracking list and
        //  we need to use the passed in list.
        //
        pv = HeapAlloc( GetProcessHeap(), uFlagsIn, dwBytesIn );

        //
        // Initialize the memory if needed
        //
        if ( ( IsTraceFlagSet( mtfMEMORYINIT ) ) && !( uFlagsIn & HEAP_ZERO_MEMORY ) )
        {
            //
            // KB: gpease 8-NOV-1999
            //     Initialize to anything but ZERO. We will use AVAILABLE_ADDRESS to
            //     indicate "Available Address". Initializing to zero
            //     is bad because it usually has meaning.
            //
            memset( pv, AVAILABLE_ADDRESS, dwBytesIn );
        } // if: zero memory requested

        //
        //  Cannot call DebugMemoryAdd() since it will get the memory tracking list head from thread local storage
        //  when we are using per thread memory tracking.  We need to use the list that this function was passed.
        //
        pv = DebugMemoryAddToList( ppmbHeadInout, mmbtMEMORYALLOCATION, pv, pszFileIn, nLineIn, pszModuleIn, dwBytesIn, pszCommentIn );
        goto Exit;
    } // if:

    pmbCurrent = *ppmbHeadInout;

    //
    // Find the memory in the memory block list
    //
    while ( ( pmbCurrent != NULL ) && ( pmbCurrent->pvMem != pvMemIn ) )
    {
        pmbPrev = pmbCurrent;
        pmbCurrent = pmbPrev->pNext;
    } // while: finding the entry in the list

    //
    //  Did we find the current memory block?
    //
    if ( pmbCurrent != NULL )
    {
        AssertMsg( pmbCurrent->mbtType == mmbtMEMORYALLOCATION, "You can only realloc memory allocations!" );

        //
        // Remove the memory from the tracking list
        //
        if ( pmbPrev != NULL )
        {
            pmbPrev->pNext = pmbCurrent->pNext;
        } // if: not first entry
        else
        {
            *ppmbHeadInout = pmbCurrent->pNext;
        } // else: first entry

        //
        // Spew if needed
        //
        if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
        {
            DebugMemorySpew( pmbCurrent, TEXT("Freeing") );
        } // if: tracing

        //
        // Force the programmer to handle a real realloc by moving the
        // memory first.
        //
        pvOld = HeapAlloc( GetProcessHeap(), uFlagsIn, pmbCurrent->dwBytes );
        if ( pvOld != NULL )
        {
            CopyMemory( pvOld, pvMemIn, pmbCurrent->dwBytes );

            //
            // Nuke the old memory if the allocation is to be smaller.
            //
            if ( dwBytesIn < pmbCurrent->dwBytes )
            {
                LPBYTE pb = (LPBYTE) pvOld + dwBytesIn;
                memset( pb, FREE_ADDRESS, pmbCurrent->dwBytes - dwBytesIn );
            } // if: smaller memory

            pmbCurrent->pvMem = pvOld;
        } // if: got new memory
        else
        {
            pvOld = pvMemIn;
        } // else: allocation failed
    } // if: found entry
    else
    {
        DebugMessage(
                  pszFileIn
                , nLineIn
                , pszModuleIn
                , TEXT("***** Realloc'ing memeory at 0x%08x which was not on the list 0x%08x (ThreadID = 0x%08x) *****")
                , pvMemIn
                , *ppmbHeadInout
                , GetCurrentThreadId()
                );
    } // else: entry not found

    //
    // We do this any way because the flags and input still need to be
    // verified by HeapReAlloc().
    //
    pv = HeapReAlloc( GetProcessHeap(), uFlagsIn, pvOld, dwBytesIn );
    if ( pv == NULL )
    {
        DWORD dwErr = TW32( GetLastError() );
        AssertMsg( dwErr == 0, "HeapReAlloc() failed!" );

        if ( pvMemIn != pvOld )
        {
            HeapFree( GetProcessHeap(), 0, pvOld );
        } // if: forced a move

        SetLastError( dwErr );

        if ( pmbCurrent != NULL )
        {
            //
            // Continue tracking the memory by re-adding it to the tracking list.
            //
            pmbCurrent->pvMem = pvMemIn;
            pmbCurrent->pNext = *ppmbHeadInout;
            *ppmbHeadInout    = pmbCurrent;
        } // if: reuse the old entry
        else
        {
            //
            //  Create a new block.  Must use DebugMemoryAddToList() since we need to pass it the list that was passed
            //  into this function.
            //
            DebugMemoryAddToList( ppmbHeadInout, mmbtMEMORYALLOCATION, pvOld, pszFileIn, nLineIn, pszModuleIn, dwBytesIn, pszCommentIn );
        } // else: make new entry

    } // if: allocation failed
    else
    {
        if ( pv != pvMemIn )
        {
            if ( pmbCurrent != NULL )
            {
                //
                // Nuke the old memory
                //
                memset( pvMemIn, FREE_ADDRESS, pmbCurrent->dwBytes );
            } // if: entry found

            //
            // Free the old memory
            //
            HeapFree( GetProcessHeap(), 0, pvMemIn );

        } // if: new memory location

        //
        // Add the allocation to the tracking table.
        //
        if ( pmbCurrent != NULL )
        {
            //
            // If the block is bigger, initialize the "new" memory
            //
            if ( IsTraceFlagSet( mtfMEMORYINIT ) && ( dwBytesIn > pmbCurrent->dwBytes ) )
            {
                //
                // Initialize the expaned memory block
                //
                LPBYTE pb = (LPBYTE) pv + pmbCurrent->dwBytes;
                memset( pb, AVAILABLE_ADDRESS, dwBytesIn - pmbCurrent->dwBytes );
            } // if: initialize memory

            //
            // Re-add the tracking block by reusing the old tracking block
            //
            pmbCurrent->pvMem      = pv;
            pmbCurrent->dwBytes    = dwBytesIn;
            pmbCurrent->pszFile    = pszFileIn;
            pmbCurrent->nLine      = nLineIn;
            pmbCurrent->pszModule  = pszModuleIn;
            pmbCurrent->pszComment = pszCommentIn;
            pmbCurrent->pNext      = *ppmbHeadInout;
            *ppmbHeadInout         = pmbCurrent;

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbCurrent, TEXT("ReAlloced") );
            } // if: tracing

        } // if: entry found
        else
        {
            //
            //  Create a new block.  Must use DebugMemoryAddToList() since we need to pass it the list that was passed
            //  into this function.
            //
            DebugMemoryAddToList( ppmbHeadInout, mmbtMEMORYALLOCATION, pvOld, pszFileIn, nLineIn, pszModuleIn, dwBytesIn, pszCommentIn );
        } // else: make new entry
    } // else: allocation succeeded

Exit:

    return pv;

} //*** DebugReallocList()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void *
//  DebugReAlloc(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      void *      pvMemIn,
//      UINT        uFlagsIn,
//      DWORD       dwBytesIn,
//      LPCTSTR     pszCommentIn
//      )
//
//  Description:
//      Replacement for LocalReAlloc, GlobalReAlloc, and realloc for CHKed/DEBUG
//      builds. Memoryallocations be tracked. Use the TraceAlloc macro to make
//      memoryallocations switch in RETAIL.
//
//  Arguments:
//      pszFileIn       - Source filename where memory was allocated.
//      nLineIn         - Source line number where memory was allocated.
//      pszModuleIn     - Source module where memory was allocated.
//      pvMemIn         - Pointer to the source memory.
//      uFlagsIn        - Flags used to allocate the memory.
//      dwBytesIn       - Size of the allocation.
//      pszCommentIn    - Optional comments about the memory.
//
//  Return Values:
//      Pointer to the new allocation.
//      NULL if allocation failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
DebugReAlloc(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    void *      pvMemIn,
    UINT        uFlagsIn,
    DWORD       dwBytesIn,
    LPCTSTR     pszCommentIn
    )
{
    void * pv;

    if ( g_fGlobalMemoryTacking )
    {
        EnterCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
        pv = DebugReAllocList( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->pmbList), pszFileIn, nLineIn, pszModuleIn, pvMemIn, uFlagsIn, dwBytesIn, pszCommentIn );
        LeaveCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
    } // if:
    else
    {
        Assert( g_TraceMemoryIndex != -1 );

        MEMORYBLOCK * pmbCurrent = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        pv = DebugReAllocList( &pmbCurrent, pszFileIn, nLineIn, pszModuleIn, pvMemIn, uFlagsIn, dwBytesIn, pszCommentIn );
        TlsSetValue( g_TraceMemoryIndex, pmbCurrent );
    } // else:

    return pv;

} //*** DebugRealloc()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void *
//  DebugFree(
//      void *      pvMemIn
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      )
//
//  Description:
//      Replacement for LocalFree for CHKed/DEBUG builds. Removes the
//      memory allocation for the memory tracking list. Use the TraceFree
//      macro to make memory allocation switch in RETAIL. The memory of the
//      freed block will be set to 0xFE.
//
//  Arguments:
//      pvMemIn     - Pointer to memory block to free.
//      pszFileIn   - Source file path to the caller
//      nLineIn     - Line number of the caller in the source file
//      pszModuleIn - Source module name of the caller
//
//  Return Values: (see HeapFree())
//      TRUE
//          Memory was freed.
//
//      FALSE
//          An Error occured.  Use GetLastError() to determine the failure.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL
DebugFree(
    void *      pvMemIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    )
{
    DebugMemoryDelete( mmbtMEMORYALLOCATION, pvMemIn, pszFileIn, nLineIn, pszModuleIn, TRUE );

    return( HeapFree( GetProcessHeap(), 0, pvMemIn ) );

} //*** DebugFree()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMemoryCheck(
//      LPVOID  pvListIn,
//      LPCTSTR pszListNameIn
//      )
//
//  Description:
//      Called just before a thread/process dies to verify that all the memory
//      allocated by the thread/process was properly freed. Anything that was
//      not freed will be listed in the debugger.
//
//      If pmbListIn is NULL, it will check the current threads tracking list.
//      The list is destroyed as it is checked.
//
//  Arguments:
//      pvListIn      - The list to check.
//      pszListNameIn - The name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemoryCheck( LPVOID pvListIn, LPCTSTR pszListNameIn )
{
    //
    //  We are either doing global memory tracking or we are doing
    //  per thread memory tracking...
    //
    Assert( ( ( g_TraceMemoryIndex == -1 ) && ( g_fGlobalMemoryTacking ) )
        ||  ( ( g_TraceMemoryIndex != -1 ) && ( !g_fGlobalMemoryTacking ) ) );

    BOOL                fFoundLeak = FALSE;
    MEMORYBLOCK *       pmb;
    SPerThreadDebug *   ptd = NULL;

    if ( IsTraceFlagSet( mtfPERTHREADTRACE ) )
    {
        Assert( g_TraceFlagsIndex != -1 );
        ptd = (SPerThreadDebug *) TlsGetValue( g_TraceFlagsIndex );
    } // if: per thread tracing

    //
    // Determine which list to use.
    //
    if ( pvListIn == NULL )
    {
        pmb = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
    } // if: use the thread list
    else
    {
        MEMORYBLOCKLIST * pmbl = (MEMORYBLOCKLIST *) pvListIn;

        Assert( pszListNameIn != NULL );

        //
        // Make sure nobody tries to use the list again.
        //
        EnterCriticalSection( &pmbl->csList );
        pmbl->fDeadList = TRUE;
        LeaveCriticalSection( &pmbl->csList );

        pmb = pmbl->pmbList;
    } // else: use the given list

    //
    // Print banner if needed.
    //
    if ( pmb != NULL )
    {
        if ( pvListIn == NULL )
        {
            if ( ptd != NULL && ptd->pcszName != NULL )
            {
                DebugMsg( TEXT("DEBUG: ******** Memory leak detected ***** %s, ThreadID = %#x ********"), ptd->pcszName, GetCurrentThreadId() );

            } // if: named thread
            else
            {
                DebugMsg( "DEBUG: ******** Memory leak detected ******************* ThreadID = 0x%08x ********", GetCurrentThreadId() );

            } // else: unnamed thread

            DebugMsg( "DEBUG: M = Moveable, A = Address, O = Object(new), P = Punk, H = Handle, B = BSTR" );
            DebugMsg( "Module     Addr/Hndl/Obj Size   Comment" );
                    //"         1         2         3         4         5         6         7         8                                        "
                    //"12345678901234567890123456789012345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1....."

        } // if: thread leak
        else
        {
            DebugMsg( TEXT("DEBUG: ******** Memory leak detected ******************* %s ********"), pszListNameIn );
            DebugMsg( "DEBUG: M = Moveable, A = Address, O = Object(new), P = Punk, H = Handle, B = BSTR" );
            DebugMsg( "Module     Addr/Hndl/Obj Size   Comment" );
                    //"         1         2         3         4         5         6         7         8                                        "
                    //"12345678901234567890123456789012345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1....."

        } // else: list leak
        fFoundLeak = TRUE;

    } // if: leak found

    //
    // Dump the entries.
    //
    while ( pmb != NULL )
    {
        LPCTSTR pszFormat;

        switch ( pmb->mbtType )
        {
            case mmbtMEMORYALLOCATION:
                pszFormat = TEXT("%10s A 0x%08x  %-5u  \"%s\"");
                break;

            case mmbtOBJECT:
                pszFormat = TEXT("%10s O 0x%08x  %-5u  \"%s\"");
                break;

            case mmbtPUNK:
                pszFormat = TEXT("%10s P 0x%08x  %-5u  \"%s\"");
                break;

            case mmbtHANDLE:
                pszFormat = TEXT("%10s H 0x%08x  %-5u  \"%s\"");
                break;

            case mmbtSYSALLOCSTRING:
                pszFormat = TEXT("%10s B 0x%08x  %-5u  \"%s\"");
                break;

            default:
                AssertMsg( 0, "Unknown memory block type!" );
                break;
        } // switch: pmb->mbtType

        DebugMessage( pmb->pszFile, pmb->nLine, pmb->pszModule, pszFormat, pmb->pszModule, pmb->pvMem, pmb->dwBytes, pmb->pszComment );

        pmb = pmb->pNext;

    } // while: something in the list

    //
    // Print trailer if needed.
    //
    if ( fFoundLeak == TRUE )
    {
        // Add an extra newline to the end of this message.
        DebugMsg( TEXT("DEBUG: ***************************** Memory leak detected *****************************") SZ_NEWLINE );

    } // if: leaking

    //
    // Assert if needed.
    //
    if ( IsDebugFlagSet( mtfMEMORYLEAKS ) )
    {
        Assert( !fFoundLeak );

    } // if: yell at leaks

} //*** DebugMemoryCheck()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugCreateMemoryList(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPVOID *    ppvListOut,
//      LPCTSTR     pszListNameIn
//      )
//
//  Description:
//      Creates a memory block list for tracking possible "global" scope
//      memory allocations.
//
//  Arguments:
//      pszFileIn     - Source file of caller.
//      nLineIn       - Source line number of caller.
//      pszModuleIn   - Source module name of caller.
//      ppvListOut    - Location to the store address of the list head.
//      pszListNameIn - Name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugCreateMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPVOID *    ppvListOut,
    LPCTSTR     pszListNameIn
    )
{
    MEMORYBLOCKLIST * pmbl;

    Assert( ppvListOut != NULL );
    Assert( *ppvListOut == NULL );

    *ppvListOut = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof( MEMORYBLOCKLIST ) );
    AssertMsg( *ppvListOut != NULL, "Low memory situation." );

    pmbl = (MEMORYBLOCKLIST*) *ppvListOut;

    InitializeCriticalSection( &(pmbl->csList) );

    Assert( pmbl->pmbList == NULL );
    Assert( pmbl->fDeadList == FALSE );

    if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
    {
        DebugMessage( pszFileIn, nLineIn, pszModuleIn, TEXT("Created new memory list %s"), pszListNameIn );
    } // if: tracing

} // DebugCreateMemoryList()
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMemoryListDelete(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      void *      pvMemIn,
//      LPVOID      pvListIn,
//      LPCTSTR     pszListNameIn,
//      BOOL        fClobberIn
//      )
//
//  Description:
//      Removes the memory from the tracking list and adds it back to the
//      "per thread" tracking list in order to called DebugMemoryDelete()
//      to do the proper destruction of the memory. Not highly efficent, but
//      reduces code maintenance by having "destroy" code in one (the most
//      used) location.
//
//  Arguments:
//      pszFileIn    - Source file of caller.
//      nLineIn      - Source line number of caller.
//      pszModuleIn  - Source module name of caller.
//      pvMemIn      - Memory to be freed.
//      pvListIn     - List from which the memory is to be freed.
//      pvListNameIn - Name of the list.
//      fClobberIn   - TRUE - destroys memory; FALSE just removes from list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMemoryListDelete(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    void *      pvMemIn,
    LPVOID      pvListIn,
    LPCTSTR     pszListNameIn,
    BOOL        fClobberIn
    )
{
    if ( ( pvMemIn != NULL ) && ( pvListIn != NULL ) )
    {
        MEMORYBLOCK *   pmbCurrent;

        MEMORYBLOCKLIST * pmbl  = (MEMORYBLOCKLIST *) pvListIn;
        MEMORYBLOCK *   pmbPrev = NULL;

        Assert( pszListNameIn != NULL );

        EnterCriticalSection( &pmbl->csList );
        AssertMsg( pmbl->fDeadList == FALSE, "List was terminated." );
        AssertMsg( pmbl->pmbList != NULL, "Memory tracking problem detecting. Nothing in list to delete." );
        pmbCurrent = pmbl->pmbList;

        //
        // Find the memory in the memory block list
        //

        while ( ( pmbCurrent != NULL ) && ( pmbCurrent->pvMem != pvMemIn ) )
        {
            pmbPrev = pmbCurrent;
            pmbCurrent = pmbPrev->pNext;
        } // while: finding the entry in the list

        //
        // Remove the memory block from the tracking list.
        //

        if ( pmbCurrent != NULL )
        {
            if ( pmbPrev != NULL )
            {
                pmbPrev->pNext = pmbCurrent->pNext;

            } // if: not first entry
            else
            {
                pmbl->pmbList = pmbCurrent->pNext;

            } // else: first entry

        } // if: got entry

        LeaveCriticalSection( &pmbl->csList );

        if ( pmbCurrent != NULL )
        {
            //
            // Add it back to the per thread list.
            //

            Assert( g_TraceMemoryIndex != -1 );
            pmbPrev = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
            pmbCurrent->pNext = pmbPrev;
            TlsSetValue( g_TraceMemoryIndex, pmbCurrent );

            //
            // Finally delete it.
            //

            DebugMemoryDelete( pmbCurrent->mbtType, pmbCurrent->pvMem, pszFileIn, nLineIn, pszModuleIn, fClobberIn );
        }
        else
        {
            //
            //  Not from the provided list. Try a thread delete any way.
            //

            DebugMemoryDelete( mmbtUNKNOWN, pvMemIn, pszFileIn, nLineIn, pszModuleIn, fClobberIn );
        }

    } // if: pvIn != NULL

} // DebugMemoryListDelete()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMoveToMemoryList(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      void *      pvMemIn,
//      LPVOID      pvListIn,
//      LPCTSTR     pszListNameIn
//      )
//
//  Description:
//      Moves the memory pvIn from the per thread tracking list to the thread
//      independent list "pmbListIn". Useful when memory is being handed from
//      one thread to another. Also useful for objects that live past the
//      lifetime of the thread that created them.
//
//  Arguments:
//      LPCTSTR pszFileIn   - Source file of the caller.
//      const int nLineIn   - Source line number of the caller.
//      LPCTSTR pszModuleIn - Source module name of the caller.
//      pvMemIn             - Memory to move to list.
//      pvListIn            - The list to move to.
//      pszListNameIn       - The name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMoveToMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    void *      pvMemIn,
    LPVOID      pvListIn,
    LPCTSTR     pszListNameIn
    )
{
    if ( ( pvMemIn != NULL ) && ( pvListIn != NULL ) )
    {
        Assert( g_TraceMemoryIndex != -1 );

        MEMORYBLOCKLIST * pmbl  = (MEMORYBLOCKLIST *) pvListIn;
        MEMORYBLOCK *   pmbCurrent = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        MEMORYBLOCK *   pmbPrev = NULL;

        Assert( pszListNameIn != NULL );

        //
        // Find the memory in the memory block list
        //
        while ( ( pmbCurrent != NULL ) && ( pmbCurrent->pvMem != pvMemIn ) )
        {
            pmbPrev = pmbCurrent;
            pmbCurrent = pmbPrev->pNext;
        } // while: finding the entry in the list

        AssertMsg( pmbCurrent != NULL, "Memory not in list. Check your code." );

        //
        // Remove the memory block from the "per thread" tracking list.
        //
        if ( pmbPrev != NULL )
        {
            pmbPrev->pNext = pmbCurrent->pNext;

        } // if: not first entry
        else
        {
            TlsSetValue( g_TraceMemoryIndex, pmbCurrent->pNext );

        } // else: first entry

        //
        // Update the "source" data.
        //
        pmbCurrent->pszFile   = pszFileIn;
        pmbCurrent->nLine     = nLineIn;
        pmbCurrent->pszModule = pszModuleIn;

        //
        // Spew if needed.
        //
        if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
        {
            TCHAR szMessage[ 128 ]; // random

            _tcscpy( szMessage, TEXT("Transferring to ") );
            _tcscat( szMessage, pszListNameIn );

            DebugMemorySpew( pmbCurrent, szMessage );
        } // if: tracing

        //
        // Add to list.
        //
        AssertMsg( pmbl->fDeadList == FALSE, "List was terminated." );
        EnterCriticalSection( &pmbl->csList );
        pmbCurrent->pNext = pmbl->pmbList;
        pmbl->pmbList  = pmbCurrent;
        LeaveCriticalSection( &pmbl->csList );

    } // if: pvIn != NULL

} // DebugMoveToMemoryList()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugMoveFromMemoryList(
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn,
//      LPVOID      pvMemIn,
//      LPVOID      pvListIn,
//      LPCTSTR     pszListNameIn
//      )
//
//  Description:
//      Moves the memory pvIn from the per thread tracking list to the thread
//      independent list "pmbListIn". Useful when memory is being handed from
//      one thread to another. Also useful for objects that live past the
//      lifetime of the thread that created them.
//
//  Arguments:
//      LPCTSTR pszFileIn   - Source file of the caller.
//      const int nLineIn   - Source line number of the caller.
//      LPCTSTR pszModuleIn - Source module name of the caller.
//      pvMemIn             - Memory to move to list.
//      pvListIn            - The list to move to.
//      pszListNameIn       - The name of the list.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugMoveFromMemoryList(
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn,
    LPVOID      pvMemIn,
    LPVOID      pvListIn,
    LPCTSTR     pszListNameIn
    )
{
    if ( ( pvMemIn != NULL ) && ( pvListIn != NULL ) )
    {
        MEMORYBLOCK *   pmbCurrent;

        MEMORYBLOCKLIST * pmbl  = (MEMORYBLOCKLIST *) pvListIn;
        MEMORYBLOCK *   pmbPrev = NULL;

        Assert( pszListNameIn != NULL );

        EnterCriticalSection( &pmbl->csList );
        AssertMsg( pmbl->fDeadList == FALSE, "List was terminated." );
        AssertMsg( pmbl->pmbList != NULL, "Memory tracking problem detecting. Nothing in list to delete." );
        pmbCurrent = pmbl->pmbList;

        //
        // Find the memory in the memory block list
        //

        while ( pmbCurrent != NULL
             && pmbCurrent->pvMem != pvMemIn
              )
        {
            pmbPrev = pmbCurrent;
            pmbCurrent = pmbPrev->pNext;
        } // while: finding the entry in the list

        AssertMsg( pmbCurrent != NULL, "Memory not in tracking list. Use TraceMemoryAddxxxx() or add it to the memory list." );

        //
        // Remove the memory block from the tracking list.
        //

        if ( pmbPrev != NULL )
        {
            pmbPrev->pNext = pmbCurrent->pNext;

        } // if: not first entry
        else
        {
            pmbl->pmbList = pmbCurrent->pNext;

        } // else: first entry

        LeaveCriticalSection( &pmbl->csList );

        //
        // Add it back to the per thread list.
        //

        Assert( g_TraceMemoryIndex != -1 );

        pmbPrev = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        pmbCurrent->pNext = pmbPrev;
        TlsSetValue( g_TraceMemoryIndex, pmbCurrent );

    } // if: pvIn != NULL

} // DebugMoveFromMemoryList()
*/
#if defined( USES_SYSALLOCSTRING )
//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT
//  DebugSysReAllocStringList(
//        MEMORYBLOCK **    ppmbHeadInout
//      , LPCTSTR           pszFileIn
//      , const int         nLineIn
//      , LPCTSTR           pszModuleIn
//      , BSTR *            pbstrInout
//      , const OLECHAR *   pszIn
//      , LPCTSTR           pszCommentIn
//      )
//
//  Description:
//      Adds memory tracing to SysReAllocString().
//
//  Arguments:
//      ppmbHeadInout   - The memory tracking list to use.
//      pszFileIn       - Source file path
//      nLineIn         - Source line number
//      pszModuleIn     - Source module name
//      pbstrInout      - Pointer to the BSTR to realloc
//      pszIn           - String to be copied (see SysReAllocString)
//      pszCommentIn    - Comment about alloction
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
static INT
DebugSysReAllocStringList(
      MEMORYBLOCK **  ppmbHeadInout
    , LPCTSTR         pszFileIn
    , const int       nLineIn
    , LPCTSTR         pszModuleIn
    , BSTR *          pbstrInout
    , const OLECHAR * pszIn
    , LPCTSTR         pszCommentIn
    )
{
    Assert( ppmbHeadInout != NULL );

    BSTR            bstrOld;
    BSTR            bstr;
    MEMORYBLOCK *   pmbCurrent = NULL;
    BOOL            fReturn = FALSE;

    //
    // Some assertions that SysReAllocString() makes. These would be fatal
    // in retail.
    //
    Assert( pbstrInout != NULL );
    Assert( pszIn != NULL );
    Assert( *pbstrInout == NULL || ( pszIn < *pbstrInout || pszIn > *pbstrInout + wcslen( *pbstrInout ) + 1 ) );

    bstrOld = *pbstrInout;

    if ( bstrOld != NULL )
    {
        MEMORYBLOCK * pmbPrev = NULL;

        pmbCurrent = *ppmbHeadInout;

        //
        // Find the memory in the memory block list
        //
        while ( ( pmbCurrent != NULL ) && ( pmbCurrent->bstr != bstrOld ) )
        {
            pmbPrev = pmbCurrent;
            pmbCurrent = pmbPrev->pNext;
        } // while: finding the entry in the list

        //
        //  Did we find the tracked addresses record?
        //
        if ( pmbCurrent != NULL )
        {
            AssertMsg( pmbCurrent->mbtType == mmbtSYSALLOCSTRING, "You can only SysReAlloc sysstring allocations!" );

            //
            // Remove the memory from the tracking list
            //
            if ( pmbPrev != NULL )
            {
                pmbPrev->pNext = pmbCurrent->pNext;
            } // if: not first entry
            else
            {
                *ppmbHeadInout = pmbCurrent->pNext;
            } // else: first entry

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbCurrent, TEXT("Freeing") );
            } // if: tracing

            //
            // Force the programmer to handle a real realloc by moving the
            // memory first.
            //
            bstrOld = SysAllocString( *pbstrInout );
            if ( bstrOld != NULL )
            {
                _tcscpy( bstrOld, *pbstrInout );
                pmbCurrent->bstr = bstrOld;
            } // if: success
            else
            {
                bstrOld = *pbstrInout;
            } // else: failed

        } // if: found entry
        else
        {
            DebugMessage(
                        pszFileIn
                      , nLineIn
                      , pszModuleIn
                      , TEXT( "***** SysReAlloc'ing memory at 0x%08x which was not found in list 0x%08x (ThreadID = 0x%08x) *****" )
                      , bstrOld
                      , *ppmbHeadInout
                      , GetCurrentThreadId()
                      );
        } // else: entry not found

    } // if: something to delete

    //
    // We do this any way because the flags and input still need to be
    // verified by SysReAllocString().
    //
    fReturn = SysReAllocString( &bstrOld, pszIn );
    if ( ! fReturn )
    {
        DWORD dwErr = GetLastError();
        AssertMsg( dwErr == 0, "SysReAllocString() failed!" );

        if ( *pbstrInout != bstrOld )
        {
            SysFreeString( bstrOld );
        } // if: forced a move

        SetLastError( dwErr );

    } // if: allocation failed
    else
    {
        if ( bstrOld != *pbstrInout )
        {
            if ( pmbCurrent != NULL )
            {
                //
                // Nuke the old memory
                //
                Assert( pmbCurrent->dwBytes != 0 ); // invalid string
                memset( *pbstrInout, FREE_ADDRESS, pmbCurrent->dwBytes );
            } // if: entry found

            //
            // Free the old memory
            //
            SysFreeString( *pbstrInout );

        } // if: new memory location

        if ( pmbCurrent != NULL )
        {
            //
            // Re-add the tracking block by reusing the old tracking block
            //
            pmbCurrent->bstr       = bstrOld;
            pmbCurrent->dwBytes    = wcslen( pszIn ) + 1;
            pmbCurrent->pszFile    = pszFileIn;
            pmbCurrent->nLine      = nLineIn;
            pmbCurrent->pszModule  = pszModuleIn;
            pmbCurrent->pszComment = pszCommentIn;
            pmbCurrent->pNext      = *ppmbHeadInout;
            *ppmbHeadInout         = pmbCurrent;

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbCurrent, TEXT("SysReAlloced") );
            } // if: tracing
        } // if: entry found
        else
        {
            //
            //  Create a new block.  Must use DebugMemoryAddToList() since we need to pass it the list that was passed
            //  into this function.
            //
            DebugMemoryAddToList( ppmbHeadInout, mmbtSYSALLOCSTRING, bstrOld, pszFileIn, nLineIn, pszModuleIn, wcslen( pszIn ) + 1, pszCommentIn );
        } // else: make new entry

    } // else: allocation succeeded

    *pbstrInout = bstrOld;

    return fReturn;

} //*** DebugSysReAllocStringList()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT
//  DebugSysReAllocString(
//        LPCTSTR         pszFileIn
//      , const int       nLineIn
//      , LPCTSTR         pszModuleIn
//      , BSTR *          pbstrInout
//      , const OLECHAR * pszIn
//      , LPCTSTR         pszCommentIn
//      )
//
//  Description:
//      Adds memory tracing to SysReAllocString().
//
//  Arguments:
//      pszFileIn       - Source file path
//      nLineIn         - Source line number
//      pszModuleIn     - Source module name
//      pbstrInout         - Pointer to the BSTR to realloc
//      pszIn           - String to be copied (see SysReAllocString)
//      pszCommentIn    - Comment about alloction
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT
DebugSysReAllocString(
      LPCTSTR         pszFileIn
    , const int       nLineIn
    , LPCTSTR         pszModuleIn
    , BSTR *          pbstrInout
    , const OLECHAR * pszIn
    , LPCTSTR         pszCommentIn
    )
{
    BOOL fReturn = FALSE;

    if ( g_fGlobalMemoryTacking )
    {
        EnterCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
        fReturn = DebugSysReAllocStringList( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->pmbList), pszFileIn, nLineIn, pszModuleIn, pbstrInout, pszIn, pszCommentIn );
        LeaveCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
    } // if:
    else
    {
        Assert( g_TraceMemoryIndex != -1 );

        MEMORYBLOCK * pmbCurrent = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        fReturn = DebugSysReAllocStringList( &pmbCurrent, pszFileIn, nLineIn, pszModuleIn, pbstrInout, pszIn, pszCommentIn );
        TlsSetValue( g_TraceMemoryIndex, pmbCurrent );
    } // else:

    return fReturn;

} //*** DebugSysReAllocString()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT
//  DebugSysReAllocStringLenList(
//        MEMORYBLOCK **    ppmbHeadInout
//      , LPCTSTR           pszFileIn
//      , const int         nLineIn
//      , LPCTSTR           pszModuleIn
//      , BSTR *            pbstrInout
//      , const OLECHAR *   pszIn
//      , unsigned int      ucchIn
//      , LPCTSTR           pszCommentIn
//      )
//
//  Description:
//      Adds memory tracing to SysReAllocString().
//
//  Arguments:
//      ppmbHeadInout   - The memory tracking list to use.
//      pszFileIn       - Source file path
//      nLineIn         - Source line number
//      pszModuleIn     - Source module name
//      pbstrInout      - Pointer to the BSTR to realloc
//      pszIn           - String to be copied (see SysReAllocString)
//      pszCommentIn    - Comment about alloction
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT
DebugSysReAllocStringLenList(
      MEMORYBLOCK **    ppmbHeadInout
    , LPCTSTR           pszFileIn
    , const int         nLineIn
    , LPCTSTR           pszModuleIn
    , BSTR *            pbstrInout
    , const OLECHAR *   pszIn
    , unsigned int      ucchIn
    , LPCTSTR           pszCommentIn
    )
{
    Assert( ppmbHeadInout != NULL );

    BSTR            bstrOld;
    BSTR            bstrTemp;
    MEMORYBLOCK *   pmbCurrent = NULL;
    BOOL            fReturn = FALSE;

    //
    // Some assertions that SysReAllocStringLen() makes. These would be fatal
    // in retail.
    //
    Assert( pbstrInout != NULL );
    Assert( pszIn != NULL );
    Assert( ( *pbstrInout == NULL ) || ( pszIn == *pbstrInout ) || ( pszIn < *pbstrInout ) || ( pszIn > *pbstrInout + wcslen( *pbstrInout ) + 1 ) );

    bstrOld = *pbstrInout;

    if ( bstrOld != NULL )
    {
        MEMORYBLOCK * pmbPrev = NULL;

        pmbCurrent = *ppmbHeadInout;

        //
        // Find the memory in the memory block list
        //
        while ( ( pmbCurrent != NULL ) && ( pmbCurrent->bstr != bstrOld ) )
        {
            pmbPrev = pmbCurrent;
            pmbCurrent = pmbPrev->pNext;
        } // while: finding the entry in the list

        //
        //  Did we find the tracking record?
        //
        if ( pmbCurrent != NULL )
        {
            AssertMsg( pmbCurrent->mbtType == mmbtSYSALLOCSTRING, "You can only SysReAlloc sysstring allocations!" );

            //
            // Remove the memory from the tracking list
            //
            if ( pmbPrev != NULL )
            {
                pmbPrev->pNext = pmbCurrent->pNext;

            } // if: not first entry
            else
            {
                *ppmbHeadInout = pmbCurrent->pNext;
            } // else: first entry

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbCurrent, TEXT("Freeing") );
            } // if: tracing

            //
            // Force the programmer to handle a real realloc by moving the
            // memory first.
            //
            bstrTemp = SysAllocString( *pbstrInout );
            if ( bstrTemp != NULL )
            {
                pmbCurrent->bstr = bstrTemp;
            } // if: success
            else
            {
                //
                //  REVIEW:   26-MAR-2001 GalenB
                //
                //  Hmmm...  If the alloc above ever fails then isn't memory low?
                //
                bstrTemp = *pbstrInout;
            } // else: failed
        } // if: found entry
        else
        {
            DebugMessage(
                        pszFileIn
                      , nLineIn
                      , pszModuleIn
                      , TEXT("***** SysReAlloc'ing memory 0x%08x which was not found in list 0x%08x (ThreadID = 0x%08x) *****")
                      , bstrOld
                      , *ppmbHeadInout
                      , GetCurrentThreadId()
                      );
        } // else: entry not found
    } // if: something to delete

    //
    // We do this any way because the flags and input still need to be
    // verified by SysReAllocString().
    //
    bstrOld = bstrTemp;
    fReturn = SysReAllocStringLen( &bstrTemp, pszIn, ucchIn );
    if ( ! fReturn )
    {
        DWORD dwErr = GetLastError();
        AssertMsg( dwErr == 0, "SysReAllocStringLen() failed!" );

        if ( bstrTemp != *pbstrInout  )
        {
            //
            //  We made a copy of the old string, but fail to realloc the new string.
            //  So SysReAllocStrinLen() returns the old pointer. We need to free our
            //  new temp memory and point it to the old incoming memory.
            //
            SysFreeString( bstrTemp );
            bstrTemp = *pbstrInout;
        } // if: forced a move

        SetLastError( dwErr );
    } // if: allocation failed
    else
    {
        if ( bstrTemp != bstrOld )
        {
            if ( pmbCurrent != NULL )
            {
                //
                // Nuke the old memory
                //
                Assert( pmbCurrent->dwBytes != 0 ); // invalid string
                memset( *pbstrInout, FREE_ADDRESS, pmbCurrent->dwBytes );
            } // if: entry found

            //
            // Free the old memory
            //
            SysFreeString( *pbstrInout );
        } // if: new memory location

        if ( pmbCurrent != NULL )
        {
            //
            // Re-add the tracking block by reusing the old tracking block
            //
            pmbCurrent->bstr       = bstrTemp;
            pmbCurrent->dwBytes    = ucchIn;
            pmbCurrent->pszFile    = pszFileIn;
            pmbCurrent->nLine      = nLineIn;
            pmbCurrent->pszModule  = pszModuleIn;
            pmbCurrent->pszComment = pszCommentIn;
            pmbCurrent->pNext      = *ppmbHeadInout;
            *ppmbHeadInout         = pmbCurrent;

            //
            // Spew if needed
            //
            if ( IsTraceFlagSet( mtfMEMORYALLOCS ) )
            {
                DebugMemorySpew( pmbCurrent, TEXT("SysReAlloced") );
            } // if: tracing

        } // if: entry found
        else
        {
            //
            //  Create a new block.  Must use DebugMemoryAddToList() since we need to pass it the list that was passed
            //  into this function.
            //
            DebugMemoryAddToList( ppmbHeadInout, mmbtSYSALLOCSTRING, bstrTemp, pszFileIn, nLineIn, pszModuleIn, ucchIn + 1, pszCommentIn );
        } // else: make new entry

    } // else: allocation succeeded

    *pbstrInout = bstrTemp;
    return fReturn;

} //*** DebugSysReAllocStringLenList()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  INT
//  DebugSysReAllocStringLen(
//        LPCTSTR         pszFileIn
//      , const int       nLineIn
//      , LPCTSTR         pszModuleIn
//      , BSTR *          pbstrInout
//      , const OLECHAR * pszIn
//      , unsigned int    ucchIn
//      , LPCTSTR         pszCommentIn
//      )
//
//  Description:
//      Adds memory tracing to SysReAllocString().
//
//  Arguments:
//      pszFileIn       - Source file path
//      nLineIn         - Source line number
//      pszModuleIn     - Source module name
//      pbstrInout         - Pointer to the BSTR to realloc
//      pszIn           - String to be copied (see SysReAllocString)
//      pszCommentIn    - Comment about alloction
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
INT
DebugSysReAllocStringLen(
      LPCTSTR         pszFileIn
    , const int       nLineIn
    , LPCTSTR         pszModuleIn
    , BSTR *          pbstrInout
    , const OLECHAR * pszIn
    , unsigned int    ucchIn
    , LPCTSTR         pszCommentIn
    )
{
    BOOL    fReturn = FALSE;

    if ( g_fGlobalMemoryTacking )
    {
        EnterCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
        fReturn = DebugSysReAllocStringLenList( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->pmbList), pszFileIn, nLineIn, pszModuleIn, pbstrInout, pszIn, ucchIn, pszCommentIn );
        LeaveCriticalSection( &(((MEMORYBLOCKLIST *) g_GlobalMemoryList)->csList) );
    } // if:
    else
    {
        Assert( g_TraceMemoryIndex != -1 );

        MEMORYBLOCK * pmbCurrent = (MEMORYBLOCK *) TlsGetValue( g_TraceMemoryIndex );
        fReturn = DebugSysReAllocStringLenList( &pmbCurrent, pszFileIn, nLineIn, pszModuleIn, pbstrInout, pszIn, ucchIn, pszCommentIn );
        TlsSetValue( g_TraceMemoryIndex, pmbCurrent );
    } // else:

    return fReturn;

} //*** DebugSysReAllocStringLen()

#endif // USES_SYSALLOCSTRING

//****************************************************************************
//
//  Global Management Functions -
//
//  These are in debug and retail but internally they change
//  depending on the build.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
// DEBUG version
//
//  void *
//  _cdecl
//  operator new(
//      size_t      stSizeIn,
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn
//      )
//
//  Description:
//      Replacment for the operator new() in the CRTs. This should be used
//      in conjunction with the "new" macro. It will track the allocations.
//
//  Arguments:
//      stSizeIn    - Size of the object to create.
//      pszFileIn   - Source filename where the call was made.
//      nLineIn     - Source line number where the call was made.
//      pszModuleIn - Source module name where the call was made.
//
//  Return Values:
//      Void pointer to the new object.
//
//--
//////////////////////////////////////////////////////////////////////////////
#undef new
void *
__cdecl
operator new(
    size_t      stSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    )
{
    void * pv = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );

    return DebugMemoryAdd( mmbtOBJECT, pv, pszFileIn, nLineIn, pszModuleIn, stSizeIn, TEXT(" new() ") );

} //*** operator new( pszFileIn, etc. ) - DEBUG

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  void *
//  __cdecl
//  operator new(
//      size_t stSizeIn
//      )
//
//  Description:
//      Stub to prevent someone from not using the "new" macro or if somehow
//      the new macro was undefined. It routine will always Assert if called.
//
//  Arguments:
//      stSizeIn    - Not used.
//
//  Return Values:
//      NULL always.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new(
    size_t stSizeIn
    )
{
#if 1
    void * pv = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );
    AssertMsg( 0, "New Macro failure" );

    return DebugMemoryAdd( mmbtOBJECT, pv, g_szUnknown, 0, g_szUnknown, stSizeIn, TEXT(" new() ") );
#else
    AssertMsg( 0, "New Macro failure" );
    return NULL;
#endif

} //*** operator new() - DEBUG

/*
//////////////////////////////////////////////////////////////////////////////
//++
//
// DEBUG version
//
//  void *
//  _cdecl
//  operator new [](
//      size_t      stSizeIn,
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn
//      )
//
//  Description:
//      Replacment for the operator new() in the CRTs. This should be used
//      in conjunction with the "new" macro. It will track the allocations.
//
//  Arguments:
//      stSizeIn    - Size of the object to create.
//      pszFileIn   - Source filename where the call was made.
//      nLineIn     - Source line number where the call was made.
//      pszModuleIn - Source module name where the call was made.
//
//  Return Values:
//      Void pointer to the new object.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new [](
    size_t      stSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    )
{
    void * pv = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );

    return DebugMemoryAdd( mmbtOBJECT, pv, pszFileIn, nLineIn, pszModuleIn, stSizeIn, TEXT(" new []() ") );

} //*** operator new []( pszFileIn, etc. ) - DEBUG

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  void *
//  __cdecl
//  operator new [](
//      size_t stSizeIn
//      )
//
//  Description:
//      Stub to prevent someone from not using the "new" macro or if somehow
//      the new macro was undefined. It routine will always Assert if called.
//
//  Arguments:
//      stSizeIn    - Not used.
//
//  Return Values:
//      NULL always.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new [](
    size_t stSizeIn
    )
{
#if 1
    void * pv = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );
    AssertMsg( 0, "New Macro failure" );

    return DebugMemoryAdd( mmbtOBJECT, pv, g_szUnknown, 0, g_szUnknown, stSizeIn, TEXT(" new() ") );
#else
    AssertMsg( 0, "New Macro failure" );
    return NULL;
#endif

} //*** operator new []() - DEBUG
*/

//////////////////////////////////////////////////////////////////////////////
//++
//
// DEBUG version
//
//  void
//  _cdecl
//  operator delete(
//      void *      pvIn,
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn
//      )
//
//  Description:
//      Replacment for the operator delete() in the CRTs. It will remove the
//      object from the memory allocation tracking table.
//
//  Arguments:
//      pvIn        - Pointer to object being destroyed.
//      pszFileIn   - Source filename where the call was made.
//      nLineIn     - Source line number where the call was made.
//      pszModuleIn - Source module name where the call was made.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete(
    void *      pvIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    )
{
    DebugMemoryDelete( mmbtOBJECT, pvIn, pszFileIn, nLineIn, pszModuleIn, TRUE );
    HeapFree( GetProcessHeap(), 0, pvIn );

} //*** operator delete( pszFileIn, etc. ) - DEBUG


//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  void
//  __cdecl
//  operator delete(
//      void * pvIn
//      )
//
//  Description:
//      Replacment for the operator delete() in the CRTs. It will remove the
//      object from the memory allocation tracking table.
//
//  Arguments:
//      pvIn    - Pointer to object being destroyed.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete(
    void *      pvIn
    )
{
    DebugMemoryDelete( mmbtOBJECT, pvIn, g_szUnknown, 0, g_szUnknown, TRUE );
    HeapFree( GetProcessHeap(), 0, pvIn );

} //*** operator delete() - DEBUG
/*
//////////////////////////////////////////////////////////////////////////////
//++
//
// DEBUG version
//
//  void
//  _cdecl
//  operator delete [](
//      void *      pvIn,
//      LPCTSTR     pszFileIn,
//      const int   nLineIn,
//      LPCTSTR     pszModuleIn
//      )
//
//  Description:
//      Replacment for the operator delete() in the CRTs. It will remove the
//      object from the memory allocation tracking table.
//
//  Arguments:
//      pvIn        - Pointer to object being destroyed.
//      pszFileIn   - Source filename where the call was made.
//      nLineIn     - Source line number where the call was made.
//      pszModuleIn - Source module name where the call was made.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete [](
    void *      pvIn,
    size_t      stSizeIn,
    LPCTSTR     pszFileIn,
    const int   nLineIn,
    LPCTSTR     pszModuleIn
    )
{
    DebugMemoryDelete( mmbtOBJECT, pvIn, pszFileIn, nLineIn, pszModuleIn, TRUE );
    HeapFree( GetProcessHeap(), 0, pvIn );

} //*** operator delete( pszFileIn, etc. ) - DEBUG
*/

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  void
//  __cdecl
//  operator delete [](
//      void * pvIn
//      )
//
//  Description:
//      Replacment for the operator delete() in the CRTs. It will remove the
//      object from the memory allocation tracking table.
//
//  Arguments:
//      pvIn    - Pointer to object being destroyed.
//
//  Return Value:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete [](
    void *      pvIn
    )
{
    DebugMemoryDelete( mmbtOBJECT, pvIn, g_szUnknown, 0, g_szUnknown, TRUE );
    HeapFree( GetProcessHeap(), 0, pvIn );

} //*** operator delete []() - DEBUG

#if !defined(ENTRY_PREFIX)
//////////////////////////////////////////////////////////////////////////////
//++
//
//  DEBUG version
//
//  int
//  __cdecl
//  _purecall( void )
//
//  Description:
//      Stub for purecall functions. It will always Assert.
//
//  Arguments:
//      None.
//
//  Return Values:
//      E_UNEXPECTED always.
//
//////////////////////////////////////////////////////////////////////////////
int
__cdecl
_purecall( void )
{
    AssertMsg( 0, "Purecall" );
    return E_UNEXPECTED;

} //*** _purecall() - DEBUG
#endif // !defined(ENTRY_PREFIX)

#else // ! DEBUG -- It's retail

//****************************************************************************
//
//  Global Management Functions -
//
//  These are the retail version.
//
//****************************************************************************

//////////////////////////////////////////////////////////////////////////////
//++
//
//  RETAIL version
//
//  void *
//  _cdecl
//  operator new(
//      size_t      stSizeIn,
//      )
//
//  Description:
//      Replacment for the operator new() in the CRTs. Simply allocates a
//      block of memory for the object to use.
//
//  Arguments:
//      stSizeIn    - Size of the object to create.
//
//  Return Values:
//      Void pointer to the new object.
//
//--
//////////////////////////////////////////////////////////////////////////////
void *
__cdecl
operator new(
    size_t stSizeIn
    )
{
    return HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, stSizeIn );

} //*** operator new() - RETAIL

//////////////////////////////////////////////////////////////////////////////
//++
//
//  RETAIL version
//
//  void
//  __cdecl
//  operator delete(
//      void * pvIn
//      )
//
//  Description:
//      Replacment for the operator delete() in the CRTs. Simply frees the
//      memory.
//
//  Arguments:
//      pvIn    - Pointer to object being destroyed.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
operator delete(
    void * pv
    )
{
    HeapFree( GetProcessHeap(), 0, pv );

} //*** operator delete() - RETAIL

#if !defined(ENTRY_PREFIX)
//////////////////////////////////////////////////////////////////////////////
//++
//
//  RETAIL version
//
//  int
//  __cdecl
//  _purecall( void )
//
//  Description:
//      Stub for purecall functions.
//
//  Arguments:
//      None.
//
//  Return Values:
//      E_UNEXPECTED always.
//
//--
//////////////////////////////////////////////////////////////////////////////
int
__cdecl
_purecall( void )
{
    // BUGBUG: DavidP 08-DEC-1999 Shouldn't we assert?
    return E_UNEXPECTED;

} //*** _purecall() - RETAIL
#endif // !defined(ENTRY_PREFIX)

#define __MODULE__  NULL


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\log.h ===
//****************************************************************************
//
// Logging Functions
//
//****************************************************************************
HRESULT
HrLogOpen( void );

HRESULT
HrLogClose( void );

HRESULT
HrLogRelease( void );

void
__cdecl
LogMsg(
    LPCSTR  pszFormatIn,
    ...
    );

void
__cdecl
LogMsg(
    LPCWSTR pszFormatIn,
    ...
    );

void
__cdecl
LogMsgNoNewline(
    LPCSTR  pszFormatIn,
    ...
    );

void
__cdecl
LogMsgNoNewline(
    LPCWSTR pszFormatIn,
    ...
    );

void
LogStatusReport( SYSTEMTIME        * pstTimeIn,
                 const WCHAR       * pcszNodeNameIn,
                 CLSID               clsidTaskMajorIn,
                 CLSID               clsidTaskMinorIn,
                 ULONG               ulMinIn,
                 ULONG               ulMaxIn,
                 ULONG               ulCurrentIn,
                 HRESULT             hrStatusIn,
                 const WCHAR       * pcszDescriptionIn,
                 const WCHAR       * pcszUrlIn
                 );

void
LogTerminateProcess( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\pragmas.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      Pragmas.h
//
//  Description:
//      Project level pragmas.
//
//  Maintained By:
//      Galen Barbee (GalenB) 22-APR-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once


#pragma warning( disable : 4100 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4201 )
#pragma warning( disable : 4509 )
#pragma warning( disable : 4702 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\logsrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2000 Microsoft Corporation
//
//  Module Name:
//      LogSrc.cpp
//
//  Description:
//      Logging utilities.
//
//  Documentation:
//      Spec\Admin\Debugging.ppt
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <tchar.h>
#include "Common.h"


//****************************************************************************
//****************************************************************************
//
//  Logging Functions
//
//  These are in both DEBUG and RETAIL.
//
//****************************************************************************
//****************************************************************************

//
// Constants
//
static const int LOG_OUTPUT_BUFFER_SIZE = 512;

//
// Globals
//
CRITICAL_SECTION * g_pcsLogging = NULL;

HANDLE g_hLogFile = INVALID_HANDLE_VALUE;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrLogOpen( void )
//
//  Description:
//      This function:
//          - initializes the log critical section
//          - enters the log critical section assuring only one thread is
//            writing to the log at a time
//          - creates the directory tree to the log file (if needed)
//          - initializes the log file by:
//              - creating a new log file if one doesn't exist.
//              - opens an existing log file (for append)
//              - appends a time/date stamp that the log was (re)opened.
//
//      Use LogClose() to exit the log critical section.
//
//      If there is a failure inside this function, the log critical
//      section will be released before returning.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK - log critical section held and log open successfully
//      Otherwize HRESULT error code.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLogOpen( void )
{
    TCHAR   szFilePath[ MAX_PATH ];
    TCHAR   szModulePath[ MAX_PATH ];
    CHAR    szBuffer[ LOG_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HANDLE  hTemp;
    BOOL    fReturn;
    HRESULT hr;

    SYSTEMTIME SystemTime;

    //
    // Create a critical section to prevent lines from being fragmented.
    //
    if ( g_pcsLogging == NULL )
    {
        PCRITICAL_SECTION pNewCritSect =
            (PCRITICAL_SECTION) HeapAlloc( GetProcessHeap(), 0, sizeof( CRITICAL_SECTION ) );
        if ( pNewCritSect == NULL )
        {
            DebugMsg( "DEBUG: Out of Memory. Logging disabled." );
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        } // if: creation failed

        InitializeCriticalSection( pNewCritSect );

        // Make sure we only have one log critical section
        InterlockedCompareExchangePointer( (PVOID *) &g_pcsLogging, pNewCritSect, 0 );
        if ( g_pcsLogging != pNewCritSect )
        {
            DebugMsg( "DEBUG: Another thread already created the CS. Deleting this one." );
            DeleteCriticalSection( pNewCritSect );
            HeapFree( GetProcessHeap(), 0, pNewCritSect );

        } // if: already have another critical section

    } // if: no critical section created yet

    Assert( g_pcsLogging != NULL );
    EnterCriticalSection( g_pcsLogging );

    //
    // Make sure the log file is open
    //
    if ( g_hLogFile == INVALID_HANDLE_VALUE )
    {
        DWORD  dwLen;
        LPTSTR psz;

        //
        // Create the directory tree
        //
        // TODO: 12-DEC-2000 DavidP
        //      Change this to be more generic.  This shouldn't be specific
        //      to clustering.
        //
        ExpandEnvironmentStrings( TEXT("%windir%\\system32\\LogFiles\\Cluster"), szFilePath, MAX_PATH );
        hr = HrCreateDirectoryPath( szFilePath );
        if ( FAILED( hr ) )
        {
#if defined( DEBUG )
            if ( !( g_tfModule & mtfOUTPUTTODISK ) )
            {
                DebugMsg( "*ERROR* Failed to create directory tree %s", szFilePath );
            } // if: not logging to disk
#endif
            goto Error;
        } // if: failed

        //
        // Add filename
        //
        dwLen = GetModuleFileName( g_hInstance, szModulePath, sizeof( szModulePath ) / sizeof( szModulePath[ 0 ] ) );
        Assert( dwLen != 0 );
        _tcscpy( &szModulePath[ dwLen - 3 ], TEXT("log") );
        psz = _tcsrchr( szModulePath, TEXT('\\') );
        Assert( psz != NULL );
        if ( psz == NULL )
        {
            hr = E_POINTER;
            goto Error;
        }
        _tcscat( szFilePath, psz );

        //
        // Create it
        //
        g_hLogFile = CreateFile( szFilePath,
                                 GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_ALWAYS,
                                 FILE_FLAG_WRITE_THROUGH,
                                 NULL
                                 );
        if ( g_hLogFile == INVALID_HANDLE_VALUE )
        {
#if defined( DEBUG )
            if ( !( g_tfModule & mtfOUTPUTTODISK ) )
            {
                DebugMsg( "*ERROR* Failed to create log at %s", szFilePath );
            } // if: not logging to disk
#endif
            hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
            goto Error;
        } // if: failed

        // Seek to the end
        SetFilePointer( g_hLogFile, 0, NULL, FILE_END );

        //
        // Write the time/date the log was (re)openned.
        //
        GetLocalTime( &SystemTime );
        _snprintf( szBuffer,
                   sizeof( szBuffer ),
                   "*" ASZ_NEWLINE
                     "* %04u-%02u-%02u %02u:%02u:%02u.%03u" ASZ_NEWLINE
                     "*" ASZ_NEWLINE,
                   SystemTime.wYear,
                   SystemTime.wMonth,
                   SystemTime.wDay,
                   SystemTime.wHour,
                   SystemTime.wMinute,
                   SystemTime.wSecond,
                   SystemTime.wMilliseconds
                   );

        fReturn = WriteFile( g_hLogFile, szBuffer, strlen(szBuffer), &dwWritten, NULL );
        if ( ! fReturn )
        {
            hr = THR( HRESULT_FROM_WIN32( GetLastError() ) );
            goto Error;
        } // if: failed

        DebugMsg( "DEBUG: Created log at %s", szFilePath );

    } // if: file not already openned

    hr = S_OK;

Cleanup:

    return hr;

Error:

    DebugMsg( "LogOpen: Failed hr = 0x%08x", hr );

    if ( g_hLogFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( g_hLogFile );
        g_hLogFile = INVALID_HANDLE_VALUE;
    } // if: handle was open

    LeaveCriticalSection( g_pcsLogging );

    goto Cleanup;

} //*** HrLogOpen()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrLogRelease( void )
//
//  Description:
//      This actually just leaves the log critical section.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK always.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLogRelease( void )
{
    Assert( g_pcsLogging != NULL );
    LeaveCriticalSection( g_pcsLogging );
    return S_OK;

} //*** HrLogRelease()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrLogClose( void )
//
//  Description:
//      Close the file.  This function expects the critical section to have
//      already been released.
//
//  Arguments:
//      None.
//
//  Return Values:
//      S_OK always.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrLogClose( void )
{
    TraceFunc( "" );

    HRESULT     hr = S_OK;

    if ( g_hLogFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( g_hLogFile );
        g_hLogFile = INVALID_HANDLE_VALUE;
    } // if: handle was open

    return hr;

} //*** HrLogClose()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII
//
//  void
//  LogMsgNoNewline(
//      LPCSTR pszFormat,
//      ...
//      )
//
//  Description:
//      Logs a message to the log file without adding a newline.
//
//  Arguments:
//      pszFormat - A printf format string to be printed.
//      ,,,       - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
LogMsgNoNewline(
    LPCSTR pszFormat,
    ...
    )
{
    va_list valist;

    CHAR    szBuf[ LOG_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HRESULT hr;

#ifdef UNICODE
    WCHAR  szFormat[ LOG_OUTPUT_BUFFER_SIZE ];
    WCHAR  szTmpBuf[ LOG_OUTPUT_BUFFER_SIZE ];

    mbstowcs( szFormat, pszFormat, strlen( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szTmpBuf, szFormat, valist );
    va_end( valist );

    dwWritten = wcstombs( szBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
    if ( dwWritten == - 1 )
    {
        dwWritten = strlen( szBuf );
    } // if: bad character found
#else
    va_start( valist, pszFormat );
    dwWritten = wvsprintf( szBuf, pszFormat, valist );
    va_end( valist );
#endif // UNICODE

    hr = HrLogOpen();
    if ( hr != S_OK )
    {
        return;
    } // if: failed

    // LogDateTime();
    WriteFile( g_hLogFile, szBuf, dwWritten, &dwWritten, NULL );

    HrLogRelease();

} //*** LogMsgNoNewline() ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE
//
//  void
//  LogMsgNoNewline(
//      LPCWSTR pszFormat,
//      ...
//      )
//
//  Description:
//      Logs a message to the log file without adding a newline.
//
//  Arguments:
//      pszFormat - A printf format string to be printed.
//      ,,,       - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
LogMsgNoNewline(
    LPCWSTR pszFormat,
    ...
    )
{
    va_list valist;

    CHAR    szBuf[ LOG_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HRESULT hr;

#ifdef UNICODE
    WCHAR  szTmpBuf[ LOG_OUTPUT_BUFFER_SIZE ];

    va_start( valist, pszFormat );
    wvsprintf( szTmpBuf, pszFormat, valist);
    va_end( valist );

    dwWritten = wcstombs( szBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
    if ( dwWritten == -1 )
    {
        dwWritten = strlen( szBuf );
    } // if: bad character found
#else
    CHAR szFormat[ LOG_OUTPUT_BUFFER_SIZE ];

    wcstombs( szFormat, pszFormat, wcslen( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    dwWritten = wvsprintf( szBuf, szFormat, valist);
    va_end( valist );

#endif // UNICODE

    hr = HrLogOpen();
    if ( hr != S_OK )
    {
        return;
    } // if: failed

    // LogDateTime();
    WriteFile( g_hLogFile, szBuf, dwWritten, &dwWritten, NULL );

    HrLogRelease();

} //*** LogMsgNoNewline() UNICODE

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  LogFormatStatusReport(
//      CHAR ** ppaszBuffer,
//      int     iFirstArg,
//      ...
//      )
//
//  Description:
//      Formats a status report for writing to the log file.
//
//  Arugments:
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
DWORD
LogFormatStatusReport(
    CHAR ** ppaszBuffer,
    int     iFirstArg,
    ...
    )
{
    va_list valist;

    va_start( valist, iFirstArg );

    DWORD dw;

    dw = FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        "%2!02u!/%3!02u!/%4!04u!-%5!02u!:%6!02u!:%7!02u!.%8!02u! - %9!02u!/%10!02u!/%11!04u!-%12!02u!:%13!02u!:%14!02u!.%15!02u!  {%16!08X!-%17!04X!-%18!04X!-%19!02X!%20!02X!-%21!02X!%22!02X!%23!02X!%24!02X!%25!02X!%26!02X!}, {%27!08X!-%28!04X!-%29!04X!-%30!02X!%31!02X!-%32!02X!%33!02X!%34!02X!%35!02X!%36!02X!%37!02X!} (%38!2d! / %39!2d! .. %40!2d! ) <%41!ws!> hr=%42!08X! %43!ws! %44!ws!" ASZ_NEWLINE,
        0,
        0,
        (LPSTR) ppaszBuffer,
        256,
        &valist
        );

    return dw;

} //*** LogFormatStatusReport()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  LogDateTime( void )
//
//  Description:
//      Adds date/time stamp to the log without a CR. This should be done
//      while holding the Logging critical section which is done by calling
//      HrLogOpen().
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
LogDateTime( void )
{
    static CHAR       szBuffer[ 25 ];
    static SYSTEMTIME OldSystemTime = { 0 };
    static DWORD      dwWritten;

    SYSTEMTIME SystemTime;
    DWORD      dwWhoCares;
    int        iCmp;

    GetLocalTime( &SystemTime );

    //
    // Avoid expensive printf by comparing times
    //
    iCmp = memcmp( (PVOID) &SystemTime, (PVOID) &OldSystemTime, sizeof( SYSTEMTIME ) );
    if ( iCmp != 0 )
    {
        dwWritten = _snprintf( szBuffer,
                               sizeof( szBuffer ),
                               "%04u-%02u-%02u %02u:%02u:%02u.%03u ",
                               SystemTime.wYear,
                               SystemTime.wMonth,
                               SystemTime.wDay,
                               SystemTime.wHour,
                               SystemTime.wMinute,
                               SystemTime.wSecond,
                               SystemTime.wMilliseconds
                               );
        Assert( dwWritten < 25 && dwWritten != -1 );

        CopyMemory( (PVOID) &OldSystemTime, (PVOID) &SystemTime, sizeof( SYSTEMTIME ) );

    } // if: time last different from this time

    WriteFile( g_hLogFile, szBuffer, dwWritten, &dwWhoCares, NULL );

} //*** LogDateTime()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  LogSystemTime( SYSTEMTIME stSystemTimeIn )
//
//  Description:
//      Adds date/time stamp to the log without a CR. This should be done
//      while holding the Logging critical section which is done by calling
//      HrLogOpen().
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
LogSystemTime( SYSTEMTIME * stSystemTimeIn )
{
    static CHAR       szBuffer[ 25 ];

    DWORD             dwWhoCares;
    DWORD             dwWritten;

    dwWritten = _snprintf( szBuffer,
                           sizeof( szBuffer ),
                           "%04u-%02u-%02u %02u:%02u:%02u.%03u ",
                           stSystemTimeIn->wYear,
                           stSystemTimeIn->wMonth,
                           stSystemTimeIn->wDay,
                           stSystemTimeIn->wHour,
                           stSystemTimeIn->wMinute,
                           stSystemTimeIn->wSecond,
                           stSystemTimeIn->wMilliseconds
                           );

    Assert( dwWritten < 25 && dwWritten != -1 );

    WriteFile( g_hLogFile, szBuffer, dwWritten, &dwWhoCares, NULL );

} //*** LogSystemTime()

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ASCII
//
//  void
//  LogMsg(
//      LPCSTR pszFormat,
//      ...
//      )
//
//  Description:
//      Logs a message to the log file and adds a newline.
//
//  Arguments:
//      pszFormat - A printf format string to be printed.
//      ,,,       - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
LogMsg(
    LPCSTR pszFormat,
    ...
    )
{
    va_list valist;

    CHAR    szBuf[ LOG_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HRESULT hr;

#ifdef UNICODE
    WCHAR  szFormat[ LOG_OUTPUT_BUFFER_SIZE ];
    WCHAR  szTmpBuf[ LOG_OUTPUT_BUFFER_SIZE ];

    mbstowcs( szFormat, pszFormat, strlen( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szTmpBuf, szFormat, valist);
    va_end( valist );

    dwWritten = wcstombs( szBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
    if ( dwWritten == - 1 )
    {
        dwWritten = strlen( szBuf );
    } // if: bad character found
#else
    va_start( valist, pszFormat );
    dwWritten = wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );
#endif // UNICODE

    hr = HrLogOpen();
    if ( FAILED( hr ) )
        goto Cleanup;

    LogDateTime();
    WriteFile( g_hLogFile, szBuf, dwWritten, &dwWritten, NULL );
    WriteFile( g_hLogFile, ASZ_NEWLINE, SIZEOF_ASZ_NEWLINE, &dwWritten, NULL );

    HrLogRelease();

Cleanup:
    return;

} //*** LogMsg() ASCII

//////////////////////////////////////////////////////////////////////////////
//++
//
//  UNICODE
//
//  void
//  LogMsg(
//      LPCWSTR pszFormat,
//      ...
//      )
//
//  Description:
//      Logs a message to the log file and adds a newline.
//
//  Arguments:
//      pszFormat - A printf format string to be printed.
//      ,,,       - Arguments for the printf string.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
LogMsg(
    LPCWSTR pszFormat,
    ...
    )
{
    va_list valist;

    CHAR    szBuf[ LOG_OUTPUT_BUFFER_SIZE ];
    DWORD   dwWritten;
    HRESULT hr;

#ifdef UNICODE
    WCHAR  szTmpBuf[ LOG_OUTPUT_BUFFER_SIZE ];

    va_start( valist, pszFormat );
    wvsprintf( szTmpBuf, pszFormat, valist);
    va_end( valist );

    dwWritten = wcstombs( szBuf, szTmpBuf, wcslen( szTmpBuf ) + 1 );
    if ( dwWritten == -1 )
    {
        dwWritten = strlen( szBuf );
    } // if: bad character found
#else
    CHAR szFormat[ LOG_OUTPUT_BUFFER_SIZE ];

    wcstombs( szFormat, pszFormat, wcslen( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    dwWritten = wvsprintf( szBuf, szFormat, valist);
    va_end( valist );

#endif // UNICODE

    hr = HrLogOpen();
    if ( FAILED( hr ) )
        goto Cleanup;

    LogDateTime();
    WriteFile( g_hLogFile, szBuf, dwWritten, &dwWritten, NULL );
    WriteFile( g_hLogFile, ASZ_NEWLINE, SIZEOF_ASZ_NEWLINE, &dwWritten, NULL );

    HrLogRelease();

Cleanup:
    return;

} //*** LogMsg() UNICODE

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  LogStatusReport(
//      SYSTEMTIME  * pstTimeIn,
//      const WCHAR * pcszNodeNameIn,
//      CLSID       clsidTaskMajorIn,
//      CLSID       clsidTaskMinorIn,
//      ULONG       ulMinIn,
//      ULONG       ulMaxIn,
//      ULONG       ulCurrentIn,
//      HRESULT     hrStatusIn,
//      const WCHAR * pcszDescriptionIn,
//      const WCHAR * pcszUrlIn
//      )
//
//  Description:
//      Writes a status report to the log file.
//
//  Arugments:
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
LogStatusReport(
    SYSTEMTIME  * pstTimeIn,
    const WCHAR * pcszNodeNameIn,
    CLSID       clsidTaskMajorIn,
    CLSID       clsidTaskMinorIn,
    ULONG       ulMinIn,
    ULONG       ulMaxIn,
    ULONG       ulCurrentIn,
    HRESULT     hrStatusIn,
    const WCHAR * pcszDescriptionIn,
    const WCHAR * pcszUrlIn
    )
{
    HRESULT hr;
    DWORD dw;
    DWORD dwWritten;

    unsigned long   dwArray[50];

    CHAR *          paszBuffer = NULL;

    SYSTEMTIME      SystemTime;
    SYSTEMTIME      SystemTime2;

    GetLocalTime( &SystemTime );

    if ( pstTimeIn )
    {
        memcpy( &SystemTime2, pstTimeIn, sizeof( SYSTEMTIME ) );
    }
    else
    {
        memset( &SystemTime2, 0, sizeof( SYSTEMTIME) );
    }

    dw = LogFormatStatusReport(
            &paszBuffer,
            0, 0,
        // Time One.
            SystemTime.wMonth,        //1
            SystemTime.wDay,          //2
            SystemTime.wYear,         //3
            SystemTime.wHour,         //4
            SystemTime.wMinute,       //5
            SystemTime.wSecond,       //6
            SystemTime.wMilliseconds, //7
        // Time Two
            SystemTime2.wMonth,
            SystemTime2.wDay,
            SystemTime2.wYear,
            SystemTime2.wHour,
            SystemTime2.wMinute,
            SystemTime2.wSecond,
            SystemTime2.wMilliseconds,
        // GUID One
            clsidTaskMajorIn.Data1,
            clsidTaskMajorIn.Data2,
            clsidTaskMajorIn.Data3,
            clsidTaskMajorIn.Data4[0],
            clsidTaskMajorIn.Data4[1],
            clsidTaskMajorIn.Data4[2],
            clsidTaskMajorIn.Data4[3],
            clsidTaskMajorIn.Data4[4],
            clsidTaskMajorIn.Data4[5],
            clsidTaskMajorIn.Data4[6],
            clsidTaskMajorIn.Data4[7],
        // GUID Two
            clsidTaskMinorIn.Data1,
            clsidTaskMinorIn.Data2,
            clsidTaskMinorIn.Data3,
            clsidTaskMinorIn.Data4[0],
            clsidTaskMinorIn.Data4[1],
            clsidTaskMinorIn.Data4[2],
            clsidTaskMinorIn.Data4[3],
            clsidTaskMinorIn.Data4[4],
            clsidTaskMinorIn.Data4[5],
            clsidTaskMinorIn.Data4[6],
            clsidTaskMinorIn.Data4[7],
        // Other...
            ulCurrentIn,
            ulMinIn,
            ulMaxIn,
            pcszNodeNameIn,
            hrStatusIn,
            pcszDescriptionIn,
            pcszUrlIn,
            0,
            0
            );

    // Open the log file.

    hr = HrLogOpen();

    if ( hr != S_OK )
    {
        return;
    } // if: failed

    // Write the initial output.
    WriteFile( g_hLogFile, paszBuffer, dw, &dwWritten, NULL );

    HrLogRelease();

    LocalFree( paszBuffer );

} //*** LogStatusReport

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  LogTerminateProcess( void )
//
//  Description:
//      Cleans up anything the logging routines may have created or
//      initialized. Typical called from the TraceTerminateProcess() macro.
//
//  Arugments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
LogTerminateProcess( void )
{
} //*** LogTerminateProcess()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\proplist.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2000 Microsoft Corporation
//
//  Module Name:
//      PropList.h
//
//  Implementation File:
//      PropList.cpp
//
//  Description:
//      Definition of the CClusPropList class.
//
//  Documentation:
//
//  Implementation File:
//      PropList.cpp
//
//  Maintained By:
//      Galen Barbee (GalenB) 31-MAY-2000
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

//class CObjectProperty;
class CClusPropValueList;
class CClusPropList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusPropValueList
//
//  Description:
//      Describes a cluster property list.
//
//  Inheritance:
//      CClusPropValueList
//
//--
/////////////////////////////////////////////////////////////////////////////

class CClusPropValueList
{
public:
    //
    // Construction.
    //

    // Default constructor
    CClusPropValueList( void )
        : m_cbDataSize( 0 )
        , m_cbDataLeft( 0 )
        , m_cbBufferSize( 0 )
        , m_bAtEnd( FALSE )
    {
        m_cbhValueList.pb = NULL;
        m_cbhCurrentValue.pb = NULL;

    } //*** CClusPropValueList()

    // Copy constructor.
    CClusPropValueList( IN const CClusPropValueList & rcpvl )
        : m_cbBufferSize( 0 )
        , m_bAtEnd( FALSE )
    {
        Init( rcpvl );

    } //*** CClusPropValueList()

    // Buffer helper constructor.
    CClusPropValueList( IN CLUSPROP_BUFFER_HELPER cbhValueList, IN DWORD cbDataSize )
        : m_cbBufferSize( 0 )
        , m_bAtEnd( FALSE )
    {
        Init( cbhValueList, cbDataSize );

    } //*** CClusPropValueList()

    // Destructor
    ~CClusPropValueList( void )
    {
        DeleteValueList();

    } //*** ~CClusPropValueList()

    // Initialize the value list
    void Init( IN const CClusPropValueList & rcpvl )
    {
        Assert( m_cbBufferSize == 0 );

        m_cbhValueList      = rcpvl.m_cbhValueList;
        m_cbhCurrentValue   = rcpvl.m_cbhCurrentValue;
        m_cbDataSize        = rcpvl.m_cbDataSize;
        m_cbDataLeft        = rcpvl.m_cbDataLeft;
        m_bAtEnd            = rcpvl.m_bAtEnd;

    } //*** Init()

    // Initialize the value list from a buffer helper
    void Init( IN const CLUSPROP_BUFFER_HELPER cbhValueList, IN DWORD cbDataSize )
    {
        Assert( m_cbBufferSize == 0 );

        m_cbhValueList      = cbhValueList;
        m_cbhCurrentValue   = cbhValueList;
        m_cbDataSize        = cbDataSize;
        m_cbDataLeft        = cbDataSize;
        m_bAtEnd            = FALSE;

    } //*** Init()

    // Assignment operator
    void operator=( IN const CClusPropValueList & rcpvl )
    {
        Assert( m_cbBufferSize == 0 );

        m_cbhValueList      = rcpvl.m_cbhValueList;
        m_cbhCurrentValue   = rcpvl.m_cbhCurrentValue;
        m_cbDataSize        = rcpvl.m_cbDataSize;
        m_cbDataLeft        = rcpvl.m_cbDataLeft;
        m_bAtEnd            = rcpvl.m_bAtEnd;

    } //*** operator=()

public:
    //
    // Accessor methods.
    //

    // Buffer helper cast operator to access the current value
    operator const CLUSPROP_BUFFER_HELPER( void ) const
    {
        return m_cbhCurrentValue;

    } //*** operator CLUSPROP_BUFFER_HELPER()

    // Access the value list
    CLUSPROP_BUFFER_HELPER CbhValueList( void ) const
    {
        return m_cbhValueList;

    } //*** CbhValueList()

    // Access the current value
    CLUSPROP_BUFFER_HELPER CbhCurrentValue( void ) const
    {
        return m_cbhCurrentValue;

    } //*** CbhCurrentValue()

    // Access the format of the current value
    CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
    {
        return static_cast< CLUSTER_PROPERTY_FORMAT >( m_cbhCurrentValue.pValue->Syntax.wFormat );

    } //*** CpfCurrentValueFormat()

    // Access the type of the current value
    CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
    {
        return static_cast< CLUSTER_PROPERTY_TYPE >( m_cbhCurrentValue.pValue->Syntax.wType );

    } //*** CptCurrentValueType()

    // Access the syntax of the current value
    CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
    {
        return static_cast< CLUSTER_PROPERTY_SYNTAX >( m_cbhCurrentValue.pValue->Syntax.dw );

    } //*** CpsCurrentValueSyntax()

    // Access the length of the data of the current value
    DWORD CbCurrentValueLength( void ) const
    {
        DWORD cbLength;

        if ( m_cbhCurrentValue.pb == NULL )
        {
            cbLength = 0;
        } // if: no value list allocated yet
        else
        {
            cbLength = m_cbhCurrentValue.pValue->cbLength;
        } // else: value list allocated

        return cbLength;

    } //*** CbCurrentValueLength()

    // Access size of the data in the buffer.
    DWORD CbDataSize( void ) const
    {
        return m_cbDataSize;

    } //*** CbDataSize()

    // Access amount of data left in buffer after current value
    DWORD CbDataLeft( void ) const
    {
        return m_cbDataLeft;

    } //*** CbDataLeft()

public:
    //
    // Parsing methods.
    //

    // Move to the first value in the list
    DWORD ScMoveToFirstValue( void );

    // Move the value after the current one in the list
    DWORD ScMoveToNextValue( void );

    // Query whether we are at the last value in the list or not
    DWORD ScCheckIfAtLastValue( void );

public:
    //
    // Methods for building a value list.
    //

    // Allocate a value list
    DWORD ScAllocValueList( IN DWORD cbMinimum );

    // Delete the value list buffer and cleanup support variables
    void DeleteValueList( void )
    {
        //
        // If m_cbBufferSize is greater then 0 then we allocated the value list.
        // If it's zero then the value list is a part of the property list in
        // CClusPropList.
        //
        if ( m_cbBufferSize > 0 )
        {
            delete [] m_cbhValueList.pb;
            m_cbhValueList.pb = NULL;
            m_cbhCurrentValue.pb = NULL;
            m_cbBufferSize = 0;
            m_cbDataSize = 0;
            m_cbDataLeft = 0;
            m_bAtEnd = FALSE;
        } // if: we allocated anything

    } //*** DeletePropList()

    // Get a value list from a resource
    DWORD ScGetResourceValueList(
                        IN HRESOURCE    hResource,
                        IN DWORD        dwControlCode,
                        IN HNODE        hHostNode       = NULL,
                        IN LPVOID       lpInBuffer      = NULL,
                        IN DWORD        cbInBufferSize  = 0
                        );

    // Get a value list from a resource type
    DWORD ScGetResourceTypeValueList(
                        IN HCLUSTER hCluster,
                        IN LPCWSTR  pwszResTypeName,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN DWORD    cbInBufferSize  = 0
                        );

private:
    CLUSPROP_BUFFER_HELPER  m_cbhValueList;     // Pointer to the value list for parsing.
    CLUSPROP_BUFFER_HELPER  m_cbhCurrentValue;  // Pointer to the current value for parsing.
    DWORD                   m_cbDataSize;       // Amount of data in the buffer.
    DWORD                   m_cbDataLeft;       // Amount of data left in buffer after current value.
    DWORD                   m_cbBufferSize;     // Size of the buffer if we allocated it.
    BOOL                    m_bAtEnd;           // Indicates whether at last value in list.

}; //*** class CClusPropValueList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusPropList
//
//  Description:
//      Describes a cluster property list.
//
//  Inheritance:
//      CClusPropList
//      CObject (MFC only)
//
//--
/////////////////////////////////////////////////////////////////////////////
class CClusPropList
{
public:
    //
    // Construction.
    //

    // Default constructor
    CClusPropList( IN BOOL bAlwaysAddProp = FALSE )
        : m_bAlwaysAddProp( bAlwaysAddProp )
        , m_cbBufferSize( 0 )
        , m_cbDataSize( 0 )
        , m_cbDataLeft( 0 )
        , m_nPropsRemaining( 0 )
    {
        m_cbhPropList.pList     = NULL;
        m_cbhCurrentProp.pb     = NULL;
        m_cbhCurrentPropName.pb = NULL;

    } //*** CClusPropList()

    // Destructor
    ~CClusPropList( void )
    {
        DeletePropList();

    } //*** ~CClusPropList()

    // Copy list into this list (like assignment operator)
    DWORD ScCopy( IN const PCLUSPROP_LIST pcplPropList, IN DWORD cbListSize );

    // Delete the property list buffer and cleanup support variables
    void DeletePropList( void )
    {
        delete [] m_cbhPropList.pb;
        m_cbhPropList.pb = NULL;
        m_cbhCurrentProp.pb = NULL;
        m_cbhCurrentPropName.pb = NULL;
        m_cbBufferSize = 0;
        m_cbDataSize = 0;
        m_cbDataLeft = 0;

    } //*** DeletePropList()

protected:
    //
    // Attributes.
    //

    BOOL                    m_bAlwaysAddProp;       // Indicate if properties should be added even if not different.
    CLUSPROP_BUFFER_HELPER  m_cbhPropList;          // Pointer to the beginning of the list.
    CLUSPROP_BUFFER_HELPER  m_cbhCurrentProp;       // Pointer to the current property.
    DWORD                   m_cbBufferSize;         // Allocated size of the buffer.
    DWORD                   m_cbDataSize;           // Amount of data in the buffer.
    DWORD                   m_cbDataLeft;           // Amount of data left in buffer after current value.

private:
    CLUSPROP_BUFFER_HELPER  m_cbhCurrentPropName;   // Pointer to the current name for parsing
    DWORD                   m_nPropsRemaining;      // Used by BMoveToNextProperty() to track end of list.
    CClusPropValueList      m_pvlValues;            // Helper class for value list of current property.

public:
    //
    // Accessor methods.
    //

    // Access the values of the current property
    const CClusPropValueList & RPvlPropertyValue( void )
    {
        return m_pvlValues;

    } //*** RPvlPropertyValue()

    // Access the property list
    operator PCLUSPROP_LIST( void ) const
    {
        return m_cbhPropList.pList;

    } //*** operator PCLUSPROP_LIST()

    // Access allocated size of the buffer
    DWORD CbBufferSize( void ) const
    {
        return m_cbBufferSize;

    } //*** CbBufferSize()

    // Access the name of the current property
    LPCWSTR PszCurrentPropertyName( void ) const
    {
        return m_cbhCurrentPropName.pName->sz;

    } //*** PszCurrentPropertyName()

    // Access the current property name as a buffer helper
    const CLUSPROP_BUFFER_HELPER CbhCurrentPropertyName( void )
    {
        return m_cbhCurrentPropName;

    } //*** CbhCurrentPropertyName()

    // Access value list of the current property as a buffer helper
    const CLUSPROP_BUFFER_HELPER CbhCurrentValueList( void )
    {
        return m_pvlValues.CbhValueList();

    } //*** CbhCurrentValueList()

    // Access current value of the current property as a buffer helper
    const CLUSPROP_BUFFER_HELPER CbhCurrentValue( void )
    {
        return m_pvlValues.CbhCurrentValue();

    } //*** CbhCurrentValue()

    // Access the format of the current value of the current property
    CLUSTER_PROPERTY_FORMAT CpfCurrentValueFormat( void ) const
    {
        return m_pvlValues.CpfCurrentValueFormat();

    } //*** CpfCurrentValueFormat()

    // Access the type of the current value of the current property
    CLUSTER_PROPERTY_TYPE CptCurrentValueType( void ) const
    {
        return m_pvlValues.CptCurrentValueType();

    } //*** CptCurrentValueType()

    // Access the syntax of the current value of the current property
    CLUSTER_PROPERTY_SYNTAX CpsCurrentValueSyntax( void ) const
    {
        return m_pvlValues.CpsCurrentValueSyntax();

    } //*** CpsCurrentValueSyntax()

    // Access the length of the current value of the current property
    DWORD CbCurrentValueLength( void ) const
    {
        return m_pvlValues.CbCurrentValueLength();

    } //*** CbCurrentValueLength()

    PCLUSPROP_LIST Plist( void )
    {
        return m_cbhPropList.pList;

    } //*** Plist()

    const CLUSPROP_BUFFER_HELPER CbhPropList( void ) const
    {
        return m_cbhPropList;

    } //*** CbhPropList()

    PBYTE PbPropList( void ) const
    {
        return m_cbhPropList.pb;

    } //*** PbPropList()

    DWORD CbPropList( void ) const
    {
        return m_cbDataSize + sizeof( CLUSPROP_SYNTAX ); /*endmark*/

    } //*** CbPropList()

    // Access amount of data left in buffer after current value
    DWORD CbDataLeft( void ) const
    {
        return m_cbDataLeft;

    } //*** CbDataLeft()

    DWORD Cprops( void ) const
    {
        if ( m_cbhPropList.pb == NULL )
        {
            return 0;
        } // if:  no buffer yet

        return m_cbhPropList.pList->nPropertyCount;

    } //*** Cprops()

public:
    //
    // Parsing methods.
    //

    // Initialize the size after getting properties from an external source
    void InitSize( IN DWORD cbSize )
    {
        Assert( m_cbhPropList.pb != NULL );
        Assert( m_cbBufferSize > 0 );

        m_cbDataSize = cbSize;
        m_cbDataLeft = cbSize;

    } //*** InitSize()

    // Move to the first property in the list
    DWORD ScMoveToFirstProperty( void );

    // Move the property after the current one in the list
    DWORD ScMoveToNextProperty( void );

    // Move to a property by specifying its name
    DWORD ScMoveToPropertyByName( IN LPCWSTR pwszPropName );

    // Move to the first value in the current property
    DWORD ScMoveToFirstPropertyValue( void )
    {
        return m_pvlValues.ScMoveToFirstValue();

    } //*** ScMoveToFirstPropertyValue()

    // Move the the value after the current on in the current property
    DWORD ScMoveToNextPropertyValue( void )
    {
        return m_pvlValues.ScMoveToNextValue();

    } //*** ScMoveToNextPropertyValue()

    // Query whether we are at the last property in the list or not
    DWORD ScCheckIfAtLastProperty( void ) const
    {
        DWORD _sc;

        if ( m_nPropsRemaining <= 1 )
        {
            _sc = ERROR_NO_MORE_ITEMS;
        } // if:  at the last property
        else
        {
            _sc = ERROR_SUCCESS;
        } // else:  not at the last property

        return _sc;

    } //*** ScCheckIfAtLastProperty()

    // Query whether the list is empty or not
    BOOL BIsListEmpty( void ) const
    {
        Assert( m_cbhPropList.pb != NULL );
        Assert( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) );

        return m_cbhPropList.pList->nPropertyCount == 0;

    } //*** BIsListEmpty()

public:
    //
    // Methods for building a property list.
    //

    // Allocate a property list
    DWORD ScAllocPropList( IN DWORD cbMinimum );

    void ClearPropList( void )
    {
        m_cbDataSize = 0;
        m_cbDataLeft = 0;

        if ( m_cbBufferSize != 0 )
        {
            ZeroMemory( m_cbhPropList.pb, m_cbBufferSize );
            m_cbhCurrentProp.pb = m_cbhPropList.pb + sizeof( m_cbhPropList.pList->nPropertyCount );
            m_cbhCurrentPropName = m_cbhCurrentProp;
        } // if:  buffer already allocated

    } //*** ClearPropList()

    DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

    DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

    DWORD ScAddMultiSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue, IN LPCWSTR pwszPrevValue );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN DWORD nValue, IN DWORD nPrevValue );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN LONG nValue, IN LONG nPrevValue );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN ULONGLONG ullValue, IN ULONGLONG ullPrevValue );

    DWORD ScSetPropToDefault( IN LPCWSTR pwszName, IN CLUSTER_PROPERTY_FORMAT propfmt );

    DWORD ScAddProp(
            IN LPCWSTR      pwszName,
            IN const PBYTE  pbValue,
            IN DWORD        cbValue,
            IN const PBYTE  pbPrevValue,
            IN DWORD        cbPrevValue
            );

    DWORD ScAddProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
    {
        return ScAddProp( pwszName, pwszValue, NULL );

    } //*** ScAddProp()

    DWORD ScAddExpandSzProp( IN LPCWSTR pwszName, IN LPCWSTR pwszValue )
    {
        return ScAddExpandSzProp( pwszName, pwszValue, NULL );

    } //*** ScAddExpandSzProp()

public:
    //
    // Get Property methods.
    //

    DWORD ScGetNodeProperties(
                        IN HNODE    hNode,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN DWORD    cbInBufferSize  = 0
                        );

    DWORD ScGetGroupProperties(
                        IN HGROUP   hGroup,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN DWORD    cbInBufferSize  = 0
                        );

    DWORD ScGetResourceProperties(
                        IN HRESOURCE    hResource,
                        IN DWORD        dwControlCode,
                        IN HNODE        hHostNode       = NULL,
                        IN LPVOID       lpInBuffer      = NULL,
                        IN DWORD        cbInBufferSize  = 0
                        );

    DWORD ScGetResourceTypeProperties(
                        IN HCLUSTER hCluster,
                        IN LPCWSTR  pwszResTypeName,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN DWORD    cbInBufferSize  = 0
                        );

    DWORD ScGetNetworkProperties(
                        IN HNETWORK hNetwork,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN DWORD    cbInBufferSize  = 0
                        );

    DWORD ScGetNetInterfaceProperties(
                        IN HNETINTERFACE    hNetInterface,
                        IN DWORD            dwControlCode,
                        IN HNODE            hHostNode       = NULL,
                        IN LPVOID           lpInBuffer      = NULL,
                        IN DWORD            cbInBufferSize  = 0
                        );

    DWORD ScGetClusterProperties(
                        IN HCLUSTER hCluster,
                        IN DWORD    dwControlCode,
                        IN HNODE    hHostNode       = NULL,
                        IN LPVOID   lpInBuffer      = NULL,
                        IN DWORD    cbInBufferSize  = 0
                        );

// Implementation
protected:
    void CopyProp(
            IN PCLUSPROP_SZ             pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LPCWSTR                  psz,
            IN size_t                   cbsz = 0
            );

    void CopyExpandSzProp(
            IN PCLUSPROP_SZ             pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LPCWSTR                  psz,
            IN size_t                   cbsz = 0
            );

    void CopyMultiSzProp(
            IN PCLUSPROP_MULTI_SZ       pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LPCWSTR                  psz,
            IN size_t                   cbsz = 0
            );

    void CopyProp(
            IN PCLUSPROP_DWORD          pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN DWORD                    nValue
            );

#if CLUSAPI_VERSION >= 0x0500

    void CopyProp(
            IN PCLUSPROP_LONG           pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN LONG                     nValue
            );

#endif // CLUSAPI_VERSION >= 0x0500

    void CopyProp(
            OUT PCLUSPROP_ULARGE_INTEGER    pprop,
            IN  CLUSTER_PROPERTY_TYPE       proptype,
            IN  ULONGLONG                   nValue
            );

    void CopyProp(
            IN PCLUSPROP_BINARY         pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN const PBYTE              pb,
            IN size_t                   cb
            );

    void CopyEmptyProp(
            IN PCLUSPROP_VALUE          pprop,
            IN CLUSTER_PROPERTY_TYPE    proptype,
            IN CLUSTER_PROPERTY_FORMAT  propfmt
            );

}; //*** class CClusPropList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\register.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Register.h
//
//  Description:
//      Registering the COM classes implementation.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 22-NOV-1999
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#if defined(MMC_SNAPIN_REGISTRATION)
//
//  These tables are for registering the Snap-ins in the MMC Snapin/Node 
//  registration area of the registry.
//
struct SExtensionTable
{
    const CLSID *           rclsid;                     // CLSID of the Snap-in Extension COM Object
    LPCWSTR                 pszInternalName;            // Registry Description - no need to localize
};

struct SNodeTypesTable
{
    const CLSID *           rclsid;                     // CLSID of the Node Type (this doesn't need to be a COM Object)
    LPCWSTR                 pszInternalName;            // Registry Description - no need to localize
    const SExtensionTable * pNameSpace;                 // Namespace extension table
    const SExtensionTable * pPropertySheet;             // Property Page extension table
    const SExtensionTable * pContextMenu;               // Context menu extension table
    const SExtensionTable * pToolBar;                   // Toolbar extension table
    const SExtensionTable * pTask;                      // Taskpad extension table
};

struct SSnapInTable
{
    const CLSID *           rclsid;                     // CLSID of the Snap-in COM Object
    LPCWSTR                 pszInternalName;            // Registry Description - no need to localize
    LPCWSTR                 pszDisplayName;             // TODO: make it internationalizable.
    BOOL                    fStandAlone;                // Marks the Snap-in as StandAlone if TRUE in the registry.
    const SNodeTypesTable * pntt;                       // Node type extension table.
};

extern const SNodeTypesTable g_SNodeTypesTable[ ];
#endif // defined(MMC_SNAPIN_REGISTRATION)

HRESULT
HrRegisterDll( BOOL fCreate );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\smartclasses.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      SmartClasses.h
//
//  Description:
//      Definitions of "smart" classes used to make sure resources such as
//      memory and handles are deallocated or closed properly.
//
//  Maintained By:
//      David Potter (DavidP)   08-SEP-1999
//      Vij Vasu     (Vvasu)    16-SEP-1999
//
//  Notes:
//      1. These classes are functionally identical to version 3 of the
//      standard library's auto_ptr class. They are redefined here since this
//      version of auto_ptr has not yet found it's way into our build
//      environment.
//
//      2. These classes are not intended to be used as a base class. They are
//      meant to be space and time efficient wrappers. Using these as base
//      classes may require the use of virtual functions which will only make
//      their memory footprint larger.
//
//
/////////////////////////////////////////////////////////////////////////////

// Make sure that this header is included only once
#pragma once


/////////////////////////////////////////////////////////////////////////////
// External Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////
#include <unknwn.h>


/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

// Store the warning state.
#pragma warning( push )

// Disable warning 4284. The text of the warning is below:
// Return type for 'identifier::operator ->' is not a UDT or reference to a UDT.
// Will produce errors if applied using infix notation
#pragma warning( disable : 4284 )


/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSmartResource
//
//  Description:
//      Automatically releases a resource.
//
//  Template Arguments:
//      t_ResourceTrait
//          A class that provides functions and types needed this class. For example,
//          this class may have a function that is used to release the resource.
//          It must define the type of the resource.
//
//  Remarks:
//      See Note 2 in the banner comment for this module.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class t_ResourceTrait >
class CSmartResource
{
private:
    //
    // Private Types
    //
    typedef t_ResourceTrait::ResourceType ResourceType;

    //
    // Private Data
    //
    ResourceType m_hResource;


public:
    //
    // Constructors & Destructors
    //

    // Default constructor
    explicit CSmartResource( ResourceType hResource = t_ResourceTrait::HGetNullValue() ) throw()
        : m_hResource( hResource )
    {
    } //*** CSmartResource( ResourceType )

    // Copy constructor
    CSmartResource( CSmartResource & rsrSourceInout ) throw()
        : m_hResource( rsrSourceInout.HRelinquishOwnership() )
    {
    } //*** CSmartResource( CSmartResource & )

    // Destructor
    ~CSmartResource() throw()
    { 
        CloseRoutineInternal();

    } //*** ~CSmartResource()


    //
    // Operators
    //

    // Assignment operator
    CSmartResource & operator=( CSmartResource & rsrRHSInout ) throw()
    {
        // Only perform the assignment if not assigning to self
        if ( &rsrRHSInout != this )
        {
            CloseRoutineInternal();
            m_hResource = rsrRHSInout.HRelinquishOwnership();
        } // if: not assigning to self

        return *this;

    } //*** operator=()

    // Operator to cast to underlying resource type
    operator ResourceType( void ) const throw()
    {
        return m_hResource;

    } //*** operator ResourceType()


    //
    // Lightweight Access Methods
    //

    // Get the handle to the resource
    ResourceType HHandle( void ) const throw()
    {
        return m_hResource;

    } //*** HResource()


    //
    // Class Methods
    //

    // Determine if the resource handle is valid
    bool FIsInvalid( void ) const throw()
    {
        return ( m_hResource == t_ResourceTrait::HGetNullValue() );

    } //*** FIsInvalid()


    // Assignment function
    CSmartResource & Assign( ResourceType hResource ) throw()
    {
        // Only perform the assignment if not assigning to self
        if ( m_hResource != hResource )
        {
            CloseRoutineInternal();
            m_hResource = hResource;
        } // if: not assigning to self

        return *this;

    } //*** Assign()

    // Free the resource.
    void Free( void ) throw()
    {
        CloseRoutineInternal();
        m_hResource = t_ResourceTrait::HGetNullValue();

    } //*** Free()

    // Relinquish ownership of the resouce without freeing it.
    ResourceType HRelinquishOwnership( void ) throw()
    {
        ResourceType hHandle = m_hResource;
        m_hResource = t_ResourceTrait::HGetNullValue();

        return hHandle;

    } //*** HRelinquishOwnership()


private:
    //
    //
    // Private operators
    //

    // The address-of operator
    CSmartResource * operator &() throw()
    {
        return this;
    }


    //
    // Private Class Methods
    //

    // Check and release the resource
    void CloseRoutineInternal( void ) throw()
    {
        if ( m_hResource != t_ResourceTrait::HGetNullValue() )
        {
            t_ResourceTrait::CloseRoutine( m_hResource );
        } // if: resource handle isn't invalid

    } //*** CloseRoutineInternal()

}; //*** class CSmartResource


/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CPtrTrait
//
//  Description:
//      Encapsulates the traits of pointers.
//
//  Template Arguments:
//      t_Ty        Type of memory to be managed (e.g. BYTE or int).
//
//  Remarks:
//      See Note 2 in the banner comment for this module.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class t_Ty >
class CPtrTrait
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public types
    //////////////////////////////////////////////////////////////////////////
    typedef t_Ty *  ResourceType;
    typedef t_Ty    DataType;


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // A routine used to release a resource.
    static void CloseRoutine( ResourceType hResourceIn )
    {
        delete hResourceIn;
    } //*** CloseRoutine()

    // Get the null value for this type.
    static ResourceType HGetNullValue()
    {
        return NULL;
    } //*** HGetNullValue()
}; //*** class CPtrTrait


/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CArrayPtrTrait
//
//  Description:
//      Encapsulates the traits of pointers.
//
//  Template Arguments:
//      t_Ty        Type of memory to be managed (e.g. BYTE or int).
//
//  Remarks:
//      See Note 2 in the banner comment for this module.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class t_Ty >
class CArrayPtrTrait
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public types
    //////////////////////////////////////////////////////////////////////////
    typedef t_Ty * ResourceType;
    typedef t_Ty   DataType;


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // A routine used to release a resource
    static void CloseRoutine( ResourceType hResourceIn )
    {
        delete [] hResourceIn;
    } //*** CloseRoutine()

    // Get the null value for this type.
    static ResourceType HGetNullValue()
    {
        return NULL;
    } //*** HGetNullValue()

}; //*** class CArrayPtrTrait


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CHandleTrait
//
//  Description:
//      The class is a handle trait class that can be used with handles whose
//      close routines take only one argument.
//
//      t_Ty
//          Type of handle to be managed (e.g. HWND).
//
//      t_CloseRoutineReturnType
//          The return type of the routine used to close the handle.
//
//      t_CloseRoutine
//          The routine used to close the handle. This function cannot throw
//          exceptions.
//
//      t_hNULL_VALUE
//          Null handle value.  Defaults to NULL.
//
//--
//////////////////////////////////////////////////////////////////////////////
template <
      class t_Ty
    , class t_CloseRoutineReturnType
    , t_CloseRoutineReturnType (*t_CloseRoutine)( t_Ty hHandleIn ) throw()
    , t_Ty t_hNULL_VALUE = NULL
    >
class CHandleTrait
{
public:
    //////////////////////////////////////////////////////////////////////////
    // Public types
    //////////////////////////////////////////////////////////////////////////
    typedef t_Ty ResourceType;


    //////////////////////////////////////////////////////////////////////////
    // Public methods
    //////////////////////////////////////////////////////////////////////////

    // A routine used to close a handle.
    static void CloseRoutine( ResourceType hResourceIn )
    {
        t_CloseRoutine( hResourceIn );
    } //*** CloseRoutine()

    // Get the null value for this type.
    static ResourceType HGetNullValue()
    {
        return t_hNULL_VALUE;
    } //*** HGetNullValue()

}; //*** class CHandleTrait


/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSmartGenericPtr
//
//  Description:
//      Automatically handles deallocation of memory.
//
//  Template Arguments:
//      t_PtrTrait
//      Trait class for the memory to be managed (e.g. CPtrTrait< int > ).
//
//  Remarks:
//      See Note 2 in the banner comment for this module.
//      It is ok for this class to derive from CSmartResource since the
//      derivation is private and the lack of virtual functions will
//      therefore not cause any problems.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class t_PtrTrait >
class CSmartGenericPtr : private CSmartResource< t_PtrTrait >
{
private:
    //
    // Private Types
    //
    typedef CSmartResource< t_PtrTrait > BaseClass;


public:
    //
    // Public Types
    //
    typedef t_PtrTrait::DataType         DataType;

    //
    // Constructors & Destructors
    //

    // Default and memory pointer constructor
    explicit CSmartGenericPtr( DataType * pMemIn = NULL ) throw()
        : BaseClass( pMemIn )
    {
    } //*** CSmartGenericPtr( DataType * )

    // Copy constructor
    CSmartGenericPtr( CSmartGenericPtr & rsrSourceInout ) throw()
        : m_pMem( rsrSourceInout.HRelinquishOwnership() )
    {
    } //*** CSmartGenericPtr( CSmartGenericPtr & )

    // Destructor
    ~CSmartGenericPtr( void ) throw()
    { 
    } //*** ~CSmartGenericPtr()


    //
    // Operators
    //

    // Assignment operator
    CSmartGenericPtr & operator=( CSmartGenericPtr & rapRHSInout ) throw()
    {
        return static_cast< CSmartGenericPtr & >( BaseClass::operator=( rapRHSInout ) );
    } //*** operator=()

    // Assign a pointer
    CSmartGenericPtr & Assign( DataType * pMemIn ) throw()
    {
        return static_cast< CSmartGenericPtr & >( BaseClass::Assign( pMemIn ) );
    } //*** Assign()

    // Pointer dereference operator*
    DataType & operator*( void ) const throw()
    {
        return *HHandle();

    } //*** operator*()

    // Pointer dereference operator->
    DataType * operator->( void ) const throw()
    {
        return HHandle();

    } //*** operator->()


    //
    // Lightweight Access Methods
    //

    // Get the memory pointer
    DataType * PMem( void ) const throw()
    {
        return HHandle();

    } //*** PMem()


    //
    // Class Methods
    //

    // Determine if memory pointer is valid
    bool FIsEmpty( void ) const throw()
    {
        return FIsInvalid();

    } //*** FIsEmpty()


    // Relinquish our ownership of the memory pointer
    DataType * PRelease( void ) throw()
    {
        return HRelinquishOwnership();
    } //*** PRelease()

}; //*** class CSmartGenericPtr


/////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSmartIfacePtr
//
//  Description:
//      Automatically calls AddRef on creation and Release on destruction.
//
//  Template Arguments:
//      t_Ty        Type of pointer to be managed (e.g. IUnknown *).
//
//  Remarks:
//      This class does not have the destructive copy semantics. That is,
//      when a CSmartIfacePtr object is copied, the source is still valid.
//
//      See Note 2 in the banner comment for this module.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class t_Ty >
class CSmartIfacePtr
{
private:
    //
    // Private Data
    //
    t_Ty * m_pUnk;


public:

    // Class to prevent explicit calls to AddRef() and Release
    class INoAddRefRelease : public t_Ty
    {
    private:
        virtual ULONG STDMETHODCALLTYPE AddRef() = 0;
        virtual ULONG STDMETHODCALLTYPE Release() = 0;
    };

    //
    // Constructors & Destructors
    //

    // Default and pointer constructor
    CSmartIfacePtr( t_Ty * pUnkIn = NULL ) throw()
        : m_pUnk( pUnkIn )
    {
        AddRefInternal();
    } //*** CSmartIfacePtr( t_Ty * )

    // Copy constructor
    CSmartIfacePtr( const CSmartIfacePtr & rsrSourceIn ) throw()
        : m_pUnk( rsrSourceIn.PUnk() )
    {
        AddRefInternal();
    } //*** CSmartIfacePtr( CSmartIfacePtr & )

    // Destructor
    ~CSmartIfacePtr( void ) throw()
    { 
        ReleaseInternal();
    } //*** ~CSmartIfacePtr()


    //
    // Operators
    //

    // Assignment operator
    INoAddRefRelease & operator=( const CSmartIfacePtr & rapRHSIn ) throw()
    {
        return Assign( rapRHSIn.PUnk() );

    } //*** operator=()

    // Pointer dereference operator*
    INoAddRefRelease & operator*( void ) const throw()
    {
        return *( static_cast< INoAddRefRelease * >( m_pUnk ) );

    } //*** operator*()

    // Pointer dereference operator->
    INoAddRefRelease * operator->( void ) const throw()
    {
        return static_cast< INoAddRefRelease * >( m_pUnk );

    } //*** operator->()


    //
    // Lightweight Access Methods
    //

    // Get the pointer
    INoAddRefRelease * PUnk( void ) const throw()
    {
        return static_cast< INoAddRefRelease * >( m_pUnk );

    } //*** PUnk()


    //
    // Class Methods
    //

    // Assignment function.
    INoAddRefRelease & Assign( t_Ty * pRHSIn ) throw()
    {
        // Only perform the assignment if not assigning to self
        if ( pRHSIn != m_pUnk ) 
        {
            ReleaseInternal();
            m_pUnk = pRHSIn;
            AddRefInternal();
        } // if: not assigning to self

        return *( static_cast< INoAddRefRelease * >( m_pUnk ) );

    } //*** Assign()

    // Attach ( assign without AddRef() )
    void Attach( t_Ty * pRHSIn ) throw()
    {
        // Only perform the attachment if not attaching to self
        if ( pRHSIn != m_pUnk ) 
        {
            ReleaseInternal();
            m_pUnk = pRHSIn;
        } // if: not attaching to self

    } //*** Attach()

    // Release this interface pointer.
    void Release() throw()
    {
        ReleaseInternal();
        m_pUnk = NULL;
    }

    // Query punkSrc for __uuidof( m_pUnk ) and store the result.
    HRESULT HrQueryAndAssign( IUnknown * punkSrc ) throw()
    {
        ReleaseInternal();
        return punkSrc->QueryInterface< t_Ty >( &m_pUnk );

    } ///*** HrQueryAndAssign()


    // Determine if pointer is valid
    bool FIsEmpty( void ) const throw()
    {
        return ( m_pUnk == NULL );

    } //*** FIsEmpty()


private:
    //
    //
    // Private operators
    //

    // The address-of operator
    CSmartIfacePtr * operator &()
    {
        return this;
    }

    //
    // Private Class Methods
    //

    // Increment the reference count on the pointer
    void AddRefInternal( void ) throw()
    {
        if ( m_pUnk != NULL )
        {
            m_pUnk->AddRef();
        }
    } //*** PRelease()

    // Release the pointer.
    // A call to this function is usually be followed by a reassignment, or else
    // this will object may contain an invalid pointer.
    void ReleaseInternal( void ) throw()
    {
        if ( m_pUnk != NULL )
        {
            m_pUnk->Release();
        }
    } //*** PRelease()

}; //*** class CSmartIfacePtr


// Restore the warning state.
#pragma warning( pop )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\swtracingsrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      SWTracingSrc.cpp
//
//  Description:
//      Software tracing functions.
//
//  Documentation:
//      Spec\Admin\Debugging.ppt
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <tchar.h>


//#define DebugDumpWMITraceFlags( _arg )  // NOP

//
// TODO: remove this when WMI is more dynamic
//
static const int cchDEBUG_OUTPUT_BUFFER_SIZE = 512;


//****************************************************************************
//
//  WMI Tracing Routines
//
//  These routines are only in the DEBUG version.
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  DebugDumpWMITraceFlags(
//      DEBUG_WMI_CONTROL_GUIDS * pdwcgIn
//      )
//
//  Description:
//      Dumps the currently set flags.
//
//  Arguments:
//      pdwcgIn     - Pointer to the DEBUG_WMI_CONTROL_GUIDS to explore.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
DebugDumpWMITraceFlags(
    DEBUG_WMI_CONTROL_GUIDS * pdwcgIn
    )
{
    DWORD      dwFlag;
    signed int nCount;

    if ( pdwcgIn->pMapFlagsToComments == NULL )
    {
        DebugMsg( TEXT("DEBUG:        no flag mappings available.") );
        return; // NOP
    } // if: no mapping table

    dwFlag = 0x80000000;
    for ( nCount = 31; nCount >= 0; nCount-- )
    {
        if ( pdwcgIn->dwFlags & dwFlag )
        {
            DebugMsg( TEXT("DEBUG:       0x%08x = %s"),
                      dwFlag,
                      ( pdwcgIn->pMapFlagsToComments[ nCount ].pszName != NULL ? pdwcgIn->pMapFlagsToComments[ nCount ].pszName : g_szUnknown )
                      );

        } // if: flag set

        dwFlag = dwFlag >> 1;

    } // for: nCount

} //*** DebugDumpWMITraceFlags( )

//****************************************************************************
//
//  WMI Tracing Routines
//
//  These routines are in both DEBUG and RETAIL versions.
//
//****************************************************************************


//////////////////////////////////////////////////////////////////////////////
//++
//
//  ULONG
//  UlWMIControlCallback(
//      IN WMIDPREQUESTCODE RequestCode,
//      IN PVOID            RequestContext,
//      IN OUT ULONG *      BufferSize,
//      IN OUT PVOID        Buffer
//      )
//
//  Description:
//      WMI's tracing control callback entry point.
//
//  Arguments:
//      See EVNTRACE.H
//
//  Return Values:
//      ERROR_SUCCESS           - success.
//      ERROR_INVALID_PARAMETER - invalid RequestCode passed in.
//
//--
//////////////////////////////////////////////////////////////////////////////
ULONG
WINAPI
UlWMIControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID            RequestContext,
    IN OUT ULONG *      BufferSize,
    IN OUT PVOID        Buffer
    )
{
    ULONG ulResult = ERROR_SUCCESS;
    DEBUG_WMI_CONTROL_GUIDS * pdwcg = (DEBUG_WMI_CONTROL_GUIDS *) RequestContext;

    switch ( RequestCode )
    {
    case WMI_ENABLE_EVENTS:
        {
            TRACEHANDLE hTrace;

            if ( pdwcg->hTrace == NULL )
            {
                hTrace = GetTraceLoggerHandle( Buffer );

            } // if:
            else
            {
                hTrace = pdwcg->hTrace;

            } // else:

            pdwcg->dwFlags = GetTraceEnableFlags( hTrace );
            pdwcg->bLevel  = GetTraceEnableLevel( hTrace );
            if ( pdwcg->dwFlags == 0 )
            {
                if ( pdwcg->pMapLevelToFlags != NULL
                  && pdwcg->bSizeOfLevelList != 0
                   )
                {
                    if ( pdwcg->bLevel >= pdwcg->bSizeOfLevelList )
                    {
                        pdwcg->bLevel = pdwcg->bSizeOfLevelList - 1;
                    }

                    pdwcg->dwFlags = pdwcg->pMapLevelToFlags[ pdwcg->bLevel ].dwFlags;
                    DebugMsg( TEXT("DEBUG: WMI tracing level set to %u - %s, flags = 0x%08x"),
                              pdwcg->pszName,
                              pdwcg->bLevel,
                              pdwcg->pMapLevelToFlags[ pdwcg->bLevel ].pszName,
                              pdwcg->dwFlags
                              );

                } // if: level->flag mapping available
                else
                {
                    DebugMsg( TEXT("DEBUG: WMI tracing level set to %u, flags = 0x%08x"),
                              pdwcg->pszName,
                              pdwcg->bLevel,
                              pdwcg->dwFlags
                              );

                } // else: no mappings

            } // if: no flags set
            else
            {
                DebugMsg( TEXT("DEBUG: WMI tracing level set to %u, flags = 0x%08x"),
                          pdwcg->pszName,
                          pdwcg->bLevel,
                          pdwcg->dwFlags
                          );

            } // else: flags set

            DebugDumpWMITraceFlags( pdwcg );

            pdwcg->hTrace  = hTrace;

        } // WMI_ENABLE_EVENTS
        break;

    case WMI_DISABLE_EVENTS:
        pdwcg->dwFlags = 0;
        pdwcg->bLevel  = 0;
        pdwcg->hTrace  = NULL;
        DebugMsg( TEXT("DEBUG: %s WMI tracing disabled."), pdwcg->pszName );
        break;

    default:
        ulResult = ERROR_INVALID_PARAMETER;
        break;

    } // switch: RequestCode

    return ulResult;

} //*** UlWMIControlCallback( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  WMIInitializeTracing(
//      DEBUG_WMI_CONTROL_GUIDS dwcgControlListIn[],
//      int                     nCountOfCOntrolGuidsIn
//      )
//
//  Description:
//      Initialize the WMI tracing.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
WMIInitializeTracing(
    DEBUG_WMI_CONTROL_GUIDS dwcgControlListIn[],
    int                     nCountOfControlGuidsIn
    )
{
    TCHAR szPath[ MAX_PATH ];
    ULONG ulStatus;
    int   nCount;


#if defined( DEBUG )
    static BOOL fRegistered = FALSE;
    AssertMsg( fRegistered == FALSE, "Re-entrance into InitializeWMITracing!!!" );
#endif // DEBUG

    GetModuleFileName( g_hInstance, szPath, MAX_PATH );

    for( nCount = 0; nCount < nCountOfControlGuidsIn; nCount++ )
    {
        TRACE_GUID_REGISTRATION * pList;
        pList = (TRACE_GUID_REGISTRATION *)
            HeapAlloc( GetProcessHeap(), 0,
                        sizeof( TRACE_GUID_REGISTRATION ) * dwcgControlListIn[ nCount ].dwSizeOfTraceList );

        if ( pList != NULL )
        {
            CopyMemory( pList,
                        dwcgControlListIn[ nCount ].pTraceList,
                        sizeof( TRACE_GUID_REGISTRATION ) * dwcgControlListIn[ nCount ].dwSizeOfTraceList );

            ulStatus = RegisterTraceGuids( UlWMIControlCallback,                            // IN  RequestAddress
                                           dwcgControlListIn,                               // IN  RequestContext
                                           dwcgControlListIn[ nCount ].guidControl,         // IN  ControlGuid
                                           dwcgControlListIn[ nCount ].dwSizeOfTraceList,   // IN  GuidCount
                                           pList,                                           // IN  GuidReg
                                           (LPCTSTR) szPath,                                // IN  MofImagePath
                                           __MODULE__,                                      // IN  MofResourceName
                                           &dwcgControlListIn[ nCount ].hRegistration       // OUT RegistrationHandle
                                           );

            AssertMsg( ulStatus == ERROR_SUCCESS, "Trace registration failed" );

            HeapFree( GetProcessHeap(), 0, pList );
        } // if: list allocated successfully
    } // for: each control GUID

#if defined( DEBUG )
    fRegistered = TRUE;
#endif // DEBUG

} //*** WMIInitializeTracing( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  WMITerminateTracing(
//      DEBUG_WMI_CONTROL_GUIDS dwcgControlListIn[],
//      int                     nCountOfCOntrolGuidsIn
//      )
//
//  Description:
//      Terminates WMI tracing and unregisters the interfaces.
//
//  Arguments:
//      dwcgControlListIn       -
//      nCountOfControlGuidsIn  -
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
WMITerminateTracing(
    DEBUG_WMI_CONTROL_GUIDS dwcgControlListIn[],
    int                     nCountOfControlGuidsIn
    )
{
    int nCount;

    for( nCount = 0; nCount < nCountOfControlGuidsIn; nCount++ )
    {
        dwcgControlListIn[ nCount ].dwFlags = 0;
        dwcgControlListIn[ nCount ].bLevel  = 0;
        dwcgControlListIn[ nCount ].hTrace  = NULL;
        UnregisterTraceGuids( dwcgControlListIn[ nCount ].hRegistration );
    } // for: each control GUID

} //*** WMITerminateTracing( )


typedef struct
{
    EVENT_TRACE_HEADER    EHeader;                              // storage for the WMI trace event header
    BYTE                  bSize;                                // Size of the string - MAX 255!
    WCHAR                 szMsg[ cchDEBUG_OUTPUT_BUFFER_SIZE ]; // Message
} DEBUG_WMI_EVENT_W;

typedef struct
{
    EVENT_TRACE_HEADER    EHeader;                              // storage for the WMI trace event header
    BYTE                  bSize;                                // Size of the string - MAX 255!
    CHAR                  szMsg[ cchDEBUG_OUTPUT_BUFFER_SIZE ]; // Message
} DEBUG_WMI_EVENT_A;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  WMIMessageByFlags(
//      DEBUG_WMI_CONTROL_GUIDS *   pEntryIn,
//      const DWORD                 dwFlagsIn,
//      LPCWSTR                     pszFormatIn,
//      ...
//      )
//
//  Description:
//
//  Arguments:
//      pEntry      -
//      dwFlagsIn   -
//      pszFormatIn -
//      ...         -
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
WMIMessageByFlags(
    DEBUG_WMI_CONTROL_GUIDS *   pEntry,
    const DWORD                 dwFlagsIn,
    LPCWSTR                     pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( pEntry->hTrace == NULL )
    {
        return; // NOP
    } // if: no trace logger

    if ( dwFlagsIn == mtfALWAYS
      || pEntry->dwFlags & dwFlagsIn
       )
    {
        ULONG ulStatus;
        DEBUG_WMI_EVENT_W DebugEvent;
        PEVENT_TRACE_HEADER peth = (PEVENT_TRACE_HEADER ) &DebugEvent;
        PWNODE_HEADER pwnh = (PWNODE_HEADER) &DebugEvent;

        ZeroMemory( &DebugEvent, sizeof( DebugEvent ) );

#ifndef UNICODE
        TCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

        va_start( valist, pszFormatIn );
        _vsntprintf( DebugEvent.szMsg, 256, szFormat, valist );
        va_end( valist );
#else
        va_start( valist, pszFormatIn );
        _vsntprintf( DebugEvent.szMsg, 256, pszFormatIn, valist );
        va_end( valist );
#endif // UNICODE

        //
        // Fill in the blanks
        //
        Assert( wcslen( DebugEvent.szMsg ) <= 255 );    // make sure the cast doesn't fail.
        DebugEvent.bSize    = (BYTE) wcslen( DebugEvent.szMsg );
        peth->Size          = sizeof( DebugEvent );
        peth->Class.Type    = 10;
        peth->Class.Level   = pEntry->bLevel;
        // peth->Class.Version = 0;
        // peth->ThreadId      = GetCurrentThreadId( ); - done by system
        pwnh->Guid          = *pEntry->guidControl;
        // peth->ClientContext = NULL;
        pwnh->Flags         = WNODE_FLAG_TRACED_GUID;

        // GetSystemTimeAsFileTime( (FILETIME *) &peth->TimeStamp ); - done by the system

        ulStatus = TraceEvent( pEntry->hTrace, (PEVENT_TRACE_HEADER) &DebugEvent );

    } // if: flags set

} //*** WMIMsg( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  WMIMessageByFlagsAndLevel(
//      DEBUG_WMI_CONTROL_GUIDS *   pEntry,
//      const DWORD                 dwFlagsIn,
//      const BYTE                  bLogLevelIn,
//      LPCWSTR                     pszFormatIn,
//      ...
//      )
//
//  Description:
//
//  Arguments:
//      pEntry      -
//      dwFlagsIn   -
//      bLogLevelIn -
//      pszFormatIn -
//      ...         -
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
WMIMessageByFlagsAndLevel(
    DEBUG_WMI_CONTROL_GUIDS *   pEntry,
    const DWORD                 dwFlagsIn,
    const BYTE                  bLogLevelIn,
    LPCWSTR                     pszFormatIn,
    ...
    )
{
    va_list valist;

    if ( pEntry->hTrace == NULL )
    {
        return; // NOP
    } // if: no trace logger

    if ( bLogLevelIn > pEntry->bLevel )
    {
        return; // NOP
    } // if: level not high enough

    if ( dwFlagsIn == mtfALWAYS
      || pEntry->dwFlags & dwFlagsIn
       )
    {
        ULONG               ulStatus;
        DEBUG_WMI_EVENT_W   DebugEvent;
        PEVENT_TRACE_HEADER peth = (PEVENT_TRACE_HEADER ) &DebugEvent;
        PWNODE_HEADER       pwnh = (PWNODE_HEADER) &DebugEvent;

        ZeroMemory( &DebugEvent, sizeof( DebugEvent ) );

#ifndef UNICODE
        TCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
        wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

        va_start( valist, pszFormatIn );
        _vsntprintf( DebugEvent.szMsg, 256,szFormat, valist);
        va_end( valist );
#else
        va_start( valist, pszFormatIn );
        _vsntprintf( DebugEvent.szMsg, 256,pszFormatIn, valist);
        va_end( valist );
#endif // UNICODE

        //
        // Fill in the blanks
        //
        Assert( wcslen( DebugEvent.szMsg ) <= 255 );    // make sure the cast doesn't fail.
        DebugEvent.bSize    = (BYTE) wcslen( DebugEvent.szMsg );
        peth->Size          = sizeof( DebugEvent );
        peth->Class.Type    = 10;
        peth->Class.Level   = pEntry->bLevel;
        // peth->Class.Version = 0;
        // peth->ThreadId      = GetCurrentThreadId( ); - done by system
        pwnh->Guid          = *pEntry->guidControl;
        // peth->ClientContext = NULL;
        pwnh->Flags         = WNODE_FLAG_TRACED_GUID;

        // GetSystemTimeAsFileTime( (FILETIME *) &peth->TimeStamp ); - done by the system

        ulStatus = TraceEvent( pEntry->hTrace, (PEVENT_TRACE_HEADER) &DebugEvent );

    } // if: flags set

} //*** WMIMessageByFlagsAndLevel( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  void
//  WMIMessageByLevel(
//      DEBUG_WMI_CONTROL_GUIDS *   pEntry,
//      const BYTE                  bLogLevelIn,
//      LPCWSTR                     pszFormatIn,
//      ...
//      )
//
//  Description:
//
//  Arguments:
//      pEntry      -
//      bLogLevelIn -
//      pszFormatIn -
//      ...         -
//
//  Return Values:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
void
__cdecl
WMIMessageByLevel(
    DEBUG_WMI_CONTROL_GUIDS * pEntry,
    const BYTE bLogLevelIn,
    LPCWSTR pszFormatIn,
    ...
    )
{
    ULONG ulStatus;
    DEBUG_WMI_EVENT_W DebugEvent;
    PEVENT_TRACE_HEADER peth = (PEVENT_TRACE_HEADER ) &DebugEvent;
    PWNODE_HEADER pwnh = (PWNODE_HEADER) &DebugEvent;
    va_list valist;

    if ( pEntry->hTrace == NULL )
    {
        return; // NOP
    } // if: no trace logger

    if ( bLogLevelIn > pEntry->bLevel )
    {
        return; // NOP
    } // if: level no high enough

    ZeroMemory( &DebugEvent, sizeof( DebugEvent ) );

#ifndef UNICODE
    TCHAR  szFormat[ cchDEBUG_OUTPUT_BUFFER_SIZE ];
    wcstombs( szFormat, pszFormatIn, StrLenW( pszFormatIn ) + 1 );

    va_start( valist, pszFormatIn );
    _vsntprintf( DebugEvent.szMsg, 256,szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormatIn );
    _vsntprintf( DebugEvent.szMsg, 256,pszFormatIn, valist);
    va_end( valist );
#endif // UNICODE

    //
    // Fill in the blanks
    //
    Assert( wcslen( DebugEvent.szMsg ) <= 255 );    // make sure the cast doesn't fail.
    DebugEvent.bSize    = (BYTE) wcslen( DebugEvent.szMsg );
    peth->Size          = sizeof( DebugEvent );
    peth->Class.Type    = 10;
    peth->Class.Level   = pEntry->bLevel;
    // peth->Class.Version = 0;
    // peth->ThreadId      = GetCurrentThreadId( ); - done by system
    pwnh->Guid          = *pEntry->guidControl;
    // peth->ClientContext = NULL;
    pwnh->Flags         = WNODE_FLAG_TRACED_GUID;

    // GetSystemTimeAsFileTime( (FILETIME *) &peth->TimeStamp ); - done by the system

    ulStatus = TraceEvent( pEntry->hTrace, (PEVENT_TRACE_HEADER) &DebugEvent );

} //*** WMIMessageByLevel( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\swtracing.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000-2001 Microsoft Corporation
//
//  Module Name:
//      SWTracing.h
//
//  Description:
//      Software tracing header.
//
//  Maintained By:
//      Galen Barbee (GalenB) 05-DEC-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//
// KB: DEBUG_SUPPORT_NT4 DavidP 05-OCT-2000
//      Turn this on to support only functionality available in NT4.
//      This will turn off WMI support.
//
// #define DEBUG_SUPPORT_NT4
#if defined( DEBUG_SUPPORT_NT4 )
#if defined( DEBUG_SW_TRACING_ENABLED )
#undef DEBUG_SW_TRACING_ENABLED
#endif
#else
#define DEBUG_SW_TRACING_ENABLED
#endif

#if defined( DEBUG_SW_TRACING_ENABLED )
//
// WMI tracing needs these defined
//
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <wmistr.h>
#pragma warning( pop )

#pragma warning( push )
#pragma warning( disable : 4201 )
#pragma warning( disable : 4096 )
#include <evntrace.h>
#pragma warning( pop )

#endif // DEBUG_SW_TRACING_ENABLED

#if defined( DEBUG_SW_TRACING_ENABLED )
//
// Enable WMI
//
#define TraceInitializeProcess( _rg, _sizeof ) \
    WMIInitializeTracing( _rg, _sizeof );
#define TraceTerminateProcess( _rg, _sizeof ) \
    WMITerminateTracing( _rg, _sizeof );

#else // DEBUG_SW_TRACING_ENABLED

#define TraceInitializeProcess( )   1 ? (void)0 : (void)__noop
#define TraceTerminateProcess( )    1 ? (void)0 : (void)__noop

#endif // DEBUG_SW_TRACING_ENABLED

#if defined( DEBUG_SW_TRACING_ENABLED )
//****************************************************************************
//
// WMI Tracing stuctures and prototypes
//
//****************************************************************************

typedef struct
{
    DWORD       dwFlags;        // Flags to be set
    LPCTSTR     pszName;        // Usefull description of the level
} DEBUG_MAP_LEVEL_TO_FLAGS;

typedef struct
{
    LPCTSTR     pszName;        // Usefull description of the flag
} DEBUG_MAP_FLAGS_TO_COMMENTS;

typedef struct
{
    LPCGUID                             guidControl;            // Control guid to register
    LPCTSTR                             pszName;                // Internal associative name
    DWORD                               dwSizeOfTraceList;      // Count of the guids in pTraceList
    const TRACE_GUID_REGISTRATION *     pTraceList;             // List of the of Tracing guids to register
    BYTE                                bSizeOfLevelList;       // Count of the level<->flags
    const DEBUG_MAP_LEVEL_TO_FLAGS *    pMapLevelToFlags;       // List of level->flags mapping. NULL if no mapping.
    const DEBUG_MAP_FLAGS_TO_COMMENTS * pMapFlagsToComments;    // List of descriptions describing the flag bits. NULL if no mapping.

    // Controlled by WMI tracing - these should be NULL/ZERO to start.
    DWORD                               dwFlags;                // Log flags
    BYTE                                bLevel;                 // Log level
    TRACEHANDLE                         hTrace;                 // Active logger handle

    // From here down is initialized by InitializeWMITracing
    TRACEHANDLE                         hRegistration;          // Return control handle
} DEBUG_WMI_CONTROL_GUIDS;

void
WMIInitializeTracing(
    DEBUG_WMI_CONTROL_GUIDS dwcgControlListIn[],
    int                     nCountOfControlGuidsIn
    );

void
WMITerminateTracing(
    DEBUG_WMI_CONTROL_GUIDS dwcgControlListIn[],
    int                     nCountOfControlGuidsIn
    );

void
__cdecl
WMIMessageByFlags(
    DEBUG_WMI_CONTROL_GUIDS *   pEntryIn,
    const DWORD                 dwFlagsIn,
    LPCWSTR                     pszFormatIn,
    ...
    );

void
__cdecl
WMIMessageByLevel(
    DEBUG_WMI_CONTROL_GUIDS *   pEntryIn,
    const BYTE                  bLogLevelIn,
    LPCWSTR                     pszFormatIn,
    ...
    );

void
__cdecl
WMIMessageByFlagsAndLevel(
    DEBUG_WMI_CONTROL_GUIDS *   pEntryIn,
    const DWORD                 dwFlagsIn,
    const BYTE                  bLogLevelIn,
    LPCWSTR                     pszFormatIn,
    ...
    );

//
// Sample WMI message macros
//
// Typically you will want a particular level to map to a set of flags. This
// way as you increase the level, you activate more and more messages.
//
// To be versatile, there there types of filtering. Choose the one that suits
// the situation that you supports your logging needs. Remember that depending
// on the use, you might need to specify additional parameters.
//
// These macros on x86 turn into 2 ops ( cmp and jnz ) in the regular code path
// thereby lessening the impact of keeping the macros enabled in RETAIL. Since
// other platforms were not available while developing these macros, you should
// wrap the definitions in protecting against other architectures.
//
// #if defined( _X86_ )
// #define WMIMsg ( g_pTraceGuidControl[0].dwFlags == 0 ) ? (void)0 : WMIMessageByFlags
// #define WMIMsg ( g_pTraceGuidControl[0].dwFlags == 0 ) ? (void)0 : WMIMessageByLevel
// #define WMIMsg ( g_pTraceGuidControl[0].dwFlags == 0 ) ? (void)0 : WMIMessageByFlagsAndLevel
// #else // not X86
// #define WMIMsg 1 ? (void)0 : (void)
// #endif // defined( _X86_ )
//
//

#endif // DEBUG_SW_TRACING_ENABLED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetres\clnetres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999-2000 Microsoft Corporation
//
//	Module Name:
//		ClNetRes.h
//
//	Implementation File:
//		ClNetRes.cpp
//
//	Description:
//		Resource DLL for DHCP and WINS Services (ClNetRes).
//
//	Maintained By:
//		David Potter (DavidP) March 18, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLNETRES_H__
#define __CLNETRES_H__
#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#pragma comment( lib, "clusapi.lib" )
#pragma comment( lib, "resutils.lib" )
#pragma comment( lib, "advapi32.lib" )

#define UNICODE 1
#define _UNICODE 1

#pragma warning( disable : 4115 )	// named type definition in parentheses
#pragma warning( disable : 4201 )	// nonstandard extension used : nameless struct/union
#pragma warning( disable : 4214 )	// nonstandard extension used : bit field types other than int

#include <windows.h>

#pragma warning( default : 4214 )	// nonstandard extension used : bit field types other than int
#pragma warning( default : 4201 )	// nonstandard extension used : nameless struct/union
#pragma warning( default : 4115 )	// named type definition in parentheses

#pragma warning( error : 4706 )		// assignment within conditional expression

#include <clusapi.h>
#include <resapi.h>
#include <stdio.h>
#include <wchar.h>
#include <wincrypt.h>
#include <stdlib.h>

#pragma warning( disable : 4100 )	// unreferenced formal parameter
#pragma warning( disable : 4127 )	// conditional expression is constant

/////////////////////////////////////////////////////////////////////////////
// DHCP Definitions
/////////////////////////////////////////////////////////////////////////////

#define DHCP_RESNAME  L"DHCP Service"
#define DHCP_SVCNAME  TEXT("DHCPServer")

BOOLEAN WINAPI DhcpDllMain(
	IN	HINSTANCE	hDllHandle,
	IN	DWORD		nReason,
	IN	LPVOID		Reserved
	);

DWORD WINAPI DhcpStartup(
	IN	LPCWSTR							pszResourceType,
	IN	DWORD							nMinVersionSupported,
	IN	DWORD							nMaxVersionSupported,
	IN	PSET_RESOURCE_STATUS_ROUTINE	pfnSetResourceStatus,
	IN	PLOG_EVENT_ROUTINE				pfnLogEvent,
	OUT PCLRES_FUNCTION_TABLE *			pFunctionTable
	);

/////////////////////////////////////////////////////////////////////////////
// WINS Definitions
/////////////////////////////////////////////////////////////////////////////

#define WINS_RESNAME  L"WINS Service"
#define WINS_SVCNAME  TEXT("WINS")

BOOLEAN WINAPI WinsDllMain(
	IN	HINSTANCE	hDllHandle,
	IN	DWORD		nReason,
	IN	LPVOID		Reserved
	);

DWORD WINAPI WinsStartup(
	IN	LPCWSTR							pszResourceType,
	IN	DWORD							nMinVersionSupported,
	IN	DWORD							nMaxVersionSupported,
	IN	PSET_RESOURCE_STATUS_ROUTINE	pfnSetResourceStatus,
	IN	PLOG_EVENT_ROUTINE				pfnLogEvent,
	OUT PCLRES_FUNCTION_TABLE *			pFunctionTable
	);

/////////////////////////////////////////////////////////////////////////////
// General Definitions
/////////////////////////////////////////////////////////////////////////////

#define RESOURCE_TYPE_IP_ADDRESS	L"IP Address"
#define RESOURCE_TYPE_NETWORK_NAME	L"Network Name"

#define DBG_PRINT printf

/////////////////////////////////////////////////////////////////////////////
// Global Variables and Prototypes
/////////////////////////////////////////////////////////////////////////////

// Event Logging routine.

extern PLOG_EVENT_ROUTINE g_pfnLogEvent;

// Resource Status routine for pending Online and Offline calls.

extern PSET_RESOURCE_STATUS_ROUTINE g_pfnSetResourceStatus;

// Handle to Service Control Manager set by the first Open resource call.

extern SC_HANDLE g_schSCMHandle;


VOID
ClNetResLogSystemEvent1(
    IN DWORD LogLevel,
    IN DWORD MessageId,
    IN DWORD ErrorCode,
    IN LPCWSTR Component
    );

DWORD ConfigureRegistryCheckpoints(
	IN		HRESOURCE		hResource,
	IN		RESOURCE_HANDLE	hResourceHandle,
	IN		LPCWSTR *		ppszKeys
	);

DWORD ConfigureCryptoKeyCheckpoints(
	IN		HRESOURCE		hResource,
	IN		RESOURCE_HANDLE	hResourceHandle,
	IN		LPCWSTR *		ppszKeys
	);

DWORD ConfigureDomesticCryptoKeyCheckpoints(
	IN		HRESOURCE		hResource,
	IN		RESOURCE_HANDLE	hResourceHandle,
	IN		LPCWSTR *		ppszKeys
	);

/////////////////////////////////////////////////////////////////////////////

#endif // __CLNETRES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetres\clnetres.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      ClNetRes.cpp
//
//  Description:
//      Resource DLL for DHCP and WINS Services (ClNetRes).
//
//  Maintained By:
//      David Potter (DavidP) March 17, 1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "clusres.h"
#include "ClNetRes.h"
#include "clusrtl.h"

//
// Global data.
//

// Event Logging routine.

PLOG_EVENT_ROUTINE g_pfnLogEvent = NULL;

// Resource Status routine for pending Online and Offline calls.

PSET_RESOURCE_STATUS_ROUTINE g_pfnSetResourceStatus = NULL;

// Handle to Service Control Manager set by the first Open resource call.

SC_HANDLE g_schSCMHandle = NULL;


//
// Function prototypes.
//

BOOLEAN WINAPI DllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    );

DWORD WINAPI Startup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    );

DWORD ConfigureRegistryCheckpoints(
    IN      HRESOURCE       hResource,
    IN      RESOURCE_HANDLE hResourceHandle,
    IN      LPCWSTR *       ppszKeys
    );

DWORD ConfigureCryptoKeyCheckpoints(
    IN      HRESOURCE       hResource,
    IN      RESOURCE_HANDLE hResourceHandle,
    IN      LPCWSTR *       ppszKeys
    );

DWORD ConfigureDomesticCryptoKeyCheckpoints(
    IN      HRESOURCE       hResource,
    IN      RESOURCE_HANDLE hResourceHandle,
    IN      LPCWSTR *       ppszKeys
    );


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllMain
//
//  Description:
//      Main DLL entry point.
//
//  Arguments:
//      DllHandle   [IN] DLL instance handle.
//      Reason      [IN] Reason for being called.
//      Reserved    [IN] Reserved argument.
//
//  Return Value:
//      TRUE        Success.
//      FALSE       Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOLEAN WINAPI DllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    )
{
    BOOLEAN bSuccess = TRUE;

    //
    // Perform global initialization.
    //
    switch ( nReason )
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( hDllHandle );
            break;

        case DLL_PROCESS_DETACH:
            break;

    } // switch: nReason

    //
    // Pass this request off to the resource type-specific routines.
    //
    if ( ! DhcpDllMain( hDllHandle, nReason, Reserved ) )
    {
        bSuccess = FALSE;
    } // if: error calling DHCP Service routine
    else if ( ! WinsDllMain( hDllHandle, nReason, Reserved ) )
    {
        bSuccess = FALSE;
    } // else if: error calling WINS Service routine

    if ( bSuccess ) {
        if ( nReason == DLL_PROCESS_ATTACH ) {
            ClRtlInitialize( TRUE, NULL );
        } else if ( nReason == DLL_PROCESS_DETACH ) {
            ClRtlCleanup();
        }
    }

    return bSuccess;

} //*** DllMain()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  Startup
//
//  Description:
//      Startup the resource DLL. This routine verifies that at least one
//      currently supported version of the resource DLL is between
//      nMinVersionSupported and nMaxVersionSupported. If not, then the
//      resource DLL should return ERROR_REVISION_MISMATCH.
//
//      If more than one version of the resource DLL interface is supported
//      by the resource DLL, then the highest version (up to
//      nMaxVersionSupported) should be returned as the resource DLL's
//      interface. If the returned version is not within range, then startup
//      fails.
//
//      The Resource Type is passed in so that if the resource DLL supports
//      more than one Resource Type, it can pass back the correct function
//      table associated with the Resource Type.
//
//  Arguments:
//      pszResourceType [IN]
//          Type of resource requesting a function table.
//
//      nMinVersionSupported [IN]
//          Minimum resource DLL interface version supported by the cluster
//          software.
//
//      nMaxVersionSupported [IN]
//          Maximum resource DLL interface version supported by the cluster
//          software.
//
//      pfnSetResourceStatus [IN]
//          Pointer to a routine that the resource DLL should call to update
//          the state of a resource after the Online or Offline routine
//          have returned a status of ERROR_IO_PENDING.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      pFunctionTable [IN]
//          Returns a pointer to the function table defined for the version
//          of the resource DLL interface returned by the resource DLL.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful.
//
//      ERROR_CLUSTER_RESNAME_NOT_FOUND
//          The resource type name is unknown by this DLL.
//
//      ERROR_REVISION_MISMATCH
//          The version of the cluster service doesn't match the version of
//          the DLL.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI Startup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    )
{
    DWORD nStatus;

    //
    // Save callbackup function pointers if they haven't been saved yet.
    //
    if ( g_pfnLogEvent == NULL )
    {
        g_pfnLogEvent = pfnLogEvent;
        g_pfnSetResourceStatus = pfnSetResourceStatus;
    } // if: function pointers specified

    //
    // Call the resource type-specific Startup routine.
    //
    if ( lstrcmpiW( pszResourceType, DHCP_RESNAME ) == 0 )
    {
        nStatus = DhcpStartup(
                        pszResourceType,
                        nMinVersionSupported,
                        nMaxVersionSupported,
                        pfnSetResourceStatus,
                        pfnLogEvent,
                        pFunctionTable
                        );
    } // if: DHCP Service resource type
    else if ( lstrcmpiW( pszResourceType, WINS_RESNAME ) == 0 )
    {
        nStatus = WinsStartup(
                        pszResourceType,
                        nMinVersionSupported,
                        nMaxVersionSupported,
                        pfnSetResourceStatus,
                        pfnLogEvent,
                        pFunctionTable
                        );
    } // if: WINS Service resource type
    else
    {
        nStatus = ERROR_CLUSTER_RESNAME_NOT_FOUND;
    } // if: resource type name not supported

    return nStatus;

} //*** Startup()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ConfigureRegistryCheckpoints
//
//  Description:
//      Configure registry key checkpoints.
//
//  Arguments:
//      hResource [IN]
//          Handle for resource to add checkpoints to.
//
//      hResourceHandle [IN]
//          Handle for logging.
//
//      pszKeys [IN]
//          Array of string pointers to keys to checkpoint.  Last entry
//          must be a NULL pointer.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ConfigureRegistryCheckpoints(
    IN      HRESOURCE       hResource,
    IN      RESOURCE_HANDLE hResourceHandle,
    IN      LPCWSTR *       ppszKeys
    )
{
    DWORD       nStatus = ERROR_SUCCESS;
    DWORD       cbReturn = 0;
    LPCWSTR *   ppszCurrent;

    //
    // Set registry key checkpoints if we need them.
    //
    for ( ppszCurrent = ppszKeys ; *ppszCurrent != L'\0' ; ppszCurrent++ )
    {
        nStatus = ClusterResourceControl(
                        hResource,
                        NULL,
                        CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT,
                        reinterpret_cast< PVOID >( const_cast< LPWSTR >( *ppszCurrent ) ),
                        (lstrlenW( *ppszCurrent ) + 1) * sizeof( WCHAR ),
                        NULL,
                        0,
                        &cbReturn
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            if ( nStatus == ERROR_ALREADY_EXISTS )
            {
                nStatus = ERROR_SUCCESS;
            } // if: checkpoint already exists
            else
            {
                (g_pfnLogEvent)(
                    hResourceHandle,
                    LOG_ERROR,
                    L"ConfigureRegistryCheckpoints: Failed to set registry checkpoint '%1'. Error: %2!u!.\n",
                    *ppszCurrent,
                    nStatus
                    );
                break;
            } // else: other error occurred
        } // if: error adding the checkpoint
    } // for: each checkpoint

    return nStatus;

} //*** ConfigureRegistryCheckpoints()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ConfigureCryptoKeyCheckpoints
//
//  Description:
//      Configure crypto key checkpoints.
//
//  Arguments:
//      hResource [IN]
//          Handle for resource to add checkpoints to.
//
//      hResourceHandle [IN]
//          Handle for logging.
//
//      pszKeys [IN]
//          Array of string pointers to keys to checkpoint.  Last entry
//          must be a NULL pointer.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ConfigureCryptoKeyCheckpoints(
    IN      HRESOURCE       hResource,
    IN      RESOURCE_HANDLE hResourceHandle,
    IN      LPCWSTR *       ppszKeys
    )
{
    DWORD       nStatus = ERROR_SUCCESS;
    DWORD       cbReturn = 0;
    LPCWSTR *   ppszCurrent;

    //
    // Set crypto key checkpoints if we need them.
    //
    for ( ppszCurrent = ppszKeys ; *ppszCurrent != L'\0' ; ppszCurrent++ )
    {
        nStatus = ClusterResourceControl(
                        hResource,
                        NULL,
                        CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
                        reinterpret_cast< PVOID >( const_cast< LPWSTR >( *ppszCurrent ) ),
                        (lstrlenW( *ppszCurrent ) + 1) * sizeof( WCHAR ),
                        NULL,
                        0,
                        &cbReturn
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            if ( nStatus == ERROR_ALREADY_EXISTS )
            {
                nStatus = ERROR_SUCCESS;
            } // if: checkpoint already exists
            else
            {
                (g_pfnLogEvent)(
                    hResourceHandle,
                    LOG_ERROR,
                    L"ConfigureCryptoKeyCheckpoints: Failed to set crypto key checkpoint '%1'. Error: %2!u!.\n",
                    *ppszCurrent,
                    nStatus
                    );
                break;
            } // else: other error occurred
        } // if: error adding the checkpoint
    } // for: each checkpoint

    return nStatus;

} //*** ConfigureCryptoKeyCheckpoints()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ConfigureDomesticCryptoKeyCheckpoints
//
//  Description:
//      Configure domestic (128-bit) crypto key checkpoints.
//
//  Arguments:
//      hResource [IN]
//          Handle for resource to add checkpoints to.
//
//      hResourceHandle [IN]
//          Handle for logging.
//
//      pszKeys [IN]
//          Array of string pointers to keys to checkpoint.  Last entry
//          must be a NULL pointer.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ConfigureDomesticCryptoKeyCheckpoints(
    IN      HRESOURCE       hResource,
    IN      RESOURCE_HANDLE hResourceHandle,
    IN      LPCWSTR *       ppszKeys
    )
{
    DWORD       nStatus = ERROR_SUCCESS;
    DWORD       cbReturn = 0;
    LPCWSTR *   ppszCurrent;
    HCRYPTPROV  hProv = NULL;

    //
    // Set crypto key checkpoints if we need them.
    //
    if ( *ppszKeys != NULL )
    {
        if ( CryptAcquireContextA(
                    &hProv,
                    NULL,
                    MS_ENHANCED_PROV_A,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                    ) )
        {
            CryptReleaseContext( hProv, 0 );
            for ( ppszCurrent = ppszKeys ; *ppszCurrent != L'\0' ; ppszCurrent++ )
            {
                nStatus = ClusterResourceControl(
                                hResource,
                                NULL,
                                CLUSCTL_RESOURCE_ADD_CRYPTO_CHECKPOINT,
                                reinterpret_cast< PVOID >( const_cast< LPWSTR >( *ppszCurrent ) ),
                                (lstrlenW( *ppszCurrent ) + 1) * sizeof( WCHAR ),
                                NULL,
                                0,
                                &cbReturn
                                );
                if ( nStatus != ERROR_SUCCESS )
                {
                    if ( nStatus == ERROR_ALREADY_EXISTS )
                    {
                        nStatus = ERROR_SUCCESS;
                    } // if: checkpoint already exists
                    else
                    {
                        (g_pfnLogEvent)(
                            hResourceHandle,
                            LOG_ERROR,
                            L"ConfigurDomesticCryptoKeyCheckpoints: Failed to set domestic crypto key checkpoint '%1'. Error: %2!u!.\n",
                            *ppszCurrent,
                            nStatus
                            );
                        break;
                    } // else: other error occurred
                } // if: error adding the checkpoint
            } // for: each checkpoint
        } // if: acquired domestic crypto context
        else
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"ConfigurDomesticCryptoKeyCheckpoints: Failed to acquire a domest crypto context. Error: %2!u!.\n",
                nStatus
                );
        } // else: error acquiring domestic crypto context
    } // if: domestic crypto keys need to be checkpointed

    return nStatus;

} //*** ConfigureDomesticCryptoKeyCheckpoints()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClNetResLogSystemEvent1
//
//  Description:
//      Log Event to the system event log.
//
//  Arguments:
//      LogLevel [IN]
//          Level of logging desired.
//
//      MessageId [IN]
//          The message ID of the error to be logged.
//
//      ErrorCode [IN]
//          The error code to be added for this error message.
//
//      Component [IN]
//          The name of the component reporting the error - e.g. "WINS" or
//          "DHCP"
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////

VOID
ClNetResLogSystemEvent1(
    IN DWORD LogLevel,
    IN DWORD MessageId,
    IN DWORD ErrorCode,
    IN LPCWSTR Component
    )
{
    DWORD Error = ErrorCode;

    ClusterLogEvent1(
        LOG_CRITICAL,
        0,
        0,
        0,
        MessageId,
        4,
        &Error,
        Component
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\registersrc.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Register.cpp
//
//  Description:
//      This file provides registration for the DLL.
//
//  Maintained By:
//      Geoffrey Pease (GPease) 18-OCT-1999
//
//////////////////////////////////////////////////////////////////////////////

#if defined(MMC_SNAPIN_REGISTRATION)
//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrRegisterNodeType(
//      SNodeTypesTable * pnttIn,
//      BOOL              fCreateIn
//      )
//
//  Description:
//      Registers the Node Type extensions for MMC Snapins using the table in
//      pnttIn as a guide.
//
//  Arguments:
//      pnttIn      - Table of node types to register.
//      fCreateIn   - TRUE == Create; FALSE == Delete
//
//  Return Values:
//      S_OK        - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrRegisterNodeType(
    const SNodeTypesTable * pnttIn,
    BOOL                    fCreateIn
    )
{
    TraceFunc1( "pnttIn = 0x%08x", pnttIn );
    Assert( pnttIn != NULL );

    LRESULT sc;
    DWORD   dwDisposition;  // placeholder
    DWORD   cbSize;

    HRESULT hr = S_OK;

    const SNodeTypesTable * pntt  = pnttIn;

    HKEY    hkeyNodeTypes   = NULL;
    HKEY    hkeyCLSID       = NULL;
    HKEY    hkeyExtension   = NULL;
    HKEY    hkey   = NULL;
    LPWSTR  pszCLSID        = NULL;

    //
    // Open the MMC NodeTypes' key.
    //
    sc = RegOpenKey( HKEY_LOCAL_MACHINE,
                     TEXT("Software\\Microsoft\\MMC\\NodeTypes"),
                     &hkeyNodeTypes
                     );
    if ( sc != ERROR_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( sc ) );
        goto Cleanup;
    } // if: error opening the key

    while ( pntt->rclsid != NULL )
    {
        //
        // Create the NODEID's CLSID key.
        //
        hr = THR( StringFromCLSID( *pntt->rclsid, &pszCLSID ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( ! fCreateIn )
        {
            sc = SHDeleteKey( hkeyNodeTypes, pszCLSID );
            if ( sc == ERROR_FILE_NOT_FOUND )
            {
                // nop
            } // if: key not found
            else if ( sc != ERROR_SUCCESS )
            {
                hr = THR( HRESULT_FROM_WIN32( sc ) );
                goto Cleanup;
            } // else if: error deleting the key

            CoTaskMemFree( pszCLSID );
            pszCLSID = NULL;
            pntt++;
            continue;
        } // if: deleting

        sc = RegCreateKeyEx( hkeyNodeTypes,
                             pszCLSID,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_CREATE_SUB_KEY | KEY_WRITE,
                             NULL,
                             &hkeyCLSID,
                             &dwDisposition
                             );
        if ( sc != ERROR_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( sc ) );
            goto Cleanup;
        } // if: error creating the key

        CoTaskMemFree( pszCLSID );
        pszCLSID = NULL;

        //
        // Set the node type's internal reference name.
        //
        cbSize = ( wcslen( pntt->pszInternalName ) + 1 ) * sizeof( WCHAR );
        sc = RegSetValueEx( hkeyCLSID, NULL, 0, REG_SZ, (LPBYTE) pntt->pszInternalName, cbSize );
        if ( sc != ERROR_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( sc ) );
            goto Cleanup;
        } // if: error setting the value

        if ( pntt->pContextMenu != NULL
          || pntt->pNameSpace != NULL
          || pntt->pPropertySheet != NULL
          || pntt->pTask != NULL
          || pntt->pToolBar != NULL
           )
        {
            //
            // Create the "Extensions" key.
            //
            sc = RegCreateKeyEx( hkeyCLSID,
                                 L"Extensions",
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_CREATE_SUB_KEY | KEY_WRITE,
                                 NULL,
                                 &hkeyExtension,
                                 &dwDisposition
                                 );
            if ( sc != ERROR_SUCCESS )
            {
                hr = THR( HRESULT_FROM_WIN32( sc ) );
                goto Cleanup;
            } // if: error creating the key

            //
            // Create the "NameSpace" key if needed.
            //
            if ( pntt->pNameSpace != NULL )
            {
                const SExtensionTable * pet;

                sc = RegCreateKeyEx( hkeyExtension,
                                     L"NameSpace",
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_CREATE_SUB_KEY | KEY_WRITE,
                                     NULL,
                                     &hkey,
                                     &dwDisposition
                                     );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error creating the key

                pet = pntt->pNameSpace;
                while ( pet->rclsid != NULL )
                {
                    //
                    // Create the NODEID's CLSID key.
                    //
                    hr = THR( StringFromCLSID( *pet->rclsid, &pszCLSID ) );
                    if ( FAILED( hr) )
                        goto Cleanup;

                    //
                    // Set the node type's internal reference name.
                    //
                    cbSize = ( wcslen( pet->pszInternalName ) + 1 ) * sizeof( WCHAR );
                    sc = RegSetValueEx( hkey, pszCLSID, 0, REG_SZ, (LPBYTE) pet->pszInternalName, cbSize );
                    if ( sc != ERROR_SUCCESS )
                    {
                        hr = THR( HRESULT_FROM_WIN32( sc ) );
                        goto Cleanup;
                    } // if: error setting the value

                    CoTaskMemFree( pszCLSID );
                    pszCLSID = NULL;

                    pet++;

                } // while: extensions

                RegCloseKey( hkey );
                hkey = NULL;

            } // if: name space list

            //
            // Create the "ContextMenu" key if needed.
            //
            if ( pntt->pContextMenu != NULL )
            {
                const SExtensionTable * pet;

                sc = RegCreateKeyEx( hkeyExtension,
                                     L"ContextMenu",
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_CREATE_SUB_KEY | KEY_WRITE,
                                     NULL,
                                     &hkey,
                                     &dwDisposition
                                     );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error creating the key

                pet = pntt->pContextMenu;
                while ( pet->rclsid != NULL )
                {
                    //
                    // Create the NODEID's CLSID key.
                    //
                    hr = THR( StringFromCLSID( *pet->rclsid, &pszCLSID ) );
                    if ( FAILED( hr ) )
                        goto Cleanup;

                    //
                    // Set the node type's internal reference name.
                    //
                    cbSize = ( wcslen( pet->pszInternalName ) + 1 ) * sizeof( WCHAR );
                    sc = RegSetValueEx( hkey, pszCLSID, 0, REG_SZ, (LPBYTE) pet->pszInternalName, cbSize );
                    if ( sc != ERROR_SUCCESS )
                    {
                        hr = THR( HRESULT_FROM_WIN32( sc ) );
                        goto Cleanup;
                    } // if: error setting the value

                    CoTaskMemFree( pszCLSID );
                    pszCLSID = NULL;

                    pet++;

                } // while: extensions

                RegCloseKey( hkey );
                hkey = NULL;

            } // if: context menu list

            //
            // Create the "ToolBar" key if needed.
            //
            if ( pntt->pToolBar != NULL )
            {
                const SExtensionTable * pet;

                sc = RegCreateKeyEx( hkeyExtension,
                                     L"ToolBar",
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_CREATE_SUB_KEY | KEY_WRITE,
                                     NULL,
                                     &hkey,
                                     &dwDisposition
                                     );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error creating the key

                pet = pntt->pToolBar;
                while ( pet->rclsid != NULL )
                {
                    //
                    // Create the NODEID's CLSID key.
                    //
                    hr = THR( StringFromCLSID( *pet->rclsid, &pszCLSID ) );
                    if ( FAILED( hr ) )
                        goto Cleanup;

                    //
                    // Set the node type's internal reference name.
                    //
                    cbSize = ( wcslen( pet->pszInternalName ) + 1 ) * sizeof( WCHAR );
                    sc = RegSetValueEx( hkey, pszCLSID, 0, REG_SZ, (LPBYTE) pet->pszInternalName, cbSize );
                    if ( sc != ERROR_SUCCESS )
                    {
                        hr = THR( HRESULT_FROM_WIN32( sc ) );
                        goto Cleanup;
                    } // if: error setting the value

                    CoTaskMemFree( pszCLSID );
                    pszCLSID = NULL;

                    pet++;

                } // while: extensions

            } // if: name space list

            //
            // Create the "PropertySheet" key if needed.
            //
            if ( pntt->pPropertySheet != NULL )
            {
                const SExtensionTable * pet;

                sc = RegCreateKeyEx( hkeyExtension,
                                     L"PropertySheet",
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_CREATE_SUB_KEY | KEY_WRITE,
                                     NULL,
                                     &hkey,
                                     &dwDisposition
                                     );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error creating the key

                pet = pntt->pPropertySheet;
                while ( pet->rclsid != NULL )
                {
                    //
                    // Create the NODEID's CLSID key.
                    //
                    hr = THR( StringFromCLSID( *pet->rclsid, &pszCLSID ) );
                    if ( FAILED( hr ) )
                        goto Cleanup;

                    //
                    // Set the node type's internal reference name.
                    //
                    cbSize = ( wcslen( pet->pszInternalName ) + 1 ) * sizeof( WCHAR );
                    sc = RegSetValueEx( hkey, pszCLSID, 0, REG_SZ, (LPBYTE) pet->pszInternalName, cbSize );
                    if ( sc != ERROR_SUCCESS )
                    {
                        hr = THR( HRESULT_FROM_WIN32( sc ) );
                        goto Cleanup;
                    } // if: error setting the value

                    CoTaskMemFree( pszCLSID );
                    pszCLSID = NULL;

                    pet++;

                } // while: extensions

            } // if: name space list

            //
            // Create the "Task" key if needed.
            //
            if ( pntt->pTask != NULL )
            {
                const SExtensionTable * pet;

                sc = RegCreateKeyEx( hkeyExtension,
                                     L"Task",
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_CREATE_SUB_KEY | KEY_WRITE,
                                     NULL,
                                     &hkey,
                                     &dwDisposition
                                     );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error creating the key

                pet = pntt->pTask;
                while ( pet->rclsid != NULL )
                {
                    //
                    // Create the NODEID's CLSID key.
                    //
                    hr = THR( StringFromCLSID( *pet->rclsid, &pszCLSID ) );
                    if ( FAILED( hr ) )
                        goto Cleanup;

                    //
                    // Set the node type's internal reference name.
                    //
                    cbSize = ( wcslen( pet->pszInternalName ) + 1 ) * sizeof( WCHAR );
                    sc = RegSetValueEx( hkey, pszCLSID, 0, REG_SZ, (LPBYTE) pet->pszInternalName, cbSize );
                    if ( sc != ERROR_SUCCESS )
                    {
                        hr = THR( HRESULT_FROM_WIN32( sc ) );
                        goto Cleanup;
                    } // if: error setting the value

                    CoTaskMemFree( pszCLSID );
                    pszCLSID = NULL;

                    pet++;

                } // while: extensions

            } // if: name space list

        } // if: extensions present

        pntt++;

    } // while: pet->rclsid

    //
    // If we made it here, then obviously we were successful.
    //
    hr = S_OK;

Cleanup:
    if ( pszCLSID != NULL )
    {
        CoTaskMemFree( pszCLSID );
    } // if: pszCLSID

    if ( hkey != NULL )
    {
        RegCloseKey( hkey );
    } // if: hkey

    if ( hkeyCLSID != NULL )
    {
        RegCloseKey( hkeyCLSID );
    } // if: hkeyCLSID

    if ( hkeyExtension != NULL)
    {
        RegCloseKey( hkeyExtension );
    } // if: hkeyExtension

    if ( hkey != NULL )
    {
        RegCloseKey( hkey );
    } // if: hkey

    if ( hkeyNodeTypes != NULL )
    {
        RegCloseKey( hkeyNodeTypes );
    } // if: hkeyNodeTypes

    HRETURN( hr );

} //*** HrRegisterNodeType( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrRegisterSnapins(
//      const SSnapInTable * psitIn
//      BOOL                 fCreateIn
//      )
//
//  Description:
//      Registers the Snap-Ins for MMC using the table in psitIn as a guide.
//
//  Arguments:
//      psitIn      - Table of snap-ins to register.
//      fCreateIn   - TRUE == Create; FALSE == Delete
//
//  Return Values:
//      S_OK        - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrRegisterSnapins(
    const SSnapInTable * psitIn,
    BOOL                 fCreateIn
    )
{
    TraceFunc1( "psitIn = 0x%08x", psitIn );
    Assert( psitIn != NULL );

    LRESULT sc;
    DWORD   dwDisposition;  // placeholder
    DWORD   cbSize;

    HRESULT hr = S_OK;

    const SSnapInTable *  psit = psitIn;

    LPWSTR  pszCLSID        = NULL;
    HKEY    hkeySnapins     = NULL;
    HKEY    hkeyCLSID       = NULL;
    HKEY    hkeyNodeTypes   = NULL;
    HKEY    hkeyTypes       = NULL;

    //
    // Register the class id of the snapin
    //
    sc = RegOpenKey( HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\MMC\\Snapins"), &hkeySnapins );
    if ( sc != ERROR_SUCCESS )
    {
        hr = THR( HRESULT_FROM_WIN32( sc ) );
        goto Cleanup;
    } // if: error opening the key

    while ( psit->rclsid )
    {
        hr = THR( StringFromCLSID( *psit->rclsid, &pszCLSID ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        if ( ! fCreateIn )
        {
            sc = SHDeleteKey( hkeySnapins, pszCLSID );
            if ( sc == ERROR_FILE_NOT_FOUND )
            {
                // nop
            } // if: key not found
            else if ( sc != ERROR_SUCCESS )
            {
                hr = THR( HRESULT_FROM_WIN32( sc ) );
                goto Cleanup;
            } // else if: error deleting the key

            CoTaskMemFree( pszCLSID );
            pszCLSID = NULL;
            psit++;
            continue;
        } // if: deleting

        sc = RegCreateKeyEx( hkeySnapins,
                             pszCLSID,
                             0,
                             0,
                             REG_OPTION_NON_VOLATILE,
                             KEY_CREATE_SUB_KEY | KEY_WRITE,
                             NULL,
                             &hkeyCLSID,
                             NULL
                             );
        if ( sc != ERROR_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( sc ) );
            goto Cleanup;
        } // if: error creating the key

        CoTaskMemFree( pszCLSID );
        pszCLSID = NULL;

        //
        // Set the (default) to a helpful description
        //
        cbSize = ( wcslen( psit->pszInternalName ) + 1 ) * sizeof( WCHAR );
        sc = RegSetValueEx( hkeyCLSID, NULL, 0, REG_SZ, (LPBYTE) psit->pszInternalName, cbSize );
        if ( sc != ERROR_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( sc ) );
            goto Cleanup;
        } // if: setting the value

        //
        // Set the Snapin's display name
        //
        cbSize = ( wcslen( psit->pszDisplayName ) + 1 ) * sizeof( WCHAR );
        sc = RegSetValueEx( hkeyCLSID, TEXT("NameString"), 0, REG_SZ, (LPBYTE) psit->pszDisplayName, cbSize );
        if ( sc != ERROR_SUCCESS )
        {
            hr = THR( HRESULT_FROM_WIN32( sc ) );
            goto Cleanup;
        } // if: error setting the value

        if ( psit->fStandAlone )
        {
            HKEY hkey;
            sc = RegCreateKeyEx( hkeyCLSID,
                                 TEXT("StandAlone"),
                                 0,
                                 0,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_CREATE_SUB_KEY | KEY_WRITE,
                                 NULL,
                                 &hkey,
                                 NULL
                                 );
            if ( sc != ERROR_SUCCESS )
            {
                hr = THR( HRESULT_FROM_WIN32( sc ) );
                goto Cleanup;
            } // if: error creating the key

            RegCloseKey( hkey );

        } // if: stand alone

        if ( psit->pntt != NULL )
        {
            int     nTypes;

            sc = RegCreateKeyEx( hkeyCLSID,
                                 TEXT("NodeTypes"),
                                 0,
                                 0,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_CREATE_SUB_KEY | KEY_WRITE,
                                 NULL,
                                 &hkeyNodeTypes,
                                 NULL
                                 );
            if ( sc != ERROR_SUCCESS )
            {
                hr = THR( HRESULT_FROM_WIN32( sc ) );
                goto Cleanup;
            } // if: error creating the key

            for ( nTypes = 0; psit->pntt[ nTypes ].rclsid; nTypes++ )
            {
                hr = THR( StringFromCLSID( *psit->pntt[ nTypes ].rclsid, &pszCLSID ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

                sc = RegCreateKeyEx( hkeyNodeTypes,
                                     pszCLSID,
                                     0,
                                     0,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_CREATE_SUB_KEY | KEY_WRITE,
                                     NULL,
                                     &hkeyTypes,
                                     NULL
                                     );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error creating the key

                CoTaskMemFree( pszCLSID );
                pszCLSID = NULL;

                //
                // Set the (default) to a helpful description
                //
                cbSize = ( wcslen( psit->pntt[ nTypes ].pszInternalName ) + 1 ) * sizeof( WCHAR );
                sc = RegSetValueEx( hkeyTypes, NULL, 0, REG_SZ, (LPBYTE) psit->pntt[ nTypes ].pszInternalName, cbSize );
                if ( sc != ERROR_SUCCESS )
                {
                    hr = THR( HRESULT_FROM_WIN32( sc ) );
                    goto Cleanup;
                } // if: error setting the value

                RegCloseKey( hkeyTypes );
                hkeyTypes = NULL;

                hr = THR( HrRegisterNodeType( psit->pntt, fCreateIn ) );
                if ( FAILED( hr ) )
                    goto Cleanup;

            } // for: each node type

            RegCloseKey( hkeyNodeTypes );
            hkeyNodeTypes = NULL;

        } // if: node types

        RegCloseKey( hkeyCLSID );
        hkeyCLSID = NULL;

        psit++;

    } // while: psit->rclsid

    //
    // If we made it here, then obviously we were successful.
    //
    hr = S_OK;

Cleanup:
    if ( pszCLSID != NULL )
    {
        CoTaskMemFree( pszCLSID );
    } // if: pszCLSID

    if ( hkeySnapins != NULL )
    {
        RegCloseKey( hkeySnapins );
    } // if: hkeySnapins

    if ( hkeyNodeTypes != NULL )
    {
        RegCloseKey( hkeyNodeTypes );
    } // if: hkeyNodeTypes

    if ( hkeyTypes != NULL )
    {
        RegCloseKey( hkeyTypes );
    } // if: hkeyTypes

    HRETURN( hr );

} //*** HrRegisterSnapins( )

#endif // defined(MMC_SNAPIN_REGISTRATION)


//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  HrRegisterAPPID(
//      HKEY            hkeyAPPIDIn,
//      LPCLASSTABLE    pClassTableEntryIn,
//      BOOL            fCreateIn
//      )
//
//  Description:
//      Writes/deletes the application GUID under the APPID key in HKCR. It also
//      writes the "DllSurrogate" and "(Default)" description.
//
//  Arguments:
//      hkeyAPPIDIn
//          An hkey to the HKCR\APPID key.
//
//      pClassTableEntryIn
//          The entry from the class table to (un)register.
//
//      fCreateIn
//          TRUE means create the entry. FALSE means delete the entry.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          The call failed.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrRegisterAPPID(
    HKEY            hkeyAPPIDIn,
    LPCLASSTABLE    pClassTableEntryIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT         hr;
    LRESULT         sc;
    DWORD           dwDisposition;
    DWORD           cbSize;

    LPOLESTR        pszCLSID;
    LPCOLESTR       psz;

    HKEY            hkeyComponent   = NULL;

    static const TCHAR szDllSurrogate[] = TEXT("DllSurrogate");

    //
    // Convert the CLSID to a string
    //
    hr = THR( StringFromCLSID( *(pClassTableEntryIn->rclsidAppId), &pszCLSID ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#ifdef UNICODE
    psz = pszCLSID;
#else // ASCII
    CHAR szCLSID[ 40 ];

    wcstombs( szCLSID, pszCLSID, StrLenW( pszCLSID ) + 1 );
    psz = szCLSID;
#endif // UNICODE

    if ( ! fCreateIn )
    {
        sc = TW32( SHDeleteKey( hkeyAPPIDIn, psz ) );
        if ( sc == ERROR_FILE_NOT_FOUND )
        {
            // nop
            hr = S_OK;
        } // if: key not found
        else if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // else if: error deleting the key

        goto Cleanup;

    } // if: deleting

    //
    // Create the "APPID" key
    //
    sc = TW32( RegCreateKeyEx( hkeyAPPIDIn,
                               pszCLSID,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_CREATE_SUB_KEY | KEY_WRITE,
                               NULL,
                               &hkeyComponent,
                               &dwDisposition
                               ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: error creating the key

    //
    //  Set "Default" for the APPID to the same name of the component.
    //
    cbSize = ( StrLen( pClassTableEntryIn->pszName ) + 1 ) * sizeof( TCHAR );
    sc = TW32( RegSetValueEx( hkeyComponent, NULL, 0, REG_SZ, (LPBYTE) pClassTableEntryIn->pszName, cbSize ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: error setting the value

    //
    //  Write out the "DllSurrogate" value.
    //
    AssertMsg( pClassTableEntryIn->pszSurrogate != NULL, "How can we have an APPID without a surrogate string? Did the macros changes?" );
    if ( pClassTableEntryIn->pszSurrogate != NULL )
    {
        cbSize = ( StrLen( pClassTableEntryIn->pszSurrogate ) + 1 ) * sizeof( TCHAR );
        sc = TW32( RegSetValueEx( hkeyComponent,
                                  szDllSurrogate,
                                  0,
                                  REG_SZ,
                                  (LPBYTE) pClassTableEntryIn->pszSurrogate,
                                  cbSize
                                  ) );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // if: error setting the value

    } // if: surrogate string found

Cleanup:
    if ( pszCLSID != NULL )
    {
        CoTaskMemFree( pszCLSID );
    } // if: pszCLSID

    if ( hkeyComponent != NULL )
    {
        RegCloseKey( hkeyComponent );
    } // if: hkeyComponent

    HRETURN( hr );

} // HrRegisterAPPID( )

//////////////////////////////////////////////////////////////////////////////
//
//  HRESULT
//  HrRegisterCLSID(
//      HKEY            hkeyCLSIDIn,
//      LPCLASSTABLE    pClassTableEntryIn,
//      BOOL            fCreateIn
//      )
//
//  Description:
//      Writes/deletes the component GUID under the CLSID key in HKCR. It also
//      writes the "InprocServer32", "Apartment" and "(Default)" description.
//
//  Arguments:
//      hkeyCLSIDin
//          An hkey to the HKCR\CLSID key.
//
//      pClassTableEntryIn
//          The entry from the class table to (un)register.
//
//      fCreateIn
//          TRUE means create the entry. FALSE means delete the entry.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs
//          The call failed.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrRegisterCLSID(
    HKEY            hkeyCLSIDIn,
    LPCLASSTABLE    pClassTableEntryIn,
    BOOL            fCreateIn
    )
{
    TraceFunc( "" );

    HRESULT         hr;
    LRESULT         sc;
    DWORD           dwDisposition;
    DWORD           cbSize;

    LPOLESTR        pszCLSID;
    LPOLESTR        psz;

    HKEY            hkeyComponent   = NULL;
    HKEY            hkeyInProc  = NULL;

    static const TCHAR szInProcServer32[] = TEXT("InProcServer32");
    static const TCHAR szThreadingModel[] = TEXT("ThreadingModel");
    static const TCHAR szAPPID[]          = TEXT("APPID");

    //
    // Convert the CLSID to a string
    //
    hr = THR( StringFromCLSID( *(pClassTableEntryIn->rclsid), &pszCLSID ) );
    if ( FAILED( hr ) )
        goto Cleanup;

#ifdef UNICODE
    psz = pszCLSID;
#else // ASCII
    CHAR szCLSID[ 40 ];

    wcstombs( szCLSID, pszCLSID, StrLenW( pszCLSID ) + 1 );
    psz = szCLSID;
#endif // UNICODE

    if ( ! fCreateIn )
    {
        sc = TW32( SHDeleteKey( hkeyCLSIDIn, psz ) );
        if ( sc == ERROR_FILE_NOT_FOUND )
        {
            // nop
            hr = S_OK;
        } // if: key not found
        else if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        } // else if: error deleting the key

        goto Cleanup;

    } // if: deleting

    //
    // Create the "CLSID" key
    //
    sc = TW32( RegCreateKeyEx( hkeyCLSIDIn,
                               pszCLSID,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_CREATE_SUB_KEY | KEY_WRITE,
                               NULL,
                               &hkeyComponent,
                               &dwDisposition
                               ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: error creating the key

    //
    // Set "Default" for the CLSID
    //
    cbSize = ( StrLen( pClassTableEntryIn->pszName ) + 1 ) * sizeof( TCHAR );
    sc = TW32( RegSetValueEx( hkeyComponent, NULL, 0, REG_SZ, (LPBYTE) pClassTableEntryIn->pszName, cbSize ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: error setting the value

    //
    // Create "InProcServer32"
    //
    sc = TW32( RegCreateKeyEx( hkeyComponent,
                               szInProcServer32,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_CREATE_SUB_KEY | KEY_WRITE,
                               NULL,
                               &hkeyInProc,
                               &dwDisposition
                               ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: error creating the key

    //
    // Set "Default" in the InProcServer32
    //
    cbSize = ( StrLen( g_szDllFilename ) + 1 ) * sizeof( TCHAR );
    sc = TW32( RegSetValueEx( hkeyInProc, NULL, 0, REG_SZ, (LPBYTE) g_szDllFilename, cbSize ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: error setting the value

    //
    // Set "ThreadModel".
    //
    cbSize = ( StrLen( pClassTableEntryIn->pszComModel ) + 1 ) * sizeof( TCHAR );
    sc = TW32( RegSetValueEx( hkeyInProc, szThreadingModel, 0, REG_SZ, (LPBYTE) pClassTableEntryIn->pszComModel, cbSize ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: error setting the value

    //
    //  If this class has an APPID, write it out now.
    //
    if ( !IsEqualIID( *pClassTableEntryIn->rclsidAppId, IID_NULL ) )
    {
        CoTaskMemFree( pszCLSID );

        //
        // Convert the CLSID to a string
        //
        hr = THR( StringFromCLSID( *(pClassTableEntryIn->rclsidAppId), &pszCLSID ) );
        if ( FAILED( hr ) )
            goto Cleanup;

#ifdef UNICODE
        psz = pszCLSID;
#else // ASCII
        CHAR szCLSID[ 40 ];

        wcstombs( szCLSID, pszCLSID, StrLenW( pszCLSID ) + 1 );
        psz = szCLSID;
#endif // UNICODE

        cbSize = ( StrLen( psz ) + 1 ) * sizeof( TCHAR );
        sc = TW32( RegSetValueEx( hkeyComponent, szAPPID, 0, REG_SZ, (LPBYTE) psz, cbSize ) );
        if ( sc != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        }
    }

Cleanup:
    if ( pszCLSID != NULL )
    {
        CoTaskMemFree( pszCLSID );
    } // if: pszCLSID

    if ( hkeyInProc != NULL )
    {
        RegCloseKey( hkeyInProc );
    } // if: hkeyInProc

    if ( hkeyComponent != NULL )
    {
        RegCloseKey( hkeyComponent );
    } // if: hkeyComponent

    HRETURN( hr );

} // HrRegisterCLSID( )

//////////////////////////////////////////////////////////////////////////////
//++
//
//  HRESULT
//  HrRegisterDll(
//      fCreateIn
//      )
//
//  Description:
//      Registers the COM objects in the DLL using the classes in g_DllClasses
//      (defined in GUIDS.CPP) as a guide.
//
//  Arguments:
//      fCreateIn   - TRUE == Create; FALSE == Delete.
//
//  Return Values:
//      S_OK        - Success.
//      Other HRESULTs.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
HrRegisterDll(
    BOOL fCreateIn
    )
{
    TraceFunc1( "%s", BOOLTOSTRING( fCreateIn ) );

    DWORD           dwDisposition;
    DWORD           cbSize;
    LRESULT         sc;

    HRESULT         hr = S_OK;
    int             iCount = 0;

    HKEY            hkeyCLSID = NULL;
    HKEY            hkeyAPPID = NULL;

    ICatRegister *  picr = NULL;

#if defined( COMPONENT_HAS_CATIDS )
    CATEGORYINFO *  prgci       = NULL;
    CATID *         prgcatid    = NULL;
#endif // defined( COMPONENT_HAS_CATIDS )

    hr = STHR( CoInitialize( NULL ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if:

    //
    // Open the "CLSID" under HKCR
    //
    sc = TW32( RegOpenKey( HKEY_CLASSES_ROOT, TEXT("CLSID"), &hkeyCLSID ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: error opening the key

    //
    //  Open the "APPID" under HKCR
    //
    sc = TW32( RegOpenKey( HKEY_CLASSES_ROOT, TEXT("APPID"), &hkeyAPPID ) );
    if ( sc != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if: error opening the key

    //
    // Create ICatRegister
    //
    hr = THR( CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void **) &picr ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

#if defined( COMPONENT_HAS_CATIDS )
    //
    // Register or unregister category IDs.
    //

    // Count the number of category IDs.
    for ( iCount = 0 ; g_DllCatIds[ iCount ].rcatid != NULL ; iCount++ )
    {
    }

    Assert( iCount > 0 ); // If COMPONENT_HAS_CATIDS is defined, there had better be some to register

    if ( iCount > 0 )
    {
        if ( fCreateIn )
        {
            // Allocate the category info array.
            prgci = new CATEGORYINFO[ iCount ];
            if ( prgci == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            } // if: error allocating category info array

            // Fill the category info array.
            for ( iCount = 0 ; g_DllCatIds[ iCount ].rcatid != NULL ; iCount++ )
            {
                prgci[ iCount ].catid = *g_DllCatIds[ iCount ].rcatid;
                prgci[ iCount ].lcid = LOCALE_NEUTRAL;
                StrCpyNW(
                      prgci[ iCount ].szDescription
                    , g_DllCatIds[ iCount ].pszName
                    , ARRAYSIZE( prgci[ iCount ].szDescription )
                    );
            } // for: each CATID

            hr = THR( picr->RegisterCategories( iCount, prgci ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:
        } // if: registering
        else
        {
            // Allocate the array of CATIDs.
            prgcatid = new CATID[ iCount ];
            if ( prgcatid == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            } // if: error allocating CATID array

            // Fill the category info array.
            for ( iCount = 0 ; g_DllCatIds[ iCount ].rcatid != NULL ; iCount++ )
            {
                prgcatid[ iCount ] = *g_DllCatIds[ iCount ].rcatid;
            } // for: each CATID

            hr = THR( picr->UnRegisterCategories( iCount, prgcatid ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:
        } // else: unregistering

    } // if: CATID table is not empty
#endif // defined( COMPONENT_HAS_CATIDS )

    //
    // Loop until we have created all the keys for our classes.
    //
    for ( iCount = 0 ; g_DllClasses[ iCount ].rclsid != NULL ; iCount++ )
    {
        LPTSTR psz;

        TraceMsg( mtfALWAYS,
                  "Registering {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x} - %s",
                  g_DllClasses[ iCount ].rclsid->Data1,
                  g_DllClasses[ iCount ].rclsid->Data2,
                  g_DllClasses[ iCount ].rclsid->Data3,
                  g_DllClasses[ iCount ].rclsid->Data4[ 0 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 1 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 2 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 3 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 4 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 5 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 6 ],
                  g_DllClasses[ iCount ].rclsid->Data4[ 7 ],
                  g_DllClasses[ iCount ].pszName
                  );

        //
        //  Register the CLSID
        //

        hr = THR( HrRegisterCLSID( hkeyCLSID, (LPCLASSTABLE) &g_DllClasses[ iCount ], fCreateIn ) );
        if ( FAILED( hr ) )
            goto Cleanup;

        //
        //  Register the APPID (if any)
        //

        if ( !IsEqualIID( *g_DllClasses[ iCount ].rclsidAppId, IID_NULL ) )
        {
            hr = THR( HrRegisterAPPID( hkeyAPPID, (LPCLASSTABLE) &g_DllClasses[ iCount ], fCreateIn ) );
            if ( FAILED( hr ) )
                goto Cleanup;

        } // if: APPID present

        //
        //  Register the category ID.
        //

        if ( g_DllClasses[ iCount ].pfnCatIDRegister != NULL )
        {
            hr = THR( (*(g_DllClasses[ iCount ].pfnCatIDRegister))( picr, fCreateIn ) );
            if ( FAILED( hr ) )
            {
                goto Cleanup;
            } // if:
        } // if:

    } // while: DLL classes to register

#if defined( MMC_SNAPIN_REGISTRATION )
    //
    // Register the "Snapins".
    //
    hr = THR( HrRegisterSnapins( g_SnapInTable, fCreateIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;

    //
    // Register "other" NodeTypes (those not associated with a Snapin).
    //
    hr = THR( HrRegisterNodeType( g_SNodeTypesTable, fCreateIn ) );
    if ( FAILED( hr ) )
        goto Cleanup;
#endif // defined( MMC_SNAPIN_REGISTRATION )

Cleanup:
    if ( hkeyCLSID != NULL )
    {
        RegCloseKey( hkeyCLSID );
    } // if:

    if ( hkeyAPPID != NULL )
    {
        RegCloseKey( hkeyAPPID );
    } // if:

    if ( picr != NULL )
    {
        picr->Release();
    } // if:

#if defined( COMPONENT_HAS_CATIDS )
    if ( prgci != NULL )
    {
        delete [] prgci;
    }
    if ( prgcatid != NULL )
    {
        delete [] prgcatid;
    }
#endif

    CoUninitialize();

    HRETURN( hr );

} //*** HrRegisterDll( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetres\dhcp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      Dhcp.cpp
//
//  Description:
//      Resource DLL for DHCP Services (ClNetRes).
//
//  Author:
//      David Potter (DavidP) March 17, 1999
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "ClNetRes.h"
#include "clusvmsg.h"
#include "clusrtl.h"

//
// Type and constant definitions.
//

#define DHCP_PARAMS_REGKEY          L"System\\CurrentControlSet\\Services\\DHCPServer\\Parameters"
#define DHCP_BIND_REGVALUE          L"Bind"
#define DHCP_DATABASEPATH_REGVALUE  L"DatabasePath"
#define DHCP_LOGFILEPATH_REGVALUE   L"DhcpLogFilePath"
#define DHCP_BACKUPPATH_REGVALUE    L"BackupDatabasePath"
#define DHCP_CLUSRESNAME_REGVALUE   L"ClusterResourceName"

#define CLUSREG_NAME_RES_TYPE   L"Type"

//
// Allow for the following number of IP address/SubnetMask for expansion.
// In this case (2 new entries, since it takes 2 slots for each).
//
#define IP_BLOCK_SIZE  4


// ADDPARAM: Add new properties here.
#define PROP_NAME__DATABASEPATH L"DatabasePath"
#define PROP_NAME__LOGFILEPATH  L"LogFilePath"
#define PROP_NAME__BACKUPPATH   L"BackupPath"

#define PROP_DEFAULT__DATABASEPATH  L"%SystemRoot%\\system32\\dhcp\\"
#define PROP_DEFAULT__BACKUPPATH    L"%SystemRoot%\\system32\\dhcp\\backup\\"

// ADDPARAM: Add new properties here.
typedef struct _DHCP_PROPS
{
    PWSTR           pszDatabasePath;
    PWSTR           pszLogFilePath;
    PWSTR           pszBackupPath;
} DHCP_PROPS, * PDHCP_PROPS;

typedef struct _DHCP_RESOURCE
{
    RESID                   resid; // for validation
    DHCP_PROPS              props;
    HCLUSTER                hCluster;
    HRESOURCE               hResource;
    SC_HANDLE               hService;
    DWORD                   dwServicePid;
    HKEY                    hkeyParameters;
    RESOURCE_HANDLE         hResourceHandle;
    LPWSTR                  pszResourceName;
    CLUS_WORKER             cwWorkerThread;
    CLUSTER_RESOURCE_STATE  state;
} DHCP_RESOURCE, * PDHCP_RESOURCE;


//
// Global data.
//

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE g_DhcpFunctionTable;

// Single instance semaphore.

#define DHCP_SINGLE_INSTANCE_SEMAPHORE L"Cluster$DHCP$Semaphore"
static HANDLE g_hSingleInstanceSemaphoreDhcp = NULL;
static PDHCP_RESOURCE g_pSingleInstanceResourceDhcp = NULL;

//
// DHCP Service resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
DhcpResourcePrivateProperties[] =
{
    { PROP_NAME__DATABASEPATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET( DHCP_PROPS, pszDatabasePath ) },
    { PROP_NAME__LOGFILEPATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET( DHCP_PROPS, pszLogFilePath ) },
    { PROP_NAME__BACKUPPATH, NULL, CLUSPROP_FORMAT_SZ, 0, 0, 0, RESUTIL_PROPITEM_REQUIRED, FIELD_OFFSET( DHCP_PROPS, pszBackupPath ) },
    { 0 }
};

//
// Registry key checkpoints.
//
LPCWSTR g_pszRegKeysDhcp[] =
{
    L"System\\CurrentControlSet\\Services\\DHCPServer\\Parameters",
    L"Software\\Microsoft\\DHCPServer\\Configuration",
    NULL
};

//
// Crypto key checkpoints.
//
LPCWSTR g_pszCryptoKeysDhcp[] =
{
    // TODO: Specify any crypto keys to be checkpointed for resources of this type
    // e.g. L"1\\My Provider v1.0\\MYACRONYM",
    NULL
};

//
// Domestic crypto key checkpoints.
//
LPCWSTR g_pszDomesticCryptoKeysDhcp[] =
{
    // TODO: Specify any domestic crypto keys to be checkpointed for resources of this type
    // e.g. L"1\\My Enhanced Provider v1.0\\MYACRONYM_128",
    NULL
};

//
// Function prototypes.
//

RESID WINAPI DhcpOpen(
    IN  LPCWSTR         pszResourceName,
    IN  HKEY            hkeyResourceKey,
    IN  RESOURCE_HANDLE hResourceHandle
    );

void WINAPI DhcpClose( IN RESID resid );

DWORD WINAPI DhcpOnline(
    IN      RESID   resid,
    IN OUT  PHANDLE phEventHandle
    );

DWORD WINAPI DhcpOnlineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PDHCP_RESOURCE  pResourceEntry
    );

DWORD DhcpBuildBindings(
    IN  PDHCP_RESOURCE  pResourceEntry,
    OUT PVOID *         ppOutBuffer,
    OUT LPDWORD         pcbOutBufferSize
    );

DWORD DhcpGetIPList(
    IN  PDHCP_RESOURCE  pResourceEntry,
    OUT LPWSTR **       pppszIPList,
    OUT LPDWORD         pcszIPAddrs
    );

DWORD DhcpGetIpAndSubnet(
    IN  HRESOURCE   hres,
    OUT LPWSTR *    ppszIPAddress,
    OUT LPWSTR *    ppszSubnetMask
    );

DWORD WINAPI DhcpOffline( IN RESID resid );

DWORD WINAPI DhcpOfflineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PDHCP_RESOURCE  pResourceEntry
    );

void WINAPI DhcpTerminate( IN RESID resid );

BOOL WINAPI DhcpLooksAlive( IN RESID resid );

BOOL WINAPI DhcpIsAlive( IN RESID resid );

BOOL DhcpCheckIsAlive(
    IN PDHCP_RESOURCE   pResourceEntry,
    IN BOOL             bFullCheck
    );

DWORD WINAPI DhcpResourceControl(
    IN  RESID   resid,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );

DWORD DhcpGetRequiredDependencies(
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    );

DWORD DhcpReadParametersToParameterBlock(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      BOOL            bCheckForRequiredProperties
    );

DWORD DhcpGetPrivateResProperties(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    OUT     PVOID           pOutBuffer,
    IN      DWORD           cbOutBufferSize,
    OUT     LPDWORD         pcbBytesReturned
    );

DWORD DhcpValidatePrivateResProperties(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      const PVOID     pInBuffer,
    IN      DWORD           cbInBufferSize,
    OUT     PDHCP_PROPS     pProps
    );

DWORD DhcpValidateParameters(
    IN  PDHCP_RESOURCE  pResourceEntry,
    IN  PDHCP_PROPS     pProps
    );

DWORD DhcpSetPrivateResProperties(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      const PVOID     pInBuffer,
    IN      DWORD           cbInBufferSize
    );

DWORD DhcpZapSystemRegistry(
    IN  PDHCP_RESOURCE  pResourceEntry,
    IN  PDHCP_PROPS     pProps,
    IN  HKEY            hkeyParametersKey
    );

DWORD DhcpGetDefaultPropertyValues(
    IN      PDHCP_RESOURCE  pResourceEntry,
    IN OUT  PDHCP_PROPS     pProps
    );

DWORD DhcpDeleteResourceHandler( IN OUT PDHCP_RESOURCE pResourceEntry );

DWORD DhcpSetNameHandler(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      LPWSTR          pszName
    );


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpDllMain
//
//  Description:
//      Main DLL entry point for the DHCP Service resource type.
//
//  Arguments:
//      DllHandle   [IN] DLL instance handle.
//      Reason      [IN] Reason for being called.
//      Reserved    [IN] Reserved argument.
//
//  Return Value:
//      TRUE        Success.
//      FALSE       Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOLEAN WINAPI DhcpDllMain(
    IN  HINSTANCE   hDllHandle,
    IN  DWORD       nReason,
    IN  LPVOID      Reserved
    )
{
    //WCHAR szErrorMsg[ 2048 ];
    DWORD status;

    switch ( nReason )
    {
        case DLL_PROCESS_ATTACH:
            //if ( g_hSingleInstanceSemaphoreWins != NULL )
            //{
            //    OutputDebugString( L"DhcpDllMain: semaphore not NULL\n" );
            //}
            g_hSingleInstanceSemaphoreDhcp = CreateSemaphoreW(
                NULL,
                0,
                1,
                DHCP_SINGLE_INSTANCE_SEMAPHORE
                );
            status = GetLastError();
            //wsprintf( szErrorMsg, L"DhcpDllMain: Status %d from CreateSemaphoreW, handle = %08.8x\n", status, g_hSingleInstanceSemaphoreWins );
            //OutputDebugString( szErrorMsg );
            if ( g_hSingleInstanceSemaphoreDhcp == NULL )
            {
                return FALSE;
            } // if: error creating semaphore
            if ( status != ERROR_ALREADY_EXISTS )
            {
                // If the semaphore didnt exist, set its initial count to 1.
                ReleaseSemaphore( g_hSingleInstanceSemaphoreDhcp, 1, NULL );
            } // if: semaphore didn't already exist
            break;

        case DLL_PROCESS_DETACH:
            if ( g_hSingleInstanceSemaphoreDhcp != NULL )
            {
                CloseHandle( g_hSingleInstanceSemaphoreDhcp );
                g_hSingleInstanceSemaphoreDhcp = NULL;
            } // if: single instance semaphore was created
            break;

    } // switch: nReason

    return TRUE;

} //*** DhcpDllMain()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpStartup
//
//  Description:
//      Startup the resource DLL for the DHCP Service resource type.
//      This routine verifies that at least one currently supported version
//      of the resource DLL is between nMinVersionSupported and
//      nMaxVersionSupported. If not, then the resource DLL should return
//      ERROR_REVISION_MISMATCH.
//
//      If more than one version of the resource DLL interface is supported
//      by the resource DLL, then the highest version (up to
//      nMaxVersionSupported) should be returned as the resource DLL's
//      interface. If the returned version is not within range, then startup
//      fails.
//
//      The Resource Type is passed in so that if the resource DLL supports
//      more than one Resource Type, it can pass back the correct function
//      table associated with the Resource Type.
//
//  Arguments:
//      pszResourceType [IN]
//          Type of resource requesting a function table.
//
//      nMinVersionSupported [IN]
//          Minimum resource DLL interface version supported by the cluster
//          software.
//
//      nMaxVersionSupported [IN]
//          Maximum resource DLL interface version supported by the cluster
//          software.
//
//      pfnSetResourceStatus [IN]
//          Pointer to a routine that the resource DLL should call to update
//          the state of a resource after the Online or Offline routine
//          have returned a status of ERROR_IO_PENDING.
//
//      pfnLogEvent [IN]
//          Pointer to a routine that handles the reporting of events from
//          the resource DLL.
//
//      pFunctionTable [IN]
//          Returns a pointer to the function table defined for the version
//          of the resource DLL interface returned by the resource DLL.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful.
//
//      ERROR_CLUSTER_RESNAME_NOT_FOUND
//          The resource type name is unknown by this DLL.
//
//      ERROR_REVISION_MISMATCH
//          The version of the cluster service doesn't match the version of
//          the DLL.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpStartup(
    IN  LPCWSTR                         pszResourceType,
    IN  DWORD                           nMinVersionSupported,
    IN  DWORD                           nMaxVersionSupported,
    IN  PSET_RESOURCE_STATUS_ROUTINE    pfnSetResourceStatus,
    IN  PLOG_EVENT_ROUTINE              pfnLogEvent,
    OUT PCLRES_FUNCTION_TABLE *         pFunctionTable
    )
{
    DWORD nStatus;

    if (   (nMinVersionSupported > CLRES_VERSION_V1_00)
        || (nMaxVersionSupported < CLRES_VERSION_V1_00) )
    {
        nStatus = ERROR_REVISION_MISMATCH;
    } // if: version not supported
    else if ( lstrcmpiW( pszResourceType, DHCP_RESNAME ) != 0 )
    {
        nStatus = ERROR_CLUSTER_RESNAME_NOT_FOUND;
    } // if: resource type name not supported
    else
    {
        *pFunctionTable = &g_DhcpFunctionTable;
        nStatus = ERROR_SUCCESS;
    } // else: we support this type of resource

    return nStatus;

} //*** DhcpStartup()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpOpen
//
//  Description:
//      Open routine for DHCP Service resources.
//
//      Open the specified resource (create an instance of the resource).
//      Allocate all structures necessary to bring the specified resource
//      online.
//
//  Arguments:
//      pszResourceName [IN]
//          Supplies the name of the resource to open.
//
//      hkeyResourceKey [IN]
//                  Supplies handle to the resource's cluster database key.
//
//      hResourceHandle [IN]
//          A handle that is passed back to the Resource Monitor when the
//          SetResourceStatus or LogEvent method is called.  See the
//          description of the pfnSetResourceStatus and pfnLogEvent arguments
//          to the DhcpStartup routine.  This handle should never be
//          closed or used for any purpose other than passing it as an
//          argument back to the Resource Monitor in the SetResourceStatus or
//          LogEvent callbacks.
//
//  Return Value:
//      resid
//          RESID of opened resource.
//
//      NULL
//          Error occurred opening the resource.  Resource Monitor may call
//          GetLastError() to get more details on the error.
//
//--
/////////////////////////////////////////////////////////////////////////////
RESID WINAPI DhcpOpen(
    IN  LPCWSTR         pszResourceName,
    IN  HKEY            hkeyResourceKey,
    IN  RESOURCE_HANDLE hResourceHandle
    )
{
    DWORD           nStatus;
    RESID           resid = 0;
    HKEY            hkeyParameters = NULL;
    PDHCP_RESOURCE  pResourceEntry = NULL;
    DWORD           bSemaphoreAcquired = FALSE;

    // Loop to avoid goto's.
    do
    {
        //
        // Check if more than one resource of this type.
        //
        if ( WaitForSingleObject( g_hSingleInstanceSemaphoreDhcp, 0 ) == WAIT_TIMEOUT )
        {
            //
            // A version of this service is already running.
            //
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Service is already running.\n"
                );
            nStatus = ERROR_SERVICE_ALREADY_RUNNING;
            break;
        } // if: semaphore for resources of this type already already locked

        bSemaphoreAcquired = TRUE;

        if ( g_pSingleInstanceResourceDhcp != NULL )
        {
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Service resource info non-null!\n"
                );
            nStatus = ERROR_DUPLICATE_SERVICE_NAME;
            break;
        } // if: resource of this type already exists

        //
        // Get a global handle to the Service Control Manager (SCM).
        // There is no call to CloseSCManager(), since the only time we will
        // need to close this handle is if we are shutting down.
        //
        if ( g_schSCMHandle == NULL )
        {
            g_schSCMHandle = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
            if ( g_schSCMHandle == NULL )
            {
                nStatus = GetLastError();
                (g_pfnLogEvent)(
                    hResourceHandle,
                    LOG_ERROR,
                    L"Failed to open Service Control Manager. Error: %1!u!.\n",
                    nStatus
                    );
                break;
            } // if: error opening the Service Control Manager
        } // if: Service Control Manager not open yet

        //
        // Make sure the service has been stopped.
        //
        nStatus = ResUtilStopResourceService( DHCP_SVCNAME );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Failed to stop the '%1!ls!' service. Error: %2!u!.\n",
                DHCP_SVCNAME,
                nStatus
                );
            ClNetResLogSystemEvent1(
                LOG_CRITICAL,
                NETRES_RESOURCE_STOP_ERROR,
                nStatus,
                L"DHCP" );
        } // if: resource of this type already exists

        //
        // Open the Parameters registry key for this resource.
        //
        nStatus = ClusterRegOpenKey(
                        hkeyResourceKey,
                        L"Parameters",
                        KEY_ALL_ACCESS,
                        &hkeyParameters
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: Unable to open Parameters key. Error: %1!u!.\n",
                nStatus
                );
            break;
        } // if: error creating the Parameters key for the resource

        //
        // Allocate a resource entry.
        //
        pResourceEntry = static_cast< DHCP_RESOURCE * >(
            LocalAlloc( LMEM_FIXED, sizeof( DHCP_RESOURCE ) )
            );
        if ( pResourceEntry == NULL )
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: Unable to allocate resource entry structure. Error: %1!u!.\n",
                nStatus
                );
            break;
        } // if: error allocating memory for the resource

        //
        // Initialize the resource entry..
        //
        ZeroMemory( pResourceEntry, sizeof( DHCP_RESOURCE ) );

        pResourceEntry->resid = static_cast< RESID >( pResourceEntry ); // for validation
        pResourceEntry->hResourceHandle = hResourceHandle;
        pResourceEntry->hkeyParameters = hkeyParameters;
        pResourceEntry->state = ClusterResourceOffline;

        //
        // Save the name of the resource.
        //
        pResourceEntry->pszResourceName = static_cast< LPWSTR >(
            LocalAlloc( LMEM_FIXED, (lstrlenW( pszResourceName ) + 1) * sizeof( WCHAR ) )
            );
        if ( pResourceEntry->pszResourceName == NULL )
        {
            nStatus = GetLastError();
            break;
        } // if: error allocating memory for the name.
        lstrcpyW( pResourceEntry->pszResourceName, pszResourceName );

        //
        // Open the cluster.
        //
        pResourceEntry->hCluster = OpenCluster( NULL );
        if ( pResourceEntry->hCluster == NULL )
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: Unable to open the cluster. Error: %1!u!.\n",
                nStatus
                );
            break;
        } // if: error opening the cluster

        //
        // Open the resource.
        //
        pResourceEntry->hResource = OpenClusterResource(
                                        pResourceEntry->hCluster,
                                        pszResourceName
                                        );
        if ( pResourceEntry->hResource == NULL )
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                hResourceHandle,
                LOG_ERROR,
                L"Open: Unable to open the resource. Error: %1!u!.\n",
                nStatus
                );
            break;
        } // if: error opening the resource

        //
        // Configure registry key checkpoints.
        //
        nStatus = ConfigureRegistryCheckpoints(
                        pResourceEntry->hResource,
                        hResourceHandle,
                        g_pszRegKeysDhcp
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error configuring registry key checkpoints

        //
        // Configure crypto key checkpoints.
        //
        nStatus = ConfigureCryptoKeyCheckpoints(
                        pResourceEntry->hResource,
                        hResourceHandle,
                        g_pszCryptoKeysDhcp
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error configuring crypto key checkpoints

        //
        // Configure domestic crypto key checkpoints.
        //
        nStatus = ConfigureDomesticCryptoKeyCheckpoints(
                        pResourceEntry->hResource,
                        hResourceHandle,
                        g_pszDomesticCryptoKeysDhcp
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error configuring domestic crypto key checkpoints

        //
        // Startup for the resource.
        //
        // TODO: Add your resource startup code here.


        resid = static_cast< RESID >( pResourceEntry );

    } while ( 0 );


    if ( resid == 0 )
    {
        if ( hkeyParameters != NULL )
        {
            ClusterRegCloseKey( hkeyParameters );
        } // if: registry key was opened
        if ( pResourceEntry != NULL )
        {
            LocalFree( pResourceEntry->pszResourceName );
            LocalFree( pResourceEntry );
        } // if: resource entry allocated
    }

    if ( nStatus != ERROR_SUCCESS )
    {
        SetLastError( nStatus );

        if (bSemaphoreAcquired) { 
            ReleaseSemaphore( g_hSingleInstanceSemaphoreDhcp, 1 , NULL );
        }
    } else {
        g_pSingleInstanceResourceDhcp = pResourceEntry; // bug #274612
    } // if: error occurred

    return resid;

} //*** DhcpOpen()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpClose
//
//  Description:
//      Close routine for DHCP Service resources.
//
//      Close the specified resource and deallocate all structures, etc.,
//      allocated in the Open call.  If the resource is not in the offline
//      state, then the resource should be taken offline (by calling
//      Terminate) before the close operation is performed.
//
//  Arguments:
//      resid       [IN] Supplies the resource ID  of the resource to close.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI DhcpClose( IN RESID resid )
{
    PDHCP_RESOURCE  pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Dhcp: Close request for a nonexistent resource id %p\n",
            resid
            );
        return;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Close resource sanity check failed! resid = %1!u!.\n",
            resid
            );
        return;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n"
        );
#endif

    //
    // Close the Parameters key.
    //
    if ( pResourceEntry->hkeyParameters )
    {
        ClusterRegCloseKey( pResourceEntry->hkeyParameters );
    } // if: parameters key is open

    //
    // Clean up the semaphore if this is the single resource instance.
    //
    if ( pResourceEntry == g_pSingleInstanceResourceDhcp )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_INFORMATION,
            L"Close: Setting semaphore %1!ls!.\n",
            DHCP_SINGLE_INSTANCE_SEMAPHORE
            );
        g_pSingleInstanceResourceDhcp = NULL;
        ReleaseSemaphore( g_hSingleInstanceSemaphoreDhcp, 1 , NULL );
    } // if: this is the single resource instance

    //
    // Deallocate the resource entry.
    //

    // ADDPARAM: Add new propertiess here.
    LocalFree( pResourceEntry->props.pszDatabasePath );
    LocalFree( pResourceEntry->props.pszBackupPath );

    LocalFree( pResourceEntry->pszResourceName );
    LocalFree( pResourceEntry );

} //*** DhcpClose()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpOnline
//
//  Description:
//      Online routine for DHCP Service resources.
//
//      Bring the specified resource online (available for use).  The resource
//      DLL should attempt to arbitrate for the resource if it is present on
//      a shared medium, like a shared SCSI bus.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be brought online
//          (available for use).
//
//      phEventHandle [IN OUT]
//          Returns a signalable handle that is signaled when the resource DLL
//          detects a failure on the resource.  This argument is NULL on
//          input, and the resource DLL returns NULL if asynchronous
//          notification of failurs is not supported.  Otherwise this must be
//          the address of a handle that is signaled on resource failures.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful, and the resource is now online.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_RESOURCE_NOT_AVAILABLE
//          If the resource was arbitrated with some other systems and one of
//          the other systems won the arbitration.
//
//      ERROR_IO_PENDING
//          The request is pending.  A thread has been activated to process
//          the online request.  The thread that is processing the online
//          request will periodically report status by calling the
//          SetResourceStatus callback method until the resource is placed
//          into the ClusterResourceOnline state (or the resource monitor
//          decides to timeout the online request and Terminate the resource.
//          This pending timeout value is settable and has a default value of
//          3 minutes.).
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpOnline(
    IN      RESID       resid,
    IN OUT  PHANDLE     phEventHandle
    )
{
    PDHCP_RESOURCE  pResourceEntry;
    DWORD           nStatus;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Dhcp: Online request for a nonexistent resource id %p.\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Online service sanity check failed! resid = %1!u!.\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n"
        );

    //
    // Start the Online thread to perform the online operation.
    //
    pResourceEntry->state = ClusterResourceOffline;
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );
    nStatus = ClusWorkerCreate(
                &pResourceEntry->cwWorkerThread,
                reinterpret_cast< PWORKER_START_ROUTINE >( DhcpOnlineThread ),
                pResourceEntry
                );
    if ( nStatus != ERROR_SUCCESS )
    {
        pResourceEntry->state = ClusterResourceFailed;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Online: Unable to start thread. Error: %1!u!.\n",
            nStatus
            );
    } // if: error creating the worker thread
    else
    {
        nStatus = ERROR_IO_PENDING;
    } // if: worker thread created successfully

    return nStatus;

} //*** DhcpOnline()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpOnlineThread
//
//  Description:
//      Worker function which brings a resource online.
//      This function is executed in a separate thread.
//
//  Arguments:
//      pWorker [IN]
//          Supplies the worker thread structure.
//
//      pResourceEntry [IN]
//          A pointer to the DHCP_RESOURCE block for this resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpOnlineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PDHCP_RESOURCE  pResourceEntry
    )
{
    RESOURCE_STATUS         resourceStatus;
    DWORD                   nStatus = ERROR_SUCCESS;
    DWORD                   cbBytesNeeded;
    HKEY                    hkeyParamsKey = NULL;
    PVOID                   pvBindings = NULL;
    DWORD                   cbBindings;
    SERVICE_STATUS_PROCESS  ServiceStatus = { 0 };
    RESOURCE_EXIT_STATE     resExitState;
    DWORD                   nRetryCount = 1200; // 10 min max

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    // Loop to avoid goto's.
    do
    {
        //
        // Create the new environment with the simulated net name when the
        // services queries GetComputerName.
        //
        if ( ! ClusWorkerCheckTerminate( pWorker ) )
        {
            nStatus = ResUtilSetResourceServiceEnvironment(
                            DHCP_SVCNAME,
                            pResourceEntry->hResource,
                            g_pfnLogEvent,
                            pResourceEntry->hResourceHandle
                            );
            if ( nStatus != ERROR_SUCCESS )
            {
                break;
            } // if: error setting the environment for the service
        } // if: not terminating
        else
        {
            break;
        } // else: terminating

        //
        // Make sure the service is ready to be controlled by the cluster.
        //
        if ( ! ClusWorkerCheckTerminate( pWorker ) )
        {
            nStatus = ResUtilSetResourceServiceStartParameters(
                            DHCP_SVCNAME,
                            g_schSCMHandle,
                            &pResourceEntry->hService,
                            g_pfnLogEvent,
                            pResourceEntry->hResourceHandle
                            );
            if ( nStatus != ERROR_SUCCESS )
            {
                break;
            } // if:  error setting service start parameters
        } // if: not terminating
        else
        {
            break;
        } // else: terminating

        //
        // Perform resource-specific initialization before starting the service.
        //
        // TODO: Add code to initialize the resource before starting the service.

        //
        // Stop the service if it's running since we are about to change
        // its parameters.
        //
        nStatus = ResUtilStopResourceService( DHCP_SVCNAME );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OnlineThread: Failed to stop the '%1!ls!' service. Error %2!u!.\n",
                DHCP_SVCNAME,
                nStatus
                );
            ClNetResLogSystemEvent1(
                LOG_CRITICAL,
                NETRES_RESOURCE_STOP_ERROR,
                nStatus,
                L"DHCP" );
            break;
        } // if: error stopping the service

        //
        // Find IP Address bindings to give to DHCPServer.
        //
        nStatus =  DhcpBuildBindings(
                        pResourceEntry,
                        &pvBindings,
                        &cbBindings
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OnlineThread: Failed to get bindings. Error %1!u!.\n",
                nStatus
                );
            break;
        } // if: error building bindings

        //
        // Open the DHCPServer\Parameters key.
        //
        nStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        DHCP_PARAMS_REGKEY,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkeyParamsKey
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OnlineThread: Unable to open the DHCPServer Parameters key. Error %1!u!.\n",
                nStatus
                );
            break;
        } // if: error opening the DHCP Server Parameters key

        //
        // Write bindings to DHCPServer\Parameters\Bind.
        //
        nStatus = RegSetValueEx(
                        hkeyParamsKey,
                        DHCP_BIND_REGVALUE,
                        0,
                        REG_MULTI_SZ,
                        static_cast< PBYTE >( pvBindings ),
                        cbBindings
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"OnlineThread: Unable to set the DHCPServer Bind value in the system registry. Error %1!u!.\n",
                nStatus
                );
            break;
        } // if: error writing the bindings

        //
        // Read our properties.
        //
        nStatus = DhcpReadParametersToParameterBlock( pResourceEntry, TRUE /* bCheckForRequiredProperties */ );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error reading parameters

        //
        // Validate our properties.
        //
        nStatus = DhcpValidateParameters( pResourceEntry, &pResourceEntry->props );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error validating parameters

        //
        // Write cluster properties to the system registry.
        //
        nStatus = DhcpZapSystemRegistry( pResourceEntry, &pResourceEntry->props, hkeyParamsKey );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error zapping the DHCP registry

        //
        // Start the service.
        //
        if ( ! StartServiceW(
                        pResourceEntry->hService,
                        0,
                        NULL
                        ) )
        {
            nStatus = GetLastError();
            if ( nStatus != ERROR_SERVICE_ALREADY_RUNNING )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"OnlineThread: Failed to start the '%1!ls!' service. Error: %2!u!.\n",
                    DHCP_SVCNAME,
                    nStatus
                    );
                ClNetResLogSystemEvent1(
                    LOG_CRITICAL,
                    NETRES_RESOURCE_START_ERROR,
                    nStatus,
                    L"DHCP" );
                break;
            } // if: error other than service already running occurred
            else
            {
                nStatus = ERROR_SUCCESS;
            } // if: service is already running
        } // if: error starting the service

        //
        // Query the status of the service in a loop until it leaves
        // the pending state.
        //
        while ( ! ClusWorkerCheckTerminate( pWorker ) && ( nRetryCount-- != 0 ) )
        {
            //
            // Query the service status.
            //
            if ( ! QueryServiceStatusEx(
                        pResourceEntry->hService,
                        SC_STATUS_PROCESS_INFO,
                        reinterpret_cast< LPBYTE >( &ServiceStatus ),
                        sizeof( SERVICE_STATUS_PROCESS ),
                        &cbBytesNeeded
                        ) )
            {
                nStatus = GetLastError();
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"OnlineThread: Failed to query service status for the '%1!ls!' service. Error: %2!u!.\n",
                    DHCP_SVCNAME,
                    nStatus
                    );

                resourceStatus.ResourceState = ClusterResourceFailed;
                break;
            } // if: error querying service status

            //
            // If the service is in any pending state continue waiting, otherwise we are done.
            //
            if (    ServiceStatus.dwCurrentState == SERVICE_START_PENDING
                ||  ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING
                ||  ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING
                ||  ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING )
            {
                resourceStatus.ResourceState = ClusterResourceOnlinePending;
            } // if: service state is pending
            else
            {
                break;
            } // else: service state is not pending

            resourceStatus.CheckPoint++;

            //
            // Notify the Resource Monitor of our current state.
            //
            resExitState = static_cast< RESOURCE_EXIT_STATE >(
                (g_pfnSetResourceStatus)(
                                pResourceEntry->hResourceHandle,
                                &resourceStatus
                                ) );
            if ( resExitState == ResourceExitStateTerminate )
            {
                break;
            } // if: resource is being terminated

            //
            // Check again in 1/2 second.
            //
            Sleep( 500 );

        } // while: not terminating while querying the status of the service

        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error querying the status of the service

        //
        // Assume that we failed.
        //
        resourceStatus.ResourceState = ClusterResourceFailed;

        //
        // If we exited the loop before setting ServiceStatus, then return now.
        //
        if ( ClusWorkerCheckTerminate( pWorker ) || ( nRetryCount == (DWORD) -1 ) )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"DhcpOnlineThread: Asked to terminate or retry period expired...\n"
            );
            break;
        } // if: being terminated

        if ( ServiceStatus.dwCurrentState != SERVICE_RUNNING )
        {
            if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
                nStatus = ServiceStatus.dwServiceSpecificExitCode;
            } else {
                nStatus = ServiceStatus.dwWin32ExitCode;
            }

            ClNetResLogSystemEvent1(
                LOG_CRITICAL,
                NETRES_RESOURCE_START_ERROR,
                nStatus,
                L"DHCP" );
            (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"OnlineThread: The '%1!ls!' service failed during initialization. Error: %2!u!.\n",
                    DHCP_SVCNAME,
                    nStatus
                    );
            break;
        } // if: service not running when loop exited

        //
        // Set status to online and save process ID of the service.
        // This is used to enable us to terminate the resource more
        // effectively.
        //
        resourceStatus.ResourceState = ClusterResourceOnline;
        if ( ! (ServiceStatus.dwServiceFlags & SERVICE_RUNS_IN_SYSTEM_PROCESS) )
        {
            pResourceEntry->dwServicePid = ServiceStatus.dwProcessId;
        } // if: not running in the system process

        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_INFORMATION,
            L"The '%1!ls!' service is now on line.\n",
            DHCP_SVCNAME
            );

    } while ( 0 );

    //
    // Cleanup.
    //
    if ( nStatus != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"OnlineThread: Error %1!u! bringing resource online.\n",
            nStatus
            );
        if ( pResourceEntry->hService != NULL )
        {
            CloseServiceHandle( pResourceEntry->hService );
            pResourceEntry->hService = NULL;
        } // if: service handle was opened
    } // if: error occurred

    LocalFree( pvBindings );
    if ( hkeyParamsKey != NULL )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: DHCP Server Parameters key is open

    g_pfnSetResourceStatus( pResourceEntry->hResourceHandle, &resourceStatus );
    pResourceEntry->state = resourceStatus.ResourceState;

    return nStatus;

} //*** DhcpOnlineThread()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpBuildBindings
//
//  Description:
//      Build bindings for the DHCP resource.
//
//  Arguments:
//      pResourceEntry [IN]
//          A pointer to the DHCP_RESOURCE block for this resource.
//
//      ppOutBuffer [OUT]
//          Pointer in which to return a buffer containing the bindings.
//
//      pcbOutBufferSize [OUT]
//          Number of bytes returned in ppOutBuffer.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpBuildBindings(
    IN  PDHCP_RESOURCE  pResourceEntry,
    OUT PVOID *         ppOutBuffer,
    OUT LPDWORD         pcbOutBufferSize
    )
{
    DWORD       nStatus;
    LPWSTR *    ppszIpList = NULL;
    DWORD       cszAddrs;
    DWORD       idx;
    DWORD       cchAddr;
    DWORD       cbAddr;
    DWORD       cbAddrTotal = sizeof( WCHAR );
    LPWSTR      pszBuffer = NULL;
    LPWSTR      pszNextChar;

    //
    // Initialize out params to null.
    //
    *ppOutBuffer = NULL;
    *pcbOutBufferSize = 0;

    // Loop to avoid goto's.
    do
    {
        //
        // Get our list of provider IP Addresses and Subnet Masks.
        //
        nStatus = DhcpGetIPList( pResourceEntry, &ppszIpList, &cszAddrs );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error getting IP list

        //
        // Count the total number of bytes required for the binding list.
        //
        for ( idx = 0 ; idx < cszAddrs ; idx++ )
        {
            cbAddr = (lstrlenW( ppszIpList[ idx ] ) + 1) * sizeof( WCHAR );
            cbAddrTotal += cbAddr;
        } // for: each IP address in the list

        pszBuffer = static_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbAddrTotal ) );
        if ( pszBuffer == NULL )
        {
            nStatus = GetLastError();
            break;
        } // if: error allocating memory

        ZeroMemory( pszBuffer, cbAddrTotal );

        pszNextChar = pszBuffer;
        for ( idx = 0 ; idx < cszAddrs ; idx++ )
        {
            lstrcpyW( pszNextChar, ppszIpList[ idx ] );
            cchAddr = lstrlenW( pszNextChar );
            if ( (idx & 1) == 0 )
            {
                pszNextChar[ cchAddr ] = L' ';
            } // if: on IP address entry
            pszNextChar += cchAddr + 1;
            LocalFree( ppszIpList[ idx ] );
            ppszIpList[ idx ] = NULL;
        } // for: each address
    } while ( 0 );

    //
    // Cleanup.
    //
    if ( nStatus != ERROR_SUCCESS )
    {
        while ( cszAddrs > 0 )
        {
            LocalFree( ppszIpList[ --cszAddrs ] );
        } // while: more entries in the list
        cbAddrTotal = 0;
    } // if: error occurred
    LocalFree( ppszIpList );

    *ppOutBuffer = (PVOID) pszBuffer;
    *pcbOutBufferSize = cbAddrTotal; 

    return nStatus;

} //*** DhcpBuildBindings()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpGetIPList
//
//  Description:
//      Get the list of IP addresses by enumerating all IP Address resources
//      upon which we are dependent and extract the Address and SubnetMask
//      properties from each.
//
//  Arguments:
//      pResourceEntry [IN]
//          A pointer to the DHCP_RESOURCE block for this resource.
//
//      pppszIPList [OUT]
//          Pointer in which to return a pointer to an array of pointers to
//          IP address strings.
//
//      pcszAddrs [OUT]
//          Number of addresses returned in pppszIPList.  This will include
//          a combined total of all IP addresses and subnet masks, which means
//          it will be a multiple of 2.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpGetIPList(
    IN  PDHCP_RESOURCE  pResourceEntry,
    OUT LPWSTR **       pppszIPList,
    OUT LPDWORD         pcszIPAddrs
    )
{
    DWORD               nStatus = ERROR_SUCCESS;
    HRESOURCE           hresProvider = NULL;
    HKEY                hkeyProvider = NULL;
    HRESENUM            hresenum = NULL;
    DWORD               idx;
    DWORD               objectType;
    DWORD               cchProviderResName = 32;
    LPWSTR              pszProviderResName;
    LPWSTR              pszProviderResType = NULL;
    DWORD               cFreeEntries = 0;
    LPWSTR *            ppszIPList = NULL;
    DWORD               cszIPAddrs = 0;

    // Loop to avoid goto's.
    do
    {
        //
        // Allocate a buffer for the provider resource name.
        //
        pszProviderResName = static_cast< LPWSTR >(
            LocalAlloc(
                    LMEM_FIXED,
                    cchProviderResName * sizeof( WCHAR )
                    ) );
        if ( pszProviderResName == NULL )
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to allocate memory.\n"
                );
            break;
        } // if: error allocating memory for provider name

        //
        // Enumerate all resources upon which this resource is dependent.
        //
        hresenum = ClusterResourceOpenEnum(
                            pResourceEntry->hResource,
                            CLUSTER_RESOURCE_ENUM_DEPENDS
                            );
        if ( hresenum == NULL )
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to open enum handle for this resource, status %1!u!.\n",
                nStatus
                );
            break;
        } // if: error opening the enumeration

        //
        // Loop through each resource looking for IP Address resource.
        // For each IP Address resource found, extract the IP address and
        // subnet mask and add it to the list.
        //
        for ( idx = 0 ; ; idx++ )
        {
            //
            // Get the next resource upon which we are dependent.
            //
            nStatus = ClusterResourceEnum(
                            hresenum,
                            idx,
                            &objectType,
                            pszProviderResName,
                            &cchProviderResName
                            );
            if ( nStatus == ERROR_NO_MORE_ITEMS )
            {
                nStatus = ERROR_SUCCESS;
                break;
            } // if: no more items in the enumeration

            //
            // If our name buffer isn't big enough, allocate a bigger one
            // and try again.
            //
            if ( nStatus == ERROR_MORE_DATA )
            {
                //
                // Allocate a bigger name buffer.
                //
                LocalFree( pszProviderResName );
                cchProviderResName++; // add space for terminating NUL
                pszProviderResName = static_cast< LPWSTR >(
                    LocalAlloc(
                            LMEM_FIXED,
                            cchProviderResName * sizeof(WCHAR)
                            ) );
                if ( pszProviderResName == NULL )
                {
                    nStatus = GetLastError();
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_ERROR,
                        L"Unable to allocate memory.\n"
                        );
                    break;
                } // if: error allocating memory for provider name

                //
                // Try to get the resource name again.
                //
                nStatus = ClusterResourceEnum(
                                hresenum,
                                idx,
                                &objectType,
                                pszProviderResName,
                                &cchProviderResName
                                );

                // ASSERT( nStatus != ERROR_MORE_DATA );
            } // if: buffer was too small

            if ( nStatus != ERROR_SUCCESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Unable to enumerate resource dependencies, status %1!u!.\n",
                    nStatus
                    );
                break;
            } // if: error enumerating next item

            //
            // Open the resource
            //
            hresProvider = OpenClusterResource( pResourceEntry->hCluster, pszProviderResName );
            if ( hresProvider == NULL )
            {
                nStatus = GetLastError();
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Unable to open handle to provider resource %1!ls!, status %2!u!.\n",
                    pszProviderResName,
                    nStatus
                    );
                break;
            } // if: error opening the resource

            //
            // Figure out what type it is.
            //
            hkeyProvider = GetClusterResourceKey( hresProvider, KEY_READ );
            if ( hkeyProvider == NULL )
            {
                nStatus = GetLastError();
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Unable to open provider resource key, status %1!u!.\n",
                    nStatus
                    );
                break;
            } // if: error getting registry key

            //
            // Get the resource type name.
            //
            pszProviderResType = ResUtilGetSzValue( hkeyProvider, CLUSREG_NAME_RES_TYPE );
            if ( pszProviderResType == NULL )
            {
                nStatus = GetLastError();
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Unable to get provider resource type, status %1!u!.\n",
                    nStatus
                    );
                break;
            } // if: error getting value

            //
            // If this is an IP Address resource, get it's Address and
            // SubnetMask properties.
            //
            if ( lstrcmpiW( pszProviderResType, RESOURCE_TYPE_IP_ADDRESS ) == 0 )
            {
                LPWSTR  pszIPAddress;
                LPWSTR  pszSubnetMask;

                //
                // Get the IP Address and SubNet mask.
                // Always allocate two full entries at a time.
                //
                if ( cFreeEntries < 2 )
                {
                    PVOID pvBuffer;

                    //
                    // Allocate a bigger buffer.
                    //
                    pvBuffer = LocalAlloc(
                                    LMEM_FIXED,
                                    (cszIPAddrs + IP_BLOCK_SIZE) *
                                        sizeof( LPWSTR )
                                    );
                    if ( pvBuffer == NULL )
                    {
                        nStatus = ERROR_NOT_ENOUGH_MEMORY;
                        (g_pfnLogEvent)(
                            pResourceEntry->hResourceHandle,
                            LOG_ERROR,
                            L"Unable to allocate memory.\n"
                            );
                        break;
                    } // if: error allocating memory

                    //
                    // If there already was a list, copy it to the new buffer.
                    //
                    if ( ppszIPList != NULL )
                    {
                        CopyMemory(
                            pvBuffer,
                            ppszIPList,
                            cszIPAddrs * sizeof( LPWSTR )
                            );

                        LocalFree( ppszIPList );
                    } // if: list already existed

                    //
                    // We are now using the newly allocated buffer.
                    //
                    ppszIPList = static_cast< LPWSTR * >( pvBuffer );
                    cFreeEntries += IP_BLOCK_SIZE;
                } // if: # available entries below threshold

                //
                // Get the IP address and SubNet mask.
                //
                nStatus = DhcpGetIpAndSubnet(
                                hresProvider,
                                &pszIPAddress,
                                &pszSubnetMask
                                );
                if ( nStatus != ERROR_SUCCESS )
                {
                    break;
                } // if: error getting IP address and subnet mask
                ppszIPList[ cszIPAddrs ] = pszIPAddress;
                ppszIPList[ cszIPAddrs + 1 ] = pszSubnetMask;
                cszIPAddrs += 2;
                cFreeEntries -= 2;
            } // if: IP Address resource found

            CloseClusterResource( hresProvider );
            ClusterRegCloseKey( hkeyProvider );
            LocalFree( pszProviderResType );
            hresProvider = NULL;
            hkeyProvider = NULL;
            pszProviderResType = NULL;
        } // for: each dependency
    } while ( 0 );

    //
    // Cleanup.
    //
    LocalFree( pszProviderResName );
    LocalFree( pszProviderResType );
    if ( hkeyProvider != NULL )
    {
        ClusterRegCloseKey( hkeyProvider );
    } // if: provider resource key was opened
    if ( hresProvider != NULL )
    {
        CloseClusterResource( hresProvider );
    } // if: provider resource was opened
    if ( hresenum != NULL )
    {
        ClusterResourceCloseEnum( hresenum );
    } // if: resource enumeration was opened

    if ( nStatus != ERROR_SUCCESS )
    {
        while ( cszIPAddrs > 0 )
        {
            LocalFree( ppszIPList[ --cszIPAddrs ] );
        } // while: more entries in the list
        LocalFree( ppszIPList );
        ppszIPList = NULL;
    } // if: error occurred

    //
    // Return the list to the caller.
    //
    *pppszIPList = ppszIPList;
    *pcszIPAddrs = cszIPAddrs;

    return nStatus;

} //*** DhcpGetIPList()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpGetIpAndSubnet
//
//  Description:
//      Get the IP Address and Subnet Mask for the given IP Address resource.
//      Note that this will cause a deadlock if called from any of the
//      standard entry points (e.g. ResourceControl() or Online()).
//
//  Arguments:
//      hres [IN]
//          The Cluster resource handle for accessing the resource.
//
//      ppszIPAddress [OUT]
//          Returns the IP Address string.
//
//      ppszSubnetMask [OUT]
//          Returns the Subnet Mask.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      ERROR_INVALID_DATA
//          No properties available.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpGetIpAndSubnet(
    IN  HRESOURCE   hres,
    OUT LPWSTR *    ppszIPAddress,
    OUT LPWSTR *    ppszSubnetMask
    )
{
    DWORD       nStatus;
    DWORD       cbProps;
    PVOID       pvProps = NULL;

    *ppszIPAddress = NULL;
    *ppszSubnetMask = NULL;

    // Loop to avoid goto's.
    do
    {
        //
        // Get the size of the private properties from the resource.
        //
        nStatus = ClusterResourceControl(
                        hres,
                        NULL,
                        CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,
                        NULL,
                        0,
                        NULL,
                        0,
                        &cbProps
                        );
        if (    (nStatus != ERROR_SUCCESS)
            ||  (cbProps == 0) )
        {
            if ( nStatus == ERROR_SUCCESS )
            {
                nStatus = ERROR_INVALID_DATA;
            } // if: no properties available
            break;
        } // if: error getting size of properties or no properties available

        //
        // Allocate the property buffer.
        //
        pvProps = LocalAlloc( LMEM_FIXED, cbProps );
        if ( pvProps == NULL )
        {
            nStatus = GetLastError();
            break;
        } // if: error allocating memory

        //
        // Get the private properties from the resource.
        //
        nStatus = ClusterResourceControl(
                        hres,
                        NULL,
                        CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,
                        NULL,
                        0,
                        pvProps,
                        cbProps,
                        &cbProps
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error getting private properties

        //
        // Find the Address property.
        //
        nStatus = ResUtilFindSzProperty(
                            pvProps,
                            cbProps,
                            L"Address",
                            ppszIPAddress
                            );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error finding the Address property

        nStatus = ResUtilFindSzProperty(
                        pvProps,
                        cbProps,
                        L"SubnetMask",
                        ppszSubnetMask
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error finding the SubnetMask property
    } while ( 0 );

    //
    // Cleanup.
    //
    if ( nStatus != ERROR_SUCCESS )
    {
        LocalFree( *ppszIPAddress );
        LocalFree( *ppszSubnetMask );
    } // if: error occurred

    LocalFree( pvProps );

    return nStatus;

} //*** DhcpGetIpAndSubnet()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpOffline
//
//  Description:
//      Offline routine for DHCP Service resources.
//
//      Take the specified resource offline (unavailable for use).  Wait
//      for any cleanup operations to complete before returning.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be shutdown
//          gracefully.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation was successful, and the resource is now offline.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_RESOURCE_NOT_AVAILABLE
//          If the resource was arbitrated with some other systems and one of
//          the other systems won the arbitration.
//
//      ERROR_IO_PENDING
//          The request is still pending.  A thread has been activated to
//          process the offline request.  The thread that is processing the
//          offline request will periodically report status by calling the
//          SetResourceStatus callback method until the resource is placed
//          into the ClusterResourceOffline state (or the resource monitor
//          decides  to timeout the offline request and Terminate the
//          resource).
//
//      Win32 error code
//          The operation failed.  This will cause the Resource Monitor to
//          log an event and call the Terminate routine.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpOffline( IN RESID resid )
{
    PDHCP_RESOURCE  pResourceEntry;
    DWORD           nStatus;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Dhcp: Offline request for a nonexistent resource id %p\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Offline resource sanity check failed! resid = %1!u!.\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n"
        );

    //
    // Start the Offline thread to perform the offline operation.
    //
    pResourceEntry->state = ClusterResourceOfflinePending;
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );
    nStatus = ClusWorkerCreate(
                &pResourceEntry->cwWorkerThread,
                reinterpret_cast< PWORKER_START_ROUTINE >( DhcpOfflineThread ),
                pResourceEntry
                );
    if ( nStatus != ERROR_SUCCESS )
    {
        pResourceEntry->state = ClusterResourceFailed;
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Offline: Unable to start thread. Error: %1!u!.\n",
            nStatus
            );
    } // if: error creating the worker thread
    else
    {
        nStatus = ERROR_IO_PENDING;
    } // if: worker thread created successfully

    return nStatus;

} //*** DhcpOffline()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpOfflineThread
//
//  Description:
//      Worker function which takes a resource offline.
//      This function is executed in a separate thread.
//
//  Arguments:
//      pWorker [IN]
//          Supplies the worker thread structure.
//
//      pResourceEntry [IN]
//          A pointer to the DHCP_RESOURCE block for this resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The operation completed successfully.
//
//      Win32 error code
//          The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpOfflineThread(
    IN  PCLUS_WORKER    pWorker,
    IN  PDHCP_RESOURCE  pResourceEntry
    )
{
    RESOURCE_STATUS     resourceStatus;
    DWORD               nStatus = ERROR_SUCCESS;
    DWORD               nRetryTime = 300;   // 300 msec at a time
    DWORD               nRetryCount = 2000; // Try 10 min max
    BOOL                bDidStop = FALSE;
    SERVICE_STATUS      ServiceStatus;
    RESOURCE_EXIT_STATE resExitState;

    ResUtilInitializeResourceStatus( &resourceStatus );
    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.CheckPoint = 1;

    // Loop to avoid goto's.
    do
    {
        //
        // If the service has gone offline or was never brought online,
        // we're done.
        //
        if ( pResourceEntry->hService == NULL )
        {
            resourceStatus.ResourceState = ClusterResourceOffline;
            break;
        }

        //
        // Try to stop the service.  Wait for it to terminate as long
        // as we're not asked to terminate.
        //
        while ( ! ClusWorkerCheckTerminate( pWorker ) && ( nRetryCount-- != 0 ) )
        {
            //
            // Tell the Resource Monitor we are still working.
            //
            resourceStatus.ResourceState = ClusterResourceOfflinePending;
            resourceStatus.CheckPoint++;
            resExitState = static_cast< RESOURCE_EXIT_STATE >(
                g_pfnSetResourceStatus(
                                pResourceEntry->hResourceHandle,
                                &resourceStatus
                                ) );
            if ( resExitState == ResourceExitStateTerminate )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"OnlineThread: Asked to terminate by call to SetResourceStatus callback.\n"
                    );
                break;
            } // if: resource is being terminated

            resourceStatus.ResourceState = ClusterResourceFailed;

            //
            // Request that the service be stopped, or if we already did that,
            // request the current status of the service.
            //
            nStatus = (ControlService(
                            pResourceEntry->hService,
                            (bDidStop
                                ? SERVICE_CONTROL_INTERROGATE
                                : SERVICE_CONTROL_STOP),
                            &ServiceStatus
                            )
                        ? ERROR_SUCCESS
                        : GetLastError()
                        );

            if ( nStatus == ERROR_SUCCESS )
            {
                bDidStop = TRUE;

                if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED )
                {
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_INFORMATION,
                        L"OfflineThread: The '%1!ls!' service stopped.\n",
                        DHCP_SVCNAME
                        );

                    //
                    // Set the status.
                    //
                    resourceStatus.ResourceState = ClusterResourceOffline;
                    CloseServiceHandle( pResourceEntry->hService );
                    pResourceEntry->hService = NULL;
                    pResourceEntry->dwServicePid = 0;
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_INFORMATION,
                        L"OfflineThread: Service is now offline.\n"
                        );
                    break;
                } // if: current service state is STOPPED
            } // if: ControlService completed successfully

            else if (   ( nStatus == ERROR_EXCEPTION_IN_SERVICE )
                    ||  ( nStatus == ERROR_PROCESS_ABORTED )
                    ||  ( nStatus == ERROR_SERVICE_NOT_ACTIVE ) )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"OfflineThread: The '%1!ls!' service died or is not active any more; status = %2!u!.\n",
                    DHCP_SVCNAME,
                    nStatus
                    );

                //
                // Set the status.
                //
                resourceStatus.ResourceState = ClusterResourceOffline;
                CloseServiceHandle( pResourceEntry->hService );
                pResourceEntry->hService = NULL;
                pResourceEntry->dwServicePid = 0;
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"OfflineThread: Service is now offline.\n"
                    );
                break;
            } // else if: service stopped abnormally

            //
            // Handle the case in which SCM refuses to accept control
            // requests sine windows is shutting down.
            //
            if ( nStatus == ERROR_SHUTDOWN_IN_PROGRESS )
            {
                DWORD dwResourceState;

                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"OfflineThread: System shutting down. Attempting to terminate service process %1!u!...\n",
                    pResourceEntry->dwServicePid
                    );

                nStatus = ResUtilTerminateServiceProcessFromResDll(
                            pResourceEntry->dwServicePid,
                            TRUE,   // bOffline
                            &dwResourceState,
                            g_pfnLogEvent,
                            pResourceEntry->hResourceHandle
                            );
                if ( nStatus == ERROR_SUCCESS )
                {
                    CloseServiceHandle( pResourceEntry->hService );
                    pResourceEntry->hService = NULL;
                    pResourceEntry->dwServicePid = 0;
                    pResourceEntry->state = ClusterResourceOffline;
                } // if: process terminated successfully
                resourceStatus.ResourceState = (CLUSTER_RESOURCE_STATE) dwResourceState;
                break;
            } // if: Windows is shutting down

            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"OfflineThread: retrying...\n"
                );

            Sleep( nRetryTime );

        } // while: not asked to terminate
    } while ( 0 );

    g_pfnSetResourceStatus( pResourceEntry->hResourceHandle, &resourceStatus );
    pResourceEntry->state = resourceStatus.ResourceState;

    return nStatus;

} //*** DhcpOfflineThread()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpTerminate
//
//  Description:
//      Terminate routine for DHCP Service resources.
//
//      Take the specified resource offline immediately (the resource is
//      unavailable for use).
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID of the resource to be shutdown
//          ungracefully.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WINAPI DhcpTerminate( IN RESID resid )
{
    PDHCP_RESOURCE  pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Dhcp: Terminate request for a nonexistent resource id %p\n",
            resid
            );
        return;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Terminate resource sanity check failed! resid = %1!u!.\n",
            resid
            );
        return;
    } // if: invalid resource ID

    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n"
        );

    //
    // Kill off any pending threads.
    //
    ClusWorkerTerminate( &pResourceEntry->cwWorkerThread );

    if ( pResourceEntry->hService != NULL )
    {
        DWORD           nTotalRetryTime = 30*1000;  // Wait 30 secs for shutdown
        DWORD           nRetryTime = 300;           // 300 msec at a time
        DWORD           nStatus;
        BOOL            bDidStop = FALSE;
        SERVICE_STATUS  ServiceStatus;

        for (;;)
        {
            nStatus = (ControlService(
                            pResourceEntry->hService,
                            (bDidStop
                                ? SERVICE_CONTROL_INTERROGATE
                                : SERVICE_CONTROL_STOP),
                            &ServiceStatus
                            )
                        ? ERROR_SUCCESS
                        : GetLastError()
                        );

            if ( nStatus == ERROR_SUCCESS )
            {
                bDidStop = TRUE;

                if ( ServiceStatus.dwCurrentState == SERVICE_STOPPED )
                {
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_INFORMATION,
                        L"Terminate: The '%1!ls!' service stopped.\n",
                        DHCP_SVCNAME
                        );
                    break;
                } // if: current service state is STOPPED
            } // if: ControlService completed successfully

            //
            // Since SCM doesn't accept any control requests during Windows
            // shutdown, don't send any more control requests.  Just exit
            // from this loop and terminate the process by brute force.
            //
            if ( nStatus == ERROR_SHUTDOWN_IN_PROGRESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"Terminate: System shutdown in progress. Will try to terminate process by brute force...\n"
                    );
                break;
            } // if: Windows is shutting down

            if (    ( nStatus == ERROR_EXCEPTION_IN_SERVICE )
                ||  ( nStatus == ERROR_PROCESS_ABORTED )
                ||  ( nStatus == ERROR_SERVICE_NOT_ACTIVE ) )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_INFORMATION,
                    L"Terminate: Service died; status = %1!u!.\n",
                    nStatus
                    );
                break;
            } // if: service stopped abnormally

            if ( (nTotalRetryTime -= nRetryTime) <= 0 )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Terminate: Service did not stop; giving up.\n" );

                break;
            } // if: retried too many times

            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"Terminate: retrying...\n"
                );

            Sleep( nRetryTime );

        } // forever

        //
        // Declare the service offline.  It may not truly be offline, so
        // if there is a pid for this service, try and terminate that process.
        // Note that terminating a process doesnt terminate all the child
        // processes.
        //
        if ( pResourceEntry->dwServicePid != 0 )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_INFORMATION,
                L"Terminate: Attempting to terminate process with pid=%1!u!...\n",
                pResourceEntry->dwServicePid
                );
            ResUtilTerminateServiceProcessFromResDll(
                pResourceEntry->dwServicePid,
                FALSE,  // bOffline
                NULL,   // pdwResourceState
                g_pfnLogEvent,
                pResourceEntry->hResourceHandle
                );
        } // if: service process ID available

        CloseServiceHandle( pResourceEntry->hService );
        pResourceEntry->hService = NULL;
        pResourceEntry->dwServicePid = 0;

    } // if: service was started

    pResourceEntry->state = ClusterResourceOffline;

} //*** DhcpTerminate()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpLooksAlive
//
//  Description:
//      LooksAlive routine for DHCP Service resources.
//
//      Perform a quick check to determine if the specified resource is
//      probably online (available for use).  This call should not block for
//      more than 300 ms, preferably less than 50 ms.
//
//  Arguments:
//      resid   [IN] Supplies the resource ID for the resource to be polled.
//
//  Return Value:
//      TRUE
//          The specified resource is probably online and available for use.
//
//      FALSE
//          The specified resource is not functioning normally.  The IsAlive
//          function will be called to perform a more thorough check.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DhcpLooksAlive( IN RESID resid )
{
    PDHCP_RESOURCE  pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Dhcp: LooksAlive request for a nonexistent resource id %p\n",
            resid
            );
        return FALSE;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"LooksAlive sanity check failed! resid = %1!u!.\n",
            resid
            );
        return FALSE;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n"
        );
#endif

    // TODO: LooksAlive code

    // NOTE: LooksAlive should be a quick check to see if the resource is
    // available or not, whereas IsAlive should be a thorough check.  If
    // there are no differences between a quick check and a thorough check,
    // IsAlive can be called for LooksAlive, as it is below.  However, if there
    // are differences, replace the call to IsAlive below with your quick
    // check code.

    //
    // Check to see if the resource is alive.
    //
    return DhcpCheckIsAlive( pResourceEntry, FALSE /* bFullCheck */ );

} //*** DhcpLooksAlive()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpIsAlive
//
//  Description:
//      IsAlive routine for DHCP Service resources.
//
//      Perform a thorough check to determine if the specified resource is
//      online (available for use).  This call should not block for more
//      more than 300 ms, preferably less than 50 ms.  If it must block for
//      longer than this, create a separate thread dedicated to polling for
//      this information and have this routine return the status of the last
//      poll performed.
//
//  Arguments:
//      resid   [IN] Supplies the resource ID for the resource to be polled.
//
//  Return Value:
//      TRUE
//          The specified resource is online and functioning normally.
//
//      FALSE
//          The specified resource is not functioning normally.  The resource
//          will be terminated and then Online will be called.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DhcpIsAlive( IN RESID resid )
{
    PDHCP_RESOURCE  pResourceEntry;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Dhcp: IsAlive request for a nonexistent resource id %p\n",
            resid
            );
        return FALSE;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! resid = %1!u!.\n",
            resid
            );
        return FALSE;
    } // if: invalid resource ID

#ifdef LOG_VERBOSE
    (g_pfnLogEvent)(
        pResourceEntry->hResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n"
        );
#endif

    //
    // Check to see if the resource is alive.
    //
    return DhcpCheckIsAlive( pResourceEntry, TRUE /* bFullCheck */ );

} //** DhcpIsAlive()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpCheckIsAlive
//
//  Description:
//      Check to see if the resource is alive for DHCP Service
//      resources.
//
//  Arguments:
//      pResourceEntry  [IN]
//          Supplies the resource entry for the resource to polled.
//
//      bFullCheck [IN]
//          TRUE = Perform a full check.
//          FALSE = Perform a cursory check.
//
//  Return Value:
//      TRUE    The specified resource is online and functioning normally.
//      FALSE   The specified resource is not functioning normally.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL DhcpCheckIsAlive(
    IN PDHCP_RESOURCE   pResourceEntry,
    IN BOOL             bFullCheck
    )
{
    BOOL    bIsAlive = TRUE;
    DWORD   nStatus;

    // Loop to avoid goto's.
    do
    {
        //
        // Check to see if the resource is alive.
        //
        nStatus = ResUtilVerifyService( pResourceEntry->hService );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"CheckIsAlive: Verification of the '%1' service failed. Error: %2!u!.\n",
                DHCP_SVCNAME,
                nStatus
                );
            bIsAlive = FALSE;
            break;
        } // if: error verifying service

        if ( bFullCheck )
        {
            // TODO: Add code to perform a full check.
        } // if: performing a full check
    } while ( 0 );

    return bIsAlive;

} //*** DhcpCheckIsAlive()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpResourceControl
//
//  Description:
//      ResourceControl routine for DHCP Service resources.
//
//      Perform the control request specified by nControlCode on the specified
//      resource.
//
//  Arguments:
//      resid [IN]
//          Supplies the resource ID for the specific resource.
//
//      nControlCode [IN]
//          Supplies the control code that defines the action to be performed.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbInBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_RESOURCE_NOT_FOUND
//          Resource ID is not valid.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      ERROR_INVALID_FUNCTION
//          The requested control code is not supported.  In some cases,
//          this allows the cluster software to perform the work.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpResourceControl(
    IN  RESID   resid,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    DWORD           nStatus;
    PDHCP_RESOURCE  pResourceEntry;
    DWORD           cbRequired = 0;

    //
    // Verify we have a valid resource ID.
    //

    pResourceEntry = static_cast< PDHCP_RESOURCE >( resid );

    if ( pResourceEntry == NULL )
    {
        DBG_PRINT(
            "Dhcp: ResourceControl request for a nonexistent resource id %p\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: NULL resource ID

    if ( pResourceEntry->resid != resid )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"ResourceControl sanity check failed! resid = %1!u!.\n",
            resid
            );
        return ERROR_RESOURCE_NOT_FOUND;
    } // if: invalid resource ID

    switch ( nControlCode )
    {
        case CLUSCTL_RESOURCE_UNKNOWN:
            *pcbBytesReturned = 0;
            nStatus = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTY_FMTS:
            nStatus = ResUtilGetPropertyFormats(
                                DhcpResourcePrivateProperties,
                                static_cast< LPWSTR> (pOutBuffer),
                                cbOutBufferSize,
                                pcbBytesReturned,
                                &cbRequired );
            if ( nStatus == ERROR_MORE_DATA ) {
                *pcbBytesReturned = cbRequired;
            }
            break;


        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
            nStatus = ResUtilEnumProperties(
                            DhcpResourcePrivateProperties,
                            static_cast< LPWSTR >( pOutBuffer ),
                            cbOutBufferSize,
                            pcbBytesReturned,
                            &cbRequired
                            );
            if ( nStatus == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            } // if: output buffer is too small
            break;

        case CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES:
            nStatus = DhcpGetPrivateResProperties(
                            pResourceEntry,
                            pOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;

        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            nStatus = DhcpValidatePrivateResProperties(
                            pResourceEntry,
                            pInBuffer,
                            cbInBufferSize,
                            NULL
                            );
            break;

        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
            nStatus = DhcpSetPrivateResProperties(
                            pResourceEntry,
                            pInBuffer,
                            cbInBufferSize
                            );
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            nStatus = DhcpGetRequiredDependencies(
                            pOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;

        case CLUSCTL_RESOURCE_DELETE:
            nStatus = DhcpDeleteResourceHandler( pResourceEntry );
            break;

        case CLUSCTL_RESOURCE_SET_NAME:
            nStatus = DhcpSetNameHandler(
                            pResourceEntry,
                            static_cast< LPWSTR >( pInBuffer )
                            );
            break;

        case CLUSCTL_RESOURCE_GET_CHARACTERISTICS:
        case CLUSCTL_RESOURCE_GET_CLASS_INFO:
        case CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO:
        case CLUSCTL_RESOURCE_STORAGE_IS_PATH_VALID:
        case CLUSCTL_RESOURCE_INSTALL_NODE:
        case CLUSCTL_RESOURCE_EVICT_NODE:
        case CLUSCTL_RESOURCE_ADD_DEPENDENCY:
        case CLUSCTL_RESOURCE_REMOVE_DEPENDENCY:
        case CLUSCTL_RESOURCE_ADD_OWNER:
        case CLUSCTL_RESOURCE_REMOVE_OWNER:
        case CLUSCTL_RESOURCE_CLUSTER_NAME_CHANGED:
        case CLUSCTL_RESOURCE_CLUSTER_VERSION_CHANGED:
        default:
            nStatus = ERROR_INVALID_FUNCTION;
            break;
    } // switch: nControlCode

    return nStatus;

} //*** DhcpResourceControl()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpResourceTypeControl
//
//  Description:
//      ResourceTypeControl routine for DHCP Service resources.
//
//      Perform the control request specified by nControlCode.
//
//  Arguments:
//      pszResourceTypeName [IN]
//          Supplies the name of the resource type.
//
//      nControlCode [IN]
//          Supplies the control code that defines the action to be performed.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbInBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      ERROR_INVALID_FUNCTION
//          The requested control code is not supported.  In some cases,
//          this allows the cluster software to perform the work.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DhcpResourceTypeControl(
    IN  LPCWSTR pszResourceTypeName,
    IN  DWORD   nControlCode,
    IN  PVOID   pInBuffer,
    IN  DWORD   cbInBufferSize,
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    DWORD   nStatus;
    DWORD   cbRequired = 0;

    switch ( nControlCode )
    {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
            *pcbBytesReturned = 0;
            nStatus = ERROR_SUCCESS;
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_RESOURCE_PROPERTY_FMTS:
            nStatus = ResUtilGetPropertyFormats(
                                    DhcpResourcePrivateProperties,
                                    static_cast< LPWSTR> (pOutBuffer),
                                    cbOutBufferSize,
                                    pcbBytesReturned,
                                    &cbRequired );
            if ( nStatus == ERROR_MORE_DATA ) {
                *pcbBytesReturned = cbRequired;
            }
            break;

        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
            nStatus = ResUtilEnumProperties(
                            DhcpResourcePrivateProperties,
                            static_cast< LPWSTR >( pOutBuffer ),
                            cbOutBufferSize,
                            pcbBytesReturned,
                            &cbRequired
                            );
            if ( nStatus == ERROR_MORE_DATA )
            {
                *pcbBytesReturned = cbRequired;
            } // if: output buffer is too small
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            nStatus = DhcpGetRequiredDependencies(
                            pOutBuffer,
                            cbOutBufferSize,
                            pcbBytesReturned
                            );
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS:
        case CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO:
        case CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS:
        case CLUSCTL_RESOURCE_TYPE_INSTALL_NODE:
        case CLUSCTL_RESOURCE_TYPE_EVICT_NODE:
        default:
            nStatus = ERROR_INVALID_FUNCTION;
            break;
    } // switch: nControlCode

    return nStatus;

} //*** DhcpResourceTypeControl()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpGetRequiredDependencies
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES control
//      function for resources of type DHCP Service.
//
//  Arguments:
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_MORE_DATA
//          The output buffer is too small to return the data.
//          pcbBytesReturned contains the required size.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpGetRequiredDependencies(
    OUT PVOID   pOutBuffer,
    IN  DWORD   cbOutBufferSize,
    OUT LPDWORD pcbBytesReturned
    )
{
    // TODO: Specify your resource's required dependencies here.
    //   The default is that the resource requires a dependency on a
    //   storage class resource (e.g. Physical Disk) and an IP Address
    //   resource.
    struct DEP_DATA
    {
        CLUSPROP_RESOURCE_CLASS rcStorage;
        CLUSPROP_SZ_DECLARE( ipaddrEntry, sizeof( RESOURCE_TYPE_IP_ADDRESS ) / sizeof( WCHAR ) );
        CLUSPROP_SZ_DECLARE( netnameEntry, sizeof( RESOURCE_TYPE_NETWORK_NAME ) / sizeof( WCHAR ) );
        CLUSPROP_SYNTAX         endmark;
    };
    DEP_DATA *  pdepdata = static_cast< DEP_DATA * >( pOutBuffer );
    DWORD       nStatus;

    *pcbBytesReturned = sizeof( DEP_DATA );
    if ( cbOutBufferSize < sizeof( DEP_DATA ) )
    {
        if ( pOutBuffer == NULL )
        {
            nStatus = ERROR_SUCCESS;
        } // if: no buffer specified
        else
        {
            nStatus = ERROR_MORE_DATA;
        } // if: buffer specified
    } // if: output buffer is too small
    else
    {
        ZeroMemory( pdepdata, sizeof( DEP_DATA ) );

        //
        // Add the Storage class entry.
        //
        pdepdata->rcStorage.Syntax.dw = CLUSPROP_SYNTAX_RESCLASS;
        pdepdata->rcStorage.cbLength = sizeof( pdepdata->rcStorage.rc );
        pdepdata->rcStorage.rc = CLUS_RESCLASS_STORAGE;

        //
        // Add the IP Address entry.
        //
        pdepdata->ipaddrEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->ipaddrEntry.cbLength = sizeof( RESOURCE_TYPE_IP_ADDRESS );
        lstrcpyW( pdepdata->ipaddrEntry.sz, RESOURCE_TYPE_IP_ADDRESS );

        //
        // Add the Network Name entry.
        //
        pdepdata->netnameEntry.Syntax.dw = CLUSPROP_SYNTAX_NAME;
        pdepdata->netnameEntry.cbLength = sizeof( RESOURCE_TYPE_NETWORK_NAME );
        lstrcpyW( pdepdata->netnameEntry.sz, RESOURCE_TYPE_NETWORK_NAME );

        //
        // Add the endmark.
        //
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;

        nStatus = ERROR_SUCCESS;
    } // else: output buffer is large enough

    return nStatus;

} //*** DhcpGetRequiredDependencies()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpReadParametersToParameterBlock
//
//  Description:
//      Reads all the parameters for a specied DHCP resource.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      bCheckForRequiredProperties [IN]
//          Determines whether an error should be generated if a required
//          property hasn't been specified.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpReadParametersToParameterBlock(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      BOOL            bCheckForRequiredProperties
    )
{
    DWORD       nStatus;
    LPWSTR      pszNameOfPropInError;

    //
    // Read our parameters.
    //
    nStatus = ResUtilGetPropertiesToParameterBlock(
                    pResourceEntry->hkeyParameters,
                    DhcpResourcePrivateProperties,
                    reinterpret_cast< LPBYTE >( &pResourceEntry->props ),
                    bCheckForRequiredProperties,
                    &pszNameOfPropInError
                    );
    if ( nStatus != ERROR_SUCCESS )
    {
        (g_pfnLogEvent)(
            pResourceEntry->hResourceHandle,
            LOG_ERROR,
            L"Unable to read the '%1!ls!' property. Error: %2!u!.\n",
            (pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
            nStatus
            );
    } // if: error getting properties

    return nStatus;

} //*** DhcpReadParametersToParameterBlock


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpGetPrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES control
//      function for resources of type DHCP Service.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pOutBuffer [OUT]
//          Supplies a pointer to the output buffer to be filled in.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the available space pointed to by
//          pOutBuffer.
//
//      pcbBytesReturned [OUT]
//          Returns the number of bytes of pOutBuffer actually filled in by
//          the resource.  If pOutBuffer is too small, pcbBytesReturned
//          contains the total number of bytes for the operation to succeed.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpGetPrivateResProperties(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    OUT     PVOID           pOutBuffer,
    IN      DWORD           cbOutBufferSize,
    OUT     LPDWORD         pcbBytesReturned
    )
{
    DWORD   nStatus;
    DWORD   nRetStatus = ERROR_SUCCESS;
    DWORD   cbRequired = 0;
    DWORD   cbLocalOutBufferSize = cbOutBufferSize;

    do {
        //
        // Read our parameters.
        //
        nStatus = DhcpReadParametersToParameterBlock(
                            pResourceEntry,
                            FALSE /* bCheckForRequiredProperties */
                            );
        if ( nStatus != ERROR_SUCCESS )
        {
            nRetStatus = nStatus;
            break;
        } // if: error reading parameters

        //
        // If the properties aren't set yet, retrieve the values from
        // the system registry.
        //
        nStatus = DhcpGetDefaultPropertyValues( pResourceEntry, &pResourceEntry->props );
        if ( nStatus != ERROR_SUCCESS )
        {
            nRetStatus = nStatus;
            break;
        } // if: error getting default properties

        //
        // Construct a property list from the parameter block.
        //
        nStatus = ResUtilPropertyListFromParameterBlock(
                        DhcpResourcePrivateProperties,
                        pOutBuffer,
                        &cbLocalOutBufferSize,
                        reinterpret_cast< const LPBYTE >( &pResourceEntry->props ),
                        pcbBytesReturned,
                        &cbRequired
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            nRetStatus = nStatus;
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Error constructing property list from parameter block. Error: %1!u!.\n",
                nStatus
                );
            //
            // Don't exit the loop if buffer is too small.
            //
            if ( nStatus != ERROR_MORE_DATA )
            {
                break;
            } // if: buffer is too small
        } // if: error getting properties

        //
        // Add unknown properties.
        //
        nStatus = ResUtilAddUnknownProperties(
                        pResourceEntry->hkeyParameters,
                        DhcpResourcePrivateProperties,
                        pOutBuffer,
                        cbOutBufferSize,
                        pcbBytesReturned,
                        &cbRequired
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            nRetStatus = nStatus;
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Error adding unknown properties to the property list. Error: %1!u!.\n",
                nStatus
                );
            break;
        } // if: error adding unknown properties

    } while ( 0 );

    if ( nRetStatus == ERROR_MORE_DATA )
    {
        *pcbBytesReturned = cbRequired;
    } // if: output buffer is too small

    return nRetStatus;

} //*** DhcpGetPrivateResProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpValidatePrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES control
//      function for resources of type DHCP Service.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//      pProps [OUT]
//          Supplies the parameter block to fill in (optional).
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_NOT_ENOUGH_MEMORY
//          An error occurred allocating memory.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpValidatePrivateResProperties(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      PVOID           pInBuffer,
    IN      DWORD           cbInBufferSize,
    OUT     PDHCP_PROPS     pProps
    )
{
    DWORD       nStatus = ERROR_SUCCESS;
    DHCP_PROPS  propsCurrent;
    DHCP_PROPS  propsNew;
    PDHCP_PROPS pLocalProps = NULL;
    LPWSTR      pszNameOfPropInError;
    BOOL        bRetrievedProps = FALSE;

    // Loop to avoid goto's.
    do
    {
        //
        // Check if there is input data.
        //
        if (    (pInBuffer == NULL)
            ||  (cbInBufferSize < sizeof( DWORD )) )
        {
            nStatus = ERROR_INVALID_DATA;
            break;
        } // if: no input buffer or input buffer not big enough to contain property list

        //
        // Retrieve the current set of private properties from the
        // cluster database.
        //
        ZeroMemory( &propsCurrent, sizeof( propsCurrent ) );

        nStatus = ResUtilGetPropertiesToParameterBlock(
                     pResourceEntry->hkeyParameters,
                     DhcpResourcePrivateProperties,
                     reinterpret_cast< LPBYTE >( &propsCurrent ),
                     FALSE, /*CheckForRequiredProperties*/
                     &pszNameOfPropInError
                     );

        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to read the '%1!ls!' property. Error: %2!u!.\n",
                (pszNameOfPropInError == NULL ? L"" : pszNameOfPropInError),
                nStatus
                );
            break;
        } // if: error getting properties
        bRetrievedProps = TRUE;

        //
        // Duplicate the resource parameter block.
        //
        if ( pProps == NULL )
        {
            pLocalProps = &propsNew;
        } // if: no parameter block passed in
        else
        {
            pLocalProps = pProps;
        } // else: parameter block passed in
        ZeroMemory( pLocalProps, sizeof( DHCP_PROPS ) );
        nStatus = ResUtilDupParameterBlock(
                        reinterpret_cast< LPBYTE >( pLocalProps ),
                        reinterpret_cast< LPBYTE >( &propsCurrent ),
                        DhcpResourcePrivateProperties
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error duplicating the parameter block

        //
        // Parse and validate the properties.
        //
        nStatus = ResUtilVerifyPropertyTable(
                        DhcpResourcePrivateProperties,
                        NULL,
                        TRUE, // AllowUnknownProperties
                        pInBuffer,
                        cbInBufferSize,
                        reinterpret_cast< LPBYTE >( pLocalProps )
                        );
        if ( nStatus == ERROR_SUCCESS )
        {
            //
            // Validate the property values.
            //
            nStatus = DhcpValidateParameters( pResourceEntry, pLocalProps );
            if ( nStatus != ERROR_SUCCESS )
            {
                break;
            } // if: error validating parameters
        } // if: property list validated successfully
    } while ( 0 );

    //
    // Cleanup our parameter block.
    //
    if (    (pLocalProps == &propsNew)
        ||  (   (nStatus != ERROR_SUCCESS)
            &&  (pLocalProps != NULL)
            )
        )
    {
        ResUtilFreeParameterBlock(
            reinterpret_cast< LPBYTE >( pLocalProps ),
            reinterpret_cast< LPBYTE >( &propsCurrent ),
            DhcpResourcePrivateProperties
            );
    } // if: we duplicated the parameter block

    if ( bRetrievedProps )
    {
        ResUtilFreeParameterBlock(
            reinterpret_cast< LPBYTE >( &propsCurrent ),
            NULL,
            DhcpResourcePrivateProperties
            );
    } // if: properties were retrieved

    return nStatus;

} // DhcpValidatePrivateResProperties


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpValidateParameters
//
//  Description:
//      Validate the parameters of a DHCP Service resource.
//
//  Arguments:
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//      pProps [IN]
//          Supplies the parameter block to validate.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_BAD_PATHNAME
//          Invalid path specified.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpValidateParameters(
    IN  PDHCP_RESOURCE  pResourceEntry,
    IN  PDHCP_PROPS     pProps
    )
{
    DWORD   nStatus;

    do {
        //
        // Verify that the service is installed.
        //
        nStatus = ResUtilVerifyResourceService( DHCP_SVCNAME );
        if (    ( nStatus != ERROR_SUCCESS )
            &&  ( nStatus != ERROR_SERVICE_NOT_ACTIVE )
            )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Error verifying the '%1!ls!' service. Error: %2!u!.\n",
                DHCP_SVCNAME,
                nStatus
                );
            break;
        } // if: error verifying service
        else
        {
            nStatus = ERROR_SUCCESS;
        } // else: service verified successfully

        //
        // Validate the DatabasePath.
        //
        if (    ( pProps->pszDatabasePath == NULL )
            ||  ( *pProps->pszDatabasePath == L'\0' )
            )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Database path property must be specified: '%1!ls!'.\n",
                pProps->pszDatabasePath
                );
            nStatus = ERROR_INVALID_PARAMETER;
            break;
        } // if: no database path specified

        //
        // Path must not begin with %SystemRoot% and must be of valid form.
        //
        if (    ( _wcsnicmp( pProps->pszDatabasePath, L"%SystemRoot%", (sizeof( L"%SystemRoot%" ) / sizeof( WCHAR )) -1 /*NULL*/) == 0 )
            ||  ! ResUtilIsPathValid( pProps->pszDatabasePath )
            )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Database path property is invalid: '%1!ls!'.\n",
                pProps->pszDatabasePath
                );
            nStatus = ERROR_BAD_PATHNAME;
            break;
        } // if: database path is malformed

        //
        // Validate the LogFilePath.
        //
        if (    ( pProps->pszLogFilePath == NULL )
            ||  ( *pProps->pszLogFilePath == L'\0' )
            )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Log file path must be specified: '%1!ls!'.\n",
                pProps->pszBackupPath
                );
            nStatus = ERROR_INVALID_PARAMETER;
            break;
        } // if: no log file path specified

        //
        // Path must not begin with %SystemRoot% and must be of valid form.
        //
        if (    ( _wcsnicmp( pProps->pszLogFilePath, L"%SystemRoot%", (sizeof( L"%SystemRoot%" ) / sizeof( WCHAR )) - 1 /*NULL*/) == 0 )
            ||  ! ResUtilIsPathValid( pProps->pszLogFilePath )
            )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Log file path property is invalid: '%1!ls!'.\n",
                pProps->pszLogFilePath
                );
            nStatus = ERROR_BAD_PATHNAME;
            break;
        } // if: log file path is malformed

        //
        // Validate the BackupPath.
        //
        if (    ( pProps->pszBackupPath == NULL )
            ||  ( *pProps->pszBackupPath == L'\0' )
            )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Backup database path must be specified: '%1!ls!'.\n",
                pProps->pszBackupPath
                );
            nStatus = ERROR_INVALID_PARAMETER;
            break;
        } // if: no backup path specified

        //
        // Path must not begin with %SystemRoot% and must be of valid form.
        //
        if (    ( _wcsnicmp( pProps->pszBackupPath, L"%SystemRoot%", (sizeof( L"%SystemRoot%" ) / sizeof( WCHAR )) - 1 /*NULL*/) == 0 )
            ||  ! ResUtilIsPathValid( pProps->pszBackupPath )
            )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Backup database path property is invalid: '%1!ls!'.\n",
                pProps->pszBackupPath
                );
            nStatus = ERROR_BAD_PATHNAME;
            break;
        } // if: backup path is malformed

    } while ( 0 );

    return nStatus;

} //*** DhcpValidateParameters()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpSetPrivateResProperties
//
//  Description:
//      Processes the CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES control
//      function for resources of type DHCP Service.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pInBuffer [IN]
//          Supplies a pointer to a buffer containing input data.
//
//      cbOutBufferSize [IN]
//          Supplies the size, in bytes, of the data pointed to by pInBuffer.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      ERROR_INVALID_PARAMETER
//          The data is formatted incorrectly.
//
//      ERROR_NOT_ENOUGH_MEMORY
//          An error occurred allocating memory.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpSetPrivateResProperties(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      PVOID           pInBuffer,
    IN      DWORD           cbInBufferSize
    )
{
    DWORD       nStatus = ERROR_SUCCESS;
    LPWSTR      pszExpandedPath = NULL;
    DHCP_PROPS  props;

    ZeroMemory( &props, sizeof( props ) );

    do
    {
        //
        // Parse the properties so they can be validated together.
        // This routine does individual property validation.
        //
        nStatus = DhcpValidatePrivateResProperties( pResourceEntry, pInBuffer, cbInBufferSize, &props );
        if ( nStatus != ERROR_SUCCESS )
        {
            return nStatus;
        } // if: error validating properties

        //
        // Expand any environment variables in the database path.
        //
        pszExpandedPath = ResUtilExpandEnvironmentStrings( props.pszDatabasePath );
        if ( pszExpandedPath == NULL )
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Error expanding the database path '%1!ls!'. Error: %2!u!.\n",
                props.pszDatabasePath,
                nStatus
                );
            break;
        } // if: error expanding database path

        //
        // Create the database directory.
        //
        nStatus = ResUtilCreateDirectoryTree( pszExpandedPath );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Error creating the database path directory '%1!ls!'. Error: %2!u!.\n",
                pszExpandedPath,
                nStatus
                );
        } // if: error creating the database directory

        LocalFree( pszExpandedPath );

        //
        // Expand any environment variables in the log file path.
        //
        pszExpandedPath = ResUtilExpandEnvironmentStrings( props.pszLogFilePath );
        if ( pszExpandedPath == NULL )
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Error expanding the log file path '%1!ls!'. Error: %2!u!.\n",
                props.pszLogFilePath,
                nStatus
                );
            break;
        } // if: error expanding log file path

        //
        // Create the log file path directory.
        //
        nStatus = ResUtilCreateDirectoryTree( pszExpandedPath );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Error creating the log file path directory '%1!ls!'. Error: %2!u!.\n",
                pszExpandedPath,
                nStatus
                );
        } // if: error creating the log file path directory

        LocalFree( pszExpandedPath );

        //
        // Expand any environment variables in the backup database path.
        //
        pszExpandedPath = ResUtilExpandEnvironmentStrings( props.pszBackupPath );
        if ( pszExpandedPath == NULL ) {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Error expanding the backup database path '%1!ls!'. Error: %2!u!.\n",
                props.pszBackupPath,
                nStatus
                );
            break;
        } // if: error expanding backup database path

        //
        // Create the backup directory.
        //
        nStatus = ResUtilCreateDirectoryTree( pszExpandedPath );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Error creating the backup database path directory '%1!ls!'. Error: %2!u!.\n",
                pszExpandedPath,
                nStatus
                );
        } // if: error creating the backup database directory

        LocalFree( pszExpandedPath );

        //
        // Set the entries in the system registry.
        //
        nStatus = DhcpZapSystemRegistry( pResourceEntry, &props, NULL );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error zapping the registry

        //
        // Save the property values.
        //
        nStatus = ResUtilSetPropertyParameterBlockEx(
                        pResourceEntry->hkeyParameters,
                        DhcpResourcePrivateProperties,
                        NULL,
                        reinterpret_cast< LPBYTE >( &props ),
                        pInBuffer,
                        cbInBufferSize,
                        TRUE, // bForceWrite
                        reinterpret_cast< LPBYTE >( &pResourceEntry->props )
                        );

        //
        // If the resource is online, return a non-success status.
        //
        // TODO: Modify the code below if your resource can handle
        // changes to properties while it is still online.
        if ( nStatus == ERROR_SUCCESS )
        {
            if ( pResourceEntry->state == ClusterResourceOnline )
            {
                nStatus = ERROR_RESOURCE_PROPERTIES_STORED;
            } // if: resource is currently online
            else if ( pResourceEntry->state == ClusterResourceOnlinePending )
            {
                nStatus = ERROR_RESOURCE_PROPERTIES_STORED;
            } // else if: resource is currently in online pending
            else
            {
                nStatus = ERROR_SUCCESS;
            } // else: resource is in some other state
        } // if: properties set successfully
    } while ( 0 );

    ResUtilFreeParameterBlock(
        reinterpret_cast< LPBYTE >( &props ),
        reinterpret_cast< LPBYTE >( &pResourceEntry->props ),
        DhcpResourcePrivateProperties
        );

    return nStatus;

} //*** DhcpSetPrivateResProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpZapSystemRegistry
//
//  Description:
//      Zap the values in the system registry used by the service with
//      cluster properties.
//
//  Arguments:
//
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//      pProps [IN]
//          Parameter block containing properties with which to zap the
//          registry.
//
//      hkeyParametersKey [IN]
//          Service Parameters key.  Can be specified as NULL.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpZapSystemRegistry(
    IN  PDHCP_RESOURCE  pResourceEntry,
    IN  PDHCP_PROPS     pProps,
    IN  HKEY            hkeyParametersKey
    )
{
    DWORD   nStatus;
    DWORD   dwLen;
    HKEY    hkeyParamsKey = hkeyParametersKey;
    LPWSTR  pszValue = NULL;

    do {
        if ( hkeyParametersKey == NULL )
        {
            //
            // Open the service Parameters key
            //
            nStatus = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            DHCP_PARAMS_REGKEY,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hkeyParamsKey
                            );
            if ( nStatus != ERROR_SUCCESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Unable to open the DHCPServer Parameters key. Error %1!u!.\n",
                    nStatus
                    );
                break;
            } // if: error opening the registry key
        } // if: no registry key specified

        //
        // Make sure the path has a trailing backslash
        //
        dwLen = lstrlenW( pProps->pszDatabasePath );
        if ( pProps->pszDatabasePath[ dwLen - 1 ] != L'\\' )
        {
            pszValue = reinterpret_cast< LPWSTR > ( LocalAlloc( LMEM_FIXED, ( dwLen + 1 + 1 ) * sizeof( *pszValue ) ) );
            if ( pszValue == NULL )
            {
                nStatus = GetLastError( );
                break;

            } // if: alloc failed

            wcscpy( pszValue, pProps->pszDatabasePath );
            wcscat( pszValue, L"\\" );

        } // if: missing backslash

        //
        // Set the database path in the system registry.
        //
        nStatus = RegSetValueEx(
                        hkeyParamsKey,
                        DHCP_DATABASEPATH_REGVALUE,
                        0,
                        REG_EXPAND_SZ,
                        reinterpret_cast< PBYTE >( ( pszValue != NULL ? pszValue : pProps->pszDatabasePath ) ),
                        ( lstrlenW( ( pszValue != NULL ? pszValue : pProps->pszDatabasePath ) ) + 1) * sizeof( WCHAR )
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to set the DHCPServer '%1!ls!' value in the system registry to '%2!ls!'. Error %3!u!.\n",
                DHCP_DATABASEPATH_REGVALUE,
                ( pszValue != NULL ? pszValue : pProps->pszDatabasePath ),
                nStatus
                );
            break;
        } // if: error setting the database path in the registry

        LocalFree( pszValue );
        pszValue = NULL;

        //
        // Make sure the path has a trailing backslash
        //
        dwLen = lstrlenW( pProps->pszLogFilePath );
        if ( pProps->pszLogFilePath[ dwLen - 1 ] != L'\\' )
        {
            pszValue = reinterpret_cast< LPWSTR > ( LocalAlloc( LMEM_FIXED, ( dwLen + 1 + 1 ) * sizeof( *pszValue ) ) );
            if ( pszValue == NULL )
            {
                nStatus = GetLastError( );
                break;

            } // if: alloc failed

            wcscpy( pszValue, pProps->pszLogFilePath );
            wcscat( pszValue, L"\\" );

        } // if: missing backslash

        //
        // Set the log file path in the system registry.
        //
        nStatus = RegSetValueEx(
                        hkeyParamsKey,
                        DHCP_LOGFILEPATH_REGVALUE,
                        0,
                        REG_EXPAND_SZ,
                        reinterpret_cast< PBYTE >( ( pszValue != NULL ? pszValue : pProps->pszLogFilePath ) ),
                        (lstrlenW( ( pszValue != NULL ? pszValue : pProps->pszLogFilePath ) ) + 1) * sizeof( WCHAR )
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to set the DHCPServer '%1!ls!' value in the system registry to '%2!ls!'. Error %3!u!.\n",
                DHCP_LOGFILEPATH_REGVALUE,
                ( pszValue != NULL ? pszValue : pProps->pszLogFilePath ),
                nStatus
                );
            break;
        } // if: error setting the log file path in the registry

        LocalFree( pszValue );
        pszValue = NULL;

        //
        // Make sure the path has a trailing backslash
        //
        dwLen = lstrlenW( pProps->pszBackupPath );
        if ( pProps->pszBackupPath[ dwLen - 1 ] != L'\\' )
        {
            pszValue = reinterpret_cast< LPWSTR > ( LocalAlloc( LMEM_FIXED, ( dwLen + 1 + 1 ) * sizeof( *pszValue ) ) );
            if ( pszValue == NULL )
            {
                nStatus = GetLastError( );
                break;

            } // if: alloc failed

            wcscpy( pszValue, pProps->pszBackupPath );
            wcscat( pszValue, L"\\" );

        } // if: missing backslash

        //
        // Set the backup database path in the system registry.
        //
        nStatus = RegSetValueEx(
                        hkeyParamsKey,
                        DHCP_BACKUPPATH_REGVALUE,
                        0,
                        REG_EXPAND_SZ,
                        reinterpret_cast< PBYTE >( ( pszValue != NULL ? pszValue : pProps->pszBackupPath ) ),
                        ( lstrlenW( ( pszValue != NULL ? pszValue : pProps->pszBackupPath ) ) + 1) * sizeof( WCHAR )
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to set the DHCPServer '%1!ls!' value in the system registry to '%2!ls!'. Error %3!u!.\n",
                DHCP_BACKUPPATH_REGVALUE,
                ( pszValue != NULL ? pszValue : pProps->pszBackupPath ),
                nStatus
                );
            break;
        } // if: error setting the backup database path in the registry

        LocalFree( pszValue );
        pszValue = NULL;

        //
        // Set the cluster resource name in the system registry.
        //
        nStatus = RegSetValueEx(
                        hkeyParamsKey,
                        DHCP_CLUSRESNAME_REGVALUE,
                        0,
                        REG_SZ,
                        reinterpret_cast< PBYTE >( pResourceEntry->pszResourceName ),
                        (lstrlenW( pResourceEntry->pszResourceName ) + 1) * sizeof( WCHAR )
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to set the DHCPServer '%1!ls!' value in the system registry to '%2!ls!'. Error %3!u!.\n",
                DHCP_CLUSRESNAME_REGVALUE,
                pResourceEntry->pszResourceName,
                nStatus
                );
            break;
        } // if: error setting the cluster resource name in the registry

    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hkeyParamsKey != hkeyParametersKey )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: we opened the registry key

    if ( pszValue != NULL )
    {
        LocalFree( pszValue );

    } //:if: allocated memory

    return nStatus;

} //*** DhcpZapSystemRegistry()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpGetDefaultPropertyValues
//
//  Description:
//      If any of the properties are not set, use the values from the
//      system registry as default values.
//
//  Arguments:
//      pResourceEntry [IN]
//          Supplies the resource entry on which to operate.
//
//      pProps [IN OUT]
//          Parameter block containing properties to set defaults in.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpGetDefaultPropertyValues(
    IN      PDHCP_RESOURCE  pResourceEntry,
    IN OUT  PDHCP_PROPS     pProps
    )
{
    DWORD   nStatus = ERROR_SUCCESS;
    DWORD   nType;
    DWORD   cbValue = 0;
    HKEY    hkeyParamsKey = NULL;
    LPWSTR  pszValue = NULL;

    do
    {
        if (    ( pProps->pszDatabasePath == NULL )
            ||  ( *pProps->pszDatabasePath == L'\0' )
            ||  ( pProps->pszBackupPath == NULL )
            ||  ( *pProps->pszBackupPath == L'\0' )
            )
        {
            //
            // Open the service Parameters key
            //
            nStatus = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            DHCP_PARAMS_REGKEY,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hkeyParamsKey
                            );
            if ( nStatus != ERROR_SUCCESS )
            {
                (g_pfnLogEvent)(
                    pResourceEntry->hResourceHandle,
                    LOG_ERROR,
                    L"Unable to open the DHCPServer Parameters key. Error %1!u!.\n",
                    nStatus
                    );
                break;
            } // if: error opening the Parameters key

            ///////////////////
            // DATABASE PATH //
            ///////////////////
            if (    ( pProps->pszDatabasePath == NULL )
                ||  ( *pProps->pszDatabasePath == L'\0' )
                )
            {
                //
                // Get the database path from the system registry.
                //
                nStatus = RegQueryValueEx(
                                hkeyParamsKey,
                                DHCP_DATABASEPATH_REGVALUE,
                                NULL,               // Reserved
                                &nType,
                                NULL,               // lpbData
                                &cbValue
                                );
                if (    ( nStatus == ERROR_SUCCESS )
                    ||  ( nStatus == ERROR_MORE_DATA )
                    )
                {
                    //
                    // Value was found.
                    //
                    pszValue = static_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
                    if ( pszValue == NULL )
                    {
                        nStatus = GetLastError();
                        break;
                    } // if: error allocating memory
                    nStatus = RegQueryValueEx(
                                    hkeyParamsKey,
                                    DHCP_DATABASEPATH_REGVALUE,
                                    NULL,               // Reserved
                                    &nType,
                                    reinterpret_cast< PUCHAR >( pszValue ),
                                    &cbValue
                                    );
                } // if: value size read successfully
                if ( nStatus != ERROR_SUCCESS )
                {
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_ERROR,
                        L"Unable to get the DHCPServer '%1!ls!' value from the system registry. Error %2!u!.\n",
                        DHCP_DATABASEPATH_REGVALUE,
                        nStatus
                        );
                    //
                    // If value not found, don't exit so we can look for the
                    // backup database path value.
                    //
                    if ( nStatus != ERROR_FILE_NOT_FOUND )
                    {
                        break;
                    } // if: error other than value not found occurred
                    LocalFree( pszValue );
                    pszValue = NULL;
                } // if: error reading the value
                else
                {
                    LocalFree( pProps->pszDatabasePath );
                    pProps->pszDatabasePath = pszValue;
                    pszValue = NULL;
                } // else: no error reading the value
            } // if: value for DatabasePath not found yet

            ///////////////////
            // LOG FILE PATH //
            ///////////////////
            if (    ( pProps->pszLogFilePath == NULL )
                ||  ( *pProps->pszLogFilePath == L'\0' )
                )
            {
                //
                // Get the log file path from the system registry.
                //
                nStatus = RegQueryValueEx(
                                hkeyParamsKey,
                                DHCP_LOGFILEPATH_REGVALUE,
                                NULL,               // Reserved
                                &nType,
                                NULL,               // lpbData
                                &cbValue
                                );
                if (    ( nStatus == ERROR_SUCCESS )
                    ||  ( nStatus == ERROR_MORE_DATA )
                    )
                {
                    //
                    // Value was found.
                    //
                    pszValue = static_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
                    if ( pszValue == NULL )
                    {
                        nStatus = GetLastError();
                        break;
                    } // if: error allocating memory
                    nStatus = RegQueryValueEx(
                                    hkeyParamsKey,
                                    DHCP_LOGFILEPATH_REGVALUE,
                                    NULL,               // Reserved
                                    &nType,
                                    reinterpret_cast< PUCHAR >( pszValue ),
                                    &cbValue
                                    );
                } // if: value size read successfully
                if ( nStatus != ERROR_SUCCESS )
                {
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_ERROR,
                        L"Unable to get the DHCPServer '%1!ls!' value from the system registry. Error %2!u!.\n",
                        DHCP_LOGFILEPATH_REGVALUE,
                        nStatus
                        );
                    //
                    // If value not found, don't exit so we can look for the
                    // backup database path value.
                    //
                    if ( nStatus != ERROR_FILE_NOT_FOUND )
                    {
                        break;
                    } // if: error other than value not found occurred
                } // if: error reading the value
                LocalFree( pProps->pszLogFilePath );
                pProps->pszLogFilePath = pszValue;
                pszValue = NULL;
            } // if: value for LogFilePath not found yet

            /////////////////
            // BACKUP PATH //
            /////////////////
            if (    ( pProps->pszBackupPath == NULL )
                ||  ( *pProps->pszBackupPath == L'\0' )
                )
            {
                //
                // Get the backup database path from the system registry.
                //
                nStatus = RegQueryValueEx(
                                hkeyParamsKey,
                                DHCP_BACKUPPATH_REGVALUE,
                                NULL,               // Reserved
                                &nType,
                                NULL,               // lpbData
                                &cbValue
                                );
                if (    ( nStatus == ERROR_SUCCESS )
                    ||  ( nStatus == ERROR_MORE_DATA )
                    )
                {
                    //
                    // Value was found.
                    //
                    pszValue = static_cast< LPWSTR >( LocalAlloc( LMEM_FIXED, cbValue ) );
                    if ( pszValue == NULL )
                    {
                        nStatus = GetLastError();
                        break;
                    } // if: error allocating memory
                    nStatus = RegQueryValueEx(
                                    hkeyParamsKey,
                                    DHCP_BACKUPPATH_REGVALUE,
                                    NULL,               // Reserved
                                    &nType,
                                    reinterpret_cast< PUCHAR >( pszValue ),
                                    &cbValue
                                    );
                } // if: value size read successfully
                if ( nStatus != ERROR_SUCCESS )
                {
                    (g_pfnLogEvent)(
                        pResourceEntry->hResourceHandle,
                        LOG_ERROR,
                        L"Unable to get the DHCPServer '%1!ls!' value from the system registry. Error %2!u!.\n",
                        DHCP_BACKUPPATH_REGVALUE,
                        nStatus
                        );
                    break;
                } // if: error reading the value
                LocalFree( pProps->pszBackupPath );
                pProps->pszBackupPath = pszValue;
                pszValue = NULL;
            } // if: value for BackupPath not found yet
        } // if: some value not found yet
    } while ( 0 );

    LocalFree( pszValue );
    if ( hkeyParamsKey != NULL )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: we opened the Parameters key

    //
    // If a key or value wasn't found, treat it as a success.
    //
    if ( nStatus == ERROR_FILE_NOT_FOUND )
    {
        nStatus = ERROR_SUCCESS;
    } // if: couldn't find one of the values

    return nStatus;

} //*** DhcpGetDefaultPropertyValues()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpDeleteResourceHandler
//
//  Description:
//      Handle the CLUSCTL_RESOURCE_DELETE control code by restoring the
//      system registry parameters to their former values.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpDeleteResourceHandler( IN OUT PDHCP_RESOURCE pResourceEntry )
{
    DWORD   nRetStatus;
    DWORD   nStatus;
    HKEY    hkeyParamsKey = NULL;

    // Loop to avoid goto's.
    do
    {
        //
        // Open the service Parameters key
        //
        nRetStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        DHCP_PARAMS_REGKEY,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkeyParamsKey
                        );
        if ( nRetStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to open the DHCPServer Parameters key. Error %1!u!.\n",
                nRetStatus
                );
            break;
        } // if: error opening the registry key

        //
        // Set the database path in the system registry.
        //
        nStatus = RegSetValueEx(
                        hkeyParamsKey,
                        DHCP_DATABASEPATH_REGVALUE,
                        0,
                        REG_EXPAND_SZ,
                        reinterpret_cast< PBYTE >( PROP_DEFAULT__DATABASEPATH ),
                        sizeof( PROP_DEFAULT__DATABASEPATH )
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to set the DHCPServer '%1!ls!' value in the system registry to '%2!ls!'. Error %3!u!.\n",
                DHCP_DATABASEPATH_REGVALUE,
                PROP_DEFAULT__DATABASEPATH,
                nStatus
                );
            if ( nRetStatus == ERROR_SUCCESS )
            {
                nRetStatus = nStatus;
            }
        } // if: error setting the database path in the registry

        //
        // Delete the log file path in the system registry.
        //
        nStatus = RegDeleteValue(
                        hkeyParamsKey,
                        DHCP_LOGFILEPATH_REGVALUE
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to delete the DHCPServer '%1!ls!' value in the system registry. Error %2!u!.\n",
                DHCP_LOGFILEPATH_REGVALUE,
                nStatus
                );
            if ( nRetStatus == ERROR_SUCCESS )
            {
                nRetStatus = nStatus;
            }
        } // if: error deleting the log file path in the registry

        //
        // Set the backup database path in the system registry.
        //
        nStatus = RegSetValueEx(
                        hkeyParamsKey,
                        DHCP_BACKUPPATH_REGVALUE,
                        0,
                        REG_EXPAND_SZ,
                        reinterpret_cast< PBYTE >( PROP_DEFAULT__BACKUPPATH ),
                        sizeof( PROP_DEFAULT__BACKUPPATH )
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to set the DHCPServer '%1!ls!' value in the system registry to '%2!ls!'. Error %3!u!.\n",
                DHCP_BACKUPPATH_REGVALUE,
                PROP_DEFAULT__BACKUPPATH,
                nStatus
                );
            if ( nRetStatus == ERROR_SUCCESS )
            {
                nRetStatus = nStatus;
            }
        } // if: error setting the backup database path in the registry

        //
        // Delete the cluster resource name in the system registry.
        //
        nStatus = RegDeleteValue(
                        hkeyParamsKey,
                        DHCP_CLUSRESNAME_REGVALUE
                        );
        if ( nStatus != ERROR_SUCCESS )
        {
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Unable to delete the DHCPServer '%1!ls!' value in the system registry. Error %2!u!.\n",
                DHCP_LOGFILEPATH_REGVALUE,
                nStatus
                );
            if ( nRetStatus == ERROR_SUCCESS )
            {
                nRetStatus = nStatus;
            }
        } // if: error deleting the cluster resource name in the registry

    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hkeyParamsKey != NULL )
    {
        RegCloseKey( hkeyParamsKey );
    } // if: we opened the registry key

    return nRetStatus;

} //*** DhcpDeleteResourceHandler()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  DhcpSetNameHandler
//
//  Description:
//      Handle the CLUSCTL_RESOURCE_SET_NAME control code by saving the new
//      name of the resource.
//
//  Arguments:
//      pResourceEntry [IN OUT]
//          Supplies the resource entry on which to operate.
//
//      pszName [IN]
//          The new name of the resource.
//
//  Return Value:
//      ERROR_SUCCESS
//          The function completed successfully.
//
//      Win32 error code
//          The function failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD DhcpSetNameHandler(
    IN OUT  PDHCP_RESOURCE  pResourceEntry,
    IN      LPWSTR          pszName
    )
{
    DWORD   nStatus = ERROR_SUCCESS;

    // Loop to avoid goto's.
    do
    {
        //
        // Save the name of the resource.
        //
        LocalFree( pResourceEntry->pszResourceName );
        pResourceEntry->pszResourceName = static_cast< LPWSTR >(
            LocalAlloc( LMEM_FIXED, (lstrlenW( pszName ) + 1) * sizeof( WCHAR ) )
            );
        if ( pResourceEntry->pszResourceName == NULL )
        {
            nStatus = GetLastError();
            (g_pfnLogEvent)(
                pResourceEntry->hResourceHandle,
                LOG_ERROR,
                L"Failed to allocate memory for the new resource name '%1!ls!'. Error %2!u!.\n",
                pszName,
                nStatus
                );
            break;
        } // if: error allocating memory for the name.
        lstrcpyW( pResourceEntry->pszResourceName, pszName );

        //
        // Write cluster properties to the system registry.
        //
        nStatus = DhcpZapSystemRegistry( pResourceEntry, &pResourceEntry->props, NULL );
        if ( nStatus != ERROR_SUCCESS )
        {
            break;
        } // if: error zapping the WINS registry

    } while ( 0 );

    return nStatus;

} //*** DhcpSetNameHandler()

/////////////////////////////////////////////////////////////////////////////
//
// Define Function Table
//
/////////////////////////////////////////////////////////////////////////////

CLRES_V1_FUNCTION_TABLE(
    g_DhcpFunctionTable,    // Name
    CLRES_VERSION_V1_00,    // Version
    Dhcp,                   // Prefix
    NULL,                   // Arbitrate
    NULL,                   // Release
    DhcpResourceControl,    // ResControl
    DhcpResourceTypeControl // ResTypeControl
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\mgmt\inc\proplistsrc.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997-2000 Microsoft Corporation
//
//  Module Name:
//      PropList.cpp
//
//  Description:
//      Implementation of the CClusPropList class.
//
//  Documentation:
//
//  Header File:
//      PropList.h
//
//  Maintained By:
//      Galen Barbee (GalenB) 31-MAY-2000
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

const int BUFFER_GROWTH_FACTOR = 256;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CchMultiSz
//
//  Description:
//      Length of all of the substrings of a multisz string minus the final NULL.
//
//      (i.e., includes the nulls of the substrings, excludes the final null)
//      multiszlen( "abcd\0efgh\0\0" => 5 + 5 = 10
//
//  Arguments:
//      psz     [IN] The string to get the length of.
//
//  Return Value:
//      Count of characters in the multisz or 0 if empty.
//
//--
/////////////////////////////////////////////////////////////////////////////
static size_t CchMultiSz(
    IN LPCWSTR psz
    )
{
    Assert( psz != NULL );

    size_t  _cchTotal = 0;
    size_t  _cchChars;

    while ( *psz != L'\0' )
    {
        _cchChars = lstrlenW( psz ) + 1;

        _cchTotal += _cchChars;
        psz += _cchChars;
    } // while: pointer not stopped on EOS

    return _cchTotal;

} //*** CchMultiSz

/////////////////////////////////////////////////////////////////////////////
//++
//
//  NCompareMultiSz
//
//  Description:
//      Compare two MULTI_SZ buffers.
//
//  Arguments:
//      pszSource   [IN] The source string.
//      pszTarget   [IN] The target string.
//
//  Return Value:
//      If the string pointed to by pszSource is less than the string pointed
//      to by pszTarget, the return value is negative. If the string pointed
//      to by pszSource is greater than the string pointed to by pszTarget,
//      the return value is positive. If the strings are equal, the return value
//      is zero.
//
//--
/////////////////////////////////////////////////////////////////////////////
static int NCompareMultiSz(
    IN LPCWSTR pszSource,
    IN LPCWSTR pszTarget
    )
{
    Assert( pszSource != NULL );
    Assert( pszTarget != NULL );

    while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') )
    {
        //
        // Move to end of strings.
        //
        while ( ( *pszSource != L'\0' ) && ( *pszTarget != L'\0') && ( *pszSource == *pszTarget ) )
        {
            ++pszSource;
            ++pszTarget;
        } // while: pointer not stopped on EOS

        //
        // If strings are the same, skip past terminating NUL.
        // Otherwise exit the loop.
        if ( ( *pszSource == L'\0' ) && ( *pszTarget == L'\0') )
        {
            ++pszSource;
            ++pszTarget;
        } // if: both stopped on EOS
        else
        {
            break;
        } // else: stopped because something is not equal -- wr are done.

    } // while: pointer not stopped on EOS

    return *pszSource - *pszTarget;

} //*** NCompareMultiSz()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropValueList class
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScMoveToFirstValue
//
//  Description:
//      Move the cursor to the first value in the value list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS   Position moved to the first value successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScMoveToFirstValue( void )
{
    Assert( m_cbhValueList.pb != NULL );

    DWORD   _sc;

    m_cbhCurrentValue = m_cbhValueList;
    m_cbDataLeft = m_cbDataSize;
    m_bAtEnd = FALSE;

    if ( m_cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
    {
        _sc = ERROR_NO_MORE_ITEMS;
    } // if: no items in the value list
    else
    {
        _sc = ERROR_SUCCESS;
    } // else: items exist in the value list

    return _sc;

} //*** CClusPropValueList::ScMoveToFirstValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScMoveToNextValue
//
//  Description:
//      Move the cursor to the next value in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Position moved to the next value successfully.
//      ERROR_NO_MORE_ITEMS Already at the end of the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScMoveToNextValue( void )
{
    Assert( m_cbhCurrentValue.pb != NULL );

    DWORD                   _sc     = ERROR_NO_MORE_ITEMS;
    DWORD                   _cbDataSize;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;

    _cbhCurrentValue = m_cbhCurrentValue;

    do
    {
        //
        // Don't try to move if we're already at the end.
        //
        if ( m_bAtEnd )
        {
            break;
        } // if: already at the end of the list

        //
        // Make sure the buffer is big enough for the value header.
        //
        if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Calculate how much to advance buffer pointer.
        //
        _cbDataSize = sizeof( *_cbhCurrentValue.pValue )
                    + ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

        //
        // Make sure the buffer is big enough for the value header,
        // the data itself, and the endmark.
        //
        if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Move past the current value to the next value's syntax.
        //
        _cbhCurrentValue.pb += _cbDataSize;

        //
        // This test will ensure that the value is always valid since we won't
        // advance if the next thing is the endmark.
        //
        if ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
        {
            m_cbhCurrentValue = _cbhCurrentValue;
            m_cbDataLeft -= _cbDataSize;
            _sc = ERROR_SUCCESS;
        } // if: next value's syntax is not the endmark
        else
        {
            m_bAtEnd = TRUE;
        } // else: next value's syntax is the endmark
    } while ( 0 );

    return _sc;

} //*** CClusPropValueList::ScMoveToNextValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScCheckIfAtLastValue
//
//  Description:
//      Indicate whether we are on the last value in the list or not.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Not currently at the last value in the list.
//      ERROR_NO_MORE_ITEMS Currently at the last value in the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScCheckIfAtLastValue( void )
{
    Assert( m_cbhCurrentValue.pb != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;
    DWORD                   _cbDataSize;

    _cbhCurrentValue = m_cbhCurrentValue;

    do
    {
        //
        // Don't try to recalculate if we already know
        // we're at the end of the list.
        //
        if ( m_bAtEnd )
        {
            break;
        } // if: already at the end of the list

        //
        // Make sure the buffer is big enough for the value header.
        //
        if ( m_cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Calculate how much to advance buffer pointer.
        //
        _cbDataSize = sizeof( *_cbhCurrentValue.pValue )
                    + ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );

        //
        // Make sure the buffer is big enough for the value header,
        // the data itself, and the endmark.
        //
        if ( m_cbDataLeft < _cbDataSize + sizeof( CLUSPROP_SYNTAX ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Move past the current value to the next value's syntax.
        //
        _cbhCurrentValue.pb += _cbDataSize;

        //
        // We are on the last value if the next thing after this value
        // is an endmark.
        //
        if ( _cbhCurrentValue.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK )
        {
            _sc = ERROR_NO_MORE_ITEMS;
        } // if: next value's syntax is the endmark
    } while ( 0 );

    return _sc;

} //*** CClusPropValueList::ScCheckIfAtLastValue()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScAllocValueList
//
//  Description:
//      Allocate a value list buffer that's big enough to hold the next
//      value.
//
//  Arguments:
//      cbMinimum   [IN] Minimum size of the value list.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScAllocValueList( IN DWORD cbMinimum )
{
    Assert( cbMinimum > 0 );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbTotal = 0;

    //
    // Add the size of the item count and final endmark.
    //
    cbMinimum += sizeof( CLUSPROP_VALUE );
    _cbTotal = m_cbDataSize + cbMinimum;

    if ( m_cbBufferSize < _cbTotal )
    {
        PBYTE   _pbNewValuelist = NULL;

        cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
        _cbTotal = m_cbDataSize + cbMinimum;

        //
        // Allocate and zero a new buffer.
        //
        _pbNewValuelist = new BYTE[ _cbTotal ];
        if ( _pbNewValuelist != NULL )
        {
            ZeroMemory( _pbNewValuelist, _cbTotal );

            //
            // If there was a previous buffer, copy it and the delete it.
            //
            if ( m_cbhValueList.pb != NULL )
            {
                if ( m_cbDataSize != 0 )
                {
                    CopyMemory( _pbNewValuelist, m_cbhValueList.pb, m_cbDataSize );
                } // if: data already exists in buffer

                delete [] m_cbhValueList.pb;
                m_cbhCurrentValue.pb = _pbNewValuelist + (m_cbhCurrentValue.pb - m_cbhValueList.pb);
            } // if: there was a previous buffer
            else
            {
                m_cbhCurrentValue.pb = _pbNewValuelist + sizeof( DWORD ); // move past prop count
            } // else: no previous buffer

            //
            // Save the new buffer.
            //
            m_cbhValueList.pb = _pbNewValuelist;
            m_cbBufferSize = _cbTotal;
        } // if: allocation succeeded
        else
        {
            _sc = ERROR_NOT_ENOUGH_MEMORY;
        } // else: allocation failed
    } // if: buffer isn't big enough

    return _sc;

} //*** CClusPropValueList::ScAllocValueList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScGetResourceValueList
//
//  Description:
//      Get value list of a resource.
//
//  Arguments:
//      hResource       [IN] Handle for the resource to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScGetResourceValueList(
    IN HRESOURCE    hResource,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    Assert( hResource != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cb = 512;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get values.
    //
    _sc = ScAllocValueList( _cb );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterResourceControl(
                        hResource,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhValueList.pb,
                        m_cbBufferSize,
                        &_cb
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocValueList( _cb );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterResourceControl(
                                hResource,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhValueList.pb,
                                m_cbBufferSize,
                                &_cb
                                );
            } // if: ScAllocValueList succeeded
        } // if: buffer too small
    } // if: ScAllocValueList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeleteValueList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cb;
        m_cbDataLeft = _cb;
    } // else: no errors

    return _sc;

} //*** CClusPropValueList::ScGetResourceValueList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropValueList::ScGetResourceTypeValueList
//
//  Description:
//      Get value list of a resource type.
//
//  Arguments:
//      hCluster        [IN] Handle for the cluster in which the resource
//                          type resides.
//      pwszResTypeName [IN] Name of the resource type.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropValueList::ScGetResourceTypeValueList(
    IN HCLUSTER hCluster,
    IN LPCWSTR  pwszResTypeName,
    IN DWORD    dwControlCode,
    IN HNODE    hHostNode,
    IN LPVOID   lpInBuffer,
    IN DWORD    cbInBufferSize
    )
{
    Assert( hCluster != NULL );
    Assert( pwszResTypeName != NULL );
    Assert( *pwszResTypeName != L'\0' );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cb = 512;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get values.
    //
    _sc = ScAllocValueList( _cb );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterResourceTypeControl(
                        hCluster,
                        pwszResTypeName,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhValueList.pb,
                        m_cbBufferSize,
                        &_cb
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocValueList( _cb );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterResourceTypeControl(
                                hCluster,
                                pwszResTypeName,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhValueList.pb,
                                m_cbBufferSize,
                                &_cb
                                );
            } // if: ScAllocValueList succeeded
        } // if: buffer too small
    } // if: ScAllocValueList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeleteValueList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cb;
        m_cbDataLeft = _cb;
    } // else: no errors

    return _sc;

} //*** CClusPropValueList::ScGetResourceTypeValueList()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusPropList class
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScCopy
//
//  Description:
//      Copy a property list.  This function is equivalent to an assignment
//      operator.  Since this operation can fail, no assignment operator is
//      provided.
//
//  Arguments:
//      pcplPropList    [IN] The proplist to copy into this instance.
//      cbListSize      [IN] The total size of the prop list.
//
//  Return Value:
//      Win32 status code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScCopy(
    IN const PCLUSPROP_LIST pcplPropList,
    IN DWORD                cbListSize
    )
{
    Assert( pcplPropList != NULL );

    DWORD   _sc = ERROR_SUCCESS;

    //
    // Clean up any vestiges of a previous prop list.
    //
    if ( m_cbhPropList.pb != NULL )
    {
        DeletePropList();
    } // if: the current list is not empty

    //
    // Allocate the new property list buffer.  If successful,
    // copy the source list.
    //
    m_cbhPropList.pb = new BYTE[ cbListSize ];
    if ( m_cbhPropList.pb != NULL )
    {
        CopyMemory( m_cbhPropList.pList, pcplPropList, cbListSize );
        m_cbBufferSize = cbListSize;
        m_cbDataSize   = cbListSize;
        m_cbDataLeft   = cbListSize;
        _sc = ScMoveToFirstProperty();
    } // if: new succeeded
    else
    {
        _sc = ERROR_NOT_ENOUGH_MEMORY;
    } // else:

    return _sc;

} //*** CClusPropList::ScCopy()

////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScMoveToFirstProperty
//
//  Description:
//      Move the cursor to the first propery in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Position moved to the first property successfully.
//      ERROR_NO_MORE_ITEMS There are no properties in the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToFirstProperty( void )
{
    Assert( m_cbhPropList.pb != NULL );
    Assert( m_cbDataSize >= sizeof( m_cbhPropList.pList->nPropertyCount ) );

    DWORD                   _sc;
    DWORD                   _cbDataLeft;
    DWORD                   _cbDataSize;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;

    do
    {
        //
        // Make sure the buffer is big enough for the list header.
        //
        if ( m_cbDataSize < sizeof( m_cbhPropList.pList->nPropertyCount ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data

        //
        // Set the property counter to the number of properties in the list.
        //
        m_nPropsRemaining = m_cbhPropList.pList->nPropertyCount;

        //
        // Point the name pointer to the first name in the list.
        //
        m_cbhCurrentPropName.pName = &m_cbhPropList.pList->PropertyName;
        m_cbDataLeft = m_cbDataSize - sizeof( m_cbhPropList.pList->nPropertyCount );

        //
        // Check to see if there are any properties in the list.
        //
        if ( m_nPropsRemaining == 0 )
        {
            _sc = ERROR_NO_MORE_ITEMS;
            break;
        } // if: no properties in the list

        //
        // Make sure the buffer is big enough for the first property name.
        //
        if ( m_cbDataLeft < sizeof( *m_cbhCurrentPropName.pName ) )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Calculate how much to advance the buffer pointer.
        //
        _cbDataSize = sizeof( *m_cbhCurrentPropName.pName )
                    + ALIGN_CLUSPROP( m_cbhCurrentPropName.pName->cbLength );

        //
        // Make sure the buffer is big enough for the name header
        // and the data itself.
        //
        if ( m_cbDataLeft < _cbDataSize )
        {
            _sc = ERROR_INVALID_DATA;
            break;
        } // if: not enough data left

        //
        // Point the value buffer to the first value in the list.
        //
        _cbhCurrentValue.pb = m_cbhCurrentPropName.pb + _cbDataSize;
        _cbDataLeft = m_cbDataLeft - _cbDataSize;
        m_pvlValues.Init( _cbhCurrentValue, _cbDataLeft );

        //
        // Indicate we are successful.
        //
        _sc = ERROR_SUCCESS;

    } while ( 0 );

    return _sc;

} //*** CClusPropList::ScMoveToFirstProperty

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScMoveToNextProperty
//
//  Description:
//      Move the cursor to the next property in the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS       Position moved to the next property successfully.
//      ERROR_NO_MORE_ITEMS Already at the end of the list.
//      ERROR_INVALID_DATA  Not enough data in the buffer.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToNextProperty( void )
{
    Assert( m_cbhPropList.pb != NULL );
    Assert( m_pvlValues.CbhValueList().pb != NULL );

    DWORD                   _sc;
    DWORD                   _cbNameSize;
    DWORD                   _cbDataLeft;
    DWORD                   _cbDataSize;
    CLUSPROP_BUFFER_HELPER  _cbhCurrentValue;
    CLUSPROP_BUFFER_HELPER  _cbhPropName;

    _cbhCurrentValue = m_pvlValues;
    _cbDataLeft = m_pvlValues.CbDataLeft();

    //
    // If we aren't already at the last property, attempt to move to the next one.
    //
    _sc = ScCheckIfAtLastProperty();
    if ( _sc == ERROR_SUCCESS )
    {
        do
        {
            //
            // Make sure the buffer is big enough for the value header.
            //
            if ( _cbDataLeft < sizeof( *_cbhCurrentValue.pValue ) )
            {
                _sc = ERROR_INVALID_DATA;
                break;
            } // if: not enough data left

            //
            // Careful!  Add offset only to cbhCurrentValue.pb.  Otherwise
            // pointer arithmetic will give undesirable results.
            //
            while ( _cbhCurrentValue.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
            {
                //
                // Make sure the buffer is big enough for the value
                // and an endmark.
                //
                _cbDataSize = sizeof( *_cbhCurrentValue.pValue )
                            + ALIGN_CLUSPROP( _cbhCurrentValue.pValue->cbLength );
                if ( _cbDataLeft < _cbDataSize + sizeof( *_cbhCurrentValue.pSyntax ) )
                {
                    _sc = ERROR_INVALID_DATA;
                    break;
                } // if: not enough data left

                //
                // Advance past the value.
                //
                _cbhCurrentValue.pb += _cbDataSize;
                _cbDataLeft -= _cbDataSize;
            } // while: not at endmark

            if ( _sc != ERROR_SUCCESS )
            {
                break;
            } // if: error occurred in loop

            //
            // Advanced past the endmark.
            // Size check already performed in above loop.
            //
            _cbDataSize = sizeof( *_cbhCurrentValue.pSyntax );
            _cbhCurrentValue.pb += _cbDataSize;
            _cbDataLeft -= _cbDataSize;

            //
            // Point the name pointer to the next name in the list.
            //
            _cbhPropName = _cbhCurrentValue;
            Assert( _cbDataLeft == m_cbDataSize - (_cbhPropName.pb - m_cbhPropList.pb) );

            //
            // Calculate the size of the name with header.
            // Make sure the buffer is big enough for the name and an endmark.
            //
            if ( _cbDataLeft < sizeof( *_cbhPropName.pName ) )
            {
                _sc = ERROR_INVALID_DATA;
                break;
            } // if: not enough data
            _cbNameSize = sizeof( *_cbhPropName.pName )
                        + ALIGN_CLUSPROP( _cbhPropName.pName->cbLength );
            if ( _cbDataLeft < _cbNameSize + sizeof( CLUSPROP_SYNTAX ) )
            {
                _sc = ERROR_INVALID_DATA;
                break;
            } // if: not enough data

            //
            // Point the value buffer to the first value in the list.
            //
            _cbhCurrentValue.pb = _cbhPropName.pb + _cbNameSize;
            m_cbhCurrentPropName = _cbhPropName;
            m_cbDataLeft = _cbDataLeft - _cbNameSize;
            m_pvlValues.Init( _cbhCurrentValue, m_cbDataLeft );

            //
            // We've successfully advanced to the next property,
            // so there is now one fewer property remaining.
            //
            --m_nPropsRemaining;
            Assert( m_nPropsRemaining >= 1 );

            _sc = ERROR_SUCCESS;

        } while ( 0 );
    } // if: not at last property

    return _sc;

} //*** CClusPropList::ScMoveToNextProperty()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScMoveToPropertyByName
//
//  Description:
//      Find the passed in property name in the proplist.  Note that the
//      cursor is reset to the beginning at the beginning of the routine and
//      the current state of the cursor is lost.
//
//  Arguments:
//      pwszPropName    [IN] Name of the property
//
//  Return Value:
//      TRUE if the property was found, FALSE if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScMoveToPropertyByName( IN LPCWSTR pwszPropName )
{
    Assert( m_cbhPropList.pb != NULL );

    DWORD   _sc;

    _sc = ScMoveToFirstProperty();
    if ( _sc == ERROR_SUCCESS )
    {
        do
        {
            //
            // See if this is the specified property.  If so, we're done.
            //
            if ( lstrcmpiW( m_cbhCurrentPropName.pName->sz, pwszPropName ) == 0 )
            {
                break;
            } // if: property found

            //
            // Advance to the next property.
            //
            _sc = ScMoveToNextProperty();

        } while ( _sc == ERROR_SUCCESS );   // do-while: not end of list
    } // if: successfully moved to the first property

    return _sc;

} //*** ClusPropList::ScMoveToPropertyByName( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAllocPropList
//
//  Description:
//      Allocate a property list buffer that's big enough to hold the next
//      property.
//
//  Arguments:
//      cbMinimum   [IN] Minimum size of the property list.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAllocPropList( IN DWORD cbMinimum )
{
    Assert( cbMinimum > 0 );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbTotal = 0;

    //
    // Add the size of the item count and final endmark.
    //
    cbMinimum += sizeof( CLUSPROP_VALUE );
    _cbTotal = m_cbDataSize + cbMinimum;

    if ( m_cbBufferSize < _cbTotal )
    {
        PBYTE   _pbNewProplist = NULL;

        cbMinimum = max( BUFFER_GROWTH_FACTOR, cbMinimum );
        _cbTotal = m_cbDataSize + cbMinimum;

        //
        // Allocate and zero a new buffer.
        //
        _pbNewProplist = new BYTE[ _cbTotal ];
        if ( _pbNewProplist != NULL )
        {
            ZeroMemory( _pbNewProplist, _cbTotal );

            //
            // If there was a previous buffer, copy it and the delete it.
            //
            if ( m_cbhPropList.pb != NULL )
            {
                if ( m_cbDataSize != 0 )
                {
                    CopyMemory( _pbNewProplist, m_cbhPropList.pb, m_cbDataSize );
                } // if: data already exists in buffer

                delete [] m_cbhPropList.pb;
                m_cbhCurrentProp.pb = _pbNewProplist + (m_cbhCurrentProp.pb - m_cbhPropList.pb);
            } // if: there was a previous buffer
            else
            {
                m_cbhCurrentProp.pb = _pbNewProplist + sizeof( DWORD ); // move past prop count
            } // else: no previous buffer

            //
            // Save the new buffer.
            //
            m_cbhPropList.pb = _pbNewProplist;
            m_cbBufferSize = _cbTotal;
        } // if: allocation succeeded
        else
        {
            _sc = ERROR_NOT_ENOUGH_MEMORY;
        } // else: allocation failed
    } // if: buffer isn't big enough

    return _sc;

} //*** CClusPropList::ScAllocPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Description:
//      Add a string property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pwszValue       [IN] Value of the property to set in the list.
//      pwszPrevValue   [IN] Previous value of the property.
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR  pwszName,
    IN LPCWSTR  pwszValue,
    IN LPCWSTR  pwszPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _bValuesDifferent = TRUE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_SZ            _pValue;

    if (( pwszPrevValue != NULL ) && ( lstrcmpW( pwszValue, pwszPrevValue ) == 0 ))
    {
        _bValuesDifferent = FALSE;
    } // if: we have a prev value and the values are the same

    //
    // If we should always add, or if the new value and the previous value
    // are not equal, add the property to the property list.
    //
    if ( m_bAlwaysAddProp || _bValuesDifferent )
    {
        DWORD   _cbNameSize;
        DWORD   _cbDataSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbDataSize = (lstrlenW( pwszValue ) + 1) * sizeof( WCHAR );
        _cbValueSize = sizeof( CLUSPROP_SZ )
                    + ALIGN_CLUSPROP( _cbDataSize )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pStringValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddMultiSzProp
//
//  Description:
//      Add a string property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pwszValue       [IN] Value of the property to set in the list.
//      pwszPrevValue   [IN] Previous value of the property.
//
//  Return Value:
//      ERROR_SUCCESS or other Win32 error code.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddMultiSzProp(
    IN LPCWSTR  pwszName,
    IN LPCWSTR  pwszValue,
    IN LPCWSTR  pwszPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _bValuesDifferent = TRUE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_MULTI_SZ      _pValue;

    if ( ( pwszPrevValue != NULL ) && ( NCompareMultiSz( pwszValue, pwszPrevValue ) == 0 ) )
    {
        _bValuesDifferent = FALSE;
    } // if: we have a prev value and the values are the same

    //
    // If we should always add, or if the new value and the previous value
    // are not equal, add the property to the property list.
    //
    if ( m_bAlwaysAddProp || _bValuesDifferent )
    {
        DWORD   _cbNameSize;
        DWORD   _cbDataSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbDataSize = static_cast< DWORD >( (CchMultiSz( pwszValue ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_SZ )
                    + ALIGN_CLUSPROP( _cbDataSize )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pMultiSzValue;
            CopyMultiSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddMultiSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddExpandSzProp
//
//  Description:
//      Add an EXPAND_SZ string property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pwszValue       [IN] Value of the property to set in the list.
//      pwszPrevValue   [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddExpandSzProp(
    IN LPCWSTR  pwszName,
    IN LPCWSTR  pwszValue,
    IN LPCWSTR  pwszPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    _bValuesDifferent = TRUE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_SZ            _pValue;

    if ( ( pwszPrevValue != NULL ) && ( lstrcmpW( pwszValue, pwszPrevValue ) == 0 ) )
    {
        _bValuesDifferent = FALSE;
    } // if: we have a prev value and the values are the same

    //
    // If we should always add, or if the new value and the previous value
    // are not equal, add the property to the property list.
    //
    if ( m_bAlwaysAddProp || _bValuesDifferent )
    {
        DWORD   _cbNameSize;
        DWORD   _cbDataSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbDataSize = (lstrlenW( pwszValue ) + 1) * sizeof( WCHAR );
        _cbValueSize = sizeof( CLUSPROP_SZ )
                    + ALIGN_CLUSPROP( _cbDataSize )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pStringValue;
            CopyExpandSzProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pwszValue, _cbDataSize );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddExpandSzProp( LPCWSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Description:
//      Add a DWORD property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      nValue          [IN] Value of the property to set in the list.
//      nPrevValue      [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR  pwszName,
    IN DWORD    nValue,
    IN DWORD    nPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_DWORD         _pValue;

    if ( m_bAlwaysAddProp || ( nValue != nPrevValue ) )
    {
        DWORD   _cbNameSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_DWORD )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pDwordValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( DWORD )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Description:
//      Add a LONG property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      nValue          [IN] Value of the property to set in the list.
//      nPrevValue      [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR  pwszName,
    IN LONG     nValue,
    IN LONG     nPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_LONG          _pValue;

    if ( m_bAlwaysAddProp || ( nValue != nPrevValue ) )
    {
        DWORD   _cbNameSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_LONG )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pLongValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, nValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( LONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Description:
//      Add a binary property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      pbValue         [IN] Value of the property to set in the list.
//      cbValue         [IN] Count of bytes in pbValue.
//      pbPrevValue     [IN] Previous value of the property.
//      cbPrevValue     [IN] Count of bytes in pbPrevValue.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR          pwszName,
    IN const PBYTE      pbValue,
    IN DWORD            cbValue,
    IN const PBYTE      pbPrevValue,
    IN DWORD            cbPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    BOOL                    bChanged = FALSE;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_BINARY        _pValue;

    //
    // Determine if the buffer has changed.
    //
    if ( m_bAlwaysAddProp || (cbValue != cbPrevValue) )
    {
        bChanged = TRUE;
    } // if: always adding the property or the value size changed
    else if ( ( cbValue != 0 ) && ( cbPrevValue != 0 ) )
    {
        bChanged = memcmp( pbValue, pbPrevValue, cbValue ) != 0;
    } // else if: value length changed

    if ( bChanged )
    {
        DWORD   _cbNameSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_BINARY )
                    + ALIGN_CLUSPROP( cbValue )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pBinaryValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, pbValue, cbValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScAddProp
//
//  Routine Description:
//      Add a ULONGLONG property to a property list if it has changed.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      ullValue        [IN] Value of the property to set in the list.
//      ullPrevValue    [IN] Previous value of the property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScAddProp(
    IN LPCWSTR      pwszName,
    IN ULONGLONG    ullValue,
    IN ULONGLONG    ullPrevValue
    )
{
    Assert( pwszName != NULL );

    DWORD                       _sc = ERROR_SUCCESS;
    PCLUSPROP_PROPERTY_NAME     _pName;
    PCLUSPROP_ULARGE_INTEGER    _pValue;

    if ( m_bAlwaysAddProp || ( ullValue != ullPrevValue ) )
    {
        DWORD   _cbNameSize;
        DWORD   _cbValueSize;

        //
        // Calculate sizes and make sure we have a property list.
        //
        _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                    + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
        _cbValueSize = sizeof( CLUSPROP_ULARGE_INTEGER )
                    + sizeof( CLUSPROP_SYNTAX ); // value list endmark

        _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
        if ( _sc == ERROR_SUCCESS )
        {
            //
            // Set the property name.
            //
            _pName = m_cbhCurrentProp.pName;
            CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
            m_cbhCurrentProp.pb += _cbNameSize;

            //
            // Set the property value.
            //
            _pValue = m_cbhCurrentProp.pULargeIntegerValue;
            CopyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, ullValue );
            m_cbhCurrentProp.pb += _cbValueSize;

            //
            // Increment the property count and buffer size.
            //
            m_cbhPropList.pList->nPropertyCount++;
            m_cbDataSize += _cbNameSize + _cbValueSize;
        } // if: ScAllocPropList successfully grew the proplist

    } // if: the value has changed

    return _sc;

} //*** CClusPropList::ScAddProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScSetPropToDefault
//
//  Description:
//      Add a property to the property list so that it will revert to its
//      default value.
//
//  Arguments:
//      pwszName    [IN] Name of the property.
//      cpfPropFmt  [IN] Format of property
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScSetPropToDefault(
    IN LPCWSTR                  pwszName,
    IN CLUSTER_PROPERTY_FORMAT  cpfPropFmt
    )
{
    Assert( pwszName != NULL );

    DWORD                   _sc = ERROR_SUCCESS;
    DWORD                   _cbNameSize;
    DWORD                   _cbValueSize;
    PCLUSPROP_PROPERTY_NAME _pName;
    PCLUSPROP_VALUE         _pValue;

    // Calculate sizes and make sure we have a property list.
    _cbNameSize = sizeof( CLUSPROP_PROPERTY_NAME )
                + ALIGN_CLUSPROP( (lstrlenW( pwszName ) + 1) * sizeof( WCHAR ) );
    _cbValueSize = sizeof( CLUSPROP_BINARY )
                + sizeof( CLUSPROP_SYNTAX ); // value list endmark

    _sc = ScAllocPropList( _cbNameSize + _cbValueSize );
    if ( _sc == ERROR_SUCCESS )
    {
        //
        // Set the property name.
        //
        _pName = m_cbhCurrentProp.pName;
        CopyProp( _pName, CLUSPROP_TYPE_NAME, pwszName );
        m_cbhCurrentProp.pb += _cbNameSize;

        //
        // Set the property value.
        //
        _pValue = m_cbhCurrentProp.pValue;
        CopyEmptyProp( _pValue, CLUSPROP_TYPE_LIST_VALUE, cpfPropFmt );
        m_cbhCurrentProp.pb += _cbValueSize;

        //
        // Increment the property count and buffer size.
        //
        m_cbhPropList.pList->nPropertyCount++;
        m_cbDataSize += _cbNameSize + _cbValueSize;
    } // if:

    return _sc;

} //*** CClusPropList::ScSetPropToDefault()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a string property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      psz         [IN] String to copy.
//      cbsz        [IN] Count of bytes in pwsz string.  If specified as 0,
//                      the the length will be determined by a call to strlen.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_SZ            pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LPCWSTR                  psz,
    IN size_t                   cbsz        // = 0
    )
{
    Assert( pprop != NULL );
    Assert( psz != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_SZ;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    if ( cbsz == 0 )
    {
        cbsz = (lstrlenW( psz ) + 1) * sizeof( WCHAR );
    } // if: zero size specified
    Assert( cbsz == (lstrlenW( psz ) + 1) * sizeof( WCHAR ) );
    pprop->cbLength = static_cast< DWORD >( cbsz );
    lstrcpyW( pprop->sz, psz );

    //
    // Set an endmark.
    //
    _cbhProps.pStringValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyMultiSzProp
//
//  Description:
//      Copy a MULTI_SZ string property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      psz         [IN] String to copy.
//      cbsz        [IN] Count of bytes in psz string.  If specified as 0,
//                      the the length will be determined by calls to strlen.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyMultiSzProp(
    OUT PCLUSPROP_MULTI_SZ      pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LPCWSTR                  psz,
    IN size_t                   cbsz
    )
{
    Assert( pprop != NULL );
    Assert( psz != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_MULTI_SZ;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    if ( cbsz == 0 )
    {
        cbsz = (CchMultiSz( psz ) + 1) * sizeof( WCHAR );
    } // if: zero size specified
    Assert( cbsz == (CchMultiSz( psz ) + 1) * sizeof( WCHAR ) );
    pprop->cbLength = static_cast< DWORD >( cbsz );
    CopyMemory( pprop->sz, psz, cbsz );

    //
    // Set an endmark.
    //
    _cbhProps.pMultiSzValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pMultiSzValue ) + ALIGN_CLUSPROP( cbsz );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyMultiSzProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyExpandSzProp
//
//  Description:
//      Copy an EXPAND_SZ string property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      psz         [IN] String to copy.
//      cbsz        [IN] Count of bytes in psz string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyExpandSzProp(
    OUT PCLUSPROP_SZ            pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LPCWSTR                  psz,
    IN size_t                   cbsz
    )
{
    Assert( pprop != NULL );
    Assert( psz != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_EXPAND_SZ;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    if ( cbsz == 0 )
    {
        cbsz = (lstrlenW( psz ) + 1) * sizeof( WCHAR );
    } // if: cbsz == 0
    Assert( cbsz == (lstrlenW( psz ) + 1) * sizeof( WCHAR ) );
    pprop->cbLength = static_cast< DWORD >( cbsz );
    lstrcpyW( pprop->sz, psz );

    //
    // Set an endmark.
    //
    _cbhProps.pStringValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cbsz );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyExpandSzProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a DWORD property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of DWORD.
//      nValue      [IN] Property value to copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_DWORD         pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN DWORD                    nValue
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_DWORD;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = sizeof( DWORD );
    pprop->dw = nValue;

    //
    // Set an endmark.
    //
    _cbhProps.pDwordValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pDwordValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( DWORD )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a LONG property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of LONG.
//      nValue      [IN] Property value to copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_LONG          pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN LONG                     nValue
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_LONG;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = sizeof( DWORD );
    pprop->l = nValue;

    //
    // Set an endmark.
    //
    _cbhProps.pLongValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pLongValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( LONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a ULONGLONG property to a property structure.
//
//  Arguments:
//      pprop       [OUT]   Property structure to fill.
//      proptype    [IN]    Type of LONG.
//      nValue      [IN]    Property value to copy.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_ULARGE_INTEGER    pprop,
    IN  CLUSTER_PROPERTY_TYPE       proptype,
    IN  ULONGLONG                   nValue
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_ULARGE_INTEGER;
    pprop->Syntax.wType = static_cast< WORD >( proptype );
    pprop->cbLength = sizeof( ULONGLONG );
    pprop->li.QuadPart = nValue;

    //
    // Set an endmark.
    //
    _cbhProps.pULargeIntegerValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pULargeIntegerValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( ULONGLONG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyProp
//
//  Description:
//      Copy a binary property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of string.
//      pb          [IN] Block to copy.
//      cbsz        [IN] Count of bytes in pb buffer.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyProp(
    OUT PCLUSPROP_BINARY        pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN const PBYTE              pb,
    IN size_t                   cb
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = CLUSPROP_FORMAT_BINARY;
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = static_cast< DWORD >( cb );
    if ( cb > 0 )
    {
        CopyMemory( pprop->rgb, pb, cb );
    } // if: non-zero data length

    //
    // Set an endmark.
    //
    _cbhProps.pBinaryValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pStringValue ) + ALIGN_CLUSPROP( cb );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyProp( PBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::CopyEmptyProp
//
//  Description:
//      Copy an empty property to a property structure.
//
//  Arguments:
//      pprop       [OUT] Property structure to fill.
//      cptPropType [IN] Type of property.
//      cpfPropFmt  [IN] Format of property.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusPropList::CopyEmptyProp(
    OUT PCLUSPROP_VALUE         pprop,
    IN CLUSTER_PROPERTY_TYPE    cptPropType,
    IN CLUSTER_PROPERTY_FORMAT  cptPropFmt
    )
{
    Assert( pprop != NULL );

    CLUSPROP_BUFFER_HELPER  _cbhProps;

    pprop->Syntax.wFormat = static_cast< WORD >( cptPropFmt );
    pprop->Syntax.wType = static_cast< WORD >( cptPropType );
    pprop->cbLength = 0;

    //
    // Set an endmark.
    //
    _cbhProps.pValue = pprop;
    _cbhProps.pb += sizeof( *_cbhProps.pValue );
    _cbhProps.pSyntax->dw = CLUSPROP_SYNTAX_ENDMARK;

} //*** CClusPropList::CopyEmptyProp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetNodeProperties
//
//  Description:
//      Get properties on a node.
//
//  Arguments:
//      hNode           [IN] Handle for the node to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNodeProperties(
    IN HNODE        hNode,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    Assert( hNode != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_NODE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterNodeControl(
                        hNode,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterNodeControl(
                                hNode,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                            );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetNodeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetGroupProperties
//
//  Description:
//      Get properties on a group.
//
//  Arguments:
//      hGroup          [IN] Handle for the group to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetGroupProperties(
    IN HGROUP       hGroup,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    Assert( hGroup != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_GROUP << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterGroupControl(
                        hGroup,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterGroupControl(
                                hGroup,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                                );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetGroupProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetResourceProperties
//
//  Description:
//      Get properties on a resource.
//
//  Arguments:
//      hResource       [IN] Handle for the resource to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetResourceProperties(
    IN HRESOURCE    hResource,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    Assert( hResource != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_RESOURCE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterResourceControl(
                        hResource,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterResourceControl(
                                hResource,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                                );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetResourceProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetResourceTypeProperties
//
//  Description:
//      Get properties on a resource type.
//
//  Arguments:
//      hCluster        [IN] Handle for the cluster in which the resource
//                          type resides.
//      pwszResTypeName [IN] Name of the resource type.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetResourceTypeProperties(
    IN HCLUSTER     hCluster,
    IN LPCWSTR      pwszResTypeName,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    Assert( hCluster != NULL );
    Assert( pwszResTypeName != NULL );
    Assert( *pwszResTypeName != L'\0' );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_RESOURCE_TYPE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterResourceTypeControl(
                        hCluster,
                        pwszResTypeName,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterResourceTypeControl(
                                hCluster,
                                pwszResTypeName,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                                );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetResourceTypeProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetNetworkProperties
//
//  Description:
//      Get properties on a network.
//
//  Arguments:
//      hNetwork        [IN] Handle for the network to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNetworkProperties(
    IN HNETWORK     hNetwork,
    IN DWORD        dwControlCode,
    IN HNODE        hHostNode,
    IN LPVOID       lpInBuffer,
    IN DWORD        cbInBufferSize
    )
{
    Assert( hNetwork != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_NETWORK << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc = ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterNetworkControl(
                        hNetwork,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterNetworkControl(
                                hNetwork,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                                );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting private properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetNetworkProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetNetInterfaceProperties
//
//  Description:
//      Get properties on a network interface.
//
//  Arguments:
//      hNetInterface   [IN] Handle for the network interface to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetNetInterfaceProperties(
    IN HNETINTERFACE    hNetInterface,
    IN DWORD            dwControlCode,
    IN HNODE            hHostNode,
    IN LPVOID           lpInBuffer,
    IN DWORD            cbInBufferSize
    )
{
    Assert( hNetInterface != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_NETINTERFACE << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc= ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterNetInterfaceControl(
                        hNetInterface,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterNetInterfaceControl(
                                hNetInterface,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                                );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting private properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetNetInterfaceProperties()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusPropList::ScGetClusterProperties
//
//  Description:
//      Get properties on a cluster.
//
//  Arguments:
//      hCluster        [IN] Handle for the cluster to get properties from.
//      dwControlCode   [IN] Control code for the request.
//      hHostNode       [IN] Handle for the node to direct this request to.
//                          Defaults to NULL.
//      lpInBuffer      [IN] Input buffer for the request.  Defaults to NULL.
//      cbInBufferSize  [IN] Size of the input buffer.  Defaults to 0.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusPropList::ScGetClusterProperties(
    IN HCLUSTER hCluster,
    IN DWORD    dwControlCode,
    IN HNODE    hHostNode,
    IN LPVOID   lpInBuffer,
    IN DWORD    cbInBufferSize
    )
{
    Assert( hCluster != NULL );
    Assert( (dwControlCode & (CLUSCTL_OBJECT_MASK << CLUSCTL_OBJECT_SHIFT))
            == (CLUS_OBJECT_CLUSTER << CLUSCTL_OBJECT_SHIFT) );

    DWORD   _sc= ERROR_SUCCESS;
    DWORD   _cbProps = 256;

    //
    // Overwrite anything that may be in the buffer.
    // Allows this class instance to be reused.
    //
    m_cbDataSize = 0;

    //
    // Get properties.
    //
    _sc = ScAllocPropList( _cbProps );
    if ( _sc == ERROR_SUCCESS )
    {
        _sc = ClusterControl(
                        hCluster,
                        hHostNode,
                        dwControlCode,
                        lpInBuffer,
                        cbInBufferSize,
                        m_cbhPropList.pb,
                        m_cbBufferSize,
                        &_cbProps
                        );
        if ( _sc == ERROR_MORE_DATA )
        {
            _sc = ScAllocPropList( _cbProps );
            if ( _sc == ERROR_SUCCESS )
            {
                _sc = ClusterControl(
                                hCluster,
                                hHostNode,
                                dwControlCode,
                                lpInBuffer,
                                cbInBufferSize,
                                m_cbhPropList.pb,
                                m_cbBufferSize,
                                &_cbProps
                                );
            } // if: ScAllocPropList succeeded
        } // if: buffer too small
    } // if: ScAllocPropList succeeded

    if ( _sc != ERROR_SUCCESS )
    {
        DeletePropList();
    } // if: error getting private properties.
    else
    {
        m_cbDataSize = _cbProps;
        m_cbDataLeft = _cbProps;
    } // else: no errors

    return _sc;

} //*** CClusPropList::ScGetClusterProperties()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\resdll\clnetres\clnetresex\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1999 Microsoft Corporation
//
//	Module Name:
//		BasePage.cpp
//
//	Description:
//		Implementation of the CBasePropertyPage class.
//
//	Author:
//		David Potter (DavidP)	March 24, 1999
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClNetResEx.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "BasePage.inl"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CBasePropertyPage, CPropertyPage )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CBasePropertyPage, CPropertyPage )
	//{{AFX_MSG_MAP(CBasePropertyPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage( void )
{
	CommonConstruct();

} //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		pdwHelpMap			[IN] Control-to-help ID map.
//		pdwWizardHelpMap	[IN] Control-to-help ID map if this is a wizard page.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
	IN const DWORD *	pdwHelpMap,
	IN const DWORD *	pdwWizardHelpMap
	)
	: m_dlghelp( pdwHelpMap, 0 )
{
	CommonConstruct();
	m_pdwWizardHelpMap = pdwWizardHelpMap;

} //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		idd					[IN] Dialog template resource ID.
//		pdwHelpMap			[IN] Control-to-help ID map.
//		pdwWizardHelpMap	[IN] Control-to-help ID map if this is a wizard page.
//		nIDCaption			[IN] Caption string resource ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
	IN UINT				idd,
	IN const DWORD *	pdwHelpMap,
	IN const DWORD *	pdwWizardHelpMap,
	IN UINT				nIDCaption
	)
	: CPropertyPage( idd, nIDCaption )
	, m_dlghelp( pdwHelpMap, idd )
{
	CommonConstruct();
	m_pdwWizardHelpMap = pdwWizardHelpMap;

} //*** CBasePropertyPage::CBasePropertyPage( UINT, UINT )

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CommonConstruct
//
//	Description:
//		Common construction.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::CommonConstruct( void )
{
	//{{AFX_DATA_INIT(CBasePropertyPage)
	//}}AFX_DATA_INIT

	m_peo = NULL;
	m_hpage = NULL;
	m_bBackPressed = FALSE;
	m_bSaved = FALSE;

	m_iddPropertyPage = NULL;
	m_iddWizardPage = NULL;
	m_idsCaption = NULL;

	m_pdwWizardHelpMap = NULL;

	m_bDoDetach = FALSE;

} //*** CBasePropertyPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::HrInit
//
//	Description:
//		Initialize the page.
//
//	Arguments:
//		peo			[IN OUT] Pointer to the extension object.
//
//	Return Value:
//		S_OK		Page initialized successfully.
//		hr			Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBasePropertyPage::HrInit( IN OUT CExtObject * peo )
{
	ASSERT( peo != NULL );

	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	HRESULT		_hr = S_FALSE;
	CWaitCursor	_wc;

	do
	{
		m_peo = peo;

		// Change the help map if this is a wizard page.
		if ( Peo()->BWizard() )
		{
			m_dlghelp.SetMap( m_pdwWizardHelpMap );
		} // if: in a wizard

		// Don't display a help button.
		m_psp.dwFlags &= ~PSP_HASHELP;

		// Construct the property page.
		if ( Peo()->BWizard() )
		{
			ASSERT( IddWizardPage() != NULL);
			Construct( IddWizardPage(), IdsCaption() );
			m_dlghelp.SetHelpMask( IddWizardPage() );
		} // if: adding page to wizard
		else
		{
			ASSERT( IddPropertyPage() != NULL );
			Construct( IddPropertyPage(), IdsCaption() );
			m_dlghelp.SetHelpMask( IddPropertyPage() );
		} // else: adding page to property sheet

		// Read the properties private to this resource and parse them.
		{
			DWORD			_sc = ERROR_SUCCESS;
			CClusPropList	_cpl;

			ASSERT( Peo() != NULL );
			ASSERT( Peo()->PodObjData() );

			// Read the properties.
			switch ( Cot() )
			{
				case CLUADMEX_OT_NODE:
					ASSERT( Peo()->PndNodeData()->m_hnode != NULL );
					_sc = _cpl.ScGetNodeProperties(
											Peo()->PndNodeData()->m_hnode,
											CLUSCTL_NODE_GET_PRIVATE_PROPERTIES
											);
					break;

				case CLUADMEX_OT_GROUP:
					ASSERT( Peo()->PgdGroupData()->m_hgroup != NULL );
					_sc = _cpl.ScGetGroupProperties(
											Peo()->PgdGroupData()->m_hgroup,
											CLUSCTL_GROUP_GET_PRIVATE_PROPERTIES
											);
					break;

				case CLUADMEX_OT_RESOURCE:
					ASSERT( Peo()->PrdResData()->m_hresource != NULL );
					_sc = _cpl.ScGetResourceProperties(
											Peo()->PrdResData()->m_hresource,
											CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
											);
					break;

				case CLUADMEX_OT_RESOURCETYPE:
					ASSERT( Peo()->PodObjData()->m_strName.GetLength() > 0 );
					_sc = _cpl.ScGetResourceTypeProperties(
											Hcluster(),
											Peo()->PodObjData()->m_strName,
											CLUSCTL_RESOURCE_TYPE_GET_PRIVATE_PROPERTIES
											);
					break;

				case CLUADMEX_OT_NETWORK:
					ASSERT( Peo()->PndNetworkData()->m_hnetwork != NULL );
					_sc = _cpl.ScGetNetworkProperties(
											Peo()->PndNetworkData()->m_hnetwork,
											CLUSCTL_NETWORK_GET_PRIVATE_PROPERTIES
											);
					break;

				case CLUADMEX_OT_NETINTERFACE:
					ASSERT( Peo()->PndNetInterfaceData()->m_hnetinterface != NULL );
					_sc = _cpl.ScGetNetInterfaceProperties(
											Peo()->PndNetInterfaceData()->m_hnetinterface,
											CLUSCTL_NETINTERFACE_GET_PRIVATE_PROPERTIES
											);
					break;

				default:
					ASSERT( 0 );
			} // switch: object type

			// Parse the properties.
			if ( _sc == ERROR_SUCCESS )
			{
				// Parse the properties.
				try
				{
					_sc = ScParseProperties( _cpl );
				} // try
				catch ( CMemoryException * _pme )
				{
					_hr = E_OUTOFMEMORY;
					_pme->Delete();
				} // catch: CMemoryException
			} // if: properties read successfully

			if ( _sc != ERROR_SUCCESS )
			{
				_hr = HRESULT_FROM_WIN32( _sc );
				break;
			} // if: error parsing getting or parsing properties
		} // Read the properties private to this resource and parse them
	} while ( 0 );

	return _hr;

} //*** CBasePropertyPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::HrCreatePage
//
//	Description:
//		Create the page.
//
//	Arguments:
//		None.
//
//	Return Value:
//		S_OK		Page created successfully.
//		hr			Error creating the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBasePropertyPage::HrCreatePage( void )
{
	ASSERT( m_hpage == NULL );

	HRESULT	_hr = S_OK;

	m_hpage = CreatePropertySheetPage( &m_psp );
	if ( m_hpage == NULL )
	{
		_hr = HRESULT_FROM_WIN32( GetLastError() );
	} // if: error creating the page

	return _hr;

} //*** CBasePropertyPage::HrCreatePage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::ScParseProperties
//
//	Description:
//		Parse the properties of the resource.  This is in a separate function
//		from HrInit so that the optimizer can do a better job.
//
//	Arguments:
//		rcpl			[IN] Cluster property list to parse.
//
//	Return Values:
//		ERROR_SUCCESS	Properties were parsed successfully.
//		Any error returns from ScParseUnknownProperty().
//
//	Exceptions Thrown:
//		Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScParseProperties( IN CClusPropList & rcpl )
{
	DWORD					_sc;
	DWORD					_cprop;
	const CObjectProperty *	_pprop;

	ASSERT( rcpl.PbPropList() != NULL );

	_sc = rcpl.ScMoveToFirstProperty();
	while ( _sc == ERROR_SUCCESS )
	{
		//
		// Parse known properties.
		//
		for ( _pprop = Pprops(), _cprop = Cprops() ; _cprop > 0 ; _pprop++, _cprop-- )
		{
			if ( lstrcmpiW( rcpl.PszCurrentPropertyName(), _pprop->m_pwszName ) == 0 )
			{
				if ( rcpl.CpfCurrentValueFormat() == _pprop->m_propFormat )
				{
					switch ( _pprop->m_propFormat )
					{
						case CLUSPROP_FORMAT_SZ:
						case CLUSPROP_FORMAT_EXPAND_SZ:
							ASSERT( 	(rcpl.CbCurrentValueLength() == (lstrlenW( rcpl.CbhCurrentValue().pStringValue->sz ) + 1) * sizeof( WCHAR ))
									||	(	(rcpl.CbCurrentValueLength() == 0)
										&&	(rcpl.CbhCurrentValue().pStringValue->sz[ 0 ] == L'\0') ) );
							*_pprop->m_value.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
							*_pprop->m_valuePrev.pstr = rcpl.CbhCurrentValue().pStringValue->sz;

							// See if we need to find an expanded version
							if ( _pprop->m_valueEx.pstr != NULL )
							{
								// Copy the non-expanded one just in case there isn't an expanded version
								*_pprop->m_valueEx.pstr = rcpl.CbhCurrentValue().pStringValue->sz;

								// See if they included an expanded version
								rcpl.ScMoveToNextPropertyValue( );
								if ( rcpl.CpfCurrentValueFormat( ) == CLUSPROP_FORMAT_EXPANDED_SZ )
								{
									*_pprop->m_valueEx.pstr = rcpl.CbhCurrentValue().pStringValue->sz;		  
								} // if: found expanded version

							} // if: *_pprop->m_valueEx.pstr is present
							break;
						case CLUSPROP_FORMAT_EXPANDED_SZ:
							ASSERT( 	(rcpl.CbCurrentValueLength() == (lstrlenW( rcpl.CbhCurrentValue().pStringValue->sz ) + 1) * sizeof( WCHAR ))
									||	(	(rcpl.CbCurrentValueLength() == 0)
										&&	(rcpl.CbhCurrentValue().pStringValue->sz[ 0 ] == L'\0') ) );
							*_pprop->m_value.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
							*_pprop->m_valuePrev.pstr = rcpl.CbhCurrentValue().pStringValue->sz;

							// See if we need to find an expanded version
							if ( _pprop->m_valueEx.pstr != NULL )
							{
								// Copy the expanded version
								*_pprop->m_valueEx.pstr = rcpl.CbhCurrentValue().pStringValue->sz;

								// See if they included a non-expanded version
								rcpl.ScMoveToNextPropertyValue( );
								if ( rcpl.CpfCurrentValueFormat( ) == CLUSPROP_FORMAT_SZ )
								{
									*_pprop->m_value.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
									*_pprop->m_valuePrev.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
								} // if: found non-expanded version

							} // if: *_pprop->m_valueEx.pstr is present
							break;
						case CLUSPROP_FORMAT_DWORD:
						case CLUSPROP_FORMAT_LONG:
							ASSERT( rcpl.CbCurrentValueLength() == sizeof( DWORD ) );
							*_pprop->m_value.pdw = rcpl.CbhCurrentValue().pDwordValue->dw;
							*_pprop->m_valuePrev.pdw = rcpl.CbhCurrentValue().pDwordValue->dw;
							break;
						case CLUSPROP_FORMAT_BINARY:
						case CLUSPROP_FORMAT_MULTI_SZ:
							*_pprop->m_value.ppb = rcpl.CbhCurrentValue().pBinaryValue->rgb;
							*_pprop->m_value.pcb = rcpl.CbhCurrentValue().pBinaryValue->cbLength;
							*_pprop->m_valuePrev.ppb = rcpl.CbhCurrentValue().pBinaryValue->rgb;
							*_pprop->m_valuePrev.pcb = rcpl.CbhCurrentValue().pBinaryValue->cbLength;
							break;
						default:
							ASSERT(0);	// don't know how to deal with this type
					} // switch: property format

					// Exit the loop since we found the parameter.
					break;
				}// if: found a type match

			} // if: found a string match

		} // for: each property that we know about

		//
		// If the property wasn't known, ask the derived class to parse it.
		//
		if ( _cprop == 0 )
		{
			_sc = ScParseUnknownProperty(
						rcpl.CbhCurrentPropertyName().pName->sz,
						rcpl.CbhCurrentValue(),
						rcpl.RPvlPropertyValue().CbDataLeft()
						);
			if ( _sc != ERROR_SUCCESS )
			{
				return _sc;
			} // if: error parsing the unknown property
		} // if: property not parsed

		//
		// Advance the buffer pointer past the value in the value list.
		//
		_sc = rcpl.ScMoveToNextProperty();
	} // while: more properties to parse

	//
	// If we reached the end of the properties, fix the return code.
	//
	if ( _sc == ERROR_NO_MORE_ITEMS )
	{
		_sc = ERROR_SUCCESS;
	} // if: ended loop after parsing all properties

	return _sc;

} //*** CBasePropertyPage::ScParseProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnCreate
//
//	Description:
//		Handler for the WM_CREATE message.
//
//	Arguments:
//		lpCreateStruct	[IN OUT] Window create structure.
//
//	Return Value:
//		-1		Error.
//		0		Success.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CBasePropertyPage::OnCreate( LPCREATESTRUCT lpCreateStruct )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	// Attach the window to the property page structure.
	// This has been done once already in the main application, since the
	// main application owns the property sheet.  It needs to be done here
	// so that the window handle can be found in the DLL's handle map.
	if ( FromHandlePermanent( m_hWnd ) == NULL ) // is the window handle already in the handle map
	{
		HWND _hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( _hWnd );
		m_bDoDetach = TRUE;
	} // if: is the window handle in the handle map

	return CPropertyPage::OnCreate( lpCreateStruct );

} //*** CBasePropertyPage::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnDestroy
//
//	Description:
//		Handler for the WM_DESTROY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnDestroy( void )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	// Detach the window from the property page structure.
	// This will be done again by the main application, since it owns the
	// property sheet.  It needs to be done here so that the window handle
	// can be removed from the DLL's handle map.
	if ( m_bDoDetach )
	{
		if ( m_hWnd != NULL )
		{
			HWND _hWnd = m_hWnd;

			Detach();
			m_hWnd = _hWnd;
		} // if: do we have a window handle?
	} // if: do we need to balance the attach we did with a detach?

	CPropertyPage::OnDestroy();

} //*** CBasePropertyPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::DoDataExchange
//
//	Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DoDataExchange( CDataExchange * pDX )
{
	if ( ! pDX->m_bSaveAndValidate || ! BSaved() )
	{
		AFX_MANAGE_STATE( AfxGetStaticModuleState() );

		//{{AFX_DATA_MAP(CBasePropertyPage)
			// NOTE: the ClassWizard will add DDX and DDV calls here
		//}}AFX_DATA_MAP
		DDX_Control( pDX, IDC_PP_ICON, m_staticIcon );
		DDX_Control( pDX, IDC_PP_TITLE, m_staticTitle );

		if ( pDX->m_bSaveAndValidate )
		{
			if ( ! BBackPressed() )
			{
				CWaitCursor	_wc;

				// Validate the data.
				if ( ! BSetPrivateProps( TRUE /*bValidateOnly*/ ) )
				{
					pDX->Fail();
				} // if: error setting private properties
			} // if: Back button not pressed
		} // if: saving data from dialog
		else
		{
			// Set the title.
			DDX_Text( pDX, IDC_PP_TITLE, m_strTitle );
		} // if: not saving data
	}  // if: not saving or haven't saved yet

	// Call the base class method.
	CPropertyPage::DoDataExchange( pDX );

} //*** CBasePropertyPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnInitDialog
//
//	Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnInitDialog( void )
{
	ASSERT( Peo() != NULL );
	ASSERT( Peo()->PodObjData() != NULL );

	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	// Set the title string.
	m_strTitle = Peo()->PodObjData()->m_strName;

	// Call the base class method.
	CPropertyPage::OnInitDialog();

	// Display an icon for the object.
	if ( Peo()->Hicon() != NULL )
	{
		m_staticIcon.SetIcon( Peo()->Hicon() );
	} // if: an icon was specified

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

} //*** CBasePropertyPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnSetActive
//
//	Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnSetActive( void )
{
	HRESULT		_hr;

	ASSERT( Peo() != NULL);
	ASSERT( Peo()->PodObjData() != NULL );

	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	// Reread the data.
	_hr = Peo()->HrGetObjectInfo();
	if ( _hr != NOERROR )
	{
		return FALSE;
	} // if: error getting object info

	// Set the title string.
	m_strTitle = Peo()->PodObjData()->m_strName;

	m_bBackPressed = FALSE;
	m_bSaved = FALSE;
	return CPropertyPage::OnSetActive();

} //*** CBasePropertyPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnApply
//
//	Description:
//		Handler for the PSM_APPLY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnApply( void )
{
	ASSERT( ! BWizard() );

	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	CWaitCursor	_wc;

	if ( ! BApplyChanges() )
	{
		return FALSE;
	} // if: error applying changes

	return CPropertyPage::OnApply();

} //*** CBasePropertyPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnWizardBack
//
//	Description:
//		Handler for the PSN_WIZBACK message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		-1		Don't change the page.
//		0		Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardBack( void )
{
	LRESULT		_lResult;

	ASSERT( BWizard() );

	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	_lResult = CPropertyPage::OnWizardBack();
	if ( _lResult != -1 )
	{
		m_bBackPressed = TRUE;
	} // if: no error occurred

	return _lResult;

} //*** CBasePropertyPage::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnWizardNext
//
//	Description:
//		Handler for the PSN_WIZNEXT message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		-1		Don't change the page.
//		0		Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardNext( void )
{
	ASSERT( BWizard() );

	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	CWaitCursor	_wc;

	// Update the data in the class from the page.
	// This necessary because, while OnKillActive() will call UpdateData(),
	// it is called after this method is called, and we need to be sure that
	// data has been saved before we apply them.
	if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
	{
		return -1;
	} // if: error updating data

	// Save the data in the sheet.
	if ( ! BApplyChanges() )
	{
		return -1;
	} // if: error applying changes

	// Create the object.

	return CPropertyPage::OnWizardNext();

} //*** CBasePropertyPage::OnWizardNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnWizardFinish
//
//	Description:
//		Handler for the PSN_WIZFINISH message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		FALSE	Don't change the page.
//		TRUE	Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnWizardFinish( void )
{
	ASSERT( BWizard() );

	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	CWaitCursor	_wc;

	// BUG! There should be no need to call UpdateData in this function.
	// See BUG: Finish Button Fails Data Transfer from Page to Variables
	// KB Article ID: Q150349

	// Update the data in the class from the page.
	if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
	{
		return FALSE;
	} // if: error updating data

	// Save the data in the sheet.
	if ( ! BApplyChanges() )
	{
		return FALSE;
	} // if: error applying changes

	return CPropertyPage::OnWizardFinish();

} //*** CBasePropertyPage::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::OnChangeCtrl
//
//	Description:
//		Handler for the messages sent when a control is changed.  This
//		method can be specified in a message map if all that needs to be
//		done is enable the Apply button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnChangeCtrl( void )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	SetModified( TRUE );

} //*** CBasePropertyPage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::EnableNext
//
//	Description:
//		Enables or disables the NEXT or FINISH button.
//
//	Arguments:
//		bEnable		[IN] TRUE = enable the button, FALSE = disable the button.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::EnableNext( IN BOOL bEnable /*TRUE*/ )
{
	ASSERT( BWizard() );
	ASSERT( PiWizardCallback() );

	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	PiWizardCallback()->EnableNext( reinterpret_cast< LONG * >( Hpage() ), bEnable );

} //*** CBasePropertyPage::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BApplyChanges
//
//	Description:
//		Apply changes made on the page.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BApplyChanges( void )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	CWaitCursor	_wc;

	// Save data.
	return BSetPrivateProps();

} //*** CBasePropertyPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BBuildPropList
//
//	Description:
//		Build the property list.
//
//	Arguments:
//		rcpl		[IN OUT] Cluster property list.
//		bNoNewProps	[IN] TRUE = exclude properties marked with opfNew.
//
//	Return Value:
//		TRUE		Property list built successfully.
//		FALSE		Error building property list.
//
//	Exceptions Thrown:
//		Any exceptions thrown by CClusPropList::AddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BBuildPropList(
	IN OUT CClusPropList &	rcpl,
	IN BOOL					bNoNewProps		// = FALSE
	)
{
	BOOL					_bNewPropsFound = FALSE;
	DWORD					_cprop;
	const CObjectProperty *	_pprop;

	for ( _pprop = Pprops(), _cprop = Cprops() ; _cprop > 0 ; _pprop++, _cprop-- )
	{
		if ( bNoNewProps && (_pprop->m_fFlags & CObjectProperty::opfNew) )
		{
			_bNewPropsFound = TRUE;
			continue;
		} // if: no new props allowed and this is a new property

		switch ( _pprop->m_propFormat )
		{
			case CLUSPROP_FORMAT_SZ:
				rcpl.ScAddProp(
						_pprop->m_pwszName,
						*_pprop->m_value.pstr,
						*_pprop->m_valuePrev.pstr
						);
				break;
			case CLUSPROP_FORMAT_EXPAND_SZ:
				rcpl.ScAddExpandSzProp(
						_pprop->m_pwszName,
						*_pprop->m_value.pstr,
						*_pprop->m_valuePrev.pstr
						);
				break;
			case CLUSPROP_FORMAT_DWORD:
				rcpl.ScAddProp(
						_pprop->m_pwszName,
						*_pprop->m_value.pdw,
						*_pprop->m_valuePrev.pdw
						);
				break;
			case CLUSPROP_FORMAT_LONG:
				rcpl.ScAddProp(
						_pprop->m_pwszName,
						*_pprop->m_value.pl,
						*_pprop->m_valuePrev.pl
						);
				break;
			case CLUSPROP_FORMAT_BINARY:
			case CLUSPROP_FORMAT_MULTI_SZ:
				rcpl.ScAddProp(
						_pprop->m_pwszName,
						*_pprop->m_value.ppb,
						*_pprop->m_value.pcb,
						*_pprop->m_valuePrev.ppb,
						*_pprop->m_valuePrev.pcb
						);
				break;
			default:
				ASSERT( 0 ); // don't know how to deal with this type
				return FALSE;
		} // switch: property format
	} // for: each property

	return ( ! bNoNewProps || _bNewPropsFound );

} //*** CBasePropertyPage::BBuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::BSetPrivateProps
//
//	Description:
//		Set the private properties for this object.
//
//	Arguments:
//		bValidateOnly	[IN] TRUE = only validate the data.
//		bNoNewProps		[IN] TRUE = exclude properties marked with opfNew.
//
//	Return Value:
//		ERROR_SUCCESS	The operation was completed successfully.
//		!0				Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BSetPrivateProps(
	IN BOOL bValidateOnly,	// = FALSE
	IN BOOL bNoNewProps		// = FALSE
	)
{
	BOOL			_bSuccess	= TRUE;
	CClusPropList	_cpl( BWizard() /*bAlwaysAddProp*/ );

	ASSERT( Peo() != NULL );
	ASSERT( Peo()->PrdResData() );
	ASSERT( Peo()->PrdResData()->m_hresource );

	// Build the property list.
	try
	{
		_bSuccess = BBuildPropList( _cpl, bNoNewProps );
	} // try
	catch ( CException * pe )
	{
		pe->ReportError();
		pe->Delete();
		_bSuccess = FALSE;
	} // catch: CException

	// Set the data.
	if ( _bSuccess )
	{
		if ( (_cpl.PbPropList() != NULL) && (_cpl.CbPropList() > 0) )
		{
			DWORD		_sc = ERROR_SUCCESS;
			DWORD		_dwControlCode;
			DWORD		_cbProps;

			switch ( Cot() )
			{
				case CLUADMEX_OT_NODE:
					ASSERT( Peo()->PndNodeData() != NULL );
					ASSERT( Peo()->PndNodeData()->m_hnode != NULL );

					// Determine which control code to use.
					if ( bValidateOnly )
					{
						_dwControlCode = CLUSCTL_NODE_VALIDATE_PRIVATE_PROPERTIES;
					} // if: only validating data
					else
					{
						_dwControlCode = CLUSCTL_NODE_SET_PRIVATE_PROPERTIES;
					} // else: setting data

					// Set private properties.
					_sc = ClusterNodeControl(
									Peo()->PndNodeData()->m_hnode,
									NULL,	// hNode
									_dwControlCode,
									_cpl.PbPropList(),
									_cpl.CbPropList(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&_cbProps
									);
					break;
				case CLUADMEX_OT_GROUP:
					ASSERT( Peo()->PgdGroupData() != NULL );
					ASSERT( Peo()->PgdGroupData()->m_hgroup != NULL );

					// Determine which control code to use.
					if ( bValidateOnly )
					{
						_dwControlCode = CLUSCTL_GROUP_VALIDATE_PRIVATE_PROPERTIES;
					} // if: only validating data
					else
					{
						_dwControlCode = CLUSCTL_GROUP_SET_PRIVATE_PROPERTIES;
					} // else: setting data

					// Set private properties.
					_sc = ClusterGroupControl(
									Peo()->PgdGroupData()->m_hgroup,
									NULL,	// hNode
									_dwControlCode,
									_cpl.PbPropList(),
									_cpl.CbPropList(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&_cbProps
									);
					break;
				case CLUADMEX_OT_RESOURCE:
					ASSERT( Peo()->PrdResData() != NULL );
					ASSERT( Peo()->PrdResData()->m_hresource != NULL );

					// Determine which control code to use.
					if ( bValidateOnly )
					{
						_dwControlCode = CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES;
					} // if: only validating data
					else
					{
						_dwControlCode = CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES;
					} // else: setting data

					// Set private properties.
					_sc = ClusterResourceControl(
									Peo()->PrdResData()->m_hresource,
									NULL,	// hNode
									_dwControlCode,
									_cpl.PbPropList(),
									_cpl.CbPropList(),
									NULL,	// lpOutBuffer
									0,		// nOutBufferSize
									&_cbProps
									);
					break;
				case CLUADMEX_OT_RESOURCETYPE:
					ASSERT( Peo()->PodObjData() != NULL );
					ASSERT( Peo()->PodObjData()->m_strName.GetLength() > 0 );

					// Determine which control code to use.
					if ( bValidateOnly )
					{
						_dwControlCode = CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES;
					} // if: only valid